/Users/josh/Documents/GitHub/honojs/hono/src/compose.test.ts
```typescript
import { compose } from './compose'
import { Context } from './context'
import type { Params } from './router'
import type { Next } from './types'

type MiddlewareTuple = [[Function, unknown], Params]

class ExpectedError extends Error {}

function buildMiddlewareTuple(fn: Function, params?: Params): MiddlewareTuple {
  return [[fn, undefined], params || {}]
}

describe('compose', () => {
  const middleware: MiddlewareTuple[] = []

  const a = async (c: Context, next: Next) => {
    c.set('log', 'log')
    await next()
  }

  const b = async (c: Context, next: Next) => {
    await next()
    c.header('x-custom-header', 'custom-header')
  }

  const c = async (c: Context, next: Next) => {
    c.set('xxx', 'yyy')
    await next()
    c.set('zzz', 'xxx')
  }

  const handler = async (c: Context, next: Next) => {
    c.set('log', `${c.get('log')} message`)
    await next()
    return c.json({ message: 'new response' })
  }

  middleware.push(buildMiddlewareTuple(a))
  middleware.push(buildMiddlewareTuple(b))
  middleware.push(buildMiddlewareTuple(c))
  middleware.push(buildMiddlewareTuple(handler))

  it('Request', async () => {
    const composed = compose(middleware)
    const context = await composed(new Context(new Request('http://localhost/')))
    expect(context.get('log')).not.toBeNull()
    expect(context.get('log')).toBe('log message')
    expect(context.get('xxx')).toBe('yyy')
  })
  it('Response', async () => {
    const composed = compose(middleware)
    const context = await composed(new Context(new Request('http://localhost/')))
    expect(context.res.headers.get('x-custom-header')).not.toBeNull()
    expect(context.res.headers.get('x-custom-header')).toBe('custom-header')
    expect((await context.res.json())['message']).toBe('new response')
    expect(context.get('zzz')).toBe('xxx')
  })
})

describe('compose with returning a promise, non-async function', () => {
  const handlers: MiddlewareTuple[] = [
    buildMiddlewareTuple(() => {
      return new Promise((resolve) =>
        setTimeout(() => {
          resolve(
            new Response(JSON.stringify({ message: 'new response' }), {
              headers: {
                'Content-Type': 'application/json',
              },
            })
          )
        })
      )
    }),
  ]

  it('Response', async () => {
    const composed = compose(handlers)
    const context = await composed(new Context(new Request('http://localhost/')))
    expect((await context.res.json())['message']).toBe('new response')
  })
})

describe('Handler and middlewares', () => {
  const middleware: MiddlewareTuple[] = []

  const req = new Request('http://localhost/')
  const c: Context = new Context(req)

  const mHandlerFoo = async (c: Context, next: Next) => {
    c.req.raw.headers.append('x-header-foo', 'foo')
    await next()
  }

  const mHandlerBar = async (c: Context, next: Next) => {
    await next()
    c.header('x-header-bar', 'bar')
  }

  const handler = (c: Context) => {
    const foo = c.req.header('x-header-foo') || ''
    return c.text(foo)
  }

  middleware.push(buildMiddlewareTuple(mHandlerFoo))
  middleware.push(buildMiddlewareTuple(mHandlerBar))
  middleware.push(buildMiddlewareTuple(handler))

  it('Should return 200 Response', async () => {
    const composed = compose(middleware)
    const context = await composed(c)
    const res = context.res
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('foo')
    expect(res.headers.get('x-header-bar')).toBe('bar')
  })
})

describe('compose with Context - 200 success', () => {
  const middleware: MiddlewareTuple[] = []

  const req = new Request('http://localhost/')
  const c: Context = new Context(req)
  const handler = (c: Context) => {
    return c.text('Hello')
  }
  const mHandler = async (_c: Context, next: Next) => {
    await next()
  }

  middleware.push(buildMiddlewareTuple(handler))
  middleware.push(buildMiddlewareTuple(mHandler))

  it('Should return 200 Response', async () => {
    const composed = compose(middleware)
    const context = await composed(c)
    expect(context.res).not.toBeNull()
    expect(context.res.status).toBe(200)
    expect(await context.res.text()).toBe('Hello')
  })
})

describe('compose with Context - 404 not found', () => {
  const middleware: MiddlewareTuple[] = []

  const req = new Request('http://localhost/')
  const onNotFound = (c: Context) => {
    return c.text('onNotFound', 404)
  }
  const onNotFoundAsync = async (c: Context) => {
    return c.text('onNotFoundAsync', 404)
  }
  const mHandler = async (_c: Context, next: Next) => {
    await next()
  }

  middleware.push(buildMiddlewareTuple(mHandler))

  it('Should return 404 Response', async () => {
    const c: Context = new Context(req)
    const composed = compose(middleware, undefined, onNotFound)
    const context = await composed(c)
    expect(context.res).not.toBeNull()
    expect(context.res.status).toBe(404)
    expect(await context.res.text()).toBe('onNotFound')
    expect(context.finalized).toBe(true)
  })

  it('Should return 404 Response - async handler', async () => {
    const c: Context = new Context(req)
    const composed = compose(middleware, undefined, onNotFoundAsync)
    const context = await composed(c)
    expect(context.res).not.toBeNull()
    expect(context.res.status).toBe(404)
    expect(await context.res.text()).toBe('onNotFoundAsync')
    expect(context.finalized).toBe(true)
  })
})

describe('compose with Context - 401 not authorized', () => {
  const middleware: MiddlewareTuple[] = []

  const req = new Request('http://localhost/')
  const c: Context = new Context(req)
  const handler = (c: Context) => {
    return c.text('Hello')
  }
  const mHandler = async (c: Context, next: Next) => {
    await next()
    c.res = new Response('Not authorized', { status: 401 })
  }

  middleware.push(buildMiddlewareTuple(mHandler))
  middleware.push(buildMiddlewareTuple(handler))

  it('Should return 401 Response', async () => {
    const composed = compose(middleware)
    const context = await composed(c)
    expect(context.res).not.toBeNull()
    expect(context.res.status).toBe(401)
    expect(await context.res.text()).toBe('Not authorized')
    expect(context.finalized).toBe(true)
  })
})

describe('compose with Context - next() below', () => {
  const middleware: MiddlewareTuple[] = []

  const req = new Request('http://localhost/')
  const c: Context = new Context(req)
  const handler = (c: Context) => {
    const message = c.req.header('x-custom') || 'blank'
    return c.text(message)
  }
  const mHandler = async (c: Context, next: Next) => {
    c.req.raw.headers.append('x-custom', 'foo')
    await next()
  }

  middleware.push(buildMiddlewareTuple(mHandler))
  middleware.push(buildMiddlewareTuple(handler))

  it('Should return 200 Response', async () => {
    const composed = compose(middleware)
    const context = await composed(c)
    expect(context.res).not.toBeNull()
    expect(context.res.status).toBe(200)
    expect(await context.res.text()).toBe('foo')
    expect(context.finalized).toBe(true)
  })
})

describe('compose with Context - 500 error', () => {
  const middleware: MiddlewareTuple[] = []

  const req = new Request('http://localhost/')
  const c: Context = new Context(req)

  it('Error on handler', async () => {
    const handler = () => {
      throw new Error()
    }

    const mHandler = async (_c: Context, next: Next) => {
      await next()
    }

    middleware.push(buildMiddlewareTuple(mHandler))
    middleware.push(buildMiddlewareTuple(handler))

    const onNotFound = (c: Context) => c.text('NotFound', 404)
    const onError = (_error: Error, c: Context) => c.text('onError', 500)

    const composed = compose(middleware, onError, onNotFound)
    const context = await composed(c)
    expect(context.res).not.toBeNull()
    expect(context.res.status).toBe(500)
    expect(await context.res.text()).toBe('onError')
    expect(context.finalized).toBe(true)
  })

  it('Error on handler - async', async () => {
    const handler = () => {
      throw new Error()
    }

    middleware.push(buildMiddlewareTuple(handler))
    const onError = async (_error: Error, c: Context) => c.text('onError', 500)

    const composed = compose(middleware, onError)
    const context = await composed(c)
    expect(context.res).not.toBeNull()
    expect(context.res.status).toBe(500)
    expect(await context.res.text()).toBe('onError')
    expect(context.finalized).toBe(true)
  })

  it('Run all the middlewares', async () => {
    const stack: number[] = []
    const middlewares = [
      async (_ctx: Context, next: Next) => {
        stack.push(0)
        await next()
      },
      async (_ctx: Context, next: Next) => {
        stack.push(1)
        await next()
      },
      async (_ctx: Context, next: Next) => {
        stack.push(2)
        await next()
      },
    ].map((h) => buildMiddlewareTuple(h))
    const composed = compose(middlewares)
    await composed(new Context(new Request('http://localhost/')))
    expect(stack).toEqual([0, 1, 2])
  })
})
describe('compose with Context - not finalized', () => {
  const req = new Request('http://localhost/')
  const c: Context = new Context(req)
  const onNotFound = (c: Context) => {
    return c.text('onNotFound', 404)
  }

  it('Should not be finalized - lack `next()`', async () => {
    const middleware: MiddlewareTuple[] = []
    const mHandler = async (_c: Context, next: Next) => {
      await next()
    }
    const mHandler2 = async () => {}

    middleware.push(buildMiddlewareTuple(mHandler))
    middleware.push(buildMiddlewareTuple(mHandler2))
    const composed = compose(middleware, undefined, onNotFound)
    const context = await composed(c)
    expect(context.finalized).toBe(false)
  })

  it('Should not be finalized - lack `return Response`', async () => {
    const middleware2: MiddlewareTuple[] = []
    const mHandler3 = async (_c: Context, next: Next) => {
      await next()
    }
    const handler = async () => {}
    middleware2.push(buildMiddlewareTuple(mHandler3))
    middleware2.push(buildMiddlewareTuple(handler))

    const composed = compose(middleware2, undefined, onNotFound)
    const context = await composed(c)
    expect(context.finalized).toBe(false)
  })
})
describe('compose with Context - next', () => {
  const req = new Request('http://localhost/')
  const c: Context = new Context(req)

  it('Should throw multiple call error', async () => {
    const middleware: MiddlewareTuple[] = []
    const mHandler = async (_c: Context, next: Next) => {
      await next()
    }
    const mHandler2 = async (_c: Context, next: Next) => {
      await next()
      await next()
    }

    middleware.push(buildMiddlewareTuple(mHandler))
    middleware.push(buildMiddlewareTuple(mHandler2))

    const composed = compose(middleware)
    try {
      await composed(c)
    } catch (err) {
      expect(err).toStrictEqual(new Error('next() called multiple times'))
    }
  })
})

describe('Compose', function () {
  it('should get executed order one by one', async () => {
    const arr: number[] = []
    const stack = []
    const called: boolean[] = []

    stack.push(
      buildMiddlewareTuple(async (_context: Context, next: Next) => {
        called.push(true)

        arr.push(1)
        await next()
        arr.push(6)
      })
    )

    stack.push(
      buildMiddlewareTuple(async (_context: Context, next: Next) => {
        called.push(true)

        arr.push(2)
        await next()
        arr.push(5)
      })
    )

    stack.push(
      buildMiddlewareTuple(async (_context: Context, next: Next) => {
        called.push(true)

        arr.push(3)
        await next()
        arr.push(4)
      })
    )

    await compose(stack)(new Context(new Request('http://localhost/')))
    expect(called).toEqual([true, true, true])
    expect(arr).toEqual([1, 2, 3, 4, 5, 6])
  })

  it('should not get executed if previous next() not triggered', async () => {
    const arr: number[] = []
    const stack = []
    const called: boolean[] = []

    stack.push(
      buildMiddlewareTuple(async (_context: Context, next: Next) => {
        called.push(true)

        arr.push(1)
        await next()
        arr.push(6)
      })
    )

    stack.push(
      buildMiddlewareTuple(async () => {
        called.push(true)
        arr.push(2)
      })
    )

    stack.push(
      buildMiddlewareTuple(async (_context: Context, next: Next) => {
        called.push(true)

        arr.push(3)
        await next()
        arr.push(4)
      })
    )

    await compose(stack)(new Context(new Request('http://localhost/')))
    expect(called).toEqual([true, true])
    expect(arr).toEqual([1, 2, 6])
  })

  it('should be able to be called twice', async () => {
    const stack = []

    stack.push(
      buildMiddlewareTuple(async (context: Context, next: Next) => {
        context.get('arr').push(1)
        await next()
        context.get('arr').push(6)
      })
    )

    stack.push(
      buildMiddlewareTuple(async (context: Context, next: Next) => {
        context.get('arr').push(2)
        await next()
        context.get('arr').push(5)
      })
    )

    stack.push(
      buildMiddlewareTuple(async (context: Context, next: Next) => {
        context.get('arr').push(3)
        await next()
        context.get('arr').push(4)
      })
    )

    const fn = compose(stack)
    const ctx1 = new Context(new Request('http://localhost/'))

    ctx1.set('arr', [])

    const ctx2 = new Context(new Request('http://localhost/'))

    ctx2.set('arr', [])

    const out = [1, 2, 3, 4, 5, 6]

    await fn(ctx1)

    expect(out).toEqual(ctx1.get('arr'))
    await fn(ctx2)

    expect(out).toEqual(ctx2.get('arr'))
  })

  it('should create next functions that return a Promise', async () => {
    const stack = []
    const arr: unknown[] = []
    for (let i = 0; i < 5; i++) {
      stack.push(
        buildMiddlewareTuple((_context: Context, next: Next) => {
          arr.push(next())
        })
      )
    }

    await compose(stack)(new Context(new Request('http://localhost/')))

    for (const next of arr) {
      const isPromise = !!(next as { then?: Function })?.then
      expect(isPromise).toBe(true)
    }
  })

  it('should work with 0 middleware', async () => {
    await compose([])(new Context(new Request('http://localhost/')))
  })

  it('should work when yielding at the end of the stack', async () => {
    const stack = []
    let called = false

    stack.push(
      buildMiddlewareTuple(async (_ctx: Context, next: Next) => {
        await next()
        called = true
      })
    )

    await compose(stack)(new Context(new Request('http://localhost/')))
    expect(called).toBe(true)
  })

  it('should reject on errors in middleware', async () => {
    const stack = []

    stack.push(
      buildMiddlewareTuple(() => {
        throw new ExpectedError()
      })
    )

    try {
      await compose(stack)(new Context(new Request('http://localhost/')))
      throw new Error('promise was not rejected')
    } catch (e) {
      expect(e).toBeInstanceOf(ExpectedError)
    }
  })

  it('should keep the context', async () => {
    const ctx = new Context(new Request('http://localhost/'))

    const stack = []

    stack.push(
      buildMiddlewareTuple(async (ctx2: Context, next: Next) => {
        await next()
        expect(ctx2).toEqual(ctx)
      })
    )

    stack.push(
      buildMiddlewareTuple(async (ctx2: Context, next: Next) => {
        await next()
        expect(ctx2).toEqual(ctx)
      })
    )

    stack.push(
      buildMiddlewareTuple(async (ctx2: Context, next: Next) => {
        await next()
        expect(ctx2).toEqual(ctx)
      })
    )

    await compose(stack)(ctx)
  })

  it('should catch downstream errors', async () => {
    const arr: number[] = []
    const stack = []

    stack.push(
      buildMiddlewareTuple(async (_ctx: Context, next: Next) => {
        arr.push(1)
        try {
          arr.push(6)
          await next()
          arr.push(7)
        } catch {
          arr.push(2)
        }
        arr.push(3)
      })
    )

    stack.push(
      buildMiddlewareTuple(async () => {
        arr.push(4)
        throw new Error()
      })
    )

    await compose(stack)(new Context(new Request('http://localhost/')))
    expect(arr).toEqual([1, 6, 4, 2, 3])
  })

  it('should compose w/ next', async () => {
    let called = false

    await compose([])(new Context(new Request('http://localhost/')), async () => {
      called = true
    })
    expect(called).toBe(true)
  })

  it('should handle errors in wrapped non-async functions', async () => {
    const stack = []

    stack.push(
      buildMiddlewareTuple(function () {
        throw new ExpectedError()
      })
    )

    try {
      await compose(stack)(new Context(new Request('http://localhost/')))
      throw new Error('promise was not rejected')
    } catch (e) {
      expect(e).toBeInstanceOf(ExpectedError)
    }
  })

  // https://github.com/koajs/compose/pull/27#issuecomment-143109739
  it('should compose w/ other compositions', async () => {
    const called: number[] = []

    await compose([
      buildMiddlewareTuple(
        compose([
          buildMiddlewareTuple((_ctx: Context, next: Next) => {
            called.push(1)
            return next()
          }),
          buildMiddlewareTuple((_ctx: Context, next: Next) => {
            called.push(2)
            return next()
          }),
        ])
      ),
      buildMiddlewareTuple((_ctx: Context, next: Next) => {
        called.push(3)
        return next()
      }),
    ])(new Context(new Request('http://localhost/')))

    expect(called).toEqual([1, 2, 3])
  })

  it('should throw if next() is called multiple times', async () => {
    try {
      await compose([
        buildMiddlewareTuple(async (_ctx: Context, next: Next) => {
          await next()
          await next()
        }),
      ])(new Context(new Request('http://localhost/')))
      throw new Error('boom')
    } catch (err) {
      expect(err instanceof Error && /multiple times/.test(err.message)).toBe(true)
    }
  })

  it('should return a valid middleware', async () => {
    let val = 0
    await compose([
      buildMiddlewareTuple(
        compose([
          buildMiddlewareTuple((_ctx: Context, next: Next) => {
            val++
            return next()
          }),
          buildMiddlewareTuple((_ctx: Context, next: Next) => {
            val++
            return next()
          }),
        ])
      ),
      buildMiddlewareTuple((_ctx: Context, next: Next) => {
        val++
        return next()
      }),
    ])(new Context(new Request('http://localhost/')))

    expect(val).toEqual(3)
  })

  it('should return last return value', async () => {
    const stack = []

    stack.push(
      buildMiddlewareTuple(async (ctx: Context, next: Next) => {
        await next()
        expect(ctx.get('val')).toEqual(2)
        ctx.set('val', 1)
      })
    )

    stack.push(
      buildMiddlewareTuple(async (ctx: Context, next: Next) => {
        ctx.set('val', 2)
        await next()
        expect(ctx.get('val')).toEqual(2)
      })
    )

    const res = await compose(stack)(new Context(new Request('http://localhost/')))
    expect(res.get('val')).toEqual(1)
  })

  it('should not affect the original middleware array', () => {
    const middleware: MiddlewareTuple[] = []
    const fn1 = (_ctx: Context, next: Next) => {
      return next()
    }
    middleware.push(buildMiddlewareTuple(fn1))

    for (const [[fn]] of middleware) {
      expect(fn).toEqual(fn1)
    }

    compose(middleware)

    for (const [[fn]] of middleware) {
      expect(fn).toEqual(fn1)
    }
  })

  it('should not get stuck on the passed in next', async () => {
    const middleware = [
      buildMiddlewareTuple((ctx: Context, next: Next) => {
        ctx.set('middleware', ctx.get('middleware') + 1)
        return next()
      }),
    ]

    const ctx = new Context(new Request('http://localhost/'))

    ctx.set('middleware', 0)
    ctx.set('next', 0)

    await compose(middleware)(ctx, ((ctx: Context, next: Next) => {
      ctx.set('next', ctx.get('next') + 1)
      return next()
    }) as Next)

    expect(ctx.get('middleware')).toEqual(1)
    expect(ctx.get('next')).toEqual(1)
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/compose.ts
```typescript
import type { Context } from './context'
import type { Env, ErrorHandler, Next, NotFoundHandler } from './types'

/**
 * Compose middleware functions into a single function based on `koa-compose` package.
 *
 * @template E - The environment type.
 *
 * @param {[[Function, unknown], unknown][] | [[Function]][]} middleware - An array of middleware functions and their corresponding parameters.
 * @param {ErrorHandler<E>} [onError] - An optional error handler function.
 * @param {NotFoundHandler<E>} [onNotFound] - An optional not-found handler function.
 *
 * @returns {(context: Context, next?: Next) => Promise<Context>} - A composed middleware function.
 */
export const compose = <E extends Env = Env>(
  middleware: [[Function, unknown], unknown][] | [[Function]][],
  onError?: ErrorHandler<E>,
  onNotFound?: NotFoundHandler<E>
): ((context: Context, next?: Next) => Promise<Context>) => {
  return (context, next) => {
    let index = -1

    return dispatch(0)

    /**
     * Dispatch the middleware functions.
     *
     * @param {number} i - The current index in the middleware array.
     *
     * @returns {Promise<Context>} - A promise that resolves to the context.
     */
    async function dispatch(i: number): Promise<Context> {
      if (i <= index) {
        throw new Error('next() called multiple times')
      }
      index = i

      let res
      let isError = false
      let handler

      if (middleware[i]) {
        handler = middleware[i][0][0]
        context.req.routeIndex = i
      } else {
        handler = (i === middleware.length && next) || undefined
      }

      if (handler) {
        try {
          res = await handler(context, () => dispatch(i + 1))
        } catch (err) {
          if (err instanceof Error && onError) {
            context.error = err
            res = await onError(err, context)
            isError = true
          } else {
            throw err
          }
        }
      } else {
        if (context.finalized === false && onNotFound) {
          res = await onNotFound(context)
        }
      }

      if (res && (context.finalized === false || isError)) {
        context.res = res
      }
      return context
    }
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/context.test.ts
```typescript
import { Context } from './context'
import { setCookie } from './helper/cookie'

const makeResponseHeaderImmutable = (res: Response) => {
  Object.defineProperty(res, 'headers', {
    value: new Proxy(res.headers, {
      set(target, prop, value) {
        if (prop === 'set') {
          throw new TypeError('Cannot modify headers: Headers are immutable')
        }
        return Reflect.set(target, prop, value)
      },
      get(target, prop) {
        if (prop === 'set') {
          return function () {
            throw new TypeError('Cannot modify headers: Headers are immutable')
          }
        }
        return Reflect.get(target, prop)
      },
    }),
    writable: false,
  })
  return res
}

describe('Context', () => {
  const req = new Request('http://localhost/')

  let c: Context
  beforeEach(() => {
    c = new Context(req)
  })

  it('c.text()', async () => {
    const res = c.text('text in c', 201, { 'X-Custom': 'Message' })
    expect(res.status).toBe(201)
    expect(res.headers.get('Content-Type')).toMatch(/^text\/plain/)
    expect(await res.text()).toBe('text in c')
    expect(res.headers.get('X-Custom')).toBe('Message')
  })

  it('c.text() with c.status()', async () => {
    c.status(404)
    const res = c.text('not found')
    expect(res.status).toBe(404)
    expect(res.headers.get('Content-Type')).toMatch(/^text\/plain/)
    expect(await res.text()).toBe('not found')
  })

  it('c.json()', async () => {
    const res = c.json({ message: 'Hello' }, 201, { 'X-Custom': 'Message' })
    expect(res.status).toBe(201)
    expect(res.headers.get('Content-Type')).toMatch('application/json')
    const text = await res.text()
    expect(text).toBe('{"message":"Hello"}')
    expect(res.headers.get('X-Custom')).toBe('Message')
  })

  it('c.html()', async () => {
    const res: Response = c.html('<h1>Hello! Hono!</h1>', 201, { 'X-Custom': 'Message' })
    expect(res.status).toBe(201)
    expect(res.headers.get('Content-Type')).toMatch('text/html')
    expect(await res.text()).toBe('<h1>Hello! Hono!</h1>')
    expect(res.headers.get('X-Custom')).toBe('Message')
  })

  it('c.html() with async', async () => {
    const resPromise: Promise<Response> = c.html(
      new Promise<string>((resolve) => setTimeout(() => resolve('<h1>Hello! Hono!</h1>'), 0)),
      201,
      {
        'X-Custom': 'Message',
      }
    )
    const res = await resPromise
    expect(res.status).toBe(201)
    expect(res.headers.get('Content-Type')).toMatch('text/html')
    expect(await res.text()).toBe('<h1>Hello! Hono!</h1>')
    expect(res.headers.get('X-Custom')).toBe('Message')
  })

  it('c.redirect()', async () => {
    let res = c.redirect('/destination')
    expect(res.status).toBe(302)
    expect(res.headers.get('Location')).toBe('/destination')
    res = c.redirect('https://example.com/destination')
    expect(res.status).toBe(302)
    expect(res.headers.get('Location')).toBe('https://example.com/destination')
  })

  it('c.redirect() w/ URL', async () => {
    const res = c.redirect(new URL('/destination', 'https://example.com'))
    expect(res.status).toBe(302)
    expect(res.headers.get('Location')).toBe('https://example.com/destination')
  })

  it('c.header()', async () => {
    c.header('X-Foo', 'Bar')
    const res = c.body('Hi')
    const foo = res.headers.get('X-Foo')
    expect(foo).toBe('Bar')
  })

  it('c.header() - append', async () => {
    c.header('X-Foo', 'Bar')
    c.header('X-Foo', 'Buzz', { append: true })
    const res = c.body('Hi')
    const foo = res.headers.get('X-Foo')
    expect(foo).toBe('Bar, Buzz')
  })

  it('c.set() and c.get()', async () => {
    expect(c.get('foo')).toBe(undefined)
    c.set('foo', 'bar')
    expect(c.get('foo')).toBe('bar')
    expect(c.get('foo2')).toBe(undefined)
  })

  it('c.var', async () => {
    expect(c.var.foo).toBe(undefined)
    c.set('foo', 'bar')
    expect(c.var.foo).toBe('bar')
    expect(c.var.foo2).toBe(undefined)
  })

  it('c.notFound()', async () => {
    const res = c.notFound()
    expect(res).instanceOf(Response)
  })

  it('Should set headers if already this.#headers is created by `c.header()`', async () => {
    c.header('X-Foo', 'Bar')
    c.header('X-Foo', 'Buzz', { append: true })
    const res = c.body('Hi', {
      headers: {
        'X-Message': 'Hi',
      },
    })
    expect(res.headers.get('X-Foo')).toBe('Bar, Buzz')
    expect(res.headers.get('X-Message')).toBe('Hi')
  })

  it('c.header() - append, c.html()', async () => {
    c.header('X-Foo', 'Bar', { append: true })
    const res = await c.html('<h1>This rendered fine</h1>')
    expect(res.headers.get('content-type')).toMatch(/^text\/html/)
  })

  it('c.header() - clear the header', async () => {
    c.header('X-Foo', 'Bar')
    c.header('X-Foo', undefined)
    c.header('X-Foo2', 'Bar')
    const res = c.body('Hi')
    expect(res.headers.get('X-Foo')).toBe(null)
    c.header('X-Foo2', undefined)
    const res2 = c.body('Hi')
    expect(res2.headers.get('X-Foo2')).toBe(null)
  })

  it('c.header() - clear the header when append is true', async () => {
    c.header('X-Foo', 'Bar', { append: true })
    c.header('X-Foo', undefined)
    expect(c.res.headers.get('X-Foo')).toBe(null)
  })

  it('c.body() - multiple header', async () => {
    const res = c.body('Hi', 200, {
      'X-Foo': ['Bar', 'Buzz'],
    })
    const foo = res.headers.get('X-Foo')
    expect(foo).toBe('Bar, Buzz')
  })

  it('c.status()', async () => {
    c.status(201)
    const res = c.body('Hi')
    expect(res.status).toBe(201)
  })

  it('Complex pattern', async () => {
    c.status(404)
    const res = c.json({ hono: 'great app' })
    expect(res.status).toBe(404)
    expect(res.headers.get('Content-Type')).toMatch('application/json')
    const obj: { [key: string]: string } = await res.json()
    expect(obj['hono']).toBe('great app')
  })

  it('Has headers and status', async () => {
    c.header('x-custom1', 'Message1')
    c.header('x-custom2', 'Message2')
    c.status(200)
    const res = c.newResponse('this is body', 201, {
      'x-custom3': 'Message3',
      'x-custom2': 'Message2-Override',
    })
    expect(res.headers.get('x-Custom1')).toBe('Message1')
    expect(res.headers.get('x-Custom2')).toBe('Message2-Override')
    expect(res.headers.get('x-Custom3')).toBe('Message3')
    expect(res.status).toBe(201)
    expect(await res.text()).toBe('this is body')

    // res is already set.
    c.res = res
    c.header('X-Custom4', 'Message4')
    c.status(202)
    expect(c.res.headers.get('X-Custom4')).toBe('Message4')
    expect(c.res.status).toBe(201)
  })

  it('Inherit current status if not specified', async () => {
    c.status(201)
    const res = c.newResponse('this is body', {
      headers: {
        'x-custom3': 'Message3',
        'x-custom2': 'Message2-Override',
      },
    })
    expect(res.headers.get('x-Custom2')).toBe('Message2-Override')
    expect(res.headers.get('x-Custom3')).toBe('Message3')
    expect(res.status).toBe(201)
    expect(await res.text()).toBe('this is body')
  })

  it('Should append the previous headers to new Response', () => {
    c.res.headers.set('x-Custom1', 'Message1')
    const res2 = new Response('foo2', {
      headers: {
        'Content-Type': 'application/json',
      },
    })
    res2.headers.set('x-Custom2', 'Message2')
    c.res = res2
    expect(c.res.headers.get('x-Custom1')).toBe('Message1')
    expect(c.res.headers.get('Content-Type')).toBe('application/json')
  })

  it('Should return 200 response', async () => {
    const res = c.text('Text')
    expect(res.status).toBe(200)
  })

  it('Should return 204 response', async () => {
    c.status(204)
    const res = c.body(null)
    expect(res.status).toBe(204)
    expect(await res.text()).toBe('')
  })

  it('Should be able read env', async () => {
    const req = new Request('http://localhost/')
    const key = 'a-secret-key'
    const ctx = new Context(req, {
      env: {
        API_KEY: key,
      },
    })
    expect(ctx.env.API_KEY).toBe(key)
  })

  it('set and set', async () => {
    const ctx = new Context(req)
    expect(ctx.get('k-foo')).toEqual(undefined)
    ctx.set('k-foo', 'v-foo')
    expect(ctx.get('k-foo')).toEqual('v-foo')
    expect(ctx.get('k-bar')).toEqual(undefined)
    ctx.set('k-bar', { k: 'v' })
    expect(ctx.get('k-bar')).toEqual({ k: 'v' })
  })

  it('has res object by default', async () => {
    c = new Context(req)
    c.res.headers.append('foo', 'bar')
    const res = c.text('foo')
    expect(res.headers.get('foo')).not.toBeNull()
    expect(res.headers.get('foo')).toBe('bar')
  })
})

describe('event and executionCtx', () => {
  const req = new Request('http://localhost/')

  it('Should return the event if accessing c.event', () => {
    const respondWith = vi.fn()
    const c = new Context(req, {
      // @ts-expect-error the type is not correct
      executionCtx: {
        respondWith: respondWith,
      },
    })
    expect(() => c.event).not.toThrowError()
    c.event.respondWith(new Response())
    expect(respondWith).toHaveBeenCalled()
  })

  it('Should throw an error if accessing c.event', () => {
    const c = new Context(req)
    expect(() => c.event).toThrowError()
  })

  it('Should return the executionCtx if accessing c.executionCtx', () => {
    const pathThroughOnException = vi.fn()
    const waitUntil = vi.fn()
    const c = new Context(req, {
      executionCtx: {
        passThroughOnException: pathThroughOnException,
        waitUntil: waitUntil,
      },
      env: {},
    })
    expect(() => c.executionCtx).not.toThrowError()
    c.executionCtx.passThroughOnException()
    expect(pathThroughOnException).toHaveBeenCalled()
    const asyncFunc = async () => {}
    c.executionCtx.waitUntil(asyncFunc())
    expect(waitUntil).toHaveBeenCalled()
  })

  it('Should throw an error if accessing c.executionCtx', () => {
    const c = new Context(req)
    expect(() => c.executionCtx).toThrowError()
  })
})

describe('Context header', () => {
  const req = new Request('http://localhost/')
  let c: Context
  beforeEach(() => {
    c = new Context(req)
  })

  it('Should return only one content-type value', async () => {
    c.header('Content-Type', 'foo')
    const res = await c.html('foo')
    expect(res.headers.get('Content-Type')).toBe('text/html; charset=UTF-8')
  })

  it('Should rewrite header values correctly', async () => {
    c.res = await c.html('foo')
    const res = c.text('foo')
    expect(res.headers.get('Content-Type')).toMatch(/^text\/plain/)
  })

  it('Should set header values if the #this.headers is set and the arg is ResponseInit', async () => {
    c.header('foo', 'bar')
    const res = c.body('foo', {
      headers: {
        'Content-Type': 'text/plain',
      },
    })
    expect(res.headers.get('foo')).toBe('bar')
  })

  it('Should set cookie headers when re-assigning Response to `c.res`', () => {
    const cookies = ['foo=bar; Path=/', 'foo2=bar2; Path=/']
    const res = new Response(null)
    res.headers.append('set-cookie', cookies[0])
    res.headers.append('set-cookie', cookies[1])
    c.res = res
    expect(c.res.headers.getSetCookie().length).toBe(2)

    // Re-assign
    const newCookies = ['foo3=bar3; Path=/']
    const newResponse = new Response(null)
    newResponse.headers.append('set-cookie', newCookies[0])
    c.res = newResponse
    expect(c.res.headers.getSetCookie().length).toBe(cookies.length)
    expect(c.res.headers.getSetCookie()).toEqual(cookies)
  })

  it('Should keep previous cookies in response headers', () => {
    c.res.headers.append('set-cookie', 'foo=bar; Path=/')
    setCookie(c, 'foo2', 'bar2', { path: '/' })
    const res = c.json({ message: 'Hello' })
    const cookies = res.headers.getSetCookie()
    expect(cookies.includes('foo=bar; Path=/')).toBe(true)
    expect(cookies.includes('foo2=bar2; Path=/')).toBe(true)
  })

  it('Should set set-cookie header values if c.res is already defined', () => {
    c.res = new Response(null, {
      headers: [
        ['set-cookie', 'a'],
        ['set-cookie', 'b'],
        ['set-cookie', 'c'],
      ],
    })
    const res = c.text('Hi')
    expect(res.headers.get('set-cookie')).toBe('a, b, c')
  })

  it('Should be able to overwrite a fetch response with a new response.', async () => {
    c.res = makeResponseHeaderImmutable(new Response('bar'))
    c.res = new Response('foo', {
      headers: {
        'X-Custom': 'Message',
      },
    })
    expect(await c.res.text()).toBe('foo')
    expect(c.res.headers.get('X-Custom')).toBe('Message')
  })

  it('Should be able to overwrite a response with a fetch response.', async () => {
    c.res = new Response('foo', {
      headers: {
        'X-Custom': 'Message',
      },
    })
    c.res = makeResponseHeaderImmutable(new Response('bar'))
    expect(await c.res.text()).toBe('bar')
    expect(c.res.headers.get('X-Custom')).toBe('Message')
  })
})

describe('Pass a ResponseInit to respond methods', () => {
  const req = new Request('http://localhost/')
  let c: Context
  beforeEach(() => {
    c = new Context(req)
  })

  it('c.json()', async () => {
    const originalResponse = new Response('Unauthorized', {
      headers: {
        'content-type': 'text/plain',
        'x-custom': 'custom message',
      },
      status: 401,
    })
    const res = c.json(
      {
        message: 'Unauthorized',
      },
      originalResponse
    )
    expect(res.status).toBe(401)
    expect(res.headers.get('content-type')).toMatch(/^application\/json/)
    expect(res.headers.get('x-custom')).toBe('custom message')
    expect(await res.json()).toEqual({
      message: 'Unauthorized',
    })
  })

  it('c.body()', async () => {
    const originalResponse = new Response('<h1>Hello</h1>', {
      headers: {
        'content-type': 'text/html',
      },
    })
    const res = c.body('<h2>Hello</h2>', originalResponse)
    expect(res.headers.get('content-type')).toMatch(/^text\/html/)
    expect(await res.text()).toBe('<h2>Hello</h2>')
  })

  it('c.body() should retain context cookies from context and original response', async () => {
    setCookie(c, 'context', '1')
    setCookie(c, 'context', '2')

    const originalResponse = new Response('', {
      headers: {
        'set-cookie': 'response=1; Path=/',
      },
    })
    const res = c.body('', originalResponse)
    const cookies = res.headers.getSetCookie()
    expect(cookies.includes('context=1; Path=/')).toBe(true)
    expect(cookies.includes('context=2; Path=/')).toBe(true)
    expect(cookies.includes('response=1; Path=/')).toBe(true)
  })

  it('c.text()', async () => {
    const originalResponse = new Response(JSON.stringify({ foo: 'bar' }))
    const res = c.text('foo', originalResponse)
    expect(res.headers.get('content-type')).toMatch(/^text\/plain/)
    expect(await res.text()).toBe('foo')
  })

  it('c.html()', async () => {
    const originalResponse = new Response('foo')
    const res = await c.html('<h1>foo</h1>', originalResponse)
    expect(res.headers.get('content-type')).toMatch(/^text\/html/)
    expect(await res.text()).toBe('<h1>foo</h1>')
  })
})

declare module './context' {
  interface ContextRenderer {
    (content: string | Promise<string>, head: { title: string }): Response | Promise<Response>
  }
}

describe('c.render', () => {
  const req = new Request('http://localhost/')
  let c: Context
  beforeEach(() => {
    c = new Context(req)
  })

  it('Should return a Response from the default renderer', async () => {
    c.header('foo', 'bar')
    const res = await c.render('<h1>content</h1>', { title: 'dummy ' })
    expect(res.headers.get('foo')).toBe('bar')
    expect(await res.text()).toBe('<h1>content</h1>')
  })

  it('Should return a Response from the custom renderer', async () => {
    c.setRenderer((content, head) => {
      return c.html(`<html><head>${head.title}</head><body>${content}</body></html>`)
    })
    c.header('foo', 'bar')
    const res = await c.render('<h1>content</h1>', { title: 'title' })
    expect(res.headers.get('foo')).toBe('bar')
    expect(await res.text()).toBe('<html><head>title</head><body><h1>content</h1></body></html>')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/context.ts
````typescript
import { HonoRequest } from './request'
import type { Result } from './router'
import type {
  Env,
  FetchEventLike,
  H,
  Input,
  NotFoundHandler,
  RouterRoute,
  TypedResponse,
} from './types'
import type { ResponseHeader } from './utils/headers'
import { HtmlEscapedCallbackPhase, resolveCallback } from './utils/html'
import type { ContentfulStatusCode, RedirectStatusCode, StatusCode } from './utils/http-status'
import type { BaseMime } from './utils/mime'
import type {
  InvalidJSONValue,
  IsAny,
  JSONParsed,
  JSONValue,
  SimplifyDeepArray,
} from './utils/types'

type HeaderRecord =
  | Record<'Content-Type', BaseMime>
  | Record<ResponseHeader, string | string[]>
  | Record<string, string | string[]>

/**
 * Data type can be a string, ArrayBuffer, Uint8Array (buffer), or ReadableStream.
 */
export type Data = string | ArrayBuffer | ReadableStream | Uint8Array

/**
 * Interface for the execution context in a web worker or similar environment.
 */
export interface ExecutionContext {
  /**
   * Extends the lifetime of the event callback until the promise is settled.
   *
   * @param promise - A promise to wait for.
   */
  waitUntil(promise: Promise<unknown>): void
  /**
   * Allows the event to be passed through to subsequent event listeners.
   */
  passThroughOnException(): void
}

/**
 * Interface for context variable mapping.
 */
export interface ContextVariableMap {}

/**
 * Interface for context renderer.
 */
export interface ContextRenderer {}

/**
 * Interface representing a renderer for content.
 *
 * @interface DefaultRenderer
 * @param {string | Promise<string>} content - The content to be rendered, which can be either a string or a Promise resolving to a string.
 * @returns {Response | Promise<Response>} - The response after rendering the content, which can be either a Response or a Promise resolving to a Response.
 */
interface DefaultRenderer {
  (content: string | Promise<string>): Response | Promise<Response>
}

/**
 * Renderer type which can either be a ContextRenderer or DefaultRenderer.
 */
export type Renderer = ContextRenderer extends Function ? ContextRenderer : DefaultRenderer

/**
 * Extracts the props for the renderer.
 */
export type PropsForRenderer = [...Required<Parameters<Renderer>>] extends [unknown, infer Props]
  ? Props
  : unknown

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type Layout<T = Record<string, any>> = (props: T) => any

/**
 * Interface for getting context variables.
 *
 * @template E - Environment type.
 */
interface Get<E extends Env> {
  <Key extends keyof E['Variables']>(key: Key): E['Variables'][Key]
  <Key extends keyof ContextVariableMap>(key: Key): ContextVariableMap[Key]
}

/**
 * Interface for setting context variables.
 *
 * @template E - Environment type.
 */
interface Set<E extends Env> {
  <Key extends keyof E['Variables']>(key: Key, value: E['Variables'][Key]): void
  <Key extends keyof ContextVariableMap>(key: Key, value: ContextVariableMap[Key]): void
}

/**
 * Interface for creating a new response.
 */
interface NewResponse {
  (data: Data | null, status?: StatusCode, headers?: HeaderRecord): Response
  (data: Data | null, init?: ResponseOrInit): Response
}

/**
 * Interface for responding with a body.
 */
interface BodyRespond {
  // if we return content, only allow the status codes that allow for returning the body
  <U extends ContentfulStatusCode>(data: Data, status?: U, headers?: HeaderRecord): Response &
    TypedResponse<unknown, U, 'body'>
  <U extends StatusCode>(data: null, status?: U, headers?: HeaderRecord): Response &
    TypedResponse<null, U, 'body'>
  <U extends ContentfulStatusCode>(data: Data, init?: ResponseOrInit<U>): Response &
    TypedResponse<unknown, U, 'body'>
  <U extends StatusCode>(data: null, init?: ResponseOrInit<U>): Response &
    TypedResponse<null, U, 'body'>
}

/**
 * Interface for responding with text.
 *
 * @interface TextRespond
 * @template T - The type of the text content.
 * @template U - The type of the status code.
 *
 * @param {T} text - The text content to be included in the response.
 * @param {U} [status] - An optional status code for the response.
 * @param {HeaderRecord} [headers] - An optional record of headers to include in the response.
 *
 * @returns {Response & TypedResponse<T, U, 'text'>} - The response after rendering the text content, typed with the provided text and status code types.
 */
interface TextRespond {
  <T extends string, U extends ContentfulStatusCode = ContentfulStatusCode>(
    text: T,
    status?: U,
    headers?: HeaderRecord
  ): Response & TypedResponse<T, U, 'text'>
  <T extends string, U extends ContentfulStatusCode = ContentfulStatusCode>(
    text: T,
    init?: ResponseOrInit<U>
  ): Response & TypedResponse<T, U, 'text'>
}

/**
 * Interface for responding with JSON.
 *
 * @interface JSONRespond
 * @template T - The type of the JSON value or simplified unknown type.
 * @template U - The type of the status code.
 *
 * @param {T} object - The JSON object to be included in the response.
 * @param {U} [status] - An optional status code for the response.
 * @param {HeaderRecord} [headers] - An optional record of headers to include in the response.
 *
 * @returns {JSONRespondReturn<T, U>} - The response after rendering the JSON object, typed with the provided object and status code types.
 */
interface JSONRespond {
  <
    T extends JSONValue | SimplifyDeepArray<unknown> | InvalidJSONValue,
    U extends ContentfulStatusCode = ContentfulStatusCode
  >(
    object: T,
    status?: U,
    headers?: HeaderRecord
  ): JSONRespondReturn<T, U>
  <
    T extends JSONValue | SimplifyDeepArray<unknown> | InvalidJSONValue,
    U extends ContentfulStatusCode = ContentfulStatusCode
  >(
    object: T,
    init?: ResponseOrInit<U>
  ): JSONRespondReturn<T, U>
}

/**
 * @template T - The type of the JSON value or simplified unknown type.
 * @template U - The type of the status code.
 *
 * @returns {Response & TypedResponse<SimplifyDeepArray<T> extends JSONValue ? (JSONValue extends SimplifyDeepArray<T> ? never : JSONParsed<T>) : never, U, 'json'>} - The response after rendering the JSON object, typed with the provided object and status code types.
 */
type JSONRespondReturn<
  T extends JSONValue | SimplifyDeepArray<unknown> | InvalidJSONValue,
  U extends ContentfulStatusCode
> = Response &
  TypedResponse<
    SimplifyDeepArray<T> extends JSONValue
      ? JSONValue extends SimplifyDeepArray<T>
        ? never
        : JSONParsed<T>
      : never,
    U,
    'json'
  >

/**
 * Interface representing a function that responds with HTML content.
 *
 * @param html - The HTML content to respond with, which can be a string or a Promise that resolves to a string.
 * @param status - (Optional) The HTTP status code for the response.
 * @param headers - (Optional) A record of headers to include in the response.
 * @param init - (Optional) The response initialization object.
 *
 * @returns A Response object or a Promise that resolves to a Response object.
 */
interface HTMLRespond {
  <T extends string | Promise<string>>(
    html: T,
    status?: ContentfulStatusCode,
    headers?: HeaderRecord
  ): T extends string ? Response : Promise<Response>
  <T extends string | Promise<string>>(
    html: T,
    init?: ResponseOrInit<ContentfulStatusCode>
  ): T extends string ? Response : Promise<Response>
}

/**
 * Options for configuring the context.
 *
 * @template E - Environment type.
 */
type ContextOptions<E extends Env> = {
  /**
   * Bindings for the environment.
   */
  env: E['Bindings']
  /**
   * Execution context for the request.
   */
  executionCtx?: FetchEventLike | ExecutionContext | undefined
  /**
   * Handler for not found responses.
   */
  notFoundHandler?: NotFoundHandler<E>
  matchResult?: Result<[H, RouterRoute]>
  path?: string
}

interface SetHeadersOptions {
  append?: boolean
}

interface SetHeaders {
  (name: 'Content-Type', value?: BaseMime, options?: SetHeadersOptions): void
  (name: ResponseHeader, value?: string, options?: SetHeadersOptions): void
  (name: string, value?: string, options?: SetHeadersOptions): void
}

type ResponseHeadersInit =
  | [string, string][]
  | Record<'Content-Type', BaseMime>
  | Record<ResponseHeader, string>
  | Record<string, string>
  | Headers

interface ResponseInit<T extends StatusCode = StatusCode> {
  headers?: ResponseHeadersInit
  status?: T
  statusText?: string
}

type ResponseOrInit<T extends StatusCode = StatusCode> = ResponseInit<T> | Response

export const TEXT_PLAIN = 'text/plain; charset=UTF-8'

/**
 * Sets the headers of a response.
 *
 * @param headers - The Headers object to set the headers on.
 * @param map - A record of header key-value pairs to set.
 * @returns The updated Headers object.
 */
const setHeaders = (headers: Headers, map: Record<string, string> = {}) => {
  for (const key of Object.keys(map)) {
    headers.set(key, map[key])
  }
  return headers
}

export class Context<
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  E extends Env = any,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  P extends string = any,
  I extends Input = {}
> {
  #rawRequest: Request
  #req: HonoRequest<P, I['out']> | undefined
  /**
   * `.env` can get bindings (environment variables, secrets, KV namespaces, D1 database, R2 bucket etc.) in Cloudflare Workers.
   *
   * @see {@link https://hono.dev/docs/api/context#env}
   *
   * @example
   * ```ts
   * // Environment object for Cloudflare Workers
   * app.get('*', async c => {
   *   const counter = c.env.COUNTER
   * })
   * ```
   */
  env: E['Bindings'] = {}
  #var: Map<unknown, unknown> | undefined
  finalized: boolean = false
  /**
   * `.error` can get the error object from the middleware if the Handler throws an error.
   *
   * @see {@link https://hono.dev/docs/api/context#error}
   *
   * @example
   * ```ts
   * app.use('*', async (c, next) => {
   *   await next()
   *   if (c.error) {
   *     // do something...
   *   }
   * })
   * ```
   */
  error: Error | undefined

  #status: StatusCode = 200
  #executionCtx: FetchEventLike | ExecutionContext | undefined
  #headers: Headers | undefined
  #preparedHeaders: Record<string, string> | undefined
  #res: Response | undefined
  #isFresh = true
  #layout: Layout<PropsForRenderer & { Layout: Layout }> | undefined
  #renderer: Renderer | undefined
  #notFoundHandler: NotFoundHandler<E> | undefined

  #matchResult: Result<[H, RouterRoute]> | undefined
  #path: string | undefined

  /**
   * Creates an instance of the Context class.
   *
   * @param req - The Request object.
   * @param options - Optional configuration options for the context.
   */
  constructor(req: Request, options?: ContextOptions<E>) {
    this.#rawRequest = req
    if (options) {
      this.#executionCtx = options.executionCtx
      this.env = options.env
      this.#notFoundHandler = options.notFoundHandler
      this.#path = options.path
      this.#matchResult = options.matchResult
    }
  }

  /**
   * `.req` is the instance of {@link HonoRequest}.
   */
  get req(): HonoRequest<P, I['out']> {
    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult)
    return this.#req
  }

  /**
   * @see {@link https://hono.dev/docs/api/context#event}
   * The FetchEvent associated with the current request.
   *
   * @throws Will throw an error if the context does not have a FetchEvent.
   */
  get event(): FetchEventLike {
    if (this.#executionCtx && 'respondWith' in this.#executionCtx) {
      return this.#executionCtx
    } else {
      throw Error('This context has no FetchEvent')
    }
  }

  /**
   * @see {@link https://hono.dev/docs/api/context#executionctx}
   * The ExecutionContext associated with the current request.
   *
   * @throws Will throw an error if the context does not have an ExecutionContext.
   */
  get executionCtx(): ExecutionContext {
    if (this.#executionCtx) {
      return this.#executionCtx as ExecutionContext
    } else {
      throw Error('This context has no ExecutionContext')
    }
  }

  /**
   * @see {@link https://hono.dev/docs/api/context#res}
   * The Response object for the current request.
   */
  get res(): Response {
    this.#isFresh = false
    return (this.#res ||= new Response('404 Not Found', { status: 404 }))
  }

  /**
   * Sets the Response object for the current request.
   *
   * @param _res - The Response object to set.
   */
  set res(_res: Response | undefined) {
    this.#isFresh = false
    if (this.#res && _res) {
      try {
        for (const [k, v] of this.#res.headers.entries()) {
          if (k === 'content-type') {
            continue
          }
          if (k === 'set-cookie') {
            const cookies = this.#res.headers.getSetCookie()
            _res.headers.delete('set-cookie')
            for (const cookie of cookies) {
              _res.headers.append('set-cookie', cookie)
            }
          } else {
            _res.headers.set(k, v)
          }
        }
      } catch (e) {
        if (e instanceof TypeError && e.message.includes('immutable')) {
          // `_res` is immutable (probably a response from a fetch API), so retry with a new response.
          this.res = new Response(_res.body, {
            headers: _res.headers,
            status: _res.status,
          })
          return
        } else {
          throw e
        }
      }
    }
    this.#res = _res
    this.finalized = true
  }

  /**
   * `.render()` can create a response within a layout.
   *
   * @see {@link https://hono.dev/docs/api/context#render-setrenderer}
   *
   * @example
   * ```ts
   * app.get('/', (c) => {
   *   return c.render('Hello!')
   * })
   * ```
   */
  render: Renderer = (...args) => {
    this.#renderer ??= (content: string | Promise<string>) => this.html(content)
    return this.#renderer(...args)
  }

  /**
   * Sets the layout for the response.
   *
   * @param layout - The layout to set.
   * @returns The layout function.
   */
  setLayout = (
    layout: Layout<PropsForRenderer & { Layout: Layout }>
  ): Layout<
    PropsForRenderer & {
      Layout: Layout
    }
  > => (this.#layout = layout)

  /**
   * Gets the current layout for the response.
   *
   * @returns The current layout function.
   */
  getLayout = (): Layout<PropsForRenderer & { Layout: Layout }> | undefined => this.#layout

  /**
   * `.setRenderer()` can set the layout in the custom middleware.
   *
   * @see {@link https://hono.dev/docs/api/context#render-setrenderer}
   *
   * @example
   * ```tsx
   * app.use('*', async (c, next) => {
   *   c.setRenderer((content) => {
   *     return c.html(
   *       <html>
   *         <body>
   *           <p>{content}</p>
   *         </body>
   *       </html>
   *     )
   *   })
   *   await next()
   * })
   * ```
   */
  setRenderer = (renderer: Renderer): void => {
    this.#renderer = renderer
  }

  /**
   * `.header()` can set headers.
   *
   * @see {@link https://hono.dev/docs/api/context#body}
   *
   * @example
   * ```ts
   * app.get('/welcome', (c) => {
   *   // Set headers
   *   c.header('X-Message', 'Hello!')
   *   c.header('Content-Type', 'text/plain')
   *
   *   return c.body('Thank you for coming')
   * })
   * ```
   */
  header: SetHeaders = (name, value, options): void => {
    // Clear the header
    if (value === undefined) {
      if (this.#headers) {
        this.#headers.delete(name)
      } else if (this.#preparedHeaders) {
        delete this.#preparedHeaders[name.toLocaleLowerCase()]
      }
      if (this.finalized) {
        this.res.headers.delete(name)
      }
      return
    }

    if (options?.append) {
      if (!this.#headers) {
        this.#isFresh = false
        this.#headers = new Headers(this.#preparedHeaders)
        this.#preparedHeaders = {}
      }
      this.#headers.append(name, value)
    } else {
      if (this.#headers) {
        this.#headers.set(name, value)
      } else {
        this.#preparedHeaders ??= {}
        this.#preparedHeaders[name.toLowerCase()] = value
      }
    }

    if (this.finalized) {
      if (options?.append) {
        this.res.headers.append(name, value)
      } else {
        this.res.headers.set(name, value)
      }
    }
  }

  status = (status: StatusCode): void => {
    this.#isFresh = false
    this.#status = status
  }

  /**
   * `.set()` can set the value specified by the key.
   *
   * @see {@link https://hono.dev/docs/api/context#set-get}
   *
   * @example
   * ```ts
   * app.use('*', async (c, next) => {
   *   c.set('message', 'Hono is hot!!')
   *   await next()
   * })
   * ```
   */
  set: Set<
    IsAny<E> extends true
      ? {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          Variables: ContextVariableMap & Record<string, any>
        }
      : E
  > = (key: string, value: unknown) => {
    this.#var ??= new Map()
    this.#var.set(key, value)
  }

  /**
   * `.get()` can use the value specified by the key.
   *
   * @see {@link https://hono.dev/docs/api/context#set-get}
   *
   * @example
   * ```ts
   * app.get('/', (c) => {
   *   const message = c.get('message')
   *   return c.text(`The message is "${message}"`)
   * })
   * ```
   */
  get: Get<
    IsAny<E> extends true
      ? {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          Variables: ContextVariableMap & Record<string, any>
        }
      : E
  > = (key: string) => {
    return this.#var ? this.#var.get(key) : undefined
  }

  /**
   * `.var` can access the value of a variable.
   *
   * @see {@link https://hono.dev/docs/api/context#var}
   *
   * @example
   * ```ts
   * const result = c.var.client.oneMethod()
   * ```
   */
  // c.var.propName is a read-only
  get var(): Readonly<
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ContextVariableMap & (IsAny<E['Variables']> extends true ? Record<string, any> : E['Variables'])
  > {
    if (!this.#var) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return {} as any
    }
    return Object.fromEntries(this.#var)
  }

  #newResponse(
    data: Data | null,
    arg?: StatusCode | ResponseOrInit,
    headers?: HeaderRecord
  ): Response {
    // Optimized
    if (this.#isFresh && !headers && !arg && this.#status === 200) {
      return new Response(data, {
        headers: this.#preparedHeaders,
      })
    }

    if (arg && typeof arg !== 'number') {
      const header = new Headers(arg.headers)
      if (this.#headers) {
        // If the header is set by c.header() and arg.headers, c.header() will be prioritized.
        this.#headers.forEach((v, k) => {
          if (k === 'set-cookie') {
            header.append(k, v)
          } else {
            header.set(k, v)
          }
        })
      }
      const headers = setHeaders(header, this.#preparedHeaders)
      return new Response(data, {
        headers,
        status: arg.status ?? this.#status,
      })
    }

    const status = typeof arg === 'number' ? arg : this.#status
    this.#preparedHeaders ??= {}

    this.#headers ??= new Headers()
    setHeaders(this.#headers, this.#preparedHeaders)

    if (this.#res) {
      this.#res.headers.forEach((v, k) => {
        if (k === 'set-cookie') {
          this.#headers?.append(k, v)
        } else {
          this.#headers?.set(k, v)
        }
      })
      setHeaders(this.#headers, this.#preparedHeaders)
    }

    headers ??= {}
    for (const [k, v] of Object.entries(headers)) {
      if (typeof v === 'string') {
        this.#headers.set(k, v)
      } else {
        this.#headers.delete(k)
        for (const v2 of v) {
          this.#headers.append(k, v2)
        }
      }
    }

    return new Response(data, {
      status,
      headers: this.#headers,
    })
  }

  newResponse: NewResponse = (...args) => this.#newResponse(...(args as Parameters<NewResponse>))

  /**
   * `.body()` can return the HTTP response.
   * You can set headers with `.header()` and set HTTP status code with `.status`.
   * This can also be set in `.text()`, `.json()` and so on.
   *
   * @see {@link https://hono.dev/docs/api/context#body}
   *
   * @example
   * ```ts
   * app.get('/welcome', (c) => {
   *   // Set headers
   *   c.header('X-Message', 'Hello!')
   *   c.header('Content-Type', 'text/plain')
   *   // Set HTTP status code
   *   c.status(201)
   *
   *   // Return the response body
   *   return c.body('Thank you for coming')
   * })
   * ```
   */
  body: BodyRespond = (
    data: Data | null,
    arg?: StatusCode | RequestInit,
    headers?: HeaderRecord
  ): ReturnType<BodyRespond> => {
    return (
      typeof arg === 'number' ? this.#newResponse(data, arg, headers) : this.#newResponse(data, arg)
    ) as ReturnType<BodyRespond>
  }

  /**
   * `.text()` can render text as `Content-Type:text/plain`.
   *
   * @see {@link https://hono.dev/docs/api/context#text}
   *
   * @example
   * ```ts
   * app.get('/say', (c) => {
   *   return c.text('Hello!')
   * })
   * ```
   */
  text: TextRespond = (
    text: string,
    arg?: ContentfulStatusCode | ResponseOrInit,
    headers?: HeaderRecord
  ): ReturnType<TextRespond> => {
    // If the header is empty, return Response immediately.
    // Content-Type will be added automatically as `text/plain`.
    if (!this.#preparedHeaders) {
      if (this.#isFresh && !headers && !arg) {
        // @ts-expect-error `Response` due to missing some types-only keys
        return new Response(text)
      }
      this.#preparedHeaders = {}
    }
    this.#preparedHeaders['content-type'] = TEXT_PLAIN
    if (typeof arg === 'number') {
      // @ts-expect-error `Response` due to missing some types-only keys
      return this.#newResponse(text, arg, headers)
    }
    // @ts-expect-error `Response` due to missing some types-only keys
    return this.#newResponse(text, arg)
  }

  /**
   * `.json()` can render JSON as `Content-Type:application/json`.
   *
   * @see {@link https://hono.dev/docs/api/context#json}
   *
   * @example
   * ```ts
   * app.get('/api', (c) => {
   *   return c.json({ message: 'Hello!' })
   * })
   * ```
   */
  json: JSONRespond = <
    T extends JSONValue | SimplifyDeepArray<unknown> | InvalidJSONValue,
    U extends ContentfulStatusCode = ContentfulStatusCode
  >(
    object: T,
    arg?: U | ResponseOrInit<U>,
    headers?: HeaderRecord
  ): JSONRespondReturn<T, U> => {
    const body = JSON.stringify(object)
    this.#preparedHeaders ??= {}
    this.#preparedHeaders['content-type'] = 'application/json'
    /* eslint-disable @typescript-eslint/no-explicit-any */
    return (
      typeof arg === 'number' ? this.#newResponse(body, arg, headers) : this.#newResponse(body, arg)
    ) as any
  }

  html: HTMLRespond = (
    html: string | Promise<string>,
    arg?: ContentfulStatusCode | ResponseOrInit<ContentfulStatusCode>,
    headers?: HeaderRecord
  ): Response | Promise<Response> => {
    this.#preparedHeaders ??= {}
    this.#preparedHeaders['content-type'] = 'text/html; charset=UTF-8'

    if (typeof html === 'object') {
      return resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then((html) => {
        return typeof arg === 'number'
          ? this.#newResponse(html, arg, headers)
          : this.#newResponse(html, arg)
      })
    }

    return typeof arg === 'number'
      ? this.#newResponse(html as string, arg, headers)
      : this.#newResponse(html as string, arg)
  }

  /**
   * `.redirect()` can Redirect, default status code is 302.
   *
   * @see {@link https://hono.dev/docs/api/context#redirect}
   *
   * @example
   * ```ts
   * app.get('/redirect', (c) => {
   *   return c.redirect('/')
   * })
   * app.get('/redirect-permanently', (c) => {
   *   return c.redirect('/', 301)
   * })
   * ```
   */
  redirect = <T extends RedirectStatusCode = 302>(
    location: string | URL,
    status?: T
  ): Response & TypedResponse<undefined, T, 'redirect'> => {
    this.#headers ??= new Headers()
    this.#headers.set('Location', String(location))
    return this.newResponse(null, status ?? 302) as any
  }

  /**
   * `.notFound()` can return the Not Found Response.
   *
   * @see {@link https://hono.dev/docs/api/context#notfound}
   *
   * @example
   * ```ts
   * app.get('/notfound', (c) => {
   *   return c.notFound()
   * })
   * ```
   */
  notFound = (): Response | Promise<Response> => {
    this.#notFoundHandler ??= () => new Response()
    return this.#notFoundHandler(this)
  }
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/hono-base.ts
````typescript
/**
 * @module
 * This module is the base module for the Hono object.
 */

/* eslint-disable @typescript-eslint/no-explicit-any */
import { compose } from './compose'
import { Context } from './context'
import type { ExecutionContext } from './context'
import type { Router } from './router'
import { METHODS, METHOD_NAME_ALL, METHOD_NAME_ALL_LOWERCASE } from './router'
import type {
  Env,
  ErrorHandler,
  FetchEventLike,
  H,
  HTTPResponseError,
  HandlerInterface,
  MergePath,
  MergeSchemaPath,
  MiddlewareHandler,
  MiddlewareHandlerInterface,
  Next,
  NotFoundHandler,
  OnHandlerInterface,
  RouterRoute,
  Schema,
} from './types'
import { COMPOSED_HANDLER } from './utils/constants'
import { getPath, getPathNoStrict, mergePath } from './utils/url'

const notFoundHandler = (c: Context) => {
  return c.text('404 Not Found', 404)
}

const errorHandler = (err: Error | HTTPResponseError, c: Context) => {
  if ('getResponse' in err) {
    return err.getResponse()
  }
  console.error(err)
  return c.text('Internal Server Error', 500)
}

type GetPath<E extends Env> = (request: Request, options?: { env?: E['Bindings'] }) => string

export type HonoOptions<E extends Env> = {
  /**
   * `strict` option specifies whether to distinguish whether the last path is a directory or not.
   *
   * @see {@link https://hono.dev/docs/api/hono#strict-mode}
   *
   * @default true
   */
  strict?: boolean
  /**
   * `router` option specifies which router to use.
   *
   * @see {@link https://hono.dev/docs/api/hono#router-option}
   *
   * @example
   * ```ts
   * const app = new Hono({ router: new RegExpRouter() })
   * ```
   */
  router?: Router<[H, RouterRoute]>
  /**
   * `getPath` can handle the host header value.
   *
   * @see {@link https://hono.dev/docs/api/routing#routing-with-host-header-value}
   *
   * @example
   * ```ts
   * const app = new Hono({
   *  getPath: (req) =>
   *   '/' + req.headers.get('host') + req.url.replace(/^https?:\/\/[^/]+(\/[^?]*)/, '$1'),
   * })
   *
   * app.get('/www1.example.com/hello', () => c.text('hello www1'))
   *
   * // A following request will match the route:
   * // new Request('http://www1.example.com/hello', {
   * //  headers: { host: 'www1.example.com' },
   * // })
   * ```
   */
  getPath?: GetPath<E>
}

type MountOptionHandler = (c: Context) => unknown
type MountReplaceRequest = (originalRequest: Request) => Request
type MountOptions =
  | MountOptionHandler
  | {
      optionHandler?: MountOptionHandler
      replaceRequest?: MountReplaceRequest
    }

class Hono<E extends Env = Env, S extends Schema = {}, BasePath extends string = '/'> {
  get!: HandlerInterface<E, 'get', S, BasePath>
  post!: HandlerInterface<E, 'post', S, BasePath>
  put!: HandlerInterface<E, 'put', S, BasePath>
  delete!: HandlerInterface<E, 'delete', S, BasePath>
  options!: HandlerInterface<E, 'options', S, BasePath>
  patch!: HandlerInterface<E, 'patch', S, BasePath>
  all!: HandlerInterface<E, 'all', S, BasePath>
  on: OnHandlerInterface<E, S, BasePath>
  use: MiddlewareHandlerInterface<E, S, BasePath>

  /*
    This class is like an abstract class and does not have a router.
    To use it, inherit the class and implement router in the constructor.
  */
  router!: Router<[H, RouterRoute]>
  readonly getPath: GetPath<E>
  // Cannot use `#` because it requires visibility at JavaScript runtime.
  private _basePath: string = '/'
  #path: string = '/'

  routes: RouterRoute[] = []

  constructor(options: HonoOptions<E> = {}) {
    // Implementation of app.get(...handlers[]) or app.get(path, ...handlers[])
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE]
    allMethods.forEach((method) => {
      this[method] = (args1: string | H, ...args: H[]) => {
        if (typeof args1 === 'string') {
          this.#path = args1
        } else {
          this.#addRoute(method, this.#path, args1)
        }
        args.forEach((handler) => {
          this.#addRoute(method, this.#path, handler)
        })
        return this as any
      }
    })

    // Implementation of app.on(method, path, ...handlers[])
    this.on = (method: string | string[], path: string | string[], ...handlers: H[]) => {
      for (const p of [path].flat()) {
        this.#path = p
        for (const m of [method].flat()) {
          handlers.map((handler) => {
            this.#addRoute(m.toUpperCase(), this.#path, handler)
          })
        }
      }
      return this as any
    }

    // Implementation of app.use(...handlers[]) or app.use(path, ...handlers[])
    this.use = (arg1: string | MiddlewareHandler<any>, ...handlers: MiddlewareHandler<any>[]) => {
      if (typeof arg1 === 'string') {
        this.#path = arg1
      } else {
        this.#path = '*'
        handlers.unshift(arg1)
      }
      handlers.forEach((handler) => {
        this.#addRoute(METHOD_NAME_ALL, this.#path, handler)
      })
      return this as any
    }

    const { strict, ...optionsWithoutStrict } = options
    Object.assign(this, optionsWithoutStrict)
    this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict
  }

  #clone(): Hono<E, S, BasePath> {
    const clone = new Hono<E, S, BasePath>({
      router: this.router,
      getPath: this.getPath,
    })
    clone.routes = this.routes
    return clone
  }

  #notFoundHandler: NotFoundHandler = notFoundHandler
  // Cannot use `#` because it requires visibility at JavaScript runtime.
  private errorHandler: ErrorHandler = errorHandler

  /**
   * `.route()` allows grouping other Hono instance in routes.
   *
   * @see {@link https://hono.dev/docs/api/routing#grouping}
   *
   * @param {string} path - base Path
   * @param {Hono} app - other Hono instance
   * @returns {Hono} routed Hono instance
   *
   * @example
   * ```ts
   * const app = new Hono()
   * const app2 = new Hono()
   *
   * app2.get("/user", (c) => c.text("user"))
   * app.route("/api", app2) // GET /api/user
   * ```
   */
  route<
    SubPath extends string,
    SubEnv extends Env,
    SubSchema extends Schema,
    SubBasePath extends string
  >(
    path: SubPath,
    app: Hono<SubEnv, SubSchema, SubBasePath>
  ): Hono<E, MergeSchemaPath<SubSchema, MergePath<BasePath, SubPath>> | S, BasePath> {
    const subApp = this.basePath(path)
    app.routes.map((r) => {
      let handler
      if (app.errorHandler === errorHandler) {
        handler = r.handler
      } else {
        handler = async (c: Context, next: Next) =>
          (await compose([], app.errorHandler)(c, () => r.handler(c, next))).res
        ;(handler as any)[COMPOSED_HANDLER] = r.handler
      }

      subApp.#addRoute(r.method, r.path, handler)
    })
    return this
  }

  /**
   * `.basePath()` allows base paths to be specified.
   *
   * @see {@link https://hono.dev/docs/api/routing#base-path}
   *
   * @param {string} path - base Path
   * @returns {Hono} changed Hono instance
   *
   * @example
   * ```ts
   * const api = new Hono().basePath('/api')
   * ```
   */
  basePath<SubPath extends string>(path: SubPath): Hono<E, S, MergePath<BasePath, SubPath>> {
    const subApp = this.#clone()
    subApp._basePath = mergePath(this._basePath, path)
    return subApp
  }

  /**
   * `.onError()` handles an error and returns a customized Response.
   *
   * @see {@link https://hono.dev/docs/api/hono#error-handling}
   *
   * @param {ErrorHandler} handler - request Handler for error
   * @returns {Hono} changed Hono instance
   *
   * @example
   * ```ts
   * app.onError((err, c) => {
   *   console.error(`${err}`)
   *   return c.text('Custom Error Message', 500)
   * })
   * ```
   */
  onError = (handler: ErrorHandler<E>): Hono<E, S, BasePath> => {
    this.errorHandler = handler
    return this
  }

  /**
   * `.notFound()` allows you to customize a Not Found Response.
   *
   * @see {@link https://hono.dev/docs/api/hono#not-found}
   *
   * @param {NotFoundHandler} handler - request handler for not-found
   * @returns {Hono} changed Hono instance
   *
   * @example
   * ```ts
   * app.notFound((c) => {
   *   return c.text('Custom 404 Message', 404)
   * })
   * ```
   */
  notFound = (handler: NotFoundHandler<E>): Hono<E, S, BasePath> => {
    this.#notFoundHandler = handler
    return this
  }

  /**
   * `.mount()` allows you to mount applications built with other frameworks into your Hono application.
   *
   * @see {@link https://hono.dev/docs/api/hono#mount}
   *
   * @param {string} path - base Path
   * @param {Function} applicationHandler - other Request Handler
   * @param {MountOptions} [options] - options of `.mount()`
   * @returns {Hono} mounted Hono instance
   *
   * @example
   * ```ts
   * import { Router as IttyRouter } from 'itty-router'
   * import { Hono } from 'hono'
   * // Create itty-router application
   * const ittyRouter = IttyRouter()
   * // GET /itty-router/hello
   * ittyRouter.get('/hello', () => new Response('Hello from itty-router'))
   *
   * const app = new Hono()
   * app.mount('/itty-router', ittyRouter.handle)
   * ```
   *
   * @example
   * ```ts
   * const app = new Hono()
   * // Send the request to another application without modification.
   * app.mount('/app', anotherApp, {
   *   replaceRequest: (req) => req,
   * })
   * ```
   */
  mount(
    path: string,
    applicationHandler: (request: Request, ...args: any) => Response | Promise<Response>,
    options?: MountOptions
  ): Hono<E, S, BasePath> {
    // handle options
    let replaceRequest: MountReplaceRequest | undefined
    let optionHandler: MountOptionHandler | undefined
    if (options) {
      if (typeof options === 'function') {
        optionHandler = options
      } else {
        optionHandler = options.optionHandler
        replaceRequest = options.replaceRequest
      }
    }

    // prepare handlers for request
    const getOptions: (c: Context) => unknown[] = optionHandler
      ? (c) => {
          const options = optionHandler!(c)
          return Array.isArray(options) ? options : [options]
        }
      : (c) => {
          let executionContext: ExecutionContext | undefined = undefined
          try {
            executionContext = c.executionCtx
          } catch {} // Do nothing
          return [c.env, executionContext]
        }
    replaceRequest ||= (() => {
      const mergedPath = mergePath(this._basePath, path)
      const pathPrefixLength = mergedPath === '/' ? 0 : mergedPath.length
      return (request) => {
        const url = new URL(request.url)
        url.pathname = url.pathname.slice(pathPrefixLength) || '/'
        return new Request(url, request)
      }
    })()

    const handler: MiddlewareHandler = async (c, next) => {
      const res = await applicationHandler(replaceRequest!(c.req.raw), ...getOptions(c))

      if (res) {
        return res
      }

      await next()
    }
    this.#addRoute(METHOD_NAME_ALL, mergePath(path, '*'), handler)
    return this
  }

  #addRoute(method: string, path: string, handler: H) {
    method = method.toUpperCase()
    path = mergePath(this._basePath, path)
    const r: RouterRoute = { path, method, handler }
    this.router.add(method, path, [handler, r])
    this.routes.push(r)
  }

  #handleError(err: unknown, c: Context<E>) {
    if (err instanceof Error) {
      return this.errorHandler(err, c)
    }
    throw err
  }

  #dispatch(
    request: Request,
    executionCtx: ExecutionContext | FetchEventLike | undefined,
    env: E['Bindings'],
    method: string
  ): Response | Promise<Response> {
    // Handle HEAD method
    if (method === 'HEAD') {
      return (async () =>
        new Response(null, await this.#dispatch(request, executionCtx, env, 'GET')))()
    }

    const path = this.getPath(request, { env })
    const matchResult = this.router.match(method, path)

    const c = new Context(request, {
      path,
      matchResult,
      env,
      executionCtx,
      notFoundHandler: this.#notFoundHandler,
    })

    // Do not `compose` if it has only one handler
    if (matchResult[0].length === 1) {
      let res: ReturnType<H>
      try {
        res = matchResult[0][0][0][0](c, async () => {
          c.res = await this.#notFoundHandler(c)
        })
      } catch (err) {
        return this.#handleError(err, c)
      }

      return res instanceof Promise
        ? res
            .then(
              (resolved: Response | undefined) =>
                resolved || (c.finalized ? c.res : this.#notFoundHandler(c))
            )
            .catch((err: Error) => this.#handleError(err, c))
        : res ?? this.#notFoundHandler(c)
    }

    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler)

    return (async () => {
      try {
        const context = await composed(c)
        if (!context.finalized) {
          throw new Error(
            'Context is not finalized. Did you forget to return a Response object or `await next()`?'
          )
        }

        return context.res
      } catch (err) {
        return this.#handleError(err, c)
      }
    })()
  }

  /**
   * `.fetch()` will be entry point of your app.
   *
   * @see {@link https://hono.dev/docs/api/hono#fetch}
   *
   * @param {Request} request - request Object of request
   * @param {Env} Env - env Object
   * @param {ExecutionContext} - context of execution
   * @returns {Response | Promise<Response>} response of request
   *
   */
  fetch: (
    request: Request,
    Env?: E['Bindings'] | {},
    executionCtx?: ExecutionContext
  ) => Response | Promise<Response> = (request, ...rest) => {
    return this.#dispatch(request, rest[1], rest[0], request.method)
  }

  /**
   * `.request()` is a useful method for testing.
   * You can pass a URL or pathname to send a GET request.
   * app will return a Response object.
   * ```ts
   * test('GET /hello is ok', async () => {
   *   const res = await app.request('/hello')
   *   expect(res.status).toBe(200)
   * })
   * ```
   * @see https://hono.dev/docs/api/hono#request
   */
  request = (
    input: RequestInfo | URL,
    requestInit?: RequestInit,
    Env?: E['Bindings'] | {},
    executionCtx?: ExecutionContext
  ): Response | Promise<Response> => {
    if (input instanceof Request) {
      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx)
    }
    input = input.toString()
    return this.fetch(
      new Request(
        /^https?:\/\//.test(input) ? input : `http://localhost${mergePath('/', input)}`,
        requestInit
      ),
      Env,
      executionCtx
    )
  }

  /**
   * `.fire()` automatically adds a global fetch event listener.
   * This can be useful for environments that adhere to the Service Worker API, such as non-ES module Cloudflare Workers.
   * @see https://hono.dev/docs/api/hono#fire
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API
   * @see https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/
   */
  fire = (): void => {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    addEventListener('fetch', (event: FetchEventLike): void => {
      event.respondWith(this.#dispatch(event.request, event, undefined, event.request.method))
    })
  }
}

export { Hono as HonoBase }

````
/Users/josh/Documents/GitHub/honojs/hono/src/hono.test.ts
```typescript
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-ts-comment */
import { expectTypeOf } from 'vitest'
import { hc } from './client'
import type { Context, ExecutionContext } from './context'
import { Hono } from './hono'
import { HTTPException } from './http-exception'
import { logger } from './middleware/logger'
import { poweredBy } from './middleware/powered-by'
import { RegExpRouter } from './router/reg-exp-router'
import { SmartRouter } from './router/smart-router'
import { TrieRouter } from './router/trie-router'
import type { Handler, MiddlewareHandler, Next } from './types'
import type { Equal, Expect } from './utils/types'
import { getPath } from './utils/url'

// https://stackoverflow.com/a/65666402
function throwExpression(errorMessage: string): never {
  throw new Error(errorMessage)
}

type Env = {
  Bindings: {
    _: string
  }
}

describe('GET Request', () => {
  describe('without middleware', () => {
    // In other words, this is a test for cases that do not use `compose()`

    const app = new Hono<Env>()

    app.get('/hello', async () => {
      return new Response('hello', {
        status: 200,
        statusText: 'Hono is OK',
      })
    })

    app.get('/hello-with-shortcuts', (c) => {
      c.header('X-Custom', 'This is Hono')
      c.status(201)
      return c.html('<h1>Hono!!!</h1>')
    })

    app.get('/hello-env', (c) => {
      return c.json(c.env)
    })

    app.get(
      '/proxy-object',
      () =>
        new Proxy(new Response('proxy'), {
          get(target, prop: keyof Response) {
            return target[prop]
          },
        })
    )

    app.get(
      '/async-proxy-object',
      async () =>
        new Proxy(new Response('proxy'), {
          get(target, prop: keyof Response) {
            return target[prop]
          },
        })
    )

    it('GET http://localhost/hello is ok', async () => {
      const res = await app.request('http://localhost/hello')
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(res.statusText).toBe('Hono is OK')
      expect(await res.text()).toBe('hello')
    })

    it('GET httphello is ng', async () => {
      const res = await app.request('httphello')
      expect(res.status).toBe(404)
    })

    it('GET /hello is ok', async () => {
      const res = await app.request('/hello')
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(res.statusText).toBe('Hono is OK')
      expect(await res.text()).toBe('hello')
    })

    it('GET hello is ok', async () => {
      const res = await app.request('hello')
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(res.statusText).toBe('Hono is OK')
      expect(await res.text()).toBe('hello')
    })

    it('GET /hello-with-shortcuts is ok', async () => {
      const res = await app.request('http://localhost/hello-with-shortcuts')
      expect(res).not.toBeNull()
      expect(res.status).toBe(201)
      expect(res.headers.get('X-Custom')).toBe('This is Hono')
      expect(res.headers.get('Content-Type')).toMatch(/text\/html/)
      expect(await res.text()).toBe('<h1>Hono!!!</h1>')
    })

    it('GET / is not found', async () => {
      const res = await app.request('http://localhost/')
      expect(res).not.toBeNull()
      expect(res.status).toBe(404)
    })

    it('GET /hello-env is ok', async () => {
      const res = await app.request('/hello-env', undefined, { HELLO: 'world' })
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ HELLO: 'world' })
    })

    it('GET /proxy-object is ok', async () => {
      const res = await app.request('/proxy-object')
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('proxy')
    })

    it('GET /async-proxy-object is ok', async () => {
      const res = await app.request('/proxy-object')
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('proxy')
    })
  })

  describe('with middleware', () => {
    // when using `compose()`

    const app = new Hono<Env>()

    app.use('*', async (ctx, next) => {
      await next()
    })

    app.get('/hello', async () => {
      return new Response('hello', {
        status: 200,
        statusText: 'Hono is OK',
      })
    })

    app.get('/hello-with-shortcuts', (c) => {
      c.header('X-Custom', 'This is Hono')
      c.status(201)
      return c.html('<h1>Hono!!!</h1>')
    })

    app.get('/hello-env', (c) => {
      return c.json(c.env)
    })

    app.get(
      '/proxy-object',
      () =>
        new Proxy(new Response('proxy'), {
          get(target, prop: keyof Response) {
            return target[prop]
          },
        })
    )

    app.get(
      '/async-proxy-object',
      async () =>
        new Proxy(new Response('proxy'), {
          get(target, prop: keyof Response) {
            return target[prop]
          },
        })
    )

    it('GET http://localhost/hello is ok', async () => {
      const res = await app.request('http://localhost/hello')
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(res.statusText).toBe('Hono is OK')
      expect(await res.text()).toBe('hello')
    })

    it('GET httphello is ng', async () => {
      const res = await app.request('httphello')
      expect(res.status).toBe(404)
    })

    it('GET /hello is ok', async () => {
      const res = await app.request('/hello')
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(res.statusText).toBe('Hono is OK')
      expect(await res.text()).toBe('hello')
    })

    it('GET hello is ok', async () => {
      const res = await app.request('hello')
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(res.statusText).toBe('Hono is OK')
      expect(await res.text()).toBe('hello')
    })

    it('GET /hello-with-shortcuts is ok', async () => {
      const res = await app.request('http://localhost/hello-with-shortcuts')
      expect(res).not.toBeNull()
      expect(res.status).toBe(201)
      expect(res.headers.get('X-Custom')).toBe('This is Hono')
      expect(res.headers.get('Content-Type')).toMatch(/text\/html/)
      expect(await res.text()).toBe('<h1>Hono!!!</h1>')
    })

    it('GET / is not found', async () => {
      const res = await app.request('http://localhost/')
      expect(res).not.toBeNull()
      expect(res.status).toBe(404)
    })

    it('GET /hello-env is ok', async () => {
      const res = await app.request('/hello-env', undefined, { HELLO: 'world' })
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ HELLO: 'world' })
    })

    it('GET /proxy-object is ok', async () => {
      const res = await app.request('/proxy-object')
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('proxy')
    })

    it('GET /async-proxy-object is ok', async () => {
      const res = await app.request('/proxy-object')
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('proxy')
    })
  })
})

describe('Register handlers without a path', () => {
  describe('No basePath', () => {
    const app = new Hono()

    app.get((c) => {
      return c.text('Hello')
    })

    it('GET http://localhost/ is ok', async () => {
      const res = await app.request('/')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('Hello')
    })

    it('GET http://localhost/anything is ok', async () => {
      const res = await app.request('/')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('Hello')
    })
  })

  describe('With specifying basePath', () => {
    const app = new Hono().basePath('/about')

    app.get((c) => {
      return c.text('About')
    })

    it('GET http://localhost/about is ok', async () => {
      const res = await app.request('/about')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('About')
    })

    it('GET http://localhost/ is not found', async () => {
      const res = await app.request('/')
      expect(res.status).toBe(404)
    })
  })

  describe('With chaining', () => {
    const app = new Hono()

    app.post('/books').get((c) => {
      return c.text('Books')
    })

    it('GET http://localhost/books is ok', async () => {
      const res = await app.request('/books')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('Books')
    })

    it('GET http://localhost/ is not found', async () => {
      const res = await app.request('/')
      expect(res.status).toBe(404)
    })
  })
})

describe('Options', () => {
  describe('router option', () => {
    it('Should be SmartRouter', () => {
      const app = new Hono()
      expect(app.router instanceof SmartRouter).toBe(true)
    })
    it('Should be RegExpRouter', () => {
      const app = new Hono({
        router: new RegExpRouter(),
      })
      expect(app.router instanceof RegExpRouter).toBe(true)
    })
  })

  describe('strict parameter', () => {
    describe('strict is true with not slash', () => {
      const app = new Hono()

      app.get('/hello', (c) => {
        return c.text('/hello')
      })

      it('/hello/ is not found', async () => {
        let res = await app.request('http://localhost/hello')
        expect(res).not.toBeNull()
        expect(res.status).toBe(200)
        res = await app.request('http://localhost/hello/')
        expect(res).not.toBeNull()
        expect(res.status).toBe(404)
      })
    })

    describe('strict is true with slash', () => {
      const app = new Hono()

      app.get('/hello/', (c) => {
        return c.text('/hello/')
      })

      it('/hello is not found', async () => {
        let res = await app.request('http://localhost/hello/')
        expect(res).not.toBeNull()
        expect(res.status).toBe(200)
        res = await app.request('http://localhost/hello')
        expect(res).not.toBeNull()
        expect(res.status).toBe(404)
      })
    })

    describe('strict is false', () => {
      const app = new Hono({ strict: false })

      app.get('/hello', (c) => {
        return c.text('/hello')
      })

      it('/hello and /hello/ are treated as the same', async () => {
        let res = await app.request('http://localhost/hello')
        expect(res).not.toBeNull()
        expect(res.status).toBe(200)
        res = await app.request('http://localhost/hello/')
        expect(res).not.toBeNull()
        expect(res.status).toBe(200)
      })
    })

    describe('strict is false with `getPath` option', () => {
      const app = new Hono({
        strict: false,
        getPath: getPath,
      })

      app.get('/hello', (c) => {
        return c.text('/hello')
      })

      it('/hello and /hello/ are treated as the same', async () => {
        let res = await app.request('http://localhost/hello')
        expect(res).not.toBeNull()
        expect(res.status).toBe(200)
        res = await app.request('http://localhost/hello/')
        expect(res).not.toBeNull()
        expect(res.status).toBe(200)
      })
    })
  })

  it('Should not modify the options passed to it', () => {
    const options = { strict: true }
    const clone = structuredClone(options)
    const app = new Hono(clone)
    expect(clone).toEqual(options)
  })
})

describe('Destruct functions in context', () => {
  it('Should return 200 response - text', async () => {
    const app = new Hono()
    app.get('/text', ({ text }) => text('foo'))
    const res = await app.request('http://localhost/text')
    expect(res.status).toBe(200)
  })
  it('Should return 200 response - json', async () => {
    const app = new Hono()
    app.get('/json', ({ json }) => json({ foo: 'bar' }))
    const res = await app.request('http://localhost/json')
    expect(res.status).toBe(200)
  })
})

describe('Routing', () => {
  it('Return it self', async () => {
    const app = new Hono()

    const app2 = app.get('/', () => new Response('get /'))
    expect(app2).not.toBeUndefined()
    app2.delete('/', () => new Response('delete /'))

    let res = await app2.request('http://localhost/', { method: 'GET' })
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('get /')

    res = await app2.request('http://localhost/', { method: 'DELETE' })
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('delete /')
  })

  it('Nested route', async () => {
    const app = new Hono()

    const book = app.basePath('/book')
    book.get('/', (c) => c.text('get /book'))
    book.get('/:id', (c) => {
      return c.text('get /book/' + c.req.param('id'))
    })
    book.post('/', (c) => c.text('post /book'))

    const user = app.basePath('/user')
    user.get('/login', (c) => c.text('get /user/login'))
    user.post('/register', (c) => c.text('post /user/register'))

    const appForEachUser = user.basePath(':id')
    appForEachUser.get('/profile', (c) => c.text('get /user/' + c.req.param('id') + '/profile'))

    app.get('/add-path-after-route-call', (c) => c.text('get /add-path-after-route-call'))

    let res = await app.request('http://localhost/book', { method: 'GET' })
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('get /book')

    res = await app.request('http://localhost/book/123', { method: 'GET' })
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('get /book/123')

    res = await app.request('http://localhost/book', { method: 'POST' })
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('post /book')

    res = await app.request('http://localhost/book/', { method: 'GET' })
    expect(res.status).toBe(404)

    res = await app.request('http://localhost/user/login', { method: 'GET' })
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('get /user/login')

    res = await app.request('http://localhost/user/register', { method: 'POST' })
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('post /user/register')

    res = await app.request('http://localhost/user/123/profile', { method: 'GET' })
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('get /user/123/profile')

    res = await app.request('http://localhost/add-path-after-route-call', { method: 'GET' })
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('get /add-path-after-route-call')
  })

  it('Nested route - subApp with basePath', async () => {
    const app = new Hono()
    const book = new Hono().basePath('/book')
    book.get('/', (c) => c.text('get /book'))
    app.route('/api', book)

    const res = await app.request('http://localhost/api/book', { method: 'GET' })
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('get /book')
  })

  it('Multiple route', async () => {
    const app = new Hono()

    const book = new Hono()
    book.get('/hello', (c) => c.text('get /book/hello'))

    const user = new Hono()
    user.get('/hello', (c) => c.text('get /user/hello'))

    app.route('/book', book).route('/user', user)

    let res = await app.request('http://localhost/book/hello', { method: 'GET' })
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('get /book/hello')

    res = await app.request('http://localhost/user/hello', { method: 'GET' })
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('get /user/hello')
  })

  describe('Nested route with middleware', () => {
    const api = new Hono()
    const api2 = api.use('*', async (_c, next) => await next())

    it('Should mount routes with no type errors', () => {
      const app = new Hono().route('/api', api2)
    })
  })

  describe('Grouped route', () => {
    let one: Hono, two: Hono, three: Hono

    beforeEach(() => {
      one = new Hono()
      two = new Hono()
      three = new Hono()
    })

    it('only works with correct order', async () => {
      three.get('/hi', (c) => c.text('hi'))
      two.route('/three', three)
      one.route('/two', two)

      const { status } = await one.request('http://localhost/two/three/hi', { method: 'GET' })
      expect(status).toBe(200)
    })

    it('fails with incorrect order 1', async () => {
      three.get('/hi', (c) => c.text('hi'))
      one.route('/two', two)
      two.route('/three', three)

      const { status } = await one.request('http://localhost/two/three/hi', { method: 'GET' })
      expect(status).toBe(404)
    })

    it('fails with incorrect order 2', async () => {
      two.route('/three', three)
      three.get('/hi', (c) => c.text('hi'))
      one.route('/two', two)

      const { status } = await one.request('http://localhost/two/three/hi', { method: 'GET' })
      expect(status).toBe(404)
    })

    it('fails with incorrect order 3', async () => {
      two.route('/three', three)
      one.route('/two', two)
      three.get('/hi', (c) => c.text('hi'))

      const { status } = await one.request('http://localhost/two/three/hi', { method: 'GET' })
      expect(status).toBe(404)
    })

    it('fails with incorrect order 4', async () => {
      one.route('/two', two)
      three.get('/hi', (c) => c.text('hi'))
      two.route('/three', three)

      const { status } = await one.request('http://localhost/two/three/hi', { method: 'GET' })
      expect(status).toBe(404)
    })

    it('fails with incorrect order 5', async () => {
      one.route('/two', two)
      two.route('/three', three)
      three.get('/hi', (c) => c.text('hi'))

      const { status } = await one.request('http://localhost/two/three/hi', { method: 'GET' })
      expect(status).toBe(404)
    })
  })

  it('routing with hostname', async () => {
    const app = new Hono({
      getPath: (req) => req.url.replace(/^https?:\/(.+?)$/, '$1'),
    })

    const sub = new Hono()
    sub.get('/', (c) => c.text('hello sub'))
    sub.get('/foo', (c) => c.text('hello sub foo'))

    app.get('/www1.example.com/hello', () => new Response('hello www1'))
    app.get('/www2.example.com/hello', () => new Response('hello www2'))

    app.get('/www1.example.com/', (c) => c.text('hello www1 root'))
    app.route('/www1.example.com/sub', sub)

    let res = await app.request('http://www1.example.com/hello')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hello www1')

    res = await app.request('http://www2.example.com/hello')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hello www2')

    res = await app.request('http://www1.example.com/')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hello www1 root')

    res = await app.request('http://www1.example.com/sub')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hello sub')

    res = await app.request('http://www1.example.com/sub/foo')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hello sub foo')
  })

  it('routing with request header', async () => {
    const app = new Hono({
      getPath: (req) =>
        '/' + req.headers.get('host') + req.url.replace(/^https?:\/\/[^/]+(\/[^?]*)/, '$1'),
    })

    const sub = new Hono()
    sub.get('/', (c) => c.text('hello sub'))
    sub.get('/foo', (c) => c.text('hello sub foo'))

    app.get('/www1.example.com/hello', () => new Response('hello www1'))
    app.get('/www2.example.com/hello', () => new Response('hello www2'))

    app.get('/www1.example.com/', (c) => c.text('hello www1 root'))
    app.route('/www1.example.com/sub', sub)

    let res = await app.request('http://www1.example.com/hello', {
      headers: {
        host: 'www1.example.com',
      },
    })
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hello www1')

    res = await app.request('http://www2.example.com/hello', {
      headers: {
        host: 'www2.example.com',
      },
    })
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hello www2')

    res = await app.request('http://www1.example.com/', {
      headers: {
        host: 'www1.example.com',
      },
    })
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hello www1 root')

    res = await app.request('http://www1.example.com/sub', {
      headers: {
        host: 'www1.example.com',
      },
    })
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hello sub')

    res = await app.request('http://www1.example.com/sub/foo', {
      headers: {
        host: 'www1.example.com',
      },
    })
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hello sub foo')
    expect(res.status).toBe(200)
  })

  describe('routing with the bindings value', () => {
    const app = new Hono<{ Bindings: { host: string } }>({
      getPath: (req, options) => {
        const url = new URL(req.url)
        const host = options?.env?.host
        const prefix = url.host === host ? '/FOO' : ''
        return url.pathname === '/' ? prefix : `${prefix}${url.pathname}`
      },
    })

    app.get('/about', (c) => c.text('About root'))
    app.get('/FOO/about', (c) => c.text('About FOO'))

    it('Should return 200 without specifying a hostname', async () => {
      const res = await app.request('/about')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('About root')
    })

    it('Should return 200 with specifying the hostname in env', async () => {
      const req = new Request('http://foo.localhost/about')
      const res = await app.fetch(req, { host: 'foo.localhost' })
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('About FOO')
    })
  })

  describe('Chained route', () => {
    const app = new Hono()

    app
      .get('/chained/:abc', (c) => {
        const abc = c.req.param('abc')
        return c.text(`GET for ${abc}`)
      })
      .post((c) => {
        const abc = c.req.param('abc')
        return c.text(`POST for ${abc}`)
      })
    it('Should return 200 response from GET request', async () => {
      const res = await app.request('http://localhost/chained/abc', { method: 'GET' })
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('GET for abc')
    })
    it('Should return 200 response from POST request', async () => {
      const res = await app.request('http://localhost/chained/abc', { method: 'POST' })
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('POST for abc')
    })
    it('Should return 404 response from PUT request', async () => {
      const res = await app.request('http://localhost/chained/abc', { method: 'PUT' })
      expect(res.status).toBe(404)
    })
  })

  describe('Encoded path', () => {
    let app: Hono
    beforeEach(() => {
      app = new Hono()
    })

    it('should decode path parameter', async () => {
      app.get('/users/:id', (c) => c.text(`id is ${c.req.param('id')}`))

      const res = await app.request('http://localhost/users/%C3%A7awa%20y%C3%AE%3F')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('id is çawa yî?')
    })

    it('should decode "/"', async () => {
      app.get('/users/:id', (c) => c.text(`id is ${c.req.param('id')}`))

      const res = await app.request('http://localhost/users/hono%2Fposts') // %2F is '/'
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('id is hono/posts')
    })

    it('should decode alphabets', async () => {
      app.get('/users/static', (c) => c.text('static'))

      const res = await app.request('http://localhost/users/%73tatic') // %73 is 's'
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('static')
    })

    it('should decode alphabets with invalid UTF-8 sequence', async () => {
      app.get('/static/:path', (c) => {
        return c.text(`by c.req.param: ${c.req.param('path')}`)
      })

      const res = await app.request('http://localhost/%73tatic/%A4%A2') // %73 is 's', %A4%A2 is invalid UTF-8 sequence
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('by c.req.param: %A4%A2')
    })

    it('should decode alphabets with invalid percent encoding', async () => {
      app.get('/static/:path', (c) => {
        return c.text(`by c.req.param: ${c.req.param('path')}`)
      })

      const res = await app.request('http://localhost/%73tatic/%a') // %73 is 's', %a is invalid percent encoding
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('by c.req.param: %a')
    })

    it('should not double decode', async () => {
      app.get('/users/:id', (c) => c.text(`posts of ${c.req.param('id')}`))

      const res = await app.request('http://localhost/users/%2525') // %25 is '%'
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('posts of %25')
    })
  })
})

describe('param and query', () => {
  const apps: Record<string, Hono> = {}
  apps['get by name'] = (() => {
    const app = new Hono()

    app.get('/entry/:id', (c) => {
      const id = c.req.param('id')
      return c.text(`id is ${id}`)
    })

    app.get('/date/:date{[0-9]+}', (c) => {
      const date = c.req.param('date')
      return c.text(`date is ${date}`)
    })

    app.get('/search', (c) => {
      const name = c.req.query('name')
      return c.text(`name is ${name}`)
    })

    app.get('/multiple-values', (c) => {
      const queries = c.req.queries('q') ?? throwExpression('missing query values')
      const limit = c.req.queries('limit') ?? throwExpression('missing query values')
      return c.text(`q is ${queries[0]} and ${queries[1]}, limit is ${limit[0]}`)
    })

    app.get('/add-header', (c) => {
      const bar = c.req.header('X-Foo')
      return c.text(`foo is ${bar}`)
    })

    return app
  })()

  apps['get all as an object'] = (() => {
    const app = new Hono()

    app.get('/entry/:id', (c) => {
      const { id } = c.req.param()
      return c.text(`id is ${id}`)
    })

    app.get('/date/:date{[0-9]+}', (c) => {
      const { date } = c.req.param()
      return c.text(`date is ${date}`)
    })

    app.get('/search', (c) => {
      const { name } = c.req.query()
      return c.text(`name is ${name}`)
    })

    app.get('/multiple-values', (c) => {
      const { q, limit } = c.req.queries()
      return c.text(`q is ${q[0]} and ${q[1]}, limit is ${limit[0]}`)
    })

    app.get('/add-header', (c) => {
      const { 'x-foo': bar } = c.req.header()
      return c.text(`foo is ${bar}`)
    })

    return app
  })()

  describe.each(Object.keys(apps))('%s', (name) => {
    const app = apps[name]

    it('param of /entry/:id is found', async () => {
      const res = await app.request('http://localhost/entry/123')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('id is 123')
    })

    it('param of /entry/:id is found, even for Array object method names', async () => {
      const res = await app.request('http://localhost/entry/key')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('id is key')
    })

    it('param of /entry/:id is decoded', async () => {
      const res = await app.request('http://localhost/entry/%C3%A7awa%20y%C3%AE%3F')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('id is çawa yî?')
    })

    it('param of /date/:date is found', async () => {
      const res = await app.request('http://localhost/date/0401')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('date is 0401')
    })

    it('query of /search?name=sam is found', async () => {
      const res = await app.request('http://localhost/search?name=sam')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('name is sam')
    })

    it('query of /search?name=sam&name=tom is found', async () => {
      const res = await app.request('http://localhost/search?name=sam&name=tom')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('name is sam')
    })

    it('query of /multiple-values?q=foo&q=bar&limit=10 is found', async () => {
      const res = await app.request('http://localhost/multiple-values?q=foo&q=bar&limit=10')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('q is foo and bar, limit is 10')
    })

    it('/add-header header - X-Foo is Bar', async () => {
      const req = new Request('http://localhost/add-header')
      req.headers.append('X-Foo', 'Bar')
      const res = await app.request(req)
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('foo is Bar')
    })
  })

  describe('param with undefined', () => {
    const app = new Hono()
    app.get('/foo/:foo', (c) => {
      const bar = c.req.param('bar')
      return c.json({ foo: bar })
    })
    it('param of /foo/foo should return undefined not "undefined"', async () => {
      const res = await app.request('http://localhost/foo/foo')
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ foo: undefined })
    })
  })
})

describe('c.req.path', () => {
  const app = new Hono()
  app.get('/', (c) => c.text(c.req.path))
  app.get('/search', (c) => c.text(c.req.path))

  it('Should get the path `/` correctly', async () => {
    const res = await app.request('/')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('/')
  })

  it('Should get the path `/search` correctly with a query', async () => {
    const res = await app.request('/search?query=hono')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('/search')
  })
})

describe('Header', () => {
  const app = new Hono()

  app.get('/text', (c) => {
    return c.text('Hello')
  })

  app.get('/text-with-custom-header', (c) => {
    c.header('X-Custom', 'Message')
    return c.text('Hello')
  })

  it('Should return correct headers - /text', async () => {
    const res = await app.request('/text')
    expect(res.status).toBe(200)
    expect(res.headers.get('content-type')).toMatch(/^text\/plain/)
    expect(await res.text()).toBe('Hello')
  })

  it('Should return correct headers - /text-with-custom-header', async () => {
    const res = await app.request('/text-with-custom-header')
    expect(res.status).toBe(200)
    expect(res.headers.get('x-custom')).toBe('Message')
    expect(res.headers.get('content-type')).toMatch(/^text\/plain/)
    expect(await res.text()).toBe('Hello')
  })
})

describe('Middleware', () => {
  describe('Basic', () => {
    const app = new Hono()

    // Custom Logger
    app.use('*', async (c, next) => {
      console.log(`${c.req.method} : ${c.req.url}`)
      await next()
    })

    // Append Custom Header
    app.use('*', async (c, next) => {
      await next()
      c.res.headers.append('x-custom', 'root')
    })

    app.use('/hello', async (c, next) => {
      await next()
      c.res.headers.append('x-message', 'custom-header')
    })

    app.use('/hello/*', async (c, next) => {
      await next()
      c.res.headers.append('x-message-2', 'custom-header-2')
    })

    app.get('/hello', (c) => {
      return c.text('hello')
    })

    app.use('/json/*', async (c, next) => {
      c.res.headers.append('foo', 'bar')
      await next()
    })

    app.get('/json', (c) => {
      // With a raw response
      return new Response(
        JSON.stringify({
          message: 'hello',
        }),
        {
          headers: {
            'content-type': 'application/json',
          },
        }
      )
    })

    app.get('/hello/:message', (c) => {
      const message = c.req.param('message')
      return c.text(`${message}`)
    })

    app.get('/error', () => {
      throw new Error('Error!')
    })

    app.notFound((c) => {
      return c.text('Not Found Foo', 404)
    })

    it('logging and custom header', async () => {
      const res = await app.request('http://localhost/hello')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('hello')
      expect(res.headers.get('x-custom')).toBe('root')
      expect(res.headers.get('x-message')).toBe('custom-header')
      expect(res.headers.get('x-message-2')).toBe('custom-header-2')
    })

    it('logging and custom header with named param', async () => {
      const res = await app.request('http://localhost/hello/message')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('message')
      expect(res.headers.get('x-custom')).toBe('root')
      expect(res.headers.get('x-message-2')).toBe('custom-header-2')
    })

    it('should return correct the content-type header', async () => {
      const res = await app.request('http://localhost/json')
      expect(res.status).toBe(200)
      expect(res.headers.get('content-type')).toMatch(/^application\/json/)
    })

    it('not found', async () => {
      const res = await app.request('http://localhost/foo')
      expect(res.status).toBe(404)
      expect(await res.text()).toBe('Not Found Foo')
    })

    it('internal server error', async () => {
      const res = await app.request('http://localhost/error')
      expect(res.status).toBe(500)
      console.log(await res.text())
    })
  })

  describe('Chained route', () => {
    const app = new Hono()
    app
      .use('/chained/*', async (c, next) => {
        c.req.raw.headers.append('x-before', 'abc')
        await next()
      })
      .use(async (c, next) => {
        await next()
        c.header(
          'x-after',
          c.req.header('x-before') ?? throwExpression('missing `x-before` header')
        )
      })
      .get('/chained/abc', (c) => {
        return c.text('GET chained')
      })
    it('GET /chained/abc', async () => {
      const res = await app.request('http://localhost/chained/abc')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('GET chained')
      expect(res.headers.get('x-after')).toBe('abc')
    })
  })

  describe('Multiple handler', () => {
    const app = new Hono()
    app
      .use(
        '/multiple/*',
        async (c, next) => {
          c.req.raw.headers.append('x-before', 'abc')
          await next()
        },
        async (c, next) => {
          await next()
          c.header(
            'x-after',
            c.req.header('x-before') ?? throwExpression('missing `x-before` header')
          )
        }
      )
      .get('/multiple/abc', (c) => {
        return c.text('GET multiple')
      })
    it('GET /multiple/abc', async () => {
      const res = await app.request('http://localhost/multiple/abc')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('GET multiple')
      expect(res.headers.get('x-after')).toBe('abc')
    })
  })

  describe('Overwrite the response from middleware after next()', () => {
    const app = new Hono()

    app.use('/normal', async (c, next) => {
      await next()
      c.res = new Response('Middleware')
    })

    app.use('/overwrite', async (c, next) => {
      await next()
      c.res = undefined
      c.res = new Response('Middleware')
    })

    app.get('*', (c) => {
      c.header('x-custom', 'foo')
      return c.text('Handler')
    })

    it('Should have the custom header', async () => {
      const res = await app.request('/normal')
      expect(res.headers.get('x-custom')).toBe('foo')
    })

    it('Should not have the custom header', async () => {
      const res = await app.request('/overwrite')
      expect(res.headers.get('x-custom')).toBe(null)
    })
  })
})

describe('Builtin Middleware', () => {
  const app = new Hono()
  app.use('/abc', poweredBy())
  app.use('/def', async (c, next) => {
    const middleware = poweredBy()
    await middleware(c, next)
  })
  app.get('/abc', () => new Response())
  app.get('/def', () => new Response())

  it('"powered-by" middleware', async () => {
    const res = await app.request('http://localhost/abc')
    expect(res.headers.get('x-powered-by')).toBe('Hono')
  })

  it('"powered-by" middleware in a handler', async () => {
    const res = await app.request('http://localhost/def')
    expect(res.headers.get('x-powered-by')).toBe('Hono')
  })
})

describe('Middleware with app.HTTP_METHOD', () => {
  describe('Basic', () => {
    const app = new Hono()

    app.all('*', async (c, next) => {
      c.header('x-before-dispatch', 'foo')
      await next()
      c.header('x-custom-message', 'hello')
    })

    const customHeader = async (c: Context, next: Next) => {
      c.req.raw.headers.append('x-custom-foo', 'bar')
      await next()
    }

    const customHeader2 = async (c: Context, next: Next) => {
      await next()
      c.header('x-custom-foo-2', 'bar-2')
    }

    app
      .get('/abc', customHeader, (c) => {
        const foo = c.req.header('x-custom-foo') || ''
        return c.text(foo)
      })
      .post(customHeader2, (c) => {
        return c.text('POST /abc')
      })

    it('GET /abc', async () => {
      const res = await app.request('http://localhost/abc')
      expect(res.status).toBe(200)
      expect(res.headers.get('x-custom-message')).toBe('hello')
      expect(res.headers.get('x-before-dispatch')).toBe('foo')
      expect(await res.text()).toBe('bar')
    })
    it('POST /abc', async () => {
      const res = await app.request('http://localhost/abc', { method: 'POST' })
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('POST /abc')
      expect(res.headers.get('x-custom-foo-2')).toBe('bar-2')
    })
  })

  describe('With builtin middleware', () => {
    const app = new Hono()
    app.get('/abc', poweredBy(), (c) => {
      return c.text('GET /abc')
    })
    it('GET /abc', async () => {
      const res = await app.request('http://localhost/abc')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('GET /abc')
      expect(res.headers.get('x-powered-by')).toBe('Hono')
    })
  })
})

describe('Not Found', () => {
  const app = new Hono()

  app.notFound((c) => {
    return c.text('Custom 404 Not Found', 404)
  })

  app.get('/hello', (c) => {
    return c.text('hello')
  })

  app.get('/notfound', (c) => {
    return c.notFound()
  })

  it('Custom 404 Not Found', async () => {
    let res = await app.request('http://localhost/hello')
    expect(res.status).toBe(200)
    res = await app.request('http://localhost/notfound')
    expect(res.status).toBe(404)
    res = await app.request('http://localhost/foo')
    expect(res.status).toBe(404)
    expect(await res.text()).toBe('Custom 404 Not Found')
  })

  describe('Not Found with a middleware', () => {
    const app = new Hono()

    app.get('/', (c) => c.text('hello'))
    app.use('*', async (c, next) => {
      await next()
      c.res = new Response((await c.res.text()) + ' + Middleware', c.res)
    })

    it('Custom 404 Not Found', async () => {
      let res = await app.request('http://localhost/')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('hello')
      res = await app.request('http://localhost/foo')
      expect(res.status).toBe(404)
      expect(await res.text()).toBe('404 Not Found + Middleware')
    })
  })

  describe('Not Found with some middleware', () => {
    const app = new Hono()

    app.get('/', (c) => c.text('hello'))
    app.use('*', async (c, next) => {
      await next()
      c.res = new Response((await c.res.text()) + ' + Middleware 1', c.res)
    })
    app.use('*', async (c, next) => {
      await next()
      c.res = new Response((await c.res.text()) + ' + Middleware 2', c.res)
    })

    it('Custom 404 Not Found', async () => {
      let res = await app.request('http://localhost/')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('hello')
      res = await app.request('http://localhost/foo')
      expect(res.status).toBe(404)
      expect(await res.text()).toBe('404 Not Found + Middleware 2 + Middleware 1')
    })
  })

  describe('No response from a handler', () => {
    const app = new Hono()

    app.get('/', (c) => c.text('hello'))
    app.get('/not-found', async (c) => undefined)

    it('Custom 404 Not Found', async () => {
      let res = await app.request('http://localhost/')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('hello')
      res = await app.request('http://localhost/not-found')
      expect(res.status).toBe(404)
      expect(await res.text()).toBe('404 Not Found')
    })
  })

  describe('Custom 404 Not Found with a middleware like Compress Middleware', () => {
    const app = new Hono()

    // Custom Middleware which creates a new Response object after `next()`.
    app.use('*', async (c, next) => {
      await next()
      c.res = new Response(await c.res.text(), c.res)
    })

    app.notFound((c) => {
      return c.text('Custom NotFound', 404)
    })

    it('Custom 404 Not Found', async () => {
      const res = await app.request('http://localhost/')
      expect(res.status).toBe(404)
      expect(await res.text()).toBe('Custom NotFound')
    })
  })
})

describe('Redirect', () => {
  const app = new Hono()
  app.get('/redirect', (c) => {
    return c.redirect('/')
  })

  it('Absolute URL', async () => {
    const res = await app.request('https://example.com/redirect')
    expect(res.status).toBe(302)
    expect(res.headers.get('Location')).toBe('/')
  })
})

describe('Error handle', () => {
  describe('Basic', () => {
    const app = new Hono()

    app.get('/error', () => {
      throw new Error('This is Error')
    })

    app.get('/error-string', () => {
      throw 'This is Error'
    })

    app.use('/error-middleware', async () => {
      throw new Error('This is Middleware Error')
    })

    app.onError((err, c) => {
      c.header('x-debug', err.message)
      return c.text('Custom Error Message', 500)
    })

    it('Should throw Error if a non-Error object is thrown in a handler', async () => {
      expect(() => app.request('/error-string')).toThrowError()
    })

    it('Custom Error Message', async () => {
      let res = await app.request('https://example.com/error')
      expect(res.status).toBe(500)
      expect(await res.text()).toBe('Custom Error Message')
      expect(res.headers.get('x-debug')).toBe('This is Error')

      res = await app.request('https://example.com/error-middleware')
      expect(res.status).toBe(500)
      expect(await res.text()).toBe('Custom Error Message')
      expect(res.headers.get('x-debug')).toBe('This is Middleware Error')
    })
  })

  describe('Async custom handler', () => {
    const app = new Hono()

    app.get('/error', () => {
      throw new Error('This is Error')
    })

    app.use('/error-middleware', async () => {
      throw new Error('This is Middleware Error')
    })

    app.onError(async (err, c) => {
      const promise = new Promise((resolve) =>
        setTimeout(() => {
          resolve('Promised')
        }, 1)
      )
      const message = (await promise) as string
      c.header('x-debug', err.message)
      return c.text(`Custom Error Message with ${message}`, 500)
    })

    it('Custom Error Message', async () => {
      let res = await app.request('https://example.com/error')
      expect(res.status).toBe(500)
      expect(await res.text()).toBe('Custom Error Message with Promised')
      expect(res.headers.get('x-debug')).toBe('This is Error')

      res = await app.request('https://example.com/error-middleware')
      expect(res.status).toBe(500)
      expect(await res.text()).toBe('Custom Error Message with Promised')
      expect(res.headers.get('x-debug')).toBe('This is Middleware Error')
    })
  })

  describe('Handle HTTPException', () => {
    const app = new Hono()

    app.get('/exception', () => {
      throw new HTTPException(401, {
        message: 'Unauthorized',
      })
    })

    it('Should return 401 response', async () => {
      const res = await app.request('http://localhost/exception')
      expect(res.status).toBe(401)
      expect(await res.text()).toBe('Unauthorized')
    })

    const app2 = new Hono()

    app2.get('/exception', () => {
      throw new HTTPException(401)
    })

    app2.onError((err, c) => {
      if (err instanceof HTTPException && err.status === 401) {
        return c.text('Custom Error Message', 401)
      }
      return c.text('Internal Server Error', 500)
    })

    it('Should return 401 response with a custom message', async () => {
      const res = await app2.request('http://localhost/exception')
      expect(res.status).toBe(401)
      expect(await res.text()).toBe('Custom Error Message')
    })
  })

  describe('Handle HTTPException like object', () => {
    const app = new Hono()

    class CustomError extends Error {
      getResponse() {
        return new Response('Custom Error', { status: 400 })
      }
    }

    app.get('/exception', () => {
      throw new CustomError()
    })

    it('Should return 401 response', async () => {
      const res = await app.request('http://localhost/exception')
      expect(res.status).toBe(400)
      expect(await res.text()).toBe('Custom Error')
    })
  })
})

describe('Error handling in middleware', () => {
  const app = new Hono()

  app.get('/handle-error-in-middleware', async (c, next) => {
    await next()
    if (c.error) {
      const message = c.error.message
      c.res = c.text(`Handle the error in middleware, original message is ${message}`, 500)
    }
  })

  app.get('/handle-error-in-middleware-async', async (c, next) => {
    await next()
    if (c.error) {
      const message = c.error.message
      c.res = c.text(
        `Handle the error in middleware with async, original message is ${message}`,
        500
      )
    }
  })

  app.get('/handle-error-in-middleware', () => {
    throw new Error('Error message')
  })

  app.get('/handle-error-in-middleware-async', async () => {
    throw new Error('Error message')
  })

  it('Should handle the error in middleware', async () => {
    const res = await app.request('https://example.com/handle-error-in-middleware')
    expect(res.status).toBe(500)
    expect(await res.text()).toBe(
      'Handle the error in middleware, original message is Error message'
    )
  })

  it('Should handle the error in middleware - async', async () => {
    const res = await app.request('https://example.com/handle-error-in-middleware-async')
    expect(res.status).toBe(500)
    expect(await res.text()).toBe(
      'Handle the error in middleware with async, original message is Error message'
    )
  })

  describe('Default route app.use', () => {
    const app = new Hono()
    app
      .use(async (c, next) => {
        c.header('x-default-use', 'abc')
        await next()
      })
      .get('/multiple/abc', (c) => {
        return c.text('GET multiple')
      })
    it('GET /multiple/abc', async () => {
      const res = await app.request('http://localhost/multiple/abc')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('GET multiple')
      expect(res.headers.get('x-default-use')).toBe('abc')
    })
  })

  describe('Error in `notFound()`', () => {
    const app = new Hono()

    app.use('*', async () => {})

    app.notFound(() => {
      throw new Error('Error in Not Found')
    })

    app.onError((err, c) => {
      return c.text(err.message, 400)
    })

    it('Should handle the error thrown in `notFound()``', async () => {
      const res = await app.request('http://localhost/')
      expect(res.status).toBe(400)
      expect(await res.text()).toBe('Error in Not Found')
    })
  })
})

describe('Request methods with custom middleware', () => {
  const app = new Hono()

  app.use('*', async (c, next) => {
    const query = c.req.query('foo')

    // @ts-ignore
    const param = c.req.param('foo') // This will cause a type error.
    const header = c.req.header('User-Agent')
    await next()
    c.header('X-Query-2', query ?? throwExpression('missing `X-Query-2` header'))
    c.header('X-Param-2', param)
    c.header('X-Header-2', header ?? throwExpression('missing `X-Header-2` header'))
  })

  app.get('/:foo', (c) => {
    const query = c.req.query('foo')
    const param = c.req.param('foo')
    const header = c.req.header('User-Agent')
    c.header('X-Query', query ?? throwExpression('missing `X-Query` header'))
    c.header('X-Param', param)
    c.header('X-Header', header ?? throwExpression('missing `X-Header` header'))
    return c.body('Hono')
  })

  it('query', async () => {
    const url = new URL('http://localhost/bar')
    url.searchParams.append('foo', 'bar')
    const req = new Request(url.toString())
    req.headers.append('User-Agent', 'bar')
    const res = await app.request(req)

    expect(res.status).toBe(200)
    expect(res.headers.get('X-Query')).toBe('bar')
    expect(res.headers.get('X-Param')).toBe('bar')
    expect(res.headers.get('X-Header')).toBe('bar')

    expect(res.headers.get('X-Query-2')).toBe('bar')
    expect(res.headers.get('X-Param-2')).toBe(null)
    expect(res.headers.get('X-Header-2')).toBe('bar')
  })
})

describe('Middleware + c.json(0, requestInit)', () => {
  const app = new Hono()
  app.use('/', async (c, next) => {
    await next()
  })
  app.get('/', (c) => {
    return c.json(0, {
      status: 200,
      headers: {
        foo: 'bar',
      },
    })
  })
  it('Should return a correct headers', async () => {
    const res = await app.request('/')
    expect(res.headers.get('content-type')).toMatch(/^application\/json/)
    expect(res.headers.get('foo')).toBe('bar')
  })
})

describe('Hono with `app.route`', () => {
  describe('Basic', () => {
    const app = new Hono()
    const api = new Hono()
    const middleware = new Hono()

    api.use('*', async (c, next) => {
      await next()
      c.res.headers.append('x-custom-a', 'a')
    })

    api.get('/posts', (c) => c.text('List'))
    api.post('/posts', (c) => c.text('Create'))
    api.get('/posts/:id', (c) => c.text(`GET ${c.req.param('id')}`))

    middleware.use('*', async (c, next) => {
      await next()
      c.res.headers.append('x-custom-b', 'b')
    })

    app.route('/api', middleware)
    app.route('/api', api)

    app.get('/foo', (c) => c.text('bar'))

    it('Should return not found response', async () => {
      const res = await app.request('http://localhost/')
      expect(res.status).toBe(404)
    })

    it('Should return not found response', async () => {
      const res = await app.request('http://localhost/posts')
      expect(res.status).toBe(404)
    })

    test('GET /api/posts', async () => {
      const res = await app.request('http://localhost/api/posts')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('List')
    })

    test('Custom header by middleware', async () => {
      const res = await app.request('http://localhost/api/posts')
      expect(res.status).toBe(200)
      expect(res.headers.get('x-custom-a')).toBe('a')
      expect(res.headers.get('x-custom-b')).toBe('b')
    })

    test('POST /api/posts', async () => {
      const res = await app.request('http://localhost/api/posts', { method: 'POST' })
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('Create')
    })

    test('GET /api/posts/123', async () => {
      const res = await app.request('http://localhost/api/posts/123')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('GET 123')
    })

    test('GET /foo', async () => {
      const res = await app.request('http://localhost/foo')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('bar')
    })

    describe('With app.get(...handler)', () => {
      const app = new Hono()
      const about = new Hono()
      about.get((c) => c.text('me'))
      const subApp = new Hono()
      subApp.route('/about', about)
      app.route('/', subApp)

      it('Should return 200 response - /about', async () => {
        const res = await app.request('/about')
        expect(res.status).toBe(200)
        expect(await res.text()).toBe('me')
      })

      test('Should return 404 response /about/foo', async () => {
        const res = await app.request('/about/foo')
        expect(res.status).toBe(404)
      })
    })

    describe('With app.get(...handler) and app.basePath()', () => {
      const app = new Hono()
      const about = new Hono().basePath('/about')
      about.get((c) => c.text('me'))
      app.route('/', about)

      it('Should return 200 response - /about', async () => {
        const res = await app.request('/about')
        expect(res.status).toBe(200)
        expect(await res.text()).toBe('me')
      })

      test('Should return 404 response /about/foo', async () => {
        const res = await app.request('/about/foo')
        expect(res.status).toBe(404)
      })
    })
  })

  describe('Chaining', () => {
    const app = new Hono()
    const route = new Hono()
    route.get('/post', (c) => c.text('GET /POST v2')).post((c) => c.text('POST /POST v2'))
    app.route('/v2', route)

    it('Should return 200 response - GET /v2/post', async () => {
      const res = await app.request('http://localhost/v2/post')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('GET /POST v2')
    })

    it('Should return 200 response - POST /v2/post', async () => {
      const res = await app.request('http://localhost/v2/post', { method: 'POST' })
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('POST /POST v2')
    })

    it('Should return 404 response - DELETE /v2/post', async () => {
      const res = await app.request('http://localhost/v2/post', { method: 'DELETE' })
      expect(res.status).toBe(404)
    })
  })

  describe('Nested', () => {
    const app = new Hono()
    const api = new Hono()
    const book = new Hono()

    book.get('/', (c) => c.text('list books'))
    book.get('/:id', (c) => c.text(`book ${c.req.param('id')}`))

    api.get('/', (c) => c.text('this is API'))
    api.route('/book', book)

    app.get('/', (c) => c.text('root'))
    app.route('/v2', api)

    it('Should return 200 response - GET /', async () => {
      const res = await app.request('http://localhost/')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('root')
    })

    it('Should return 200 response - GET /v2', async () => {
      const res = await app.request('http://localhost/v2')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('this is API')
    })

    it('Should return 200 response - GET /v2/book', async () => {
      const res = await app.request('http://localhost/v2/book')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('list books')
    })

    it('Should return 200 response - GET /v2/book/123', async () => {
      const res = await app.request('http://localhost/v2/book/123')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('book 123')
    })
  })

  describe('onError', () => {
    const app = new Hono()
    const sub = new Hono()

    app.use('*', async (c, next) => {
      await next()
      if (c.req.query('app-error')) {
        throw new Error('This is Error')
      }
    })

    app.onError((err, c) => {
      return c.text('onError by app', 500)
    })

    sub.get('/posts/:id', async (c, next) => {
      c.header('handler-chain', '1')
      await next()
    })

    sub.get('/posts/:id', (c) => {
      return c.text(`post: ${c.req.param('id')}`)
    })

    sub.get('/error', () => {
      throw new Error('This is Error')
    })

    sub.onError((err, c) => {
      return c.text('onError by sub', 500)
    })

    app.route('/sub', sub)

    it('GET /posts/123 for sub', async () => {
      const res = await app.request('https://example.com/sub/posts/123')
      expect(res.status).toBe(200)
      expect(res.headers.get('handler-chain')).toBe('1')
      expect(await res.text()).toBe('post: 123')
    })

    it('should be handled by app', async () => {
      const res = await app.request('https://example.com/sub/ok?app-error=1')
      expect(res.status).toBe(500)
      expect(await res.text()).toBe('onError by app')
    })

    it('should be handled by sub', async () => {
      const res = await app.request('https://example.com/sub/error')
      expect(res.status).toBe(500)
      expect(await res.text()).toBe('onError by sub')
    })
  })

  describe('onError for a single handler', () => {
    const app = new Hono()
    const sub = new Hono()

    sub.get('/ok', (c) => c.text('OK'))

    sub.get('/error', () => {
      throw new Error('This is Error')
    })

    sub.onError((err, c) => {
      return c.text('onError by sub', 500)
    })

    app.route('/sub', sub)

    it('ok', async () => {
      const res = await app.request('https://example.com/sub/ok')
      expect(res.status).toBe(200)
    })

    it('error', async () => {
      const res = await app.request('https://example.com/sub/error')
      expect(res.status).toBe(500)
      expect(await res.text()).toBe('onError by sub')
    })
  })

  describe('notFound', () => {
    const app = new Hono()
    const sub = new Hono()

    app.get('/explicit-404', async (c) => {
      c.header('explicit', '1')
    })

    app.notFound((c) => {
      return c.text('404 Not Found by app', 404)
    })

    sub.get('/ok', (c) => {
      return c.text('ok')
    })

    sub.get('/explicit-404', async (c) => {
      c.header('explicit', '1')
    })

    sub.notFound((c) => {
      return c.text('404 Not Found by sub', 404)
    })

    app.route('/sub', sub)

    it('/explicit-404 should be handled on app', async () => {
      const res = await app.request('https://example.com/explicit-404')
      expect(res.status).toBe(404)
      expect(res.headers.get('explicit')).toBe('1')
      expect(await res.text()).toBe('404 Not Found by app')
    })

    it('/sub/explicit-404 should be handled on app', async () => {
      const res = await app.request('https://example.com/sub/explicit-404')
      expect(res.status).toBe(404)
      expect(res.headers.get('explicit')).toBe('1')
      expect(await res.text()).toBe('404 Not Found by app')
    })

    it('/implicit-404 should be handled by app', async () => {
      const res = await app.request('https://example.com/implicit-404')
      expect(res.status).toBe(404)
      expect(res.headers.get('explicit')).toBe(null)
      expect(await res.text()).toBe('404 Not Found by app')
    })

    it('/sub/implicit-404 should be handled by sub', async () => {
      const res = await app.request('https://example.com/sub/implicit-404')
      expect(res.status).toBe(404)
      expect(res.headers.get('explicit')).toBe(null)
      expect(await res.text()).toBe('404 Not Found by app')
    })
  })
})

describe('Using other methods with `app.on`', () => {
  it('Should handle PURGE method with RegExpRouter', async () => {
    const app = new Hono({ router: new RegExpRouter() })

    app.on('PURGE', '/purge', (c) => c.text('Accepted', 202))

    const req = new Request('http://localhost/purge', {
      method: 'PURGE',
    })
    const res = await app.request(req)
    expect(res.status).toBe(202)
    expect(await res.text()).toBe('Accepted')
  })

  it('Should handle PURGE method with TrieRouter', async () => {
    const app = new Hono({ router: new TrieRouter() })

    app.on('PURGE', '/purge', (c) => c.text('Accepted', 202))

    const req = new Request('http://localhost/purge', {
      method: 'PURGE',
    })
    const res = await app.request(req)
    expect(res.status).toBe(202)
    expect(await res.text()).toBe('Accepted')
  })
})

describe('Multiple methods with `app.on`', () => {
  const app = new Hono()
  app.on(['PUT', 'DELETE'], '/posts/:id', (c) => {
    return c.json({
      postId: c.req.param('id'),
      method: c.req.method,
    })
  })

  it('Should return 200 with PUT', async () => {
    const req = new Request('http://localhost/posts/123', {
      method: 'PUT',
    })
    const res = await app.request(req)
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({
      postId: '123',
      method: 'PUT',
    })
  })

  it('Should return 200 with DELETE', async () => {
    const req = new Request('http://localhost/posts/123', {
      method: 'DELETE',
    })
    const res = await app.request(req)
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({
      postId: '123',
      method: 'DELETE',
    })
  })

  it('Should return 404 with POST', async () => {
    const req = new Request('http://localhost/posts/123', {
      method: 'POST',
    })
    const res = await app.request(req)
    expect(res.status).toBe(404)
  })
})

describe('Multiple paths with one handler', () => {
  const app = new Hono()

  const paths = ['/hello', '/ja/hello', '/en/hello']
  app.on('GET', paths, (c) => {
    return c.json({
      path: c.req.path,
      routePath: c.req.routePath,
    })
  })

  it('Should handle multiple paths', async () => {
    paths.map(async (path) => {
      const res = await app.request(path)
      expect(res.status).toBe(200)
      const data = await res.json()
      expect(data).toEqual({
        path,
        routePath: path,
      })
    })
  })
})

describe('Multiple handler', () => {
  describe('handler + handler', () => {
    const app = new Hono()

    app.get('/posts/:id', (c) => {
      const id = c.req.param('id')
      c.header('foo', 'bar')
      return c.text(`id is ${id}`)
    })

    app.get('/:type/:id', (c) => {
      c.status(404)
      c.header('foo2', 'bar2')
      return c.text('foo')
    })
    it('Should return response from `specialized` route', async () => {
      const res = await app.request('http://localhost/posts/123')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('id is 123')
      expect(res.headers.get('foo')).toBe('bar')
      expect(res.headers.get('foo2')).toBeNull()
    })
  })

  describe('Duplicate param name', () => {
    describe('basic', () => {
      const app = new Hono()
      app.get('/:type/:url', (c) => {
        return c.text(`type: ${c.req.param('type')}, url: ${c.req.param('url')}`)
      })
      app.get('/foo/:type/:url', (c) => {
        return c.text(`foo type: ${c.req.param('type')}, url: ${c.req.param('url')}`)
      })

      it('Should return a correct param - GET /car/good-car', async () => {
        const res = await app.request('/car/good-car')
        expect(res.ok).toBe(true)
        expect(await res.text()).toBe('type: car, url: good-car')
      })
      it('Should return a correct param - GET /foo/food/good-food', async () => {
        const res = await app.request('/foo/food/good-food')
        expect(res.ok).toBe(true)
        expect(await res.text()).toBe('foo type: food, url: good-food')
      })
    })

    describe('self', () => {
      const app = new Hono()
      app.get('/:id/:id', (c) => {
        const id = c.req.param('id')
        return c.text(`id is ${id}`)
      })
      it('Should return 123 - GET /123/456', async () => {
        const res = await app.request('/123/456')
        expect(res.status).toBe(200)
        expect(await res.text()).toBe('id is 123')
      })
    })

    describe('hierarchy', () => {
      const app = new Hono()
      app.get('/posts/:id/comments/:comment_id', (c) => {
        return c.text(`post: ${c.req.param('id')}, comment: ${c.req.param('comment_id')}`)
      })
      app.get('/posts/:id', (c) => {
        return c.text(`post: ${c.req.param('id')}`)
      })
      it('Should return a correct param - GET /posts/123/comments/456', async () => {
        const res = await app.request('/posts/123/comments/456')
        expect(res.status).toBe(200)
        expect(await res.text()).toBe('post: 123, comment: 456')
      })
      it('Should return a correct param - GET /posts/789', async () => {
        const res = await app.request('/posts/789')
        expect(res.status).toBe(200)
        expect(await res.text()).toBe('post: 789')
      })
    })

    describe('different regular expression', () => {
      const app = new Hono()
      app.get('/:id/:action{create|update}', (c) => {
        return c.text(`id: ${c.req.param('id')}, action: ${c.req.param('action')}`)
      })
      app.get('/:id/:action{delete}', (c) => {
        return c.text(`id: ${c.req.param('id')}, action: ${c.req.param('action')}`)
      })

      it('Should return a correct param - GET /123/create', async () => {
        const res = await app.request('/123/create')
        expect(res.status).toBe(200)
        expect(await res.text()).toBe('id: 123, action: create')
      })
      it('Should return a correct param - GET /456/update', async () => {
        const res = await app.request('/467/update')
        expect(res.status).toBe(200)
        expect(await res.text()).toBe('id: 467, action: update')
      })
      it('Should return a correct param - GET /789/delete', async () => {
        const res = await app.request('/789/delete')
        expect(res.status).toBe(200)
        expect(await res.text()).toBe('id: 789, action: delete')
      })
    })
  })
})

describe('Multiple handler - async', () => {
  describe('handler + handler', () => {
    const app = new Hono()
    app.get('/posts/:id', async (c) => {
      await new Promise((resolve) => setTimeout(resolve, 1))
      c.header('foo2', 'bar2')
      const id = c.req.param('id')
      return c.text(`id is ${id}`)
    })
    app.get('/:type/:id', async (c) => {
      await new Promise((resolve) => setTimeout(resolve, 1))
      c.header('foo', 'bar')
      c.status(404)
      return c.text('foo')
    })

    it('Should return response from `specialized` route', async () => {
      const res = await app.request('http://localhost/posts/123')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('id is 123')
      expect(res.headers.get('foo')).toBeNull()
      expect(res.headers.get('foo2')).toBe('bar2')
    })
  })
})

describe('Lack returning response with a single handler', () => {
  const app = new Hono()
  // @ts-expect-error it should return Response to type it
  app.get('/sync', () => {})
  app.get('/async', async () => {})

  it('Should return 404 response if lacking returning response', async () => {
    const res = await app.request('/sync')
    expect(res.status).toBe(404)
  })

  it('Should return 404 response if lacking returning response in an async handler', async () => {
    const res = await app.request('/async')
    expect(res.status).toBe(404)
  })
})

describe('Context is not finalized', () => {
  it('should throw error - lack `await next()`', async () => {
    const app = new Hono()

    // @ts-ignore
    app.use('*', () => {})
    app.get('/foo', (c) => {
      return c.text('foo')
    })
    app.onError((err, c) => {
      return c.text(err.message, 500)
    })
    const res = await app.request('http://localhost/foo')
    expect(res.status).toBe(500)
    expect(await res.text()).toMatch(/^Context is not finalized/)
  })

  it('should throw error - lack `returning Response`', async () => {
    const app = new Hono()
    app.use('*', async (_c, next) => {
      await next()
    })

    // @ts-ignore
    app.get('/foo', () => {})
    app.onError((err, c) => {
      return c.text(err.message, 500)
    })
    const res = await app.request('http://localhost/foo')
    expect(res.status).toBe(500)
    expect(await res.text()).toMatch(/^Context is not finalized/)
  })
})

describe('Parse Body', () => {
  const app = new Hono()

  app.post('/json', async (c) => {
    return c.json<{}, 200>(await c.req.parseBody(), 200)
  })
  app.post('/form', async (c) => {
    return c.json<{}, 200>(await c.req.parseBody(), 200)
  })

  it('POST with JSON', async () => {
    const req = new Request('http://localhost/json', {
      method: 'POST',
      body: JSON.stringify({ message: 'hello hono' }),
      headers: new Headers({ 'Content-Type': 'application/json' }),
    })
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
  })

  it('POST with `multipart/form-data`', async () => {
    const formData = new FormData()
    formData.append('message', 'hello')
    const req = new Request('https://localhost/form', {
      method: 'POST',
      body: formData,
    })

    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({ message: 'hello' })
  })

  it('POST with `application/x-www-form-urlencoded`', async () => {
    const searchParam = new URLSearchParams()
    searchParam.append('message', 'hello')
    const req = new Request('https://localhost/form', {
      method: 'POST',
      body: searchParam,
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
    })

    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({ message: 'hello' })
  })
})

describe('Both two middleware returning response', () => {
  it('Should return correct Content-Type`', async () => {
    const app = new Hono()
    app.use('*', async (c, next) => {
      await next()
      return c.html('Foo')
    })
    app.get('/', (c) => {
      return c.text('Bar')
    })
    const res = await app.request('http://localhost/')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('Bar')
    expect(res.headers.get('Content-Type')).toMatch(/^text\/plain/)
  })
})

describe('Count of logger called', () => {
  // It will be added `2` each time the logger is called once.
  let count = 0
  let log = ''

  const app = new Hono()

  const logFn = (str: string) => {
    count++
    log = str
  }

  app.use('*', logger(logFn))
  app.get('/', (c) => c.text('foo'))

  it('Should be called two times', async () => {
    const res = await app.request('http://localhost/not-found')
    expect(res).not.toBeNull()
    expect(res.status).toBe(404)
    expect(await res.text()).toBe('404 Not Found')
    expect(count).toBe(2)
    expect(log).toMatch(/404/)
  })

  it('Should be called two times / Custom Not Found', async () => {
    app.notFound((c) => c.text('Custom Not Found', 404))
    const res = await app.request('http://localhost/custom-not-found')
    expect(res).not.toBeNull()
    expect(res.status).toBe(404)
    expect(await res.text()).toBe('Custom Not Found')
    expect(count).toBe(4)
    expect(log).toMatch(/404/)
  })
})

describe('Context set/get variables', () => {
  type Variables = {
    id: number
    title: string
  }

  const app = new Hono<{ Variables: Variables }>()

  it('Should set and get variables with correct types', async () => {
    app.use('*', async (c, next) => {
      c.set('id', 123)
      c.set('title', 'Hello')
      await next()
    })
    app.get('/', (c) => {
      const id = c.get('id')
      const title = c.get('title')
      // type verifyID = Expect<Equal<number, typeof id>>
      expectTypeOf(id).toEqualTypeOf<number>()
      // type verifyTitle = Expect<Equal<string, typeof title>>
      expectTypeOf(title).toEqualTypeOf<string>()
      return c.text(`${id} is ${title}`)
    })
    const res = await app.request('http://localhost/')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('123 is Hello')
  })
})

describe('Context binding variables', () => {
  type Bindings = {
    USER_ID: number
    USER_NAME: string
  }

  const app = new Hono<{ Bindings: Bindings }>()

  it('Should get binding variables with correct types', async () => {
    app.get('/', (c) => {
      expectTypeOf(c.env).toEqualTypeOf<Bindings>()
      return c.text('These are verified')
    })
    const res = await app.request('http://localhost/')
    expect(res.status).toBe(200)
  })
})

describe('Handler as variables', () => {
  const app = new Hono()

  it('Should be typed correctly', async () => {
    const handler: Handler = (c) => {
      const id = c.req.param('id')
      return c.text(`Post id is ${id}`)
    }
    app.get('/posts/:id', handler)

    const res = await app.request('http://localhost/posts/123')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('Post id is 123')
  })
})

describe('json', () => {
  const api = new Hono()

  api.get('/message', (c) => {
    return c.json({
      message: 'Hello',
    })
  })

  api.get('/message-async', async (c) => {
    return c.json({
      message: 'Hello',
    })
  })

  describe('Single handler', () => {
    const app = new Hono()
    app.route('/api', api)

    it('Should return 200 response', async () => {
      const res = await app.request('http://localhost/api/message')
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({
        message: 'Hello',
      })
    })

    it('Should return 200 response - with async', async () => {
      const res = await app.request('http://localhost/api/message-async')
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({
        message: 'Hello',
      })
    })
  })

  describe('With middleware', () => {
    const app = new Hono()
    app.use('*', async (_c, next) => {
      await next()
    })
    app.route('/api', api)

    it('Should return 200 response', async () => {
      const res = await app.request('http://localhost/api/message')
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({
        message: 'Hello',
      })
    })

    it('Should return 200 response - with async', async () => {
      const res = await app.request('http://localhost/api/message-async')
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({
        message: 'Hello',
      })
    })
  })
})

describe('Optional parameters', () => {
  const app = new Hono()
  app.get('/api/:version/animal/:type?', (c) => {
    const type1 = c.req.param('type')
    expectTypeOf(type1).toEqualTypeOf<string | undefined>()
    const { type, version } = c.req.param()
    expectTypeOf(version).toEqualTypeOf<string>()
    expectTypeOf(type).toEqualTypeOf<string | undefined>()

    return c.json({
      type: type,
    })
  })

  it('Should match with an optional parameter', async () => {
    const res = await app.request('http://localhost/api/v1/animal/bird')
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({
      type: 'bird',
    })
  })

  it('Should match without an optional parameter', async () => {
    const res = await app.request('http://localhost/api/v1/animal')
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({
      type: undefined,
    })
  })

  it('Should have a correct type with an optional parameter in a regexp path', async () => {
    const app = new Hono()
    app.get('/url/:url{.*}?', (c) => {
      const url = c.req.param('url')
      expectTypeOf(url).toEqualTypeOf<string | undefined>()
      return c.json(0)
    })
  })
})

describe('app.mount()', () => {
  describe('Basic', () => {
    const anotherApp = (req: Request, ...params: unknown[]) => {
      const path = getPath(req)
      if (path === '/') {
        return new Response('AnotherApp')
      }
      if (path === '/hello') {
        return new Response('Hello from AnotherApp')
      }
      if (path === '/header') {
        const message = req.headers.get('x-message')
        return new Response(message)
      }
      if (path === '/with-query') {
        const queryStrings = new URL(req.url).searchParams.toString()
        return new Response(queryStrings)
      }
      if (path == '/with-params') {
        return new Response(
          JSON.stringify({
            params,
          }),
          {
            headers: {
              'Content-Type': 'application.json',
            },
          }
        )
      }
      if (path === '/undefined') {
        return undefined as unknown as Response
      }
      return new Response('Not Found from AnotherApp', {
        status: 404,
      })
    }

    const app = new Hono()
    app.use('*', async (c, next) => {
      await next()
      c.header('x-message', 'Foo')
    })
    app.get('/', (c) => c.text('Hono'))
    app.notFound((c) => {
      return c.text('Not Found from App', 404)
    })

    app.mount('/another-app', anotherApp, () => {
      return 'params'
    })
    app.mount('/another-app-with-array-option', anotherApp, () => {
      return ['param1', 'param2']
    })
    app.mount('/another-app2/sub-slash/', anotherApp)

    const api = new Hono().basePath('/api')
    api.mount('/another-app', anotherApp)

    it('Should return responses from Hono app', async () => {
      const res = await app.request('/')
      expect(res.status).toBe(200)
      expect(res.headers.get('x-message')).toBe('Foo')
      expect(await res.text()).toBe('Hono')
    })

    it('Should return responses from AnotherApp', async () => {
      let res = await app.request('/another-app')
      expect(res.status).toBe(200)
      expect(res.headers.get('x-message')).toBe('Foo')
      expect(await res.text()).toBe('AnotherApp')

      res = await app.request('/another-app/hello')
      expect(res.status).toBe(200)
      expect(res.headers.get('x-message')).toBe('Foo')
      expect(await res.text()).toBe('Hello from AnotherApp')

      const req = new Request('http://localhost/another-app/header', {
        headers: {
          'x-message': 'Message Foo!',
        },
      })
      res = await app.request(req)
      expect(res.status).toBe(200)
      expect(res.headers.get('x-message')).toBe('Foo')
      expect(await res.text()).toBe('Message Foo!')

      res = await app.request('/another-app/not-found')
      expect(res.status).toBe(404)
      expect(res.headers.get('x-message')).toBe('Foo')
      expect(await res.text()).toBe('Not Found from AnotherApp')

      res = await app.request('/another-app/with-query?foo=bar&baz=qux')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('foo=bar&baz=qux')

      res = await app.request('/another-app/with-params')
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({
        params: ['params'],
      })

      res = await app.request('/another-app/undefined')
      expect(res.status).toBe(404)
      expect(await res.text()).toBe('Not Found from App')
    })

    it('Should return response from Another app with an array option', async () => {
      const res = await app.request('/another-app-with-array-option/with-params')
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({
        params: ['param1', 'param2'],
      })
    })

    it('Should return responses from AnotherApp - sub + slash', async () => {
      const res = await app.request('/another-app2/sub-slash')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('AnotherApp')
    })

    it('Should return responses from AnotherApp - with `basePath()`', async () => {
      const res = await api.request('/api/another-app')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('AnotherApp')
    })
  })

  describe('With fetch', () => {
    const anotherApp = async (req: Request, env: {}, executionContext: ExecutionContext) => {
      const path = getPath(req)
      if (path === '/') {
        return new Response(
          JSON.stringify({
            env,
            executionContext,
          }),
          {
            headers: {
              'Content-Type': 'application/json',
            },
          }
        )
      }
      return new Response('Not Found from AnotherApp', {
        status: 404,
      })
    }

    const app = new Hono()
    app.mount('/another-app', anotherApp)

    it('Should handle Env and ExecuteContext', async () => {
      const request = new Request('http://localhost/another-app')
      const res = await app.fetch(
        request,
        {
          TOKEN: 'foo',
        },
        {
          // Force mocking!

          // @ts-ignore
          waitUntil: 'waitUntil',

          // @ts-ignore
          passThroughOnException: 'passThroughOnException',
        }
      )
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({
        env: {
          TOKEN: 'foo',
        },
        executionContext: {
          waitUntil: 'waitUntil',
          passThroughOnException: 'passThroughOnException',
        },
      })
    })
  })

  describe('Mount on `/`', () => {
    const anotherApp = (req: Request, params: unknown) => {
      const path = getPath(req)
      if (path === '/') {
        return new Response('AnotherApp')
      }
      if (path === '/hello') {
        return new Response('Hello from AnotherApp')
      }
      if (path === '/good/night') {
        return new Response('Good Night from AnotherApp')
      }
      return new Response('Not Found from AnotherApp', {
        status: 404,
      })
    }

    const app = new Hono()
    app.mount('/', anotherApp)

    it('Should return responses from AnotherApp - mount on `/`', async () => {
      let res = await app.request('/')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('AnotherApp')
      res = await app.request('/hello')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('Hello from AnotherApp')
      res = await app.request('/good/night')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('Good Night from AnotherApp')
      res = await app.request('/not-found')
      expect(res.status).toBe(404)
      expect(await res.text()).toBe('Not Found from AnotherApp')
    })
  })

  describe('With replaceRequest option', () => {
    const anotherApp = (req: Request) => {
      const path = getPath(req)
      if (path === '/app') {
        return new Response(getPath(req))
      }
      return new Response(null, { status: 404 })
    }

    const app = new Hono()
    app.mount('/app', anotherApp, {
      replaceRequest: (req) => req,
    })

    it('Should return 200 response with the correct path', async () => {
      const res = await app.request('/app')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('/app')
    })
  })
})

describe('HEAD method', () => {
  const app = new Hono()

  app.get('/page', (c) => {
    c.header('X-Message', 'Foo')
    c.header('X-Method', c.req.method)
    return c.text('/page')
  })

  it('Should return 200 response with body - GET /page', async () => {
    const res = await app.request('/page')
    expect(res.status).toBe(200)
    expect(res.headers.get('X-Message')).toBe('Foo')
    expect(res.headers.get('X-Method')).toBe('GET')
    expect(await res.text()).toBe('/page')
  })

  it('Should return 200 response without body - HEAD /page', async () => {
    const req = new Request('http://localhost/page', {
      method: 'HEAD',
    })
    const res = await app.request(req)
    expect(res.status).toBe(200)
    expect(res.headers.get('X-Message')).toBe('Foo')
    expect(res.headers.get('X-Method')).toBe('HEAD')
    expect(res.body).toBe(null)
  })
})

declare module './context' {
  interface ContextRenderer {
    (content: string | Promise<string>, head: { title: string }): Response | Promise<Response>
  }
}

describe('app.request()', () => {
  it('Should return response with Request and RequestInit as args', async () => {
    const app = new Hono()
    app.get('/foo', (c) => {
      return c.json(c.req.header('x-message'))
    })
    const req = new Request('http://localhost/foo')
    const headers = new Headers()
    headers.append('x-message', 'hello')
    const res = await app.request(req, {
      headers,
    })
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('"hello"')
  })
})

describe('app.fire()', () => {
  it('Should call global.addEventListener', () => {
    const app = new Hono()
    const addEventListener = vi.fn()
    global.addEventListener = addEventListener
    app.fire()
    expect(addEventListener).toHaveBeenCalledWith('fetch', expect.any(Function))

    const fetchEventListener = addEventListener.mock.calls[0][1]
    const respondWith = vi.fn()
    const request = new Request('http://localhost')
    fetchEventListener({ respondWith, request })
    expect(respondWith).toHaveBeenCalledWith(expect.any(Promise))
  })
})

describe('Context render and setRenderer', () => {
  const app = new Hono()
  app.get('/default', (c) => {
    return c.render('<h1>content</h1>', { title: 'dummy ' })
  })
  app.use('/page', async (c, next) => {
    c.setRenderer((content, head) => {
      return new Response(
        `<html><head><title>${head.title}</title></head><body><h1>${content}</h1></body></html>`
      )
    })
    await next()
  })
  app.get('/page', (c) => {
    return c.render('page content', {
      title: 'page title',
    })
  })

  it('Should return a Response from the default renderer', async () => {
    const res = await app.request('/default')
    expect(await res.text()).toBe('<h1>content</h1>')
  })

  it('Should return a Response from the custom renderer', async () => {
    const res = await app.request('/page')
    expect(await res.text()).toBe(
      '<html><head><title>page title</title></head><body><h1>page content</h1></body></html>'
    )
  })
})

describe('c.var - with testing types', () => {
  const app = new Hono<{
    Bindings: {
      Token: string
    }
  }>()

  const mw =
    (): MiddlewareHandler<{
      Variables: {
        echo: (str: string) => string
      }
    }> =>
    async (c, next) => {
      c.set('echo', (str) => str)
      await next()
    }

  const mw2 =
    (): MiddlewareHandler<{
      Variables: {
        echo2: (str: string) => string
      }
    }> =>
    async (c, next) => {
      c.set('echo2', (str) => str)
      await next()
    }

  const mw3 =
    (): MiddlewareHandler<{
      Variables: {
        echo3: (str: string) => string
      }
    }> =>
    async (c, next) => {
      c.set('echo3', (str) => str)
      await next()
    }

  const mw4 =
    (): MiddlewareHandler<{
      Variables: {
        echo4: (str: string) => string
      }
    }> =>
    async (c, next) => {
      c.set('echo4', (str) => str)
      await next()
    }

  const mw5 =
    (): MiddlewareHandler<{
      Variables: {
        echo5: (str: string) => string
      }
    }> =>
    async (c, next) => {
      c.set('echo5', (str) => str)
      await next()
    }

  const mw6 =
    (): MiddlewareHandler<{
      Variables: {
        echo6: (str: string) => string
      }
    }> =>
    async (c, next) => {
      c.set('echo6', (str) => str)
      await next()
    }

  const mw7 =
    (): MiddlewareHandler<{
      Variables: {
        echo7: (str: string) => string
      }
    }> =>
    async (c, next) => {
      c.set('echo7', (str) => str)
      await next()
    }

  const mw8 =
    (): MiddlewareHandler<{
      Variables: {
        echo8: (str: string) => string
      }
    }> =>
    async (c, next) => {
      c.set('echo8', (str) => str)
      await next()
    }

  const mw9 =
    (): MiddlewareHandler<{
      Variables: {
        echo9: (str: string) => string
      }
    }> =>
    async (c, next) => {
      c.set('echo9', (str) => str)
      await next()
    }

  const mw10 =
    (): MiddlewareHandler<{
      Variables: {
        echo10: (str: string) => string
      }
    }> =>
    async (c, next) => {
      c.set('echo10', (str) => str)
      await next()
    }

  app.use('/no-path/1').get(mw(), (c) => {
    return c.text(c.var.echo('hello'))
  })

  app.use('/no-path/2').get(mw(), mw2(), (c) => {
    return c.text(c.var.echo('hello') + c.var.echo2('hello2'))
  })

  app.use('/no-path/3').get(mw(), mw2(), mw3(), (c) => {
    return c.text(c.var.echo('hello') + c.var.echo2('hello2') + c.var.echo3('hello3'))
  })

  app.use('/no-path/4').get(mw(), mw2(), mw3(), mw4(), (c) => {
    return c.text(
      c.var.echo('hello') + c.var.echo2('hello2') + c.var.echo3('hello3') + c.var.echo4('hello4')
    )
  })

  app.use('/no-path/5').get(mw(), mw2(), mw3(), mw4(), mw5(), (c) => {
    return c.text(
      c.var.echo('hello') +
        c.var.echo2('hello2') +
        c.var.echo3('hello3') +
        c.var.echo4('hello4') +
        c.var.echo5('hello5')
    )
  })

  app.use('/no-path/6').get(mw(), mw2(), mw3(), mw4(), mw5(), mw6(), (c) => {
    return c.text(
      c.var.echo('hello') +
        c.var.echo2('hello2') +
        c.var.echo3('hello3') +
        c.var.echo4('hello4') +
        c.var.echo5('hello5') +
        c.var.echo6('hello6')
    )
  })

  app.use('/no-path/7').get(mw(), mw2(), mw3(), mw4(), mw5(), mw6(), mw7(), (c) => {
    return c.text(
      c.var.echo('hello') +
        c.var.echo2('hello2') +
        c.var.echo3('hello3') +
        c.var.echo4('hello4') +
        c.var.echo5('hello5') +
        c.var.echo6('hello6') +
        c.var.echo7('hello7')
    )
  })

  app.use('/no-path/8').get(mw(), mw2(), mw3(), mw4(), mw5(), mw6(), mw7(), mw8(), (c) => {
    return c.text(
      c.var.echo('hello') +
        c.var.echo2('hello2') +
        c.var.echo3('hello3') +
        c.var.echo4('hello4') +
        c.var.echo5('hello5') +
        c.var.echo6('hello6') +
        c.var.echo7('hello7') +
        c.var.echo8('hello8')
    )
  })

  app.use('/no-path/9').get(mw(), mw2(), mw3(), mw4(), mw5(), mw6(), mw7(), mw8(), mw9(), (c) => {
    return c.text(
      c.var.echo('hello') +
        c.var.echo2('hello2') +
        c.var.echo3('hello3') +
        c.var.echo4('hello4') +
        c.var.echo5('hello5') +
        c.var.echo6('hello6') +
        c.var.echo7('hello7') +
        c.var.echo8('hello8') +
        c.var.echo9('hello9')
    )
  })

  app.use('/no-path/10').get(
    // @ts-expect-error The handlers are more than 10
    mw(),
    mw2(),
    mw3(),
    mw4(),
    mw5(),
    mw6(),
    mw7(),
    mw8(),
    mw9(),
    mw10(),
    (c) => {
      return c.text(
        // @ts-expect-error
        c.var.echo('hello') +
          c.var.echo2('hello2') +
          c.var.echo3('hello3') +
          c.var.echo4('hello4') +
          c.var.echo5('hello5') +
          c.var.echo6('hello6') +
          c.var.echo7('hello7') +
          c.var.echo8('hello8') +
          c.var.echo9('hello9') +
          c.var.echo10('hello10')
      )
    }
  )

  app.get('*', mw())

  app.get('/path/1', mw(), (c) => {
    return c.text(c.var.echo('hello'))
  })

  app.get('/path/2', mw(), mw2(), (c) => {
    return c.text(c.var.echo('hello') + c.var.echo2('hello2'))
  })

  app.get('/path/3', mw(), mw2(), mw3(), (c) => {
    return c.text(c.var.echo('hello') + c.var.echo2('hello2') + c.var.echo3('hello3'))
  })

  app.get('/path/4', mw(), mw2(), mw3(), mw4(), (c) => {
    return c.text(
      c.var.echo('hello') + c.var.echo2('hello2') + c.var.echo3('hello3') + c.var.echo4('hello4')
    )
  })

  app.get('/path/5', mw(), mw2(), mw3(), mw4(), mw5(), (c) => {
    return c.text(
      c.var.echo('hello') +
        c.var.echo2('hello2') +
        c.var.echo3('hello3') +
        c.var.echo4('hello4') +
        c.var.echo5('hello5')
    )
  })

  app.get('/path/6', mw(), mw2(), mw3(), mw4(), mw5(), mw6(), (c) => {
    return c.text(
      c.var.echo('hello') +
        c.var.echo2('hello2') +
        c.var.echo3('hello3') +
        c.var.echo4('hello4') +
        c.var.echo5('hello5') +
        c.var.echo6('hello6')
    )
  })

  app.get('/path/7', mw(), mw2(), mw3(), mw4(), mw5(), mw6(), mw7(), (c) => {
    return c.text(
      c.var.echo('hello') +
        c.var.echo2('hello2') +
        c.var.echo3('hello3') +
        c.var.echo4('hello4') +
        c.var.echo5('hello5') +
        c.var.echo6('hello6') +
        c.var.echo7('hello7')
    )
  })

  app.get('/path/8', mw(), mw2(), mw3(), mw4(), mw5(), mw6(), mw7(), mw8(), (c) => {
    return c.text(
      c.var.echo('hello') +
        c.var.echo2('hello2') +
        c.var.echo3('hello3') +
        c.var.echo4('hello4') +
        c.var.echo5('hello5') +
        c.var.echo6('hello6') +
        c.var.echo7('hello7') +
        c.var.echo8('hello8')
    )
  })

  app.get('/path/9', mw(), mw2(), mw3(), mw4(), mw5(), mw6(), mw7(), mw8(), mw9(), (c) => {
    return c.text(
      c.var.echo('hello') +
        c.var.echo2('hello2') +
        c.var.echo3('hello3') +
        c.var.echo4('hello4') +
        c.var.echo5('hello5') +
        c.var.echo6('hello6') +
        c.var.echo7('hello7') +
        c.var.echo8('hello8') +
        c.var.echo9('hello9')
    )
  })

  // @ts-expect-error
  app.get('/path/10', mw(), mw2(), mw3(), mw4(), mw5(), mw6(), mw7(), mw8(), mw9(), mw10(), (c) => {
    return c.text(
      // @ts-expect-error
      c.var.echo('hello') +
        // @ts-expect-error
        c.var.echo2('hello2') +
        // @ts-expect-error
        c.var.echo3('hello3') +
        // @ts-expect-error
        c.var.echo4('hello4') +
        // @ts-expect-error
        c.var.echo5('hello5') +
        // @ts-expect-error
        c.var.echo6('hello6') +
        // @ts-expect-error
        c.var.echo7('hello7') +
        // @ts-expect-error
        c.var.echo8('hello8') +
        // @ts-expect-error
        c.var.echo9('hello9') +
        // @ts-expect-error
        c.var.echo10('hello10')
    )
  })

  app.on('GET', '/on/1', mw(), (c) => {
    return c.text(c.var.echo('hello'))
  })

  app.on('GET', '/on/2', mw(), mw2(), (c) => {
    return c.text(c.var.echo('hello') + c.var.echo2('hello2'))
  })

  app.on('GET', '/on/3', mw(), mw2(), mw3(), (c) => {
    return c.text(c.var.echo('hello') + c.var.echo2('hello2') + c.var.echo3('hello3'))
  })

  app.on('GET', '/on/4', mw(), mw2(), mw3(), mw4(), (c) => {
    return c.text(
      c.var.echo('hello') + c.var.echo2('hello2') + c.var.echo3('hello3') + c.var.echo4('hello4')
    )
  })

  app.on('GET', '/on/5', mw(), mw2(), mw3(), mw4(), mw5(), (c) => {
    return c.text(
      c.var.echo('hello') +
        c.var.echo2('hello2') +
        c.var.echo3('hello3') +
        c.var.echo4('hello4') +
        c.var.echo5('hello5')
    )
  })

  app.on('GET', '/on/6', mw(), mw2(), mw3(), mw4(), mw5(), mw6(), (c) => {
    return c.text(
      c.var.echo('hello') +
        c.var.echo2('hello2') +
        c.var.echo3('hello3') +
        c.var.echo4('hello4') +
        c.var.echo5('hello5') +
        c.var.echo6('hello6')
    )
  })

  app.on('GET', '/on/7', mw(), mw2(), mw3(), mw4(), mw5(), mw6(), mw7(), (c) => {
    return c.text(
      c.var.echo('hello') +
        c.var.echo2('hello2') +
        c.var.echo3('hello3') +
        c.var.echo4('hello4') +
        c.var.echo5('hello5') +
        c.var.echo6('hello6') +
        c.var.echo7('hello7')
    )
  })

  app.on('GET', '/on/8', mw(), mw2(), mw3(), mw4(), mw5(), mw6(), mw7(), mw8(), (c) => {
    return c.text(
      c.var.echo('hello') +
        c.var.echo2('hello2') +
        c.var.echo3('hello3') +
        c.var.echo4('hello4') +
        c.var.echo5('hello5') +
        c.var.echo6('hello6') +
        c.var.echo7('hello7') +
        c.var.echo8('hello8')
    )
  })

  app.on('GET', '/on/9', mw(), mw2(), mw3(), mw4(), mw5(), mw6(), mw7(), mw8(), mw9(), (c) => {
    return c.text(
      c.var.echo('hello') +
        c.var.echo2('hello2') +
        c.var.echo3('hello3') +
        c.var.echo4('hello4') +
        c.var.echo5('hello5') +
        c.var.echo6('hello6') +
        c.var.echo7('hello7') +
        c.var.echo8('hello8') +
        c.var.echo9('hello9')
    )
  })

  // @ts-expect-error
  app.on(
    'GET',
    '/on/10',
    mw(),
    mw2(),
    mw3(),
    mw4(),
    mw5(),
    mw6(),
    mw7(),
    mw8(),
    mw9(),
    mw10(),
    (c) => {
      return c.text(
        // @ts-expect-error
        c.var.echo('hello') +
          // @ts-expect-error
          c.var.echo2('hello2') +
          // @ts-expect-error
          c.var.echo3('hello3') +
          // @ts-expect-error
          c.var.echo4('hello4') +
          // @ts-expect-error
          c.var.echo5('hello5') +
          // @ts-expect-error
          c.var.echo6('hello6') +
          // @ts-expect-error
          c.var.echo7('hello7') +
          // @ts-expect-error
          c.var.echo8('hello8') +
          // @ts-expect-error
          c.var.echo9('hello9') +
          // @ts-expect-error
          c.var.echo10('hello10')
      )
    }
  )

  app.on(['GET', 'POST'], '/on/1', mw(), (c) => {
    return c.text(c.var.echo('hello'))
  })

  app.on(['GET', 'POST'], '/on/2', mw(), mw2(), (c) => {
    return c.text(c.var.echo('hello') + c.var.echo2('hello2'))
  })

  app.on(['GET', 'POST'], '/on/3', mw(), mw2(), mw3(), (c) => {
    return c.text(c.var.echo('hello') + c.var.echo2('hello2') + c.var.echo3('hello3'))
  })

  app.on(['GET', 'POST'], '/on/4', mw(), mw2(), mw3(), mw4(), (c) => {
    return c.text(
      c.var.echo('hello') + c.var.echo2('hello2') + c.var.echo3('hello3') + c.var.echo4('hello4')
    )
  })

  app.on(['GET', 'POST'], '/on/5', mw(), mw2(), mw3(), mw4(), mw5(), (c) => {
    return c.text(
      c.var.echo('hello') +
        c.var.echo2('hello2') +
        c.var.echo3('hello3') +
        c.var.echo4('hello4') +
        c.var.echo5('hello5')
    )
  })

  app.on(['GET', 'POST'], '/on/6', mw(), mw2(), mw3(), mw4(), mw5(), mw6(), (c) => {
    return c.text(
      c.var.echo('hello') +
        c.var.echo2('hello2') +
        c.var.echo3('hello3') +
        c.var.echo4('hello4') +
        c.var.echo5('hello5') +
        c.var.echo6('hello6')
    )
  })

  app.on(['GET', 'POST'], '/on/7', mw(), mw2(), mw3(), mw4(), mw5(), mw6(), mw7(), (c) => {
    return c.text(
      c.var.echo('hello') +
        c.var.echo2('hello2') +
        c.var.echo3('hello3') +
        c.var.echo4('hello4') +
        c.var.echo5('hello5') +
        c.var.echo6('hello6') +
        c.var.echo7('hello7')
    )
  })

  app.on(['GET', 'POST'], '/on/8', mw(), mw2(), mw3(), mw4(), mw5(), mw6(), mw7(), mw8(), (c) => {
    return c.text(
      c.var.echo('hello') +
        c.var.echo2('hello2') +
        c.var.echo3('hello3') +
        c.var.echo4('hello4') +
        c.var.echo5('hello5') +
        c.var.echo6('hello6') +
        c.var.echo7('hello7') +
        c.var.echo8('hello8')
    )
  })

  app.on(
    ['GET', 'POST'],
    '/on/9',
    mw(),
    mw2(),
    mw3(),
    mw4(),
    mw5(),
    mw6(),
    mw7(),
    mw8(),
    mw9(),
    (c) => {
      return c.text(
        c.var.echo('hello') +
          c.var.echo2('hello2') +
          c.var.echo3('hello3') +
          c.var.echo4('hello4') +
          c.var.echo5('hello5') +
          c.var.echo6('hello6') +
          c.var.echo7('hello7') +
          c.var.echo8('hello8') +
          c.var.echo9('hello9')
      )
    }
  )

  // @ts-expect-error
  app.on(
    ['GET', 'POST'],
    '/on/10',
    mw(),
    mw2(),
    mw3(),
    mw4(),
    mw5(),
    mw6(),
    mw7(),
    mw8(),
    mw9(),
    mw10(),
    (c) => {
      return c.text(
        // @ts-expect-error
        c.var.echo('hello') +
          // @ts-expect-error
          c.var.echo2('hello2') +
          // @ts-expect-error
          c.var.echo3('hello3') +
          // @ts-expect-error
          c.var.echo4('hello4') +
          // @ts-expect-error
          c.var.echo5('hello5') +
          // @ts-expect-error
          c.var.echo6('hello6') +
          // @ts-expect-error
          c.var.echo7('hello7') +
          // @ts-expect-error
          c.var.echo8('hello8') +
          // @ts-expect-error
          c.var.echo9('hello9') +
          // @ts-expect-error
          c.var.echo10('hello10')
      )
    }
  )

  it('Should return the correct response - no-path', async () => {
    let res = await app.request('/no-path/1')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hello')

    res = await app.request('/no-path/2')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hellohello2')

    res = await app.request('/no-path/3')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hellohello2hello3')

    res = await app.request('/no-path/4')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hellohello2hello3hello4')

    res = await app.request('/no-path/5')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hellohello2hello3hello4hello5')
  })

  it('Should return the correct response - path', async () => {
    let res = await app.request('/path/1')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hello')

    res = await app.request('/path/2')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hellohello2')

    res = await app.request('/path/3')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hellohello2hello3')

    res = await app.request('/path/4')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hellohello2hello3hello4')

    res = await app.request('/path/5')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hellohello2hello3hello4hello5')
  })

  it('Should return the correct response - on', async () => {
    let res = await app.request('/on/1')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hello')

    res = await app.request('/on/2')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hellohello2')

    res = await app.request('/on/3')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hellohello2hello3')

    res = await app.request('/on/4')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hellohello2hello3hello4')

    res = await app.request('/on/5')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hellohello2hello3hello4hello5')
  })

  it('Should not throw type errors', () => {
    const app = new Hono<{
      Variables: {
        hello: () => string
      }
    }>()

    app.get(mw())
    app.get(mw(), mw2())
    app.get(mw(), mw2(), mw3())
    app.get(mw(), mw2(), mw3(), mw4())
    app.get(mw(), mw2(), mw3(), mw4(), mw5())

    app.get('/', mw())
    app.get('/', mw(), mw2())
    app.get('/', mw(), mw2(), mw3())
    app.get('/', mw(), mw2(), mw3(), mw4())
    app.get('/', mw(), mw2(), mw3(), mw4(), mw5())
  })

  it('Should be a read-only', () => {
    expect(() => {
      app.get('/path/1', mw(), (c) => {
        // @ts-expect-error
        c.var.echo = 'hello'
        return c.text(c.var.echo('hello'))
      })
    }).toThrow()
  })

  it('Should not throw a type error', (c) => {
    const app = new Hono<{
      Bindings: {
        TOKEN: string
      }
    }>()

    app.get('/', poweredBy(), async (c) => {
      expectTypeOf(c.env.TOKEN).toEqualTypeOf<string>()
    })

    app.get('/', async (c, next) => {
      expectTypeOf(c.env.TOKEN).toEqualTypeOf<string>()
      const mw = poweredBy()
      await mw(c, next)
    })

    app.use(mw())
    app.use('*', mw())

    const route = app.get('/posts', mw(), (c) => c.json(0))
    const client = hc<typeof route>('/')
    type key = keyof typeof client
    type verify = Expect<Equal<'posts', key>>
  })

  it('Should throw type errors', (c) => {
    try {
      // @ts-expect-error
      app.get(['foo', 'bar'], poweredBy())
      // @ts-expect-error
      app.use(['foo', 'bar'], poweredBy())
    } catch {}
  })
})

describe('Compatible with extended Hono classes, such Zod OpenAPI Hono.', () => {
  class ExtendedHono extends Hono {
    // @ts-ignore
    route(path: string, app?: Hono) {
      // @ts-ignore
      super.route(path, app)
      return this
    }
    // @ts-ignore
    basePath(path: string) {
      return new ExtendedHono(super.basePath(path))
    }
  }
  const a = new ExtendedHono()
  const sub = new Hono()
  sub.get('/foo', (c) => c.text('foo'))
  a.route('/sub', sub)

  it('Should return 200 response', async () => {
    const res = await a.request('/sub/foo')
    expect(res.status).toBe(200)
  })
})

describe('Generics for Bindings and Variables', () => {
  interface CloudflareBindings {
    MY_VARIABLE: string
  }

  it('Should not throw type errors', () => {
    // @ts-expect-error Bindings should extend object
    new Hono<{
      Bindings: number
    }>()

    const appWithInterface = new Hono<{
      Bindings: CloudflareBindings
    }>()

    appWithInterface.get('/', (c) => {
      expectTypeOf(c.env.MY_VARIABLE).toMatchTypeOf<string>()
      return c.text('/')
    })

    const appWithType = new Hono<{
      Bindings: {
        foo: string
      }
    }>()

    appWithType.get('/', (c) => {
      expectTypeOf(c.env.foo).toMatchTypeOf<string>()
      return c.text('Hello Hono!')
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/hono.ts
```typescript
import { HonoBase } from './hono-base'
import type { HonoOptions } from './hono-base'
import { RegExpRouter } from './router/reg-exp-router'
import { SmartRouter } from './router/smart-router'
import { TrieRouter } from './router/trie-router'
import type { BlankEnv, BlankSchema, Env, Schema } from './types'

/**
 * The Hono class extends the functionality of the HonoBase class.
 * It sets up routing and allows for custom options to be passed.
 *
 * @template E - The environment type.
 * @template S - The schema type.
 * @template BasePath - The base path type.
 */
export class Hono<
  E extends Env = BlankEnv,
  S extends Schema = BlankSchema,
  BasePath extends string = '/'
> extends HonoBase<E, S, BasePath> {
  /**
   * Creates an instance of the Hono class.
   *
   * @param options - Optional configuration options for the Hono instance.
   */
  constructor(options: HonoOptions<E> = {}) {
    super(options)
    this.router =
      options.router ??
      new SmartRouter({
        routers: [new RegExpRouter(), new TrieRouter()],
      })
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/http-exception.test.ts
```typescript
import { HTTPException } from './http-exception'

describe('HTTPException', () => {
  it('Should be 401 HTTP exception object', async () => {
    // We should throw an exception if is not authorized
    // because next handlers should not be fired.
    const exception = new HTTPException(401, {
      message: 'Unauthorized',
    })
    const res = exception.getResponse()

    expect(res.status).toBe(401)
    expect(await res.text()).toBe('Unauthorized')
    expect(exception.status).toBe(401)
    expect(exception.message).toBe('Unauthorized')
  })

  it('Should be accessible to the object causing the exception', async () => {
    // We should pass the cause of the error to the cause option
    // because it makes debugging easier.
    const error = new Error('Server Error')
    const exception = new HTTPException(500, {
      message: 'Internal Server Error',
      cause: error,
    })
    const res = exception.getResponse()

    expect(res.status).toBe(500)
    expect(await res.text()).toBe('Internal Server Error')
    expect(exception.status).toBe(500)
    expect(exception.message).toBe('Internal Server Error')
    expect(exception.cause).toBe(error)
  })

  it('Should prioritize the status code over the code in the response', async () => {
    const exception = new HTTPException(400, {
      res: new Response('An exception', {
        status: 200,
      }),
    })
    const res = exception.getResponse()
    expect(res.status).toBe(400)
    expect(await res.text()).toBe('An exception')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/http-exception.ts
````typescript
/**
 * @module
 * This module provides the `HTTPException` class.
 */

import type { ContentfulStatusCode } from './utils/http-status'

/**
 * Options for creating an `HTTPException`.
 * @property res - Optional response object to use.
 * @property message - Optional custom error message.
 * @property cause - Optional cause of the error.
 */
type HTTPExceptionOptions = {
  res?: Response
  message?: string
  cause?: unknown
}

/**
 * `HTTPException` must be used when a fatal error such as authentication failure occurs.
 *
 * @see {@link https://hono.dev/docs/api/exception}
 *
 * @param {StatusCode} status - status code of HTTPException
 * @param {HTTPExceptionOptions} options - options of HTTPException
 * @param {HTTPExceptionOptions["res"]} options.res - response of options of HTTPException
 * @param {HTTPExceptionOptions["message"]} options.message - message of options of HTTPException
 * @param {HTTPExceptionOptions["cause"]} options.cause - cause of options of HTTPException
 *
 * @example
 * ```ts
 * import { HTTPException } from 'hono/http-exception'
 *
 * // ...
 *
 * app.post('/auth', async (c, next) => {
 *   // authentication
 *   if (authorized === false) {
 *     throw new HTTPException(401, { message: 'Custom error message' })
 *   }
 *   await next()
 * })
 * ```
 */
export class HTTPException extends Error {
  readonly res?: Response
  readonly status: ContentfulStatusCode

  /**
   * Creates an instance of `HTTPException`.
   * @param status - HTTP status code for the exception. Defaults to 500.
   * @param options - Additional options for the exception.
   */
  constructor(status: ContentfulStatusCode = 500, options?: HTTPExceptionOptions) {
    super(options?.message, { cause: options?.cause })
    this.res = options?.res
    this.status = status
  }

  /**
   * Returns the response object associated with the exception.
   * If a response object is not provided, a new response is created with the error message and status code.
   * @returns The response object.
   */
  getResponse(): Response {
    if (this.res) {
      const newResponse = new Response(this.res.body, {
        status: this.status,
        headers: this.res.headers,
      })
      return newResponse
    }
    return new Response(this.message, {
      status: this.status,
    })
  }
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/index.ts
````typescript
/**
 * @module
 *
 * Hono - Web Framework built on Web Standards
 *
 * @example
 * ```ts
 * import { Hono } from 'hono'
 * const app = new Hono()
 *
 * app.get('/', (c) => c.text('Hono!'))
 *
 * export default app
 * ```
 */

import { Hono } from './hono'

/**
 * Types for environment variables, error handlers, handlers, middleware handlers, and more.
 */
export type {
  Env,
  ErrorHandler,
  Handler,
  MiddlewareHandler,
  Next,
  NotFoundHandler,
  ValidationTargets,
  Input,
  Schema,
  ToSchema,
  TypedResponse,
} from './types'
/**
 * Types for context, context variable map, context renderer, and execution context.
 */
export type { Context, ContextVariableMap, ContextRenderer, ExecutionContext } from './context'
/**
 * Type for HonoRequest.
 */
export type { HonoRequest } from './request'
/**
 * Types for inferring request and response types and client request options.
 */
export type { InferRequestType, InferResponseType, ClientRequestOptions } from './client'

/**
 * Hono framework for building web applications.
 */
export { Hono }

````
/Users/josh/Documents/GitHub/honojs/hono/src/request.test.ts
```typescript
import { HonoRequest } from './request'
import type { RouterRoute } from './types'

type RecursiveRecord<K extends string, T> = {
  [key in K]: T | RecursiveRecord<K, T>
}

describe('Query', () => {
  test('req.query() and req.queries()', () => {
    const rawRequest = new Request('http://localhost?page=2&tag=A&tag=B')
    const req = new HonoRequest(rawRequest)

    const page = req.query('page')
    expect(page).not.toBeUndefined()
    expect(page).toBe('2')

    const q = req.query('q')
    expect(q).toBeUndefined()

    const tags = req.queries('tag')
    expect(tags).not.toBeUndefined()
    expect(tags).toEqual(['A', 'B'])

    const q2 = req.queries('q2')
    expect(q2).toBeUndefined()
  })

  test('decode special chars', () => {
    const rawRequest = new Request('http://localhost?mail=framework%40hono.dev&tag=%401&tag=%402')
    const req = new HonoRequest(rawRequest)

    const mail = req.query('mail')
    expect(mail).toBe('framework@hono.dev')

    const tags = req.queries('tag')
    expect(tags).toEqual(['@1', '@2'])
  })
})

describe('Param', () => {
  test('req.param() with ParamStash', () => {
    const rawRequest = new Request('http://localhost?page=2&tag=A&tag=B')
    const req = new HonoRequest<'/:id/:name'>(rawRequest, '/123/key', [
      [
        [[undefined, {} as RouterRoute], { id: 0 }],
        [[undefined, {} as RouterRoute], { id: 0, name: 1 }],
      ],
      ['123', 'key'],
    ])

    expect(req.param('id')).toBe('123')
    expect(req.param('name')).toBe(undefined)

    req.routeIndex = 1
    expect(req.param('id')).toBe('123')
    expect(req.param('name')).toBe('key')
  })

  test('req.param() without ParamStash', () => {
    const rawRequest = new Request('http://localhost?page=2&tag=A&tag=B')
    const req = new HonoRequest<'/:id/:name'>(rawRequest, '/123/key', [
      [
        [[undefined, {} as RouterRoute], { id: '123' }],
        [[undefined, {} as RouterRoute], { id: '456', name: 'key' }],
      ],
    ])

    expect(req.param('id')).toBe('123')
    expect(req.param('name')).toBe(undefined)

    req.routeIndex = 1
    expect(req.param('id')).toBe('456')
    expect(req.param('name')).toBe('key')
  })
})

describe('matchedRoutes', () => {
  test('req.routePath', () => {
    const handlerA = () => {}
    const handlerB = () => {}
    const rawRequest = new Request('http://localhost?page=2&tag=A&tag=B')
    const req = new HonoRequest<'/:id/:name'>(rawRequest, '/123/key', [
      [
        [[handlerA, { handler: handlerA, method: 'GET', path: '/:id' }], { id: '123' }],
        [
          [handlerA, { handler: handlerB, method: 'GET', path: '/:id/:name' }],
          { id: '456', name: 'key' },
        ],
      ],
    ])

    expect(req.matchedRoutes).toEqual([
      { handler: handlerA, method: 'GET', path: '/:id' },
      { handler: handlerB, method: 'GET', path: '/:id/:name' },
    ])
  })
})

describe('routePath', () => {
  test('req.routePath', () => {
    const handlerA = () => {}
    const handlerB = () => {}
    const rawRequest = new Request('http://localhost?page=2&tag=A&tag=B')
    const req = new HonoRequest<'/:id/:name'>(rawRequest, '/123/key', [
      [
        [[handlerA, { handler: handlerA, method: 'GET', path: '/:id' }], { id: '123' }],
        [
          [handlerA, { handler: handlerB, method: 'GET', path: '/:id/:name' }],
          { id: '456', name: 'key' },
        ],
      ],
    ])

    expect(req.routePath).toBe('/:id')

    req.routeIndex = 1
    expect(req.routePath).toBe('/:id/:name')
  })
})

describe('req.addValidatedData() and req.data()', () => {
  const rawRequest = new Request('http://localhost')

  const payload = {
    title: 'hello',
    author: {
      name: 'young man',
      age: 20,
    },
  }

  test('add data - json', () => {
    const req = new HonoRequest<'/', { json: typeof payload }>(rawRequest)
    req.addValidatedData('json', payload)
    const data = req.valid('json')
    expect(data).toEqual(payload)
  })

  test('replace data - json', () => {
    const req = new HonoRequest<'/', { json: typeof payload }>(rawRequest)
    req.addValidatedData('json', payload)
    req.addValidatedData('json', {
      tag: ['sport', 'music'],
      author: {
        tall: 170,
      },
    })
    const data = req.valid('json')
    expect(data).toEqual({
      author: {
        tall: 170,
      },
      tag: ['sport', 'music'],
    })
  })
})

describe('headers', () => {
  test('empty string is a valid header value', () => {
    const req = new HonoRequest(new Request('http://localhost', { headers: { foo: '' } }))
    const foo = req.header('foo')
    expect(foo).toEqual('')
  })

  test('Keys of the arguments for req.header() are not case-sensitive', () => {
    const req = new HonoRequest(
      new Request('http://localhost', {
        headers: {
          'Content-Type': 'application/json',
          apikey: 'abc',
          lowercase: 'lowercase value',
        },
      })
    )
    expect(req.header('Content-Type')).toBe('application/json')
    expect(req.header('ApiKey')).toBe('abc')
  })
})

const text = '{"foo":"bar"}'
const json = { foo: 'bar' }
const buffer = new TextEncoder().encode('{"foo":"bar"}').buffer

describe('Body methods with caching', () => {
  test('req.text()', async () => {
    const req = new HonoRequest(
      new Request('http://localhost', {
        method: 'POST',
        body: text,
      })
    )
    expect(await req.text()).toEqual(text)
    expect(await req.json()).toEqual(json)
    expect(await req.arrayBuffer()).toEqual(buffer)
    expect(await req.blob()).toEqual(
      new Blob([text], {
        type: 'text/plain;charset=utf-8',
      })
    )
  })

  test('req.json()', async () => {
    const req = new HonoRequest(
      new Request('http://localhost', {
        method: 'POST',
        body: '{"foo":"bar"}',
      })
    )
    expect(await req.json()).toEqual(json)
    expect(await req.text()).toEqual(text)
    expect(await req.arrayBuffer()).toEqual(buffer)
    expect(await req.blob()).toEqual(
      new Blob([text], {
        type: 'text/plain;charset=utf-8',
      })
    )
  })

  test('req.arrayBuffer()', async () => {
    const buffer = new TextEncoder().encode('{"foo":"bar"}').buffer
    const req = new HonoRequest(
      new Request('http://localhost', {
        method: 'POST',
        body: buffer,
      })
    )
    expect(await req.arrayBuffer()).toEqual(buffer)
    expect(await req.text()).toEqual(text)
    expect(await req.json()).toEqual(json)
    expect(await req.blob()).toEqual(
      new Blob([text], {
        type: '',
      })
    )
  })

  test('req.blob()', async () => {
    const blob = new Blob(['{"foo":"bar"}'], {
      type: 'application/json',
    })
    const req = new HonoRequest(
      new Request('http://localhost', {
        method: 'POST',
        body: blob,
      })
    )
    expect(await req.blob()).toEqual(blob)
    expect(await req.text()).toEqual(text)
    expect(await req.json()).toEqual(json)
    expect(await req.arrayBuffer()).toEqual(buffer)
  })

  test('req.formData()', async () => {
    const data = new FormData()
    data.append('foo', 'bar')
    const req = new HonoRequest(
      new Request('http://localhost', {
        method: 'POST',
        body: data,
      })
    )
    expect((await req.formData()).get('foo')).toBe('bar')
    expect(async () => await req.text()).not.toThrow()
    expect(async () => await req.arrayBuffer()).not.toThrow()
    expect(async () => await req.blob()).not.toThrow()
  })

  describe('req.parseBody()', async () => {
    it('should parse form data', async () => {
      const data = new FormData()
      data.append('foo', 'bar')
      const req = new HonoRequest(
        new Request('http://localhost', {
          method: 'POST',
          body: data,
        })
      )
      expect((await req.parseBody())['foo']).toBe('bar')
      expect(async () => await req.text()).not.toThrow()
      expect(async () => await req.arrayBuffer()).not.toThrow()
      expect(async () => await req.blob()).not.toThrow()
    })

    describe('Return type', () => {
      let req: HonoRequest
      beforeEach(() => {
        const data = new FormData()
        data.append('foo', 'bar')
        req = new HonoRequest(
          new Request('http://localhost', {
            method: 'POST',
            body: data,
          })
        )
      })

      it('without options', async () => {
        expectTypeOf((await req.parseBody())['key']).toEqualTypeOf<string | File>()
      })

      it('{all: true}', async () => {
        expectTypeOf((await req.parseBody({ all: true }))['key']).toEqualTypeOf<
          string | File | (string | File)[]
        >()
      })

      it('{dot: true}', async () => {
        expectTypeOf((await req.parseBody({ dot: true }))['key']).toEqualTypeOf<
          string | File | RecursiveRecord<string, string | File>
        >()
      })

      it('{all: true, dot: true}', async () => {
        expectTypeOf((await req.parseBody({ all: true, dot: true }))['key']).toEqualTypeOf<
          | string
          | File
          | (string | File)[]
          | RecursiveRecord<string, string | File | (string | File)[]>
        >()
      })

      it('specify return type explicitly', async () => {
        expectTypeOf(
          await req.parseBody<{ key1: string; key2: string }>({ all: true, dot: true })
        ).toEqualTypeOf<{ key1: string; key2: string }>()
      })
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/request.ts
````typescript
/* eslint-disable @typescript-eslint/no-explicit-any */
import type { Result } from './router'
import type {
  Input,
  InputToDataByTarget,
  ParamKeyToRecord,
  ParamKeys,
  RemoveQuestion,
  RouterRoute,
  ValidationTargets,
} from './types'
import { parseBody } from './utils/body'
import type { BodyData, ParseBodyOptions } from './utils/body'
import type { CustomHeader, RequestHeader } from './utils/headers'
import type { Simplify, UnionToIntersection } from './utils/types'
import { decodeURIComponent_, getQueryParam, getQueryParams, tryDecode } from './utils/url'

type Body = {
  json: any
  text: string
  arrayBuffer: ArrayBuffer
  blob: Blob
  formData: FormData
}
type BodyCache = Partial<Body & { parsedBody: BodyData }>

const tryDecodeURIComponent = (str: string) => tryDecode(str, decodeURIComponent_)

export class HonoRequest<P extends string = '/', I extends Input['out'] = {}> {
  /**
   * `.raw` can get the raw Request object.
   *
   * @see {@link https://hono.dev/docs/api/request#raw}
   *
   * @example
   * ```ts
   * // For Cloudflare Workers
   * app.post('/', async (c) => {
   *   const metadata = c.req.raw.cf?.hostMetadata?
   *   ...
   * })
   * ```
   */
  raw: Request

  #validatedData: { [K in keyof ValidationTargets]?: {} } // Short name of validatedData
  #matchResult: Result<[unknown, RouterRoute]>
  routeIndex: number = 0
  /**
   * `.path` can get the pathname of the request.
   *
   * @see {@link https://hono.dev/docs/api/request#path}
   *
   * @example
   * ```ts
   * app.get('/about/me', (c) => {
   *   const pathname = c.req.path // `/about/me`
   * })
   * ```
   */
  path: string
  bodyCache: BodyCache = {}

  constructor(
    request: Request,
    path: string = '/',
    matchResult: Result<[unknown, RouterRoute]> = [[]]
  ) {
    this.raw = request
    this.path = path
    this.#matchResult = matchResult
    this.#validatedData = {}
  }

  /**
   * `.req.param()` gets the path parameters.
   *
   * @see {@link https://hono.dev/docs/api/routing#path-parameter}
   *
   * @example
   * ```ts
   * const name = c.req.param('name')
   * // or all parameters at once
   * const { id, comment_id } = c.req.param()
   * ```
   */
  param<P2 extends ParamKeys<P> = ParamKeys<P>>(key: P2 extends `${infer _}?` ? never : P2): string
  param<P2 extends RemoveQuestion<ParamKeys<P>> = RemoveQuestion<ParamKeys<P>>>(
    key: P2
  ): string | undefined
  param(key: string): string | undefined
  param<P2 extends string = P>(): Simplify<UnionToIntersection<ParamKeyToRecord<ParamKeys<P2>>>>
  param(key?: string): unknown {
    return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams()
  }

  #getDecodedParam(key: string): string | undefined {
    const paramKey = this.#matchResult[0][this.routeIndex][1][key]
    const param = this.#getParamValue(paramKey)
    return param ? (/\%/.test(param) ? tryDecodeURIComponent(param) : param) : undefined
  }

  #getAllDecodedParams(): Record<string, string> {
    const decoded: Record<string, string> = {}

    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1])
    for (const key of keys) {
      const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key])
      if (value && typeof value === 'string') {
        decoded[key] = /\%/.test(value) ? tryDecodeURIComponent(value) : value
      }
    }

    return decoded
  }

  #getParamValue(paramKey: any): string | undefined {
    return this.#matchResult[1] ? this.#matchResult[1][paramKey as any] : paramKey
  }

  /**
   * `.query()` can get querystring parameters.
   *
   * @see {@link https://hono.dev/docs/api/request#query}
   *
   * @example
   * ```ts
   * // Query params
   * app.get('/search', (c) => {
   *   const query = c.req.query('q')
   * })
   *
   * // Get all params at once
   * app.get('/search', (c) => {
   *   const { q, limit, offset } = c.req.query()
   * })
   * ```
   */
  query(key: string): string | undefined
  query(): Record<string, string>
  query(key?: string) {
    return getQueryParam(this.url, key)
  }

  /**
   * `.queries()` can get multiple querystring parameter values, e.g. /search?tags=A&tags=B
   *
   * @see {@link https://hono.dev/docs/api/request#queries}
   *
   * @example
   * ```ts
   * app.get('/search', (c) => {
   *   // tags will be string[]
   *   const tags = c.req.queries('tags')
   * })
   * ```
   */
  queries(key: string): string[] | undefined
  queries(): Record<string, string[]>
  queries(key?: string) {
    return getQueryParams(this.url, key)
  }

  /**
   * `.header()` can get the request header value.
   *
   * @see {@link https://hono.dev/docs/api/request#header}
   *
   * @example
   * ```ts
   * app.get('/', (c) => {
   *   const userAgent = c.req.header('User-Agent')
   * })
   * ```
   */
  header(name: RequestHeader): string | undefined
  header(name: string): string | undefined
  header(): Record<RequestHeader | (string & CustomHeader), string>
  header(name?: string) {
    if (name) {
      return this.raw.headers.get(name) ?? undefined
    }

    const headerData: Record<string, string | undefined> = {}
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value
    })
    return headerData
  }

  /**
   * `.parseBody()` can parse Request body of type `multipart/form-data` or `application/x-www-form-urlencoded`
   *
   * @see {@link https://hono.dev/docs/api/request#parsebody}
   *
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.parseBody()
   * })
   * ```
   */
  async parseBody<Options extends Partial<ParseBodyOptions>, T extends BodyData<Options>>(
    options?: Options
  ): Promise<T>
  async parseBody<T extends BodyData>(options?: Partial<ParseBodyOptions>): Promise<T>
  async parseBody(options?: Partial<ParseBodyOptions>) {
    return (this.bodyCache.parsedBody ??= await parseBody(this, options))
  }

  #cachedBody = (key: keyof Body) => {
    const { bodyCache, raw } = this
    const cachedBody = bodyCache[key]

    if (cachedBody) {
      return cachedBody
    }

    const anyCachedKey = Object.keys(bodyCache)[0]
    if (anyCachedKey) {
      return (bodyCache[anyCachedKey as keyof Body] as Promise<BodyInit>).then((body) => {
        if (anyCachedKey === 'json') {
          body = JSON.stringify(body)
        }
        return new Response(body)[key]()
      })
    }

    return (bodyCache[key] = raw[key]())
  }

  /**
   * `.json()` can parse Request body of type `application/json`
   *
   * @see {@link https://hono.dev/docs/api/request#json}
   *
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.json()
   * })
   * ```
   */
  json<T = any>(): Promise<T> {
    return this.#cachedBody('json')
  }

  /**
   * `.text()` can parse Request body of type `text/plain`
   *
   * @see {@link https://hono.dev/docs/api/request#text}
   *
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.text()
   * })
   * ```
   */
  text(): Promise<string> {
    return this.#cachedBody('text')
  }

  /**
   * `.arrayBuffer()` parse Request body as an `ArrayBuffer`
   *
   * @see {@link https://hono.dev/docs/api/request#arraybuffer}
   *
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.arrayBuffer()
   * })
   * ```
   */
  arrayBuffer(): Promise<ArrayBuffer> {
    return this.#cachedBody('arrayBuffer')
  }

  /**
   * Parses the request body as a `Blob`.
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.blob();
   * });
   * ```
   * @see https://hono.dev/docs/api/request#blob
   */
  blob(): Promise<Blob> {
    return this.#cachedBody('blob')
  }

  /**
   * Parses the request body as `FormData`.
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.formData();
   * });
   * ```
   * @see https://hono.dev/docs/api/request#formdata
   */
  formData(): Promise<FormData> {
    return this.#cachedBody('formData')
  }

  /**
   * Adds validated data to the request.
   *
   * @param target - The target of the validation.
   * @param data - The validated data to add.
   */
  addValidatedData(target: keyof ValidationTargets, data: {}) {
    this.#validatedData[target] = data
  }

  /**
   * Gets validated data from the request.
   *
   * @param target - The target of the validation.
   * @returns The validated data.
   *
   * @see https://hono.dev/docs/api/request#valid
   */
  valid<T extends keyof I & keyof ValidationTargets>(target: T): InputToDataByTarget<I, T>
  valid(target: keyof ValidationTargets) {
    return this.#validatedData[target] as unknown
  }

  /**
   * `.url()` can get the request url strings.
   *
   * @see {@link https://hono.dev/docs/api/request#url}
   *
   * @example
   * ```ts
   * app.get('/about/me', (c) => {
   *   const url = c.req.url // `http://localhost:8787/about/me`
   *   ...
   * })
   * ```
   */
  get url(): string {
    return this.raw.url
  }

  /**
   * `.method()` can get the method name of the request.
   *
   * @see {@link https://hono.dev/docs/api/request#method}
   *
   * @example
   * ```ts
   * app.get('/about/me', (c) => {
   *   const method = c.req.method // `GET`
   * })
   * ```
   */
  get method(): string {
    return this.raw.method
  }

  /**
   * `.matchedRoutes()` can return a matched route in the handler
   *
   * @see {@link https://hono.dev/docs/api/request#matchedroutes}
   *
   * @example
   * ```ts
   * app.use('*', async function logger(c, next) {
   *   await next()
   *   c.req.matchedRoutes.forEach(({ handler, method, path }, i) => {
   *     const name = handler.name || (handler.length < 2 ? '[handler]' : '[middleware]')
   *     console.log(
   *       method,
   *       ' ',
   *       path,
   *       ' '.repeat(Math.max(10 - path.length, 0)),
   *       name,
   *       i === c.req.routeIndex ? '<- respond from here' : ''
   *     )
   *   })
   * })
   * ```
   */
  get matchedRoutes(): RouterRoute[] {
    return this.#matchResult[0].map(([[, route]]) => route)
  }

  /**
   * `routePath()` can retrieve the path registered within the handler
   *
   * @see {@link https://hono.dev/docs/api/request#routepath}
   *
   * @example
   * ```ts
   * app.get('/posts/:id', (c) => {
   *   return c.json({ path: c.req.routePath })
   * })
   * ```
   */
  get routePath(): string {
    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path
  }
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/router.ts
````typescript
/**
 * @module
 * This module provides types definitions and variables for the routers.
 */

/**
 * Constant representing all HTTP methods in uppercase.
 */
export const METHOD_NAME_ALL = 'ALL' as const
/**
 * Constant representing all HTTP methods in lowercase.
 */
export const METHOD_NAME_ALL_LOWERCASE = 'all' as const
/**
 * Array of supported HTTP methods.
 */
export const METHODS = ['get', 'post', 'put', 'delete', 'options', 'patch'] as const
/**
 * Error message indicating that a route cannot be added because the matcher is already built.
 */
export const MESSAGE_MATCHER_IS_ALREADY_BUILT =
  'Can not add a route since the matcher is already built.'

/**
 * Interface representing a router.
 *
 * @template T - The type of the handler.
 */
export interface Router<T> {
  /**
   * The name of the router.
   */
  name: string

  /**
   * Adds a route to the router.
   *
   * @param method - The HTTP method (e.g., 'get', 'post').
   * @param path - The path for the route.
   * @param handler - The handler for the route.
   */
  add(method: string, path: string, handler: T): void

  /**
   * Matches a route based on the given method and path.
   *
   * @param method - The HTTP method (e.g., 'get', 'post').
   * @param path - The path to match.
   * @returns The result of the match.
   */
  match(method: string, path: string): Result<T>
}

/**
 * Type representing a map of parameter indices.
 */
export type ParamIndexMap = Record<string, number>
/**
 * Type representing a stash of parameters.
 */
export type ParamStash = string[]
/**
 * Type representing a map of parameters.
 */
export type Params = Record<string, string>
/**
 * Type representing the result of a route match.
 *
 * The result can be in one of two formats:
 * 1. An array of handlers with their corresponding parameter index maps, followed by a parameter stash.
 * 2. An array of handlers with their corresponding parameter maps.
 *
 * Example:
 *
 * [[handler, paramIndexMap][], paramArray]
 * ```typescript
 * [
 *   [
 *     [middlewareA, {}],                     // '*'
 *     [funcA,       {'id': 0}],              // '/user/:id/*'
 *     [funcB,       {'id': 0, 'action': 1}], // '/user/:id/:action'
 *   ],
 *   ['123', 'abc']
 * ]
 * ```
 *
 * [[handler, params][]]
 * ```typescript
 * [
 *   [
 *     [middlewareA, {}],                             // '*'
 *     [funcA,       {'id': '123'}],                  // '/user/:id/*'
 *     [funcB,       {'id': '123', 'action': 'abc'}], // '/user/:id/:action'
 *   ]
 * ]
 * ```
 */
export type Result<T> = [[T, ParamIndexMap][], ParamStash] | [[T, Params][]]

/**
 * Error class representing an unsupported path error.
 */
export class UnsupportedPathError extends Error {}

````
/Users/josh/Documents/GitHub/honojs/hono/src/types.test.ts
```typescript
/* eslint-disable @typescript-eslint/no-unused-vars */
import { expectTypeOf } from 'vitest'
import { Context } from './context'
import { createMiddleware } from './helper/factory'
import { Hono } from './hono'
import { poweredBy } from './middleware/powered-by'
import type {
  AddParam,
  Env,
  ExtractSchema,
  Handler,
  InputToDataByTarget,
  MergePath,
  MergeSchemaPath,
  MiddlewareHandler,
  ParamKeyToRecord,
  ParamKeys,
  RemoveQuestion,
  ResponseFormat,
  ToSchema,
  TypedResponse,
} from './types'
import type { ContentfulStatusCode, StatusCode } from './utils/http-status'
import type { Equal, Expect } from './utils/types'
import { validator } from './validator'

describe('Env', () => {
  test('Env', () => {
    type E = {
      Variables: {
        foo: string
      }
      Bindings: {
        FLAG: boolean
      }
    }
    const app = new Hono<E>()
    app.use('*', poweredBy())
    app.get('/', (c) => {
      const foo = c.get('foo')
      expectTypeOf(foo).toEqualTypeOf<string>()
      const FLAG = c.env.FLAG
      expectTypeOf(FLAG).toEqualTypeOf<boolean>()
      return c.text('foo')
    })
  })
})

describe('HandlerInterface', () => {
  type Env = {}

  type Payload = { foo: string; bar: boolean }

  describe('no path pattern', () => {
    const app = new Hono<Env>()
    const middleware: MiddlewareHandler<
      Env,
      '/',
      {
        in: { json: Payload }
        out: { json: Payload }
      }
    > = async (_c, next) => {
      await next()
    }
    test('Context', () => {
      const route = app.get(middleware, (c) => {
        type Expected = Context<
          Env,
          '/',
          {
            in: { json: Payload }
            out: { json: Payload }
          }
        >
        expectTypeOf(c).toEqualTypeOf<Expected>()
        return c.json({
          message: 'Hello!',
        })
      })
      app.get(middleware, (c) => {
        const data = c.req.valid('json')
        expectTypeOf(data).toEqualTypeOf<Payload>()
        return c.json({
          message: 'Hello!',
        })
      })
      type Actual = ExtractSchema<typeof route>
      type Expected = {
        '/': {
          $get: {
            input: {
              json: Payload
            }
            output: {
              message: string
            }
            outputFormat: 'json'
            status: ContentfulStatusCode
          }
        }
      }
      type verify = Expect<Equal<Expected, Actual>>
    })
  })

  describe('path pattern', () => {
    const app = new Hono<Env>()
    const middleware: MiddlewareHandler<
      Env,
      '/foo',
      { in: { json: Payload }; out: { json: Payload } }
    > = async (_c, next) => {
      await next()
    }
    test('Context and AppType', () => {
      const route = app.get('/foo', middleware, (c) => {
        type Expected = Context<Env, '/foo', { in: { json: Payload }; out: { json: Payload } }>
        expectTypeOf(c).toEqualTypeOf<Expected>()
        return c.json({
          message: 'Hello!',
        })
      })
      type Actual = ExtractSchema<typeof route>
      type Expected = {
        '/foo': {
          $get: {
            input: {
              json: {
                foo: string
                bar: boolean
              }
            }
            output: {
              message: string
            }
            outputFormat: 'json'
            status: ContentfulStatusCode
          }
        }
      }
      type verify = Expect<Equal<Expected, Actual>>
    })
  })

  describe('With path parameters', () => {
    const app = new Hono<Env>()
    const middleware: MiddlewareHandler<Env, '/post/:id'> = async (_c, next) => {
      await next()
    }
    it('Should have the `param` type', () => {
      const route = app.get('/post/:id', middleware, (c) => {
        return c.text('foo')
      })
      type Actual = ExtractSchema<typeof route>
      type Expected = {
        '/post/:id': {
          $get: {
            input: {
              param: {
                id: string
              }
            }
            output: 'foo'
            outputFormat: 'text'
            status: ContentfulStatusCode
          }
        }
      }
      type verify = Expect<Equal<Expected, Actual>>
    })
  })

  describe('Without path', () => {
    const app = new Hono<Env>().basePath('/foo/:foo')

    it('With basePath and path params', () => {
      const route = app.get(async (c) => {
        const foo = c.req.param('foo')
        expect(typeof foo).toBe('string')
        return c.text(foo)
      })
      type Actual = ExtractSchema<typeof route>

      type Expected = {
        '/foo/:foo': {
          $get: {
            input: {
              param: {
                foo: string
              }
            }
            output: string
            outputFormat: 'text'
            status: ContentfulStatusCode
          }
        }
      }
      type verify = Expect<Equal<Expected, Actual>>
    })

    it('Chained', () => {
      const route = app.post('/books/:id').get((c) => {
        const id = c.req.param('id')
        return c.text(id)
      })
      type Actual = ExtractSchema<typeof route>
      type Expected = {
        '/foo/:foo/books/:id': {
          $get: {
            input: {
              param: {
                id: string
              } & {
                foo: string
              }
            }
            output: string
            outputFormat: 'text'
            status: ContentfulStatusCode
          }
        }
      } & {
        '/foo/:foo/books/:id': {
          $post: {
            input: {
              param: {
                id: string
              } & {
                foo: string
              }
            }
            output: {}
            outputFormat: ResponseFormat
            status: StatusCode
          }
        }
      }
      type verify = Expect<Equal<Expected, Actual>>
    })
  })
})

describe('OnHandlerInterface', () => {
  const app = new Hono()
  test('Context', () => {
    const middleware: MiddlewareHandler<
      Env,
      '/purge',
      { in: { form: { id: string } }; out: { form: { id: number } } }
    > = async (_c, next) => {
      await next()
    }
    const route = app.on('PURGE', '/purge', middleware, (c) => {
      const data = c.req.valid('form')
      expectTypeOf(data).toEqualTypeOf<{ id: number }>()
      return c.json({
        success: true,
      })
    })
    type Actual = ExtractSchema<typeof route>
    type Expected = {
      '/purge': {
        $purge: {
          input: {
            form: {
              id: string
            }
          }
          output: {
            success: boolean
          }
          outputFormat: 'json'
          status: ContentfulStatusCode
        }
      }
    }
    type verify = Expect<Equal<Expected, Actual>>
  })

  test('app.on(method, path[], middleware, handler) should not throw a type error', () => {
    const middleware: MiddlewareHandler<{ Variables: { foo: string } }> = async () => {}
    app.on('GET', ['/a', '/b'], middleware, (c) => {
      expectTypeOf(c.var.foo).toEqualTypeOf<string>()
      return c.json({})
    })
  })
})

describe('TypedResponse', () => {
  test('unknown', () => {
    type Actual = TypedResponse
    type Expected = {
      _data: unknown
      _status: StatusCode
      _format: ResponseFormat
    }
    type verify = Expect<Equal<Expected, Actual>>
  })

  test('text auto infer', () => {
    type Actual = TypedResponse<string>
    type Expected = {
      _data: string
      _status: StatusCode
      _format: 'text'
    }
    type verify = Expect<Equal<Expected, Actual>>
  })

  test('json auto infer', () => {
    type Actual = TypedResponse<{ ok: true }>
    type Expected = {
      _data: { ok: true }
      _status: StatusCode
      _format: 'json'
    }
    type verify = Expect<Equal<Expected, Actual>>
  })
})

describe('Schema', () => {
  test('Schema', () => {
    type AppType = Hono<
      Env,
      ToSchema<
        'post',
        '/api/posts/:id',
        {
          in: {
            json: {
              id: number
              title: string
            }
          }
        },
        TypedResponse<
          {
            message: string
            success: boolean
          },
          StatusCode,
          'json'
        >
      >
    >

    type Actual = ExtractSchema<AppType>
    type Expected = {
      '/api/posts/:id': {
        $post: {
          input: {
            json: {
              id: number
              title: string
            }
          } & {
            param: {
              id: string
            }
          }
          output: {
            message: string
            success: boolean
          }
          outputFormat: 'json'
          status: StatusCode
        }
      }
    }
    type verify = Expect<Equal<Expected, Actual>>
  })
})

describe('Support c.json(undefined)', () => {
  it('Should return a correct type', () => {
    const app = new Hono().get('/this/is/a/test', async (c) => {
      return c.json(undefined)
    })
    type Actual = ExtractSchema<typeof app>
    type Expected = {
      '/this/is/a/test': {
        $get: {
          input: {}
          output: never
          outputFormat: 'json'
          status: ContentfulStatusCode
        }
      }
    }
    type verify = Expect<Equal<Expected, Actual>>
  })
})

describe('Test types of Handler', () => {
  type E = {
    Variables: {
      foo: number
    }
  }

  const url = 'http://localhost/'

  test('Env', async () => {
    const app = new Hono<E>()
    const handler: Handler<E> = (c) => {
      const foo = c.get('foo')
      expectTypeOf(foo).toEqualTypeOf<number>()
      const id = c.req.param('id')
      expectTypeOf(id).toEqualTypeOf<string>()
      return c.text('Hi')
    }
    app.get('/', handler)
    const res = await app.request(url)
    expect(res.status).toBe(200)
  })

  test('Env, Path', async () => {
    const app = new Hono<E>()
    const handler: Handler<E, '/'> = (c) => {
      const foo = c.get('foo')
      expectTypeOf(foo).toEqualTypeOf<number>()
      return c.text('Hi')
    }
    app.get('/', handler)

    const res = await app.request(url)
    expect(res.status).toBe(200)
  })

  type User = {
    name: string
    age: number
  }

  test('Env, Path, Type', async () => {
    const app = new Hono<E>()
    const handler: Handler<E, '/', { in: { json: User }; out: { json: User } }> = (c) => {
      const foo = c.get('foo')
      expectTypeOf(foo).toEqualTypeOf<number>()
      const { name } = c.req.valid('json')
      expectTypeOf(name).toEqualTypeOf<string>()
      return c.text('Hi')
    }
  })
})

describe('`json()`', () => {
  const app = new Hono<{ Variables: { foo: string } }>()
  app.get('/post/:id', (c) => {
    c.req.param('id')
    const id = c.req.param('id')
    return c.text('foo')
  })

  test('json', () => {
    const route = app.get('/hello', (c) => {
      return c.json({
        message: 'Hello!',
      })
    })
    type Actual = ExtractSchema<typeof route>
    type Expected = {
      '/hello': {
        $get: {
          input: {}
          output: {
            message: string
          }
          outputFormat: 'json'
          status: ContentfulStatusCode
        }
      }
    }
    type verify = Expect<Equal<Expected, Actual>>
  })

  test('json with specific status code', () => {
    const route = app.get('/hello', (c) => {
      return c.json(
        {
          message: 'Hello!',
        },
        200
      )
    })
    type Actual = ExtractSchema<typeof route>
    type Expected = {
      '/hello': {
        $get: {
          input: {}
          output: {
            message: string
          }
          outputFormat: 'json'
          status: 200
        }
      }
    }
    type verify = Expect<Equal<Expected, Actual>>
  })
})

describe('Path parameters', () => {
  test('ParamKeys', () => {
    type Actual = ParamKeys<'/posts/:postId/comment/:commentId'>
    type Expected = 'postId' | 'commentId'
    type verify = Expect<Equal<Expected, Actual>>
  })

  describe('ParamKeyToRecord', () => {
    test('With ?', () => {
      type Actual = ParamKeyToRecord<'/animal/type?'>
      type Expected = { [K in '/animal/type']: string | undefined }
      type verify = Expect<Equal<Expected, Actual>>
    })
    test('Without ?', () => {
      type Actual = ParamKeyToRecord<'/animal/type'>
      type Expected = { [K in '/animal/type']: string }
      type verify = Expect<Equal<Expected, Actual>>
    })
  })

  describe('Path parameters in app', () => {
    test('Optional parameters - /api/:a/:b?', () => {
      const app = new Hono()
      const routes = app.get('/api/:a/:b?', (c) => {
        const a = c.req.param('a')
        const b = c.req.param('b')
        expectTypeOf(a).toEqualTypeOf<string>()
        expectTypeOf(b).toEqualTypeOf<string | undefined>()
        return c.json({ a, b })
      })
      type T = ExtractSchema<typeof routes>
      type Output = T['/api/:a/:b?']['$get']['output']
      type Expected = {
        a: string
        b: string | undefined
      }
      type verify = Expect<Equal<Expected, Output>>
    })
  })
})

describe('For HonoRequest', () => {
  type Input = {
    json: {
      id: number
      title: string
    }
    query: {
      page: string
    }
  }

  test('InputToDataByType with value', () => {
    type Actual = InputToDataByTarget<Input, 'json'>
    type Expected = {
      id: number
      title: string
    }
    type verify = Expect<Equal<Expected, Actual>>
  })

  test('InputToDataByType without value', () => {
    type Actual = InputToDataByTarget<Input, 'form'>
    type verify = Expect<Equal<never, Actual>>
  })

  test('RemoveQuestion', () => {
    type Actual = RemoveQuestion<'/animal/type?'>
    type verify = Expect<Equal<'/animal/type', Actual>>
  })
})

describe('AddParam', () => {
  it('Should add params to input correctly', () => {
    type Actual = AddParam<
      {
        param: {
          id: string
        }
      } & {
        query: {
          page: string
        }
      },
      '/:id'
    >
    type Expected = {
      query: {
        page: string
      }
    } & {
      param: {
        id: string
      }
    }
    type verify = Expect<Equal<Expected, Actual>>
  })
})

describe('ToSchema', () => {
  it('Should convert parameters to schema correctly', () => {
    type Actual = ToSchema<
      'get',
      '/:id',
      { in: { param: { id: string }; query: { page: string } } },
      TypedResponse<{}>
    >
    type Expected = {
      '/:id': {
        $get: {
          input: {
            param: {
              id: string
            }
            query: {
              page: string
            }
          }
          output: {}
          outputFormat: 'json'
          status: StatusCode
        }
      }
    }
    type verify = Expect<Equal<Expected, Actual>>
  })
})

describe('MergePath', () => {
  it('Should merge paths correctly', () => {
    type path1 = MergePath<'/api', '/book'>
    type verify1 = Expect<Equal<'/api/book', path1>>
    type path2 = MergePath<'/api/', '/book'>
    type verify2 = Expect<Equal<'/api/book', path2>>
    type path3 = MergePath<'/api/', '/'>
    type verify3 = Expect<Equal<'/api/', path3>>
    type path4 = MergePath<'/api', '/'>
    type verify4 = Expect<Equal<'/api', path4>>
    type path5 = MergePath<'/', ''>
    type verify5 = Expect<Equal<'/', path5>>
    type path6 = MergePath<'', '/'>
    type verify6 = Expect<Equal<'/', path6>>
    type path7 = MergePath<'/', '/'>
    type verify7 = Expect<Equal<'/', path7>>
    type path8 = MergePath<'', ''>
    type verify8 = Expect<Equal<'/', path8>>
  })
})

describe('MergeSchemaPath', () => {
  it('Should merge schema and sub path correctly', () => {
    type Sub = ToSchema<
      'post',
      '/posts',
      {
        in: {
          json: {
            id: number
            title: string
          }
        }
      },
      TypedResponse<{
        message: string
      }>
    > &
      ToSchema<
        'get',
        '/posts',
        {},
        TypedResponse<{
          ok: boolean
        }>
      >

    type Actual = MergeSchemaPath<Sub, '/api'>

    type Expected = {
      '/api/posts': {
        $post: {
          input: {
            json: {
              id: number
              title: string
            }
          }
          output: {
            message: string
          }
          outputFormat: 'json'
          status: StatusCode
        }
        $get: {
          input: {}
          output: {
            ok: boolean
          }
          outputFormat: 'json'
          status: StatusCode
        }
      }
    }

    type verify = Expect<Equal<Expected, Actual>>
  })

  it('Should merge schema which has params and sub path does not have params', () => {
    type Actual = MergeSchemaPath<
      {
        '/': {
          $get: {
            input: {
              param: {
                id: string
              }
              query: {
                page: string
              }
            }
            output: {}
            outputFormat: 'json'
            status: StatusCode
          }
        }
      },
      '/something'
    >
    type Expected = {
      '/something': {
        $get: {
          input: {
            param: {
              id: string
            }
            query: {
              page: string
            }
          }
          output: {}
          outputFormat: 'json'
          status: StatusCode
        }
      }
    }
    type verify = Expect<Equal<Expected, Actual>>
  })

  type GetKey<T> = T extends Record<infer K, unknown> ? K : never

  it('Should remove a slash - `/` + `/`', () => {
    type Sub = ToSchema<'get', '/', {}, TypedResponse<{}>>
    type Actual = MergeSchemaPath<Sub, '/'>
    type verify = Expect<Equal<'/', GetKey<Actual>>>
  })

  it('Should remove a slash - `/tags` + `/`', () => {
    type Sub = ToSchema<'get', '/tags', {}, TypedResponse<{}>>
    type Actual = MergeSchemaPath<Sub, '/'>
    type verify = Expect<Equal<'/tags', GetKey<Actual>>>
  })

  it('Should remove a slash - `/` + `/tags`', () => {
    type Sub = ToSchema<'get', '/', {}, TypedResponse<{}>>
    type Actual = MergeSchemaPath<Sub, '/tags'>
    type verify = Expect<Equal<'/tags', GetKey<Actual>>>
  })

  test('MergeSchemaPath - SubPath has path params', () => {
    type Actual = MergeSchemaPath<ToSchema<'get', '/', {}, TypedResponse>, '/a/:b'>
    type Expected = {
      '/a/:b': {
        $get: {
          input: {
            param: {
              b: string
            }
          }
          output: {}
          outputFormat: ResponseFormat
          status: StatusCode
        }
      }
    }
    type verify = Expect<Equal<Expected, Actual>>
  })

  test('MergeSchemaPath - Path and SubPath have path params', () => {
    type Actual = MergeSchemaPath<ToSchema<'get', '/c/:d', {}, TypedResponse<{}>>, '/a/:b'>
    type Expected = {
      '/a/:b/c/:d': {
        $get: {
          input: {
            param: {
              d: string
            } & {
              b: string
            }
          }
          output: {}
          outputFormat: 'json'
          status: StatusCode
        }
      }
    }
    type verify = Expect<Equal<Expected, Actual>>
  })

  test('MergeSchemaPath - Path and SubPath have regexp path params', () => {
    type Actual = MergeSchemaPath<ToSchema<'get', '/c/:d{.+}', {}, TypedResponse<{}>>, '/a/:b{.+}'>
    type Expected = {
      '/a/:b{.+}/c/:d{.+}': {
        $get: {
          input: {
            param: {
              d: string
            } & {
              b: string
            }
          }
          output: {}
          outputFormat: 'json'
          status: StatusCode
        }
      }
    }
    type verify = Expect<Equal<Expected, Actual>>
  })

  test('MergeSchemaPath - Method has Endpoints as Union', () => {
    type Actual = MergeSchemaPath<
      {
        '/': {
          $get:
            | {
                input: {}
                output: {
                  error: string
                }
                outputFormat: 'json'
                status: 404
              }
            | {
                input: {}
                output: {
                  success: boolean
                }
                outputFormat: 'json'
                status: 200
              }
        }
      },
      '/api/hello'
    >
    type Expected = {
      '/api/hello': {
        $get:
          | {
              input: {}
              output: {
                error: string
              }
              outputFormat: 'json'
              status: 404
            }
          | {
              input: {}
              output: {
                success: boolean
              }
              outputFormat: 'json'
              status: 200
            }
      }
    }
    type verify = Expect<Equal<Expected, Actual>>
  })
})

describe('Different types using json()', () => {
  describe('no path pattern', () => {
    const app = new Hono()

    test('Three different types', () => {
      const route = app.get((c) => {
        const flag = false
        if (flag) {
          return c.json({
            ng: true,
          })
        }
        if (!flag) {
          return c.json({
            ok: true,
          })
        }
        return c.json({
          default: true,
        })
      })
      type Actual = ExtractSchema<typeof route>
      type Expected = {
        '/': {
          $get:
            | {
                input: {}
                output: {
                  ng: boolean
                }
                outputFormat: 'json'
                status: ContentfulStatusCode
              }
            | {
                input: {}
                output: {
                  ok: boolean
                }
                outputFormat: 'json'
                status: ContentfulStatusCode
              }
            | {
                input: {}
                output: {
                  default: boolean
                }
                outputFormat: 'json'
                status: ContentfulStatusCode
              }
        }
      }
      type verify = Expect<Equal<Expected, Actual>>
    })

    test('Three different types and status codes', () => {
      const route = app.get((c) => {
        const flag = false
        if (flag) {
          return c.json(
            {
              ng: true,
            },
            400
          )
        }
        if (!flag) {
          return c.json(
            {
              ok: true,
            },
            200
          )
        }
        return c.json({
          default: true,
        })
      })
      type Actual = ExtractSchema<typeof route>
      type Expected = {
        '/': {
          $get:
            | {
                input: {}
                output: {
                  ng: boolean
                }
                outputFormat: 'json'
                status: 400
              }
            | {
                input: {}
                output: {
                  ok: boolean
                }
                outputFormat: 'json'
                status: 200
              }
            | {
                input: {}
                output: {
                  default: boolean
                }
                outputFormat: 'json'
                status: ContentfulStatusCode
              }
        }
      }
      type verify = Expect<Equal<Expected, Actual>>
    })
  })

  describe('path pattern', () => {
    const app = new Hono()

    test('Three different types', () => {
      const route = app.get('/foo', (c) => {
        const flag = false
        if (flag) {
          return c.json({
            ng: true,
          })
        }
        if (!flag) {
          return c.json({
            ok: true,
          })
        }
        return c.json({
          default: true,
        })
      })
      type Actual = ExtractSchema<typeof route>
      type Expected = {
        '/foo': {
          $get:
            | {
                input: {}
                output: {
                  ng: boolean
                }
                outputFormat: 'json'
                status: ContentfulStatusCode
              }
            | {
                input: {}
                output: {
                  ok: boolean
                }
                outputFormat: 'json'
                status: ContentfulStatusCode
              }
            | {
                input: {}
                output: {
                  default: boolean
                }
                outputFormat: 'json'
                status: ContentfulStatusCode
              }
        }
      }
      type verify = Expect<Equal<Expected, Actual>>
    })

    test('Three different types and status codes', () => {
      const route = app.get('/foo', (c) => {
        const flag = false
        if (flag) {
          return c.json(
            {
              ng: true,
            },
            400
          )
        }
        if (!flag) {
          return c.json(
            {
              ok: true,
            },
            200
          )
        }
        return c.json({
          default: true,
        })
      })
      type Actual = ExtractSchema<typeof route>
      type Expected = {
        '/foo': {
          $get:
            | {
                input: {}
                output: {
                  ng: boolean
                }
                outputFormat: 'json'
                status: 400
              }
            | {
                input: {}
                output: {
                  ok: boolean
                }
                outputFormat: 'json'
                status: 200
              }
            | {
                input: {}
                output: {
                  default: boolean
                }
                outputFormat: 'json'
                status: ContentfulStatusCode
              }
        }
      }
      type verify = Expect<Equal<Expected, Actual>>
    })
  })
})

describe('json() in an async handler', () => {
  const app = new Hono()

  test('json', () => {
    const route = app.get(async (c) => {
      return c.json({
        ok: true,
      })
    })
    type Actual = ExtractSchema<typeof route>
    type Expected = {
      '/': {
        $get: {
          input: {}
          output: {
            ok: boolean
          }
          outputFormat: 'json'
          status: ContentfulStatusCode
        }
      }
    }
    type verify = Expect<Equal<Expected, Actual>>
  })

  test('json with specific status code', () => {
    const route = app.get(async (c) => {
      return c.json(
        {
          ok: true,
        },
        200
      )
    })
    type Actual = ExtractSchema<typeof route>
    type Expected = {
      '/': {
        $get: {
          input: {}
          output: {
            ok: boolean
          }
          outputFormat: 'json'
          status: 200
        }
      }
    }
    type verify = Expect<Equal<Expected, Actual>>
  })
})

/**
 * Other tests for `c.var` are written in `hono.test.ts`.
 * This tests are only for types.
 */
describe('c.var with chaining - test only types', () => {
  const mw1 = createMiddleware<
    { Variables: { foo1: string } },
    string,
    { out: { query: { bar1: number } } }
  >(async () => {})
  const mw2 = createMiddleware<
    { Variables: { foo2: string } },
    string,
    { out: { query: { bar2: number } } }
  >(async () => {})
  const mw3 = createMiddleware<
    { Variables: { foo3: string } },
    string,
    { out: { query: { bar3: number } } }
  >(async () => {})
  const mw4 = createMiddleware<
    { Variables: { foo4: string } },
    string,
    { out: { query: { bar4: number } } }
  >(async () => {})
  const mw5 = createMiddleware<
    { Variables: { foo5: string } },
    string,
    { out: { query: { bar5: number } } }
  >(async () => {})
  const mw6 = createMiddleware<
    { Variables: { foo6: string } },
    string,
    { out: { query: { bar6: number } } }
  >(async () => {})
  const mw7 = createMiddleware<
    { Variables: { foo7: string } },
    string,
    { out: { query: { bar7: number } } }
  >(async () => {})
  const mw8 = createMiddleware<
    { Variables: { foo8: string } },
    string,
    { out: { query: { bar8: number } } }
  >(async () => {})
  const mw9 = createMiddleware<
    { Variables: { foo9: string } },
    string,
    { out: { query: { bar9: number } } }
  >(async () => {})
  const mw10 = createMiddleware<
    { Variables: { foo10: string } },
    string,
    { out: { query: { bar10: number } } }
  >(async () => {})

  it('Should not throw type errors', () => {
    // app.get(handler...)

    new Hono().get(mw1).get('/', (c) => {
      expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
      return c.json(0)
    })

    new Hono().get(mw1, mw2).get('/', (c) => {
      expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
      return c.json(0)
    })

    new Hono().get(mw1, mw2, mw3).get('/', (c) => {
      expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo3).toEqualTypeOf<string>()
      return c.json(0)
    })

    new Hono().get(mw1, mw2, mw3, mw4).get('/', (c) => {
      expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo3).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo4).toEqualTypeOf<string>()
      return c.json(0)
    })

    new Hono().get(mw1, mw2, mw3, mw4, mw5).get('/', (c) => {
      expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo3).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo4).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo5).toEqualTypeOf<string>()
      return c.json(0)
    })

    new Hono().get(mw1, mw2, mw3, mw4, mw5, mw6).get('/', (c) => {
      expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo3).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo4).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo5).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo6).toEqualTypeOf<string>()
      return c.json(0)
    })

    new Hono().get(mw1, mw2, mw3, mw4, mw5, mw6, mw7).get('/', (c) => {
      expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo3).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo4).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo5).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo6).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo7).toEqualTypeOf<string>()
      return c.json(0)
    })

    new Hono().get(mw1, mw2, mw3, mw4, mw5, mw6, mw7, mw8).get('/', (c) => {
      expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo3).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo4).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo5).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo6).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo7).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo8).toEqualTypeOf<string>()
      return c.json(0)
    })

    new Hono().get(mw1, mw2, mw3, mw4, mw5, mw6, mw7, mw8, mw9).get('/', (c) => {
      expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo3).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo4).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo5).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo6).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo7).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo8).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo9).toEqualTypeOf<string>()
      return c.json(0)
    })

    new Hono().get(mw1, mw2, mw3, mw4, mw5, mw6, mw7, mw8, mw9, mw10).get('/', (c) => {
      expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo3).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo4).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo5).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo6).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo7).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo8).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo9).toEqualTypeOf<string>()
      expectTypeOf(c.var.foo10).toEqualTypeOf<string>()
      return c.json(0)
    })

    new Hono().get(
      mw1,
      mw2,
      mw3,
      mw4,
      mw5,
      mw6,
      mw7,
      mw8,
      async (c) => {
        expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo3).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo4).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo5).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo6).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo7).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo8).toEqualTypeOf<string>()
      },
      (c) => c.json(0)
    )

    new Hono().get(mw1, mw2, mw3, mw4, mw5, mw6, mw7, mw8, mw9, (c) => {
      expectTypeOf(c.req.valid('query')).toMatchTypeOf<{
        bar1: number
        bar2: number
        bar3: number
        bar4: number
        bar5: number
        bar6: number
        bar7: number
        bar8: number
        bar9: number
      }>()

      return c.json(0)
    })

    new Hono().get(
      '/',
      mw1,
      mw2,
      mw3,
      mw4,
      mw5,
      mw6,
      mw7,
      mw8,
      async (c) => {
        expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo3).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo4).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo5).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo6).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo7).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo8).toEqualTypeOf<string>()
      },
      (c) => c.json(0)
    )

    new Hono().get('/', mw1, mw2, mw3, mw4, mw5, mw6, mw7, mw8, mw9, (c) => {
      expectTypeOf(c.req.valid('query')).toMatchTypeOf<{
        bar1: number
        bar2: number
        bar3: number
        bar4: number
        bar5: number
        bar6: number
        bar7: number
        bar8: number
        bar9: number
      }>()

      return c.json(0)
    })

    type Env = {
      Variables: {
        init: number
      }
    }

    new Hono<Env>()
      .get('/', mw1, (c) => {
        expectTypeOf(c.get('init')).toEqualTypeOf<number>()
        expectTypeOf(c.var.init).toEqualTypeOf<number>()
        expectTypeOf(c.get('foo1')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
        return c.json(0)
      })
      .get('/', (c) => {
        expectTypeOf(c.get('init')).toEqualTypeOf<number>()
        expectTypeOf(c.var.init).toEqualTypeOf<number>()
        // @ts-expect-error foo1 is not typed
        c.get('foo1')
        // @ts-expect-error foo1 is not typed
        c.var.foo1
        return c.json(0)
      })
    new Hono<Env>()
      .get('/', mw1, mw2, (c) => {
        expectTypeOf(c.get('init')).toEqualTypeOf<number>()
        expectTypeOf(c.var.init).toEqualTypeOf<number>()
        expectTypeOf(c.get('foo1')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo2')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
        return c.json(0)
      })
      .get('/', (c) => {
        expectTypeOf(c.get('init')).toEqualTypeOf<number>()
        expectTypeOf(c.var.init).toEqualTypeOf<number>()
        // @ts-expect-error foo1 is not typed
        c.get('foo1')
        // @ts-expect-error foo1 is not typed
        c.var.foo1
        // @ts-expect-error foo2 is not typed
        c.get('foo2')
        // @ts-expect-error foo2 is not typed
        c.var.foo2
        return c.json(0)
      })
    new Hono<Env>()
      .get('/', mw1, mw2, mw3, (c) => {
        expectTypeOf(c.get('init')).toEqualTypeOf<number>()
        expectTypeOf(c.var.init).toEqualTypeOf<number>()
        expectTypeOf(c.get('foo1')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo2')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo3')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo3).toEqualTypeOf<string>()
        return c.json(0)
      })
      .get('/', (c) => {
        expectTypeOf(c.get('init')).toEqualTypeOf<number>()
        expectTypeOf(c.var.init).toEqualTypeOf<number>()
        // @ts-expect-error foo1 is not typed
        c.get('foo1')
        // @ts-expect-error foo1 is not typed
        c.var.foo1
        // @ts-expect-error foo2 is not typed
        c.get('foo2')
        // @ts-expect-error foo2 is not typed
        c.var.foo2
        // @ts-expect-error foo3 is not typed
        c.get('foo3')
        // @ts-expect-error foo3 is not typed
        c.var.foo3
        return c.json(0)
      })
    new Hono<Env>()
      .get('/', mw1, mw2, mw3, mw4, (c) => {
        expectTypeOf(c.get('init')).toEqualTypeOf<number>()
        expectTypeOf(c.var.init).toEqualTypeOf<number>()
        expectTypeOf(c.get('foo1')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo2')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo3')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo3).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo4')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo4).toEqualTypeOf<string>()
        return c.json(0)
      })
      .get('/', (c) => {
        expectTypeOf(c.get('init')).toEqualTypeOf<number>()
        expectTypeOf(c.var.init).toEqualTypeOf<number>()
        // @ts-expect-error foo1 is not typed
        c.get('foo1')
        // @ts-expect-error foo1 is not typed
        c.var.foo1
        // @ts-expect-error foo2 is not typed
        c.get('foo2')
        // @ts-expect-error foo2 is not typed
        c.var.foo2
        // @ts-expect-error foo3 is not typed
        c.get('foo3')
        // @ts-expect-error foo3 is not typed
        c.var.foo3
        // @ts-expect-error foo4 is not typed
        c.get('foo4')
        // @ts-expect-error foo4 is not typed
        c.var.foo4
        return c.json(0)
      })

    new Hono<Env>()
      .get('/', mw1, mw2, mw3, mw4, mw5, (c) => {
        expectTypeOf(c.get('init')).toEqualTypeOf<number>()
        expectTypeOf(c.var.init).toEqualTypeOf<number>()
        expectTypeOf(c.get('foo1')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo2')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo3')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo3).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo4')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo4).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo5')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo5).toEqualTypeOf<string>()
        return c.json(0)
      })
      .get('/', (c) => {
        expectTypeOf(c.get('init')).toEqualTypeOf<number>()
        expectTypeOf(c.var.init).toEqualTypeOf<number>()
        // @ts-expect-error foo1 is not typed
        c.get('foo1')
        // @ts-expect-error foo1 is not typed
        c.var.foo1
        // @ts-expect-error foo2 is not typed
        c.get('foo2')
        // @ts-expect-error foo2 is not typed
        c.var.foo2
        // @ts-expect-error foo3 is not typed
        c.get('foo3')
        // @ts-expect-error foo3 is not typed
        c.var.foo3
        // @ts-expect-error foo4 is not typed
        c.get('foo4')
        // @ts-expect-error foo4 is not typed
        c.var.foo4
        // @ts-expect-error foo5 is not typed
        c.get('foo5')
        // @ts-expect-error foo5 is not typed
        c.var.foo5
        return c.json(0)
      })
    new Hono<Env>()
      .get('/', mw1, mw2, mw3, mw4, mw5, mw6, (c) => {
        expectTypeOf(c.get('init')).toEqualTypeOf<number>()
        expectTypeOf(c.var.init).toEqualTypeOf<number>()
        expectTypeOf(c.get('foo1')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo2')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo3')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo3).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo4')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo4).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo5')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo5).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo6')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo6).toEqualTypeOf<string>()
        return c.json(0)
      })
      .get('/', (c) => {
        expectTypeOf(c.get('init')).toEqualTypeOf<number>()
        expectTypeOf(c.var.init).toEqualTypeOf<number>()
        // @ts-expect-error foo1 is not typed
        c.get('foo1')
        // @ts-expect-error foo1 is not typed
        c.var.foo1
        // @ts-expect-error foo2 is not typed
        c.get('foo2')
        // @ts-expect-error foo2 is not typed
        c.var.foo2
        // @ts-expect-error foo3 is not typed
        c.get('foo3')
        // @ts-expect-error foo3 is not typed
        c.var.foo3
        // @ts-expect-error foo4 is not typed
        c.get('foo4')
        // @ts-expect-error foo4 is not typed
        c.var.foo4
        // @ts-expect-error foo5 is not typed
        c.get('foo5')
        // @ts-expect-error foo5 is not typed
        c.var.foo5
        // @ts-expect-error foo6 is not typed
        c.get('foo6')
        // @ts-expect-error foo6 is not typed
        c.var.foo6
        return c.json(0)
      })
    new Hono<Env>()
      .get('/', mw1, mw2, mw3, mw4, mw5, mw6, mw7, (c) => {
        expectTypeOf(c.get('init')).toEqualTypeOf<number>()
        expectTypeOf(c.var.init).toEqualTypeOf<number>()
        expectTypeOf(c.get('foo1')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo2')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo3')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo3).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo4')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo4).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo5')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo5).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo6')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo6).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo7')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo7).toEqualTypeOf<string>()
        return c.json(0)
      })
      .get('/', (c) => {
        expectTypeOf(c.get('init')).toEqualTypeOf<number>()
        expectTypeOf(c.var.init).toEqualTypeOf<number>()
        // @ts-expect-error foo1 is not typed
        c.get('foo1')
        // @ts-expect-error foo1 is not typed
        c.var.foo1
        // @ts-expect-error foo2 is not typed
        c.get('foo2')
        // @ts-expect-error foo2 is not typed
        c.var.foo2
        // @ts-expect-error foo3 is not typed
        c.get('foo3')
        // @ts-expect-error foo3 is not typed
        c.var.foo3
        // @ts-expect-error foo4 is not typed
        c.get('foo4')
        // @ts-expect-error foo4 is not typed
        c.var.foo4
        // @ts-expect-error foo5 is not typed
        c.get('foo5')
        // @ts-expect-error foo5 is not typed
        c.var.foo5
        // @ts-expect-error foo6 is not typed
        c.get('foo6')
        // @ts-expect-error foo6 is not typed
        c.var.foo6
        // @ts-expect-error foo7 is not typed
        c.get('foo7')
        // @ts-expect-error foo7 is not typed
        c.var.foo7
        return c.json(0)
      })
    new Hono<Env>()
      .get('/', mw1, mw2, mw3, mw4, mw5, mw6, mw7, mw8, (c) => {
        expectTypeOf(c.get('init')).toEqualTypeOf<number>()
        expectTypeOf(c.var.init).toEqualTypeOf<number>()
        expectTypeOf(c.get('foo1')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo2')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo3')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo3).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo4')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo4).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo5')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo5).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo6')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo6).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo7')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo7).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo8')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo8).toEqualTypeOf<string>()
        return c.json(0)
      })
      .get('/', (c) => {
        expectTypeOf(c.get('init')).toEqualTypeOf<number>()
        expectTypeOf(c.var.init).toEqualTypeOf<number>()
        // @ts-expect-error foo1 is not typed
        c.get('foo1')
        // @ts-expect-error foo1 is not typed
        c.var.foo1
        // @ts-expect-error foo2 is not typed
        c.get('foo2')
        // @ts-expect-error foo2 is not typed
        c.var.foo2
        // @ts-expect-error foo3 is not typed
        c.get('foo3')
        // @ts-expect-error foo3 is not typed
        c.var.foo3
        // @ts-expect-error foo4 is not typed
        c.get('foo4')
        // @ts-expect-error foo4 is not typed
        c.var.foo4
        // @ts-expect-error foo5 is not typed
        c.get('foo5')
        // @ts-expect-error foo5 is not typed
        c.var.foo5
        // @ts-expect-error foo6 is not typed
        c.get('foo6')
        // @ts-expect-error foo6 is not typed
        c.var.foo6
        // @ts-expect-error foo7 is not typed
        c.get('foo7')
        // @ts-expect-error foo7 is not typed
        c.var.foo7
        // @ts-expect-error foo8 is not typed
        c.get('foo8')
        // @ts-expect-error foo8 is not typed
        c.var.foo8
        return c.json(0)
      })

    new Hono<Env>()
      .get('/', mw1, mw2, mw3, mw4, mw5, mw6, mw7, mw8, mw9, (c) => {
        expectTypeOf(c.get('init')).toEqualTypeOf<number>()
        expectTypeOf(c.var.init).toEqualTypeOf<number>()
        expectTypeOf(c.get('foo1')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo2')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo3')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo3).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo4')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo4).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo5')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo5).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo6')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo6).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo7')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo7).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo8')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo8).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo9')).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo9).toEqualTypeOf<string>()
        return c.json(0)
      })
      .get('/', (c) => {
        expectTypeOf(c.get('init')).toEqualTypeOf<number>()
        expectTypeOf(c.var.init).toEqualTypeOf<number>()
        // @ts-expect-error foo1 is not typed
        c.get('foo1')
        // @ts-expect-error foo1 is not typed
        c.var.foo1
        // @ts-expect-error foo2 is not typed
        c.get('foo2')
        // @ts-expect-error foo2 is not typed
        c.var.foo2
        // @ts-expect-error foo3 is not typed
        c.get('foo3')
        // @ts-expect-error foo3 is not typed
        c.var.foo3
        // @ts-expect-error foo4 is not typed
        c.get('foo4')
        // @ts-expect-error foo4 is not typed
        c.var.foo4
        // @ts-expect-error foo5 is not typed
        c.get('foo5')
        // @ts-expect-error foo5 is not typed
        c.var.foo5
        // @ts-expect-error foo6 is not typed
        c.get('foo6')
        // @ts-expect-error foo6 is not typed
        c.var.foo6
        // @ts-expect-error foo7 is not typed
        c.get('foo7')
        // @ts-expect-error foo7 is not typed
        c.var.foo7
        // @ts-expect-error foo8 is not typed
        c.get('foo8')
        // @ts-expect-error foo8 is not typed
        c.var.foo8
        // @ts-expect-error foo9 is not typed
        c.get('foo9')
        // @ts-expect-error foo9 is not typed
        c.var.foo9
        return c.json(0)
      })
  })
})

/**
 *
 * Declaring a ContextVariableMap for testing.
 */
declare module './context' {
  interface ContextVariableMap {
    payload: string
  }
}

describe('ContextVariableMap type tests', () => {
  it('Should not throw type errors with c.var', () => {
    new Hono().get((c) => {
      expectTypeOf(c.get('payload')).toEqualTypeOf<string>()
      return c.json(0)
    })
    new Hono().get((c) => {
      expectTypeOf(c.var.payload).toEqualTypeOf<string>()
      return c.json(0)
    })
  })

  it('Should override ContextVariableMap with env variables', () => {
    const middleware = createMiddleware<{
      Variables: {
        payload: number
      }
    }>(async (c, next) => {
      c.set('payload', 123)
      await next()
    })

    new Hono().get(middleware, (c) => {
      expectTypeOf(c.get('payload')).toEqualTypeOf<number>()
      return c.json(0)
    })
  })

  it('Should use ContextVariableMap when c is Context<any>', () => {
    const c = new Context(new Request('http://localhost'))
    expectTypeOf(c.get('payload')).toEqualTypeOf<string>()
    expectTypeOf(c.var.payload).toEqualTypeOf<string>()
    // @ts-expect-error the value of payload should be string
    expectTypeOf(c.set('payload', 123))
  })
})

/**
 * It's challenge to test all cases. This is a minimal pattern.
 */
describe('Env types with chained routes - test only types', () => {
  const app = new Hono<{ Variables: { testVar: string } }>()
  it('Should not throw a type error', () => {
    app
      .post(
        '/',
        validator('json', (v) => v),
        async (c) => {
          expectTypeOf(c.get('testVar')).toEqualTypeOf<string>()
          return c.json({ success: true })
        }
      )
      .patch(
        '/',
        validator('json', (v) => v),
        async (c) => {
          expectTypeOf(c.get('testVar')).toEqualTypeOf<string>()
          return c.json({ success: true })
        }
      )
  })
})

/**
 * Ref: https://github.com/honojs/hono/issues/3027
 */
describe('Env types with validator as first middleware - test only types', () => {
  const app = new Hono<{ Variables: { testVar: string } }>()
  it('Should not throw a type error', () => {
    const testApp = app.get(
      validator('json', () => {
        return {
          cd: 'bar',
        }
      }),
      async (c) => {
        const foo = c.req.valid('json') // Error here
        return c.json(1)
      }
    )

    const dummyMiddleware1 = createMiddleware(async (c, next) => {
      await next()
    })
    // Multiple levels of middleware
    const testApp2 = app.post(
      validator('json', () => {
        return {
          cd: 'bar',
        }
      }),
      dummyMiddleware1,
      createMiddleware(async (c, next) => {
        await next()
      }),
      async (c) => {
        const foo = c.req.valid('json') // Error here also
        return c.json(1)
      }
    )
  })
})

describe('Env types with `use` middleware - test only types', () => {
  const app = new Hono()

  const mw1 = createMiddleware<{ Variables: { foo1: string } }>(async () => {})
  const mw2 = createMiddleware<{ Variables: { foo2: string } }>(async () => {})

  it('Should not throw a type error', () => {
    app
      .use(mw1)
      .use(mw2)
      .get('/', (c) => {
        expectTypeOf(c.get('foo1')).toEqualTypeOf<string>()
        expectTypeOf(c.get('foo2')).toEqualTypeOf<string>()
        return c.json({ success: true })
      })
    app.use(mw1, mw2).get('/', (c) => {
      expectTypeOf(c.get('foo1')).toEqualTypeOf<string>()
      expectTypeOf(c.get('foo2')).toEqualTypeOf<string>()
      return c.json({ success: true })
    })
  })
})

describe('Env types and a path type with `app.use(path, handler...)` - test only types', () => {
  it('Should not throw a type error', () => {
    type Env = {
      Variables: {
        foo: string
      }
    }

    // app.use(path, handler)
    new Hono<Env>()
      .use('/:id', async (c, next) => {
        expectTypeOf(c.var.foo).toEqualTypeOf<string>()
        expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
        await next()
      })
      .get((c) => {
        expectTypeOf(c.var.foo).toEqualTypeOf<string>()
        expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
        return c.json(0)
      })

    // app.use(path, handler x2)
    new Hono<Env>()
      .use(
        '/:id',
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        }
      )
      .get((c) => {
        expectTypeOf(c.var.foo).toEqualTypeOf<string>()
        expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
        return c.json(0)
      })

    // app.use(path, handler x3)
    new Hono<Env>()
      .use(
        '/:id',
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        }
      )
      .get((c) => {
        expectTypeOf(c.var.foo).toEqualTypeOf<string>()
        expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
        return c.json(0)
      })

    // app.use(path, handler x4)
    new Hono<Env>()
      .use(
        '/:id',
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        }
      )
      .get((c) => {
        expectTypeOf(c.var.foo).toEqualTypeOf<string>()
        expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
        return c.json(0)
      })

    // app.use(path, handler x5)
    new Hono<Env>()
      .use(
        '/:id',
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        }
      )
      .get((c) => {
        expectTypeOf(c.var.foo).toEqualTypeOf<string>()
        expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
        return c.json(0)
      })

    // app.use(path, handler x6)
    new Hono<Env>()
      .use(
        '/:id',
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        }
      )
      .get((c) => {
        expectTypeOf(c.var.foo).toEqualTypeOf<string>()
        expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
        return c.json(0)
      })

    // app.use(path, handler x7)
    new Hono<Env>()
      .use(
        '/:id',
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        }
      )
      .get((c) => {
        expectTypeOf(c.var.foo).toEqualTypeOf<string>()
        expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
        return c.json(0)
      })

    // app.use(path, handler x8)
    new Hono<Env>()
      .use(
        '/:id',
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        }
      )
      .get((c) => {
        expectTypeOf(c.var.foo).toEqualTypeOf<string>()
        expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
        return c.json(0)
      })

    // app.use(path, handler x9)
    new Hono<Env>()
      .use(
        '/:id',
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        }
      )
      .get((c) => {
        expectTypeOf(c.var.foo).toEqualTypeOf<string>()
        expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
        return c.json(0)
      })

    // app.use(path, handler x10)
    new Hono<Env>()
      .use(
        '/:id',
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        },
        async (c, next) => {
          expectTypeOf(c.var.foo).toEqualTypeOf<string>()
          expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
          await next()
        }
      )
      .get((c) => {
        expectTypeOf(c.var.foo).toEqualTypeOf<string>()
        expectTypeOf(c.req.param('id')).toEqualTypeOf<string>()
        return c.json(0)
      })
  })
})

// https://github.com/honojs/hono/issues/3122
describe('Returning type from `app.use(path, mw)`', () => {
  const mw = createMiddleware(async (c, next) => {
    await next()
  })
  it('Should not mark `*` as never', () => {
    const app = new Hono().use('*', mw)
    type Actual = ExtractSchema<typeof app>
    type Expected = {
      '*': {}
    }
    type verify = Expect<Equal<Expected, Actual>>
  })
})

describe('generic typed variables', () => {
  const okHelper = (c: Context) => {
    return <TData>(data: TData) => c.json({ data })
  }
  type Variables = {
    ok: ReturnType<typeof okHelper>
  }
  const app = new Hono<{ Variables: Variables }>()

  it('Should set and get variables with correct types', async () => {
    const route = app
      .use('*', async (c, next) => {
        c.set('ok', okHelper(c))
        await next()
      })
      .get('/', (c) => {
        const ok = c.get('ok')
        return ok('Hello')
      })
    type Actual = ExtractSchema<typeof route>['/']['$get']['output']
    type Expected = { data: string }
    expectTypeOf<Actual>().toEqualTypeOf<Expected>()
  })
})

describe('status code', () => {
  const app = new Hono()

  it('should only allow to return .json() with contentful status codes', async () => {
    const route = app.get('/', async (c) => c.json({}))
    type Actual = ExtractSchema<typeof route>['/']['$get']['status']
    expectTypeOf<Actual>().toEqualTypeOf<ContentfulStatusCode>()
  })

  it('should only allow to return .body(null) with all status codes', async () => {
    const route = app.get('/', async (c) => c.body(null))
    type Actual = ExtractSchema<typeof route>['/']['$get']['status']
    expectTypeOf<Actual>().toEqualTypeOf<StatusCode>()
  })

  it('should only allow to return .text() with contentful status codes', async () => {
    const route = app.get('/', async (c) => c.text('whatever'))
    type Actual = ExtractSchema<typeof route>['/']['$get']['status']
    expectTypeOf<Actual>().toEqualTypeOf<ContentfulStatusCode>()
  })

  it('should throw type error when .json({}) is used with contentless status codes', async () => {
    // @ts-expect-error 204 is not contentful status code
    app.get('/', async (c) => c.json({}, 204))
    app.get('/', async (c) =>
      c.json(
        {},
        // @ts-expect-error 204 is not contentful status code
        {
          status: 204,
        }
      )
    )
  })

  it('should throw type error when .body(content) is used with contentless status codes', async () => {
    // @ts-expect-error 204 is not contentful status code
    app.get('/', async (c) => c.body('content', 204))
    // @ts-expect-error 204 is not contentful status code
    app.get('/', async (c) => c.body('content', { status: 204 }))
  })

  it('should throw type error when .text(content) is used with contentless status codes', async () => {
    // @ts-expect-error 204 is not contentful status code
    app.get('/', async (c) => c.text('content', 204))
    // @ts-expect-error 204 is not contentful status code
    app.get('/', async (c) => c.text('content', { status: 204 }))
  })

  it('should throw type error when .html(content) is used with contentless status codes', async () => {
    // @ts-expect-error 204 is not contentful status code
    app.get('/', async (c) => c.html('<h1>title</h1>', 204))
    // @ts-expect-error 204 is not contentful status code
    app.get('/', async (c) => c.html('<h1>title</h1>', { status: 204 }))
  })

  it('.body() not override other responses in hono client', async () => {
    const router = app.get('/', async (c) => {
      if (c.req.header('Content-Type') === 'application/json') {
        return c.text('Hello', 200)
      }

      if (c.req.header('Content-Type') === 'application/x-www-form-urlencoded') {
        return c.body('Hello', 201)
      }

      return c.body(null, 204)
    })

    type Actual = ExtractSchema<typeof router>['/']['$get']['status']
    expectTypeOf<Actual>().toEqualTypeOf<204 | 201 | 200>()
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/types.ts
```typescript
/**
 * @module
 * This module contains some type definitions for the Hono modules.
 */

/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/no-explicit-any */
import type { Context } from './context'
import type { HonoBase } from './hono-base'
import type { CustomHeader, RequestHeader } from './utils/headers'
import type { StatusCode } from './utils/http-status'
import type {
  IfAnyThenEmptyObject,
  IsAny,
  JSONValue,
  RemoveBlankRecord,
  Simplify,
  UnionToIntersection,
} from './utils/types'

////////////////////////////////////////
//////                            //////
//////           Values           //////
//////                            //////
////////////////////////////////////////

export type Bindings = object
export type Variables = object

export type BlankEnv = {}
export type Env = {
  Bindings?: Bindings
  Variables?: Variables
}

export type Next = () => Promise<void>

export type ExtractInput<I extends Input | Input['in']> = I extends Input
  ? unknown extends I['in']
    ? {}
    : I['in']
  : I
export type Input = {
  in?: {}
  out?: {}
  outputFormat?: ResponseFormat
}

export type BlankSchema = {}
export type BlankInput = {}

////////////////////////////////////////
//////                            //////
//////          Routes            //////
//////                            //////
////////////////////////////////////////

export interface RouterRoute {
  path: string
  method: string
  handler: H
}

////////////////////////////////////////
//////                            //////
//////          Handlers          //////
//////                            //////
////////////////////////////////////////

export type HandlerResponse<O> = Response | TypedResponse<O> | Promise<Response | TypedResponse<O>>

export type Handler<
  E extends Env = any,
  P extends string = any,
  I extends Input = BlankInput,
  R extends HandlerResponse<any> = any
> = (c: Context<E, P, I>, next: Next) => R

export type MiddlewareHandler<
  E extends Env = any,
  P extends string = string,
  I extends Input = {}
> = (c: Context<E, P, I>, next: Next) => Promise<Response | void>

export type H<
  E extends Env = any,
  P extends string = any,
  I extends Input = BlankInput,
  R extends HandlerResponse<any> = any
> = Handler<E, P, I, R> | MiddlewareHandler<E, P, I>

export type NotFoundHandler<E extends Env = any> = (c: Context<E>) => Response | Promise<Response>

export interface HTTPResponseError extends Error {
  getResponse: () => Response
}
export type ErrorHandler<E extends Env = any> = (
  err: Error | HTTPResponseError,
  c: Context<E>
) => Response | Promise<Response>

////////////////////////////////////////
//////                            //////
//////     HandlerInterface       //////
//////                            //////
////////////////////////////////////////

export interface HandlerInterface<
  E extends Env = Env,
  M extends string = string,
  S extends Schema = BlankSchema,
  BasePath extends string = '/'
> {
  // app.get(handler)
  <
    P extends string = ExtractStringKey<S> extends never ? BasePath : ExtractStringKey<S>,
    I extends Input = BlankInput,
    R extends HandlerResponse<any> = any,
    E2 extends Env = E
  >(
    handler: H<E2, P, I, R>
  ): HonoBase<IntersectNonAnyTypes<[E, E2]>, S & ToSchema<M, P, I, MergeTypedResponse<R>>, BasePath>

  // app.get(handler x2)
  <
    P extends string = ExtractStringKey<S> extends never ? BasePath : ExtractStringKey<S>,
    I extends Input = BlankInput,
    I2 extends Input = I,
    R extends HandlerResponse<any> = any,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>
  >(
    ...handlers: [H<E2, P, I>, H<E3, P, I2, R>]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3]>,
    S & ToSchema<M, P, I2, MergeTypedResponse<R>>,
    BasePath
  >

  // app.get(path, handler)
  <
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    E2 extends Env = E
  >(
    path: P,
    handler: H<E2, MergedPath, I, R>
  ): HonoBase<E, S & ToSchema<M, MergePath<BasePath, P>, I, MergeTypedResponse<R>>, BasePath>

  // app.get(handler x 3)
  <
    P extends string = ExtractStringKey<S> extends never ? BasePath : ExtractStringKey<S>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>
  >(
    ...handlers: [H<E2, P, I>, H<E3, P, I2>, H<E4, P, I3, R>]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4]>,
    S & ToSchema<M, P, I3, MergeTypedResponse<R>>,
    BasePath
  >

  // app.get(path, handler x2)
  <
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>
  >(
    path: P,
    ...handlers: [H<E2, MergedPath, I>, H<E3, MergedPath, I2, R>]
  ): HonoBase<E, S & ToSchema<M, MergePath<BasePath, P>, I2, MergeTypedResponse<R>>, BasePath>

  // app.get(handler x 4)
  <
    P extends string = ExtractStringKey<S> extends never ? BasePath : ExtractStringKey<S>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>
  >(
    ...handlers: [H<E2, P, I>, H<E3, P, I2>, H<E4, P, I3>, H<E5, P, I4, R>]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    S & ToSchema<M, P, I4, MergeTypedResponse<R>>,
    BasePath
  >

  // app.get(path, handler x3)
  <
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>
  >(
    path: P,
    ...handlers: [H<E2, MergedPath, I>, H<E3, MergedPath, I2>, H<E4, MergedPath, I3, R>]
  ): HonoBase<E, S & ToSchema<M, MergePath<BasePath, P>, I3, MergeTypedResponse<R>>, BasePath>

  // app.get(handler x 5)
  <
    P extends string = ExtractStringKey<S> extends never ? BasePath : ExtractStringKey<S>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>
  >(
    ...handlers: [H<E2, P, I>, H<E3, P, I2>, H<E4, P, I3>, H<E5, P, I4>, H<E6, P, I5, R>]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    S & ToSchema<M, P, I5, MergeTypedResponse<R>>,
    BasePath
  >

  // app.get(path, handler x4)
  <
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>
  >(
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4, R>
    ]
  ): HonoBase<E, S & ToSchema<M, MergePath<BasePath, P>, I4, MergeTypedResponse<R>>, BasePath>

  // app.get(handler x 6)
  <
    P extends string = ExtractStringKey<S> extends never ? BasePath : ExtractStringKey<S>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>
  >(
    ...handlers: [
      H<E2, P, I>,
      H<E3, P, I2>,
      H<E4, P, I3>,
      H<E5, P, I4>,
      H<E6, P, I5>,
      H<E7, P, I6, R>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    S & ToSchema<M, P, I6, MergeTypedResponse<R>>,
    BasePath
  >

  // app.get(path, handler x5)
  <
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>
  >(
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4>,
      H<E6, MergedPath, I5, R>
    ]
  ): HonoBase<E, S & ToSchema<M, MergePath<BasePath, P>, I5, MergeTypedResponse<R>>, BasePath>

  // app.get(handler x 7)
  <
    P extends string = ExtractStringKey<S> extends never ? BasePath : ExtractStringKey<S>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    I7 extends Input = I & I2 & I3 & I4 & I5 & I6,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>
  >(
    ...handlers: [
      H<E2, P, I>,
      H<E3, P, I2>,
      H<E4, P, I3>,
      H<E5, P, I4>,
      H<E6, P, I5>,
      H<E7, P, I6>,
      H<E8, P, I7, R>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>,
    S & ToSchema<M, P, I7, MergeTypedResponse<R>>,
    BasePath
  >

  // app.get(path, handler x6)
  <
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>
  >(
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4>,
      H<E6, MergedPath, I5>,
      H<E7, MergedPath, I6, R>
    ]
  ): HonoBase<E, S & ToSchema<M, MergePath<BasePath, P>, I6, MergeTypedResponse<R>>, BasePath>

  // app.get(handler x 8)
  <
    P extends string = ExtractStringKey<S> extends never ? BasePath : ExtractStringKey<S>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    I7 extends Input = I & I2 & I3 & I4 & I5 & I6,
    I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    E9 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>
  >(
    ...handlers: [
      H<E2, P, I>,
      H<E3, P, I2>,
      H<E4, P, I3>,
      H<E5, P, I4>,
      H<E6, P, I5>,
      H<E7, P, I6>,
      H<E8, P, I7>,
      H<E9, P, I8, R>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9]>,
    S & ToSchema<M, P, I8, MergeTypedResponse<R>>,
    BasePath
  >

  // app.get(path, handler x7)
  <
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    I7 extends Input = I & I2 & I3 & I4 & I5 & I6,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>
  >(
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4>,
      H<E6, MergedPath, I5>,
      H<E7, MergedPath, I6>,
      H<E8, MergedPath, I7, R>
    ]
  ): HonoBase<E, S & ToSchema<M, MergePath<BasePath, P>, I7, MergeTypedResponse<R>>, BasePath>

  // app.get(handler x 9)
  <
    P extends string = ExtractStringKey<S> extends never ? BasePath : ExtractStringKey<S>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    I7 extends Input = I & I2 & I3 & I4 & I5 & I6,
    I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7,
    I9 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    E9 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>,
    E10 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9]>
  >(
    ...handlers: [
      H<E2, P, I>,
      H<E3, P, I2>,
      H<E4, P, I3>,
      H<E5, P, I4>,
      H<E6, P, I5>,
      H<E7, P, I6>,
      H<E8, P, I7>,
      H<E9, P, I8>,
      H<E10, P, I9, R>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9, E10]>,
    S & ToSchema<M, P, I9, MergeTypedResponse<R>>,
    BasePath
  >

  // app.get(path, handler x8)
  <
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    I7 extends Input = I & I2 & I3 & I4 & I5 & I6,
    I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    E9 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>
  >(
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4>,
      H<E6, MergedPath, I5>,
      H<E7, MergedPath, I6>,
      H<E8, MergedPath, I7>,
      H<E9, MergedPath, I8, R>
    ]
  ): HonoBase<E, S & ToSchema<M, MergePath<BasePath, P>, I8, MergeTypedResponse<R>>, BasePath>

  // app.get(handler x 10)
  <
    P extends string = ExtractStringKey<S> extends never ? BasePath : ExtractStringKey<S>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    I7 extends Input = I & I2 & I3 & I4 & I5 & I6,
    I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7,
    I9 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8,
    I10 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8 & I9,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    E9 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>,
    E10 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9]>,
    E11 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9, E10]>
  >(
    ...handlers: [
      H<E2, P, I>,
      H<E3, P, I2>,
      H<E4, P, I3>,
      H<E5, P, I4>,
      H<E6, P, I5>,
      H<E7, P, I6>,
      H<E8, P, I7>,
      H<E9, P, I8>,
      H<E10, P, I9>,
      H<E11, P, I10, R>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9, E10, E11]>,
    S & ToSchema<M, P, I10, MergeTypedResponse<R>>,
    BasePath
  >

  // app.get(path, handler x9)
  <
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    I7 extends Input = I & I2 & I3 & I4 & I5 & I6,
    I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7,
    I9 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    E9 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>,
    E10 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9]>
  >(
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4>,
      H<E6, MergedPath, I5>,
      H<E7, MergedPath, I6>,
      H<E8, MergedPath, I7>,
      H<E9, MergedPath, I8>,
      H<E10, MergedPath, I9, R>
    ]
  ): HonoBase<E, S & ToSchema<M, MergePath<BasePath, P>, I9, MergeTypedResponse<R>>, BasePath>

  // app.get(path, handler x10)
  <
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    I7 extends Input = I & I2 & I3 & I4 & I5 & I6,
    I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7,
    I9 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8,
    I10 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8 & I9,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    E9 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>,
    E10 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9]>,
    E11 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9, E10]>
  >(
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4>,
      H<E6, MergedPath, I5>,
      H<E7, MergedPath, I6>,
      H<E8, MergedPath, I7>,
      H<E9, MergedPath, I8>,
      H<E10, MergedPath, I9>,
      H<E11, MergedPath, I10, R>
    ]
  ): HonoBase<E, S & ToSchema<M, MergePath<BasePath, P>, I10, MergeTypedResponse<R>>, BasePath>

  // app.get(...handlers[])
  <
    P extends string = ExtractStringKey<S> extends never ? BasePath : ExtractStringKey<S>,
    I extends Input = BlankInput,
    R extends HandlerResponse<any> = any
  >(
    ...handlers: H<E, P, I, R>[]
  ): HonoBase<E, S & ToSchema<M, P, I, MergeTypedResponse<R>>, BasePath>

  // app.get(path, ...handlers[])
  <P extends string, I extends Input = BlankInput, R extends HandlerResponse<any> = any>(
    path: P,
    ...handlers: H<E, MergePath<BasePath, P>, I, R>[]
  ): HonoBase<E, S & ToSchema<M, MergePath<BasePath, P>, I, MergeTypedResponse<R>>, BasePath>

  // app.get(path)
  <P extends string, R extends HandlerResponse<any> = any, I extends Input = BlankInput>(
    path: P
  ): HonoBase<E, S & ToSchema<M, MergePath<BasePath, P>, I, MergeTypedResponse<R>>, BasePath>
}

////////////////////////////////////////
//////                            //////
////// MiddlewareHandlerInterface //////
//////                            //////
////////////////////////////////////////

export interface MiddlewareHandlerInterface<
  E extends Env = Env,
  S extends Schema = BlankSchema,
  BasePath extends string = '/'
> {
  //// app.use(...handlers[])
  <E2 extends Env = E>(
    ...handlers: MiddlewareHandler<E2, MergePath<BasePath, ExtractStringKey<S>>>[]
  ): HonoBase<IntersectNonAnyTypes<[E, E2]>, S, BasePath>

  // app.use(handler)
  <E2 extends Env = E>(
    handler: MiddlewareHandler<E2, MergePath<BasePath, ExtractStringKey<S>>>
  ): HonoBase<IntersectNonAnyTypes<[E, E2]>, S, BasePath>

  // app.use(handler x2)
  <
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    P extends string = MergePath<BasePath, ExtractStringKey<S>>
  >(
    ...handlers: [MiddlewareHandler<E2, P>, MiddlewareHandler<E3, P>]
  ): HonoBase<IntersectNonAnyTypes<[E, E2, E3]>, S, BasePath>

  // app.get(path, handler)
  <
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    E2 extends Env = E
  >(
    path: P,
    handler: MiddlewareHandler<E2, MergedPath>
  ): HonoBase<IntersectNonAnyTypes<[E, E2]>, ChangePathOfSchema<S, MergedPath>, BasePath>

  // app.use(handler x3)
  <
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    P extends string = MergePath<BasePath, ExtractStringKey<S>>
  >(
    ...handlers: [MiddlewareHandler<E2, P>, MiddlewareHandler<E3, P>, MiddlewareHandler<E4, P>]
  ): HonoBase<IntersectNonAnyTypes<[E, E2, E3, E4]>, S, BasePath>

  // app.get(path, handler x2)
  <
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>
  >(
    path: P,
    ...handlers: [MiddlewareHandler<E2, P>, MiddlewareHandler<E3, P>]
  ): HonoBase<IntersectNonAnyTypes<[E, E2, E3]>, ChangePathOfSchema<S, MergedPath>, BasePath>

  // app.use(handler x4)
  <
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    P extends string = MergePath<BasePath, ExtractStringKey<S>>
  >(
    ...handlers: [
      MiddlewareHandler<E2, P>,
      MiddlewareHandler<E3, P>,
      MiddlewareHandler<E4, P>,
      MiddlewareHandler<E5, P>
    ]
  ): HonoBase<IntersectNonAnyTypes<[E, E2, E3, E4, E5]>, S, BasePath>

  // app.get(path, handler x3)
  <
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>
  >(
    path: P,
    ...handlers: [MiddlewareHandler<E2, P>, MiddlewareHandler<E3, P>, MiddlewareHandler<E4, P>]
  ): HonoBase<IntersectNonAnyTypes<[E, E2, E3, E4]>, ChangePathOfSchema<S, MergedPath>, BasePath>

  // app.use(handler x5)
  <
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    P extends string = MergePath<BasePath, ExtractStringKey<S>>
  >(
    ...handlers: [
      MiddlewareHandler<E2, P>,
      MiddlewareHandler<E3, P>,
      MiddlewareHandler<E4, P>,
      MiddlewareHandler<E5, P>,
      MiddlewareHandler<E6, P>
    ]
  ): HonoBase<IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>, S, BasePath>

  // app.get(path, handler x4)
  <
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>
  >(
    path: P,
    ...handlers: [
      MiddlewareHandler<E2, P>,
      MiddlewareHandler<E3, P>,
      MiddlewareHandler<E4, P>,
      MiddlewareHandler<E5, P>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    ChangePathOfSchema<S, MergedPath>,
    BasePath
  >

  // app.use(handler x6)
  <
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    P extends string = MergePath<BasePath, ExtractStringKey<S>>
  >(
    ...handlers: [
      MiddlewareHandler<E2, P>,
      MiddlewareHandler<E3, P>,
      MiddlewareHandler<E4, P>,
      MiddlewareHandler<E5, P>,
      MiddlewareHandler<E6, P>,
      MiddlewareHandler<E7, P>
    ]
  ): HonoBase<IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>, S, BasePath>

  // app.get(path, handler x5)
  <
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>
  >(
    path: P,
    ...handlers: [
      MiddlewareHandler<E2, P>,
      MiddlewareHandler<E3, P>,
      MiddlewareHandler<E4, P>,
      MiddlewareHandler<E5, P>,
      MiddlewareHandler<E6, P>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    ChangePathOfSchema<S, MergedPath>,
    BasePath
  >

  // app.use(handler x7)
  <
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    P extends string = MergePath<BasePath, ExtractStringKey<S>>
  >(
    ...handlers: [
      MiddlewareHandler<E2, P>,
      MiddlewareHandler<E3, P>,
      MiddlewareHandler<E4, P>,
      MiddlewareHandler<E5, P>,
      MiddlewareHandler<E6, P>,
      MiddlewareHandler<E7, P>,
      MiddlewareHandler<E8, P>
    ]
  ): HonoBase<IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>, S, BasePath>

  // app.get(path, handler x6)
  <
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>
  >(
    path: P,
    ...handlers: [
      MiddlewareHandler<E2, P>,
      MiddlewareHandler<E3, P>,
      MiddlewareHandler<E4, P>,
      MiddlewareHandler<E5, P>,
      MiddlewareHandler<E6, P>,
      MiddlewareHandler<E7, P>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    ChangePathOfSchema<S, MergedPath>,
    BasePath
  >

  // app.use(handler x8)
  <
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    E9 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>,
    P extends string = MergePath<BasePath, ExtractStringKey<S>>
  >(
    ...handlers: [
      MiddlewareHandler<E2, P>,
      MiddlewareHandler<E3, P>,
      MiddlewareHandler<E4, P>,
      MiddlewareHandler<E5, P>,
      MiddlewareHandler<E6, P>,
      MiddlewareHandler<E7, P>,
      MiddlewareHandler<E8, P>,
      MiddlewareHandler<E9, P>
    ]
  ): HonoBase<IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9]>, S, BasePath>

  // app.get(path, handler x7)
  <
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>
  >(
    path: P,
    ...handlers: [
      MiddlewareHandler<E2, P>,
      MiddlewareHandler<E3, P>,
      MiddlewareHandler<E4, P>,
      MiddlewareHandler<E5, P>,
      MiddlewareHandler<E6, P>,
      MiddlewareHandler<E7, P>,
      MiddlewareHandler<E8, P>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>,
    ChangePathOfSchema<S, MergedPath>,
    BasePath
  >

  // app.use(handler x9)
  <
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    E9 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>,
    E10 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9]>,
    P extends string = MergePath<BasePath, ExtractStringKey<S>>
  >(
    ...handlers: [
      MiddlewareHandler<E2, P>,
      MiddlewareHandler<E3, P>,
      MiddlewareHandler<E4, P>,
      MiddlewareHandler<E5, P>,
      MiddlewareHandler<E6, P>,
      MiddlewareHandler<E7, P>,
      MiddlewareHandler<E8, P>,
      MiddlewareHandler<E9, P>,
      MiddlewareHandler<E10, P>
    ]
  ): HonoBase<IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9, E10]>, S, BasePath>

  // app.get(path, handler x8)
  <
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    E9 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>
  >(
    path: P,
    ...handlers: [
      MiddlewareHandler<E2, P>,
      MiddlewareHandler<E3, P>,
      MiddlewareHandler<E4, P>,
      MiddlewareHandler<E5, P>,
      MiddlewareHandler<E6, P>,
      MiddlewareHandler<E7, P>,
      MiddlewareHandler<E8, P>,
      MiddlewareHandler<E9, P>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9]>,
    ChangePathOfSchema<S, MergedPath>,
    BasePath
  >

  // app.use(handler x10)
  <
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    E9 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>,
    E10 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9]>,
    E11 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9, E10]>,
    P extends string = MergePath<BasePath, ExtractStringKey<S>>
  >(
    ...handlers: [
      MiddlewareHandler<E2, P>,
      MiddlewareHandler<E3, P>,
      MiddlewareHandler<E4, P>,
      MiddlewareHandler<E5, P>,
      MiddlewareHandler<E6, P>,
      MiddlewareHandler<E7, P>,
      MiddlewareHandler<E8, P>,
      MiddlewareHandler<E9, P>,
      MiddlewareHandler<E10, P>,
      MiddlewareHandler<E11, P>
    ]
  ): HonoBase<IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9, E10, E11]>, S, BasePath>

  // app.get(path, handler x9)
  <
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    E9 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>,
    E10 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9]>
  >(
    path: P,
    ...handlers: [
      MiddlewareHandler<E2, P>,
      MiddlewareHandler<E3, P>,
      MiddlewareHandler<E4, P>,
      MiddlewareHandler<E5, P>,
      MiddlewareHandler<E6, P>,
      MiddlewareHandler<E7, P>,
      MiddlewareHandler<E8, P>,
      MiddlewareHandler<E9, P>,
      MiddlewareHandler<E10, P>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9, E10]>,
    ChangePathOfSchema<S, MergedPath>,
    BasePath
  >

  //// app.use(path, ...handlers[])
  <P extends string, E2 extends Env = E>(
    path: P,
    ...handlers: MiddlewareHandler<E2, MergePath<BasePath, P>>[]
  ): HonoBase<E, S, BasePath>
}

////////////////////////////////////////
//////                            //////
//////     OnHandlerInterface     //////
//////                            //////
////////////////////////////////////////

export interface OnHandlerInterface<
  E extends Env = Env,
  S extends Schema = BlankSchema,
  BasePath extends string = '/'
> {
  // app.on(method, path, handler)
  <
    M extends string,
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    E2 extends Env = E
  >(
    method: M,
    path: P,
    handler: H<E2, MergedPath, I, R>
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2]>,
    S & ToSchema<M, MergePath<BasePath, P>, I, MergeTypedResponse<R>>,
    BasePath
  >

  // app.on(method, path, handler x2)
  <
    M extends string,
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>
  >(
    method: M,
    path: P,
    ...handlers: [H<E2, MergedPath, I>, H<E3, MergedPath, I2, R>]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3]>,
    S & ToSchema<M, MergePath<BasePath, P>, I2, MergeTypedResponse<R>>,
    BasePath
  >

  // app.on(method, path, handler x3)
  <
    M extends string,
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>
  >(
    method: M,
    path: P,
    ...handlers: [H<E2, MergedPath, I>, H<E3, MergedPath, I2>, H<E4, MergedPath, I3, R>]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4]>,
    S & ToSchema<M, MergePath<BasePath, P>, I3, MergeTypedResponse<R>>,
    BasePath
  >

  // app.on(method, path, handler x4)
  <
    M extends string,
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>
  >(
    method: M,
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4, R>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    S & ToSchema<M, MergePath<BasePath, P>, I4, MergeTypedResponse<R>>,
    BasePath
  >

  // app.on(method, path, handler x5)
  <
    M extends string,
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>
  >(
    method: M,
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4>,
      H<E6, MergedPath, I5, R>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    S & ToSchema<M, MergePath<BasePath, P>, I5, MergeTypedResponse<R>>,
    BasePath
  >

  // app.on(method, path, handler x6)
  <
    M extends string,
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>
  >(
    method: M,
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4>,
      H<E6, MergedPath, I5>,
      H<E7, MergedPath, I6, R>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    S & ToSchema<M, MergePath<BasePath, P>, I6, MergeTypedResponse<R>>,
    BasePath
  >

  // app.on(method, path, handler x7)
  <
    M extends string,
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    I7 extends Input = I & I2 & I3 & I4 & I5 & I6,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>
  >(
    method: M,
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4>,
      H<E6, MergedPath, I5>,
      H<E7, MergedPath, I6>,
      H<E8, MergedPath, I7, R>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>,
    S & ToSchema<M, MergePath<BasePath, P>, I7, MergeTypedResponse<R>>,
    BasePath
  >

  // app.on(method, path, handler x8)
  <
    M extends string,
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    I7 extends Input = I & I2 & I3 & I4 & I5 & I6,
    I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    E9 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>
  >(
    method: M,
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4>,
      H<E6, MergedPath, I5>,
      H<E7, MergedPath, I6>,
      H<E8, MergedPath, I7>,
      H<E9, MergedPath, I8, R>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9]>,
    S & ToSchema<M, MergePath<BasePath, P>, I8, MergeTypedResponse<R>>,
    BasePath
  >

  // app.on(method, path, handler x9)
  <
    M extends string,
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    I7 extends Input = I & I2 & I3 & I4 & I5 & I6,
    I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7,
    I9 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    E9 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>,
    E10 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9]>
  >(
    method: M,
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4>,
      H<E6, MergedPath, I5>,
      H<E7, MergedPath, I6>,
      H<E8, MergedPath, I7>,
      H<E9, MergedPath, I8>,
      H<E10, MergedPath, I9, R>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9, E10]>,
    S & ToSchema<M, MergePath<BasePath, P>, I9, MergeTypedResponse<R>>,
    BasePath
  >

  // app.on(method, path, handler x10)
  <
    M extends string,
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    I7 extends Input = I & I2 & I3 & I4 & I5 & I6,
    I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7,
    I9 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8,
    I10 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8 & I9,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    E9 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>,
    E10 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9]>,
    E11 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9, E10]>
  >(
    method: M,
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4>,
      H<E6, MergedPath, I5>,
      H<E7, MergedPath, I6>,
      H<E8, MergedPath, I7>,
      H<E9, MergedPath, I8>,
      H<E10, MergedPath, I9>,
      H<E11, MergedPath, I10, R>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9, E10, E11]>,
    S & ToSchema<M, MergePath<BasePath, P>, I10, MergeTypedResponse<HandlerResponse<any>>>,
    BasePath
  >

  // app.get(method, path, ...handler)
  <
    M extends string,
    P extends string,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput
  >(
    method: M,
    path: P,
    ...handlers: H<E, MergePath<BasePath, P>, I, R>[]
  ): HonoBase<E, S & ToSchema<M, MergePath<BasePath, P>, I, MergeTypedResponse<R>>, BasePath>

  // app.get(method[], path, handler)
  <
    Ms extends string[],
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    E2 extends Env = E
  >(
    methods: Ms,
    path: P,
    handler: H<E2, MergedPath, I, R>
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2]>,
    S & ToSchema<Ms[number], MergePath<BasePath, P>, I, MergeTypedResponse<R>>,
    BasePath
  >

  // app.get(method[], path, handler x2)
  <
    Ms extends string[],
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>
  >(
    methods: Ms,
    path: P,
    ...handlers: [H<E2, MergedPath, I>, H<E3, MergedPath, I2, R>]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3]>,
    S & ToSchema<Ms[number], MergePath<BasePath, P>, I2, MergeTypedResponse<R>>,
    BasePath
  >

  // app.get(method[], path, handler x3)
  <
    Ms extends string[],
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>
  >(
    methods: Ms,
    path: P,
    ...handlers: [H<E2, MergedPath, I>, H<E3, MergedPath, I2>, H<E4, MergedPath, I3, R>]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4]>,
    S & ToSchema<Ms[number], MergePath<BasePath, P>, I3, MergeTypedResponse<R>>,
    BasePath
  >

  // app.get(method[], path, handler x4)
  <
    Ms extends string[],
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>
  >(
    methods: Ms,
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4, R>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    S & ToSchema<Ms[number], MergePath<BasePath, P>, I4, MergeTypedResponse<R>>,
    BasePath
  >

  // app.get(method[], path, handler x5)
  <
    Ms extends string[],
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>
  >(
    methods: Ms,
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4>,
      H<E6, MergedPath, I5, R>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    S & ToSchema<Ms[number], MergePath<BasePath, P>, I5, MergeTypedResponse<R>>,
    BasePath
  >

  // app.get(method[], path, handler x6)
  <
    Ms extends string[],
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>
  >(
    methods: Ms,
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4>,
      H<E6, MergedPath, I5>,
      H<E7, MergedPath, I6, R>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    S & ToSchema<Ms[number], MergePath<BasePath, P>, I6, MergeTypedResponse<R>>,
    BasePath
  >

  // app.get(method[], path, handler x7)
  <
    Ms extends string[],
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    I7 extends Input = I & I2 & I3 & I4 & I5 & I6,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>
  >(
    methods: Ms,
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4>,
      H<E6, MergedPath, I5>,
      H<E7, MergedPath, I6>,
      H<E8, MergedPath, I7, R>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>,
    S & ToSchema<Ms[number], MergePath<BasePath, P>, I7, MergeTypedResponse<R>>,
    BasePath
  >

  // app.get(method[], path, handler x8)
  <
    Ms extends string[],
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    I7 extends Input = I & I2 & I3 & I4 & I5 & I6,
    I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    E9 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>
  >(
    methods: Ms,
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4>,
      H<E6, MergedPath, I5>,
      H<E7, MergedPath, I6>,
      H<E8, MergedPath, I7>,
      H<E9, MergedPath, I8, R>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9]>,
    S & ToSchema<Ms[number], MergePath<BasePath, P>, I8, MergeTypedResponse<R>>,
    BasePath
  >

  // app.get(method[], path, handler x9)
  <
    Ms extends string[],
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    I7 extends Input = I & I2 & I3 & I4 & I5 & I6,
    I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7,
    I9 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    E9 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>,
    E10 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9]>
  >(
    methods: Ms,
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4>,
      H<E6, MergedPath, I5>,
      H<E7, MergedPath, I6>,
      H<E8, MergedPath, I7>,
      H<E9, MergedPath, I8>,
      H<E10, MergedPath, I9, R>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9, E10]>,
    S & ToSchema<Ms[number], MergePath<BasePath, P>, I9, MergeTypedResponse<HandlerResponse<any>>>,
    BasePath
  >

  // app.get(method[], path, handler x10)
  <
    Ms extends string[],
    P extends string,
    MergedPath extends MergePath<BasePath, P> = MergePath<BasePath, P>,
    R extends HandlerResponse<any> = any,
    I extends Input = BlankInput,
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    I7 extends Input = I & I2 & I3 & I4 & I5 & I6,
    I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7,
    I9 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8,
    I10 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8 & I9,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    E9 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>,
    E10 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9]>,
    E11 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9, E10]>
  >(
    methods: Ms,
    path: P,
    ...handlers: [
      H<E2, MergedPath, I>,
      H<E3, MergedPath, I2>,
      H<E4, MergedPath, I3>,
      H<E5, MergedPath, I4>,
      H<E6, MergedPath, I5>,
      H<E7, MergedPath, I6>,
      H<E8, MergedPath, I7>,
      H<E9, MergedPath, I8>,
      H<E10, MergedPath, I9>,
      H<E11, MergedPath, I10, R>
    ]
  ): HonoBase<
    IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9, E10, E11]>,
    S & ToSchema<Ms[number], MergePath<BasePath, P>, I10, MergeTypedResponse<HandlerResponse<any>>>,
    BasePath
  >

  // app.on(method[], path, ...handler)
  <P extends string, R extends HandlerResponse<any> = any, I extends Input = BlankInput>(
    methods: string[],
    path: P,
    ...handlers: H<E, MergePath<BasePath, P>, I, R>[]
  ): HonoBase<E, S & ToSchema<string, MergePath<BasePath, P>, I, MergeTypedResponse<R>>, BasePath>

  // app.on(method | method[], path[], ...handlers[])
  <I extends Input = BlankInput, R extends HandlerResponse<any> = any, E2 extends Env = E>(
    methods: string | string[],
    paths: string[],
    ...handlers: H<E2, any, I, R>[]
  ): HonoBase<E, S & ToSchema<string, string, I, MergeTypedResponse<R>>, BasePath>
}

type ExtractStringKey<S> = keyof S & string

////////////////////////////////////////
//////                            //////
//////           ToSchema           //////
//////                            //////
////////////////////////////////////////

export type ToSchema<
  M extends string,
  P extends string,
  I extends Input | Input['in'],
  RorO // Response or Output
> = Simplify<{
  [K in P]: {
    [K2 in M as AddDollar<K2>]: Simplify<
      {
        input: AddParam<ExtractInput<I>, P>
      } & (IsAny<RorO> extends true
        ? {
            output: {}
            outputFormat: ResponseFormat
            status: StatusCode
          }
        : RorO extends TypedResponse<infer T, infer U, infer F>
        ? {
            output: unknown extends T ? {} : T
            outputFormat: I extends { outputFormat: string } ? I['outputFormat'] : F
            status: U
          }
        : {
            output: unknown extends RorO ? {} : RorO
            outputFormat: unknown extends RorO
              ? 'json'
              : I extends { outputFormat: string }
              ? I['outputFormat']
              : 'json'
            status: StatusCode
          })
    >
  }
}>

export type Schema = {
  [Path: string]: {
    [Method: `$${Lowercase<string>}`]: Endpoint
  }
}

type ChangePathOfSchema<S extends Schema, Path extends string> = keyof S extends never
  ? { [K in Path]: {} }
  : { [K in keyof S as Path]: S[K] }

export type Endpoint = {
  input: any
  output: any
  outputFormat: ResponseFormat
  status: StatusCode
}

type ExtractParams<Path extends string> = string extends Path
  ? Record<string, string>
  : Path extends `${infer _Start}:${infer Param}/${infer Rest}`
  ? { [K in Param | keyof ExtractParams<`/${Rest}`>]: string }
  : Path extends `${infer _Start}:${infer Param}`
  ? { [K in Param]: string }
  : never

type FlattenIfIntersect<T> = T extends infer O ? { [K in keyof O]: O[K] } : never

export type MergeSchemaPath<OrigSchema extends Schema, SubPath extends string> = {
  [P in keyof OrigSchema as MergePath<SubPath, P & string>]: [OrigSchema[P]] extends [
    Record<string, Endpoint>
  ]
    ? { [M in keyof OrigSchema[P]]: MergeEndpointParamsWithPath<OrigSchema[P][M], SubPath> }
    : never
}

type MergeEndpointParamsWithPath<T extends Endpoint, SubPath extends string> = T extends unknown
  ? {
      input: T['input'] extends { param: infer _ }
        ? ExtractParams<SubPath> extends never
          ? T['input']
          : FlattenIfIntersect<
              T['input'] & {
                param: {
                  // Maps extracted keys, stripping braces, to a string-typed record.
                  [K in keyof ExtractParams<SubPath> as K extends `${infer Prefix}{${infer _}}`
                    ? Prefix
                    : K]: string
                }
              }
            >
        : RemoveBlankRecord<ExtractParams<SubPath>> extends never
        ? T['input']
        : T['input'] & {
            // Maps extracted keys, stripping braces, to a string-typed record.
            param: {
              [K in keyof ExtractParams<SubPath> as K extends `${infer Prefix}{${infer _}}`
                ? Prefix
                : K]: string
            }
          }
      output: T['output']
      outputFormat: T['outputFormat']
      status: T['status']
    }
  : never
export type AddParam<I, P extends string> = ParamKeys<P> extends never
  ? I
  : I extends { param: infer _ }
  ? I
  : I & { param: UnionToIntersection<ParamKeyToRecord<ParamKeys<P>>> }

type AddDollar<T extends string> = `$${Lowercase<T>}`

export type MergePath<A extends string, B extends string> = B extends ''
  ? MergePath<A, '/'>
  : A extends ''
  ? B
  : A extends '/'
  ? B
  : A extends `${infer P}/`
  ? B extends `/${infer Q}`
    ? `${P}/${Q}`
    : `${P}/${B}`
  : B extends `/${infer Q}`
  ? Q extends ''
    ? A
    : `${A}/${Q}`
  : `${A}/${B}`

////////////////////////////////////////
//////                            //////
//////        TypedResponse       //////
//////                            //////
////////////////////////////////////////

export type KnownResponseFormat = 'json' | 'text' | 'redirect'
export type ResponseFormat = KnownResponseFormat | string

export type TypedResponse<
  T = unknown,
  U extends StatusCode = StatusCode,
  F extends ResponseFormat = T extends string
    ? 'text'
    : T extends JSONValue
    ? 'json'
    : ResponseFormat
> = {
  _data: T
  _status: U
  _format: F
}

type MergeTypedResponse<T> = T extends Promise<infer T2>
  ? T2 extends TypedResponse
    ? T2
    : TypedResponse
  : T extends TypedResponse
  ? T
  : TypedResponse

////////////////////////////////////////
//////                             /////
//////      ValidationTargets      /////
//////                             /////
////////////////////////////////////////

export type FormValue = string | Blob
export type ParsedFormValue = string | File

export type ValidationTargets<T extends FormValue = ParsedFormValue, P extends string = string> = {
  json: any
  form: Record<string, T | T[]>
  query: Record<string, string | string[]>
  param: Record<P, P extends `${infer _}?` ? string | undefined : string>
  header: Record<RequestHeader | CustomHeader, string>
  cookie: Record<string, string>
}

////////////////////////////////////////
//////                            //////
//////      Path parameters       //////
//////                            //////
////////////////////////////////////////

type ParamKey<Component> = Component extends `:${infer NameWithPattern}`
  ? NameWithPattern extends `${infer Name}{${infer Rest}`
    ? Rest extends `${infer _Pattern}?`
      ? `${Name}?`
      : Name
    : NameWithPattern
  : never

export type ParamKeys<Path> = Path extends `${infer Component}/${infer Rest}`
  ? ParamKey<Component> | ParamKeys<Rest>
  : ParamKey<Path>

export type ParamKeyToRecord<T extends string> = T extends `${infer R}?`
  ? Record<R, string | undefined>
  : { [K in T]: string }

////////////////////////////////////////
//////                            //////
/////       For HonoRequest       //////
//////                            //////
////////////////////////////////////////

export type InputToDataByTarget<
  T extends Input['out'],
  Target extends keyof ValidationTargets
> = T extends {
  [K in Target]: infer R
}
  ? R
  : never

export type RemoveQuestion<T> = T extends `${infer R}?` ? R : T

////////////////////////////////////////
//////                            //////
//////         Utilities          //////
//////                            //////
////////////////////////////////////////

export type ExtractSchema<T> = UnionToIntersection<
  T extends HonoBase<infer _, infer S, any> ? S : never
>

type ProcessHead<T> = IfAnyThenEmptyObject<T extends Env ? (Env extends T ? {} : T) : T>
export type IntersectNonAnyTypes<T extends any[]> = T extends [infer Head, ...infer Rest]
  ? ProcessHead<Head> & IntersectNonAnyTypes<Rest>
  : {}

////////////////////////////////////////
//////                            //////
//////         FetchEvent         //////
//////                            //////
////////////////////////////////////////

export abstract class FetchEventLike {
  abstract readonly request: Request
  abstract respondWith(promise: Response | Promise<Response>): void
  abstract passThroughOnException(): void
  abstract waitUntil(promise: Promise<void>): void
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/jsx-renderer/index.test.tsx
```
/** @jsxImportSource ../../jsx */
import { expectTypeOf } from 'vitest'
import { html } from '../../helper/html'
import { Hono } from '../../hono'
import type { FC } from '../../jsx'
import { Suspense } from '../../jsx/streaming'
import { jsxRenderer, useRequestContext } from '.'

const RequestUrl: FC = () => {
  const c = useRequestContext()
  return html`${c.req.url}`
}

describe('JSX renderer', () => {
  it('basic', async () => {
    const app = new Hono()
    app.use(
      '*',
      jsxRenderer(({ children, title }) => (
        <html>
          <head>{title}</head>
          <body>{children}</body>
        </html>
      ))
    )
    app.get('/', (c) =>
      c.render(
        <h1>
          <RequestUrl />
        </h1>,
        { title: 'Title' }
      )
    )

    const app2 = new Hono()
    app2.use(
      '*',
      jsxRenderer(({ children }) => <div class='nested'>{children}</div>)
    )
    app2.get('/', (c) => c.render(<h1>http://localhost/nested</h1>, { title: 'Title' }))
    app.route('/nested', app2)

    let res = await app.request('http://localhost/')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe(
      '<!DOCTYPE html><html><head>Title</head><body><h1>http://localhost/</h1></body></html>'
    )

    res = await app.request('http://localhost/nested')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe(
      '<!DOCTYPE html><div class="nested"><h1>http://localhost/nested</h1></div>'
    )
  })

  it('Should get the context object as a 2nd arg', async () => {
    const app = new Hono()
    app.use(
      jsxRenderer(
        ({ children }, c) => {
          return (
            <div>
              {children} at {c.req.path}
            </div>
          )
        },
        { docType: false }
      )
    )
    app.get('/hi', (c) => {
      return c.render('hi', { title: 'hi' })
    })

    const res = await app.request('/hi')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('<div>hi at /hi</div>')
  })

  it('nested layout with Layout', async () => {
    const app = new Hono()
    app.use(
      '*',
      jsxRenderer(({ children, title, Layout }) => (
        <Layout>
          <html>
            <head>{title}</head>
            <body>{children}</body>
          </html>
        </Layout>
      ))
    )

    const app2 = new Hono()
    app2.use(
      '*',
      jsxRenderer(({ children, Layout, title }) => (
        <Layout title={title}>
          <div class='nested'>{children}</div>
        </Layout>
      ))
    )
    app2.get('/', (c) => c.render(<h1>http://localhost/nested</h1>, { title: 'Nested' }))

    const app3 = new Hono()
    app3.use(
      '*',
      jsxRenderer(({ children, Layout, title }) => (
        <Layout title={title}>
          <div class='nested2'>{children}</div>
        </Layout>
      ))
    )
    app3.get('/', (c) => c.render(<h1>http://localhost/nested</h1>, { title: 'Nested2' }))
    app2.route('/nested2', app3)

    app.route('/nested', app2)

    let res = await app.request('http://localhost/nested')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe(
      '<!DOCTYPE html><html><head>Nested</head><body><div class="nested"><h1>http://localhost/nested</h1></div></body></html>'
    )

    res = await app.request('http://localhost/nested/nested2')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe(
      '<!DOCTYPE html><html><head>Nested2</head><body><div class="nested"><div class="nested2"><h1>http://localhost/nested</h1></div></div></body></html>'
    )
  })

  it('Should return a default doctype', async () => {
    const app = new Hono()
    app.use(
      '*',
      jsxRenderer(
        ({ children }) => {
          return (
            <html>
              <body>{children}</body>
            </html>
          )
        },
        { docType: true }
      )
    )
    app.get('/', (c) => c.render(<h1>Hello</h1>, { title: 'Title' }))
    const res = await app.request('/')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('<!DOCTYPE html><html><body><h1>Hello</h1></body></html>')
  })

  it('Should return a non includes doctype', async () => {
    const app = new Hono()
    app.use(
      '*',
      jsxRenderer(
        ({ children }) => {
          return (
            <html>
              <body>{children}</body>
            </html>
          )
        },
        { docType: false }
      )
    )
    app.get('/', (c) => c.render(<h1>Hello</h1>, { title: 'Title' }))
    const res = await app.request('/')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('<html><body><h1>Hello</h1></body></html>')
  })

  it('Should return a custom doctype', async () => {
    const app = new Hono()
    app.use(
      '*',
      jsxRenderer(
        ({ children }) => {
          return (
            <html>
              <body>{children}</body>
            </html>
          )
        },
        {
          docType:
            '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">',
        }
      )
    )
    app.get('/', (c) => c.render(<h1>Hello</h1>, { title: 'Title' }))
    const res = await app.request('/')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe(
      '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html><body><h1>Hello</h1></body></html>'
    )
  })

  it('Should return as streaming content with default headers', async () => {
    const app = new Hono()
    app.use(
      '*',
      jsxRenderer(
        ({ children }) => {
          return (
            <html>
              <body>{children}</body>
            </html>
          )
        },
        {
          docType: true,
          stream: true,
        }
      )
    )
    const AsyncComponent = async () => {
      const c = useRequestContext()
      return <p>Hello {c.req.query('name')}!</p>
    }
    app.get('/', (c) =>
      c.render(
        <Suspense fallback={<p>Loading...</p>}>
          <AsyncComponent />
        </Suspense>,
        { title: 'Title' }
      )
    )
    const res = await app.request('/?name=Hono')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('Transfer-Encoding')).toEqual('chunked')
    expect(res.headers.get('Content-Type')).toEqual('text/html; charset=UTF-8')
    expect(res.headers.get('Content-Encoding')).toEqual('Identity')

    if (!res.body) {
      throw new Error('Body is null')
    }

    const chunk: string[] = []
    const reader = res.body.getReader()
    const decoder = new TextDecoder()
    for (;;) {
      const { value, done } = await reader.read()
      if (done) {
        break
      }
      chunk.push(decoder.decode(value))
    }
    expect(chunk).toEqual([
      '<!DOCTYPE html><html><body><template id="H:0"></template><p>Loading...</p><!--/$--></body></html>',
      `<template data-hono-target="H:0"><p>Hello Hono!</p></template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:0')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
</script>`,
    ])
  })

  // this test relies upon 'Should return as streaming content with default headers'
  // this should be refactored to prevent tests depending on each other
  it('Should return as streaming content with custom headers', async () => {
    const app = new Hono()
    app.use(
      '*',
      jsxRenderer(
        ({ children }) => {
          return (
            <html>
              <body>{children}</body>
            </html>
          )
        },
        {
          docType: true,
          stream: {
            'Transfer-Encoding': 'chunked',
            'Content-Type': 'text/html',
          },
        }
      )
    )
    const AsyncComponent = async () => {
      const c = useRequestContext()
      return <p>Hello {c.req.query('name')} again!</p>
    }
    app.get('/', (c) =>
      c.render(
        <Suspense fallback={<p>Loading...</p>}>
          <AsyncComponent />
        </Suspense>,
        { title: 'Title' }
      )
    )
    const res = await app.request('/?name=Hono')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('Transfer-Encoding')).toEqual('chunked')
    expect(res.headers.get('Content-Type')).toEqual('text/html')

    if (!res.body) {
      throw new Error('Body is null')
    }

    const chunk: string[] = []
    const reader = res.body.getReader()
    const decoder = new TextDecoder()
    for (;;) {
      const { value, done } = await reader.read()
      if (done) {
        break
      }
      chunk.push(decoder.decode(value))
    }
    expect(chunk).toEqual([
      '<!DOCTYPE html><html><body><template id="H:1"></template><p>Loading...</p><!--/$--></body></html>',
      `<template data-hono-target="H:1"><p>Hello Hono again!</p></template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:1')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
</script>`,
    ])
  })

  it('Should return as streaming content with headers added in a handler', async () => {
    const app = new Hono()
    app.use(jsxRenderer(async ({ children }) => <div>{children}</div>, { stream: true }))
    app.get('/', (c) => {
      c.header('X-Message-Set', 'Hello')
      c.header('X-Message-Append', 'Hello', { append: true })
      return c.render('Hi', { title: 'Hi' })
    })
    const res = await app.request('/')
    expect(res.status).toBe(200)
    expect(res.headers.get('Transfer-Encoding')).toBe('chunked')
    expect(res.headers.get('Content-Type')).toBe('text/html; charset=UTF-8')
    expect(res.headers.get('X-Message-Set')).toBe('Hello')
    expect(res.headers.get('X-Message-Append')).toBe('Hello')
    expect(await res.text()).toBe('<!DOCTYPE html><div>Hi</div>')
  })

  it('Env', async () => {
    type JSXRendererEnv = {
      Variables: {
        foo: string
      }
      Bindings: {
        bar: string
      }
    }

    const VariableFoo: FC = () => {
      const c = useRequestContext<JSXRendererEnv>()
      expectTypeOf(c.get('foo')).toEqualTypeOf<string>()
      return html`${c.get('foo')}`
    }

    const BindingsBar: FC = () => {
      const c = useRequestContext<JSXRendererEnv>()
      expectTypeOf(c.env.bar).toEqualTypeOf<string>()
      return html`${c.env.bar}`
    }

    const app = new Hono<JSXRendererEnv>()
    app.use('*', jsxRenderer())
    app.get('/', (c) => {
      c.set('foo', 'fooValue')
      return c.render(
        <>
          <h1>
            <VariableFoo />
          </h1>
          <p>
            <BindingsBar />
          </p>
        </>,
        { title: 'Title' }
      )
    })
    const res = await app.request('http://localhost/', undefined, { bar: 'barValue' })
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('<!DOCTYPE html><h1>fooValue</h1><p>barValue</p>')
  })

  it('Should return a resolved content', async () => {
    const app = new Hono()
    app.use(jsxRenderer(async ({ children }) => <div>{children}</div>))
    app.get('/', (c) => c.render('Hi', { title: 'Hi' }))
    const res = await app.request('/')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('<!DOCTYPE html><div>Hi</div>')
  })

  describe('keep context status', async () => {
    it('Should keep context status', async () => {
      const app = new Hono()
      app.use(
        '*',
        jsxRenderer(({ children }) => {
          return (
            <html>
              <body>{children}</body>
            </html>
          )
        })
      )
      app.get('/', (c) => {
        c.status(201)
        return c.render(<h1>Hello</h1>, { title: 'Title' })
      })
      const res = await app.request('/')
      expect(res).not.toBeNull()
      expect(res.status).toBe(201)
      expect(await res.text()).toBe('<!DOCTYPE html><html><body><h1>Hello</h1></body></html>')
    })

    it('Should keep context status with stream option', async () => {
      const app = new Hono()
      app.use(
        '*',
        jsxRenderer(
          ({ children }) => {
            return (
              <html>
                <body>{children}</body>
              </html>
            )
          },
          { stream: true }
        )
      )
      app.get('/', (c) => {
        c.status(201)
        return c.render(<h1>Hello</h1>, { title: 'Title' })
      })
      const res = await app.request('/')
      expect(res).not.toBeNull()
      expect(res.status).toBe(201)
      expect(await res.text()).toBe('<!DOCTYPE html><html><body><h1>Hello</h1></body></html>')
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/jsx-renderer/index.ts
````typescript
/**
 * @module
 * JSX Renderer Middleware for Hono.
 */

/* eslint-disable @typescript-eslint/no-explicit-any */
import type { Context, PropsForRenderer } from '../../context'
import { html, raw } from '../../helper/html'
import { Fragment, createContext, jsx, useContext } from '../../jsx'
import type { FC, Context as JSXContext, JSXNode, PropsWithChildren } from '../../jsx'
import { renderToReadableStream } from '../../jsx/streaming'
import type { Env, Input, MiddlewareHandler } from '../../types'
import type { HtmlEscapedString } from '../../utils/html'

export const RequestContext: JSXContext<Context<any, any, {}> | null> =
  createContext<Context | null>(null)

type RendererOptions = {
  docType?: boolean | string
  stream?: boolean | Record<string, string>
}

type Component = (
  props: PropsForRenderer & { Layout: FC },
  c: Context
) => HtmlEscapedString | Promise<HtmlEscapedString>

type ComponentWithChildren = (
  props: PropsWithChildren<PropsForRenderer & { Layout: FC }>,
  c: Context
) => HtmlEscapedString | Promise<HtmlEscapedString>

const createRenderer =
  (c: Context, Layout: FC, component?: Component, options?: RendererOptions) =>
  (children: JSXNode, props: PropsForRenderer) => {
    const docType =
      typeof options?.docType === 'string'
        ? options.docType
        : options?.docType === false
        ? ''
        : '<!DOCTYPE html>'

    const currentLayout = component
      ? jsx(
          (props: any) => component(props, c),
          {
            Layout,
            ...(props as any),
          },
          children as any
        )
      : children

    const body = html`${raw(docType)}${jsx(
      RequestContext.Provider,
      { value: c },
      currentLayout as any
    )}`

    if (options?.stream) {
      if (options.stream === true) {
        c.header('Transfer-Encoding', 'chunked')
        c.header('Content-Type', 'text/html; charset=UTF-8')
        c.header('Content-Encoding', 'Identity')
      } else {
        for (const [key, value] of Object.entries(options.stream)) {
          c.header(key, value)
        }
      }
      return c.body(renderToReadableStream(body))
    } else {
      return c.html(body)
    }
  }

/**
 * JSX Renderer Middleware for hono.
 *
 * @see {@link https://hono.dev/docs/middleware/builtin/jsx-renderer}
 *
 * @param {ComponentWithChildren} [component] - The component to render, which can accept children and props.
 * @param {RendererOptions} [options] - The options for the JSX renderer middleware.
 * @param {boolean | string} [options.docType=true] - The DOCTYPE to be added at the beginning of the HTML. If set to false, no DOCTYPE will be added.
 * @param {boolean | Record<string, string>} [options.stream=false] - If set to true, enables streaming response with default headers. If a record is provided, custom headers will be used.
 * @returns {MiddlewareHandler} The middleware handler function.
 *
 * @example
 * ```ts
 * const app = new Hono()
 *
 * app.get(
 *   '/page/*',
 *   jsxRenderer(({ children }) => {
 *     return (
 *       <html>
 *         <body>
 *           <header>Menu</header>
 *           <div>{children}</div>
 *         </body>
 *       </html>
 *     )
 *   })
 * )
 *
 * app.get('/page/about', (c) => {
 *   return c.render(<h1>About me!</h1>)
 * })
 * ```
 */
export const jsxRenderer = (
  component?: ComponentWithChildren,
  options?: RendererOptions
): MiddlewareHandler =>
  function jsxRenderer(c, next) {
    const Layout = (c.getLayout() ?? Fragment) as FC
    if (component) {
      c.setLayout((props) => {
        return component({ ...props, Layout }, c)
      })
    }
    c.setRenderer(createRenderer(c, Layout, component, options) as any)
    return next()
  }

/**
 * useRequestContext for Hono.
 *
 * @template E - The environment type.
 * @template P - The parameter type.
 * @template I - The input type.
 * @returns {Context<E, P, I>} An instance of Context.
 *
 * @example
 * ```ts
 * const RequestUrlBadge: FC = () => {
 *   const c = useRequestContext()
 *   return <b>{c.req.url}</b>
 * }
 *
 * app.get('/page/info', (c) => {
 *   return c.render(
 *     <div>
 *       You are accessing: <RequestUrlBadge />
 *     </div>
 *   )
 * })
 * ```
 */
export const useRequestContext = <
  E extends Env = any,
  P extends string = any,
  I extends Input = {}
>(): Context<E, P, I> => {
  const c = useContext(RequestContext)
  if (!c) {
    throw new Error('RequestContext is not provided.')
  }
  return c
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/jwt/index.test.ts
```typescript
import { Hono } from '../../hono'
import { HTTPException } from '../../http-exception'
import { jwt } from '.'

describe('JWT', () => {
  describe('Credentials in header', () => {
    let handlerExecuted: boolean

    beforeEach(() => {
      handlerExecuted = false
    })

    const app = new Hono()

    app.use('/auth/*', jwt({ secret: 'a-secret' }))
    app.use('/auth-unicode/*', jwt({ secret: 'a-secret' }))
    app.use('/nested/*', async (c, next) => {
      const auth = jwt({ secret: 'a-secret' })
      return auth(c, next)
    })

    app.get('/auth/*', (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })
    app.get('/auth-unicode/*', (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })
    app.get('/nested/*', (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })

    it('Should not authorize', async () => {
      const req = new Request('http://localhost/auth/a')
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
      expect(await res.text()).toBe('Unauthorized')
      expect(handlerExecuted).toBeFalsy()
    })

    it('Should authorize', async () => {
      const credential =
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.B54pAqIiLbu170tGQ1rY06Twv__0qSHTA0ioQPIOvFE'
      const req = new Request('http://localhost/auth/a')
      req.headers.set('Authorization', `Bearer ${credential}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ message: 'hello world' })
      expect(handlerExecuted).toBeTruthy()
    })

    it('Should authorize Unicode', async () => {
      const credential =
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.B54pAqIiLbu170tGQ1rY06Twv__0qSHTA0ioQPIOvFE'

      const req = new Request('http://localhost/auth-unicode/a')
      req.headers.set('Authorization', `Basic ${credential}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ message: 'hello world' })
      expect(handlerExecuted).toBeTruthy()
    })

    it('Should not authorize Unicode', async () => {
      const invalidToken =
        'ssyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.B54pAqIiLbu170tGQ1rY06Twv__0qSHTA0ioQPIOvFE'

      const url = 'http://localhost/auth-unicode/a'
      const req = new Request(url)
      req.headers.set('Authorization', `Basic ${invalidToken}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
      expect(res.headers.get('www-authenticate')).toEqual(
        `Bearer realm="${url}",error="invalid_token",error_description="token verification failure"`
      )
      expect(handlerExecuted).toBeFalsy()
    })

    it('Should not authorize', async () => {
      const invalid_token = 'invalid token'
      const url = 'http://localhost/auth/a'
      const req = new Request(url)
      req.headers.set('Authorization', `Bearer ${invalid_token}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
      expect(res.headers.get('www-authenticate')).toEqual(
        `Bearer realm="${url}",error="invalid_request",error_description="invalid credentials structure"`
      )
      expect(handlerExecuted).toBeFalsy()
    })

    it('Should not authorize - nested', async () => {
      const req = new Request('http://localhost/nested/a')
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
      expect(await res.text()).toBe('Unauthorized')
      expect(handlerExecuted).toBeFalsy()
    })

    it('Should authorize - nested', async () => {
      const credential =
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.B54pAqIiLbu170tGQ1rY06Twv__0qSHTA0ioQPIOvFE'
      const req = new Request('http://localhost/nested/a')
      req.headers.set('Authorization', `Bearer ${credential}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ message: 'hello world' })
      expect(handlerExecuted).toBeTruthy()
    })
  })

  describe('Credentials in cookie', () => {
    let handlerExecuted: boolean

    beforeEach(() => {
      handlerExecuted = false
    })

    const app = new Hono()

    app.use('/auth/*', jwt({ secret: 'a-secret', cookie: 'access_token' }))
    app.use('/auth-unicode/*', jwt({ secret: 'a-secret', cookie: 'access_token' }))

    app.get('/auth/*', (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })
    app.get('/auth-unicode/*', (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })

    it('Should not authorize', async () => {
      const req = new Request('http://localhost/auth/a')
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
      expect(await res.text()).toBe('Unauthorized')
      expect(handlerExecuted).toBeFalsy()
    })

    it('Should authorize', async () => {
      const url = 'http://localhost/auth/a'
      const credential =
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.B54pAqIiLbu170tGQ1rY06Twv__0qSHTA0ioQPIOvFE'
      const req = new Request(url, {
        headers: new Headers({
          Cookie: `access_token=${credential}`,
        }),
      })
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(await res.json()).toEqual({ message: 'hello world' })
      expect(res.status).toBe(200)
      expect(handlerExecuted).toBeTruthy()
    })

    it('Should authorize Unicode', async () => {
      const credential =
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.B54pAqIiLbu170tGQ1rY06Twv__0qSHTA0ioQPIOvFE'

      const req = new Request('http://localhost/auth-unicode/a', {
        headers: new Headers({
          Cookie: `access_token=${credential}`,
        }),
      })
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ message: 'hello world' })
      expect(handlerExecuted).toBeTruthy()
    })

    it('Should not authorize Unicode', async () => {
      const invalidToken =
        'ssyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.B54pAqIiLbu170tGQ1rY06Twv__0qSHTA0ioQPIOvFE'

      const url = 'http://localhost/auth-unicode/a'
      const req = new Request(url)
      req.headers.set('Cookie', `access_token=${invalidToken}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
      expect(res.headers.get('www-authenticate')).toEqual(
        `Bearer realm="${url}",error="invalid_token",error_description="token verification failure"`
      )
      expect(handlerExecuted).toBeFalsy()
    })

    it('Should not authorize', async () => {
      const invalidToken = 'invalid token'
      const url = 'http://localhost/auth/a'
      const req = new Request(url)
      req.headers.set('Cookie', `access_token=${invalidToken}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
      expect(res.headers.get('www-authenticate')).toEqual(
        `Bearer realm="${url}",error="invalid_token",error_description="token verification failure"`
      )
      expect(handlerExecuted).toBeFalsy()
    })
  })

  describe('Error handling with `cause`', () => {
    const app = new Hono()

    app.use('/auth/*', jwt({ secret: 'a-secret' }))
    app.get('/auth/*', (c) => c.text('Authorized'))

    app.onError((e, c) => {
      if (e instanceof HTTPException && e.cause instanceof Error) {
        return c.json({ name: e.cause.name, message: e.cause.message }, 401)
      }
      return c.text(e.message, 401)
    })

    it('Should not authorize', async () => {
      const credential = 'abc.def.ghi'
      const req = new Request('http://localhost/auth')
      req.headers.set('Authorization', `Bearer ${credential}`)
      const res = await app.request(req)
      expect(res.status).toBe(401)
      expect(await res.json()).toEqual({
        name: 'JwtTokenInvalid',
        message: `invalid JWT token: ${credential}`,
      })
    })
  })

  describe('Credentials in signed cookie with prefix Options', () => {
    let handlerExecuted: boolean

    beforeEach(() => {
      handlerExecuted = false
    })

    const app = new Hono()

    app.use(
      '/auth/*',
      jwt({
        secret: 'a-secret',
        cookie: {
          key: 'cookie_name',
          secret: 'cookie_secret',
          prefixOptions: 'host',
        },
      })
    )

    app.get('/auth/*', async (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })

    it('Should not authorize', async () => {
      const req = new Request('http://localhost/auth/a')
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
      expect(await res.text()).toBe('Unauthorized')
      expect(handlerExecuted).toBeFalsy()
    })

    it('Should authorize', async () => {
      const url = 'http://localhost/auth/a'
      const req = new Request(url, {
        headers: new Headers({
          Cookie:
            '__Host-cookie_name=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.B54pAqIiLbu170tGQ1rY06Twv__0qSHTA0ioQPIOvFE.i2NSvtJOXOPS9NDL1u8dqTYmMrzcD4mNSws6P6qmeV0%3D; Path=/',
        }),
      })
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ message: 'hello world' })
      expect(handlerExecuted).toBeTruthy()
    })
  })

  describe('Credentials in signed cookie without prefix Options', () => {
    let handlerExecuted: boolean

    beforeEach(() => {
      handlerExecuted = false
    })

    const app = new Hono()

    app.use(
      '/auth/*',
      jwt({
        secret: 'a-secret',
        cookie: {
          key: 'cookie_name',
          secret: 'cookie_secret',
        },
      })
    )

    app.get('/auth/*', async (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })

    it('Should not authorize', async () => {
      const req = new Request('http://localhost/auth/a')
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
      expect(await res.text()).toBe('Unauthorized')
      expect(handlerExecuted).toBeFalsy()
    })

    it('Should authorize', async () => {
      const url = 'http://localhost/auth/a'
      const req = new Request(url, {
        headers: new Headers({
          Cookie:
            'cookie_name=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.B54pAqIiLbu170tGQ1rY06Twv__0qSHTA0ioQPIOvFE.i2NSvtJOXOPS9NDL1u8dqTYmMrzcD4mNSws6P6qmeV0%3D; Path=/',
        }),
      })
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ message: 'hello world' })
      expect(handlerExecuted).toBeTruthy()
    })
  })

  describe('Credentials in cookie object with prefix Options', () => {
    let handlerExecuted: boolean

    beforeEach(() => {
      handlerExecuted = false
    })

    const app = new Hono()

    app.use(
      '/auth/*',
      jwt({
        secret: 'a-secret',
        cookie: {
          key: 'cookie_name',
          prefixOptions: 'host',
        },
      })
    )

    app.get('/auth/*', async (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })

    it('Should not authorize', async () => {
      const req = new Request('http://localhost/auth/a')
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
      expect(await res.text()).toBe('Unauthorized')
      expect(handlerExecuted).toBeFalsy()
    })

    it('Should authorize', async () => {
      const url = 'http://localhost/auth/a'
      const req = new Request(url, {
        headers: new Headers({
          Cookie:
            '__Host-cookie_name=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.B54pAqIiLbu170tGQ1rY06Twv__0qSHTA0ioQPIOvFE',
        }),
      })
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ message: 'hello world' })
      expect(handlerExecuted).toBeTruthy()
    })
  })

  describe('Credentials in cookie object without prefix Options', () => {
    let handlerExecuted: boolean

    beforeEach(() => {
      handlerExecuted = false
    })

    const app = new Hono()

    app.use(
      '/auth/*',
      jwt({
        secret: 'a-secret',
        cookie: {
          key: 'cookie_name',
        },
      })
    )

    app.get('/auth/*', async (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })

    it('Should not authorize', async () => {
      const req = new Request('http://localhost/auth/a')
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
      expect(await res.text()).toBe('Unauthorized')
      expect(handlerExecuted).toBeFalsy()
    })

    it('Should authorize', async () => {
      const url = 'http://localhost/auth/a'
      const req = new Request(url, {
        headers: new Headers({
          Cookie:
            'cookie_name=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.B54pAqIiLbu170tGQ1rY06Twv__0qSHTA0ioQPIOvFE',
        }),
      })
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ message: 'hello world' })
      expect(handlerExecuted).toBeTruthy()
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/jwt/index.ts
```typescript
import type { JwtVariables } from './jwt'
export type { JwtVariables }
export { jwt, verify, decode, sign } from './jwt'
import type {} from '../..'

declare module '../..' {
  interface ContextVariableMap extends JwtVariables {}
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/jwt/jwt.ts
````typescript
/**
 * @module
 * JWT Auth Middleware for Hono.
 */

import type { Context } from '../../context'
import { getCookie, getSignedCookie } from '../../helper/cookie'
import { HTTPException } from '../../http-exception'
import type { MiddlewareHandler } from '../../types'
import type { CookiePrefixOptions } from '../../utils/cookie'
import { Jwt } from '../../utils/jwt'
import '../../context'
import type { SignatureAlgorithm } from '../../utils/jwt/jwa'
import type { SignatureKey } from '../../utils/jwt/jws'

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type JwtVariables<T = any> = {
  jwtPayload: T
}

/**
 * JWT Auth Middleware for Hono.
 *
 * @see {@link https://hono.dev/docs/middleware/builtin/jwt}
 *
 * @param {object} options - The options for the JWT middleware.
 * @param {SignatureKey} [options.secret] - A value of your secret key.
 * @param {string} [options.cookie] - If this value is set, then the value is retrieved from the cookie header using that value as a key, which is then validated as a token.
 * @param {SignatureAlgorithm} [options.alg=HS256] - An algorithm type that is used for verifying. Available types are `HS256` | `HS384` | `HS512` | `RS256` | `RS384` | `RS512` | `PS256` | `PS384` | `PS512` | `ES256` | `ES384` | `ES512` | `EdDSA`.
 * @returns {MiddlewareHandler} The middleware handler function.
 *
 * @example
 * ```ts
 * const app = new Hono()
 *
 * app.use(
 *   '/auth/*',
 *   jwt({
 *     secret: 'it-is-very-secret',
 *   })
 * )
 *
 * app.get('/auth/page', (c) => {
 *   return c.text('You are authorized')
 * })
 * ```
 */
export const jwt = (options: {
  secret: SignatureKey
  cookie?:
    | string
    | { key: string; secret?: string | BufferSource; prefixOptions?: CookiePrefixOptions }
  alg?: SignatureAlgorithm
}): MiddlewareHandler => {
  if (!options || !options.secret) {
    throw new Error('JWT auth middleware requires options for "secret"')
  }

  if (!crypto.subtle || !crypto.subtle.importKey) {
    throw new Error('`crypto.subtle.importKey` is undefined. JWT auth middleware requires it.')
  }

  return async function jwt(ctx, next) {
    const credentials = ctx.req.raw.headers.get('Authorization')
    let token
    if (credentials) {
      const parts = credentials.split(/\s+/)
      if (parts.length !== 2) {
        const errDescription = 'invalid credentials structure'
        throw new HTTPException(401, {
          message: errDescription,
          res: unauthorizedResponse({
            ctx,
            error: 'invalid_request',
            errDescription,
          }),
        })
      } else {
        token = parts[1]
      }
    } else if (options.cookie) {
      if (typeof options.cookie == 'string') {
        token = getCookie(ctx, options.cookie)
      } else if (options.cookie.secret) {
        if (options.cookie.prefixOptions) {
          token = await getSignedCookie(
            ctx,
            options.cookie.secret,
            options.cookie.key,
            options.cookie.prefixOptions
          )
        } else {
          token = await getSignedCookie(ctx, options.cookie.secret, options.cookie.key)
        }
      } else {
        if (options.cookie.prefixOptions) {
          token = getCookie(ctx, options.cookie.key, options.cookie.prefixOptions)
        } else {
          token = getCookie(ctx, options.cookie.key)
        }
      }
    }

    if (!token) {
      const errDescription = 'no authorization included in request'
      throw new HTTPException(401, {
        message: errDescription,
        res: unauthorizedResponse({
          ctx,
          error: 'invalid_request',
          errDescription,
        }),
      })
    }

    let payload
    let cause
    try {
      payload = await Jwt.verify(token, options.secret, options.alg)
    } catch (e) {
      cause = e
    }
    if (!payload) {
      throw new HTTPException(401, {
        message: 'Unauthorized',
        res: unauthorizedResponse({
          ctx,
          error: 'invalid_token',
          statusText: 'Unauthorized',
          errDescription: 'token verification failure',
        }),
        cause,
      })
    }

    ctx.set('jwtPayload', payload)

    await next()
  }
}

function unauthorizedResponse(opts: {
  ctx: Context
  error: string
  errDescription: string
  statusText?: string
}) {
  return new Response('Unauthorized', {
    status: 401,
    statusText: opts.statusText,
    headers: {
      'WWW-Authenticate': `Bearer realm="${opts.ctx.req.url}",error="${opts.error}",error_description="${opts.errDescription}"`,
    },
  })
}

export const verify = Jwt.verify
export const decode = Jwt.decode
export const sign = Jwt.sign

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/compress/index.test.ts
```typescript
import { stream, streamSSE } from '../../helper/streaming'
import { Hono } from '../../hono'
import { compress } from '.'

describe('Compress Middleware', () => {
  const app = new Hono()

  // Apply compress middleware to all routes
  app.use('*', compress())

  // Test routes
  app.get('/small', (c) => {
    c.header('Content-Type', 'text/plain')
    c.header('Content-Length', '5')
    return c.text('small')
  })
  app.get('/large', (c) => {
    c.header('Content-Type', 'text/plain')
    c.header('Content-Length', '1024')
    return c.text('a'.repeat(1024))
  })
  app.get('/small-json', (c) => {
    c.header('Content-Type', 'application/json')
    c.header('Content-Length', '26')
    return c.json({ message: 'Hello, World!' })
  })
  app.get('/large-json', (c) => {
    c.header('Content-Type', 'application/json')
    c.header('Content-Length', '1024')
    return c.json({ data: 'a'.repeat(1024), message: 'Large JSON' })
  })
  app.get('/no-transform', (c) => {
    c.header('Content-Type', 'text/plain')
    c.header('Content-Length', '1024')
    c.header('Cache-Control', 'no-transform')
    return c.text('a'.repeat(1024))
  })
  app.get('/jpeg-image', (c) => {
    c.header('Content-Type', 'image/jpeg')
    c.header('Content-Length', '1024')
    return c.body(new Uint8Array(1024)) // Simulated JPEG data
  })
  app.get('/already-compressed', (c) => {
    c.header('Content-Type', 'application/octet-stream')
    c.header('Content-Encoding', 'br')
    c.header('Content-Length', '1024')
    return c.body(new Uint8Array(1024)) // Simulated compressed data
  })
  app.get('/transfer-encoding-deflate', (c) => {
    c.header('Content-Type', 'application/octet-stream')
    c.header('Transfer-Encoding', 'deflate')
    c.header('Content-Length', '1024')
    return c.body(new Uint8Array(1024)) // Simulated deflate data
  })
  app.get('/chunked', (c) => {
    c.header('Content-Type', 'application/octet-stream')
    c.header('Transfer-Encoding', 'chunked')
    c.header('Content-Length', '1024')
    return c.body(new Uint8Array(1024)) // Simulated chunked data
  })
  app.get('/stream', (c) =>
    stream(c, async (stream) => {
      c.header('Content-Type', 'text/plain')
      // 60000 bytes
      for (let i = 0; i < 10000; i++) {
        await stream.write('chunk ')
      }
    })
  )
  app.get('/already-compressed-stream', (c) =>
    stream(c, async (stream) => {
      c.header('Content-Type', 'text/plain')
      c.header('Content-Encoding', 'br')
      // 60000 bytes
      for (let i = 0; i < 10000; i++) {
        await stream.write(new Uint8Array([0, 1, 2, 3, 4, 5])) // Simulated compressed data
      }
    })
  )
  app.get('/sse', (c) =>
    streamSSE(c, async (stream) => {
      for (let i = 0; i < 1000; i++) {
        await stream.writeSSE({ data: 'chunk' })
      }
    })
  )
  app.notFound((c) => c.text('Custom NotFound', 404))

  const testCompression = async (
    path: string,
    acceptEncoding: string,
    expectedEncoding: string | null
  ) => {
    const req = new Request(`http://localhost${path}`, {
      method: 'GET',
      headers: new Headers({ 'Accept-Encoding': acceptEncoding }),
    })
    const res = await app.request(req)
    expect(res.headers.get('Content-Encoding')).toBe(expectedEncoding)
    return res
  }

  describe('Compression Behavior', () => {
    it('should compress large responses with gzip', async () => {
      const res = await testCompression('/large', 'gzip', 'gzip')
      expect(res.headers.get('Content-Length')).toBeNull()
      expect((await res.arrayBuffer()).byteLength).toBeLessThan(1024)
    })

    it('should compress large responses with deflate', async () => {
      const res = await testCompression('/large', 'deflate', 'deflate')
      expect((await res.arrayBuffer()).byteLength).toBeLessThan(1024)
    })

    it('should prioritize gzip over deflate when both are accepted', async () => {
      await testCompression('/large', 'gzip, deflate', 'gzip')
    })

    it('should not compress small responses', async () => {
      const res = await testCompression('/small', 'gzip, deflate', null)
      expect(res.headers.get('Content-Length')).toBe('5')
    })

    it('should not compress when no Accept-Encoding is provided', async () => {
      await testCompression('/large', '', null)
    })

    it('should not compress images', async () => {
      const res = await testCompression('/jpeg-image', 'gzip', null)
      expect(res.headers.get('Content-Type')).toBe('image/jpeg')
      expect(res.headers.get('Content-Length')).toBe('1024')
    })

    it('should not compress already compressed responses', async () => {
      const res = await testCompression('/already-compressed', 'gzip', 'br')
      expect(res.headers.get('Content-Length')).toBe('1024')
    })

    it('should remove Content-Length when compressing', async () => {
      const res = await testCompression('/large', 'gzip', 'gzip')
      expect(res.headers.get('Content-Length')).toBeNull()
    })

    it('should not remove Content-Length when not compressing', async () => {
      const res = await testCompression('/jpeg-image', 'gzip', null)
      expect(res.headers.get('Content-Length')).toBeDefined()
    })

    it('should not compress transfer-encoding: deflate', async () => {
      const res = await testCompression('/transfer-encoding-deflate', 'gzip', null)
      expect(res.headers.get('Content-Length')).toBe('1024')
      expect(res.headers.get('Transfer-Encoding')).toBe('deflate')
    })

    it('should not compress transfer-encoding: chunked', async () => {
      const res = await testCompression('/chunked', 'gzip', null)
      expect(res.headers.get('Content-Length')).toBe('1024')
      expect(res.headers.get('Transfer-Encoding')).toBe('chunked')
    })
  })

  describe('JSON Handling', () => {
    it('should not compress small JSON responses', async () => {
      const res = await testCompression('/small-json', 'gzip', null)
      expect(res.headers.get('Content-Length')).toBe('26')
    })

    it('should compress large JSON responses', async () => {
      const res = await testCompression('/large-json', 'gzip', 'gzip')
      expect(res.headers.get('Content-Length')).toBeNull()
      const decompressed = await decompressResponse(res)
      const json = JSON.parse(decompressed)
      expect(json.data.length).toBe(1024)
      expect(json.message).toBe('Large JSON')
    })
  })

  describe('Streaming Responses', () => {
    it('should compress streaming responses written in multiple chunks', async () => {
      const res = await testCompression('/stream', 'gzip', 'gzip')
      const decompressed = await decompressResponse(res)
      expect(decompressed.length).toBe(60000)
    })

    it('should not compress already compressed streaming responses', async () => {
      const res = await testCompression('/already-compressed-stream', 'gzip', 'br')
      expect((await res.arrayBuffer()).byteLength).toBe(60000)
    })

    it('should not compress server-sent events', async () => {
      const res = await testCompression('/sse', 'gzip', null)
      expect((await res.arrayBuffer()).byteLength).toBe(13000)
    })
  })

  describe('Edge Cases', () => {
    it('should not compress responses with Cache-Control: no-transform', async () => {
      await testCompression('/no-transform', 'gzip', null)
    })

    it('should handle HEAD requests without compression', async () => {
      const req = new Request('http://localhost/large', {
        method: 'HEAD',
        headers: new Headers({ 'Accept-Encoding': 'gzip' }),
      })
      const res = await app.request(req)
      expect(res.headers.get('Content-Encoding')).toBeNull()
    })

    it('should compress custom 404 Not Found responses', async () => {
      const res = await testCompression('/not-found', 'gzip', 'gzip')
      expect(res.status).toBe(404)
      const decompressed = await decompressResponse(res)
      expect(decompressed).toBe('Custom NotFound')
    })
  })
})

async function decompressResponse(res: Response): Promise<string> {
  const decompressedStream = res.body!.pipeThrough(new DecompressionStream('gzip'))
  const decompressedResponse = new Response(decompressedStream)
  return await decompressedResponse.text()
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/compress/index.ts
````typescript
/**
 * @module
 * Compress Middleware for Hono.
 */

import type { MiddlewareHandler } from '../../types'
import { COMPRESSIBLE_CONTENT_TYPE_REGEX } from '../../utils/compress'

const ENCODING_TYPES = ['gzip', 'deflate'] as const
const cacheControlNoTransformRegExp = /(?:^|,)\s*?no-transform\s*?(?:,|$)/i

interface CompressionOptions {
  encoding?: (typeof ENCODING_TYPES)[number]
  threshold?: number
}

/**
 * Compress Middleware for Hono.
 *
 * @see {@link https://hono.dev/docs/middleware/builtin/compress}
 *
 * @param {CompressionOptions} [options] - The options for the compress middleware.
 * @param {'gzip' | 'deflate'} [options.encoding] - The compression scheme to allow for response compression. Either 'gzip' or 'deflate'. If not defined, both are allowed and will be used based on the Accept-Encoding header. 'gzip' is prioritized if this option is not provided and the client provides both in the Accept-Encoding header.
 * @param {number} [options.threshold=1024] - The minimum size in bytes to compress. Defaults to 1024 bytes.
 * @returns {MiddlewareHandler} The middleware handler function.
 *
 * @example
 * ```ts
 * const app = new Hono()
 *
 * app.use(compress())
 * ```
 */
export const compress = (options?: CompressionOptions): MiddlewareHandler => {
  const threshold = options?.threshold ?? 1024

  return async function compress(ctx, next) {
    await next()

    const contentLength = ctx.res.headers.get('Content-Length')

    // Check if response should be compressed
    if (
      ctx.res.headers.has('Content-Encoding') || // already encoded
      ctx.res.headers.has('Transfer-Encoding') || // already encoded or chunked
      ctx.req.method === 'HEAD' || // HEAD request
      (contentLength && Number(contentLength) < threshold) || // content-length below threshold
      !shouldCompress(ctx.res) || // not compressible type
      !shouldTransform(ctx.res) // cache-control: no-transform
    ) {
      return
    }

    const accepted = ctx.req.header('Accept-Encoding')
    const encoding =
      options?.encoding ?? ENCODING_TYPES.find((encoding) => accepted?.includes(encoding))
    if (!encoding || !ctx.res.body) {
      return
    }

    // Compress the response
    const stream = new CompressionStream(encoding)
    ctx.res = new Response(ctx.res.body.pipeThrough(stream), ctx.res)
    ctx.res.headers.delete('Content-Length')
    ctx.res.headers.set('Content-Encoding', encoding)
  }
}

const shouldCompress = (res: Response) => {
  const type = res.headers.get('Content-Type')
  return type && COMPRESSIBLE_CONTENT_TYPE_REGEX.test(type)
}

const shouldTransform = (res: Response) => {
  const cacheControl = res.headers.get('Cache-Control')
  // Don't compress for Cache-Control: no-transform
  // https://tools.ietf.org/html/rfc7234#section-5.2.2.4
  return !cacheControl || !cacheControlNoTransformRegExp.test(cacheControl)
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/logger/index.test.ts
```typescript
import { Hono } from '../../hono'
import { logger } from '.'

describe('Logger by Middleware', () => {
  let app: Hono
  let log: string

  beforeEach(() => {
    function sleep(time: number) {
      return new Promise((resolve) => setTimeout(resolve, time))
    }

    app = new Hono()

    const logFn = (str: string) => {
      log = str
    }

    const shortRandomString = 'hono'
    const longRandomString = 'hono'.repeat(1000)

    app.use('*', logger(logFn))
    app.get('/short', (c) => c.text(shortRandomString))
    app.get('/long', (c) => c.text(longRandomString))
    app.get('/seconds', async (c) => {
      await sleep(1000)

      return c.text(longRandomString)
    })
    app.get('/empty', (c) => c.text(''))
    app.get('/redirect', (c) => {
      return c.redirect('/empty', 301)
    })
    app.get('/server-error', (c) => {
      const res = new Response('', { status: 511 })
      if (c.req.query('status')) {
        // test status code not yet supported by runtime `Response` object
        Object.defineProperty(res, 'status', { value: parseInt(c.req.query('status') as string) })
      }
      return res
    })
  })

  it('Log status 200 with empty body', async () => {
    const res = await app.request('http://localhost/empty')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(log.startsWith('--> GET /empty \x1b[32m200\x1b[0m')).toBe(true)
    expect(log).toMatch(/m?s$/)
  })

  it('Log status 200 with small body', async () => {
    const res = await app.request('http://localhost/short')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(log.startsWith('--> GET /short \x1b[32m200\x1b[0m')).toBe(true)
    expect(log).toMatch(/m?s$/)
  })

  it('Log status 200 with small body and query param', async () => {
    const res = await app.request('http://localhost/short?foo=bar')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(log.startsWith('--> GET /short?foo=bar \x1b[32m200\x1b[0m')).toBe(true)
    expect(log).toMatch(/m?s$/)
  })

  it('Log status 200 with big body', async () => {
    const res = await app.request('http://localhost/long')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(log.startsWith('--> GET /long \x1b[32m200\x1b[0m')).toBe(true)
    expect(log).toMatch(/m?s$/)
  })

  it('Time in seconds', async () => {
    const res = await app.request('http://localhost/seconds')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(log.startsWith('--> GET /seconds \x1b[32m200\x1b[0m')).toBe(true)
    expect(log).toMatch(/1s/)
  })

  it('Log status 301 with empty body', async () => {
    const res = await app.request('http://localhost/redirect')
    expect(res).not.toBeNull()
    expect(res.status).toBe(301)
    expect(log.startsWith('--> GET /redirect \x1b[36m301\x1b[0m')).toBe(true)
    expect(log).toMatch(/m?s$/)
  })

  it('Log status 404', async () => {
    const msg = 'Default 404 Not Found'
    app.all('*', (c) => {
      return c.text(msg, 404)
    })
    const res = await app.request('http://localhost/notfound')
    expect(res).not.toBeNull()
    expect(res.status).toBe(404)
    expect(log.startsWith('--> GET /notfound \x1b[33m404\x1b[0m')).toBe(true)
    expect(log).toMatch(/m?s$/)
  })

  it('Log status 511 with empty body', async () => {
    const res = await app.request('http://localhost/server-error')
    expect(res).not.toBeNull()
    expect(res.status).toBe(511)
    expect(log.startsWith('--> GET /server-error \x1b[31m511\x1b[0m')).toBe(true)
    expect(log).toMatch(/m?s$/)
  })

  it('Log status 100', async () => {
    const res = await app.request('http://localhost/server-error?status=100')
    expect(res).not.toBeNull()
    expect(res.status).toBe(100)
    expect(log.startsWith('--> GET /server-error?status=100 100')).toBe(true)
    expect(log).toMatch(/m?s$/)
  })

  it('Log status 700', async () => {
    const res = await app.request('http://localhost/server-error?status=700')
    expect(res).not.toBeNull()
    expect(res.status).toBe(700)
    expect(log.startsWith('--> GET /server-error?status=700 700')).toBe(true)
    expect(log).toMatch(/m?s$/)
  })
})

describe('Logger by Middleware in NO_COLOR', () => {
  let app: Hono
  let log: string

  beforeEach(() => {
    vi.stubEnv('NO_COLOR', '1')
    function sleep(time: number) {
      return new Promise((resolve) => setTimeout(resolve, time))
    }

    app = new Hono()

    const logFn = (str: string) => {
      log = str
    }

    const shortRandomString = 'hono'
    const longRandomString = 'hono'.repeat(1000)

    app.use('*', logger(logFn))
    app.get('/short', (c) => c.text(shortRandomString))
    app.get('/long', (c) => c.text(longRandomString))
    app.get('/seconds', async (c) => {
      await sleep(1000)

      return c.text(longRandomString)
    })
    app.get('/empty', (c) => c.text(''))
  })
  afterAll(() => {
    vi.unstubAllEnvs()
  })
  it('Log status 200 with empty body', async () => {
    const res = await app.request('http://localhost/empty')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(log.startsWith('--> GET /empty 200')).toBe(true)
    expect(log).toMatch(/m?s$/)
  })

  it('Log status 200 with small body', async () => {
    const res = await app.request('http://localhost/short')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(log.startsWith('--> GET /short 200')).toBe(true)
    expect(log).toMatch(/m?s$/)
  })

  it('Log status 200 with big body', async () => {
    const res = await app.request('http://localhost/long')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(log.startsWith('--> GET /long 200')).toBe(true)
    expect(log).toMatch(/m?s$/)
  })

  it('Time in seconds', async () => {
    const res = await app.request('http://localhost/seconds')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(log.startsWith('--> GET /seconds 200')).toBe(true)
    expect(log).toMatch(/1s/)
  })

  it('Log status 404', async () => {
    const msg = 'Default 404 Not Found'
    app.all('*', (c) => {
      return c.text(msg, 404)
    })
    const res = await app.request('http://localhost/notfound')
    expect(res).not.toBeNull()
    expect(res.status).toBe(404)
    expect(log.startsWith('--> GET /notfound 404')).toBe(true)
    expect(log).toMatch(/m?s$/)
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/logger/index.ts
````typescript
/**
 * @module
 * Logger Middleware for Hono.
 */

import type { MiddlewareHandler } from '../../types'
import { getColorEnabled } from '../../utils/color'

enum LogPrefix {
  Outgoing = '-->',
  Incoming = '<--',
  Error = 'xxx',
}

const humanize = (times: string[]) => {
  const [delimiter, separator] = [',', '.']

  const orderTimes = times.map((v) => v.replace(/(\d)(?=(\d\d\d)+(?!\d))/g, '$1' + delimiter))

  return orderTimes.join(separator)
}

const time = (start: number) => {
  const delta = Date.now() - start
  return humanize([delta < 1000 ? delta + 'ms' : Math.round(delta / 1000) + 's'])
}

const colorStatus = (status: number) => {
  const colorEnabled = getColorEnabled()
  if (colorEnabled) {
    switch ((status / 100) | 0) {
      case 5: // red = error
        return `\x1b[31m${status}\x1b[0m`
      case 4: // yellow = warning
        return `\x1b[33m${status}\x1b[0m`
      case 3: // cyan = redirect
        return `\x1b[36m${status}\x1b[0m`
      case 2: // green = success
        return `\x1b[32m${status}\x1b[0m`
    }
  }
  // Fallback to unsupported status code.
  // E.g.) Bun and Deno supports new Response with 101, but Node.js does not.
  // And those may evolve to accept more status.
  return `${status}`
}

type PrintFunc = (str: string, ...rest: string[]) => void

function log(
  fn: PrintFunc,
  prefix: string,
  method: string,
  path: string,
  status: number = 0,
  elapsed?: string
) {
  const out =
    prefix === LogPrefix.Incoming
      ? `${prefix} ${method} ${path}`
      : `${prefix} ${method} ${path} ${colorStatus(status)} ${elapsed}`
  fn(out)
}

/**
 * Logger Middleware for Hono.
 *
 * @see {@link https://hono.dev/docs/middleware/builtin/logger}
 *
 * @param {PrintFunc} [fn=console.log] - Optional function for customized logging behavior.
 * @returns {MiddlewareHandler} The middleware handler function.
 *
 * @example
 * ```ts
 * const app = new Hono()
 *
 * app.use(logger())
 * app.get('/', (c) => c.text('Hello Hono!'))
 * ```
 */
export const logger = (fn: PrintFunc = console.log): MiddlewareHandler => {
  return async function logger(c, next) {
    const { method, url } = c.req

    const path = url.slice(url.indexOf('/', 8))

    log(fn, LogPrefix.Incoming, method, path)

    const start = Date.now()

    await next()

    log(fn, LogPrefix.Outgoing, method, path, c.res.status, time(start))
  }
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/cache/index.test.ts
```typescript
import type { ExecutionContext } from '../../context'
import { Hono } from '../../hono'
import { cache } from '.'

// Mock
class Context implements ExecutionContext {
  passThroughOnException(): void {
    throw new Error('Method not implemented.')
  }
  async waitUntil(promise: Promise<unknown>): Promise<void> {
    await promise
  }
}

describe('Customizing Caching Keys', () => {
  const app = new Hono()

  const dynamicCacheName = 'dynamic-cache-name'
  app.use(
    '/dynamic-cache-name/*',
    cache({
      cacheName: async () => dynamicCacheName,
      wait: true,
      cacheControl: 'max-age=10',
    })
  )
  app.get('/dynamic-cache-name/', (c) => {
    return c.text('cached')
  })

  const dynamicCacheKey = 'dynamic-cache-key'
  app.use(
    '/dynamic-cache-key/*',
    cache({
      cacheName: 'my-app-v1',
      wait: true,
      cacheControl: 'max-age=10',
      keyGenerator: async () => dynamicCacheKey,
    })
  )
  app.get('/dynamic-cache-key/', (c) => {
    return c.text('cached')
  })

  app.use(
    '/dynamic-cache/*',
    cache({
      cacheName: async () => dynamicCacheName,
      cacheControl: 'max-age=10',
      keyGenerator: async () => dynamicCacheKey,
    })
  )
  app.get('/dynamic-cache/', (c) => {
    return c.text('cached')
  })

  const ctx = new Context()

  it('Should use dynamically generated cache name', async () => {
    await app.request('http://localhost/dynamic-cache-name/', undefined, ctx)
    const cache = await caches.open(dynamicCacheName)
    const keys = Array.from(await cache.keys())
    expect(keys.length).toBe(1)
  })

  it('Should use dynamically generated cache key', async () => {
    await app.request('http://localhost/dynamic-cache-key/')
    const cache = await caches.open('my-app-v1')
    const response = await cache.match(dynamicCacheKey)
    expect(response).not.toBeNull()
  })

  it('Should retrieve cached response with dynamic cache name and key', async () => {
    await app.request('http://localhost/dynamic-cache/', undefined, undefined, ctx)
    const res = await app.request('http://localhost/dynamic-cache/', undefined, undefined, ctx)
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('cache-control')).toBe('max-age=10')
  })
})

describe('Cache Middleware', () => {
  const app = new Hono()

  let count = 1
  // wait, because this is test.
  // You don't have to set `wait: true`.
  app.use('/wait/*', cache({ cacheName: 'my-app-v1', wait: true, cacheControl: 'max-age=10' }))
  app.get('/wait/', (c) => {
    c.header('X-Count', `${count}`)
    count++
    return c.text('cached')
  })

  // Default, use `waitUntil`
  app.use('/not-wait/*', cache({ cacheName: 'my-app-v1', cacheControl: 'max-age=10' }))
  app.get('/not-wait/', (c) => {
    return c.text('not cached')
  })

  app.use('/wait2/*', cache({ cacheName: 'my-app-v1', wait: true, cacheControl: 'max-age=10' }))
  app.use('/wait2/*', cache({ cacheName: 'my-app-v1', wait: true, cacheControl: 'Max-Age=20' }))
  app.get('/wait2/', (c) => {
    return c.text('cached')
  })

  app.use('/wait3/*', cache({ cacheName: 'my-app-v1', wait: true, cacheControl: 'max-age=10' }))
  app.use(
    '/wait3/private/*',
    cache({ cacheName: 'my-app-v1', wait: true, cacheControl: 'private' })
  )
  app.get('/wait3/private/', (c) => {
    return c.text('cached')
  })

  app.use('/wait4/*', cache({ cacheName: 'my-app-v1', wait: true, cacheControl: 'max-age=10' }))
  app.get('/wait4/', (c) => {
    c.header('Cache-Control', 'private')
    return c.text('cached')
  })

  app.use('/vary1/*', cache({ cacheName: 'my-app-v1', wait: true, vary: ['Accept'] }))
  app.get('/vary1/', (c) => {
    return c.text('cached')
  })

  app.use('/vary2/*', cache({ cacheName: 'my-app-v1', wait: true, vary: ['Accept'] }))
  app.get('/vary2/', (c) => {
    c.header('Vary', 'Accept-Encoding')
    return c.text('cached')
  })

  app.use(
    '/vary3/*',
    cache({ cacheName: 'my-app-v1', wait: true, vary: ['Accept', 'Accept-Encoding'] })
  )
  app.get('/vary3/', (c) => {
    c.header('Vary', 'Accept-Language')
    return c.text('cached')
  })

  app.use(
    '/vary4/*',
    cache({ cacheName: 'my-app-v1', wait: true, vary: ['Accept', 'Accept-Encoding'] })
  )
  app.get('/vary4/', (c) => {
    c.header('Vary', 'Accept, Accept-Language')
    return c.text('cached')
  })

  app.use('/vary5/*', cache({ cacheName: 'my-app-v1', wait: true, vary: 'Accept' }))
  app.get('/vary5/', (c) => {
    return c.text('cached with Accept and Accept-Encoding headers')
  })

  app.use(
    '/vary6/*',
    cache({ cacheName: 'my-app-v1', wait: true, vary: 'Accept, Accept-Encoding' })
  )
  app.get('/vary6/', (c) => {
    c.header('Vary', 'Accept, Accept-Language')
    return c.text('cached with Accept and Accept-Encoding headers as array')
  })

  app.use('/vary7/*', cache({ cacheName: 'my-app-v1', wait: true, vary: ['Accept'] }))
  app.get('/vary7/', (c) => {
    c.header('Vary', '*')
    return c.text('cached')
  })

  app.use(
    '/not-found/*',
    cache({ cacheName: 'my-app-v1', wait: true, cacheControl: 'max-age=10', vary: ['Accept'] })
  )

  const ctx = new Context()

  it('Should return cached response', async () => {
    await app.request('http://localhost/wait/')
    const res = await app.request('http://localhost/wait/')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('cache-control')).toBe('max-age=10')
    expect(res.headers.get('x-count')).toBe('1')
  })

  it('Should not return cached response', async () => {
    await app.fetch(new Request('http://localhost/not-wait/'), undefined, ctx)
    const res = await app.fetch(new Request('http://localhost/not-wait/'), undefined, ctx)
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('cache-control')).toBe('max-age=10')
  })

  it('Should not return duplicate header values', async () => {
    const res = await app.request('/wait2/')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('cache-control')).toBe('max-age=20')
  })

  it('Should return composed middleware header values', async () => {
    const res = await app.request('/wait3/private/')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('cache-control')).toBe('private, max-age=10')
  })

  it('Should return composed handler header values', async () => {
    const res = await app.request('/wait4/')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('cache-control')).toBe('private, max-age=10')
  })

  it('Should correctly apply a single Vary header from middleware', async () => {
    const res = await app.request('http://localhost/vary1/')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('vary')).toBe('accept')
  })

  it('Should merge Vary headers from middleware and handler without duplicating', async () => {
    const res = await app.request('http://localhost/vary2/')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('vary')).toBe('accept, accept-encoding')
  })

  it('Should deduplicate while merging multiple Vary headers from middleware and handler', async () => {
    const res = await app.request('http://localhost/vary3/')
    expect(res.headers.get('vary')).toBe('accept, accept-encoding, accept-language')
  })

  it('Should prevent duplication of Vary headers when identical ones are set by both middleware and handler', async () => {
    const res = await app.request('http://localhost/vary4/')
    expect(res.headers.get('vary')).toBe('accept, accept-encoding, accept-language')
  })

  it('Should correctly apply and return a single Vary header with Accept specified by middleware', async () => {
    const res = await app.request('http://localhost/vary5/')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('vary')).toBe('accept')
  })

  it('Should merge Vary headers specified by middleware as a string with additional headers added by handler', async () => {
    const res = await app.request('http://localhost/vary6/')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('vary')).toBe('accept, accept-encoding, accept-language')
  })

  it('Should prioritize the "*" Vary header from handler over any set by middleware', async () => {
    const res = await app.request('http://localhost/vary7/')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('vary')).toBe('*')
  })

  it('Should not allow "*" as a Vary header in middleware configuration due to its impact on caching effectiveness', async () => {
    expect(() => cache({ cacheName: 'my-app-v1', wait: true, vary: ['*'] })).toThrow()
    expect(() => cache({ cacheName: 'my-app-v1', wait: true, vary: '*' })).toThrow()
  })

  it('Should not cache if it is not found', async () => {
    const res = await app.request('/not-found/')
    expect(res).not.toBeNull()
    expect(res.status).toBe(404)
    expect(res.headers.get('cache-control')).toBeFalsy()
    expect(res.headers.get('vary')).toBeFalsy()
  })

  it('Should not be enabled if caches is not defined', async () => {
    vi.stubGlobal('caches', undefined)
    const app = new Hono()
    app.use(cache({ cacheName: 'my-app-v1', cacheControl: 'max-age=10' }))
    app.get('/', (c) => {
      return c.text('cached')
    })
    expect(caches).toBeUndefined()
    const res = await app.request('/')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('cache-control')).toBe(null)
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/cache/index.ts
````typescript
/**
 * @module
 * Cache Middleware for Hono.
 */

import type { Context } from '../../context'
import type { MiddlewareHandler } from '../../types'

/**
 * Cache Middleware for Hono.
 *
 * @see {@link https://hono.dev/docs/middleware/builtin/cache}
 *
 * @param {Object} options - The options for the cache middleware.
 * @param {string | Function} options.cacheName - The name of the cache. Can be used to store multiple caches with different identifiers.
 * @param {boolean} [options.wait=false] - A boolean indicating if Hono should wait for the Promise of the `cache.put` function to resolve before continuing with the request. Required to be true for the Deno environment.
 * @param {string} [options.cacheControl] - A string of directives for the `Cache-Control` header.
 * @param {string | string[]} [options.vary] - Sets the `Vary` header in the response. If the original response header already contains a `Vary` header, the values are merged, removing any duplicates.
 * @param {Function} [options.keyGenerator] - Generates keys for every request in the `cacheName` store. This can be used to cache data based on request parameters or context parameters.
 * @returns {MiddlewareHandler} The middleware handler function.
 * @throws {Error} If the `vary` option includes "*".
 *
 * @example
 * ```ts
 * app.get(
 *   '*',
 *   cache({
 *     cacheName: 'my-app',
 *     cacheControl: 'max-age=3600',
 *   })
 * )
 * ```
 */
export const cache = (options: {
  cacheName: string | ((c: Context) => Promise<string> | string)
  wait?: boolean
  cacheControl?: string
  vary?: string | string[]
  keyGenerator?: (c: Context) => Promise<string> | string
}): MiddlewareHandler => {
  if (!globalThis.caches) {
    console.log('Cache Middleware is not enabled because caches is not defined.')
    return async (_c, next) => await next()
  }

  if (options.wait === undefined) {
    options.wait = false
  }

  const cacheControlDirectives = options.cacheControl
    ?.split(',')
    .map((directive) => directive.toLowerCase())
  const varyDirectives = Array.isArray(options.vary)
    ? options.vary
    : options.vary?.split(',').map((directive) => directive.trim())
  // RFC 7231 Section 7.1.4 specifies that "*" is not allowed in Vary header.
  // See: https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.4
  if (options.vary?.includes('*')) {
    throw new Error(
      'Middleware vary configuration cannot include "*", as it disallows effective caching.'
    )
  }

  const addHeader = (c: Context) => {
    if (cacheControlDirectives) {
      const existingDirectives =
        c.res.headers
          .get('Cache-Control')
          ?.split(',')
          .map((d) => d.trim().split('=', 1)[0]) ?? []
      for (const directive of cacheControlDirectives) {
        let [name, value] = directive.trim().split('=', 2)
        name = name.toLowerCase()
        if (!existingDirectives.includes(name)) {
          c.header('Cache-Control', `${name}${value ? `=${value}` : ''}`, { append: true })
        }
      }
    }

    if (varyDirectives) {
      const existingDirectives =
        c.res.headers
          .get('Vary')
          ?.split(',')
          .map((d) => d.trim()) ?? []

      const vary = Array.from(
        new Set(
          [...existingDirectives, ...varyDirectives].map((directive) => directive.toLowerCase())
        )
      ).sort()

      if (vary.includes('*')) {
        c.header('Vary', '*')
      } else {
        c.header('Vary', vary.join(', '))
      }
    }
  }

  return async function cache(c, next) {
    let key = c.req.url
    if (options.keyGenerator) {
      key = await options.keyGenerator(c)
    }

    const cacheName =
      typeof options.cacheName === 'function' ? await options.cacheName(c) : options.cacheName
    const cache = await caches.open(cacheName)
    const response = await cache.match(key)
    if (response) {
      return new Response(response.body, response)
    }

    await next()
    if (!c.res.ok) {
      return
    }
    addHeader(c)
    const res = c.res.clone()
    if (options.wait) {
      await cache.put(key, res)
    } else {
      c.executionCtx.waitUntil(cache.put(key, res))
    }
  }
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/combine/index.test.ts
```typescript
import { Hono } from '../../hono'
import type { MiddlewareHandler } from '../../types'
import { every, except, some } from '.'

const nextMiddleware: MiddlewareHandler = async (_, next) => await next()

describe('some', () => {
  let app: Hono

  beforeEach(() => {
    app = new Hono()
  })

  it('Should call only the first middleware', async () => {
    const middleware1 = vi.fn(nextMiddleware)
    const middleware2 = vi.fn(nextMiddleware)

    app.use('/', some(middleware1, middleware2))
    app.get('/', (c) => {
      return c.text('Hello World')
    })
    const res = await app.request('http://localhost/')

    expect(middleware1).toBeCalled()
    expect(middleware2).not.toBeCalled()
    expect(await res.text()).toBe('Hello World')
  })

  it('Should try to call the second middleware if the first one throws an error', async () => {
    const middleware1 = () => {
      throw new Error('Error')
    }
    const middleware2 = vi.fn(nextMiddleware)

    app.use('/', some(middleware1, middleware2))
    app.get('/', (c) => {
      return c.text('Hello World')
    })
    const res = await app.request('http://localhost/')

    expect(middleware2).toBeCalled()
    expect(await res.text()).toBe('Hello World')
  })

  it('Should try to call the second middleware if the first one returns false', async () => {
    const middleware1 = () => false
    const middleware2 = vi.fn(nextMiddleware)

    app.use('/', some(middleware1, middleware2))
    app.get('/', (c) => {
      return c.text('Hello World')
    })
    const res = await app.request('http://localhost/')

    expect(middleware2).toBeCalled()
    expect(await res.text()).toBe('Hello World')
  })

  it('Should throw last error if all middleware throw an error', async () => {
    const middleware1 = () => {
      throw new Error('Error1')
    }
    const middleware2 = () => {
      throw new Error('Error2')
    }

    app.use('/', some(middleware1, middleware2))
    app.get('/', (c) => {
      return c.text('Hello World')
    })
    app.onError((error, c) => {
      return c.text(error.message)
    })
    const res = await app.request('http://localhost/')

    expect(await res.text()).toBe('Error2')
  })

  it('Should throw error if all middleware return false', async () => {
    const middleware1 = () => false
    const middleware2 = () => false

    app.use('/', some(middleware1, middleware2))
    app.get('/', (c) => {
      return c.text('Hello World')
    })
    app.onError((_, c) => {
      return c.text('oops')
    })
    const res = await app.request('http://localhost/')

    expect(await res.text()).toBe('oops')
  })

  it('Should not call skipped middleware even if an error is thrown', async () => {
    const middleware1: MiddlewareHandler = async (c, next) => {
      await next()
    }
    const middleware2 = vi.fn(() => true)

    app.use(
      '/',
      every(some(middleware1, middleware2), () => {
        throw new Error('Error')
      })
    )
    app.get('/', (c) => c.text('OK'))
    app.onError((_, c) => {
      return c.text('oops')
    })
    const res = await app.request('http://localhost/')

    expect(middleware2).not.toBeCalled()
    expect(await res.text()).toBe('oops')
  })

  it('Should not call skipped middleware even if an error is thrown with returning truthy value middleware', async () => {
    const middleware1 = () => true
    const middleware2 = vi.fn(() => true)

    app.use(
      '/',
      every(some(middleware1, middleware2), () => {
        throw new Error('Error')
      })
    )
    app.get('/', (c) => c.text('OK'))
    app.onError((_, c) => {
      return c.text('oops')
    })
    const res = await app.request('http://localhost/')

    expect(middleware2).not.toBeCalled()
    expect(await res.text()).toBe('oops')
  })
})

describe('every', () => {
  let app: Hono

  beforeEach(() => {
    app = new Hono()
  })

  it('Should call all middleware', async () => {
    const middleware1 = vi.fn(nextMiddleware)
    const middleware2 = vi.fn(nextMiddleware)

    app.use('/', every(middleware1, middleware2))
    app.get('/', (c) => {
      return c.text('Hello World')
    })
    const res = await app.request('http://localhost/')

    expect(middleware1).toBeCalled()
    expect(middleware2).toBeCalled()
    expect(await res.text()).toBe('Hello World')
  })

  it('Should throw error if any middleware throws an error', async () => {
    const middleware1 = () => {
      throw new Error('Error1')
    }
    const middleware2 = vi.fn(nextMiddleware)

    app.use('/', every(middleware1, middleware2))
    app.get('/', (c) => {
      return c.text('Hello World')
    })
    app.onError((error, c) => {
      return c.text(error.message)
    })
    const res = await app.request('http://localhost/')

    expect(await res.text()).toBe('Error1')
    expect(middleware2).not.toBeCalled()
  })

  it('Should throw error if any middleware returns false', async () => {
    const middleware1 = () => false
    const middleware2 = vi.fn(nextMiddleware)

    app.use('/', every(middleware1, middleware2))
    app.get('/', (c) => {
      return c.text('Hello World')
    })
    app.onError((_, c) => {
      return c.text('oops')
    })
    const res = await app.request('http://localhost/')

    expect(await res.text()).toBe('oops')
    expect(middleware2).not.toBeCalled()
  })

  it('Should return the same response a middleware returns if it short-circuits the chain', async () => {
    const middleware1: MiddlewareHandler = async (c) => {
      return c.text('Hello Middleware 1')
    }
    const middleware2 = vi.fn(nextMiddleware)

    app.use('/', every(middleware1, middleware2))
    app.get('/', (c) => {
      return c.text('Hello World')
    })
    const res = await app.request('http://localhost/')

    expect(await res.text()).toBe('Hello Middleware 1')
    expect(middleware2).not.toBeCalled()
  })

  it('Should pass the path params to middlewares', async () => {
    const app = new Hono()
    app.use('*', nextMiddleware)
    const paramMiddleware: MiddlewareHandler = async (c) => {
      return c.json(c.req.param(), 200)
    }

    app.use('/:id', every(paramMiddleware))
    app.get('/:id', (c) => {
      return c.text('Hello World')
    })

    const res = await app.request('http://localhost/123')
    expect(await res.json()).toEqual({ id: '123' })
  })
})

describe('except', () => {
  let app: Hono

  beforeEach(() => {
    app = new Hono()
  })

  it('Should call all middleware, except the one that matches the condition', async () => {
    const middleware1 = vi.fn(nextMiddleware)
    const middleware2 = vi.fn(nextMiddleware)

    app.use('*', except('/maintenance', middleware1, middleware2))
    app.get('/maintenance', (c) => {
      return c.text('Hello Maintenance')
    })
    app.get('*', (c) => {
      return c.redirect('/maintenance')
    })
    let res = await app.request('http://localhost/')

    expect(middleware1).toBeCalled()
    expect(middleware2).toBeCalled()
    expect(res.headers.get('location')).toBe('/maintenance')

    middleware1.mockClear()
    middleware2.mockClear()
    res = await app.request('http://localhost/maintenance')

    expect(middleware1).not.toBeCalled()
    expect(middleware2).not.toBeCalled()
    expect(await res.text()).toBe('Hello Maintenance')
  })

  it('Should call all middleware, except the one that matches some of the conditions', async () => {
    const middleware1 = vi.fn(nextMiddleware)
    const middleware2 = vi.fn(nextMiddleware)

    app.use('*', except(['/maintenance', '/public/users/:id'], middleware1, middleware2))
    app.get('/maintenance', (c) => {
      return c.text('Hello Maintenance')
    })
    app.get('/public/users/:id', (c) => {
      return c.text(`Hello Public User ${c.req.param('id')}`)
    })
    app.get('/secret', (c) => {
      return c.text('Hello Secret')
    })
    let res = await app.request('http://localhost/secret')

    expect(middleware1).toBeCalled()
    expect(middleware2).toBeCalled()
    expect(await res.text()).toBe('Hello Secret')

    middleware1.mockClear()
    middleware2.mockClear()
    res = await app.request('http://localhost/maintenance')

    expect(middleware1).not.toBeCalled()
    expect(middleware2).not.toBeCalled()
    expect(await res.text()).toBe('Hello Maintenance')

    middleware1.mockClear()
    middleware2.mockClear()
    res = await app.request('http://localhost/public/users/123')

    expect(middleware1).not.toBeCalled()
    expect(middleware2).not.toBeCalled()
    expect(await res.text()).toBe('Hello Public User 123')
  })

  it('Should call all middleware, except the one that matches some of the condition function', async () => {
    const middleware1 = vi.fn(nextMiddleware)
    const middleware2 = vi.fn(nextMiddleware)

    app.use(
      '*',
      except(['/maintenance', (c) => !!c.req.path.match(/public/)], middleware1, middleware2)
    )
    app.get('/maintenance', (c) => {
      return c.text('Hello Maintenance')
    })
    app.get('/public/users/:id', (c) => {
      return c.text(`Hello Public User ${c.req.param('id')}`)
    })
    app.get('/secret', (c) => {
      return c.text('Hello Secret')
    })
    let res = await app.request('http://localhost/secret')

    expect(middleware1).toBeCalled()
    expect(middleware2).toBeCalled()
    expect(await res.text()).toBe('Hello Secret')

    middleware1.mockClear()
    middleware2.mockClear()
    res = await app.request('http://localhost/maintenance')

    expect(middleware1).not.toBeCalled()
    expect(middleware2).not.toBeCalled()
    expect(await res.text()).toBe('Hello Maintenance')

    middleware1.mockClear()
    middleware2.mockClear()
    res = await app.request('http://localhost/public/users/123')

    expect(middleware1).not.toBeCalled()
    expect(middleware2).not.toBeCalled()
    expect(await res.text()).toBe('Hello Public User 123')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/combine/index.ts
````typescript
/**
 * @module
 * Combine Middleware for Hono.
 */

import { compose } from '../../compose'
import type { Context } from '../../context'
import { METHOD_NAME_ALL } from '../../router'
import { TrieRouter } from '../../router/trie-router'
import type { MiddlewareHandler, Next } from '../../types'

type Condition = (c: Context) => boolean

/**
 * Create a composed middleware that runs the first middleware that returns true.
 *
 * @param middleware - An array of MiddlewareHandler or Condition functions.
 * Middleware is applied in the order it is passed, and if any middleware exits without returning
 * an exception first, subsequent middleware will not be executed.
 * You can also pass a condition function that returns a boolean value. If returns true
 * the evaluation will be halted, and rest of the middleware will not be executed.
 * @returns A composed middleware.
 *
 * @example
 * ```ts
 * import { some } from 'hono/combine'
 * import { bearerAuth } from 'hono/bearer-auth'
 * import { myRateLimit } from '@/rate-limit'
 *
 * // If client has a valid token, then skip rate limiting.
 * // Otherwise, apply rate limiting.
 * app.use('/api/*', some(
 *   bearerAuth({ token }),
 *   myRateLimit({ limit: 100 }),
 * ));
 * ```
 */
export const some = (...middleware: (MiddlewareHandler | Condition)[]): MiddlewareHandler => {
  return async function some(c, next) {
    let isNextCalled = false
    const wrappedNext = () => {
      isNextCalled = true
      return next()
    }

    let lastError: unknown
    for (const handler of middleware) {
      try {
        const result = await handler(c, wrappedNext)
        if (result === true && !c.finalized) {
          await wrappedNext()
        } else if (result === false) {
          lastError = new Error('No successful middleware found')
          continue
        }
        lastError = undefined
        break
      } catch (error) {
        lastError = error
        if (isNextCalled) {
          break
        }
      }
    }
    if (lastError) {
      throw lastError
    }
  }
}

/**
 * Create a composed middleware that runs all middleware and throws an error if any of them fail.
 *
 * @param middleware - An array of MiddlewareHandler or Condition functions.
 * Middleware is applied in the order it is passed, and if any middleware throws an error,
 * subsequent middleware will not be executed.
 * You can also pass a condition function that returns a boolean value. If returns false
 * the evaluation will be halted, and rest of the middleware will not be executed.
 * @returns A composed middleware.
 *
 * @example
 * ```ts
 * import { some, every } from 'hono/combine'
 * import { bearerAuth } from 'hono/bearer-auth'
 * import { myCheckLocalNetwork } from '@/check-local-network'
 * import { myRateLimit } from '@/rate-limit'
 *
 * // If client is in local network, then skip authentication and rate limiting.
 * // Otherwise, apply authentication and rate limiting.
 * app.use('/api/*', some(
 *   myCheckLocalNetwork(),
 *   every(
 *     bearerAuth({ token }),
 *     myRateLimit({ limit: 100 }),
 *   ),
 * ));
 * ```
 */
export const every = (...middleware: (MiddlewareHandler | Condition)[]): MiddlewareHandler => {
  return async function every(c, next) {
    const currentRouteIndex = c.req.routeIndex
    await compose(
      middleware.map((m) => [
        [
          async (c: Context, next: Next) => {
            c.req.routeIndex = currentRouteIndex // should be unchanged in this context
            const res = await m(c, next)
            if (res === false) {
              throw new Error('Unmet condition')
            }
            return res
          },
        ],
      ])
    )(c, next)
  }
}

/**
 * Create a composed middleware that runs all middleware except when the condition is met.
 *
 * @param condition - A string or Condition function.
 * If there are multiple targets to match any of them, they can be passed as an array.
 * If a string is passed, it will be treated as a path pattern to match.
 * If a Condition function is passed, it will be evaluated against the request context.
 * @param middleware - A composed middleware
 *
 * @example
 * ```ts
 * import { except } from 'hono/combine'
 * import { bearerAuth } from 'hono/bearer-auth
 *
 * // If client is accessing public API, then skip authentication.
 * // Otherwise, require a valid token.
 * app.use('/api/*', except(
 *   '/api/public/*',
 *   bearerAuth({ token }),
 * ));
 * ```
 */
export const except = (
  condition: string | Condition | (string | Condition)[],
  ...middleware: MiddlewareHandler[]
): MiddlewareHandler => {
  let router: TrieRouter<true> | undefined = undefined
  const conditions = (Array.isArray(condition) ? condition : [condition])
    .map((condition) => {
      if (typeof condition === 'string') {
        router ||= new TrieRouter()
        router.add(METHOD_NAME_ALL, condition, true)
      } else {
        return condition
      }
    })
    .filter(Boolean) as Condition[]

  if (router) {
    conditions.unshift((c: Context) => !!router?.match(METHOD_NAME_ALL, c.req.path)?.[0]?.[0]?.[0])
  }

  const handler = some((c: Context) => conditions.some((cond) => cond(c)), every(...middleware))
  return async function except(c, next) {
    await handler(c, next)
  }
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/secure-headers/index.test.ts
```typescript
import { Hono } from '../../hono'
import { poweredBy } from '../powered-by'
import { NONCE, secureHeaders } from '.'
import type { ContentSecurityPolicyOptionHandler } from '.'

declare module '../..' {
  interface ContextVariableMap {
    ['test-scriptSrc-nonce']?: string
    ['test-styleSrc-nonce']?: string
  }
}

describe('Secure Headers Middleware', () => {
  it('default middleware', async () => {
    const app = new Hono()
    app.use('*', secureHeaders())
    app.get('/test', async (ctx) => {
      return ctx.text('test')
    })

    const res = await app.request('/test')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('X-Frame-Options')).toEqual('SAMEORIGIN')
    expect(res.headers.get('Strict-Transport-Security')).toEqual(
      'max-age=15552000; includeSubDomains'
    )
    expect(res.headers.get('X-Download-Options')).toEqual('noopen')
    expect(res.headers.get('X-XSS-Protection')).toEqual('0')
    expect(res.headers.get('X-Powered-By')).toBeNull()
    expect(res.headers.get('X-DNS-Prefetch-Control')).toEqual('off')
    expect(res.headers.get('X-Content-Type-Options')).toEqual('nosniff')
    expect(res.headers.get('Referrer-Policy')).toEqual('no-referrer')
    expect(res.headers.get('X-Permitted-Cross-Domain-Policies')).toEqual('none')
    expect(res.headers.get('Cross-Origin-Resource-Policy')).toEqual('same-origin')
    expect(res.headers.get('Cross-Origin-Opener-Policy')).toEqual('same-origin')
    expect(res.headers.get('Origin-Agent-Cluster')).toEqual('?1')
    expect(res.headers.get('Permissions-Policy')).toBeNull()
    expect(res.headers.get('Content-Security-Policy')).toBeFalsy()
    expect(res.headers.get('Content-Security-Policy-ReportOnly')).toBeFalsy()
  })

  it('all headers enabled', async () => {
    const app = new Hono()
    app.use(
      '*',
      secureHeaders({
        contentSecurityPolicy: {
          defaultSrc: ["'self'"],
        },
        contentSecurityPolicyReportOnly: {
          defaultSrc: ["'self'"],
        },
        crossOriginEmbedderPolicy: true,
        permissionsPolicy: {
          camera: [],
        },
      })
    )
    app.get('/test', async (ctx) => {
      return ctx.text('test')
    })

    const res = await app.request('/test')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('X-Frame-Options')).toEqual('SAMEORIGIN')
    expect(res.headers.get('Strict-Transport-Security')).toEqual(
      'max-age=15552000; includeSubDomains'
    )
    expect(res.headers.get('X-Download-Options')).toEqual('noopen')
    expect(res.headers.get('X-XSS-Protection')).toEqual('0')
    expect(res.headers.get('X-Powered-By')).toBeNull()
    expect(res.headers.get('X-DNS-Prefetch-Control')).toEqual('off')
    expect(res.headers.get('X-Content-Type-Options')).toEqual('nosniff')
    expect(res.headers.get('Referrer-Policy')).toEqual('no-referrer')
    expect(res.headers.get('X-Permitted-Cross-Domain-Policies')).toEqual('none')
    expect(res.headers.get('Cross-Origin-Resource-Policy')).toEqual('same-origin')
    expect(res.headers.get('Cross-Origin-Opener-Policy')).toEqual('same-origin')
    expect(res.headers.get('Origin-Agent-Cluster')).toEqual('?1')
    expect(res.headers.get('Cross-Origin-Embedder-Policy')).toEqual('require-corp')
    expect(res.headers.get('Permissions-Policy')).toEqual('camera=()')
    expect(res.headers.get('Content-Security-Policy')).toEqual("default-src 'self'")
    expect(res.headers.get('Content-Security-Policy-Report-Only')).toEqual("default-src 'self'")
  })

  it('specific headers disabled', async () => {
    const app = new Hono()
    app.use('*', secureHeaders({ xFrameOptions: false, xXssProtection: false }))
    app.get('/test', async (ctx) => {
      return ctx.text('test')
    })

    const res = await app.request('/test')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('X-Frame-Options')).toBeNull()
    expect(res.headers.get('Strict-Transport-Security')).toEqual(
      'max-age=15552000; includeSubDomains'
    )
    expect(res.headers.get('X-Download-Options')).toEqual('noopen')
    expect(res.headers.get('X-XSS-Protection')).toBeNull()
    expect(res.headers.get('X-Powered-By')).toBeNull()
    expect(res.headers.get('X-DNS-Prefetch-Control')).toEqual('off')
    expect(res.headers.get('X-Content-Type-Options')).toEqual('nosniff')
    expect(res.headers.get('Referrer-Policy')).toEqual('no-referrer')
    expect(res.headers.get('X-Permitted-Cross-Domain-Policies')).toEqual('none')
    expect(res.headers.get('Cross-Origin-Resource-Policy')).toEqual('same-origin')
    expect(res.headers.get('Cross-Origin-Opener-Policy')).toEqual('same-origin')
    expect(res.headers.get('Permissions-Policy')).toBeNull()
    expect(res.headers.get('Origin-Agent-Cluster')).toEqual('?1')
  })

  it('should remove x-powered-by header', async () => {
    const appBefore = new Hono()
    appBefore.use('*', secureHeaders())
    appBefore.use('*', poweredBy())

    const resBefore = await appBefore.request('/')
    expect(resBefore.headers.get('x-powered-by')).toBeFalsy()

    const appAfter = new Hono()
    appAfter.use('*', poweredBy())
    appAfter.use('*', secureHeaders())

    const resAfter = await appAfter.request('/')
    expect(resAfter.headers.get('x-powered-by')).toBe('Hono')
  })

  it('should override Strict-Transport-Security header after middleware', async () => {
    const app = new Hono()
    app.use('/test1', secureHeaders())

    app.all('*', async (c) => {
      c.res.headers.set('Strict-Transport-Security', 'Hono')
      return c.text('header updated')
    })

    const res1 = await app.request('/test1')
    expect(res1.headers.get('Strict-Transport-Security')).toEqual(
      'max-age=15552000; includeSubDomains'
    )

    const res2 = await app.request('/test2')
    expect(res2.headers.get('Strict-Transport-Security')).toEqual('Hono')
  })

  it('should use custom value when overridden', async () => {
    const app = new Hono()
    app.use(
      '/test',
      secureHeaders({
        strictTransportSecurity: 'max-age=31536000; includeSubDomains; preload;',
        xFrameOptions: 'DENY',
        xXssProtection: '1',
      })
    )

    const res = await app.request('/test')
    expect(res.headers.get('Strict-Transport-Security')).toEqual(
      'max-age=31536000; includeSubDomains; preload;'
    )
    expect(res.headers.get('X-FRAME-OPTIONS')).toEqual('DENY')
    expect(res.headers.get('X-XSS-Protection')).toEqual('1')
  })

  it('should set Permission-Policy header correctly', async () => {
    const app = new Hono()
    app.use(
      '/test',
      secureHeaders({
        permissionsPolicy: {
          fullscreen: ['self'],
          bluetooth: ['none'],
          payment: ['self', 'example.com'],
          syncXhr: [],
          camera: false,
          microphone: true,
          geolocation: ['*'],
          usb: ['self', 'https://a.example.com', 'https://b.example.com'],
          accelerometer: ['https://*.example.com'],
          gyroscope: ['src'],
          magnetometer: ['https://a.example.com', 'https://b.example.com'],
        },
      })
    )

    const res = await app.request('/test')
    expect(res.headers.get('Permissions-Policy')).toEqual(
      'fullscreen=(self), bluetooth=none, payment=(self "example.com"), sync-xhr=(), camera=none, microphone=*, ' +
        'geolocation=*, usb=(self "https://a.example.com" "https://b.example.com"), ' +
        'accelerometer=("https://*.example.com"), gyroscope=(src), ' +
        'magnetometer=("https://a.example.com" "https://b.example.com")'
    )
  })

  it('Remove X-Powered-By', async () => {
    const app = new Hono()

    app.get('/test', secureHeaders(), poweredBy(), async (c) => {
      return c.text('Hono is hot')
    })

    app.get(
      '/test2',
      secureHeaders({
        removePoweredBy: false,
      }),
      poweredBy(),
      async (c) => {
        return c.text('Hono is hot')
      }
    )

    const res = await app.request('/test')
    const poweredby = res.headers.get('X-Powered-By')
    expect(poweredby).toEqual(null)
    expect(await res.text()).toEqual('Hono is hot')

    const res2 = await app.request('/test2')
    const poweredby2 = res2.headers.get('X-Powered-By')
    expect(poweredby2).toEqual('Hono')
    expect(await res2.text()).toEqual('Hono is hot')
  })

  describe.each([
    { cspSettingName: 'contentSecurityPolicy', cspHeaderName: 'Content-Security-Policy' },
    {
      cspSettingName: 'contentSecurityPolicyReportOnly',
      cspHeaderName: 'Content-Security-Policy-Report-Only',
    },
  ])('CSP Setting ($cspSettingName)', ({ cspSettingName, cspHeaderName }) => {
    it('CSP Setting', async () => {
      const app = new Hono()
      app.use(
        '/test',
        secureHeaders({
          [cspSettingName]: {
            defaultSrc: ["'self'"],
            baseUri: ["'self'"],
            fontSrc: ["'self'", 'https:', 'data:'],
            frameAncestors: ["'self'"],
            imgSrc: ["'self'", 'data:'],
            objectSrc: ["'none'"],
            scriptSrc: ["'self'"],
            scriptSrcAttr: ["'none'"],
            styleSrc: ["'self'", 'https:', "'unsafe-inline'"],
          },
        })
      )

      app.all('*', async (c) => {
        c.res.headers.set('Strict-Transport-Security', 'Hono')
        return c.text('header updated')
      })

      const res = await app.request('/test')
      expect(res.headers.get(cspHeaderName)).toEqual(
        "default-src 'self'; base-uri 'self'; font-src 'self' https: data:; frame-ancestors 'self'; img-src 'self' data:; object-src 'none'; script-src 'self'; script-src-attr 'none'; style-src 'self' https: 'unsafe-inline'"
      )
    })

    it('CSP Setting one only', async () => {
      const app = new Hono()
      app.use(
        '/test',
        secureHeaders({
          [cspSettingName]: {
            defaultSrc: ["'self'"],
          },
        })
      )

      app.all('*', async (c) => {
        return c.text('header updated')
      })

      const res = await app.request('/test')
      expect(res.headers.get(cspHeaderName)).toEqual("default-src 'self'")
    })

    it('No CSP Setting', async () => {
      const app = new Hono()
      app.use('/test', secureHeaders({ [cspSettingName]: {} }))

      app.all('*', async (c) => {
        return c.text('header updated')
      })

      const res = await app.request('/test')
      expect(res.headers.get(cspHeaderName)).toEqual('')
    })

    it('CSP with reportTo', async () => {
      const app = new Hono()
      app.use(
        '/test1',
        secureHeaders({
          reportingEndpoints: [
            {
              name: 'endpoint-1',
              url: 'https://example.com/reports',
            },
          ],
          [cspSettingName]: {
            defaultSrc: ["'self'"],
            reportTo: 'endpoint-1',
          },
        })
      )

      app.use(
        '/test2',
        secureHeaders({
          reportTo: [
            {
              group: 'endpoint-1',
              max_age: 10886400,
              endpoints: [{ url: 'https://example.com/reports' }],
            },
          ],
          [cspSettingName]: {
            defaultSrc: ["'self'"],
            reportTo: 'endpoint-1',
          },
        })
      )

      app.use(
        '/test3',
        secureHeaders({
          reportTo: [
            {
              group: 'g1',
              max_age: 10886400,
              endpoints: [
                { url: 'https://a.example.com/reports' },
                { url: 'https://b.example.com/reports' },
              ],
            },
            {
              group: 'g2',
              max_age: 10886400,
              endpoints: [
                { url: 'https://c.example.com/reports' },
                { url: 'https://d.example.com/reports' },
              ],
            },
          ],
          [cspSettingName]: {
            defaultSrc: ["'self'"],
            reportTo: 'g2',
          },
        })
      )

      app.use(
        '/test4',
        secureHeaders({
          reportingEndpoints: [
            {
              name: 'e1',
              url: 'https://a.example.com/reports',
            },
            {
              name: 'e2',
              url: 'https://b.example.com/reports',
            },
          ],
          [cspSettingName]: {
            defaultSrc: ["'self'"],
            reportTo: 'e1',
          },
        })
      )

      app.all('*', async (c) => {
        return c.text('header updated')
      })

      const res1 = await app.request('/test1')
      expect(res1.headers.get('Reporting-Endpoints')).toEqual(
        'endpoint-1="https://example.com/reports"'
      )
      expect(res1.headers.get(cspHeaderName)).toEqual("default-src 'self'; report-to endpoint-1")

      const res2 = await app.request('/test2')
      expect(res2.headers.get('Report-To')).toEqual(
        '{"group":"endpoint-1","max_age":10886400,"endpoints":[{"url":"https://example.com/reports"}]}'
      )
      expect(res2.headers.get(cspHeaderName)).toEqual("default-src 'self'; report-to endpoint-1")

      const res3 = await app.request('/test3')
      expect(res3.headers.get('Report-To')).toEqual(
        '{"group":"g1","max_age":10886400,"endpoints":[{"url":"https://a.example.com/reports"},{"url":"https://b.example.com/reports"}]}, {"group":"g2","max_age":10886400,"endpoints":[{"url":"https://c.example.com/reports"},{"url":"https://d.example.com/reports"}]}'
      )
      expect(res3.headers.get(cspHeaderName)).toEqual("default-src 'self'; report-to g2")

      const res4 = await app.request('/test4')
      expect(res4.headers.get('Reporting-Endpoints')).toEqual(
        'e1="https://a.example.com/reports", e2="https://b.example.com/reports"'
      )
      expect(res4.headers.get(cspHeaderName)).toEqual("default-src 'self'; report-to e1")
    })

    it('CSP nonce for script-src', async () => {
      const app = new Hono()
      app.use(
        '/test',
        secureHeaders({
          [cspSettingName]: {
            scriptSrc: ["'self'", NONCE],
          },
        })
      )

      app.all('*', async (c) => {
        return c.text(`nonce: ${c.get('secureHeadersNonce')}`)
      })

      const res = await app.request('/test')
      const csp = res.headers.get(cspHeaderName)
      const nonce = csp?.match(/script-src 'self' 'nonce-([a-zA-Z0-9+/]+=*)'/)?.[1] || ''
      expect(csp).toMatch(`script-src 'self' 'nonce-${nonce}'`)
      expect(await res.text()).toEqual(`nonce: ${nonce}`)
    })

    it('CSP nonce for script-src and style-src', async () => {
      const app = new Hono()
      app.use(
        '/test',
        secureHeaders({
          [cspSettingName]: {
            scriptSrc: ["'self'", NONCE],
            styleSrc: ["'self'", NONCE],
          },
        })
      )

      app.all('*', async (c) => {
        return c.text(`nonce: ${c.get('secureHeadersNonce')}`)
      })

      const res = await app.request('/test')
      const csp = res.headers.get(cspHeaderName)
      const nonce = csp?.match(/script-src 'self' 'nonce-([a-zA-Z0-9+/]+=*)'/)?.[1] || ''
      expect(csp).toMatch(`script-src 'self' 'nonce-${nonce}'`)
      expect(csp).toMatch(`style-src 'self' 'nonce-${nonce}'`)
      expect(await res.text()).toEqual(`nonce: ${nonce}`)
    })

    it('CSP nonce by app own function', async () => {
      const app = new Hono()
      const setNonce: ContentSecurityPolicyOptionHandler = (ctx, directive) => {
        ctx.set(`test-${directive}-nonce`, directive)
        return `'nonce-${directive}'`
      }
      app.use(
        '/test',
        secureHeaders({
          [cspSettingName]: {
            scriptSrc: ["'self'", setNonce],
            styleSrc: ["'self'", setNonce],
          },
        })
      )

      app.all('*', async (c) => {
        return c.text(
          `script: ${c.get('test-scriptSrc-nonce')}, style: ${c.get('test-styleSrc-nonce')}`
        )
      })

      const res = await app.request('/test')
      const csp = res.headers.get(cspHeaderName)
      expect(csp).toMatch(`script-src 'self' 'nonce-scriptSrc'`)
      expect(csp).toMatch(`style-src 'self' 'nonce-styleSrc'`)
      expect(await res.text()).toEqual('script: scriptSrc, style: styleSrc')
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/secure-headers/index.ts
```typescript
export type { ContentSecurityPolicyOptionHandler } from './secure-headers'
export { NONCE, secureHeaders } from './secure-headers'
import type { SecureHeadersVariables } from './secure-headers'
export type { SecureHeadersVariables }

declare module '../..' {
  interface ContextVariableMap extends SecureHeadersVariables {}
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/secure-headers/permissions-policy.ts
```typescript
// https://github.com/w3c/webappsec-permissions-policy/blob/main/features.md

export type PermissionsPolicyDirective =
  | StandardizedFeatures
  | ProposedFeatures
  | ExperimentalFeatures

/**
 * These features have been declared in a published version of the respective specification.
 */
type StandardizedFeatures =
  | 'accelerometer'
  | 'ambientLightSensor'
  | 'attributionReporting'
  | 'autoplay'
  | 'battery'
  | 'bluetooth'
  | 'camera'
  | 'chUa'
  | 'chUaArch'
  | 'chUaBitness'
  | 'chUaFullVersion'
  | 'chUaFullVersionList'
  | 'chUaMobile'
  | 'chUaModel'
  | 'chUaPlatform'
  | 'chUaPlatformVersion'
  | 'chUaWow64'
  | 'computePressure'
  | 'crossOriginIsolated'
  | 'directSockets'
  | 'displayCapture'
  | 'encryptedMedia'
  | 'executionWhileNotRendered'
  | 'executionWhileOutOfViewport'
  | 'fullscreen'
  | 'geolocation'
  | 'gyroscope'
  | 'hid'
  | 'identityCredentialsGet'
  | 'idleDetection'
  | 'keyboardMap'
  | 'magnetometer'
  | 'microphone'
  | 'midi'
  | 'navigationOverride'
  | 'payment'
  | 'pictureInPicture'
  | 'publickeyCredentialsGet'
  | 'screenWakeLock'
  | 'serial'
  | 'storageAccess'
  | 'syncXhr'
  | 'usb'
  | 'webShare'
  | 'windowManagement'
  | 'xrSpatialTracking'

/**
 * These features have been proposed, but the definitions have not yet been integrated into their respective specs.
 */
type ProposedFeatures =
  | 'clipboardRead'
  | 'clipboardWrite'
  | 'gemepad'
  | 'sharedAutofill'
  | 'speakerSelection'

/**
 * These features generally have an explainer only, but may be available for experimentation by web developers.
 */
type ExperimentalFeatures =
  | 'allScreensCapture'
  | 'browsingTopics'
  | 'capturedSurfaceControl'
  | 'conversionMeasurement'
  | 'digitalCredentialsGet'
  | 'focusWithoutUserActivation'
  | 'joinAdInterestGroup'
  | 'localFonts'
  | 'runAdAuction'
  | 'smartCard'
  | 'syncScript'
  | 'trustTokenRedemption'
  | 'unload'
  | 'verticalScroll'

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/secure-headers/secure-headers.ts
````typescript
/**
 * @module
 * Secure Headers Middleware for Hono.
 */

import type { Context } from '../../context'
import type { MiddlewareHandler } from '../../types'
import { encodeBase64 } from '../../utils/encode'
import type { PermissionsPolicyDirective } from './permissions-policy'

export type SecureHeadersVariables = {
  secureHeadersNonce?: string
}

export type ContentSecurityPolicyOptionHandler = (ctx: Context, directive: string) => string
type ContentSecurityPolicyOptionValue = (string | ContentSecurityPolicyOptionHandler)[]

interface ContentSecurityPolicyOptions {
  defaultSrc?: ContentSecurityPolicyOptionValue
  baseUri?: ContentSecurityPolicyOptionValue
  childSrc?: ContentSecurityPolicyOptionValue
  connectSrc?: ContentSecurityPolicyOptionValue
  fontSrc?: ContentSecurityPolicyOptionValue
  formAction?: ContentSecurityPolicyOptionValue
  frameAncestors?: ContentSecurityPolicyOptionValue
  frameSrc?: ContentSecurityPolicyOptionValue
  imgSrc?: ContentSecurityPolicyOptionValue
  manifestSrc?: ContentSecurityPolicyOptionValue
  mediaSrc?: ContentSecurityPolicyOptionValue
  objectSrc?: ContentSecurityPolicyOptionValue
  reportTo?: string
  sandbox?: ContentSecurityPolicyOptionValue
  scriptSrc?: ContentSecurityPolicyOptionValue
  scriptSrcAttr?: ContentSecurityPolicyOptionValue
  scriptSrcElem?: ContentSecurityPolicyOptionValue
  styleSrc?: ContentSecurityPolicyOptionValue
  styleSrcAttr?: ContentSecurityPolicyOptionValue
  styleSrcElem?: ContentSecurityPolicyOptionValue
  upgradeInsecureRequests?: ContentSecurityPolicyOptionValue
  workerSrc?: ContentSecurityPolicyOptionValue
}

interface ReportToOptions {
  group: string
  max_age: number
  endpoints: ReportToEndpoint[]
}

interface ReportToEndpoint {
  url: string
}

interface ReportingEndpointOptions {
  name: string
  url: string
}

type PermissionsPolicyValue = '*' | 'self' | 'src' | 'none' | string

type PermissionsPolicyOptions = Partial<
  Record<PermissionsPolicyDirective, PermissionsPolicyValue[] | boolean>
>

type overridableHeader = boolean | string

interface SecureHeadersOptions {
  contentSecurityPolicy?: ContentSecurityPolicyOptions
  contentSecurityPolicyReportOnly?: ContentSecurityPolicyOptions
  crossOriginEmbedderPolicy?: overridableHeader
  crossOriginResourcePolicy?: overridableHeader
  crossOriginOpenerPolicy?: overridableHeader
  originAgentCluster?: overridableHeader
  referrerPolicy?: overridableHeader
  reportingEndpoints?: ReportingEndpointOptions[]
  reportTo?: ReportToOptions[]
  strictTransportSecurity?: overridableHeader
  xContentTypeOptions?: overridableHeader
  xDnsPrefetchControl?: overridableHeader
  xDownloadOptions?: overridableHeader
  xFrameOptions?: overridableHeader
  xPermittedCrossDomainPolicies?: overridableHeader
  xXssProtection?: overridableHeader
  removePoweredBy?: boolean
  permissionsPolicy?: PermissionsPolicyOptions
}

type HeadersMap = {
  [key in keyof SecureHeadersOptions]: [string, string]
}

const HEADERS_MAP: HeadersMap = {
  crossOriginEmbedderPolicy: ['Cross-Origin-Embedder-Policy', 'require-corp'],
  crossOriginResourcePolicy: ['Cross-Origin-Resource-Policy', 'same-origin'],
  crossOriginOpenerPolicy: ['Cross-Origin-Opener-Policy', 'same-origin'],
  originAgentCluster: ['Origin-Agent-Cluster', '?1'],
  referrerPolicy: ['Referrer-Policy', 'no-referrer'],
  strictTransportSecurity: ['Strict-Transport-Security', 'max-age=15552000; includeSubDomains'],
  xContentTypeOptions: ['X-Content-Type-Options', 'nosniff'],
  xDnsPrefetchControl: ['X-DNS-Prefetch-Control', 'off'],
  xDownloadOptions: ['X-Download-Options', 'noopen'],
  xFrameOptions: ['X-Frame-Options', 'SAMEORIGIN'],
  xPermittedCrossDomainPolicies: ['X-Permitted-Cross-Domain-Policies', 'none'],
  xXssProtection: ['X-XSS-Protection', '0'],
}

const DEFAULT_OPTIONS: SecureHeadersOptions = {
  crossOriginEmbedderPolicy: false,
  crossOriginResourcePolicy: true,
  crossOriginOpenerPolicy: true,
  originAgentCluster: true,
  referrerPolicy: true,
  strictTransportSecurity: true,
  xContentTypeOptions: true,
  xDnsPrefetchControl: true,
  xDownloadOptions: true,
  xFrameOptions: true,
  xPermittedCrossDomainPolicies: true,
  xXssProtection: true,
  removePoweredBy: true,
  permissionsPolicy: {},
}

type SecureHeadersCallback = (
  ctx: Context,
  headersToSet: [string, string | string[]][]
) => [string, string][]

const generateNonce = () => {
  const arrayBuffer = new Uint8Array(16)
  crypto.getRandomValues(arrayBuffer)
  return encodeBase64(arrayBuffer.buffer)
}

export const NONCE: ContentSecurityPolicyOptionHandler = (ctx) => {
  const key = 'secureHeadersNonce'
  const init = ctx.get(key)
  const nonce = init || generateNonce()
  if (init == null) {
    ctx.set(key, nonce)
  }
  return `'nonce-${nonce}'`
}

/**
 * Secure Headers Middleware for Hono.
 *
 * @see {@link https://hono.dev/docs/middleware/builtin/secure-headers}
 *
 * @param {Partial<SecureHeadersOptions>} [customOptions] - The options for the secure headers middleware.
 * @param {ContentSecurityPolicyOptions} [customOptions.contentSecurityPolicy] - Settings for the Content-Security-Policy header.
 * @param {ContentSecurityPolicyOptions} [customOptions.contentSecurityPolicyReportOnly] - Settings for the Content-Security-Policy-Report-Only header.
 * @param {overridableHeader} [customOptions.crossOriginEmbedderPolicy=false] - Settings for the Cross-Origin-Embedder-Policy header.
 * @param {overridableHeader} [customOptions.crossOriginResourcePolicy=true] - Settings for the Cross-Origin-Resource-Policy header.
 * @param {overridableHeader} [customOptions.crossOriginOpenerPolicy=true] - Settings for the Cross-Origin-Opener-Policy header.
 * @param {overridableHeader} [customOptions.originAgentCluster=true] - Settings for the Origin-Agent-Cluster header.
 * @param {overridableHeader} [customOptions.referrerPolicy=true] - Settings for the Referrer-Policy header.
 * @param {ReportingEndpointOptions[]} [customOptions.reportingEndpoints] - Settings for the Reporting-Endpoints header.
 * @param {ReportToOptions[]} [customOptions.reportTo] - Settings for the Report-To header.
 * @param {overridableHeader} [customOptions.strictTransportSecurity=true] - Settings for the Strict-Transport-Security header.
 * @param {overridableHeader} [customOptions.xContentTypeOptions=true] - Settings for the X-Content-Type-Options header.
 * @param {overridableHeader} [customOptions.xDnsPrefetchControl=true] - Settings for the X-DNS-Prefetch-Control header.
 * @param {overridableHeader} [customOptions.xDownloadOptions=true] - Settings for the X-Download-Options header.
 * @param {overridableHeader} [customOptions.xFrameOptions=true] - Settings for the X-Frame-Options header.
 * @param {overridableHeader} [customOptions.xPermittedCrossDomainPolicies=true] - Settings for the X-Permitted-Cross-Domain-Policies header.
 * @param {overridableHeader} [customOptions.xXssProtection=true] - Settings for the X-XSS-Protection header.
 * @param {boolean} [customOptions.removePoweredBy=true] - Settings for remove X-Powered-By header.
 * @param {PermissionsPolicyOptions} [customOptions.permissionsPolicy] - Settings for the Permissions-Policy header.
 * @returns {MiddlewareHandler} The middleware handler function.
 *
 * @example
 * ```ts
 * const app = new Hono()
 * app.use(secureHeaders())
 * ```
 */
export const secureHeaders = (customOptions?: SecureHeadersOptions): MiddlewareHandler => {
  const options = { ...DEFAULT_OPTIONS, ...customOptions }
  const headersToSet = getFilteredHeaders(options)
  const callbacks: SecureHeadersCallback[] = []

  if (options.contentSecurityPolicy) {
    const [callback, value] = getCSPDirectives(options.contentSecurityPolicy)
    if (callback) {
      callbacks.push(callback)
    }
    headersToSet.push(['Content-Security-Policy', value as string])
  }

  if (options.contentSecurityPolicyReportOnly) {
    const [callback, value] = getCSPDirectives(options.contentSecurityPolicyReportOnly)
    if (callback) {
      callbacks.push(callback)
    }
    headersToSet.push(['Content-Security-Policy-Report-Only', value as string])
  }

  if (options.permissionsPolicy && Object.keys(options.permissionsPolicy).length > 0) {
    headersToSet.push([
      'Permissions-Policy',
      getPermissionsPolicyDirectives(options.permissionsPolicy),
    ])
  }

  if (options.reportingEndpoints) {
    headersToSet.push(['Reporting-Endpoints', getReportingEndpoints(options.reportingEndpoints)])
  }

  if (options.reportTo) {
    headersToSet.push(['Report-To', getReportToOptions(options.reportTo)])
  }

  return async function secureHeaders(ctx, next) {
    // should evaluate callbacks before next()
    // some callback calls ctx.set() for embedding nonce to the page
    const headersToSetForReq =
      callbacks.length === 0
        ? headersToSet
        : callbacks.reduce((acc, cb) => cb(ctx, acc), headersToSet)
    await next()
    setHeaders(ctx, headersToSetForReq)

    if (options?.removePoweredBy) {
      ctx.res.headers.delete('X-Powered-By')
    }
  }
}

function getFilteredHeaders(options: SecureHeadersOptions): [string, string][] {
  return Object.entries(HEADERS_MAP)
    .filter(([key]) => options[key as keyof SecureHeadersOptions])
    .map(([key, defaultValue]) => {
      const overrideValue = options[key as keyof SecureHeadersOptions]
      return typeof overrideValue === 'string' ? [defaultValue[0], overrideValue] : defaultValue
    })
}

function getCSPDirectives(
  contentSecurityPolicy: ContentSecurityPolicyOptions
): [SecureHeadersCallback | undefined, string | string[]] {
  const callbacks: ((ctx: Context, values: string[]) => void)[] = []
  const resultValues: string[] = []

  for (const [directive, value] of Object.entries(contentSecurityPolicy)) {
    const valueArray = Array.isArray(value) ? value : [value]

    valueArray.forEach((value, i) => {
      if (typeof value === 'function') {
        const index = i * 2 + 2 + resultValues.length
        callbacks.push((ctx, values) => {
          values[index] = value(ctx, directive)
        })
      }
    })

    resultValues.push(
      directive.replace(/[A-Z]+(?![a-z])|[A-Z]/g, (match, offset) =>
        offset ? '-' + match.toLowerCase() : match.toLowerCase()
      ),
      ...valueArray.flatMap((value) => [' ', value]),
      '; '
    )
  }
  resultValues.pop()

  return callbacks.length === 0
    ? [undefined, resultValues.join('')]
    : [
        (ctx, headersToSet) =>
          headersToSet.map((values) => {
            if (
              values[0] === 'Content-Security-Policy' ||
              values[0] === 'Content-Security-Policy-Report-Only'
            ) {
              const clone = values[1].slice() as unknown as string[]
              callbacks.forEach((cb) => {
                cb(ctx, clone)
              })
              return [values[0], clone.join('')]
            } else {
              return values as [string, string]
            }
          }),
        resultValues,
      ]
}

function getPermissionsPolicyDirectives(policy: PermissionsPolicyOptions): string {
  return Object.entries(policy)
    .map(([directive, value]) => {
      const kebabDirective = camelToKebab(directive)

      if (typeof value === 'boolean') {
        return `${kebabDirective}=${value ? '*' : 'none'}`
      }

      if (Array.isArray(value)) {
        if (value.length === 0) {
          return `${kebabDirective}=()`
        }
        if (value.length === 1 && (value[0] === '*' || value[0] === 'none')) {
          return `${kebabDirective}=${value[0]}`
        }
        const allowlist = value.map((item) => (['self', 'src'].includes(item) ? item : `"${item}"`))
        return `${kebabDirective}=(${allowlist.join(' ')})`
      }

      return ''
    })
    .filter(Boolean)
    .join(', ')
}

function camelToKebab(str: string): string {
  return str.replace(/([a-z\d])([A-Z])/g, '$1-$2').toLowerCase()
}

function getReportingEndpoints(
  reportingEndpoints: SecureHeadersOptions['reportingEndpoints'] = []
): string {
  return reportingEndpoints.map((endpoint) => `${endpoint.name}="${endpoint.url}"`).join(', ')
}

function getReportToOptions(reportTo: SecureHeadersOptions['reportTo'] = []): string {
  return reportTo.map((option) => JSON.stringify(option)).join(', ')
}

function setHeaders(ctx: Context, headersToSet: [string, string][]) {
  headersToSet.forEach(([header, value]) => {
    ctx.res.headers.set(header, value)
  })
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/basic-auth/index.test.ts
```typescript
import { createHash } from 'crypto'
import { Hono } from '../../hono'
import { basicAuth } from '.'

describe('Basic Auth by Middleware', () => {
  let handlerExecuted: boolean

  beforeEach(() => {
    handlerExecuted = false
  })

  const app = new Hono()

  const username = 'hono-user-a'
  const password = 'hono-password-a'
  const unicodePassword = '炎'

  const usernameB = 'hono-user-b'
  const passwordB = 'hono-password-b'

  const usernameC = 'hono-user-c'
  const passwordC = 'hono-password-c'

  app.use(
    '/auth/*',
    basicAuth({
      username,
      password,
    })
  )
  // Test multiple handlers
  app.use('/auth/*', async (c, next) => {
    c.header('x-custom', 'foo')
    await next()
  })

  app.use(
    '/auth-unicode/*',
    basicAuth({
      username: username,
      password: unicodePassword,
    })
  )

  app.use(
    '/auth-multi/*',
    basicAuth(
      {
        username: usernameB,
        password: passwordB,
      },
      {
        username: usernameC,
        password: passwordC,
      }
    )
  )

  app.use(
    '/auth-override-func/*',
    basicAuth({
      username: username,
      password: password,
      hashFunction: (data: string) => createHash('sha256').update(data).digest('hex'),
    })
  )

  app.use('/nested/*', async (c, next) => {
    const auth = basicAuth({ username: username, password: password })
    return auth(c, next)
  })

  app.use('/verify-user/*', async (c, next) => {
    const auth = basicAuth({
      verifyUser: (username, password, c) => {
        return (
          c.req.path === '/verify-user' &&
          username === 'dynamic-user' &&
          password === 'hono-password'
        )
      },
    })
    return auth(c, next)
  })

  app.use(
    '/auth-custom-invalid-user-message-string/*',
    basicAuth({
      username,
      password,
      invalidUserMessage: 'Custom unauthorized message as string',
    })
  )

  app.use(
    '/auth-custom-invalid-user-message-object/*',
    basicAuth({
      username,
      password,
      invalidUserMessage: { message: 'Custom unauthorized message as object' },
    })
  )

  app.use(
    '/auth-custom-invalid-user-message-function-string/*',
    basicAuth({
      username,
      password,
      invalidUserMessage: () => 'Custom unauthorized message as function string',
    })
  )

  app.use(
    '/auth-custom-invalid-user-message-function-object/*',
    basicAuth({
      username,
      password,
      invalidUserMessage: () => ({ message: 'Custom unauthorized message as function object' }),
    })
  )

  app.get('/auth/*', (c) => {
    handlerExecuted = true
    return c.text('auth')
  })
  app.get('/auth-unicode/*', (c) => {
    handlerExecuted = true
    return c.text('auth')
  })
  app.get('/auth-multi/*', (c) => {
    handlerExecuted = true
    return c.text('auth')
  })
  app.get('/auth-override-func/*', (c) => {
    handlerExecuted = true
    return c.text('auth')
  })

  app.get('/nested/*', (c) => {
    handlerExecuted = true
    return c.text('nested')
  })

  app.get('/verify-user', (c) => {
    handlerExecuted = true
    return c.text('verify-user')
  })

  app.get('/auth-custom-invalid-user-message-string/*', (c) => {
    handlerExecuted = true
    return c.text('auth')
  })
  app.get('/auth-custom-invalid-user-message-object/*', (c) => {
    handlerExecuted = true
    return c.text('auth')
  })
  app.get('/auth-custom-invalid-user-message-function-string/*', (c) => {
    handlerExecuted = true
    return c.text('auth')
  })

  app.get('/auth-custom-invalid-user-message-function-object/*', (c) => {
    handlerExecuted = true
    return c.text('auth')
  })

  it('Should not authorize', async () => {
    const req = new Request('http://localhost/auth/a')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(401)
    expect(handlerExecuted).toBeFalsy()
    expect(await res.text()).toBe('Unauthorized')
    expect(res.headers.get('x-custom')).toBeNull()
  })

  it('Should authorize', async () => {
    const credential = Buffer.from(username + ':' + password).toString('base64')

    const req = new Request('http://localhost/auth/a')
    req.headers.set('Authorization', `Basic ${credential}`)
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(handlerExecuted).toBeTruthy()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('auth')
    expect(res.headers.get('x-custom')).toBe('foo')
  })

  it('Should authorize Unicode', async () => {
    const credential = Buffer.from(username + ':' + unicodePassword).toString('base64')

    const req = new Request('http://localhost/auth-unicode/a')
    req.headers.set('Authorization', `Basic ${credential}`)
    const res = await app.request(req)
    expect(handlerExecuted).toBeTruthy()
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('auth')
  })

  it('Should authorize multiple users', async () => {
    let credential = Buffer.from(usernameB + ':' + passwordB).toString('base64')

    let req = new Request('http://localhost/auth-multi/b')
    req.headers.set('Authorization', `Basic ${credential}`)
    let res = await app.request(req)
    expect(handlerExecuted).toBeTruthy()
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('auth')

    handlerExecuted = false
    credential = Buffer.from(usernameC + ':' + passwordC).toString('base64')
    req = new Request('http://localhost/auth-multi/c')
    req.headers.set('Authorization', `Basic ${credential}`)
    res = await app.request(req)
    expect(handlerExecuted).toBeTruthy()
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('auth')
  })

  it('Should authorize with sha256 function override', async () => {
    const credential = Buffer.from(username + ':' + password).toString('base64')

    const req = new Request('http://localhost/auth-override-func/a')
    req.headers.set('Authorization', `Basic ${credential}`)
    const res = await app.request(req)
    expect(handlerExecuted).toBeTruthy()
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('auth')
  })

  it('Should authorize - nested', async () => {
    const credential = Buffer.from(username + ':' + password).toString('base64')

    const req = new Request('http://localhost/nested')
    req.headers.set('Authorization', `Basic ${credential}`)
    const res = await app.request(req)
    expect(handlerExecuted).toBeTruthy()
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('nested')
  })

  it('Should not authorize - nested', async () => {
    const credential = Buffer.from('foo' + ':' + 'bar').toString('base64')

    const req = new Request('http://localhost/nested')
    req.headers.set('Authorization', `Basic ${credential}`)
    const res = await app.request(req)
    expect(handlerExecuted).toBeFalsy()
    expect(res).not.toBeNull()
    expect(res.status).toBe(401)
    expect(await res.text()).toBe('Unauthorized')
  })

  it('Should authorize - verifyUser', async () => {
    const credential = Buffer.from('dynamic-user' + ':' + 'hono-password').toString('base64')

    const req = new Request('http://localhost/verify-user')
    req.headers.set('Authorization', `Basic ${credential}`)
    const res = await app.request(req)
    expect(handlerExecuted).toBeTruthy()
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('verify-user')
  })

  it('Should not authorize - verifyUser', async () => {
    const credential = Buffer.from('foo' + ':' + 'bar').toString('base64')

    const req = new Request('http://localhost/verify-user')
    req.headers.set('Authorization', `Basic ${credential}`)
    const res = await app.request(req)
    expect(handlerExecuted).toBeFalsy()
    expect(res).not.toBeNull()
    expect(res.status).toBe(401)
    expect(await res.text()).toBe('Unauthorized')
  })

  it('Should not authorize - custom invalid user message as string', async () => {
    const req = new Request('http://localhost/auth-custom-invalid-user-message-string')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(401)
    expect(handlerExecuted).toBeFalsy()
    expect(await res.text()).toBe('Custom unauthorized message as string')
  })

  it('Should not authorize - custom invalid user message as object', async () => {
    const req = new Request('http://localhost/auth-custom-invalid-user-message-object')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(401)
    expect(res.headers.get('Content-Type')).toMatch('application/json')
    expect(handlerExecuted).toBeFalsy()
    expect(await res.text()).toBe('{"message":"Custom unauthorized message as object"}')
  })

  it('Should not authorize - custom invalid user message as function string', async () => {
    const req = new Request('http://localhost/auth-custom-invalid-user-message-function-string')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(401)
    expect(handlerExecuted).toBeFalsy()
    expect(await res.text()).toBe('Custom unauthorized message as function string')
  })

  it('Should not authorize - custom invalid user message as function object', async () => {
    const req = new Request('http://localhost/auth-custom-invalid-user-message-function-object')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(401)
    expect(res.headers.get('Content-Type')).toMatch('application/json')
    expect(handlerExecuted).toBeFalsy()
    expect(await res.text()).toBe('{"message":"Custom unauthorized message as function object"}')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/basic-auth/index.ts
````typescript
/**
 * @module
 * Basic Auth Middleware for Hono.
 */

import type { Context } from '../../context'
import { HTTPException } from '../../http-exception'
import type { MiddlewareHandler } from '../../types'
import { auth } from '../../utils/basic-auth'
import { timingSafeEqual } from '../../utils/buffer'

type MessageFunction = (c: Context) => string | object | Promise<string | object>

type BasicAuthOptions =
  | {
      username: string
      password: string
      realm?: string
      hashFunction?: Function
      invalidUserMessage?: string | object | MessageFunction
    }
  | {
      verifyUser: (username: string, password: string, c: Context) => boolean | Promise<boolean>
      realm?: string
      hashFunction?: Function
      invalidUserMessage?: string | object | MessageFunction
    }

/**
 * Basic Auth Middleware for Hono.
 *
 * @see {@link https://hono.dev/docs/middleware/builtin/basic-auth}
 *
 * @param {BasicAuthOptions} options - The options for the basic authentication middleware.
 * @param {string} options.username - The username for authentication.
 * @param {string} options.password - The password for authentication.
 * @param {string} [options.realm="Secure Area"] - The realm attribute for the WWW-Authenticate header.
 * @param {Function} [options.hashFunction] - The hash function used for secure comparison.
 * @param {Function} [options.verifyUser] - The function to verify user credentials.
 * @param {string | object | MessageFunction} [options.invalidUserMessage="Unauthorized"] - The invalid user message.
 * @returns {MiddlewareHandler} The middleware handler function.
 * @throws {HTTPException} If neither "username and password" nor "verifyUser" options are provided.
 *
 * @example
 * ```ts
 * const app = new Hono()
 *
 * app.use(
 *   '/auth/*',
 *   basicAuth({
 *     username: 'hono',
 *     password: 'ahotproject',
 *   })
 * )
 *
 * app.get('/auth/page', (c) => {
 *   return c.text('You are authorized')
 * })
 * ```
 */
export const basicAuth = (
  options: BasicAuthOptions,
  ...users: { username: string; password: string }[]
): MiddlewareHandler => {
  const usernamePasswordInOptions = 'username' in options && 'password' in options
  const verifyUserInOptions = 'verifyUser' in options

  if (!(usernamePasswordInOptions || verifyUserInOptions)) {
    throw new Error(
      'basic auth middleware requires options for "username and password" or "verifyUser"'
    )
  }

  if (!options.realm) {
    options.realm = 'Secure Area'
  }

  if (!options.invalidUserMessage) {
    options.invalidUserMessage = 'Unauthorized'
  }

  if (usernamePasswordInOptions) {
    users.unshift({ username: options.username, password: options.password })
  }

  return async function basicAuth(ctx, next) {
    const requestUser = auth(ctx.req.raw)
    if (requestUser) {
      if (verifyUserInOptions) {
        if (await options.verifyUser(requestUser.username, requestUser.password, ctx)) {
          await next()
          return
        }
      } else {
        for (const user of users) {
          const [usernameEqual, passwordEqual] = await Promise.all([
            timingSafeEqual(user.username, requestUser.username, options.hashFunction),
            timingSafeEqual(user.password, requestUser.password, options.hashFunction),
          ])
          if (usernameEqual && passwordEqual) {
            await next()
            return
          }
        }
      }
    }
    // Invalid user.
    const status = 401
    const headers = {
      'WWW-Authenticate': 'Basic realm="' + options.realm?.replace(/"/g, '\\"') + '"',
    }
    const responseMessage =
      typeof options.invalidUserMessage === 'function'
        ? await options.invalidUserMessage(ctx)
        : options.invalidUserMessage
    const res =
      typeof responseMessage === 'string'
        ? new Response(responseMessage, { status, headers })
        : new Response(JSON.stringify(responseMessage), {
            status,
            headers: {
              ...headers,
              'content-type': 'application/json',
            },
          })
    throw new HTTPException(status, { res })
  }
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/timeout/index.test.ts
```typescript
import type { Context } from '../../context'
import { Hono } from '../../hono'
import { HTTPException } from '../../http-exception'
import type { HTTPExceptionFunction } from '.'
import { timeout } from '.'

describe('Timeout API', () => {
  const app = new Hono()

  app.use('/slow-endpoint', timeout(1000))
  app.use(
    '/slow-endpoint/custom',
    timeout(
      1100,
      () => new HTTPException(408, { message: 'Request timeout. Please try again later.' })
    )
  )
  const exception500: HTTPExceptionFunction = (context: Context) =>
    new HTTPException(500, { message: `Internal Server Error at ${context.req.path}` })
  app.use('/slow-endpoint/error', timeout(1200, exception500))
  app.use('/normal-endpoint', timeout(1000))

  app.get('/slow-endpoint', async (c) => {
    await new Promise((resolve) => setTimeout(resolve, 1100))
    return c.text('This should not show up')
  })

  app.get('/slow-endpoint/custom', async (c) => {
    await new Promise((resolve) => setTimeout(resolve, 1200))
    return c.text('This should not show up')
  })

  app.get('/slow-endpoint/error', async (c) => {
    await new Promise((resolve) => setTimeout(resolve, 1300))
    return c.text('This should not show up')
  })

  app.get('/normal-endpoint', async (c) => {
    await new Promise((resolve) => setTimeout(resolve, 900))
    return c.text('This should not show up')
  })

  it('Should trigger default timeout exception', async () => {
    const res = await app.request('http://localhost/slow-endpoint')
    expect(res).not.toBeNull()
    expect(res.status).toBe(504)
    expect(await res.text()).toContain('Gateway Timeout')
  })

  it('Should apply custom exception with function', async () => {
    const res = await app.request('http://localhost/slow-endpoint/custom')
    expect(res).not.toBeNull()
    expect(res.status).toBe(408)
    expect(await res.text()).toContain('Request timeout. Please try again later.')
  })

  it('Error timeout with custom status code and message', async () => {
    const res = await app.request('http://localhost/slow-endpoint/error')
    expect(res).not.toBeNull()
    expect(res.status).toBe(500)
    expect(await res.text()).toContain('Internal Server Error at /slow-endpoint/error')
  })

  it('No Timeout should pass', async () => {
    const res = await app.request('http://localhost/normal-endpoint')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toContain('This should not show up')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/timeout/index.ts
````typescript
/**
 * @module
 * Timeout Middleware for Hono.
 */

import type { Context } from '../../context'
import { HTTPException } from '../../http-exception'
import type { MiddlewareHandler } from '../../types'

export type HTTPExceptionFunction = (context: Context) => HTTPException

const defaultTimeoutException = new HTTPException(504, {
  message: 'Gateway Timeout',
})

/**
 * Timeout Middleware for Hono.
 *
 * @param {number} duration - The timeout duration in milliseconds.
 * @param {HTTPExceptionFunction | HTTPException} [exception=defaultTimeoutException] - The exception to throw when the timeout occurs. Can be a function that returns an HTTPException or an HTTPException object.
 * @returns {MiddlewareHandler} The middleware handler function.
 *
 * @example
 * ```ts
 * const app = new Hono()
 *
 * app.use(
 *   '/long-request',
 *   timeout(5000) // Set timeout to 5 seconds
 * )
 *
 * app.get('/long-request', async (c) => {
 *   await someLongRunningFunction()
 *   return c.text('Completed within time limit')
 * })
 * ```
 */
export const timeout = (
  duration: number,
  exception: HTTPExceptionFunction | HTTPException = defaultTimeoutException
): MiddlewareHandler => {
  return async function timeout(context, next) {
    let timer: number | undefined
    const timeoutPromise = new Promise<void>((_, reject) => {
      timer = setTimeout(() => {
        reject(typeof exception === 'function' ? exception(context) : exception)
      }, duration) as unknown as number
    })

    try {
      await Promise.race([next(), timeoutPromise])
    } finally {
      if (timer !== undefined) {
        clearTimeout(timer)
      }
    }
  }
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/powered-by/index.test.ts
```typescript
import { Hono } from '../../hono'
import { poweredBy } from '.'

describe('Powered by Middleware', () => {
  const app = new Hono()

  app.use('/poweredBy/*', poweredBy())
  app.get('/poweredBy', (c) => c.text('root'))

  app.use('/poweredBy2/*', poweredBy())
  app.use('/poweredBy2/*', poweredBy())
  app.get('/poweredBy2', (c) => c.text('root'))

  app.use('/poweredBy3/*', poweredBy({ serverName: 'Foo' }))
  app.get('/poweredBy3', (c) => c.text('root'))

  it('Should return with X-Powered-By header', async () => {
    const res = await app.request('http://localhost/poweredBy')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('X-Powered-By')).toBe('Hono')
  })

  it('Should not return duplicate values', async () => {
    const res = await app.request('http://localhost/poweredBy2')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('X-Powered-By')).toBe('Hono')
  })

  it('Should return custom serverName', async () => {
    const res = await app.request('http://localhost/poweredBy3')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('X-Powered-By')).toBe('Foo')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/powered-by/index.ts
````typescript
/**
 * @module
 * Powered By Middleware for Hono.
 */
import type { MiddlewareHandler } from '../../types'

type PoweredByOptions = {
  /**
   * The value for X-Powered-By header.
   * @default Hono
   */
  serverName?: string
}

/**
 * Powered By Middleware for Hono.
 *
 * @param options - The options for the Powered By Middleware.
 * @returns {MiddlewareHandler} The middleware handler function.
 *
 * @example
 * ```ts
 * import { poweredBy } from 'hono/powered-by'
 *
 * const app = new Hono()
 *
 * app.use(poweredBy()) // With options: poweredBy({ serverName: "My Server" })
 * ```
 */
export const poweredBy = (options?: PoweredByOptions): MiddlewareHandler => {
  return async function poweredBy(c, next) {
    await next()
    c.res.headers.set('X-Powered-By', options?.serverName ?? 'Hono')
  }
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/language/index.test.ts
```typescript
import { Hono } from '../../hono'
import { detectors } from './language'
import { languageDetector } from '.'

describe('languageDetector', () => {
  const createTestApp = (options = {}) => {
    const app = new Hono()

    app.use('/*', languageDetector(options))

    app.get('/*', (c) => c.text(c.get('language')))

    return app
  }

  describe('Query Parameter Detection', () => {
    it('should detect language from query parameter', async () => {
      const app = createTestApp({
        supportedLanguages: ['en', 'fr', 'es'],
        fallbackLanguage: 'en',
      })

      const res = await app.request('/?lang=fr')
      expect(await res.text()).toBe('fr')
    })

    it('should ignore unsupported languages in query', async () => {
      const app = createTestApp({
        supportedLanguages: ['en', 'fr'],
        fallbackLanguage: 'en',
      })

      const res = await app.request('/?lang=de')
      expect(await res.text()).toBe('en')
    })
  })

  describe('Cookie Detection', () => {
    it('should detect language from cookie', async () => {
      const app = createTestApp({
        supportedLanguages: ['en', 'fr'],
        fallbackLanguage: 'en',
      })

      const res = await app.request('/', {
        headers: {
          cookie: 'language=fr',
        },
      })
      expect(await res.text()).toBe('fr')
    })

    it('should cache detected language in cookie when enabled', async () => {
      const app = createTestApp({
        supportedLanguages: ['en', 'fr'],
        fallbackLanguage: 'en',
        caches: ['cookie'],
      })

      const res = await app.request('/?lang=fr')
      expect(res.headers.get('set-cookie')).toContain('language=fr')
    })
  })

  describe('Header Detection', () => {
    it('should detect language from Accept-Language header', async () => {
      const app = createTestApp({
        supportedLanguages: ['en', 'fr', 'es'],
        fallbackLanguage: 'en',
      })

      const res = await app.request('/', {
        headers: {
          'accept-language': 'fr-FR,fr;q=0.9,en;q=0.8',
        },
      })
      expect(await res.text()).toBe('fr')
    })

    it('should handle malformed Accept-Language headers', async () => {
      const app = createTestApp({
        supportedLanguages: ['en', 'fr'],
        fallbackLanguage: 'en',
      })

      const res = await app.request('/', {
        headers: {
          'accept-language': 'invalid;header;;format',
        },
      })
      expect(await res.text()).toBe('en')
    })
  })

  describe('Path Detection', () => {
    it('should detect language from path', async () => {
      const app = createTestApp({
        order: ['path'],
        supportedLanguages: ['en', 'fr'],
        fallbackLanguage: 'en',
        lookupFromPathIndex: 0,
      })

      const res = await app.request('/fr/page')
      expect(await res.text()).toBe('fr')
    })

    it('should handle invalid path index gracefully', async () => {
      const app = createTestApp({
        order: ['path'],
        supportedLanguages: ['en', 'fr'],
        fallbackLanguage: 'en',
        lookupFromPathIndex: 99,
      })

      const res = await app.request('/fr/page')
      expect(await res.text()).toBe('en')
    })
  })

  describe('Detection Order', () => {
    it('should respect detection order', async () => {
      const app = createTestApp({
        order: ['cookie', 'querystring'],
        supportedLanguages: ['en', 'fr', 'es'],
        fallbackLanguage: 'en',
      })

      const res = await app.request('/?lang=fr', {
        headers: {
          cookie: 'language=es',
        },
      })

      // Since cookie is first in order, it should use 'es'
      expect(await res.text()).toBe('es')
    })

    it('should fall back to next detector if first fails', async () => {
      const app = createTestApp({
        order: ['cookie', 'querystring'],
        supportedLanguages: ['en', 'fr'],
        fallbackLanguage: 'en',
      })

      const res = await app.request('/?lang=fr') // No cookie
      expect(await res.text()).toBe('fr') // Should use querystring
    })
  })

  describe('Language Conversion', () => {
    it('should apply language conversion function', async () => {
      const app = createTestApp({
        supportedLanguages: ['en', 'fr'],
        fallbackLanguage: 'en',
        convertDetectedLanguage: (lang: string) => lang.split('-')[0],
      })

      const res = await app.request('/?lang=fr-FR')
      expect(await res.text()).toBe('fr')
    })

    it('should handle case sensitivity according to options', async () => {
      const app = createTestApp({
        supportedLanguages: ['en', 'fr'],
        fallbackLanguage: 'en',
        ignoreCase: false,
      })

      const res = await app.request('/?lang=FR')
      expect(await res.text()).toBe('en') // Falls back because case doesn't match
    })
  })

  describe('Error Handling', () => {
    it('should fall back to default language on error', async () => {
      const app = createTestApp({
        supportedLanguages: ['en', 'fr'],
        fallbackLanguage: 'en',
      })

      const detector = vi.spyOn(detectors, 'querystring').mockImplementation(() => {
        throw new Error('Simulated error')
      })

      const res = await app.request('/?lang=fr')
      expect(await res.text()).toBe('en')

      detector.mockRestore()
    })

    it('should handle missing cookie values gracefully', async () => {
      const app = createTestApp({
        supportedLanguages: ['en', 'fr'],
        fallbackLanguage: 'en',
        order: ['cookie'],
      })

      const res = await app.request('/')
      expect(await res.text()).toBe('en')
    })
  })

  describe('Configuration Validation', () => {
    it('should throw if fallback language is not in supported languages', () => {
      expect(() => {
        createTestApp({
          supportedLanguages: ['fr', 'es'],
          fallbackLanguage: 'en',
        })
      }).toThrow()
    })

    it('should throw if path index is negative', () => {
      expect(() => {
        createTestApp({
          lookupFromPathIndex: -1,
        })
      }).toThrow()
    })

    it('should handle empty supported languages list', () => {
      expect(() => {
        createTestApp({
          supportedLanguages: [],
        })
      }).toThrow()
    })
  })

  describe('Debug Mode', () => {
    it('should log errors in debug mode', async () => {
      const consoleErrorSpy = vi.spyOn(console, 'error')

      const app = createTestApp({
        supportedLanguages: ['en', 'fr'],
        fallbackLanguage: 'en',
        debug: true,
      })

      const detector = vi.spyOn(detectors, 'querystring').mockImplementation(() => {
        throw new Error('Simulated error')
      })

      await app.request('/?lang=fr')

      expect(consoleErrorSpy).toHaveBeenCalledWith(
        'Error in querystring detector:',
        expect.any(Error)
      )

      detector.mockRestore()
      consoleErrorSpy.mockRestore()
    })

    // The log test remains unchanged
    it('should log debug information when enabled', async () => {
      const consoleSpy = vi.spyOn(console, 'log')

      const app = createTestApp({
        supportedLanguages: ['en', 'fr'],
        fallbackLanguage: 'en',
        debug: true,
      })

      await app.request('/?lang=fr')

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('Language detected from querystring')
      )

      consoleSpy.mockRestore()
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/language/index.ts
```typescript
import type { LanguageVariables, DetectorOptions, DetectorType, CacheType } from './language'
export type { LanguageVariables, DetectorOptions, DetectorType, CacheType }
export {
  languageDetector,
  detectFromCookie,
  detectFromHeader,
  detectFromPath,
  detectFromQuery,
} from './language'
declare module '../..' {
  interface ContextVariableMap extends LanguageVariables {}
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/language/language.ts
```typescript
/**
 * @module
 * Language module for Hono.
 */
import type { Context } from '../../context'
import { setCookie, getCookie } from '../../helper/cookie'
import type { MiddlewareHandler } from '../../types'
import { parseAccept } from '../../utils/accept'

export type DetectorType = 'path' | 'querystring' | 'cookie' | 'header'
export type CacheType = 'cookie'

export interface DetectorOptions {
  /** Order of language detection strategies */
  order: DetectorType[]
  /** Query parameter name for language */
  lookupQueryString: string
  /** Cookie name for language */
  lookupCookie: string
  /** Index in URL path where language code appears */
  lookupFromPathIndex: number
  /** Header key for language detection */
  lookupFromHeaderKey: string
  /** Caching strategies */
  caches: CacheType[] | false
  /** Cookie configuration options */
  cookieOptions?: {
    domain?: string
    path?: string
    sameSite?: 'Strict' | 'Lax' | 'None'
    secure?: boolean
    maxAge?: number
    httpOnly?: boolean
  }
  /** Whether to ignore case in language codes */
  ignoreCase: boolean
  /** Default language if none detected */
  fallbackLanguage: string
  /** List of supported language codes */
  supportedLanguages: string[]
  /** Optional function to transform detected language codes */
  convertDetectedLanguage?: (lang: string) => string
  /** Enable debug logging */
  debug?: boolean
}

export interface LanguageVariables {
  language: string
}

export const DEFAULT_OPTIONS: DetectorOptions = {
  order: ['querystring', 'cookie', 'header'],
  lookupQueryString: 'lang',
  lookupCookie: 'language',
  lookupFromHeaderKey: 'accept-language',
  lookupFromPathIndex: 0,
  caches: ['cookie'],
  ignoreCase: true,
  fallbackLanguage: 'en',
  supportedLanguages: ['en'],
  cookieOptions: {
    sameSite: 'Strict',
    secure: true,
    maxAge: 365 * 24 * 60 * 60,
    httpOnly: true,
  },
  debug: false,
}
/**
 * Parse Accept-Language header values with quality scores
 * @param header Accept-Language header string
 * @returns Array of parsed languages with quality scores
 */
export function parseAcceptLanguage(header: string): Array<{ lang: string; q: number }> {
  return parseAccept(header).map(({ type, q }) => ({ lang: type, q }))
}

/**
 * Validate and normalize language codes
 * @param lang Language code to normalize
 * @param options Detector options
 * @returns Normalized language code or undefined
 */
export const normalizeLanguage = (
  lang: string | null | undefined,
  options: DetectorOptions
): string | undefined => {
  if (!lang) {
    return undefined
  }

  try {
    let normalizedLang = lang.trim()
    if (options.convertDetectedLanguage) {
      normalizedLang = options.convertDetectedLanguage(normalizedLang)
    }

    const compLang = options.ignoreCase ? normalizedLang.toLowerCase() : normalizedLang
    const compSupported = options.supportedLanguages.map((l) =>
      options.ignoreCase ? l.toLowerCase() : l
    )

    const matchedLang = compSupported.find((l) => l === compLang)
    return matchedLang ? options.supportedLanguages[compSupported.indexOf(matchedLang)] : undefined
  } catch {
    return undefined
  }
}

/**
 * Detects language from query parameter
 */
export const detectFromQuery = (c: Context, options: DetectorOptions): string | undefined => {
  try {
    const query = c.req.query(options.lookupQueryString)
    return normalizeLanguage(query, options)
  } catch {
    return undefined
  }
}

/**
 * Detects language from cookie
 */
export const detectFromCookie = (c: Context, options: DetectorOptions): string | undefined => {
  try {
    const cookie = getCookie(c, options.lookupCookie)
    return normalizeLanguage(cookie, options)
  } catch {
    return undefined
  }
}

/**
 * Detects language from Accept-Language header
 */
export function detectFromHeader(c: Context, options: DetectorOptions): string | undefined {
  try {
    const acceptLanguage = c.req.header(options.lookupFromHeaderKey)
    if (!acceptLanguage) {
      return undefined
    }

    const languages = parseAcceptLanguage(acceptLanguage)
    for (const { lang } of languages) {
      const normalizedLang = normalizeLanguage(lang, options)
      if (normalizedLang) {
        return normalizedLang
      }
    }
    return undefined
  } catch {
    return undefined
  }
}

/**
 * Detects language from URL path
 */
export function detectFromPath(c: Context, options: DetectorOptions): string | undefined {
  try {
    const pathSegments = c.req.path.split('/').filter(Boolean)
    const langSegment = pathSegments[options.lookupFromPathIndex]
    return normalizeLanguage(langSegment, options)
  } catch {
    return undefined
  }
}

/**
 * Collection of all language detection strategies
 */
export const detectors = {
  querystring: detectFromQuery,
  cookie: detectFromCookie,
  header: detectFromHeader,
  path: detectFromPath,
} as const

/** Type for detector functions */
export type DetectorFunction = (c: Context, options: DetectorOptions) => string | undefined

/** Type-safe detector map */
export type Detectors = Record<keyof typeof detectors, DetectorFunction>

/**
 * Validate detector options
 * @param options Detector options to validate
 * @throws Error if options are invalid
 */
export function validateOptions(options: DetectorOptions): void {
  if (!options.supportedLanguages.includes(options.fallbackLanguage)) {
    throw new Error('Fallback language must be included in supported languages')
  }

  if (options.lookupFromPathIndex < 0) {
    throw new Error('Path index must be non-negative')
  }

  if (!options.order.every((detector) => Object.keys(detectors).includes(detector))) {
    throw new Error('Invalid detector type in order array')
  }
}

/**
 * Cache detected language
 */
function cacheLanguage(c: Context, language: string, options: DetectorOptions): void {
  if (!Array.isArray(options.caches) || !options.caches.includes('cookie')) {
    return
  }

  try {
    setCookie(c, options.lookupCookie, language, options.cookieOptions)
  } catch (error) {
    if (options.debug) {
      console.error('Failed to cache language:', error)
    }
  }
}

/**
 * Detect language from request
 */
const detectLanguage = (c: Context, options: DetectorOptions): string => {
  let detectedLang: string | undefined

  for (const detectorName of options.order) {
    const detector = detectors[detectorName]
    if (!detector) {
      continue
    }

    try {
      detectedLang = detector(c, options)
      if (detectedLang) {
        if (options.debug) {
          console.log(`Language detected from ${detectorName}: ${detectedLang}`)
        }
        break
      }
    } catch (error) {
      if (options.debug) {
        console.error(`Error in ${detectorName} detector:`, error)
      }
      continue
    }
  }

  const finalLang = detectedLang || options.fallbackLanguage

  if (detectedLang && options.caches) {
    cacheLanguage(c, finalLang, options)
  }

  return finalLang
}

/**
 * Language detector middleware factory
 * @param userOptions Configuration options for the language detector
 * @returns Hono middleware function
 */
export const languageDetector = (userOptions: Partial<DetectorOptions>): MiddlewareHandler => {
  const options: DetectorOptions = {
    ...DEFAULT_OPTIONS,
    ...userOptions,
    cookieOptions: {
      ...DEFAULT_OPTIONS.cookieOptions,
      ...userOptions.cookieOptions,
    },
  }

  validateOptions(options)

  return async function languageDetector(ctx, next) {
    try {
      const lang = detectLanguage(ctx, options)
      ctx.set('language', lang)
    } catch (error) {
      if (options.debug) {
        console.error('Language detection failed:', error)
      }
      ctx.set('language', options.fallbackLanguage)
    }

    await next()
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/jwk/index.test.ts
```typescript
import { HttpResponse, http } from 'msw'
import { setupServer } from 'msw/node'
import { setSignedCookie } from '../../helper/cookie'
import { Hono } from '../../hono'
import { HTTPException } from '../../http-exception'
import { encodeBase64Url } from '../../utils/encode'
import { Jwt } from '../../utils/jwt'
import type { HonoJsonWebKey } from '../../utils/jwt/jws'
import { signing } from '../../utils/jwt/jws'
import { verifyFromJwks } from '../../utils/jwt/jwt'
import type { JWTPayload } from '../../utils/jwt/types'
import { utf8Encoder } from '../../utils/jwt/utf8'
import * as test_keys from './keys.test.json'
import { jwk } from '.'

const verify_keys = test_keys.public_keys

describe('JWK', () => {
  const server = setupServer(
    http.get('http://localhost/.well-known/jwks.json', () => {
      return HttpResponse.json({ keys: verify_keys })
    }),
    http.get('http://localhost/.well-known/missing-jwks.json', () => {
      return HttpResponse.json({})
    }),
    http.get('http://localhost/.well-known/bad-jwks.json', () => {
      return HttpResponse.json({ keys: 'bad-keys' })
    }),
    http.get('http://localhost/.well-known/404-jwks.json', () => {
      return HttpResponse.text('Not Found', { status: 404 })
    })
  )
  beforeAll(() => server.listen())
  afterEach(() => server.resetHandlers())
  afterAll(() => server.close())

  describe('verifyFromJwks', () => {
    it('Should throw error on missing options', async () => {
      const credential = await Jwt.sign({ message: 'hello world' }, test_keys.private_keys[0])
      await expect(verifyFromJwks(credential, {})).rejects.toThrow(
        'verifyFromJwks requires options for either "keys" or "jwks_uri" or both'
      )
    })
  })

  describe('Credentials in header', () => {
    let handlerExecuted: boolean

    beforeEach(() => {
      handlerExecuted = false
    })

    const app = new Hono()

    app.use('/auth-with-keys/*', jwk({ keys: verify_keys }))
    app.use('/auth-with-keys-unicode/*', jwk({ keys: verify_keys }))
    app.use('/auth-with-keys-nested/*', async (c, next) => {
      const auth = jwk({ keys: verify_keys })
      return auth(c, next)
    })
    app.use(
      '/auth-with-keys-fn/*',
      jwk({
        keys: async () => {
          const response = await fetch('http://localhost/.well-known/jwks.json')
          const data = await response.json()
          return data.keys
        },
      })
    )
    app.use(
      '/auth-with-jwks_uri/*',
      jwk({
        jwks_uri: 'http://localhost/.well-known/jwks.json',
      })
    )
    app.use(
      '/auth-with-keys-and-jwks_uri/*',
      jwk({
        keys: verify_keys,
        jwks_uri: 'http://localhost/.well-known/jwks.json',
      })
    )
    app.use(
      '/auth-with-missing-jwks_uri/*',
      jwk({
        jwks_uri: 'http://localhost/.well-known/missing-jwks.json',
      })
    )
    app.use(
      '/auth-with-404-jwks_uri/*',
      jwk({
        jwks_uri: 'http://localhost/.well-known/404-jwks.json',
      })
    )
    app.use(
      '/auth-with-bad-jwks_uri/*',
      jwk({
        jwks_uri: 'http://localhost/.well-known/bad-jwks.json',
      })
    )

    app.get('/auth-with-keys/*', (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })
    app.get('/auth-with-keys-unicode/*', (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })
    app.get('/auth-with-keys-nested/*', (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })
    app.get('/auth-with-keys-fn/*', (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })
    app.get('/auth-with-jwks_uri/*', (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })
    app.get('/auth-with-keys-and-jwks_uri/*', (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })
    app.get('/auth-with-missing-jwks_uri/*', (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })
    app.get('/auth-with-404-jwks_uri/*', (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })
    app.get('/auth-with-bad-jwks_uri/*', (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })

    it('Should throw an error if the middleware is missing both keys and jwks_uri (empty)', async () => {
      expect(() => app.use('/auth-with-empty-middleware/*', jwk({}))).toThrow(
        'JWK auth middleware requires options for either "keys" or "jwks_uri"'
      )
    })

    it('Should throw an error when crypto.subtle is missing', async () => {
      const subtleSpy = vi.spyOn(global.crypto, 'subtle', 'get').mockReturnValue({
        importKey: undefined,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      } as any)
      expect(() => app.use('/auth-with-bad-env/*', jwk({ keys: verify_keys }))).toThrow()
      subtleSpy.mockRestore()
    })

    it('Should return a server error if options.jwks_uri returns a 404', async () => {
      const credential = await Jwt.sign({ message: 'hello world' }, test_keys.private_keys[0])
      const req = new Request('http://localhost/auth-with-404-jwks_uri/a')
      req.headers.set('Authorization', `Basic ${credential}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(500)
    })

    it('Should return a server error if the remotely fetched keys from options.jwks_uri are missing', async () => {
      const credential = await Jwt.sign({ message: 'hello world' }, test_keys.private_keys[0])
      const req = new Request('http://localhost/auth-with-missing-jwks_uri/a')
      req.headers.set('Authorization', `Basic ${credential}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(500)
    })

    it('Should return a server error if the remotely fetched keys from options.jwks_uri are malformed', async () => {
      const credential = await Jwt.sign({ message: 'hello world' }, test_keys.private_keys[0])
      const req = new Request('http://localhost/auth-with-bad-jwks_uri/a')
      req.headers.set('Authorization', `Basic ${credential}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(500)
    })

    it('Should not authorize requests with missing access token', async () => {
      const req = new Request('http://localhost/auth-with-keys/a')
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
      expect(await res.text()).toBe('Unauthorized')
      expect(handlerExecuted).toBeFalsy()
    })

    it('Should authorize from a static array passed to options.keys (key 1)', async () => {
      const credential = await Jwt.sign({ message: 'hello world' }, test_keys.private_keys[0])
      const req = new Request('http://localhost/auth-with-keys/a')
      req.headers.set('Authorization', `Bearer ${credential}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ message: 'hello world' })
      expect(handlerExecuted).toBeTruthy()
    })

    it('Should authorize from a static array passed to options.keys (key 2)', async () => {
      const credential = await Jwt.sign({ message: 'hello world' }, test_keys.private_keys[1])
      const req = new Request('http://localhost/auth-with-keys/a')
      req.headers.set('Authorization', `Bearer ${credential}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ message: 'hello world' })
      expect(handlerExecuted).toBeTruthy()
      expect(res.status).toBe(200)
    })

    it('Should not authorize a token without header', async () => {
      const encodeJwtPart = (part: unknown): string =>
        encodeBase64Url(utf8Encoder.encode(JSON.stringify(part))).replace(/=/g, '')
      const encodeSignaturePart = (buf: ArrayBufferLike): string =>
        encodeBase64Url(buf).replace(/=/g, '')
      const jwtSignWithoutHeader = async (payload: JWTPayload, privateKey: HonoJsonWebKey) => {
        const encodedPayload = encodeJwtPart(payload)
        const signaturePart = await signing(
          privateKey,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          privateKey.alg as any,
          utf8Encoder.encode(encodedPayload)
        )
        const signature = encodeSignaturePart(signaturePart)
        return `${encodedPayload}.${signature}`
      }
      const credential = await jwtSignWithoutHeader(
        { message: 'hello world' },
        test_keys.private_keys[1]
      )
      const req = new Request('http://localhost/auth-with-keys/a')
      req.headers.set('Authorization', `Bearer ${credential}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
    })

    it('Should not authorize a token with missing "kid" in header', async () => {
      const encodeJwtPart = (part: unknown): string =>
        encodeBase64Url(utf8Encoder.encode(JSON.stringify(part))).replace(/=/g, '')
      const encodeSignaturePart = (buf: ArrayBufferLike): string =>
        encodeBase64Url(buf).replace(/=/g, '')
      const jwtSignWithoutKid = async (payload: JWTPayload, privateKey: HonoJsonWebKey) => {
        const encodedPayload = encodeJwtPart(payload)
        const encodedHeader = encodeJwtPart({ alg: privateKey.alg, typ: 'JWT' })
        const partialToken = `${encodedHeader}.${encodedPayload}`
        const signaturePart = await signing(
          privateKey,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          privateKey.alg as any,
          utf8Encoder.encode(partialToken)
        )
        const signature = encodeSignaturePart(signaturePart)
        return `${partialToken}.${signature}`
      }
      const credential = await jwtSignWithoutKid(
        { message: 'hello world' },
        test_keys.private_keys[1]
      )
      const req = new Request('http://localhost/auth-with-keys/a')
      req.headers.set('Authorization', `Bearer ${credential}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
    })

    it('Should not authorize a token with invalid "kid" in header', async () => {
      const copy = structuredClone(test_keys.private_keys[1])
      copy.kid = 'invalid-kid'
      const credential = await Jwt.sign({ message: 'hello world' }, copy)
      const req = new Request('http://localhost/auth-with-keys/a')
      req.headers.set('Authorization', `Bearer ${credential}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
    })

    it('Should authorize with Unicode payload from a static array passed to options.keys', async () => {
      const credential = await Jwt.sign({ message: 'hello world' }, test_keys.private_keys[0])
      const req = new Request('http://localhost/auth-with-keys-unicode/a')
      req.headers.set('Authorization', `Basic ${credential}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ message: 'hello world' })
      expect(handlerExecuted).toBeTruthy()
    })

    it('Should authorize from a function passed to options.keys', async () => {
      const credential = await Jwt.sign({ message: 'hello world' }, test_keys.private_keys[0])
      const req = new Request('http://localhost/auth-with-keys-fn/a')
      req.headers.set('Authorization', `Basic ${credential}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ message: 'hello world' })
      expect(handlerExecuted).toBeTruthy()
    })

    it('Should authorize from keys remotely fetched from options.jwks_uri', async () => {
      const credential = await Jwt.sign({ message: 'hello world' }, test_keys.private_keys[0])
      const req = new Request('http://localhost/auth-with-jwks_uri/a')
      req.headers.set('Authorization', `Basic ${credential}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ message: 'hello world' })
      expect(handlerExecuted).toBeTruthy()
    })

    it('Should authorize from keys and hard-coded and remotely fetched from options.jwks_uri', async () => {
      const credential = await Jwt.sign({ message: 'hello world' }, test_keys.private_keys[0])
      const req = new Request('http://localhost/auth-with-keys-and-jwks_uri/a')
      req.headers.set('Authorization', `Basic ${credential}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ message: 'hello world' })
      expect(handlerExecuted).toBeTruthy()
    })

    it('Should not authorize requests with invalid Unicode payload in header', async () => {
      const invalidToken =
        'ssyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.B54pAqIiLbu170tGQ1rY06Twv__0qSHTA0ioQPIOvFE'
      const url = 'http://localhost/auth-with-keys-unicode/a'
      const req = new Request(url)
      req.headers.set('Authorization', `Basic ${invalidToken}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
      expect(res.headers.get('www-authenticate')).toEqual(
        `Bearer realm="${url}",error="invalid_token",error_description="token verification failure"`
      )
      expect(handlerExecuted).toBeFalsy()
    })

    it('Should not authorize requests with malformed token structure in header', async () => {
      const invalid_token = 'invalid token'
      const url = 'http://localhost/auth-with-keys/a'
      const req = new Request(url)
      req.headers.set('Authorization', `Bearer ${invalid_token}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
      expect(res.headers.get('www-authenticate')).toEqual(
        `Bearer realm="${url}",error="invalid_request",error_description="invalid credentials structure"`
      )
      expect(handlerExecuted).toBeFalsy()
    })

    it('Should not authorize requests without authorization in nested JWK middleware', async () => {
      const req = new Request('http://localhost/auth-with-keys-nested/a')
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
      expect(await res.text()).toBe('Unauthorized')
      expect(handlerExecuted).toBeFalsy()
    })

    it('Should authorize requests with authorization in nested JWK middleware', async () => {
      const credential = await Jwt.sign({ message: 'hello world' }, test_keys.private_keys[0])
      const req = new Request('http://localhost/auth-with-keys-nested/a')
      req.headers.set('Authorization', `Bearer ${credential}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ message: 'hello world' })
      expect(handlerExecuted).toBeTruthy()
    })
  })

  describe('Credentials in cookie', () => {
    let handlerExecuted: boolean

    beforeEach(() => {
      handlerExecuted = false
    })

    const app = new Hono()

    app.use('/auth-with-keys/*', jwk({ keys: verify_keys, cookie: 'access_token' }))
    app.use('/auth-with-keys-unicode/*', jwk({ keys: verify_keys, cookie: 'access_token' }))
    app.use(
      '/auth-with-keys-prefixed/*',
      jwk({ keys: verify_keys, cookie: { key: 'access_token', prefixOptions: 'host' } })
    )
    app.use(
      '/auth-with-keys-unprefixed/*',
      jwk({ keys: verify_keys, cookie: { key: 'access_token' } })
    )

    app.get('/auth-with-keys/*', (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })
    app.get('/auth-with-keys-prefixed/*', (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })
    app.get('/auth-with-keys-unprefixed/*', (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })
    app.get('/auth-with-keys-unicode/*', (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })

    it('Should not authorize requests with missing access token', async () => {
      const req = new Request('http://localhost/auth-with-keys/a')
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
      expect(await res.text()).toBe('Unauthorized')
      expect(handlerExecuted).toBeFalsy()
    })

    it('Should authorize cookie from a static array passed to options.keys', async () => {
      const url = 'http://localhost/auth-with-keys/a'
      const credential = await Jwt.sign({ message: 'hello world' }, test_keys.private_keys[0])
      const req = new Request(url, {
        headers: new Headers({
          Cookie: `access_token=${credential}`,
        }),
      })
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(await res.json()).toEqual({ message: 'hello world' })
      expect(res.status).toBe(200)
      expect(handlerExecuted).toBeTruthy()
    })

    it('Should authorize prefixed cookie from a static array passed to options.keys', async () => {
      const url = 'http://localhost/auth-with-keys-prefixed/a'
      const credential = await Jwt.sign({ message: 'hello world' }, test_keys.private_keys[0])
      const req = new Request(url, {
        headers: new Headers({
          Cookie: `__Host-access_token=${credential}`,
        }),
      })
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(await res.json()).toEqual({ message: 'hello world' })
      expect(res.status).toBe(200)
      expect(handlerExecuted).toBeTruthy()
    })

    it('Should authorize unprefixed cookie from a static array passed to options.keys', async () => {
      const url = 'http://localhost/auth-with-keys-unprefixed/a'
      const credential = await Jwt.sign({ message: 'hello world' }, test_keys.private_keys[0])
      const req = new Request(url, {
        headers: new Headers({
          Cookie: `access_token=${credential}`,
        }),
      })
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(await res.json()).toEqual({ message: 'hello world' })
      expect(res.status).toBe(200)
      expect(handlerExecuted).toBeTruthy()
    })

    it('Should authorize with Unicode payload from a static array passed to options.keys', async () => {
      const credential = await Jwt.sign({ message: 'hello world' }, test_keys.private_keys[0])
      const req = new Request('http://localhost/auth-with-keys-unicode/a', {
        headers: new Headers({
          Cookie: `access_token=${credential}`,
        }),
      })
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ message: 'hello world' })
      expect(handlerExecuted).toBeTruthy()
    })

    it('Should not authorize requests with invalid Unicode payload in cookie', async () => {
      const invalidToken =
        'ssyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.B54pAqIiLbu170tGQ1rY06Twv__0qSHTA0ioQPIOvFE'

      const url = 'http://localhost/auth-with-keys-unicode/a'
      const req = new Request(url)
      req.headers.set('Cookie', `access_token=${invalidToken}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
      expect(res.headers.get('www-authenticate')).toEqual(
        `Bearer realm="${url}",error="invalid_token",error_description="token verification failure"`
      )
      expect(handlerExecuted).toBeFalsy()
    })

    it('Should not authorize requests with malformed token structure in cookie', async () => {
      const invalidToken = 'invalid token'
      const url = 'http://localhost/auth-with-keys/a'
      const req = new Request(url)
      req.headers.set('Cookie', `access_token=${invalidToken}`)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(401)
      expect(res.headers.get('www-authenticate')).toEqual(
        `Bearer realm="${url}",error="invalid_token",error_description="token verification failure"`
      )
      expect(handlerExecuted).toBeFalsy()
    })
  })

  describe('Credentials in a signed cookie', () => {
    let handlerExecuted: boolean

    beforeEach(() => {
      handlerExecuted = false
    })

    const app = new Hono()
    const test_secret = 'Shhh'

    app.use(
      '/auth-with-signed-cookie/*',
      jwk({ keys: verify_keys, cookie: { key: 'access_token', secret: test_secret } })
    )
    app.use(
      '/auth-with-signed-with-prefix-options-cookie/*',
      jwk({
        keys: verify_keys,
        cookie: { key: 'access_token', secret: test_secret, prefixOptions: 'host' },
      })
    )

    app.get('/sign-cookie', async (c) => {
      const credential = await Jwt.sign(
        { message: 'signed hello world' },
        test_keys.private_keys[0]
      )
      await setSignedCookie(c, 'access_token', credential, test_secret)
      return c.text('OK')
    })
    app.get('/sign-cookie-with-prefix', async (c) => {
      const credential = await Jwt.sign(
        { message: 'signed hello world' },
        test_keys.private_keys[0]
      )
      await setSignedCookie(c, 'access_token', credential, test_secret, { prefix: 'host' })
      return c.text('OK')
    })
    app.get('/auth-with-signed-cookie/*', async (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })
    app.get('/auth-with-signed-with-prefix-options-cookie/*', async (c) => {
      handlerExecuted = true
      const payload = c.get('jwtPayload')
      return c.json(payload)
    })

    it('Should authorize signed cookie', async () => {
      const url = 'http://localhost/auth-with-signed-cookie/a'
      const sign_res = await app.request('http://localhost/sign-cookie')
      const cookieHeader = sign_res.headers.get('Set-Cookie') as string
      expect(cookieHeader).not.toBeNull()
      const req = new Request(url)
      req.headers.set('Cookie', cookieHeader)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ message: 'signed hello world' })
      expect(handlerExecuted).toBeTruthy()
    })

    it('Should authorize prefixed signed cookie', async () => {
      const url = 'http://localhost/auth-with-signed-with-prefix-options-cookie/a'
      const sign_res = await app.request('http://localhost/sign-cookie-with-prefix')
      const cookieHeader = sign_res.headers.get('Set-Cookie') as string
      expect(cookieHeader).not.toBeNull()
      const req = new Request(url)
      req.headers.set('Cookie', cookieHeader)
      const res = await app.request(req)
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ message: 'signed hello world' })
      expect(handlerExecuted).toBeTruthy()
    })

    it('Should not authorize an unsigned cookie', async () => {
      const url = 'http://localhost/auth-with-signed-cookie/a'
      const credential = await Jwt.sign(
        { message: 'unsigned hello world' },
        test_keys.private_keys[0]
      )
      const unsignedCookie = `access_token=${credential}`
      const req = new Request(url)
      req.headers.set('Cookie', unsignedCookie)
      const res = await app.request(req)
      expect(res.status).toBe(401)
      expect(await res.text()).toBe('Unauthorized')
      expect(handlerExecuted).toBeFalsy()
    })
  })

  describe('Error handling with `cause`', () => {
    const app = new Hono()

    app.use('/auth-with-keys/*', jwk({ keys: verify_keys }))
    app.get('/auth-with-keys/*', (c) => c.text('Authorized'))

    app.onError((e, c) => {
      if (e instanceof HTTPException && e.cause instanceof Error) {
        return c.json({ name: e.cause.name, message: e.cause.message }, 401)
      }
      return c.text(e.message, 401)
    })

    it('Should not authorize', async () => {
      const credential = 'abc.def.ghi'
      const req = new Request('http://localhost/auth-with-keys')
      req.headers.set('Authorization', `Bearer ${credential}`)
      const res = await app.request(req)
      expect(res.status).toBe(401)
      expect(await res.json()).toEqual({
        name: 'JwtTokenInvalid',
        message: `invalid JWT token: ${credential}`,
      })
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/jwk/index.ts
```typescript
export { jwk } from './jwk'

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/jwk/jwk.ts
````typescript
/**
 * @module
 * JWK Auth Middleware for Hono.
 */

import type { Context } from '../../context'
import { getCookie, getSignedCookie } from '../../helper/cookie'
import { HTTPException } from '../../http-exception'
import type { MiddlewareHandler } from '../../types'
import type { CookiePrefixOptions } from '../../utils/cookie'
import { Jwt } from '../../utils/jwt'
import '../../context'
import type { HonoJsonWebKey } from '../../utils/jwt/jws'

/**
 * JWK Auth Middleware for Hono.
 *
 * @see {@link https://hono.dev/docs/middleware/builtin/jwk}
 *
 * @param {object} options - The options for the JWK middleware.
 * @param {HonoJsonWebKey[] | (() => Promise<HonoJsonWebKey[]>)} [options.keys] - The values of your public keys, or a function that returns them.
 * @param {string} [options.jwks_uri] - If this value is set, attempt to fetch JWKs from this URI, expecting a JSON response with `keys` which are added to the provided options.keys
 * @param {string} [options.cookie] - If this value is set, then the value is retrieved from the cookie header using that value as a key, which is then validated as a token.
 * @param {RequestInit} [init] - Optional initialization options for the `fetch` request when retrieving JWKS from a URI.
 * @returns {MiddlewareHandler} The middleware handler function.
 *
 * @example
 * ```ts
 * const app = new Hono()
 *
 * app.use("/auth/*", jwk({ jwks_uri: "https://example-backend.hono.dev/.well-known/jwks.json" }))
 *
 * app.get('/auth/page', (c) => {
 *   return c.text('You are authorized')
 * })
 * ```
 */

export const jwk = (
  options: {
    keys?: HonoJsonWebKey[] | (() => Promise<HonoJsonWebKey[]>)
    jwks_uri?: string
    cookie?:
      | string
      | { key: string; secret?: string | BufferSource; prefixOptions?: CookiePrefixOptions }
  },
  init?: RequestInit
): MiddlewareHandler => {
  if (!options || !(options.keys || options.jwks_uri)) {
    throw new Error('JWK auth middleware requires options for either "keys" or "jwks_uri" or both')
  }

  if (!crypto.subtle || !crypto.subtle.importKey) {
    throw new Error('`crypto.subtle.importKey` is undefined. JWK auth middleware requires it.')
  }

  return async function jwk(ctx, next) {
    const credentials = ctx.req.raw.headers.get('Authorization')
    let token
    if (credentials) {
      const parts = credentials.split(/\s+/)
      if (parts.length !== 2) {
        const errDescription = 'invalid credentials structure'
        throw new HTTPException(401, {
          message: errDescription,
          res: unauthorizedResponse({
            ctx,
            error: 'invalid_request',
            errDescription,
          }),
        })
      } else {
        token = parts[1]
      }
    } else if (options.cookie) {
      if (typeof options.cookie == 'string') {
        token = getCookie(ctx, options.cookie)
      } else if (options.cookie.secret) {
        if (options.cookie.prefixOptions) {
          token = await getSignedCookie(
            ctx,
            options.cookie.secret,
            options.cookie.key,
            options.cookie.prefixOptions
          )
        } else {
          token = await getSignedCookie(ctx, options.cookie.secret, options.cookie.key)
        }
      } else {
        if (options.cookie.prefixOptions) {
          token = getCookie(ctx, options.cookie.key, options.cookie.prefixOptions)
        } else {
          token = getCookie(ctx, options.cookie.key)
        }
      }
    }

    if (!token) {
      const errDescription = 'no authorization included in request'
      throw new HTTPException(401, {
        message: errDescription,
        res: unauthorizedResponse({
          ctx,
          error: 'invalid_request',
          errDescription,
        }),
      })
    }

    let payload
    let cause
    try {
      payload = await Jwt.verifyFromJwks(token, options, init)
    } catch (e) {
      cause = e
    }

    if (!payload) {
      if (cause instanceof Error && cause.constructor === Error) {
        throw cause
      }
      throw new HTTPException(401, {
        message: 'Unauthorized',
        res: unauthorizedResponse({
          ctx,
          error: 'invalid_token',
          statusText: 'Unauthorized',
          errDescription: 'token verification failure',
        }),
        cause,
      })
    }

    ctx.set('jwtPayload', payload)

    await next()
  }
}

function unauthorizedResponse(opts: {
  ctx: Context
  error: string
  errDescription: string
  statusText?: string
}) {
  return new Response('Unauthorized', {
    status: 401,
    statusText: opts.statusText,
    headers: {
      'WWW-Authenticate': `Bearer realm="${opts.ctx.req.url}",error="${opts.error}",error_description="${opts.errDescription}"`,
    },
  })
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/jwk/keys.test.json
```json
{
  "public_keys": [
    {
      "kid": "hono-test-kid-1",
      "kty": "RSA",
      "use": "sig",
      "alg": "RS256",
      "e": "AQAB",
      "n": "2XGQh8VC_p8gRqfBLY0E3RycnfBl5g1mKyeiyRSPjdaR7fmNPuC3mHjVWXtyXWSvAuRYPYfL_pSi6erpxVv7NuPJbKaZ-I1MwdRPdG2qHu9mNYxniws73gvF3tUN9eSsQUIBL0sYEOnVMjniDcOxIr3Rgz_RxdLB_FxTDXYhzzG49L79wGV1udILGHq0lqlMtmUX6LRtbaoRt1fJB4rTCkYeQp9r5HYP79PKTR43vLIq0aZryI4CyBkPG_0vGEvnzasGdp-qE9Ywt_J2anQKt3nvVVR4Yhs2EIoPQkYoDnVySjeuRsUA5JQYKThrM4sFZSQsO82dHTvwKo2z2x6ZMw"
    },
    {
      "kid": "hono-test-kid-2",
      "kty": "RSA",
      "use": "sig",
      "alg": "RS256",
      "e": "AQAB",
      "n": "uRVR5DkH22a_FM4RtqvnVxd6QAjdfj8oFYPaxIux7K8oTaBy5YagxTWN0qeKI5lI3nL20cx72XxD_UF4TETCFgfD-XB48cdjnSQlOXXbRPXUX0Rdte48naAt4przAb7ydUxrfvDlbSZe02Du-ZGRzEB6RW6KLFWUvTadI4w33qb2i8hauQuTcRmaIUESt8oytUGS44dXAw3Nqt_NL-e7TRgX5o1u_31Uvet1ofsv6Mx8vxJ6zMdM_AKvzLt2iuoK_8vL4R86CjD3dpal2BwO7RkRl2Wcuf5jxjM4pruJ2RBCpzBieEvSIH8kKHIm9SfTzTDJqRhoXd7KM5jL1GNzyw"
    }
  ],
  "private_keys": [
    {
      "kid": "hono-test-kid-1",
      "alg": "RS256",
      "d": "A5CR2gGPegHwOYUbUzylZvdgUFNWMetOUK7M3TClGdVgSkWpELrTLhpTa3m50KYlG446x03baxUGU4D_MoKx7GukX0-fGCzY17FvWNOwOLACcPMYT3ZwfAQ2_jkBimJxU7CNUtH18KQ-U1B3nQ1apHZc-1Xa6CKIY5nv32yfj6uTrERRLOs7Fn9xpOE4uMHEf-l1ppIEIqK5QkEoPRMCUBABsGBSfiJP2hQVa-R-nezX3kVSxKTxAjDEOkquzb-CKlJW7xN2xQ7p40Wi7lDWZkOapBNGr59Z4gcFfo6f8XpQrqoFjDfsGsdH5q9MH_3lEEtD14wymXNnCoRHNr_mwQ",
      "dp": "WMq_BNbd3At-J9VzXgE-aLvPhztS1W8K9xlghITpwAyzhEfCp9mO7IOEVtNWKoEtVFEaZrWKuNWKd-dnzjvydltCkpJ7QhTmiFNFsEzKNJdGQ1Tfsj9658csbVLUOhI4oVcN6kiCa6OdH41Z_JMyN75cTgd4z5h_FRYRRgjoUEU",
      "dq": "Lz9vM7L-aEsPJOM5K2PqInLP9HNwDl943S79d_aw6w-JnHPFcu95no6-6nRcd87eSWoTvHZeFgsle4oiV0UpAocEO7xraCBa_Z9o-jGbBfynOLyXMH2l70yWBdCGCzgc_Wg2sKJwiYYXXfGJ3CzSeIRet82Rn54Q9mMlB6Ie8LE",
      "e": "AQAB",
      "kty": "RSA",
      "n": "2XGQh8VC_p8gRqfBLY0E3RycnfBl5g1mKyeiyRSPjdaR7fmNPuC3mHjVWXtyXWSvAuRYPYfL_pSi6erpxVv7NuPJbKaZ-I1MwdRPdG2qHu9mNYxniws73gvF3tUN9eSsQUIBL0sYEOnVMjniDcOxIr3Rgz_RxdLB_FxTDXYhzzG49L79wGV1udILGHq0lqlMtmUX6LRtbaoRt1fJB4rTCkYeQp9r5HYP79PKTR43vLIq0aZryI4CyBkPG_0vGEvnzasGdp-qE9Ywt_J2anQKt3nvVVR4Yhs2EIoPQkYoDnVySjeuRsUA5JQYKThrM4sFZSQsO82dHTvwKo2z2x6ZMw",
      "p": "7K-X3xMf3xxdlHTRs17x4WkbFUq4ZCU9L1al88UW2tpoF8ZDLUvaKXeF0vkosKvYUsiHsV1fbGVo6Oy75iII-op-t6-tP3R61nkjaytyJ8p32nbxBI1UWpFxZYNxG_Od07kau3LwkgDh8Ogr6zqmq8-lKoBPio-4K7PY5FiyWzs",
      "q": "6y__IKt1n1pTc-S9l1WfSuC96jX8iQhEsGSxnshyNZi59mH1AigkrAw9T5b7OFX7ulHXwuithsVi8cxkq2inNmemxD3koiiU-sv6vg6lRCoZsXFHiUCP-2HoK17sR1zUb6HQpp5MEHY8qoC3Mi3IpkNC7gAbAukbMQo3WlIGqmk",
      "qi": "flgM56Nw2hzHHy0Lz8ewBtOkkzfq1r_n6SmSZdU0zWlEp1lLovpHmuwyVeXpQlLJUHqcNVRw0NlwV7EN0rPd4rG3hcMdogj_Jl-r52TYzx4kVpbMEIh4xKs5rFzxbb96A3F9Ox-muRWvfOUCpXxGXCCGqHRmjRUolxDxsiPznuk"
    },
    {
      "kid": "hono-test-kid-2",
      "alg": "RS256",
      "d": "JCIL50TVClnQQyUJ40JDO0b7mGXCrCNzVWP1ATsOhNkbQrBozfOPDoEqi24m81U5GyiRlBraMPboJRizfhxMUdW5RkjVa8pT4blNRR8DrD5b9C9aJir5DYLYgm1itLwNBKZjNBieicUcbSL29KUdNCWAWW6_rfEVRS1U1zxIKgDUPVd6d7jiIwAKuKvGlMc11RGRZj5eKSNMQyLU5u8Qs_VQuoBRNAyWLZZcHMlAWbh3er7m0jkmUDRdVU0y_n1UAGsr9cAxPwf2HtS5j5R2ahEodatsJynnafYtj6jbOR6jvO3N2Vf-NJ7jVY2-kfv1rJd86KAxD-tIAGx2w1VRTQ",
      "dp": "wQhiWfdvVxk7ERmYj7Fn04wqjP7o7-72bn3SznGyBSkvpkg1WX4j467vpRtXVn4qxSSMXCj2UMKCrovba2RWHp1cnkvT-TFTbONkBuhOBpbx3TVwgGd-IfDJVa_i89XjiYgtEApHz173kRodEENXxcOj_mbOGyBb9Yl2M45A-tU",
      "dq": "ERdP5mdziJ46OsDHTdZ4hOX2ti0EljtVqGo1B4WKXey6DMH0JGHGU_3fFiF4Gomhy3nyGUI7Qhk3kf7lixAtSsk1lWAAeQLPt1r8yZkD5odLKXLyua_yZJ041d3O3wxRYXl3OvzoVy6rPhzRPIaxevNp-Pp5ZNoKfonQPz3bDGc",
      "e": "AQAB",
      "kty": "RSA",
      "n": "uRVR5DkH22a_FM4RtqvnVxd6QAjdfj8oFYPaxIux7K8oTaBy5YagxTWN0qeKI5lI3nL20cx72XxD_UF4TETCFgfD-XB48cdjnSQlOXXbRPXUX0Rdte48naAt4przAb7ydUxrfvDlbSZe02Du-ZGRzEB6RW6KLFWUvTadI4w33qb2i8hauQuTcRmaIUESt8oytUGS44dXAw3Nqt_NL-e7TRgX5o1u_31Uvet1ofsv6Mx8vxJ6zMdM_AKvzLt2iuoK_8vL4R86CjD3dpal2BwO7RkRl2Wcuf5jxjM4pruJ2RBCpzBieEvSIH8kKHIm9SfTzTDJqRhoXd7KM5jL1GNzyw",
      "p": "7cY_nFnn4w5pVi7wq_S9FJHIGsxCwogXqSSC_d7yWopbI2rW3Ugx21IMcWT2pnpsF_VYQx5FnNFviFufNOloREOguqci4lBinAilYBf3VXaN_YrxSk4flJmykwm_HBbXpHt_L3t4HBf-uuY-klJxFkeTbBErjxMS0U0EheEpDYU",
      "q": "x0UidqgkzWPqXa7vZ5noYTY5e3TDQZ_l8A26lFDKAbB62lXvnp_MhnQYDAx9VgUGYYrXv7UmaH-ZCSzuMM9Uhuw0lXRyojF-TLowNjASMlWbkJsJus3zi_AI4pAKyYnhNADxZrT1kxseI8zHiq0_bQa8qLaleXBTdkpc3Z6M1Q8",
      "qi": "x5VJcfnlX9ZhH6eMKx27rOGQrPjQ4BjZgmND7rrX-CSrE0M0RG4KuC4ZOu5XpQ-YsOC_bIzolBN2cHGn4ttPXeUc3y5bnqJYo7FxMdGn4gPRbXlVjCrE54JH_cdkl8cDqcaybjme1-ilNu-vHJWgHPdpbOguhRpicARkptAkOe0"
    }
  ]
}
```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/method-override/index.test.ts
```typescript
import { Hono } from '../../hono'
import { methodOverride } from './index'

describe('Method Override Middleware', () => {
  describe('Form', () => {
    const app = new Hono()
    app.use('/posts/*', methodOverride({ app }))
    app.use('/posts-custom/*', methodOverride({ app, form: 'custom-input-name' }))
    app.on(['post', 'delete'], ['/posts', '/posts-custom'], async (c) => {
      const form = await c.req.formData()
      return c.json({
        method: c.req.method,
        message: form.get('message'),
        contentType: c.req.header('content-type') ?? '',
      })
    })

    describe('multipart/form-data', () => {
      it('Should override POST to DELETE', async () => {
        const form = new FormData()
        form.append('message', 'Hello')
        form.append('_method', 'DELETE')
        const res = await app.request('/posts', {
          body: form,
          method: 'POST',
        })
        expect(res.status).toBe(200)
        const data = await res.json()
        expect(data.method).toBe('DELETE')
        expect(data.message).toBe('Hello')
        expect(data.contentType).toMatch(/^multipart\/form-data;/)
      })

      it('Should override POST to DELETE - with a custom form input name', async () => {
        const form = new FormData()
        form.append('message', 'Hello')
        form.append('custom-input-name', 'DELETE')
        const res = await app.request('/posts-custom', {
          body: form,
          method: 'POST',
        })
        expect(res.status).toBe(200)
        const data = await res.json()
        expect(data.method).toBe('DELETE')
        expect(data.message).toBe('Hello')
        expect(data.contentType).toMatch(/^multipart\/form-data;/)
      })

      it('Should override POST to PATCH - not found', async () => {
        const form = new FormData()
        form.append('message', 'Hello')
        form.append('_method', 'PATCH')
        const res = await app.request('/posts', {
          body: form,
          method: 'POST',
        })
        expect(res.status).toBe(404)
      })
    })

    describe('application/x-www-form-urlencoded', () => {
      it('Should override POST to DELETE', async () => {
        const params = new URLSearchParams()
        params.append('message', 'Hello')
        params.append('_method', 'DELETE')
        const res = await app.request('/posts', {
          body: params,
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          method: 'POST',
        })
        expect(res.status).toBe(200)
        const data = await res.json()
        expect(data.method).toBe('DELETE')
        expect(data.message).toBe('Hello')
        expect(data.contentType).toBe('application/x-www-form-urlencoded')
      })

      it('Should override POST to DELETE - with a custom form input name', async () => {
        const params = new URLSearchParams()
        params.append('message', 'Hello')
        params.append('custom-input-name', 'DELETE')
        const res = await app.request('/posts-custom', {
          body: params,
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          method: 'POST',
        })
        expect(res.status).toBe(200)
        const data = await res.json()
        expect(data.method).toBe('DELETE')
        expect(data.message).toBe('Hello')
        expect(data.contentType).toBe('application/x-www-form-urlencoded')
      })

      it('Should override POST to PATCH - not found', async () => {
        const form = new FormData()
        form.append('message', 'Hello')
        form.append('_method', 'PATCH')
        const res = await app.request('/posts', {
          body: form,
          method: 'POST',
        })
        expect(res.status).toBe(404)
      })
    })
  })

  describe('Header', () => {
    const app = new Hono()
    app.use('/posts/*', methodOverride({ app, header: 'X-METHOD-OVERRIDE' }))
    app.on(['get', 'post', 'delete'], '/posts', async (c) => {
      return c.json({
        method: c.req.method,
        headerValue: c.req.header('X-METHOD-OVERRIDE') ?? null,
      })
    })

    it('Should override POST to DELETE', async () => {
      const res = await app.request('/posts', {
        method: 'POST',
        headers: {
          'X-METHOD-OVERRIDE': 'DELETE',
        },
      })
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({
        method: 'DELETE',
        headerValue: null,
      })
    })

    it('Should not override GET request', async () => {
      const res = await app.request('/posts', {
        method: 'GET',
        headers: {
          'X-METHOD-OVERRIDE': 'DELETE',
        },
      })
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({
        method: 'GET',
        headerValue: 'DELETE', // It does not modify the headers.
      })
    })
  })

  describe('Query', () => {
    const app = new Hono()
    app.use('/posts/*', methodOverride({ app, query: '_method' }))
    app.on(['get', 'post', 'delete'], '/posts', async (c) => {
      return c.json({
        method: c.req.method,
        queryValue: c.req.query('_method') ?? null,
      })
    })

    it('Should override POST to DELETE', async () => {
      const res = await app.request('/posts?_method=delete', {
        method: 'POST',
      })
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({
        method: 'DELETE',
        queryValue: null,
      })
    })

    it('Should not override GET request', async () => {
      const res = await app.request('/posts?_method=delete', {
        method: 'GET',
      })
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({
        method: 'GET',
        queryValue: 'delete', // It does not modify the queries.
      })
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/method-override/index.ts
````typescript
/**
 * @module
 * Method Override Middleware for Hono.
 */

import type { Context, ExecutionContext } from '../../context'
import type { Hono } from '../../hono'
import type { MiddlewareHandler } from '../../types'
import { parseBody } from '../../utils/body'

type MethodOverrideOptions = {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  app: Hono<any, any, any>
} & (
  | {
      // Default is 'form' and the value is `_method`
      form?: string
      header?: never
      query?: never
    }
  | {
      form?: never
      header: string
      query?: never
    }
  | {
      form?: never
      header?: never
      query: string
    }
)

const DEFAULT_METHOD_FORM_NAME = '_method'

/**
 * Method Override Middleware for Hono.
 *
 * @see {@link https://hono.dev/docs/middleware/builtin/method-override}
 *
 * @param {MethodOverrideOptions} options - The options for the method override middleware.
 * @param {Hono} options.app - The instance of Hono is used in your application.
 * @param {string} [options.form=_method] - Form key with a value containing the method name.
 * @param {string} [options.header] - Header name with a value containing the method name.
 * @param {string} [options.query] - Query parameter key with a value containing the method name.
 * @returns {MiddlewareHandler} The middleware handler function.
 *
 * @example
 * ```ts
 * const app = new Hono()
 *
 * // If no options are specified, the value of `_method` in the form,
 * // e.g. DELETE, is used as the method.
 * app.use('/posts', methodOverride({ app }))
 *
 * app.delete('/posts', (c) => {
 *   // ....
 * })
 * ```
 */
export const methodOverride = (options: MethodOverrideOptions): MiddlewareHandler =>
  async function methodOverride(c, next) {
    if (c.req.method === 'GET') {
      return await next()
    }

    const app = options.app
    // Method override by form
    if (!(options.header || options.query)) {
      const contentType = c.req.header('content-type')
      const methodFormName = options.form || DEFAULT_METHOD_FORM_NAME
      const clonedRequest = c.req.raw.clone()
      const newRequest = clonedRequest.clone()
      // Content-Type is `multipart/form-data`
      if (contentType?.startsWith('multipart/form-data')) {
        const form = await clonedRequest.formData()
        const method = form.get(methodFormName)
        if (method) {
          const newForm = await newRequest.formData()
          newForm.delete(methodFormName)
          const newHeaders = new Headers(clonedRequest.headers)
          newHeaders.delete('content-type')
          newHeaders.delete('content-length')
          const request = new Request(c.req.url, {
            body: newForm,
            headers: newHeaders,
            method: method as string,
          })
          return app.fetch(request, c.env, getExecutionCtx(c))
        }
      }
      // Content-Type is `application/x-www-form-urlencoded`
      if (contentType === 'application/x-www-form-urlencoded') {
        const params = await parseBody<Record<string, string>>(clonedRequest)
        const method = params[methodFormName]
        if (method) {
          delete params[methodFormName]
          const newParams = new URLSearchParams(params)
          const request = new Request(newRequest, {
            body: newParams,
            method: method as string,
          })
          return app.fetch(request, c.env, getExecutionCtx(c))
        }
      }
    }
    // Method override by header
    else if (options.header) {
      const headerName = options.header
      const method = c.req.header(headerName)
      if (method) {
        const newHeaders = new Headers(c.req.raw.headers)
        newHeaders.delete(headerName)
        const request = new Request(c.req.raw, {
          headers: newHeaders,
          method,
        })
        return app.fetch(request, c.env, getExecutionCtx(c))
      }
    }
    // Method override by query
    else if (options.query) {
      const queryName = options.query
      const method = c.req.query(queryName)
      if (method) {
        const url = new URL(c.req.url)
        url.searchParams.delete(queryName)
        const request = new Request(url.toString(), {
          body: c.req.raw.body,
          headers: c.req.raw.headers,
          method,
        })
        return app.fetch(request, c.env, getExecutionCtx(c))
      }
    }
    await next()
  }

const getExecutionCtx = (c: Context) => {
  let executionCtx: ExecutionContext | undefined
  try {
    executionCtx = c.executionCtx
  } catch {
    // Do nothing
  }
  return executionCtx
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/pretty-json/index.test.ts
```typescript
import { Hono } from '../../hono'
import { prettyJSON } from '.'

describe('JSON pretty by Middleware', () => {
  it('Should return pretty JSON output', async () => {
    const app = new Hono()
    app.use('*', prettyJSON())
    app.get('/', (c) => {
      return c.json({ message: 'Hono!' })
    })

    const res = await app.request('http://localhost/?pretty')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe(`{
  "message": "Hono!"
}`)
  })

  it('Should return pretty JSON output with 4 spaces', async () => {
    const app = new Hono()
    app.use('*', prettyJSON({ space: 4 }))
    app.get('/', (c) => {
      return c.json({ message: 'Hono!' })
    })

    const res = await app.request('http://localhost/?pretty')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(await res.text()).toBe(`{
    "message": "Hono!"
}`)
  })

  it('Should return pretty JSON output when middleware received custom query', async () => {
    const targetQuery = 'format'

    const app = new Hono()
    app.use(
      '*',
      prettyJSON({
        query: targetQuery,
      })
    )
    app.get('/', (c) =>
      c.json({
        message: 'Hono!',
      })
    )

    const prettyText = await (await app.request(`?${targetQuery}`)).text()
    expect(prettyText).toBe(`{
  "message": "Hono!"
}`)
    const nonPrettyText = await (await app.request('?pretty')).text()
    expect(nonPrettyText).toBe('{"message":"Hono!"}')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/pretty-json/index.ts
````typescript
/**
 * @module
 * Pretty JSON Middleware for Hono.
 */

import type { MiddlewareHandler } from '../../types'

interface PrettyOptions {
  /**
   * Number of spaces for indentation.
   * @default 2
   */
  space?: number

  /**
   * Query conditions for when to Pretty.
   * @default 'pretty'
   */
  query?: string
}

/**
 * Pretty JSON Middleware for Hono.
 *
 * @see {@link https://hono.dev/docs/middleware/builtin/pretty-json}
 *
 * @param options - The options for the pretty JSON middleware.
 * @returns {MiddlewareHandler} The middleware handler function.
 *
 * @example
 * ```ts
 * const app = new Hono()
 *
 * app.use(prettyJSON()) // With options: prettyJSON({ space: 4 })
 * app.get('/', (c) => {
 *   return c.json({ message: 'Hono!' })
 * })
 * ```
 */
export const prettyJSON = (options?: PrettyOptions): MiddlewareHandler => {
  const targetQuery = options?.query ?? 'pretty'
  return async function prettyJSON(c, next) {
    const pretty = c.req.query(targetQuery) || c.req.query(targetQuery) === ''
    await next()
    if (pretty && c.res.headers.get('Content-Type')?.startsWith('application/json')) {
      const obj = await c.res.json()
      c.res = new Response(JSON.stringify(obj, null, options?.space ?? 2), c.res)
    }
  }
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/timing/index.test.ts
```typescript
import { Hono } from '../../hono'
import { endTime, setMetric, startTime, timing } from '.'

describe('Server-Timing API', () => {
  const app = new Hono()

  const totalDescription = 'my total DescRipTion!'
  const name = 'sleep'
  const region = 'region'
  const regionDesc = 'europe-west3'

  app.use(
    '*',
    timing({
      totalDescription,
    })
  )
  app.get('/', (c) => c.text('/'))
  app.get('/api', async (c) => {
    startTime(c, name)
    await new Promise((r) => setTimeout(r, 30))
    endTime(c, name)

    return c.text('api!')
  })
  app.get('/cache', async (c) => {
    setMetric(c, region, regionDesc)

    return c.text('cache!')
  })

  const sub = new Hono()

  sub.use(timing())
  sub.get('/', (c) => c.text('sub'))
  app.route('/sub', sub)

  it('Should contain total duration', async () => {
    const res = await app.request('http://localhost/')
    expect(res).not.toBeNull()
    expect(res.headers.has('server-timing')).toBeTruthy()
    expect(res.headers.get('server-timing')?.includes('total;dur=')).toBeTruthy()
    expect(res.headers.get('server-timing')?.includes(totalDescription)).toBeTruthy()
  })

  it('Should contain value metrics', async () => {
    const res = await app.request('http://localhost/api')
    expect(res).not.toBeNull()
    expect(res.headers.has('server-timing')).toBeTruthy()
    expect(res.headers.get('server-timing')?.includes(`${name};dur=`)).toBeTruthy()
    expect(res.headers.get('server-timing')?.includes(name)).toBeTruthy()
  })

  it('Should contain value-less metrics', async () => {
    const res = await app.request('http://localhost/cache')
    expect(res).not.toBeNull()
    expect(res.headers.has('server-timing')).toBeTruthy()
    expect(
      res.headers.get('server-timing')?.includes(`${region};desc="${regionDesc}"`)
    ).toBeTruthy()
    expect(res.headers.get('server-timing')?.includes(region)).toBeTruthy()
    expect(res.headers.get('server-timing')?.includes(regionDesc)).toBeTruthy()
  })

  it('Should not be enabled if the main app has the timing middleware', async () => {
    const consoleWarnSpy = vi.spyOn(console, 'warn')
    const res = await app.request('/sub')
    expect(res.status).toBe(200)
    expect(res.headers.has('server-timing')).toBeTruthy()
    expect(res.headers.get('server-timing')?.includes(totalDescription)).toBeTruthy()
    expect(consoleWarnSpy).not.toHaveBeenCalled()
    consoleWarnSpy.mockRestore()
  })

  describe('Should handle crossOrigin setting', async () => {
    it('Should do nothing when crossOrigin is falsy', async () => {
      const crossOriginApp = new Hono()

      crossOriginApp.use(
        '*',
        timing({
          crossOrigin: false,
        })
      )

      crossOriginApp.get('/', (c) => c.text('/'))

      const res = await crossOriginApp.request('http://localhost/')

      expect(res).not.toBeNull()
      expect(res.headers.has('server-timing')).toBeTruthy()
      expect(res.headers.has('timing-allow-origin')).toBeFalsy()
    })

    it('Should set Timing-Allow-Origin to * when crossOrigin is true', async () => {
      const crossOriginApp = new Hono()

      crossOriginApp.use(
        '*',
        timing({
          crossOrigin: true,
        })
      )

      crossOriginApp.get('/', (c) => c.text('/'))

      const res = await crossOriginApp.request('http://localhost/')

      expect(res).not.toBeNull()
      expect(res.headers.has('server-timing')).toBeTruthy()
      expect(res.headers.has('timing-allow-origin')).toBeTruthy()
      expect(res.headers.get('timing-allow-origin')).toBe('*')
    })

    it('Should set Timing-Allow-Origin to the value of crossOrigin when it is a string', async () => {
      const crossOriginApp = new Hono()

      crossOriginApp.use(
        '*',
        timing({
          crossOrigin: 'https://example.com',
        })
      )

      crossOriginApp.get('/', (c) => c.text('/'))

      const res = await crossOriginApp.request('http://localhost/')

      expect(res).not.toBeNull()
      expect(res.headers.has('server-timing')).toBeTruthy()
      expect(res.headers.has('timing-allow-origin')).toBeTruthy()
      expect(res.headers.get('timing-allow-origin')).toBe('https://example.com')
    })

    it('Should set Timing-Allow-Origin to the return value of crossOrigin when it is a function', async () => {
      const crossOriginApp = new Hono()

      crossOriginApp.use(
        '*',
        timing({
          crossOrigin: (c) => c.req.header('origin') ?? '*',
        })
      )

      crossOriginApp.get('/', (c) => c.text('/'))

      const res = await crossOriginApp.request('http://localhost/', {
        headers: {
          origin: 'https://example.com',
        },
      })

      expect(res).not.toBeNull()
      expect(res.headers.has('server-timing')).toBeTruthy()
      expect(res.headers.has('timing-allow-origin')).toBeTruthy()
      expect(res.headers.get('timing-allow-origin')).toBe('https://example.com')
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/timing/index.ts
```typescript
import type { TimingVariables } from './timing'
export { TimingVariables }
export { timing, setMetric, startTime, endTime } from './timing'

declare module '../..' {
  interface ContextVariableMap extends TimingVariables {}
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/timing/timing.ts
````typescript
/**
 * @module
 * Server-Timing Middleware for Hono.
 */

import type { Context } from '../../context'
import type { MiddlewareHandler } from '../../types'
import '../../context'

export type TimingVariables = {
  metric?: {
    headers: string[]
    timers: Map<string, Timer>
  }
}

interface Timer {
  description?: string
  start: number
}

interface TimingOptions {
  total?: boolean
  enabled?: boolean | ((c: Context) => boolean)
  totalDescription?: string
  autoEnd?: boolean
  crossOrigin?: boolean | string | ((c: Context) => boolean | string)
}

const getTime = (): number => {
  try {
    return performance.now()
  } catch {}
  return Date.now()
}

/**
 * Server-Timing Middleware for Hono.
 *
 * @see {@link https://hono.dev/docs/middleware/builtin/timing}
 *
 * @param {TimingOptions} [config] - The options for the timing middleware.
 * @param {boolean} [config.total=true] - Show the total response time.
 * @param {boolean | ((c: Context) => boolean)} [config.enabled=true] - Whether timings should be added to the headers or not.
 * @param {string} [config.totalDescription=Total Response Time] - Description for the total response time.
 * @param {boolean} [config.autoEnd=true] - If `startTime()` should end automatically at the end of the request.
 * @param {boolean | string | ((c: Context) => boolean | string)} [config.crossOrigin=false] - The origin this timings header should be readable.
 * @returns {MiddlewareHandler} The middleware handler function.
 *
 * @example
 * ```ts
 * const app = new Hono()
 *
 * // add the middleware to your router
 * app.use(timing());
 *
 * app.get('/', async (c) => {
 *   // add custom metrics
 *   setMetric(c, 'region', 'europe-west3')
 *
 *   // add custom metrics with timing, must be in milliseconds
 *   setMetric(c, 'custom', 23.8, 'My custom Metric')
 *
 *   // start a new timer
 *   startTime(c, 'db');
 *
 *   const data = await db.findMany(...);
 *
 *   // end the timer
 *   endTime(c, 'db');
 *
 *   return c.json({ response: data });
 * });
 * ```
 */
export const timing = (config?: TimingOptions): MiddlewareHandler => {
  const options: TimingOptions = {
    total: true,
    enabled: true,
    totalDescription: 'Total Response Time',
    autoEnd: true,
    crossOrigin: false,
    ...config,
  }
  return async function timing(c, next) {
    const headers: string[] = []
    const timers = new Map<string, Timer>()

    if (c.get('metric')) {
      return await next()
    }

    c.set('metric', { headers, timers })

    if (options.total) {
      startTime(c, 'total', options.totalDescription)
    }
    await next()

    if (options.total) {
      endTime(c, 'total')
    }

    if (options.autoEnd) {
      timers.forEach((_, key) => endTime(c, key))
    }

    const enabled = typeof options.enabled === 'function' ? options.enabled(c) : options.enabled

    if (enabled) {
      c.res.headers.append('Server-Timing', headers.join(','))

      const crossOrigin =
        typeof options.crossOrigin === 'function' ? options.crossOrigin(c) : options.crossOrigin

      if (crossOrigin) {
        c.res.headers.append(
          'Timing-Allow-Origin',
          typeof crossOrigin === 'string' ? crossOrigin : '*'
        )
      }
    }
  }
}

interface SetMetric {
  (c: Context, name: string, value: number, description?: string, precision?: number): void

  (c: Context, name: string, description?: string): void
}

/**
 * Set a metric for the timing middleware.
 *
 * @param {Context} c - The context of the request.
 * @param {string} name - The name of the metric.
 * @param {number | string} [valueDescription] - The value or description of the metric.
 * @param {string} [description] - The description of the metric.
 * @param {number} [precision] - The precision of the metric value.
 *
 * @example
 * ```ts
 * setMetric(c, 'region', 'europe-west3')
 * setMetric(c, 'custom', 23.8, 'My custom Metric')
 * ```
 */
export const setMetric: SetMetric = (
  c: Context,
  name: string,
  valueDescription: number | string | undefined,
  description?: string,
  precision?: number
) => {
  const metrics = c.get('metric')
  if (!metrics) {
    console.warn('Metrics not initialized! Please add the `timing()` middleware to this route!')
    return
  }
  if (typeof valueDescription === 'number') {
    const dur = valueDescription.toFixed(precision || 1)

    const metric = description ? `${name};dur=${dur};desc="${description}"` : `${name};dur=${dur}`

    metrics.headers.push(metric)
  } else {
    // Value-less metric
    const metric = valueDescription ? `${name};desc="${valueDescription}"` : `${name}`

    metrics.headers.push(metric)
  }
}

/**
 * Start a timer for the timing middleware.
 *
 * @param {Context} c - The context of the request.
 * @param {string} name - The name of the timer.
 * @param {string} [description] - The description of the timer.
 *
 * @example
 * ```ts
 * startTime(c, 'db')
 * ```
 */
export const startTime = (c: Context, name: string, description?: string) => {
  const metrics = c.get('metric')
  if (!metrics) {
    console.warn('Metrics not initialized! Please add the `timing()` middleware to this route!')
    return
  }
  metrics.timers.set(name, { description, start: getTime() })
}

/**
 * End a timer for the timing middleware.
 *
 * @param {Context} c - The context of the request.
 * @param {string} name - The name of the timer.
 * @param {number} [precision] - The precision of the timer value.
 *
 * @example
 * ```ts
 * endTime(c, 'db')
 * ```
 */
export const endTime = (c: Context, name: string, precision?: number) => {
  const metrics = c.get('metric')
  if (!metrics) {
    console.warn('Metrics not initialized! Please add the `timing()` middleware to this route!')
    return
  }
  const timer = metrics.timers.get(name)
  if (!timer) {
    console.warn(`Timer "${name}" does not exist!`)
    return
  }
  const { description, start } = timer

  const duration = getTime() - start

  setMetric(c, name, duration, description, precision)
  metrics.timers.delete(name)
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/csrf/index.test.ts
```typescript
import type { Context } from '../../context'
import { Hono } from '../../hono'
import { csrf } from '../../middleware/csrf'

const simplePostHandler = vi.fn(async (c: Context) => {
  if (c.req.header('content-type') === 'application/json') {
    return c.text((await c.req.json<{ name: string }>())['name'])
  } else {
    const body = await c.req.parseBody<{ name: string }>()
    return c.text(body['name'])
  }
})

const buildSimplePostRequestData = (origin?: string) => ({
  method: 'POST',
  headers: Object.assign(
    {
      'content-type': 'application/x-www-form-urlencoded',
    },
    origin ? { origin } : {}
  ) as Record<string, string>,
  body: 'name=hono',
})

describe('CSRF by Middleware', () => {
  beforeEach(() => {
    simplePostHandler.mockClear()
  })

  describe('simple usage', () => {
    const app = new Hono()

    app.use('*', csrf())
    app.get('/form', (c) => c.html('<form></form>'))
    app.post('/form', simplePostHandler)
    app.put('/form', (c) => c.text('OK'))
    app.delete('/form', (c) => c.text('OK'))
    app.patch('/form', (c) => c.text('OK'))

    describe('GET /form', async () => {
      it('should be 200 for any request', async () => {
        const res = await app.request('http://localhost/form')

        expect(res.status).toBe(200)
        expect(await res.text()).toBe('<form></form>')
      })
    })

    describe('HEAD /form', async () => {
      it('should be 200 for any request', async () => {
        const res = await app.request('http://localhost/form', { method: 'HEAD' })

        expect(res.status).toBe(200)
      })
    })

    describe('POST /form', async () => {
      it('should be 200 for local request', async () => {
        /*
         * <form action="/form" method="POST"><input name="name" value="hono" /></form>
         * or
         * <script>
         * fetch('/form', {
         *   method: 'POST',
         *   headers: {
         *     'content-type': 'application/x-www-form-urlencoded',
         *   },
         *   body: 'name=hono',
         * });
         * </script>
         */
        const res = await app.request(
          'http://localhost/form',
          buildSimplePostRequestData('http://localhost')
        )

        expect(res.status).toBe(200)
        expect(await res.text()).toBe('hono')
      })

      it('should be 403 for "application/x-www-form-urlencoded" cross origin', async () => {
        /*
         * via http://example.com
         *
         * <form action="http://localhost/form" method="POST">
         *   <input name="name" value="hono" />
         * </form>
         * or
         * <script>
         * fetch('http://localhost/form', {
         *   method: 'POST',
         *   headers: {
         *     'content-type': 'application/x-www-form-urlencoded',
         *   },
         *   body: 'name=hono',
         * });
         * </script>
         */
        const res = await app.request(
          'http://localhost/form',
          buildSimplePostRequestData('http://example.com')
        )

        expect(res.status).toBe(403)
        expect(simplePostHandler).not.toHaveBeenCalled()
      })
    })

    it('should be 403 for "multipart/form-data" cross origin', async () => {
      /*
       * via http://example.com
       *
       * <form action="http://localhost/form" method="POST" enctype="multipart/form-data">
       *   <input name="name" value="hono" />
       * </form>
       * or
       * <script>
       * fetch('http://localhost/form', {
       *   method: 'POST',
       *   headers: {
       *     'content-type': 'multipart/form-data',
       *   },
       *   body: 'name=hono',
       * });
       * </script>
       */
      const res = await app.request(
        'http://localhost/form',
        buildSimplePostRequestData('http://example.com')
      )

      expect(res.status).toBe(403)
      expect(simplePostHandler).not.toHaveBeenCalled()
    })

    it('should be 403 for "text/plain" cross origin', async () => {
      /*
       * via http://example.com
       *
       * <form action="http://localhost/form" method="POST" enctype="text/plain">
       *   <input name="name" value="hono" />
       * </form>
       * or
       * <script>
       * fetch('http://localhost/form', {
       *   method: 'POST',
       *   headers: {
       *     'content-type': 'text/plain',
       *   },
       *   body: 'name=hono',
       * });
       * </script>
       */
      const res = await app.request(
        'http://localhost/form',
        buildSimplePostRequestData('http://example.com')
      )

      expect(res.status).toBe(403)
      expect(simplePostHandler).not.toHaveBeenCalled()
    })

    it('should be 403 if request has no origin header', async () => {
      const res = await app.request('http://localhost/form', buildSimplePostRequestData())

      expect(res.status).toBe(403)
      expect(simplePostHandler).not.toHaveBeenCalled()
    })

    it('should be 200 for application/json', async () => {
      /*
       * via http://example.com
       * Assume localhost allows cross origin POST
       *
       * <script>
       * fetch('http://localhost/form', {
       *   method: 'POST',
       *   headers: {
       *     'content-type': 'application/json',
       *   },
       *   body: JSON.stringify({ name: 'hono' }),
       * });
       * </script>
       */
      const res = await app.request('http://localhost/form', {
        method: 'POST',
        headers: {
          'content-type': 'application/json',
          origin: 'http://example.com',
        },
        body: JSON.stringify({ name: 'hono' }),
      })

      expect(res.status).toBe(200)
      expect(await res.text()).toBe('hono')
    })

    it('should be 403 for "Application/x-www-form-urlencoded" cross origin', async () => {
      const res = await app.request('http://localhost/form', {
        method: 'POST',
        headers: Object.assign({
          'content-type': 'Application/x-www-form-urlencoded',
        }),
        body: 'name=hono',
      })
      expect(res.status).toBe(403)
      expect(simplePostHandler).not.toHaveBeenCalled()
    })

    it('should be 403 if the content-type is not set', async () => {
      const res = await app.request('/form', {
        method: 'POST',
        body: new Blob(['test'], {}),
      })
      expect(res.status).toBe(403)
      expect(simplePostHandler).not.toHaveBeenCalled()
    })
  })

  describe('with origin option', () => {
    describe('string', () => {
      const app = new Hono()

      app.use(
        '*',
        csrf({
          origin: 'https://example.com',
        })
      )
      app.post('/form', simplePostHandler)

      it('should be 200 for allowed origin', async () => {
        const res = await app.request(
          'https://example.com/form',
          buildSimplePostRequestData('https://example.com')
        )
        expect(res.status).toBe(200)
      })

      it('should be 403 for not allowed origin', async () => {
        const res = await app.request(
          'https://example.jp/form',
          buildSimplePostRequestData('https://example.jp')
        )
        expect(res.status).toBe(403)
        expect(simplePostHandler).not.toHaveBeenCalled()
      })
    })

    describe('string[]', () => {
      const app = new Hono()

      app.use(
        '*',
        csrf({
          origin: ['https://example.com', 'https://hono.example.com'],
        })
      )
      app.post('/form', simplePostHandler)

      it('should be 200 for allowed origin', async () => {
        let res = await app.request(
          'https://hono.example.com/form',
          buildSimplePostRequestData('https://hono.example.com')
        )
        expect(res.status).toBe(200)

        res = await app.request(
          'https://example.com/form',
          buildSimplePostRequestData('https://example.com')
        )
        expect(res.status).toBe(200)
      })

      it('should be 403 for not allowed origin', async () => {
        const res = await app.request(
          'http://example.jp/form',
          buildSimplePostRequestData('http://example.jp')
        )
        expect(res.status).toBe(403)
        expect(simplePostHandler).not.toHaveBeenCalled()
      })
    })

    describe('IsAllowedOriginHandler', () => {
      const app = new Hono()

      app.use(
        '*',
        csrf({
          origin: (origin) => /https:\/\/(\w+\.)?example\.com$/.test(origin),
        })
      )
      app.post('/form', simplePostHandler)

      it('should be 200 for allowed origin', async () => {
        let res = await app.request(
          'https://hono.example.com/form',
          buildSimplePostRequestData('https://hono.example.com')
        )
        expect(res.status).toBe(200)

        res = await app.request(
          'https://example.com/form',
          buildSimplePostRequestData('https://example.com')
        )
        expect(res.status).toBe(200)
      })

      it('should be 403 for not allowed origin', async () => {
        let res = await app.request(
          'http://honojs.hono.example.jp/form',
          buildSimplePostRequestData('http://example.jp')
        )
        expect(res.status).toBe(403)
        expect(simplePostHandler).not.toHaveBeenCalled()

        res = await app.request(
          'http://example.jp/form',
          buildSimplePostRequestData('http://example.jp')
        )
        expect(res.status).toBe(403)
        expect(simplePostHandler).not.toHaveBeenCalled()
      })
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/csrf/index.ts
````typescript
/**
 * @module
 * CSRF Protection Middleware for Hono.
 */

import type { Context } from '../../context'
import { HTTPException } from '../../http-exception'
import type { MiddlewareHandler } from '../../types'

type IsAllowedOriginHandler = (origin: string, context: Context) => boolean
interface CSRFOptions {
  origin?: string | string[] | IsAllowedOriginHandler
}

const isSafeMethodRe = /^(GET|HEAD)$/
const isRequestedByFormElementRe =
  /^\b(application\/x-www-form-urlencoded|multipart\/form-data|text\/plain)\b/i

/**
 * CSRF Protection Middleware for Hono.
 *
 * @see {@link https://hono.dev/docs/middleware/builtin/csrf}
 *
 * @param {CSRFOptions} [options] - The options for the CSRF protection middleware.
 * @param {string|string[]|(origin: string, context: Context) => boolean} [options.origin] - Specify origins.
 * @returns {MiddlewareHandler} The middleware handler function.
 *
 * @example
 * ```ts
 * const app = new Hono()
 *
 * app.use(csrf())
 *
 * // Specifying origins with using `origin` option
 * // string
 * app.use(csrf({ origin: 'myapp.example.com' }))
 *
 * // string[]
 * app.use(
 *   csrf({
 *     origin: ['myapp.example.com', 'development.myapp.example.com'],
 *   })
 * )
 *
 * // Function
 * // It is strongly recommended that the protocol be verified to ensure a match to `$`.
 * // You should *never* do a forward match.
 * app.use(
 *   '*',
 *   csrf({
 *     origin: (origin) => /https:\/\/(\w+\.)?myapp\.example\.com$/.test(origin),
 *   })
 * )
 * ```
 */
export const csrf = (options?: CSRFOptions): MiddlewareHandler => {
  const handler: IsAllowedOriginHandler = ((optsOrigin) => {
    if (!optsOrigin) {
      return (origin, c) => origin === new URL(c.req.url).origin
    } else if (typeof optsOrigin === 'string') {
      return (origin) => origin === optsOrigin
    } else if (typeof optsOrigin === 'function') {
      return optsOrigin
    } else {
      return (origin) => optsOrigin.includes(origin)
    }
  })(options?.origin)
  const isAllowedOrigin = (origin: string | undefined, c: Context) => {
    if (origin === undefined) {
      // denied always when origin header is not present
      return false
    }
    return handler(origin, c)
  }

  return async function csrf(c, next) {
    if (
      !isSafeMethodRe.test(c.req.method) &&
      isRequestedByFormElementRe.test(c.req.header('content-type') || 'text/plain') &&
      !isAllowedOrigin(c.req.header('origin'), c)
    ) {
      const res = new Response('Forbidden', {
        status: 403,
      })
      throw new HTTPException(403, { res })
    }

    await next()
  }
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/body-limit/index.test.ts
```typescript
import { Hono } from '../../hono'
import { bodyLimit } from '.'

const buildRequestInit = (init: RequestInit = {}): RequestInit & { duplex: 'half' } => {
  const headers: Record<string, string> = {
    'Content-Type': 'text/plain',
  }
  if (typeof init.body === 'string') {
    headers['Content-Length'] = init.body.length.toString()
  }
  return {
    method: 'POST',
    headers,
    body: null,
    ...init,
    duplex: 'half',
  }
}

describe('Body Limit Middleware', () => {
  let app: Hono

  const exampleText = 'hono is so hot' // 14byte
  const exampleText2 = 'hono is so hot and cute' // 23byte

  beforeEach(() => {
    app = new Hono()
    app.use('*', bodyLimit({ maxSize: 14 }))
    app.get('/', (c) => c.text('index'))
    app.post('/body-limit-15byte', async (c) => {
      return c.text(await c.req.raw.text())
    })
  })

  describe('GET request', () => {
    it('should return 200 response', async () => {
      const res = await app.request('/')
      expect(res).not.toBeNull()
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('index')
    })
  })

  describe('POST request', () => {
    describe('string body', () => {
      it('should return 200 response', async () => {
        const res = await app.request('/body-limit-15byte', buildRequestInit({ body: exampleText }))

        expect(res).not.toBeNull()
        expect(res.status).toBe(200)
        expect(await res.text()).toBe(exampleText)
      })

      it('should return 413 response', async () => {
        const res = await app.request(
          '/body-limit-15byte',
          buildRequestInit({ body: exampleText2 })
        )

        expect(res).not.toBeNull()
        expect(res.status).toBe(413)
        expect(await res.text()).toBe('Payload Too Large')
      })
    })

    describe('ReadableStream body', () => {
      it('should return 200 response', async () => {
        const contents = ['a', 'b', 'c']
        const stream = new ReadableStream({
          start(controller) {
            while (contents.length) {
              controller.enqueue(new TextEncoder().encode(contents.shift() as string))
            }
            controller.close()
          },
        })
        const res = await app.request('/body-limit-15byte', buildRequestInit({ body: stream }))

        expect(res).not.toBeNull()
        expect(res.status).toBe(200)
        expect(await res.text()).toBe('abc')
      })

      it('should return 413 response', async () => {
        const readSpy = vi.fn().mockImplementation(() => {
          return {
            done: false,
            value: new TextEncoder().encode(exampleText),
          }
        })
        const stream = new ReadableStream()
        vi.spyOn(stream, 'getReader').mockReturnValue({
          read: readSpy,
        } as unknown as ReadableStreamDefaultReader)
        const res = await app.request('/body-limit-15byte', buildRequestInit({ body: stream }))

        expect(res).not.toBeNull()
        expect(res.status).toBe(413)
        expect(readSpy).toHaveBeenCalledTimes(2)
        expect(await res.text()).toBe('Payload Too Large')
      })
    })
  })

  describe('custom error handler', () => {
    beforeEach(() => {
      app = new Hono()
      app.post(
        '/text-limit-15byte-custom',
        bodyLimit({
          maxSize: 15,
          onError: (c) => {
            return c.text('no', 413)
          },
        }),
        (c) => {
          return c.text('yes')
        }
      )
    })

    it('should return the custom error handler', async () => {
      const res = await app.request(
        '/text-limit-15byte-custom',
        buildRequestInit({ body: exampleText2 })
      )

      expect(res).not.toBeNull()
      expect(res.status).toBe(413)
      expect(await res.text()).toBe('no')
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/body-limit/index.ts
````typescript
/**
 * @module
 * Body Limit Middleware for Hono.
 */

import type { Context } from '../../context'
import { HTTPException } from '../../http-exception'
import type { MiddlewareHandler } from '../../types'

const ERROR_MESSAGE = 'Payload Too Large'

type OnError = (c: Context) => Response | Promise<Response>
type BodyLimitOptions = {
  maxSize: number
  onError?: OnError
}

class BodyLimitError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'BodyLimitError'
  }
}

/**
 * Body Limit Middleware for Hono.
 *
 * @see {@link https://hono.dev/docs/middleware/builtin/body-limit}
 *
 * @param {BodyLimitOptions} options - The options for the body limit middleware.
 * @param {number} options.maxSize - The maximum body size allowed.
 * @param {OnError} [options.onError] - The error handler to be invoked if the specified body size is exceeded.
 * @returns {MiddlewareHandler} The middleware handler function.
 *
 * @example
 * ```ts
 * const app = new Hono()
 *
 * app.post(
 *   '/upload',
 *   bodyLimit({
 *     maxSize: 50 * 1024, // 50kb
 *     onError: (c) => {
 *       return c.text('overflow :(', 413)
 *     },
 *   }),
 *   async (c) => {
 *     const body = await c.req.parseBody()
 *     if (body['file'] instanceof File) {
 *       console.log(`Got file sized: ${body['file'].size}`)
 *     }
 *     return c.text('pass :)')
 *   }
 * )
 * ```
 */
export const bodyLimit = (options: BodyLimitOptions): MiddlewareHandler => {
  const onError: OnError =
    options.onError ||
    (() => {
      const res = new Response(ERROR_MESSAGE, {
        status: 413,
      })
      throw new HTTPException(413, { res })
    })
  const maxSize = options.maxSize

  return async function bodyLimit(c, next) {
    if (!c.req.raw.body) {
      // maybe GET or HEAD request
      return next()
    }

    if (c.req.raw.headers.has('content-length')) {
      // we can trust content-length header because it's already validated by server
      const contentLength = parseInt(c.req.raw.headers.get('content-length') || '0', 10)
      return contentLength > maxSize ? onError(c) : next()
    }

    // maybe chunked transfer encoding

    let size = 0
    const rawReader = c.req.raw.body.getReader()
    const reader = new ReadableStream({
      async start(controller) {
        try {
          for (;;) {
            const { done, value } = await rawReader.read()
            if (done) {
              break
            }
            size += value.length
            if (size > maxSize) {
              controller.error(new BodyLimitError(ERROR_MESSAGE))
              break
            }

            controller.enqueue(value)
          }
        } finally {
          controller.close()
        }
      },
    })

    const requestInit: RequestInit & { duplex: 'half' } = { body: reader, duplex: 'half' }
    c.req.raw = new Request(c.req.raw, requestInit as RequestInit)

    await next()

    if (c.error instanceof BodyLimitError) {
      c.res = await onError(c)
    }
  }
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/bearer-auth/index.test.ts
```typescript
import { Hono } from '../../hono'
import { bearerAuth } from '.'

describe('Bearer Auth by Middleware', () => {
  let app: Hono
  let handlerExecuted: boolean
  let token: string
  let tokens: string[]

  beforeEach(async () => {
    app = new Hono()
    handlerExecuted = false
    token = 'abcdefg12345-._~+/='
    tokens = ['abcdefg12345-._~+/=', 'alternative']

    app.use('/auth/*', bearerAuth({ token }))
    app.use('/auth/*', async (c, next) => {
      c.header('x-custom', 'foo')
      await next()
    })
    app.get('/auth/*', (c) => {
      handlerExecuted = true
      return c.text('auth')
    })

    app.use('/authBot/*', bearerAuth({ token, prefix: 'Bot' }))
    app.get('/authBot/*', (c) => {
      handlerExecuted = true
      return c.text('auth bot')
    })

    app.use('/apiKey/*', bearerAuth({ token, prefix: '', headerName: 'X-Api-Key' }))
    app.get('/apiKey/*', (c) => {
      handlerExecuted = true
      return c.text('auth apiKey')
    })

    app.use('/nested/*', async (c, next) => {
      const auth = bearerAuth({ token })
      return auth(c, next)
    })
    app.get('/nested/*', (c) => {
      handlerExecuted = true
      return c.text('auth nested')
    })

    app.use('/auths/*', bearerAuth({ token: tokens }))
    app.get('/auths/*', (c) => {
      handlerExecuted = true
      return c.text('auths')
    })

    app.use(
      '/auth-verify-token/*',
      bearerAuth({
        verifyToken: async (token, c) => {
          return c.req.path === '/auth-verify-token' && token === 'dynamic-token'
        },
      })
    )
    app.get('/auth-verify-token/*', (c) => {
      handlerExecuted = true
      return c.text('auth-verify-token')
    })

    app.use('/auth-custom-header/*', bearerAuth({ token: tokens, headerName: 'X-Auth' }))
    app.get('/auth-custom-header/*', (c) => {
      handlerExecuted = true
      return c.text('auth-custom-header')
    })

    app.use(
      '/auth-custom-no-authentication-header-message-string/*',
      bearerAuth({
        token,
        noAuthenticationHeaderMessage: 'Custom no authentication header message as string',
      })
    )
    app.get('/auth-custom-no-authentication-header-message-string/*', (c) => {
      handlerExecuted = true
      return c.text('auth')
    })

    app.use(
      '/auth-custom-no-authentication-header-message-object/*',
      bearerAuth({
        token,
        noAuthenticationHeaderMessage: {
          message: 'Custom no authentication header message as object',
        },
      })
    )
    app.get('/auth-custom-no-authentication-header-message-object/*', (c) => {
      handlerExecuted = true
      return c.text('auth')
    })

    app.use(
      '/auth-custom-no-authentication-header-message-function-string/*',
      bearerAuth({
        token,
        noAuthenticationHeaderMessage: () =>
          'Custom no authentication header message as function string',
      })
    )
    app.get('/auth-custom-no-authentication-header-message-function-string/*', (c) => {
      handlerExecuted = true
      return c.text('auth')
    })

    app.use(
      '/auth-custom-no-authentication-header-message-function-object/*',
      bearerAuth({
        token,
        noAuthenticationHeaderMessage: () => ({
          message: 'Custom no authentication header message as function object',
        }),
      })
    )
    app.get('/auth-custom-no-authentication-header-message-function-object/*', (c) => {
      handlerExecuted = true
      return c.text('auth')
    })

    app.use(
      '/auth-custom-invalid-authentication-header-message-string/*',
      bearerAuth({
        token,
        invalidAuthenticationHeaderMessage:
          'Custom invalid authentication header message as string',
      })
    )
    app.get('/auth-custom-invalid-authentication-header-message-string/*', (c) => {
      handlerExecuted = true
      return c.text('auth')
    })

    app.use(
      '/auth-custom-invalid-authentication-header-message-object/*',
      bearerAuth({
        token,
        invalidAuthenticationHeaderMessage: {
          message: 'Custom invalid authentication header message as object',
        },
      })
    )
    app.get('/auth-custom-invalid-authentication-header-message-object/*', (c) => {
      handlerExecuted = true
      return c.text('auth')
    })

    app.use(
      '/auth-custom-invalid-authentication-header-message-function-string/*',
      bearerAuth({
        token,
        invalidAuthenticationHeaderMessage: () =>
          'Custom invalid authentication header message as function string',
      })
    )
    app.get('/auth-custom-invalid-authentication-header-message-function-string/*', (c) => {
      handlerExecuted = true
      return c.text('auth')
    })

    app.use(
      '/auth-custom-invalid-authentication-header-message-function-object/*',
      bearerAuth({
        token,
        invalidAuthenticationHeaderMessage: () => ({
          message: 'Custom invalid authentication header message as function object',
        }),
      })
    )
    app.get('/auth-custom-invalid-authentication-header-message-function-object/*', (c) => {
      handlerExecuted = true
      return c.text('auth')
    })

    app.use(
      '/auth-custom-invalid-token-message-string/*',
      bearerAuth({
        token,
        invalidTokenMessage: 'Custom invalid token message as string',
      })
    )
    app.get('/auth-custom-invalid-token-message-string/*', (c) => {
      handlerExecuted = true
      return c.text('auth')
    })

    app.use(
      '/auth-custom-invalid-token-message-object/*',
      bearerAuth({
        token,
        invalidTokenMessage: { message: 'Custom invalid token message as object' },
      })
    )
    app.get('/auth-custom-invalid-token-message-object/*', (c) => {
      handlerExecuted = true
      return c.text('auth')
    })

    app.use(
      '/auth-custom-invalid-token-message-function-string/*',
      bearerAuth({
        token,
        invalidTokenMessage: () => 'Custom invalid token message as function string',
      })
    )
    app.get('/auth-custom-invalid-token-message-function-string/*', (c) => {
      handlerExecuted = true
      return c.text('auth')
    })

    app.use(
      '/auth-custom-invalid-token-message-function-object/*',
      bearerAuth({
        token,
        invalidTokenMessage: () => ({
          message: 'Custom invalid token message as function object',
        }),
      })
    )
    app.get('/auth-custom-invalid-token-message-function-object/*', (c) => {
      handlerExecuted = true
      return c.text('auth')
    })
  })

  it('Should authorize', async () => {
    const req = new Request('http://localhost/auth/a')
    req.headers.set('Authorization', 'Bearer abcdefg12345-._~+/=')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(handlerExecuted).toBeTruthy()
    expect(await res.text()).toBe('auth')
    expect(res.headers.get('x-custom')).toBe('foo')
  })

  it('Should not authorize - no authorization header', async () => {
    const req = new Request('http://localhost/auth/a')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(401)
    expect(handlerExecuted).toBeFalsy()
    expect(await res.text()).toBe('Unauthorized')
    expect(res.headers.get('x-custom')).toBeNull()
  })

  it('Should not authorize - invalid request', async () => {
    const req = new Request('http://localhost/auth/a')
    req.headers.set('Authorization', 'Beare abcdefg12345-._~+/=')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(handlerExecuted).toBeFalsy()
    expect(res.status).toBe(400)
    expect(await res.text()).toBe('Bad Request')
    expect(res.headers.get('x-custom')).toBeNull()
  })

  it('Should not authorize - invalid token', async () => {
    const req = new Request('http://localhost/auth/a')
    req.headers.set('Authorization', 'Bearer invalid-token')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(401)
    expect(await res.text()).toBe('Unauthorized')
    expect(res.headers.get('x-custom')).toBeNull()
  })

  it('Should authorize', async () => {
    const req = new Request('http://localhost/authBot/a')
    req.headers.set('Authorization', 'Bot abcdefg12345-._~+/=')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(handlerExecuted).toBeTruthy()
    expect(await res.text()).toBe('auth bot')
  })

  it('Should not authorize - invalid request', async () => {
    const req = new Request('http://localhost/authBot/a')
    req.headers.set('Authorization', 'Bearer abcdefg12345-._~+/=')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(handlerExecuted).toBeFalsy()
    expect(res.status).toBe(400)
    expect(await res.text()).toBe('Bad Request')
  })

  it('Should authorize', async () => {
    const req = new Request('http://localhost/apiKey/a')
    req.headers.set('X-Api-Key', 'abcdefg12345-._~+/=')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(handlerExecuted).toBeTruthy()
    expect(await res.text()).toBe('auth apiKey')
  })

  it('Should not authorize - invalid request', async () => {
    const req = new Request('http://localhost/apiKey/a')
    req.headers.set('Authorization', 'Bearer abcdefg12345-._~+/=')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(handlerExecuted).toBeFalsy()
    expect(res.status).toBe(401)
    expect(await res.text()).toBe('Unauthorized')
  })

  it('Should authorize - nested', async () => {
    const req = new Request('http://localhost/nested/a')
    req.headers.set('Authorization', 'Bearer abcdefg12345-._~+/=')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(handlerExecuted).toBeTruthy()
    expect(await res.text()).toBe('auth nested')
  })

  it('Should not authorize - nested', async () => {
    const req = new Request('http://localhost/nested/a')
    req.headers.set('Authorization', 'Bearer invalid-token')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(handlerExecuted).toBeFalsy()
    expect(res.status).toBe(401)
    expect(await res.text()).toBe('Unauthorized')
  })

  it('Should authorize - with any token in list', async () => {
    const req1 = new Request('http://localhost/auths/a')
    req1.headers.set('Authorization', 'Bearer abcdefg12345-._~+/=')
    const res1 = await app.request(req1)
    expect(res1).not.toBeNull()
    expect(res1.status).toBe(200)
    expect(handlerExecuted).toBeTruthy()
    expect(await res1.text()).toBe('auths')

    const req2 = new Request('http://localhost/auths/a')
    req2.headers.set('Authorization', 'Bearer alternative')
    const res2 = await app.request(req2)
    expect(res2).not.toBeNull()
    expect(res2.status).toBe(200)
    expect(handlerExecuted).toBeTruthy()
    expect(await res2.text()).toBe('auths')
  })

  it('Should authorize - verifyToken option', async () => {
    const res = await app.request('/auth-verify-token', {
      headers: { Authorization: 'Bearer dynamic-token' },
    })
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(handlerExecuted).toBeTruthy()
    expect(await res.text()).toBe('auth-verify-token')
  })

  it('Should not authorize - verifyToken option', async () => {
    const res = await app.request('/auth-verify-token', {
      headers: { Authorization: 'Bearer invalid-token' },
    })
    expect(res).not.toBeNull()
    expect(handlerExecuted).toBeFalsy()
    expect(res.status).toBe(401)
  })

  it('Should authorize - custom header', async () => {
    const req = new Request('http://localhost/auth-custom-header/a')
    req.headers.set('X-Auth', 'Bearer abcdefg12345-._~+/=')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(handlerExecuted).toBeTruthy()
    expect(await res.text()).toBe('auth-custom-header')
  })

  it('Should not authorize - custom header', async () => {
    const req = new Request('http://localhost/auth-custom-header/a')
    req.headers.set('X-Auth', 'Bearer invalid-token')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(handlerExecuted).toBeFalsy()
    expect(res.status).toBe(401)
    expect(await res.text()).toBe('Unauthorized')
  })

  it('Should not authorize - custom no authorization header message as string', async () => {
    const req = new Request('http://localhost/auth-custom-no-authentication-header-message-string')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(401)
    expect(handlerExecuted).toBeFalsy()
    expect(await res.text()).toBe('Custom no authentication header message as string')
  })

  it('Should not authorize - custom no authorization header message as object', async () => {
    const req = new Request('http://localhost/auth-custom-no-authentication-header-message-object')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(401)
    expect(res.headers.get('Content-Type')).toMatch('application/json')
    expect(handlerExecuted).toBeFalsy()
    expect(await res.text()).toBe('{"message":"Custom no authentication header message as object"}')
  })

  it('Should not authorize - custom no authorization header message as function string', async () => {
    const req = new Request(
      'http://localhost/auth-custom-no-authentication-header-message-function-string'
    )
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(401)
    expect(handlerExecuted).toBeFalsy()
    expect(await res.text()).toBe('Custom no authentication header message as function string')
  })

  it('Should not authorize - custom no authorization header message as function object', async () => {
    const req = new Request(
      'http://localhost/auth-custom-no-authentication-header-message-function-object'
    )
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(401)
    expect(res.headers.get('Content-Type')).toMatch('application/json')
    expect(handlerExecuted).toBeFalsy()
    expect(await res.text()).toBe(
      '{"message":"Custom no authentication header message as function object"}'
    )
  })

  it('Should not authorize - custom invalid authentication header message as string', async () => {
    const req = new Request(
      'http://localhost/auth-custom-invalid-authentication-header-message-string'
    )
    req.headers.set('Authorization', 'Beare abcdefg12345-._~+/=')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(400)
    expect(handlerExecuted).toBeFalsy()
    expect(await res.text()).toBe('Custom invalid authentication header message as string')
  })

  it('Should not authorize - custom invalid authentication header message as object', async () => {
    const req = new Request(
      'http://localhost/auth-custom-invalid-authentication-header-message-object'
    )
    req.headers.set('Authorization', 'Beare abcdefg12345-._~+/=')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(400)
    expect(res.headers.get('Content-Type')).toMatch('application/json')
    expect(handlerExecuted).toBeFalsy()
    expect(await res.text()).toBe(
      '{"message":"Custom invalid authentication header message as object"}'
    )
  })

  it('Should not authorize - custom invalid authentication header message as function string', async () => {
    const req = new Request(
      'http://localhost/auth-custom-invalid-authentication-header-message-function-string'
    )
    req.headers.set('Authorization', 'Beare abcdefg12345-._~+/=')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(400)
    expect(handlerExecuted).toBeFalsy()
    expect(await res.text()).toBe('Custom invalid authentication header message as function string')
  })

  it('Should not authorize - custom invalid authentication header message as function object', async () => {
    const req = new Request(
      'http://localhost/auth-custom-invalid-authentication-header-message-function-object'
    )
    req.headers.set('Authorization', 'Beare abcdefg12345-._~+/=')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(400)
    expect(res.headers.get('Content-Type')).toMatch('application/json')
    expect(handlerExecuted).toBeFalsy()
    expect(await res.text()).toBe(
      '{"message":"Custom invalid authentication header message as function object"}'
    )
  })

  it('Should not authorize - custom invalid token message as string', async () => {
    const req = new Request('http://localhost/auth-custom-invalid-token-message-string')
    req.headers.set('Authorization', 'Bearer invalid-token')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(401)
    expect(handlerExecuted).toBeFalsy()
    expect(await res.text()).toBe('Custom invalid token message as string')
  })

  it('Should not authorize - custom invalid token message as object', async () => {
    const req = new Request('http://localhost/auth-custom-invalid-token-message-object')
    req.headers.set('Authorization', 'Bearer invalid-token')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(401)
    expect(res.headers.get('Content-Type')).toMatch('application/json')
    expect(handlerExecuted).toBeFalsy()
    expect(await res.text()).toBe('{"message":"Custom invalid token message as object"}')
  })

  it('Should not authorize - custom invalid token message as function string', async () => {
    const req = new Request('http://localhost/auth-custom-invalid-token-message-function-string')
    req.headers.set('Authorization', 'Bearer invalid-token')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(401)
    expect(handlerExecuted).toBeFalsy()
    expect(await res.text()).toBe('Custom invalid token message as function string')
  })

  it('Should not authorize - custom invalid token message as function object', async () => {
    const req = new Request('http://localhost/auth-custom-invalid-token-message-function-object')
    req.headers.set('Authorization', 'Bearer invalid-token')
    const res = await app.request(req)
    expect(res).not.toBeNull()
    expect(res.status).toBe(401)
    expect(res.headers.get('Content-Type')).toMatch('application/json')
    expect(handlerExecuted).toBeFalsy()
    expect(await res.text()).toBe('{"message":"Custom invalid token message as function object"}')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/bearer-auth/index.ts
````typescript
/**
 * @module
 * Bearer Auth Middleware for Hono.
 */

import type { Context } from '../../context'
import { HTTPException } from '../../http-exception'
import type { MiddlewareHandler } from '../../types'
import { timingSafeEqual } from '../../utils/buffer'
import type { ContentfulStatusCode } from '../../utils/http-status'

const TOKEN_STRINGS = '[A-Za-z0-9._~+/-]+=*'
const PREFIX = 'Bearer'
const HEADER = 'Authorization'

type MessageFunction = (c: Context) => string | object | Promise<string | object>

type BearerAuthOptions =
  | {
      token: string | string[]
      realm?: string
      prefix?: string
      headerName?: string
      hashFunction?: Function
      noAuthenticationHeaderMessage?: string | object | MessageFunction
      invalidAuthenticationHeaderMessage?: string | object | MessageFunction
      invalidTokenMessage?: string | object | MessageFunction
    }
  | {
      realm?: string
      prefix?: string
      headerName?: string
      verifyToken: (token: string, c: Context) => boolean | Promise<boolean>
      hashFunction?: Function
      noAuthenticationHeaderMessage?: string | object | MessageFunction
      invalidAuthenticationHeaderMessage?: string | object | MessageFunction
      invalidTokenMessage?: string | object | MessageFunction
    }

/**
 * Bearer Auth Middleware for Hono.
 *
 * @see {@link https://hono.dev/docs/middleware/builtin/bearer-auth}
 *
 * @param {BearerAuthOptions} options - The options for the bearer authentication middleware.
 * @param {string | string[]} [options.token] - The string or array of strings to validate the incoming bearer token against.
 * @param {Function} [options.verifyToken] - The function to verify the token.
 * @param {string} [options.realm=""] - The domain name of the realm, as part of the returned WWW-Authenticate challenge header.
 * @param {string} [options.prefix="Bearer"] - The prefix (or known as `schema`) for the Authorization header value. If set to the empty string, no prefix is expected.
 * @param {string} [options.headerName=Authorization] - The header name.
 * @param {Function} [options.hashFunction] - A function to handle hashing for safe comparison of authentication tokens.
 * @param {string | object | MessageFunction} [options.noAuthenticationHeaderMessage="Unauthorized"] - The no authentication header message.
 * @param {string | object | MessageFunction} [options.invalidAuthenticationHeaderMeasage="Bad Request"] - The invalid authentication header message.
 * @param {string | object | MessageFunction} [options.invalidTokenMessage="Unauthorized"] - The invalid token message.
 * @returns {MiddlewareHandler} The middleware handler function.
 * @throws {Error} If neither "token" nor "verifyToken" options are provided.
 * @throws {HTTPException} If authentication fails, with 401 status code for missing or invalid token, or 400 status code for invalid request.
 *
 * @example
 * ```ts
 * const app = new Hono()
 *
 * const token = 'honoishot'
 *
 * app.use('/api/*', bearerAuth({ token }))
 *
 * app.get('/api/page', (c) => {
 *   return c.json({ message: 'You are authorized' })
 * })
 * ```
 */
export const bearerAuth = (options: BearerAuthOptions): MiddlewareHandler => {
  if (!('token' in options || 'verifyToken' in options)) {
    throw new Error('bearer auth middleware requires options for "token"')
  }
  if (!options.realm) {
    options.realm = ''
  }
  if (options.prefix === undefined) {
    options.prefix = PREFIX
  }

  const realm = options.realm?.replace(/"/g, '\\"')
  const prefixRegexStr = options.prefix === '' ? '' : `${options.prefix} +`
  const regexp = new RegExp(`^${prefixRegexStr}(${TOKEN_STRINGS}) *$`)
  const wwwAuthenticatePrefix = options.prefix === '' ? '' : `${options.prefix} `

  const throwHTTPException = async (
    c: Context,
    status: ContentfulStatusCode,
    wwwAuthenticateHeader: string,
    messageOption: string | object | MessageFunction
  ): Promise<Response> => {
    const headers = {
      'WWW-Authenticate': wwwAuthenticateHeader,
    }
    const responseMessage =
      typeof messageOption === 'function' ? await messageOption(c) : messageOption
    const res =
      typeof responseMessage === 'string'
        ? new Response(responseMessage, { status, headers })
        : new Response(JSON.stringify(responseMessage), {
            status,
            headers: {
              ...headers,
              'content-type': 'application/json',
            },
          })
    throw new HTTPException(status, { res })
  }

  return async function bearerAuth(c, next) {
    const headerToken = c.req.header(options.headerName || HEADER)
    if (!headerToken) {
      // No Authorization header
      await throwHTTPException(
        c,
        401,
        `${wwwAuthenticatePrefix}realm="${realm}"`,
        options.noAuthenticationHeaderMessage || 'Unauthorized'
      )
    } else {
      const match = regexp.exec(headerToken)
      if (!match) {
        // Invalid Request
        await throwHTTPException(
          c,
          400,
          `${wwwAuthenticatePrefix}error="invalid_request"`,
          options.invalidAuthenticationHeaderMessage || 'Bad Request'
        )
      } else {
        let equal = false
        if ('verifyToken' in options) {
          equal = await options.verifyToken(match[1], c)
        } else if (typeof options.token === 'string') {
          equal = await timingSafeEqual(options.token, match[1], options.hashFunction)
        } else if (Array.isArray(options.token) && options.token.length > 0) {
          for (const token of options.token) {
            if (await timingSafeEqual(token, match[1], options.hashFunction)) {
              equal = true
              break
            }
          }
        }
        if (!equal) {
          // Invalid Token
          await throwHTTPException(
            c,
            401,
            `${wwwAuthenticatePrefix}error="invalid_token"`,
            options.invalidTokenMessage || 'Unauthorized'
          )
        }
      }
    }
    await next()
  }
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/cors/index.test.ts
```typescript
import { Hono } from '../../hono'
import { cors } from '../../middleware/cors'

describe('CORS by Middleware', () => {
  const app = new Hono()

  app.use('/api/*', cors())

  app.use(
    '/api2/*',
    cors({
      origin: 'http://example.com',
      allowHeaders: ['X-Custom-Header', 'Upgrade-Insecure-Requests'],
      allowMethods: ['POST', 'GET', 'OPTIONS'],
      exposeHeaders: ['Content-Length', 'X-Kuma-Revision'],
      maxAge: 600,
      credentials: true,
    })
  )

  app.use(
    '/api3/*',
    cors({
      origin: ['http://example.com', 'http://example.org', 'http://example.dev'],
    })
  )

  app.use(
    '/api4/*',
    cors({
      origin: (origin) => (origin.endsWith('.example.com') ? origin : 'http://example.com'),
    })
  )

  app.use('/api5/*', cors())

  app.use(
    '/api6/*',
    cors({
      origin: 'http://example.com',
    })
  )
  app.use(
    '/api6/*',
    cors({
      origin: 'http://example.com',
    })
  )

  app.get('/api/abc', (c) => {
    return c.json({ success: true })
  })

  app.get('/api2/abc', (c) => {
    return c.json({ success: true })
  })

  app.get('/api3/abc', (c) => {
    return c.json({ success: true })
  })

  app.get('/api4/abc', (c) => {
    return c.json({ success: true })
  })

  app.get('/api5/abc', () => {
    return new Response(JSON.stringify({ success: true }))
  })

  it('GET default', async () => {
    const res = await app.request('http://localhost/api/abc')

    expect(res.status).toBe(200)
    expect(res.headers.get('Access-Control-Allow-Origin')).toBe('*')
    expect(res.headers.get('Vary')).toBeNull()
  })

  it('Preflight default', async () => {
    const req = new Request('https://localhost/api/abc', { method: 'OPTIONS' })
    req.headers.append('Access-Control-Request-Headers', 'X-PINGOTHER, Content-Type')
    const res = await app.request(req)

    expect(res.status).toBe(204)
    expect(res.statusText).toBe('No Content')
    expect(res.headers.get('Access-Control-Allow-Methods')?.split(',')[0]).toBe('GET')
    expect(res.headers.get('Access-Control-Allow-Headers')?.split(',')).toEqual([
      'X-PINGOTHER',
      'Content-Type',
    ])
  })

  it('Preflight with options', async () => {
    const req = new Request('https://localhost/api2/abc', {
      method: 'OPTIONS',
      headers: { origin: 'http://example.com' },
    })
    const res = await app.request(req)

    expect(res.headers.get('Access-Control-Allow-Origin')).toBe('http://example.com')
    expect(res.headers.get('Vary')?.split(/\s*,\s*/)).toEqual(expect.arrayContaining(['Origin']))
    expect(res.headers.get('Access-Control-Allow-Headers')?.split(/\s*,\s*/)).toEqual([
      'X-Custom-Header',
      'Upgrade-Insecure-Requests',
    ])
    expect(res.headers.get('Access-Control-Allow-Methods')?.split(/\s*,\s*/)).toEqual([
      'POST',
      'GET',
      'OPTIONS',
    ])
    expect(res.headers.get('Access-Control-Expose-Headers')?.split(/\s*,\s*/)).toEqual([
      'Content-Length',
      'X-Kuma-Revision',
    ])
    expect(res.headers.get('Access-Control-Max-Age')).toBe('600')
    expect(res.headers.get('Access-Control-Allow-Credentials')).toBe('true')
  })

  it('Disallow an unmatched origin', async () => {
    const req = new Request('https://localhost/api2/abc', {
      method: 'OPTIONS',
      headers: { origin: 'http://example.net' },
    })
    const res = await app.request(req)
    expect(res.headers.has('Access-Control-Allow-Origin')).toBeFalsy()
  })

  it('Allow multiple origins', async () => {
    let req = new Request('http://localhost/api3/abc', {
      headers: {
        Origin: 'http://example.org',
      },
    })
    let res = await app.request(req)
    expect(res.headers.get('Access-Control-Allow-Origin')).toBe('http://example.org')

    req = new Request('http://localhost/api3/abc')
    res = await app.request(req)
    expect(
      res.headers.has('Access-Control-Allow-Origin'),
      'An unmatched origin should be disallowed'
    ).toBeFalsy()

    req = new Request('http://localhost/api3/abc', {
      headers: {
        Referer: 'http://example.net/',
      },
    })
    res = await app.request(req)
    expect(
      res.headers.has('Access-Control-Allow-Origin'),
      'An unmatched origin should be disallowed'
    ).toBeFalsy()
  })

  it('Allow different Vary header value', async () => {
    const res = await app.request('http://localhost/api3/abc', {
      headers: {
        Vary: 'accept-encoding',
        Origin: 'http://example.com',
      },
    })

    expect(res.status).toBe(200)
    expect(res.headers.get('Access-Control-Allow-Origin')).toBe('http://example.com')
    expect(res.headers.get('Vary')).toBe('accept-encoding')
  })

  it('Allow origins by function', async () => {
    let req = new Request('http://localhost/api4/abc', {
      headers: {
        Origin: 'http://subdomain.example.com',
      },
    })
    let res = await app.request(req)
    expect(res.headers.get('Access-Control-Allow-Origin')).toBe('http://subdomain.example.com')

    req = new Request('http://localhost/api4/abc')
    res = await app.request(req)
    expect(res.headers.get('Access-Control-Allow-Origin')).toBe('http://example.com')

    req = new Request('http://localhost/api4/abc', {
      headers: {
        Referer: 'http://evil-example.com/',
      },
    })
    res = await app.request(req)
    expect(res.headers.get('Access-Control-Allow-Origin')).toBe('http://example.com')
  })

  it('With raw Response object', async () => {
    const res = await app.request('http://localhost/api5/abc')

    expect(res.headers.get('Access-Control-Allow-Origin')).toBe('*')
    expect(res.headers.get('Vary')).toBeNull()
  })

  it('Should not return duplicate header values', async () => {
    const res = await app.request('http://localhost/api6/abc', {
      headers: {
        origin: 'http://example.com',
      },
    })

    expect(res.headers.get('Access-Control-Allow-Origin')).toBe('http://example.com')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/cors/index.ts
````typescript
/**
 * @module
 * CORS Middleware for Hono.
 */

import type { Context } from '../../context'
import type { MiddlewareHandler } from '../../types'

type CORSOptions = {
  origin: string | string[] | ((origin: string, c: Context) => string | undefined | null)
  allowMethods?: string[]
  allowHeaders?: string[]
  maxAge?: number
  credentials?: boolean
  exposeHeaders?: string[]
}

/**
 * CORS Middleware for Hono.
 *
 * @see {@link https://hono.dev/docs/middleware/builtin/cors}
 *
 * @param {CORSOptions} [options] - The options for the CORS middleware.
 * @param {string | string[] | ((origin: string, c: Context) => string | undefined | null)} [options.origin='*'] - The value of "Access-Control-Allow-Origin" CORS header.
 * @param {string[]} [options.allowMethods=['GET', 'HEAD', 'PUT', 'POST', 'DELETE', 'PATCH']] - The value of "Access-Control-Allow-Methods" CORS header.
 * @param {string[]} [options.allowHeaders=[]] - The value of "Access-Control-Allow-Headers" CORS header.
 * @param {number} [options.maxAge] - The value of "Access-Control-Max-Age" CORS header.
 * @param {boolean} [options.credentials] - The value of "Access-Control-Allow-Credentials" CORS header.
 * @param {string[]} [options.exposeHeaders=[]] - The value of "Access-Control-Expose-Headers" CORS header.
 * @returns {MiddlewareHandler} The middleware handler function.
 *
 * @example
 * ```ts
 * const app = new Hono()
 *
 * app.use('/api/*', cors())
 * app.use(
 *   '/api2/*',
 *   cors({
 *     origin: 'http://example.com',
 *     allowHeaders: ['X-Custom-Header', 'Upgrade-Insecure-Requests'],
 *     allowMethods: ['POST', 'GET', 'OPTIONS'],
 *     exposeHeaders: ['Content-Length', 'X-Kuma-Revision'],
 *     maxAge: 600,
 *     credentials: true,
 *   })
 * )
 *
 * app.all('/api/abc', (c) => {
 *   return c.json({ success: true })
 * })
 * app.all('/api2/abc', (c) => {
 *   return c.json({ success: true })
 * })
 * ```
 */
export const cors = (options?: CORSOptions): MiddlewareHandler => {
  const defaults: CORSOptions = {
    origin: '*',
    allowMethods: ['GET', 'HEAD', 'PUT', 'POST', 'DELETE', 'PATCH'],
    allowHeaders: [],
    exposeHeaders: [],
  }
  const opts = {
    ...defaults,
    ...options,
  }

  const findAllowOrigin = ((optsOrigin) => {
    if (typeof optsOrigin === 'string') {
      if (optsOrigin === '*') {
        return () => optsOrigin
      } else {
        return (origin: string) => (optsOrigin === origin ? origin : null)
      }
    } else if (typeof optsOrigin === 'function') {
      return optsOrigin
    } else {
      return (origin: string) => (optsOrigin.includes(origin) ? origin : null)
    }
  })(opts.origin)

  return async function cors(c, next) {
    function set(key: string, value: string) {
      c.res.headers.set(key, value)
    }

    const allowOrigin = findAllowOrigin(c.req.header('origin') || '', c)
    if (allowOrigin) {
      set('Access-Control-Allow-Origin', allowOrigin)
    }

    // Suppose the server sends a response with an Access-Control-Allow-Origin value with an explicit origin (rather than the "*" wildcard).
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin
    if (opts.origin !== '*') {
      const existingVary = c.req.header('Vary')

      if (existingVary) {
        set('Vary', existingVary)
      } else {
        set('Vary', 'Origin')
      }
    }

    if (opts.credentials) {
      set('Access-Control-Allow-Credentials', 'true')
    }

    if (opts.exposeHeaders?.length) {
      set('Access-Control-Expose-Headers', opts.exposeHeaders.join(','))
    }

    if (c.req.method === 'OPTIONS') {
      if (opts.maxAge != null) {
        set('Access-Control-Max-Age', opts.maxAge.toString())
      }

      if (opts.allowMethods?.length) {
        set('Access-Control-Allow-Methods', opts.allowMethods.join(','))
      }

      let headers = opts.allowHeaders
      if (!headers?.length) {
        const requestHeaders = c.req.header('Access-Control-Request-Headers')
        if (requestHeaders) {
          headers = requestHeaders.split(/\s*,\s*/)
        }
      }
      if (headers?.length) {
        set('Access-Control-Allow-Headers', headers.join(','))
        c.res.headers.append('Vary', 'Access-Control-Request-Headers')
      }

      c.res.headers.delete('Content-Length')
      c.res.headers.delete('Content-Type')

      return new Response(null, {
        headers: c.res.headers,
        status: 204,
        statusText: 'No Content',
      })
    }
    await next()
  }
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/serve-static/index.test.ts
```typescript
import { Hono } from '../../hono'
import { serveStatic as baseServeStatic } from '.'

describe('Serve Static Middleware', () => {
  const app = new Hono()
  const getContent = vi.fn(async (path) => {
    if (path.endsWith('not-found.txt')) {
      return null
    }
    return `Hello in ${path}`
  })

  const serveStatic = baseServeStatic({
    getContent,
    pathResolve: (path) => {
      return `./${path}`
    },
    isDir: (path) => {
      return path === 'static/hello.world'
    },
    onFound: (path, c) => {
      if (path.endsWith('hello.html')) {
        c.header('X-Custom', `Found the file at ${path}`)
      }
    },
  })

  app.get('/static/*', serveStatic)

  beforeEach(() => {
    getContent.mockClear()
  })

  it('Should return 200 response - /static/hello.html', async () => {
    const res = await app.request('/static/hello.html')
    expect(res.status).toBe(200)
    expect(res.headers.get('Content-Encoding')).toBeNull()
    expect(res.headers.get('Content-Type')).toMatch(/^text\/html/)
    expect(await res.text()).toBe('Hello in ./static/hello.html')
    expect(res.headers.get('X-Custom')).toBe('Found the file at ./static/hello.html')
  })

  it('Should return 200 response - /static/sub', async () => {
    const res = await app.request('/static/sub')
    expect(res.status).toBe(200)
    expect(res.headers.get('Content-Type')).toMatch(/^text\/html/)
    expect(await res.text()).toBe('Hello in ./static/sub/index.html')
  })

  it('Should return 200 response - /static/helloworld', async () => {
    const res = await app.request('/static/helloworld')
    expect(res.status).toBe(200)
    expect(res.headers.get('Content-Type')).toMatch(/^text\/html/)
    expect(await res.text()).toBe('Hello in ./static/helloworld/index.html')
  })

  it('Should return 200 response - /static/hello.world', async () => {
    const res = await app.request('/static/hello.world')
    expect(res.status).toBe(200)
    expect(res.headers.get('Content-Type')).toMatch(/^text\/html/)
    expect(await res.text()).toBe('Hello in ./static/hello.world/index.html')
  })

  it('Should decode URI strings - /static/%E7%82%8E.txt', async () => {
    const res = await app.request('/static/%E7%82%8E.txt')
    expect(res.status).toBe(200)
    expect(res.headers.get('Content-Type')).toMatch(/^text\/plain/)
    expect(await res.text()).toBe('Hello in ./static/炎.txt')
  })

  it('Should return 404 response - /static/not-found.txt', async () => {
    const res = await app.request('/static/not-found.txt')
    expect(res.status).toBe(404)
    expect(res.headers.get('Content-Encoding')).toBeNull()
    expect(res.headers.get('Content-Type')).toMatch(/^text\/plain/)
    expect(await res.text()).toBe('404 Not Found')
    expect(getContent).toBeCalledTimes(1)
  })

  it('Should not allow a directory traversal - /static/%2e%2e/static/hello.html', async () => {
    const res = await app.fetch({
      method: 'GET',
      url: 'http://localhost/static/%2e%2e/static/hello.html',
    } as Request)
    expect(res.status).toBe(404)
    expect(res.headers.get('Content-Type')).toMatch(/^text\/plain/)
    expect(await res.text()).toBe('404 Not Found')
  })

  it('Should return a pre-compressed zstd response - /static/hello.html', async () => {
    const app = new Hono().use(
      '*',
      baseServeStatic({
        getContent,
        precompressed: true,
      })
    )

    const res = await app.request('/static/hello.html', {
      headers: { 'Accept-Encoding': 'zstd' },
    })

    expect(res.status).toBe(200)
    expect(res.headers.get('Content-Encoding')).toBe('zstd')
    expect(res.headers.get('Vary')).toBe('Accept-Encoding')
    expect(res.headers.get('Content-Type')).toMatch(/^text\/html/)
    expect(await res.text()).toBe('Hello in static/hello.html.zst')
  })

  it('Should return a pre-compressed brotli response - /static/hello.html', async () => {
    const app = new Hono().use(
      '*',
      baseServeStatic({
        getContent,
        precompressed: true,
      })
    )

    const res = await app.request('/static/hello.html', {
      headers: { 'Accept-Encoding': 'wompwomp, gzip, br, deflate, zstd' },
    })

    expect(res.status).toBe(200)
    expect(res.headers.get('Content-Encoding')).toBe('br')
    expect(res.headers.get('Vary')).toBe('Accept-Encoding')
    expect(res.headers.get('Content-Type')).toMatch(/^text\/html/)
    expect(await res.text()).toBe('Hello in static/hello.html.br')
  })

  it('Should return a pre-compressed brotli response - /static/hello.unknown', async () => {
    const app = new Hono().use(
      '*',
      baseServeStatic({
        getContent,
        precompressed: true,
      })
    )

    const res = await app.request('/static/hello.unknown', {
      headers: { 'Accept-Encoding': 'wompwomp, gzip, br, deflate, zstd' },
    })

    expect(res.status).toBe(200)
    expect(res.headers.get('Content-Encoding')).toBe('br')
    expect(res.headers.get('Vary')).toBe('Accept-Encoding')
    expect(res.headers.get('Content-Type')).toBe('application/octet-stream')
    expect(await res.text()).toBe('Hello in static/hello.unknown.br')
  })

  it('Should not return a pre-compressed response - /static/not-found.txt', async () => {
    const app = new Hono().use(
      '*',
      baseServeStatic({
        getContent,
        precompressed: true,
      })
    )

    const res = await app.request('/static/not-found.txt', {
      headers: { 'Accept-Encoding': 'gzip, zstd, br' },
    })

    expect(res.status).toBe(404)
    expect(res.headers.get('Content-Encoding')).toBeNull()
    expect(res.headers.get('Vary')).toBeNull()
    expect(res.headers.get('Content-Type')).toMatch(/^text\/plain/)
    expect(await res.text()).toBe('404 Not Found')
  })

  it('Should not return a pre-compressed response - /static/hello.html', async () => {
    const app = new Hono().use(
      '*',
      baseServeStatic({
        getContent,
        precompressed: true,
      })
    )

    const res = await app.request('/static/hello.html', {
      headers: { 'Accept-Encoding': 'wompwomp, unknown' },
    })

    expect(res.status).toBe(200)
    expect(res.headers.get('Content-Encoding')).toBeNull()
    expect(res.headers.get('Vary')).toBeNull()
    expect(res.headers.get('Content-Type')).toMatch(/^text\/html/)
    expect(await res.text()).toBe('Hello in static/hello.html')
  })

  it('Should not find pre-compressed files - /static/hello.jpg', async () => {
    const app = new Hono().use(
      '*',
      baseServeStatic({
        getContent,
        precompressed: true,
      })
    )

    const res = await app.request('/static/hello.jpg', {
      headers: { 'Accept-Encoding': 'gzip, br, deflate, zstd' },
    })

    expect(res.status).toBe(200)
    expect(res.headers.get('Content-Encoding')).toBeNull()
    expect(res.headers.get('Vary')).toBeNull()
    expect(res.headers.get('Content-Type')).toMatch(/^image\/jpeg/)
    expect(await res.text()).toBe('Hello in static/hello.jpg')
  })

  it('Should return response object content as-is', async () => {
    const body = new ReadableStream()
    const response = new Response(body)
    const app = new Hono().use(
      '*',
      baseServeStatic({
        getContent: async () => {
          return response
        },
      })
    )

    const res = await app.fetch({
      method: 'GET',
      url: 'http://localhost',
    } as Request)
    expect(res.status).toBe(200)
    expect(res.body).toBe(body)
  })

  describe('Changing root path', () => {
    const pathResolve = (path: string) => {
      return path.startsWith('/') ? path : `./${path}`
    }

    it('Should return the content with absolute root path', async () => {
      const app = new Hono()
      const serveStatic = baseServeStatic({
        getContent,
        pathResolve,
        root: '/home/hono/child',
      })
      app.get('/static/*', serveStatic)

      const res = await app.request('/static/html/hello.html')
      expect(await res.text()).toBe('Hello in /home/hono/child/static/html/hello.html')
    })

    it('Should traverse the directories with absolute root path', async () => {
      const app = new Hono()
      const serveStatic = baseServeStatic({
        getContent,
        pathResolve,
        root: '/home/hono/../parent',
      })
      app.get('/static/*', serveStatic)

      const res = await app.request('/static/html/hello.html')
      expect(await res.text()).toBe('Hello in /home/parent/static/html/hello.html')
    })

    it('Should treat the root path includes .. as relative path', async () => {
      const app = new Hono()
      const serveStatic = baseServeStatic({
        getContent,
        pathResolve,
        root: '../home/hono',
      })
      app.get('/static/*', serveStatic)

      const res = await app.request('/static/html/hello.html')
      expect(await res.text()).toBe('Hello in ./../home/hono/static/html/hello.html')
    })

    it('Should not allow directory traversal with . as relative path', async () => {
      const app = new Hono()
      const serveStatic = baseServeStatic({
        getContent,
        pathResolve,
        root: '.',
      })
      app.get('*', serveStatic)

      const res = await app.request('///etc/passwd')
      expect(res.status).toBe(404)
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/serve-static/index.ts
```typescript
/**
 * @module
 * Serve Static Middleware for Hono.
 */

import type { Context, Data } from '../../context'
import type { Env, MiddlewareHandler } from '../../types'
import { COMPRESSIBLE_CONTENT_TYPE_REGEX } from '../../utils/compress'
import { getFilePath, getFilePathWithoutDefaultDocument } from '../../utils/filepath'
import { getMimeType } from '../../utils/mime'

export type ServeStaticOptions<E extends Env = Env> = {
  root?: string
  path?: string
  precompressed?: boolean
  mimes?: Record<string, string>
  rewriteRequestPath?: (path: string) => string
  onFound?: (path: string, c: Context<E>) => void | Promise<void>
  onNotFound?: (path: string, c: Context<E>) => void | Promise<void>
}

const ENCODINGS = {
  br: '.br',
  zstd: '.zst',
  gzip: '.gz',
} as const
const ENCODINGS_ORDERED_KEYS = Object.keys(ENCODINGS) as (keyof typeof ENCODINGS)[]

const DEFAULT_DOCUMENT = 'index.html'
const defaultPathResolve = (path: string) => path

/**
 * This middleware is not directly used by the user. Create a wrapper specifying `getContent()` by the environment such as Deno or Bun.
 */
export const serveStatic = <E extends Env = Env>(
  options: ServeStaticOptions<E> & {
    getContent: (path: string, c: Context<E>) => Promise<Data | Response | null>
    pathResolve?: (path: string) => string
    isDir?: (path: string) => boolean | undefined | Promise<boolean | undefined>
  }
): MiddlewareHandler => {
  let isAbsoluteRoot = false
  let root: string

  if (options.root) {
    if (options.root.startsWith('/')) {
      isAbsoluteRoot = true
      root = new URL(`file://${options.root}`).pathname
    } else {
      root = options.root
    }
  }

  return async (c, next) => {
    // Do nothing if Response is already set
    if (c.finalized) {
      await next()
      return
    }

    let filename = options.path ?? decodeURI(c.req.path)
    filename = options.rewriteRequestPath ? options.rewriteRequestPath(filename) : filename

    // If it was Directory, force `/` on the end.
    if (!filename.endsWith('/') && options.isDir) {
      const path = getFilePathWithoutDefaultDocument({
        filename,
        root,
      })
      if (path && (await options.isDir(path))) {
        filename += '/'
      }
    }

    let path = getFilePath({
      filename,
      root,
      defaultDocument: DEFAULT_DOCUMENT,
    })

    if (!path) {
      return await next()
    }

    if (isAbsoluteRoot) {
      path = '/' + path
    }

    const getContent = options.getContent
    const pathResolve = options.pathResolve ?? defaultPathResolve
    path = pathResolve(path)
    let content = await getContent(path, c)

    if (!content) {
      let pathWithoutDefaultDocument = getFilePathWithoutDefaultDocument({
        filename,
        root,
      })
      if (!pathWithoutDefaultDocument) {
        return await next()
      }
      pathWithoutDefaultDocument = pathResolve(pathWithoutDefaultDocument)

      if (pathWithoutDefaultDocument !== path) {
        content = await getContent(pathWithoutDefaultDocument, c)
        if (content) {
          path = pathWithoutDefaultDocument
        }
      }
    }

    if (content instanceof Response) {
      return c.newResponse(content.body, content)
    }

    if (content) {
      const mimeType = (options.mimes && getMimeType(path, options.mimes)) || getMimeType(path)
      c.header('Content-Type', mimeType || 'application/octet-stream')

      if (options.precompressed && (!mimeType || COMPRESSIBLE_CONTENT_TYPE_REGEX.test(mimeType))) {
        const acceptEncodingSet = new Set(
          c.req
            .header('Accept-Encoding')
            ?.split(',')
            .map((encoding) => encoding.trim())
        )

        for (const encoding of ENCODINGS_ORDERED_KEYS) {
          if (!acceptEncodingSet.has(encoding)) {
            continue
          }
          const compressedContent = (await getContent(path + ENCODINGS[encoding], c)) as Data | null

          if (compressedContent) {
            content = compressedContent
            c.header('Content-Encoding', encoding)
            c.header('Vary', 'Accept-Encoding', { append: true })
            break
          }
        }
      }
      await options.onFound?.(path, c)
      return c.body(content)
    }

    await options.onNotFound?.(path, c)
    await next()
    return
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/context-storage/index.test.ts
```typescript
import { Hono } from '../../hono'
import { contextStorage, getContext } from '.'

describe('Context Storage Middleware', () => {
  type Env = {
    Variables: {
      message: string
    }
  }

  const app = new Hono<Env>()

  app.use(contextStorage())
  app.use(async (c, next) => {
    c.set('message', 'Hono is hot!!')
    await next()
  })
  app.get('/', (c) => {
    return c.text(getMessage())
  })

  const getMessage = () => {
    return getContext<Env>().var.message
  }

  it('Should get context', async () => {
    const res = await app.request('/')
    expect(await res.text()).toBe('Hono is hot!!')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/context-storage/index.ts
````typescript
/**
 * @module
 * Context Storage Middleware for Hono.
 */

import { AsyncLocalStorage } from 'node:async_hooks'
import type { Context } from '../../context'
import type { Env, MiddlewareHandler } from '../../types'

const asyncLocalStorage = new AsyncLocalStorage<Context>()

/**
 * Context Storage Middleware for Hono.
 *
 * @see {@link https://hono.dev/docs/middleware/builtin/context-storage}
 *
 * @returns {MiddlewareHandler} The middleware handler function.
 *
 * @example
 * ```ts
 * type Env = {
 *   Variables: {
 *     message: string
 *   }
 * }
 *
 * const app = new Hono<Env>()
 *
 * app.use(contextStorage())
 *
 * app.use(async (c, next) => {
 *   c.set('message', 'Hono is hot!!)
 *   await next()
 * })
 *
 * app.get('/', async (c) => { c.text(getMessage()) })
 *
 * const getMessage = () => {
 *   return getContext<Env>().var.message
 * }
 * ```
 */
export const contextStorage = (): MiddlewareHandler => {
  return async function contextStorage(c, next) {
    await asyncLocalStorage.run(c, next)
  }
}

export const getContext = <E extends Env = Env>(): Context<E> => {
  const context = asyncLocalStorage.getStore()
  if (!context) {
    throw new Error('Context is not available')
  }
  return context
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/ip-restriction/index.test.ts
```typescript
import { Context } from '../../context'
import type { AddressType, GetConnInfo } from '../../helper/conninfo'
import { Hono } from '../../hono'
import { ipRestriction } from '.'
import type { IPRestrictionRule } from '.'

describe('ipRestriction middleware', () => {
  it('Should restrict', async () => {
    const getConnInfo: GetConnInfo = (c) => {
      return {
        remote: {
          address: c.env.ip,
        },
      }
    }
    const app = new Hono<{
      Bindings: {
        ip: string
      }
    }>()
    app.use(
      '/basic',
      ipRestriction(getConnInfo, {
        allowList: ['192.168.1.0', '192.168.2.0/24'],
        denyList: ['192.168.2.10'],
      })
    )
    app.get('/basic', (c) => c.text('Hello World!'))

    app.use(
      '/allow-empty',
      ipRestriction(getConnInfo, {
        denyList: ['192.168.1.0'],
      })
    )
    app.get('/allow-empty', (c) => c.text('Hello World!'))

    expect((await app.request('/basic', {}, { ip: '0.0.0.0' })).status).toBe(403)

    expect((await app.request('/basic', {}, { ip: '192.168.1.0' })).status).toBe(200)

    expect((await app.request('/basic', {}, { ip: '192.168.2.5' })).status).toBe(200)
    expect((await app.request('/basic', {}, { ip: '192.168.2.10' })).status).toBe(403)

    expect((await app.request('/allow-empty', {}, { ip: '0.0.0.0' })).status).toBe(200)

    expect((await app.request('/allow-empty', {}, { ip: '192.168.1.0' })).status).toBe(403)

    expect((await app.request('/allow-empty', {}, { ip: '192.168.2.5' })).status).toBe(200)
    expect((await app.request('/allow-empty', {}, { ip: '192.168.2.10' })).status).toBe(200)
  })
  it('Custom onerror', async () => {
    const res = await ipRestriction(
      () => '0.0.0.0',
      { denyList: ['0.0.0.0'] },
      () => new Response('error')
    )(new Context(new Request('http://localhost/')), async () => void 0)
    expect(res).toBeTruthy()
    if (res) {
      expect(await res.text()).toBe('error')
    }
  })
})

describe('isMatchForRule', () => {
  const isMatch = async (info: { addr: string; type: AddressType }, rule: IPRestrictionRule) => {
    const middleware = ipRestriction(
      () => ({
        remote: {
          address: info.addr,
          addressType: info.type,
        },
      }),
      {
        allowList: [rule],
      }
    )
    try {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      await middleware(undefined as any, () => Promise.resolve())
    } catch {
      return false
    }
    return true
  }

  it('star', async () => {
    expect(await isMatch({ addr: '192.168.2.0', type: 'IPv4' }, '*')).toBeTruthy()
    expect(await isMatch({ addr: '192.168.2.1', type: 'IPv4' }, '*')).toBeTruthy()
    expect(await isMatch({ addr: '::0', type: 'IPv6' }, '*')).toBeTruthy()
  })
  it('CIDR Notation', async () => {
    expect(await isMatch({ addr: '192.168.2.0', type: 'IPv4' }, '192.168.2.0/24')).toBeTruthy()
    expect(await isMatch({ addr: '192.168.2.1', type: 'IPv4' }, '192.168.2.0/24')).toBeTruthy()
    expect(await isMatch({ addr: '192.168.2.1', type: 'IPv4' }, '192.168.2.1/32')).toBeTruthy()
    expect(await isMatch({ addr: '192.168.2.1', type: 'IPv4' }, '192.168.2.2/32')).toBeFalsy()

    expect(await isMatch({ addr: '::0', type: 'IPv6' }, '::0/1')).toBeTruthy()
  })
  it('Static Rules', async () => {
    expect(await isMatch({ addr: '192.168.2.1', type: 'IPv4' }, '192.168.2.1')).toBeTruthy()
    expect(await isMatch({ addr: '1234::5678', type: 'IPv6' }, '1234::5678')).toBeTruthy()
    expect(
      await isMatch({ addr: '::ffff:127.0.0.1', type: 'IPv6' }, '::ffff:127.0.0.1')
    ).toBeTruthy()
    expect(await isMatch({ addr: '::ffff:127.0.0.1', type: 'IPv6' }, '::ffff:7f00:1')).toBeTruthy()
  })
  it('Function Rules', async () => {
    expect(await isMatch({ addr: '0.0.0.0', type: 'IPv4' }, () => true)).toBeTruthy()
    expect(await isMatch({ addr: '0.0.0.0', type: 'IPv4' }, () => false)).toBeFalsy()

    const ipaddr = '93.184.216.34'
    await isMatch({ addr: ipaddr, type: 'IPv4' }, (ip) => {
      expect(ipaddr).toBe(ip.addr)
      return false
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/ip-restriction/index.ts
```typescript
/**
 * IP Restriction Middleware for Hono
 * @module
 */

import type { Context, MiddlewareHandler } from '../..'
import type { AddressType, GetConnInfo } from '../../helper/conninfo'
import { HTTPException } from '../../http-exception'
import {
  convertIPv4ToBinary,
  convertIPv6BinaryToString,
  convertIPv6ToBinary,
  distinctRemoteAddr,
} from '../../utils/ipaddr'

/**
 * Function to get IP Address
 */
type GetIPAddr = GetConnInfo | ((c: Context) => string)

/**
 * ### IPv4 and IPv6
 * - `*` match all
 *
 * ### IPv4
 * - `192.168.2.0` static
 * - `192.168.2.0/24` CIDR Notation
 *
 * ### IPv6
 * - `::1` static
 * - `::1/10` CIDR Notation
 */
type IPRestrictionRuleFunction = (addr: { addr: string; type: AddressType }) => boolean
export type IPRestrictionRule = string | ((addr: { addr: string; type: AddressType }) => boolean)

const IS_CIDR_NOTATION_REGEX = /\/[0-9]{0,3}$/
const buildMatcher = (
  rules: IPRestrictionRule[]
): ((addr: { addr: string; type: AddressType; isIPv4: boolean }) => boolean) => {
  const functionRules: IPRestrictionRuleFunction[] = []
  const staticRules: Set<string> = new Set()
  const cidrRules: [boolean, bigint, bigint][] = []

  for (let rule of rules) {
    if (rule === '*') {
      return () => true
    } else if (typeof rule === 'function') {
      functionRules.push(rule)
    } else {
      if (IS_CIDR_NOTATION_REGEX.test(rule)) {
        const separatedRule = rule.split('/')

        const addrStr = separatedRule[0]
        const type = distinctRemoteAddr(addrStr)
        if (type === undefined) {
          throw new TypeError(`Invalid rule: ${rule}`)
        }

        const isIPv4 = type === 'IPv4'
        const prefix = parseInt(separatedRule[1])

        if (isIPv4 ? prefix === 32 : prefix === 128) {
          // this rule is a static rule
          rule = addrStr
        } else {
          const addr = (isIPv4 ? convertIPv4ToBinary : convertIPv6ToBinary)(addrStr)
          const mask = ((1n << BigInt(prefix)) - 1n) << BigInt((isIPv4 ? 32 : 128) - prefix)

          cidrRules.push([isIPv4, addr & mask, mask] as [boolean, bigint, bigint])
          continue
        }
      }

      const type = distinctRemoteAddr(rule)
      if (type === undefined) {
        throw new TypeError(`Invalid rule: ${rule}`)
      }
      staticRules.add(
        type === 'IPv4'
          ? rule // IPv4 address is already normalized, so it is registered as is.
          : convertIPv6BinaryToString(convertIPv6ToBinary(rule)) // normalize IPv6 address (e.g. 0000:0000:0000:0000:0000:0000:0000:0001 => ::1)
      )
    }
  }

  return (remote: {
    addr: string
    type: AddressType
    isIPv4: boolean
    binaryAddr?: bigint
  }): boolean => {
    if (staticRules.has(remote.addr)) {
      return true
    }
    for (const [isIPv4, addr, mask] of cidrRules) {
      if (isIPv4 !== remote.isIPv4) {
        continue
      }
      const remoteAddr = (remote.binaryAddr ||= (
        isIPv4 ? convertIPv4ToBinary : convertIPv6ToBinary
      )(remote.addr))
      if ((remoteAddr & mask) === addr) {
        return true
      }
    }
    for (const rule of functionRules) {
      if (rule({ addr: remote.addr, type: remote.type })) {
        return true
      }
    }
    return false
  }
}

/**
 * Rules for IP Restriction Middleware
 */
export interface IPRestrictionRules {
  denyList?: IPRestrictionRule[]
  allowList?: IPRestrictionRule[]
}

/**
 * IP Restriction Middleware
 *
 * @param getIP function to get IP Address
 */
export const ipRestriction = (
  getIP: GetIPAddr,
  { denyList = [], allowList = [] }: IPRestrictionRules,
  onError?: (
    remote: { addr: string; type: AddressType },
    c: Context
  ) => Response | Promise<Response>
): MiddlewareHandler => {
  const allowLength = allowList.length

  const denyMatcher = buildMatcher(denyList)
  const allowMatcher = buildMatcher(allowList)

  const blockError = (c: Context): HTTPException =>
    new HTTPException(403, {
      res: c.text('Forbidden', {
        status: 403,
      }),
    })

  return async function ipRestriction(c, next) {
    const connInfo = getIP(c)
    const addr = typeof connInfo === 'string' ? connInfo : connInfo.remote.address
    if (!addr) {
      throw blockError(c)
    }
    const type =
      (typeof connInfo !== 'string' && connInfo.remote.addressType) || distinctRemoteAddr(addr)

    const remoteData = { addr, type, isIPv4: type === 'IPv4' }

    if (denyMatcher(remoteData)) {
      if (onError) {
        return onError({ addr, type }, c)
      }
      throw blockError(c)
    }
    if (allowMatcher(remoteData)) {
      return await next()
    }

    if (allowLength === 0) {
      return await next()
    } else {
      if (onError) {
        return await onError({ addr, type }, c)
      }
      throw blockError(c)
    }
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/etag/digest.ts
```typescript
const mergeBuffers = (buffer1: ArrayBuffer | undefined, buffer2: Uint8Array): Uint8Array => {
  if (!buffer1) {
    return buffer2
  }
  const merged = new Uint8Array(buffer1.byteLength + buffer2.byteLength)
  merged.set(new Uint8Array(buffer1), 0)
  merged.set(buffer2, buffer1.byteLength)
  return merged
}

export const generateDigest = async (
  stream: ReadableStream<Uint8Array> | null,
  generator: (body: Uint8Array) => ArrayBuffer | Promise<ArrayBuffer>
): Promise<string | null> => {
  if (!stream) {
    return null
  }

  let result: ArrayBuffer | undefined = undefined

  const reader = stream.getReader()
  for (;;) {
    const { value, done } = await reader.read()
    if (done) {
      break
    }

    result = await generator(mergeBuffers(result, value))
  }

  if (!result) {
    return null
  }

  return Array.prototype.map
    .call(new Uint8Array(result), (x) => x.toString(16).padStart(2, '0'))
    .join('')
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/etag/index.test.ts
```typescript
import { Hono } from '../../hono'
import { RETAINED_304_HEADERS, etag } from '.'

describe('Etag Middleware', () => {
  it('Should return etag header', async () => {
    const app = new Hono()
    app.use('/etag/*', etag())
    app.get('/etag/abc', (c) => {
      return c.text('Hono is hot')
    })
    app.get('/etag/def', (c) => {
      return c.json({ message: 'Hono is hot' })
    })
    let res = await app.request('http://localhost/etag/abc')
    expect(res.headers.get('ETag')).not.toBeFalsy()
    expect(res.headers.get('ETag')).toBe('"d104fafdb380655dab607c9bddc4d4982037afa1"')

    res = await app.request('http://localhost/etag/def')
    expect(res.headers.get('ETag')).not.toBeFalsy()
    expect(res.headers.get('ETag')).toBe('"67340414f1a52c4669a6cec71f0ae04532b29249"')
  })

  it('Should return etag header with another algorithm', async () => {
    const app = new Hono()
    app.use(
      '/etag/*',
      etag({
        generateDigest: (body) =>
          crypto.subtle.digest(
            {
              name: 'SHA-256',
            },
            body
          ),
      })
    )
    app.get('/etag/abc', (c) => {
      return c.text('Hono is hot')
    })
    app.get('/etag/def', (c) => {
      return c.json({ message: 'Hono is hot' })
    })
    let res = await app.request('http://localhost/etag/abc')
    expect(res.headers.get('ETag')).not.toBeFalsy()
    expect(res.headers.get('ETag')).toBe(
      '"ed00834279b4fd5dcdc7ab6a5c9774de8afb2de30da2c8e0f17d0952839b5370"'
    )

    res = await app.request('http://localhost/etag/def')
    expect(res.headers.get('ETag')).not.toBeFalsy()
    expect(res.headers.get('ETag')).toBe(
      '"83b61a767db6e22afea68dd645b4d4597a06276c8ce7f895ad865cf4ab154ec4"'
    )
  })

  it('Should return etag header - binary', async () => {
    const app = new Hono()
    app.use('/etag/*', etag())
    app.get('/etag', async (c) => {
      return c.body(new Uint8Array(1))
    })

    const res = await app.request('http://localhost/etag')
    expect(res.headers.get('ETag')).not.toBeFalsy()
    const etagHeader = res.headers.get('ETag')
    expect(etagHeader).toBe('"5ba93c9db0cff93f52b521d7420e43f6eda2784f"')
  })

  it('Should not be the same etag - arrayBuffer', async () => {
    const app = new Hono()
    app.use('/etag/*', etag())
    app.get('/etag/ab1', (c) => {
      return c.body(new ArrayBuffer(1))
    })
    app.get('/etag/ab2', (c) => {
      return c.body(new ArrayBuffer(2))
    })

    let res = await app.request('http://localhost/etag/ab1')
    const hash = res.headers.get('Etag')
    res = await app.request('http://localhost/etag/ab2')
    expect(res.headers.get('ETag')).not.toBe(hash)
  })

  it('Should not be the same etag - Uint8Array', async () => {
    const app = new Hono()
    app.use('/etag/*', etag())
    app.get('/etag/ui1', (c) => {
      return c.body(new Uint8Array([1, 2, 3]))
    })
    app.get('/etag/ui2', (c) => {
      return c.body(new Uint8Array([1, 2, 3, 4]))
    })

    let res = await app.request('http://localhost/etag/ui1')
    const hash = res.headers.get('Etag')
    res = await app.request('http://localhost/etag/ui2')
    expect(res.headers.get('ETag')).not.toBe(hash)
  })

  it('Should not be the same etag - ReadableStream', async () => {
    const app = new Hono()
    app.use('/etag/*', etag())
    app.get('/etag/rs1', (c) => {
      return c.body(
        new ReadableStream({
          start(controller) {
            controller.enqueue(new Uint8Array([1]))
            controller.enqueue(new Uint8Array([2]))
            controller.close()
          },
        })
      )
    })
    app.get('/etag/rs2', (c) => {
      return c.body(
        new ReadableStream({
          start(controller) {
            controller.enqueue(new Uint8Array([1]))
            controller.enqueue(new Uint8Array([3]))
            controller.close()
          },
        })
      )
    })

    let res = await app.request('http://localhost/etag/rs1')
    const hash = res.headers.get('Etag')
    res = await app.request('http://localhost/etag/rs2')
    expect(res.headers.get('ETag')).not.toBe(hash)
  })

  it('Should not return etag header when the stream is empty', async () => {
    const app = new Hono()
    app.use('/etag/*', etag())
    app.get('/etag/abc', (c) => {
      const stream = new ReadableStream({
        start(controller) {
          controller.close()
        },
      })
      return c.body(stream)
    })
    const res = await app.request('http://localhost/etag/abc')
    expect(res.status).toBe(200)
    expect(res.headers.get('ETag')).toBeNull()
  })

  it('Should not return etag header when body is null', async () => {
    const app = new Hono()
    app.use('/etag/*', etag())
    app.get('/etag/abc', () => new Response(null, { status: 500 }))
    const res = await app.request('http://localhost/etag/abc')
    expect(res.status).toBe(500)
    expect(res.headers.get('ETag')).toBeNull()
  })

  it('Should return etag header - weak', async () => {
    const app = new Hono()
    app.use('/etag/*', etag({ weak: true }))
    app.get('/etag/abc', (c) => {
      return c.text('Hono is hot')
    })

    const res = await app.request('http://localhost/etag/abc')
    expect(res.headers.get('ETag')).not.toBeFalsy()
    expect(res.headers.get('ETag')).toBe('W/"d104fafdb380655dab607c9bddc4d4982037afa1"')
  })

  it('Should handle conditional GETs', async () => {
    const app = new Hono()
    app.use('/etag/*', etag())
    app.get('/etag/ghi', (c) =>
      c.text('Hono is great', 200, {
        'cache-control': 'public, max-age=120',
        date: 'Mon, Feb 27 2023 12:08:36 GMT',
        expires: 'Mon, Feb 27 2023 12:10:36 GMT',
        server: 'Upstream 1.2',
        vary: 'Accept-Language',
      })
    )

    // unconditional GET
    let res = await app.request('http://localhost/etag/ghi')
    expect(res.status).toBe(200)
    expect(res.headers.get('ETag')).not.toBeFalsy()
    const etagHeaderValue = res.headers.get('ETag') || ''

    // conditional GET with the wrong ETag:
    res = await app.request('http://localhost/etag/ghi', {
      headers: {
        'If-None-Match': '"not the right etag"',
      },
    })
    expect(res.status).toBe(200)

    // conditional GET with matching ETag:
    res = await app.request('http://localhost/etag/ghi', {
      headers: {
        'If-None-Match': etagHeaderValue,
      },
    })
    expect(res.status).toBe(304)
    expect(res.headers.get('Etag')).toBe(etagHeaderValue)
    expect(await res.text()).toBe('')
    expect(res.headers.get('cache-control')).toBe('public, max-age=120')
    expect(res.headers.get('date')).toBe('Mon, Feb 27 2023 12:08:36 GMT')
    expect(res.headers.get('expires')).toBe('Mon, Feb 27 2023 12:10:36 GMT')
    expect(res.headers.get('server')).toBeFalsy()
    expect(res.headers.get('vary')).toBe('Accept-Language')

    // conditional GET with matching ETag among list:
    res = await app.request('http://localhost/etag/ghi', {
      headers: {
        'If-None-Match': `"mismatch 1", ${etagHeaderValue}, "mismatch 2"`,
      },
    })
    expect(res.status).toBe(304)
  })

  it('Should not return duplicate etag header values', async () => {
    const app = new Hono()
    app.use('/etag/*', etag())
    app.use('/etag/*', etag())
    app.get('/etag/abc', (c) => c.text('Hono is hot'))

    const res = await app.request('http://localhost/etag/abc')
    expect(res.headers.get('ETag')).not.toBeFalsy()
    expect(res.headers.get('ETag')).toBe('"d104fafdb380655dab607c9bddc4d4982037afa1"')
  })

  it('Should not override ETag headers from upstream', async () => {
    const app = new Hono()
    app.use('/etag/*', etag())
    app.get('/etag/predefined', (c) =>
      c.text('This response has an ETag', 200, { ETag: '"f-0194-d"' })
    )

    const res = await app.request('http://localhost/etag/predefined')
    expect(res.headers.get('ETag')).toBe('"f-0194-d"')
  })

  it('Should retain the default and the specified headers', async () => {
    const cacheControl = 'public, max-age=120'
    const message = 'Hello!'
    const app = new Hono()
    app.use(
      '/etag/*',
      etag({
        retainedHeaders: ['x-message-retain', ...RETAINED_304_HEADERS],
      })
    )
    app.get('/etag', (c) => {
      return c.text('Hono is hot', 200, {
        'cache-control': cacheControl,
        'x-message-retain': message,
        'x-message': message,
      })
    })
    const res = await app.request('/etag', {
      headers: {
        'If-None-Match': '"d104fafdb380655dab607c9bddc4d4982037afa1"',
      },
    })
    expect(res.status).toBe(304)
    expect(res.headers.get('ETag')).not.toBeFalsy()
    expect(res.headers.get('ETag')).toBe('"d104fafdb380655dab607c9bddc4d4982037afa1"')
    expect(res.headers.get('Cache-Control')).toBe(cacheControl)
    expect(res.headers.get('x-message-retain')).toBe(message)
    expect(res.headers.get('x-message')).toBeFalsy()
  })

  describe('When crypto is not available', () => {
    let _crypto: Crypto | undefined
    beforeAll(() => {
      _crypto = globalThis.crypto
      Object.defineProperty(globalThis, 'crypto', {
        value: {},
      })
    })

    afterAll(() => {
      Object.defineProperty(globalThis, 'crypto', {
        value: _crypto,
      })
    })

    it('Should not generate etag', async () => {
      const app = new Hono()
      app.use('/etag/*', etag())
      app.get('/etag/no-digest', (c) => c.text('Hono is hot'))
      const res = await app.request('/etag/no-digest')
      expect(res.status).toBe(200)
      expect(res.headers.get('ETag')).toBeNull()
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/etag/index.ts
````typescript
/**
 * @module
 * ETag Middleware for Hono.
 */

import type { MiddlewareHandler } from '../../types'
import { generateDigest } from './digest'

type ETagOptions = {
  retainedHeaders?: string[]
  weak?: boolean
  generateDigest?: (body: Uint8Array) => ArrayBuffer | Promise<ArrayBuffer>
}

/**
 * Default headers to pass through on 304 responses. From the spec:
 * > The response must not contain a body and must include the headers that
 * > would have been sent in an equivalent 200 OK response: Cache-Control,
 * > Content-Location, Date, ETag, Expires, and Vary.
 */
export const RETAINED_304_HEADERS = [
  'cache-control',
  'content-location',
  'date',
  'etag',
  'expires',
  'vary',
]

function etagMatches(etag: string, ifNoneMatch: string | null) {
  return ifNoneMatch != null && ifNoneMatch.split(/,\s*/).indexOf(etag) > -1
}

function initializeGenerator(
  generator?: ETagOptions['generateDigest']
): ETagOptions['generateDigest'] | undefined {
  if (!generator) {
    if (crypto && crypto.subtle) {
      generator = (body: Uint8Array) =>
        crypto.subtle.digest(
          {
            name: 'SHA-1',
          },
          body
        )
    }
  }

  return generator
}

/**
 * ETag Middleware for Hono.
 *
 * @see {@link https://hono.dev/docs/middleware/builtin/etag}
 *
 * @param {ETagOptions} [options] - The options for the ETag middleware.
 * @param {boolean} [options.weak=false] - Define using or not using a weak validation. If true is set, then `W/` is added to the prefix of the value.
 * @param {string[]} [options.retainedHeaders=RETAINED_304_HEADERS] - The headers that you want to retain in the 304 Response.
 * @param {function(Uint8Array): ArrayBuffer | Promise<ArrayBuffer>} [options.generateDigest] -
 * A custom digest generation function. By default, it uses 'SHA-1'
 * This function is called with the response body as a `Uint8Array` and should return a hash as an `ArrayBuffer` or a Promise of one.
 * @returns {MiddlewareHandler} The middleware handler function.
 *
 * @example
 * ```ts
 * const app = new Hono()
 *
 * app.use('/etag/*', etag())
 * app.get('/etag/abc', (c) => {
 *   return c.text('Hono is hot')
 * })
 * ```
 */
export const etag = (options?: ETagOptions): MiddlewareHandler => {
  const retainedHeaders = options?.retainedHeaders ?? RETAINED_304_HEADERS
  const weak = options?.weak ?? false
  const generator = initializeGenerator(options?.generateDigest)

  return async function etag(c, next) {
    const ifNoneMatch = c.req.header('If-None-Match') ?? null

    await next()

    const res = c.res as Response
    let etag = res.headers.get('ETag')

    if (!etag) {
      if (!generator) {
        return
      }
      const hash = await generateDigest(res.clone().body, generator)
      if (hash === null) {
        return
      }
      etag = weak ? `W/"${hash}"` : `"${hash}"`
    }

    if (etagMatches(etag, ifNoneMatch)) {
      c.res = new Response(null, {
        status: 304,
        statusText: 'Not Modified',
        headers: {
          ETag: etag,
        },
      })
      c.res.headers.forEach((_, key) => {
        if (retainedHeaders.indexOf(key.toLowerCase()) === -1) {
          c.res.headers.delete(key)
        }
      })
    } else {
      c.res.headers.set('ETag', etag)
    }
  }
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/trailing-slash/index.test.ts
```typescript
import { Hono } from '../../hono'
import { appendTrailingSlash, trimTrailingSlash } from '.'

describe('Resolve trailing slash', () => {
  let app: Hono

  it('Trim', async () => {
    app = new Hono({ strict: true })

    app.use('*', trimTrailingSlash())

    app.get('/', async (c) => {
      return c.text('ok')
    })
    app.get('/the/example/endpoint/without/trailing/slash', async (c) => {
      return c.text('ok')
    })

    let resp: Response, loc: URL

    resp = await app.request('/')
    expect(resp).not.toBeNull()
    expect(resp.status).toBe(200)

    resp = await app.request('/the/example/endpoint/without/trailing/slash')
    expect(resp).not.toBeNull()
    expect(resp.status).toBe(200)

    resp = await app.request('/the/example/endpoint/without/trailing/slash/')
    loc = new URL(resp.headers.get('location')!)
    expect(resp).not.toBeNull()
    expect(resp.status).toBe(301)
    expect(loc.pathname).toBe('/the/example/endpoint/without/trailing/slash')

    resp = await app.request('/the/example/endpoint/without/trailing/slash/?exampleParam=1')
    loc = new URL(resp.headers.get('location')!)
    expect(resp).not.toBeNull()
    expect(resp.status).toBe(301)
    expect(loc.pathname).toBe('/the/example/endpoint/without/trailing/slash')
    expect(loc.searchParams.get('exampleParam')).toBe('1')
  })

  it('Append', async () => {
    app = new Hono({ strict: true })

    app.use('*', appendTrailingSlash())

    app.get('/', async (c) => {
      return c.text('ok')
    })
    app.get('/the/example/endpoint/with/trailing/slash/', async (c) => {
      return c.text('ok')
    })
    app.get('/the/example/simulate/a.file', async (c) => {
      return c.text('ok')
    })

    let resp: Response, loc: URL

    resp = await app.request('/')
    expect(resp).not.toBeNull()
    expect(resp.status).toBe(200)

    resp = await app.request('/the/example/simulate/a.file')
    expect(resp).not.toBeNull()
    expect(resp.status).toBe(200)

    resp = await app.request('/the/example/endpoint/with/trailing/slash/')
    expect(resp).not.toBeNull()
    expect(resp.status).toBe(200)

    resp = await app.request('/the/example/endpoint/with/trailing/slash')
    loc = new URL(resp.headers.get('location')!)
    expect(resp).not.toBeNull()
    expect(resp.status).toBe(301)
    expect(loc.pathname).toBe('/the/example/endpoint/with/trailing/slash/')

    resp = await app.request('/the/example/endpoint/with/trailing/slash?exampleParam=1')
    loc = new URL(resp.headers.get('location')!)
    expect(resp).not.toBeNull()
    expect(resp.status).toBe(301)
    expect(loc.pathname).toBe('/the/example/endpoint/with/trailing/slash/')
    expect(loc.searchParams.get('exampleParam')).toBe('1')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/trailing-slash/index.ts
````typescript
/**
 * @module
 * Trailing Slash Middleware for Hono.
 */

import type { MiddlewareHandler } from '../../types'

/**
 * Trailing Slash Middleware for Hono.
 *
 * @see {@link https://hono.dev/docs/middleware/builtin/trailing-slash}
 *
 * @returns {MiddlewareHandler} The middleware handler function.
 *
 * @example
 * ```ts
 * const app = new Hono()
 *
 * app.use(trimTrailingSlash())
 * app.get('/about/me/', (c) => c.text('With Trailing Slash'))
 * ```
 */
export const trimTrailingSlash = (): MiddlewareHandler => {
  return async function trimTrailingSlash(c, next) {
    await next()

    if (
      c.res.status === 404 &&
      c.req.method === 'GET' &&
      c.req.path !== '/' &&
      c.req.path.at(-1) === '/'
    ) {
      const url = new URL(c.req.url)
      url.pathname = url.pathname.substring(0, url.pathname.length - 1)

      c.res = c.redirect(url.toString(), 301)
    }
  }
}

/**
 * Append trailing slash middleware for Hono.
 * Append a trailing slash to the URL if it doesn't have one. For example, `/path/to/page` will be redirected to `/path/to/page/`.
 *
 * @see {@link https://hono.dev/docs/middleware/builtin/trailing-slash}
 *
 * @returns {MiddlewareHandler} The middleware handler function.
 *
 * @example
 * ```ts
 * const app = new Hono()
 *
 * app.use(appendTrailingSlash())
 * ```
 */
export const appendTrailingSlash = (): MiddlewareHandler => {
  return async function appendTrailingSlash(c, next) {
    await next()

    if (c.res.status === 404 && c.req.method === 'GET' && c.req.path.at(-1) !== '/') {
      const url = new URL(c.req.url)
      url.pathname += '/'

      c.res = c.redirect(url.toString(), 301)
    }
  }
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/request-id/index.test.ts
```typescript
import type { Context } from '../../context'
import { Hono } from '../../hono'
import { requestId } from '.'

const regexUUIDv4 = /([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})/

describe('Request ID Middleware', () => {
  const app = new Hono()
  app.use('*', requestId())
  app.get('/requestId', (c) => c.text(c.get('requestId') ?? 'No Request ID'))

  it('Should return random request id', async () => {
    const res = await app.request('http://localhost/requestId')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('X-Request-Id')).toMatch(regexUUIDv4)
    expect(await res.text()).match(regexUUIDv4)
  })

  it('Should return custom request id', async () => {
    const res = await app.request('http://localhost/requestId', {
      headers: {
        'X-Request-Id': 'hono-is-hot',
      },
    })
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('X-Request-Id')).toBe('hono-is-hot')
    expect(await res.text()).toBe('hono-is-hot')
  })

  it('Should return random request id without using request header', async () => {
    const res = await app.request('http://localhost/requestId', {
      headers: {
        'X-Request-Id': 'Hello!12345-@*^',
      },
    })
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('X-Request-Id')).toMatch(regexUUIDv4)
    expect(await res.text()).toMatch(regexUUIDv4)
  })
})

describe('Request ID Middleware with custom generator', () => {
  function generateWord() {
    return 'HonoIsWebFramework'
  }
  function generateDoubleRequestId(c: Context) {
    const honoId = c.req.header('Hono-Request-Id')
    const ohnoId = c.req.header('Ohno-Request-Id')
    if (honoId && ohnoId) {
      return honoId + ohnoId
    }
    return crypto.randomUUID()
  }
  const app = new Hono()
  app.use('/word', requestId({ generator: generateWord }))
  app.use('/doubleRequestId', requestId({ generator: generateDoubleRequestId }))
  app.get('/word', (c) => c.text(c.get('requestId') ?? 'No Request ID'))
  app.get('/doubleRequestId', (c) => c.text(c.get('requestId') ?? 'No Request ID'))
  it('Should return custom request id', async () => {
    const res = await app.request('http://localhost/word')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('X-Request-Id')).toBe('HonoIsWebFramework')
    expect(await res.text()).toBe('HonoIsWebFramework')
  })

  it('Should return complex request id', async () => {
    const res = await app.request('http://localhost/doubleRequestId', {
      headers: {
        'Hono-Request-Id': 'Hello',
        'Ohno-Request-Id': 'World',
      },
    })
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('X-Request-Id')).toBe('HelloWorld')
    expect(await res.text()).toBe('HelloWorld')
  })
})

describe('Request ID Middleware with limit length', () => {
  const charactersOf255 = 'h'.repeat(255)
  const charactersOf256 = 'h'.repeat(256)

  const app = new Hono()
  app.use('/requestId', requestId())
  app.use('/limit256', requestId({ limitLength: 256 }))
  app.get('/requestId', (c) => c.text(c.get('requestId') ?? 'No Request ID'))
  app.get('/limit256', (c) => c.text(c.get('requestId') ?? 'No Request ID'))

  it('Should return custom request id', async () => {
    const res = await app.request('http://localhost/requestId', {
      headers: {
        'X-Request-Id': charactersOf255,
      },
    })
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('X-Request-Id')).toBe(charactersOf255)
    expect(await res.text()).toBe(charactersOf255)
  })
  it('Should return random request id without using request header', async () => {
    const res = await app.request('http://localhost/requestId', {
      headers: {
        'X-Request-Id': charactersOf256,
      },
    })
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('X-Request-Id')).toMatch(regexUUIDv4)
    expect(await res.text()).toMatch(regexUUIDv4)
  })
  it('Should return custom request id with 256 characters', async () => {
    const res = await app.request('http://localhost/limit256', {
      headers: {
        'X-Request-Id': charactersOf256,
      },
    })
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('X-Request-Id')).toBe(charactersOf256)
    expect(await res.text()).toBe(charactersOf256)
  })
})

describe('Request ID Middleware with custom header', () => {
  const app = new Hono()
  app.use('/requestId', requestId({ headerName: 'Hono-Request-Id' }))
  app.get('/emptyId', requestId({ headerName: '' }))
  app.get('/requestId', (c) => c.text(c.get('requestId') ?? 'No Request ID'))
  app.get('/emptyId', (c) => c.text(c.get('requestId') ?? 'No Request ID'))

  it('Should return custom request id', async () => {
    const res = await app.request('http://localhost/requestId', {
      headers: {
        'Hono-Request-Id': 'hono-is-hot',
      },
    })
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('Hono-Request-Id')).toBe('hono-is-hot')
    expect(await res.text()).toBe('hono-is-hot')
  })

  it('Should not return request id', async () => {
    const res = await app.request('http://localhost/emptyId')
    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('X-Request-Id')).toBeNull()
    expect(await res.text()).toMatch(regexUUIDv4)
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/request-id/index.ts
```typescript
import type { RequestIdVariables } from './request-id'
export type { RequestIdVariables }
export { requestId } from './request-id'

declare module '../..' {
  interface ContextVariableMap extends RequestIdVariables {}
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/middleware/request-id/request-id.ts
````typescript
/**
 * @module
 * Request ID Middleware for Hono.
 */

import type { Context } from '../../context'
import type { MiddlewareHandler } from '../../types'

export type RequestIdVariables = {
  requestId: string
}

export type RequestIdOptions = {
  limitLength?: number
  headerName?: string
  generator?: (c: Context) => string
}

/**
 * Request ID Middleware for Hono.
 *
 * @param {object} options - Options for Request ID middleware.
 * @param {number} [options.limitLength=255] - The maximum length of request id.
 * @param {string} [options.headerName=X-Request-Id] - The header name used in request id.
 * @param {generator} [options.generator=() => crypto.randomUUID()] - The request id generation function.
 *
 * @returns {MiddlewareHandler} The middleware handler function.
 *
 * @example
 * ```ts
 * type Variables = RequestIdVariables
 * const app = new Hono<{Variables: Variables}>()
 *
 * app.use(requestId())
 * app.get('/', (c) => {
 *   console.log(c.get('requestId')) // Debug
 *   return c.text('Hello World!')
 * })
 * ```
 */
export const requestId = ({
  limitLength = 255,
  headerName = 'X-Request-Id',
  generator = () => crypto.randomUUID(),
}: RequestIdOptions = {}): MiddlewareHandler => {
  return async function requestId(c, next) {
    // If `headerName` is empty string, req.header will return the object
    let reqId = headerName ? c.req.header(headerName) : undefined
    if (!reqId || reqId.length > limitLength || /[^\w\-]/.test(reqId)) {
      reqId = generator(c)
    }

    c.set('requestId', reqId)
    if (headerName) {
      c.header(headerName, reqId)
    }
    await next()
  }
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/validator/index.ts
```typescript
/**
 * @module
 * Validator for Hono.
 */

export { validator } from './validator'
export type { ValidationFunction } from './validator'

```
/Users/josh/Documents/GitHub/honojs/hono/src/validator/validator.test.ts
```typescript
/* eslint-disable @typescript-eslint/no-unused-vars */
import type { ZodSchema } from 'zod'
import { z } from 'zod'
import { Hono } from '../hono'
import { HTTPException } from '../http-exception'
import type {
  ErrorHandler,
  ExtractSchema,
  MiddlewareHandler,
  ParsedFormValue,
  ValidationTargets,
} from '../types'
import type { ContentfulStatusCode } from '../utils/http-status'
import type { Equal, Expect } from '../utils/types'
import type { ValidationFunction } from './validator'
import { validator } from './validator'

// Reference implementation for only testing
const zodValidator = <
  T extends ZodSchema,
  E extends {},
  P extends string,
  Target extends keyof ValidationTargets
>(
  target: Target,
  schema: T
): MiddlewareHandler<
  E,
  P,
  { in: { [K in Target]: z.input<T> }; out: { [K in Target]: z.output<T> } }
> =>
  validator(target, (value, c) => {
    const result = schema.safeParse(value)
    if (!result.success) {
      return c.text('Invalid!', 400)
    }
    const data = result.data as z.output<T>
    return data
  })

describe('Basic', () => {
  const app = new Hono()

  const route = app.get(
    '/search',
    async (_c, next) => {
      await next()
    },
    validator('query', (value, c) => {
      type verify = Expect<Equal<Record<string, string | string[]>, typeof value>>
      if (!value) {
        return c.text('Invalid!', 400)
      }
    }),
    (c) => {
      return c.text('Valid!')
    }
  )

  type Expected = {
    '/search': {
      $get: {
        input: {
          query: undefined
        }
        output: 'Valid!'
        outputFormat: 'text'
        status: ContentfulStatusCode
      }
    }
  }

  type Actual = ExtractSchema<typeof route>

  type verify = Expect<Equal<Expected, Actual>>

  it('Should return 200 response', async () => {
    const res = await app.request('http://localhost/search?q=foo')
    expect(res.status).toBe(200)
  })

  it('Should return 400 response', async () => {
    const res = await app.request('http://localhost/search')
    expect(res.status).toBe(200)
  })
})

const onErrorHandler: ErrorHandler = (e, c) => {
  if (e instanceof HTTPException) {
    return c.json({ message: e.message, success: false }, e.status)
  }
  return c.json({ message: e.message }, 500)
}

describe('JSON', () => {
  const app = new Hono()
  app.post(
    '/post',
    validator('json', (value) => value),
    (c) => {
      return c.json(c.req.valid('json'))
    }
  )

  it('Should return 200 response with a valid JSON data', async () => {
    const res = await app.request('http://localhost/post', {
      method: 'POST',
      body: JSON.stringify({ foo: 'bar' }),
      headers: {
        'Content-Type': 'application/json',
      },
    })
    expect(res.status).toBe(200)
    const data = await res.json()
    expect(data).toEqual({ foo: 'bar' })
  })

  it('Should not validate if Content-Type is not set', async () => {
    const res = await app.request('http://localhost/post', {
      method: 'POST',
      body: JSON.stringify({ foo: 'bar' }),
    })
    expect(res.status).toBe(200)
    const data = await res.json()
    expect(data.foo).toBeUndefined()
  })

  it('Should not validate if Content-Type is wrong', async () => {
    const res = await app.request('http://localhost/post', {
      method: 'POST',
      headers: {
        'Content-Type': 'text/plain;charset=utf-8',
      },
      body: JSON.stringify({ foo: 'bar' }),
    })
    expect(res.status).toBe(200)
  })

  it('Should validate if Content-Type is a application/json with a charset', async () => {
    const res = await app.request('http://localhost/post', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ foo: 'bar' }),
    })
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({ foo: 'bar' })
  })

  it('Should validate if Content-Type is a subtype like application/merge-patch+json', async () => {
    const res = await app.request('http://localhost/post', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/merge-patch+json',
      },
      body: JSON.stringify({ foo: 'bar' }),
    })
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({ foo: 'bar' })
  })

  it('Should validate if Content-Type is application/vnd.api+json', async () => {
    const res = await app.request('http://localhost/post', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/vnd.api+json',
      },
      body: JSON.stringify({ foo: 'bar' }),
    })
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({ foo: 'bar' })
  })

  it('Should not validate if Content-Type does not start with application/json', async () => {
    const res = await app.request('http://localhost/post', {
      method: 'POST',
      headers: {
        'Content-Type': 'Xapplication/json',
      },
      body: JSON.stringify({ foo: 'bar' }),
    })
    expect(res.status).toBe(200)
    const data = await res.json()
    expect(data.foo).toBeUndefined()
  })
})

describe('Malformed JSON', () => {
  const app = new Hono()
  app.post(
    '/post',
    validator('json', (value) => value),
    (c) => {
      return c.json(c.req.valid('json'))
    }
  )

  it('Should return 400 response if the body data is not a valid JSON', async () => {
    const formData = new FormData()
    formData.append('foo', 'bar')
    const res = await app.request('http://localhost/post', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: formData,
    })
    expect(res.status).toBe(400)
  })
})

describe('FormData', () => {
  const app = new Hono()
  app.post(
    '/post',
    validator('form', (value) => value),
    (c) => {
      return c.json(c.req.valid('form'))
    }
  )

  it('Should return 200 response with a valid form data', async () => {
    const formData = new FormData()
    formData.append('message', 'hi')
    const res = await app.request('http://localhost/post', {
      method: 'POST',
      body: formData,
    })
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({ message: 'hi' })
  })

  it('Should validate a URL Encoded Data', async () => {
    const params = new URLSearchParams()
    params.append('foo', 'bar')
    const res = await app.request('/post', {
      method: 'POST',
      body: params,
      headers: {
        'content-type': 'application/x-www-form-urlencoded',
      },
    })
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({
      foo: 'bar',
    })
  })

  it('Should validate if Content-Type is a application/x-www-form-urlencoded with a charset', async () => {
    const params = new URLSearchParams()
    params.append('foo', 'bar')
    const res = await app.request('/post', {
      method: 'POST',
      body: params,
      headers: {
        'content-type': 'application/x-www-form-urlencoded; charset=UTF-8',
      },
    })
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({
      foo: 'bar',
    })
  })

  it('Should return `foo[]` as an array', async () => {
    const form = new FormData()
    form.append('foo[]', 'bar1')
    form.append('foo[]', 'bar2')
    const res = await app.request('/post', {
      method: 'POST',
      body: form,
    })
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({
      'foo[]': ['bar1', 'bar2'],
    })
  })

  it('Should return `foo` as an array if multiple values are appended', async () => {
    const form = new FormData()
    form.append('foo', 'bar1')
    form.append('foo', 'bar2')
    form.append('foo', 'bar3')
    const res = await app.request('/post', {
      method: 'POST',
      body: form,
    })
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({
      foo: ['bar1', 'bar2', 'bar3'],
    })
  })
})

describe('Malformed FormData request', () => {
  const app = new Hono()
  app.post(
    '/post',
    validator('form', (value) => value),
    (c) => {
      return c.json(c.req.valid('form'))
    }
  )
  app.onError(onErrorHandler)

  it('Should return 400 response, for malformed content type header', async () => {
    const res = await app.request('http://localhost/post', {
      method: 'POST',
      body: 'hi',
      headers: {
        'content-type': 'multipart/form-data',
      },
    })
    expect(res.status).toBe(400)
    const data = await res.json()
    expect(data['success']).toBe(false)
    expect(data['message']).toMatch(/^Malformed FormData request./)
  })
})

describe('JSON and FormData', () => {
  const app = new Hono()
  app.post(
    '/',
    validator('json', (value) => value),
    validator('form', (value) => value),
    async (c) => {
      const jsonData = c.req.valid('json')
      const formData = c.req.valid('form')
      return c.json({
        json: jsonData,
        form: formData,
      })
    }
  )

  it('Should validate a JSON request', async () => {
    const res = await app.request('/', {
      method: 'POST',
      body: JSON.stringify({ foo: 'bar' }),
      headers: {
        'Content-Type': 'application/json',
      },
    })
    expect(res.status).toBe(200)
    const data = await res.json()
    expect(data.json).toEqual({ foo: 'bar' })
  })

  it('Should validate a FormData request', async () => {
    const form = new FormData()
    form.append('foo', 'bar')
    const res = await app.request('/', {
      method: 'POST',
      body: form,
    })
    expect(res.status).toBe(200)
    const data = await res.json()
    expect(data.form).toEqual({ foo: 'bar' })
  })
})

describe('Cached contents', () => {
  describe('json', () => {
    const app = new Hono()
    const bodyTypes = ['json', 'text', 'arrayBuffer', 'blob']

    for (const type of bodyTypes) {
      app.post(
        `/${type}`,
        async (c, next) => {
          // @ts-expect-error not type safe
          await c.req[type]()
          await next()
        },
        validator('json', (value) => {
          if (value instanceof Promise) {
            throw new Error('Value is Promise')
          }
          return value
        }),
        async (c) => {
          const data = await c.req.json()
          return c.json(data, 200)
        }
      )
    }

    for (const type of bodyTypes) {
      const endpoint = `/${type}`
      it(`Should return the cached JSON content - ${endpoint}`, async () => {
        const res = await app.request(endpoint, {
          method: 'POST',
          body: JSON.stringify({ message: 'Hello' }),
          headers: {
            'Content-Type': 'application/json',
          },
        })
        expect(res.status).toBe(200)
        expect(await res.json()).toEqual({ message: 'Hello' })
      })
    }
  })

  describe('Cached content', () => {
    const app = new Hono()
    const bodyTypes = ['formData', 'text', 'arrayBuffer', 'blob']

    for (const type of bodyTypes) {
      app.post(
        `/${type}`,
        async (c, next) => {
          // @ts-expect-error not type safe
          await c.req[type]()
          await next()
        },
        validator('form', (value) => {
          if (value instanceof Promise) {
            throw new Error('Value is Promise')
          }
          return value
        }),
        async (c) => {
          return c.json({ message: 'OK' }, 200)
        }
      )
    }

    for (const type of bodyTypes) {
      const endpoint = `/${type}`
      it(`Should return the cached FormData content - ${endpoint}`, async () => {
        const form = new FormData()
        form.append('message', 'Hello')
        const res = await app.request(endpoint, {
          method: 'POST',
          body: form,
        })
        expect(res.status).toBe(200)
        expect(await res.json()).toEqual({ message: 'OK' })
      })
    }
  })
})

describe('Validator middleware with a custom validation function', () => {
  const app = new Hono()

  const validationFunction: ValidationFunction<{ id: string }, { id: number }> = (v) => {
    return {
      id: Number(v.id),
    }
  }

  const route = app.post('/post', validator('json', validationFunction), (c) => {
    const post = c.req.valid('json')
    type Expected = {
      id: number
    }
    type verify = Expect<Equal<Expected, typeof post>>
    return c.json({
      post,
    })
  })

  type Expected = {
    '/post': {
      $post: {
        input: {
          json: {
            id: string
          }
        }
        output: {
          post: {
            id: number
          }
        }
        outputFormat: 'json'
        status: ContentfulStatusCode
      }
    }
  }

  type Actual = ExtractSchema<typeof route>
  type verify2 = Expect<Equal<Expected, Actual>>

  it('Should validate JSON with transformation and return 200 response', async () => {
    const res = await app.request('http://localhost/post', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        id: '123',
      }),
    })
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({
      post: {
        id: 123,
      },
    })
  })
})

describe('Validator middleware with Zod validates JSON', () => {
  const app = new Hono()

  const schema = z.object({
    id: z.number(),
    title: z.string(),
  })

  const route = app.post('/post', zodValidator('json', schema), (c) => {
    const post = c.req.valid('json')
    type Expected = {
      id: number
      title: string
    }
    type verify = Expect<Equal<Expected, typeof post>>
    return c.json({
      post: post,
    })
  })

  type Expected = {
    '/post': {
      $post: {
        input: {
          json: {
            id: number
            title: string
          }
        }
        output: {
          post: {
            id: number
            title: string
          }
        }
        outputFormat: 'json'
        status: ContentfulStatusCode
      }
    }
  }

  type Actual = ExtractSchema<typeof route>

  type verify2 = Expect<Equal<Expected, Actual>>

  it('Should validate JSON and return 200 response', async () => {
    const res = await app.request('http://localhost/post', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        id: 123,
        title: 'Hello',
      }),
    })
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({
      post: {
        id: 123,
        title: 'Hello',
      },
    })
  })

  it('Should validate JSON and return 400 response', async () => {
    const res = await app.request('http://localhost/post', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        id: '123',
        title: 'Hello',
      }),
    })
    expect(res.status).toBe(400)
    expect(await res.text()).toBe('Invalid!')
  })
})

describe('Validator middleware with Zod validates Form data', () => {
  const app = new Hono()

  const schema = z.object({
    id: z.string(),
    title: z.string(),
  })
  app.post('/post', zodValidator('form', schema), (c) => {
    const post = c.req.valid('form')
    return c.json({
      post: post,
    })
  })

  it('Should validate Form data and return 200 response', async () => {
    const form = new FormData()
    form.append('id', '123')
    form.append('title', 'Hello')
    const res = await app.request('http://localhost/post', {
      method: 'POST',
      body: form,
    })
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({
      post: {
        id: '123',
        title: 'Hello',
      },
    })
  })

  it('Should validate Form data and return 400 response', async () => {
    const res = await app.request('http://localhost/post', {
      method: 'POST',
    })
    expect(res.status).toBe(400)
    expect(await res.text()).toBe('Invalid!')
  })
})

describe('Validator middleware with Zod validates query params', () => {
  const app = new Hono()

  const schema = z.object({
    page: z
      .string()
      .refine((v) => {
        return !isNaN(Number(v))
      })
      .transform((v) => {
        return Number(v)
      }),
    tag: z.array(z.string()),
  })

  app.get('/search', zodValidator('query', schema), (c) => {
    const res = c.req.valid('query')
    return c.json({
      page: res.page,
      tags: res.tag,
    })
  })

  it('Should validate query params and return 200 response', async () => {
    const res = await app.request('http://localhost/search?page=123&tag=a&tag=b')
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({
      page: 123,
      tags: ['a', 'b'],
    })
  })

  it('Should validate query params and return 400 response', async () => {
    const res = await app.request('http://localhost/search?page=onetwothree')
    expect(res.status).toBe(400)
    expect(await res.text()).toBe('Invalid!')
  })
})

describe('Validator middleware with Zod validates param', () => {
  const app = new Hono()

  const schema = z.object({
    id: z
      .string()
      .regex(/^[0-9]+$/)
      .transform((v) => {
        return Number(v)
      }),
    title: z.string(),
  })
  app.get('/users/:id/books/:title', zodValidator('param', schema), (c) => {
    const param = c.req.valid('param')
    return c.json({
      param: param,
    })
  })

  it('Should validate Form data and return 200 response', async () => {
    const res = await app.request('http://localhost/users/123/books/Hello')
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({
      param: {
        id: 123,
        title: 'Hello',
      },
    })
  })

  it('Should validate Form data and return 400 response', async () => {
    const res = await app.request('http://localhost/users/0.123/books/Hello')
    expect(res.status).toBe(400)
    expect(await res.text()).toBe('Invalid!')
  })
})

describe('Validator middleware with Zod validates header values', () => {
  const app = new Hono()

  const schema = z.object({
    'x-request-id': z.string().uuid(),
  })

  app.get('/ping', zodValidator('header', schema), (c) => {
    const data = c.req.valid('header')
    const xRequestId = data['x-request-id']
    return c.json({
      xRequestId,
    })
  })

  it('Should validate header values and return 200 response', async () => {
    const res = await app.request('/ping', {
      headers: {
        'x-request-id': '6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b',
      },
    })
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({
      xRequestId: '6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b',
    })
  })

  it('Should validate header values and return 400 response', async () => {
    const res = await app.request('http://localhost/ping', {
      headers: {
        'x-request-id': 'invalid-key',
      },
    })
    expect(res.status).toBe(400)
    expect(await res.text()).toBe('Invalid!')
  })
})

describe('Validator middleware with Zod validates cookies', () => {
  const app = new Hono()

  const schema = z.object({
    debug: z.enum(['0', '1']),
  })

  app.get('/api/user', zodValidator('cookie', schema), (c) => {
    const { debug } = c.req.valid('cookie')
    return c.json({
      debug,
    })
  })

  it('Should validate cookies and return 200 response', async () => {
    const res = await app.request('/api/user', {
      headers: {
        Cookie: 'debug=0',
      },
    })
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({
      debug: '0',
    })
  })

  it('Should validate cookies and return 400 response', async () => {
    const res = await app.request('/api/user', {
      headers: {
        Cookie: 'debug=true',
      },
    })
    expect(res.status).toBe(400)
    expect(await res.text()).toBe('Invalid!')
  })
})

describe('Validator middleware with Zod multiple validators', () => {
  const app = new Hono<{ Variables: { id: number } }>()
  const route = app.post(
    '/posts',
    zodValidator(
      'query',
      z.object({
        page: z
          .string()
          .refine((v) => {
            return !isNaN(Number(v))
          })
          .transform((v) => {
            return Number(v)
          }),
      })
    ),
    zodValidator(
      'form',
      z.object({
        title: z.string(),
      })
    ),
    (c) => {
      const id = c.get('id')
      type verify = Expect<Equal<number, typeof id>>
      const formValidatedData = c.req.valid('form')
      type verify2 = Expect<Equal<{ title: string }, typeof formValidatedData>>
      const { page } = c.req.valid('query')
      const { title } = c.req.valid('form')
      return c.json({ page, title })
    }
  )

  type Actual = ExtractSchema<typeof route>

  type Expected = {
    '/posts': {
      $post: {
        input: {
          query: {
            page: string
          }
        } & {
          form: {
            title: string
          }
        }
        output: {
          page: number
          title: string
        }
        outputFormat: 'json'
        status: ContentfulStatusCode
      }
    }
  }

  type verify = Expect<Equal<Expected, Actual>>

  it('Should validate both query param and form data and return 200 response', async () => {
    const form = new FormData()
    form.append('title', 'Hello')
    const res = await app.request('http://localhost/posts?page=2', {
      method: 'POST',
      body: form,
    })
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({
      page: 2,
      title: 'Hello',
    })
  })

  it('Should validate both query param and form data and return 400 response', async () => {
    const res = await app.request('http://localhost/posts?page=2', {
      method: 'POST',
    })
    expect(res.status).toBe(400)
    expect(await res.text()).toBe('Invalid!')
  })
})

it('With path parameters', () => {
  const app = new Hono()

  const route = app.put(
    '/posts/:id',
    validator('param', () => {
      return {
        id: '123',
      }
    }),
    validator('form', () => {
      return {
        title: 'Foo',
      }
    }),
    (c) => {
      return c.text('Valid!')
    }
  )

  type Expected = {
    '/posts/:id': {
      $put: {
        input: {
          form: {
            title: ParsedFormValue | ParsedFormValue[]
          }
        } & {
          param: {
            id: string
          }
        }
        output: 'Valid!'
        outputFormat: 'text'
        status: ContentfulStatusCode
      }
    }
  }

  type Actual = ExtractSchema<typeof route>
  type verify = Expect<Equal<Expected, Actual>>
})

it('`on`', () => {
  const app = new Hono()

  const route = app.on(
    'PURGE',
    '/purge',
    validator('form', () => {
      return {
        tag: 'foo',
      }
    }),
    validator('query', () => {
      return {
        q: 'bar',
      }
    }),
    (c) => {
      return c.json({
        success: true,
      })
    }
  )

  type Expected = {
    '/purge': {
      $purge: {
        input: {
          form: {
            tag: ParsedFormValue | ParsedFormValue[]
          }
        } & {
          query: {
            q: string | string[]
          }
        }
        output: {
          success: boolean
        }
        outputFormat: 'json'
        status: ContentfulStatusCode
      }
    }
  }

  type Actual = ExtractSchema<typeof route>
  type verify = Expect<Equal<Expected, Actual>>
})

it('`app.on`', () => {
  const app = new Hono()

  const route = app
    .get(
      '/posts',
      validator('query', () => {
        return {
          page: '2',
        }
      }),
      (c) => {
        return c.json({
          posts: [
            {
              title: 'foo',
            },
          ],
        })
      }
    )
    .post(
      validator('json', () => {
        return {
          title: 'Hello',
        }
      }),
      validator('query', () => {
        return {
          title: 'Hello',
        }
      }),
      (c) => {
        return c.json({
          success: true,
        })
      }
    )

  type Actual = ExtractSchema<typeof route>
  //type verify = Expect<Equal<Expected, Actual>>
})

describe('Clone Request object', () => {
  describe('json', () => {
    const app = new Hono()
    app.post(
      '/',
      validator('json', () => {
        return {
          foo: 'bar',
        }
      }),
      async (c) => {
        // `c.req.json()` should not throw the error
        await c.req.json()
        // `c.req.text()` should not throw the error
        await c.req.text()
        // `c.req.arrayBuffer()` should not throw the error
        await c.req.arrayBuffer()
        // `c.req.blob()` should not throw the error
        await c.req.blob()
        return c.text('foo')
      }
    )

    it('Should not throw the error with c.req.json()', async () => {
      const req = new Request('http://localhost', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ foo: 'bar' }),
      })
      const res = await app.request(req)
      expect(res.status).toBe(200)
    })
  })

  describe('form', () => {
    const app = new Hono()
    app.post(
      '/',
      validator('form', () => {
        return {
          foo: 'bar',
        }
      }),
      async (c) => {
        // `c.req.parseBody()` should not throw the error
        await c.req.parseBody()
        // `c.req.text()` should not throw the error
        await c.req.text()
        // `c.req.arrayBuffer()` should not throw the error
        await c.req.arrayBuffer()
        // `c.req.blob()` should not throw the error
        await c.req.blob()
        return c.text('foo')
      }
    )

    app.post(
      '/cached',
      async (c, next) => {
        await c.req.parseBody()
        await next()
      },
      validator('form', (value) => {
        if (value instanceof FormData) {
          throw new Error('The value should not be a FormData')
        }
        return value
      }),
      (c) => {
        const v = c.req.valid('form')
        return c.json(v)
      }
    )

    it('Should not throw the error with c.req.parseBody()', async () => {
      const body = new FormData()
      body.append('foo', 'bar')
      const req = new Request('http://localhost', {
        method: 'POST',
        body: body,
      })
      const res = await app.request(req)
      expect(res.status).toBe(200)
    })

    it('Should not be an instance of FormData if the formData is cached', async () => {
      const body = new FormData()
      body.append('foo', 'bar')
      const req = new Request('http://localhost/cached', {
        method: 'POST',
        body: body,
      })
      const res = await app.request(req)
      expect(res.status).toBe(200)
      expect(await res.json()).toEqual({ foo: 'bar' })
    })
  })
})

describe('Async validator function', () => {
  const app = new Hono()

  app.get(
    '/posts',
    validator('query', async () => {
      return {
        page: '1',
      }
    }),
    (c) => {
      const { page } = c.req.valid('query')
      return c.json({ page })
    }
  )

  it('Should get the values from the async function', async () => {
    const res = await app.request('/posts')
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({
      page: '1',
    })
  })
})

describe('Validator with using Zod directly', () => {
  it('Should exclude Response & TypedResponse type', () => {
    const testSchema = z.object({
      name: z.string(),
      age: z.number(),
      type: z.enum(['a']),
    })
    const app = new Hono()

    const route = app.post(
      '/posts',
      validator('json', (value, c) => {
        const parsed = testSchema.safeParse(value)
        if (!parsed.success) {
          return c.json({ foo: 'bar' }, 401)
        }
        return parsed.data
      }),
      (c) => {
        const data = c.req.valid('json')
        expectTypeOf(data.name).toEqualTypeOf<string>()
        return c.json(
          {
            message: 'Created!',
          },
          201
        )
      }
    )

    expectTypeOf<ExtractSchema<typeof route>>().toEqualTypeOf<{
      '/posts': {
        $post: {
          input: {
            json: {
              type: 'a'
              name: string
              age: number
            }
          }
          output: {
            message: string
          }
          outputFormat: 'json'
          status: 201
        }
      }
    }>()
  })
})

describe('Transform', () => {
  it('Should be number when the type is transformed', () => {
    const route = new Hono().get(
      '/',
      validator('query', async () => {
        return {
          page: 1,
        }
      }),
      (c) => {
        const { page } = c.req.valid('query')
        expectTypeOf(page).toEqualTypeOf<number>()
        return c.json({ page })
      }
    )

    type Expected = {
      '/': {
        $get: {
          input: {
            query: {
              page: string | string[]
            }
          }
          output: {
            page: number
          }
          outputFormat: 'json'
          status: ContentfulStatusCode
        }
      }
    }

    type Actual = ExtractSchema<typeof route>
    type verify = Expect<Equal<Expected, Actual>>
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/validator/validator.ts
```typescript
import type { Context } from '../context'
import { getCookie } from '../helper/cookie'
import { HTTPException } from '../http-exception'
import type { Env, MiddlewareHandler, TypedResponse, ValidationTargets } from '../types'
import type { BodyData } from '../utils/body'
import { bufferToFormData } from '../utils/buffer'

type ValidationTargetKeysWithBody = 'form' | 'json'
type ValidationTargetByMethod<M> = M extends 'get' | 'head' // GET and HEAD request must not have a body content.
  ? Exclude<keyof ValidationTargets, ValidationTargetKeysWithBody>
  : keyof ValidationTargets

export type ValidationFunction<
  InputType,
  OutputType,
  E extends Env = {},
  P extends string = string
> = (
  value: InputType,
  c: Context<E, P>
) => OutputType | Response | Promise<OutputType> | Promise<Response>

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type ExcludeResponseType<T> = T extends Response & TypedResponse<any> ? never : T

const jsonRegex = /^application\/([a-z-\.]+\+)?json(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/
const multipartRegex = /^multipart\/form-data(;\s?boundary=[a-zA-Z0-9'"()+_,\-./:=?]+)?$/
const urlencodedRegex = /^application\/x-www-form-urlencoded(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/

export const validator = <
  InputType,
  P extends string,
  M extends string,
  U extends ValidationTargetByMethod<M>,
  OutputType = ValidationTargets[U],
  OutputTypeExcludeResponseType = ExcludeResponseType<OutputType>,
  P2 extends string = P,
  V extends {
    in: {
      [K in U]: K extends 'json'
        ? unknown extends InputType
          ? OutputTypeExcludeResponseType
          : InputType
        : { [K2 in keyof OutputTypeExcludeResponseType]: ValidationTargets[K][K2] }
    }
    out: { [K in U]: OutputTypeExcludeResponseType }
  } = {
    in: {
      [K in U]: K extends 'json'
        ? unknown extends InputType
          ? OutputTypeExcludeResponseType
          : InputType
        : { [K2 in keyof OutputTypeExcludeResponseType]: ValidationTargets[K][K2] }
    }
    out: { [K in U]: OutputTypeExcludeResponseType }
  },
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  E extends Env = any
>(
  target: U,
  validationFunc: ValidationFunction<
    unknown extends InputType ? ValidationTargets[U] : InputType,
    OutputType,
    E,
    P2
  >
): MiddlewareHandler<E, P, V> => {
  return async (c, next) => {
    let value = {}
    const contentType = c.req.header('Content-Type')

    switch (target) {
      case 'json':
        if (!contentType || !jsonRegex.test(contentType)) {
          break
        }
        try {
          value = await c.req.json()
        } catch {
          const message = 'Malformed JSON in request body'
          throw new HTTPException(400, { message })
        }
        break
      case 'form': {
        if (
          !contentType ||
          !(multipartRegex.test(contentType) || urlencodedRegex.test(contentType))
        ) {
          break
        }

        let formData: FormData

        if (c.req.bodyCache.formData) {
          formData = await c.req.bodyCache.formData
        } else {
          try {
            const arrayBuffer = await c.req.arrayBuffer()
            formData = await bufferToFormData(arrayBuffer, contentType)
            c.req.bodyCache.formData = formData
          } catch (e) {
            let message = 'Malformed FormData request.'
            message += e instanceof Error ? ` ${e.message}` : ` ${String(e)}`
            throw new HTTPException(400, { message })
          }
        }

        const form: BodyData<{ all: true }> = {}
        formData.forEach((value, key) => {
          if (key.endsWith('[]')) {
            ;((form[key] ??= []) as unknown[]).push(value)
          } else if (Array.isArray(form[key])) {
            ;(form[key] as unknown[]).push(value)
          } else if (key in form) {
            form[key] = [form[key] as string | File, value]
          } else {
            form[key] = value
          }
        })
        value = form
        break
      }
      case 'query':
        value = Object.fromEntries(
          Object.entries(c.req.queries()).map(([k, v]) => {
            return v.length === 1 ? [k, v[0]] : [k, v]
          })
        )
        break
      case 'param':
        value = c.req.param() as Record<string, string>
        break
      case 'header':
        value = c.req.header()
        break
      case 'cookie':
        value = getCookie(c)
        break
    }

    const res = await validationFunc(value as never, c as never)

    if (res instanceof Response) {
      return res
    }

    c.req.addValidatedData(target, res as never)

    await next()
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/preset/quick.test.ts
```typescript
import { getRouterName } from '../helper/dev'
import { Hono } from './quick'

describe('hono/quick preset', () => {
  it('Should have SmartRouter + LinearRouter', async () => {
    const app = new Hono()
    expect(getRouterName(app)).toBe('SmartRouter + LinearRouter')
  })
})

describe('Generics for Bindings and Variables', () => {
  interface CloudflareBindings {
    MY_VARIABLE: string
  }

  it('Should not throw type errors', () => {
    // @ts-expect-error Bindings should extend object
    new Hono<{
      Bindings: number
    }>()

    const appWithInterface = new Hono<{
      Bindings: CloudflareBindings
    }>()

    appWithInterface.get('/', (c) => {
      expectTypeOf(c.env.MY_VARIABLE).toMatchTypeOf<string>()
      return c.text('/')
    })

    const appWithType = new Hono<{
      Bindings: {
        foo: string
      }
    }>()

    appWithType.get('/', (c) => {
      expectTypeOf(c.env.foo).toMatchTypeOf<string>()
      return c.text('Hello Hono!')
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/preset/quick.ts
```typescript
/**
 * @module
 * The preset that uses `LinearRouter`.
 */

import { HonoBase } from '../hono-base'
import type { HonoOptions } from '../hono-base'
import { LinearRouter } from '../router/linear-router'
import { SmartRouter } from '../router/smart-router'
import { TrieRouter } from '../router/trie-router'
import type { BlankEnv, BlankSchema, Env, Schema } from '../types'

export class Hono<
  E extends Env = BlankEnv,
  S extends Schema = BlankSchema,
  BasePath extends string = '/'
> extends HonoBase<E, S, BasePath> {
  constructor(options: HonoOptions<E> = {}) {
    super(options)
    this.router = new SmartRouter({
      routers: [new LinearRouter(), new TrieRouter()],
    })
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/preset/tiny.test.ts
```typescript
import { getRouterName } from '../helper/dev'
import { Hono } from './tiny'

describe('hono/tiny preset', () => {
  it('Should have PatternRouter', async () => {
    const app = new Hono()
    expect(getRouterName(app)).toBe('PatternRouter')
  })
})

describe('Generics for Bindings and Variables', () => {
  interface CloudflareBindings {
    MY_VARIABLE: string
  }

  it('Should not throw type errors', () => {
    // @ts-expect-error Bindings should extend object
    new Hono<{
      Bindings: number
    }>()

    const appWithInterface = new Hono<{
      Bindings: CloudflareBindings
    }>()

    appWithInterface.get('/', (c) => {
      expectTypeOf(c.env.MY_VARIABLE).toMatchTypeOf<string>()
      return c.text('/')
    })

    const appWithType = new Hono<{
      Bindings: {
        foo: string
      }
    }>()

    appWithType.get('/', (c) => {
      expectTypeOf(c.env.foo).toMatchTypeOf<string>()
      return c.text('Hello Hono!')
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/preset/tiny.ts
```typescript
/**
 * @module
 * The preset that uses `PatternRouter`.
 */

import { HonoBase } from '../hono-base'
import type { HonoOptions } from '../hono-base'
import { PatternRouter } from '../router/pattern-router'
import type { BlankEnv, BlankSchema, Env, Schema } from '../types'

export class Hono<
  E extends Env = BlankEnv,
  S extends Schema = BlankSchema,
  BasePath extends string = '/'
> extends HonoBase<E, S, BasePath> {
  constructor(options: HonoOptions<E> = {}) {
    super(options)
    this.router = new PatternRouter()
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/accept.test.ts
```typescript
import { parseAccept } from './accept'

describe('parseAccept Comprehensive Tests', () => {
  describe('Basic Functionality', () => {
    test('parses simple accept header', () => {
      const header = 'text/html,application/json;q=0.9'
      expect(parseAccept(header)).toEqual([
        { type: 'text/html', params: {}, q: 1 },
        { type: 'application/json', params: { q: '0.9' }, q: 0.9 },
      ])
    })

    test('handles missing header', () => {
      expect(parseAccept('')).toEqual([])
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      expect(parseAccept(undefined as any)).toEqual([])
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      expect(parseAccept(null as any)).toEqual([])
    })
  })

  describe('Quality Values', () => {
    test('handles extreme q values', () => {
      const header = 'a;q=999999,b;q=-99999,c;q=Infinity,d;q=-Infinity,e;q=NaN'
      const result = parseAccept(header)
      expect(result.map((x) => x.q)).toEqual([1, 1, 1, 0, 0])
    })

    test('handles malformed q values', () => {
      const header = 'a;q=,b;q=invalid,c;q=1.2.3,d;q=true,e;q="0.5"'
      const result = parseAccept(header)
      expect(result.every((x) => x.q >= 0 && x.q <= 1)).toBe(true)
    })

    test('preserves original q string in params', () => {
      const header = 'type;q=invalid'
      const result = parseAccept(header)
      expect(result[0].params.q).toBe('invalid')
      expect(result[0].q).toBe(1) // Normalized q value
    })
  })

  describe('Parameter Handling', () => {
    test('handles complex parameters', () => {
      const header = 'type;a=1;b="2";c=\'3\';d="semi;colon";e="nested"quoted""'
      const result = parseAccept(header)
      expect(result[0].params).toEqual({
        a: '1',
        b: '"2"',

        c: "'3'",
        d: '"semi;colon"',
        e: '"nested"quoted""',
      })
    })

    test('handles malformed parameters', () => {
      const header = 'type;=value;;key=;=;====;key====value'
      const result = parseAccept(header)
      expect(result[0].type).toBe('type')
      expect(Object.keys(result[0].params).length).toBe(0)
    })

    test('handles duplicate parameters', () => {
      const header = 'type;key=1;key=2;KEY=3'
      const result = parseAccept(header)
      expect(result[0].params.key).toBe('2')
      expect(result[0].params.KEY).toBe('3')
    })
  })

  describe('Media Type Edge Cases', () => {
    test('handles malformed media types', () => {
      const headers = [
        '*/html',
        'text/*mal/formed',
        '/partial',
        'missing/',
        'inv@lid/type',
        'text/(html)',
        'text/html?invalid',
      ]
      headers.forEach((header) => {
        const result = parseAccept(header)
        expect(result[0].type).toBe(header)
      })
    })

    test('handles extremely long types', () => {
      const longType = 'a'.repeat(10000) + '/' + 'b'.repeat(10000)
      const result = parseAccept(longType)
      expect(result[0].type).toBe(longType)
    })
  })

  describe('Delimiter Edge Cases', () => {
    test('handles multiple consecutive delimiters', () => {
      const header = 'a,,,,b;q=0.9,,,,c;q=0.8,,,,'
      const result = parseAccept(header)
      expect(result.map((x) => x.type)).toEqual(['a', 'b', 'c'])
    })

    test('handles unusual whitespace', () => {
      const header = '\n\t a \t\n ; \n\t q=0.9 \t\n , \n\t b \t\n'
      const result = parseAccept(header)
      expect(result.map((x) => x.type)).toEqual(['b', 'a'])
    })
  })

  describe('Security Cases', () => {
    test('handles potential injection patterns', () => {
      const headers = [
        'type;q=0.9--',
        'type;q=0.9;drop table users',
        'type;__|;q=0.9',
        'text/html"><script>alert(1)</script>',
        'application/json${process.env}',
      ]
      headers.forEach((header) => {
        expect(() => parseAccept(header)).not.toThrow()
      })
    })

    test('handles extremely large input', () => {
      const header = 'a;q=0.9,'.repeat(100000)
      expect(() => parseAccept(header)).not.toThrow()
    })
  })

  describe('Unicode and Special Characters', () => {
    test('handles unicode in types and parameters', () => {
      const header = '🌐/😊;param=🔥;q=0.9'
      const result = parseAccept(header)
      expect(result[0].type).toBe('🌐/😊')
      expect(result[0].params.param).toBe('🔥')
    })

    test('handles special characters', () => {
      const header = 'type;param=\x00\x01\x02\x03'
      const result = parseAccept(header)
      expect(result[0].params.param).toBe('\x00\x01\x02\x03')
    })
  })

  describe('Sort Stability', () => {
    test('maintains stable sort for equal q values', () => {
      const header = 'a;q=0.9,b;q=0.9,c;q=0.9,d;q=0.9'
      const result = parseAccept(header)
      expect(result.map((x) => x.type)).toEqual(['a', 'b', 'c', 'd'])
    })

    test('handles mixed priorities correctly', () => {
      const header = 'd;q=0.8,b;q=0.9,c;q=0.8,a;q=0.9'
      const result = parseAccept(header)
      expect(result.map((x) => x.type)).toEqual(['b', 'a', 'd', 'c'])
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/accept.ts
```typescript
export interface Accept {
  type: string
  params: Record<string, string>
  q: number
}

/**
 * Parse an Accept header into an array of objects with type, parameters, and quality score.
 * @param acceptHeader The Accept header string
 * @returns An array of parsed Accept values
 */
export const parseAccept = (acceptHeader: string): Accept[] => {
  if (!acceptHeader) {
    return []
  }

  const acceptValues = acceptHeader.split(',').map((value, index) => ({ value, index }))

  return acceptValues
    .map(parseAcceptValue)
    .filter((item): item is Accept & { index: number } => Boolean(item))
    .sort(sortByQualityAndIndex)
    .map(({ type, params, q }) => ({ type, params, q }))
}
const parseAcceptValueRegex = /;(?=(?:(?:[^"]*"){2})*[^"]*$)/
const parseAcceptValue = ({ value, index }: { value: string; index: number }) => {
  const parts = value
    .trim()
    .split(parseAcceptValueRegex)
    .map((s) => s.trim())
  const type = parts[0]
  if (!type) {
    return null
  }

  const params = parseParams(parts.slice(1))
  const q = parseQuality(params.q)

  return { type, params, q, index }
}

const parseParams = (paramParts: string[]): Record<string, string> => {
  return paramParts.reduce<Record<string, string>>((acc, param) => {
    const [key, val] = param.split('=').map((s) => s.trim())
    if (key && val) {
      acc[key] = val
    }
    return acc
  }, {})
}

const parseQuality = (qVal?: string): number => {
  if (qVal === undefined) {
    return 1
  }
  if (qVal === '') {
    return 1
  }
  if (qVal === 'NaN') {
    return 0
  }

  const num = Number(qVal)
  if (num === Infinity) {
    return 1
  }
  if (num === -Infinity) {
    return 0
  }
  if (Number.isNaN(num)) {
    return 1
  }
  if (num < 0 || num > 1) {
    return 1
  }

  return num
}

const sortByQualityAndIndex = (a: Accept & { index: number }, b: Accept & { index: number }) => {
  const qDiff = b.q - a.q
  if (qDiff !== 0) {
    return qDiff
  }
  return a.index - b.index
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/basic-auth.test.ts
```typescript
import { auth } from './basic-auth'

describe('auth', () => {
  it('auth() - not include Authorization Header', () => {
    const res = auth(new Request('http://localhost/auth'))
    expect(res).toBeUndefined()
  })

  it('auth() - invalid Authorization Header format', () => {
    const res = auth(
      new Request('http://localhost/auth', {
        headers: { Authorization: 'InvalidAuthHeader' },
      })
    )
    expect(res).toBeUndefined()
  })

  it('auth() - invalid Base64 string in Authorization Header', () => {
    const res = auth(
      new Request('http://localhost/auth', {
        headers: { Authorization: 'Basic InvalidBase64' },
      })
    )
    expect(res).toBeUndefined()
  })

  it('auth() - valid Authorization Header', () => {
    const validBase64 = btoa('username:password')
    const res = auth(
      new Request('http://localhost/auth', {
        headers: { Authorization: `Basic ${validBase64}` },
      })
    )
    expect(res).toEqual({ username: 'username', password: 'password' })
  })

  it('auth() - empty username', () => {
    const validBase64 = btoa(':password')
    const res = auth(
      new Request('http://localhost/auth', {
        headers: { Authorization: `Basic ${validBase64}` },
      })
    )
    expect(res).toEqual({ username: '', password: 'password' })
  })

  it('auth() - empty password', () => {
    const validBase64 = btoa('username:')
    const res = auth(
      new Request('http://localhost/auth', {
        headers: { Authorization: `Basic ${validBase64}` },
      })
    )
    expect(res).toEqual({ username: 'username', password: '' })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/basic-auth.ts
```typescript
import { decodeBase64 } from './encode'

const CREDENTIALS_REGEXP = /^ *(?:[Bb][Aa][Ss][Ii][Cc]) +([A-Za-z0-9._~+/-]+=*) *$/
const USER_PASS_REGEXP = /^([^:]*):(.*)$/
const utf8Decoder = new TextDecoder()

export type Auth = (req: Request) => { username: string; password: string } | undefined

export const auth: Auth = (req: Request) => {
  const match = CREDENTIALS_REGEXP.exec(req.headers.get('Authorization') || '')
  if (!match) {
    return undefined
  }

  let userPass = undefined
  // If an invalid string is passed to atob(), it throws a `DOMException`.
  try {
    userPass = USER_PASS_REGEXP.exec(utf8Decoder.decode(decodeBase64(match[1])))
  } catch {} // Do nothing

  if (!userPass) {
    return undefined
  }

  return { username: userPass[1], password: userPass[2] }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/body.test.ts
```typescript
import { parseBody } from './body'
import type { BodyData } from './body'

type RecursiveRecord<K extends string, T> = {
  [key in K]: T | RecursiveRecord<K, T>
}

describe('Parse Body Util', () => {
  const FORM_URL = 'https://localhost/form'
  const SEARCH_URL = 'https://localhost/search'

  const createRequest = (
    url: string,
    method: 'POST',
    body: BodyInit,
    headers?: { [key: string]: string }
  ) => {
    return new Request(url, {
      method,
      body,
      headers,
    })
  }

  it('should parse `multipart/form-data`', async () => {
    const data = new FormData()
    data.append('message', 'hello')

    const req = createRequest(FORM_URL, 'POST', data)

    expect(await parseBody(req)).toEqual({ message: 'hello' })
  })

  it('should parse `x-www-form-urlencoded`', async () => {
    const searchParams = new URLSearchParams()
    searchParams.append('message', 'hello')

    const req = createRequest(SEARCH_URL, 'POST', searchParams, {
      'Content-Type': 'application/x-www-form-urlencoded',
    })

    expect(await parseBody(req)).toEqual({ message: 'hello' })
  })

  it('should not parse multiple values in default', async () => {
    const data = new FormData()
    data.append('file', 'bbb')
    data.append('message', 'hello')

    const req = createRequest(FORM_URL, 'POST', data)

    expect(await parseBody(req)).toEqual({
      file: 'bbb',
      message: 'hello',
    })
  })

  it('should not update file object properties', async () => {
    const file = new File(['foo'], 'file1', {
      type: 'application/octet-stream',
    })
    const data = new FormData()

    const req = createRequest(FORM_URL, 'POST', data)
    vi.spyOn(req, 'formData').mockImplementation(
      async () =>
        ({
          forEach: (cb) => {
            cb(file, 'file', data)
            cb('hoo', 'file.hoo', data)
          },
        } as FormData)
    )

    const parsedData = await parseBody(req, { dot: true })
    expect(parsedData.file).not.instanceOf(File)
    expect(parsedData).toEqual({
      file: {
        hoo: 'hoo',
      },
    })
  })

  it('should override value if `all` option is false', async () => {
    const data = new FormData()
    data.append('file', 'aaa')
    data.append('file', 'bbb')
    data.append('message', 'hello')

    const req = createRequest(FORM_URL, 'POST', data)

    expect(await parseBody(req)).toEqual({
      file: 'bbb',
      message: 'hello',
    })
  })

  it('should parse multiple values if `all` option is true', async () => {
    const data = new FormData()
    data.append('file', 'aaa')
    data.append('file', 'bbb')
    data.append('message', 'hello')

    const req = createRequest(FORM_URL, 'POST', data)

    expect(await parseBody(req, { all: true })).toEqual({
      file: ['aaa', 'bbb'],
      message: 'hello',
    })
  })

  it('should not parse nested values in default', async () => {
    const data = new FormData()
    data.append('obj.key1', 'value1')
    data.append('obj.key2', 'value2')

    const req = createRequest(FORM_URL, 'POST', data)

    expect(await parseBody(req, { dot: false })).toEqual({
      'obj.key1': 'value1',
      'obj.key2': 'value2',
    })
  })

  it('should not parse nested values in default for non-nested keys', async () => {
    const data = new FormData()
    data.append('key1', 'value1')
    data.append('key2', 'value2')

    const req = createRequest(FORM_URL, 'POST', data)

    expect(await parseBody(req, { dot: false })).toEqual({
      key1: 'value1',
      key2: 'value2',
    })
  })

  it('should handle nested values and non-nested values together with dot option true', async () => {
    const data = new FormData()
    data.append('obj.key1', 'value1')
    data.append('obj.key2', 'value2')
    data.append('key3', 'value3')

    const req = createRequest(FORM_URL, 'POST', data)

    expect(await parseBody(req, { dot: true })).toEqual({
      obj: { key1: 'value1', key2: 'value2' },
      key3: 'value3',
    })
  })

  it('should handle deeply nested objects with dot option true', async () => {
    const data = new FormData()
    data.append('a.b.c.d', 'value')

    const req = createRequest(FORM_URL, 'POST', data)

    expect(await parseBody(req, { dot: true })).toEqual({
      a: { b: { c: { d: 'value' } } },
    })
  })

  it('should parse nested values if `dot` option is true', async () => {
    const data = new FormData()
    data.append('obj.key1', 'value1')
    data.append('obj.key2', 'value2')

    const req = createRequest(FORM_URL, 'POST', data)

    expect(await parseBody(req, { dot: true })).toEqual({
      obj: { key1: 'value1', key2: 'value2' },
    })
  })

  it('should parse data if both `all` and `dot` are set', async () => {
    const data = new FormData()
    data.append('obj.sub.foo', 'value1')
    data.append('obj.sub.foo', 'value2')
    data.append('key', 'value3')

    const req = createRequest(FORM_URL, 'POST', data)

    expect(await parseBody(req, { dot: true, all: true })).toEqual({
      obj: { sub: { foo: ['value1', 'value2'] } },
      key: 'value3',
    })
  })

  it('should parse nested values if values are `File`', async () => {
    const file1 = new File(['foo'], 'file1', {
      type: 'application/octet-stream',
    })
    const file2 = new File(['bar'], 'file2', {
      type: 'application/octet-stream',
    })
    const data = new FormData()
    data.append('file.file1', file1)
    data.append('file.file2', file2)

    const req = createRequest(FORM_URL, 'POST', data)

    expect(await parseBody(req, { all: true, dot: true })).toEqual({
      file: { file1, file2 },
    })
  })

  it('should parse multiple values if values are `File`', async () => {
    const file1 = new File(['foo'], 'file1', {
      type: 'application/octet-stream',
    })
    const file2 = new File(['bar'], 'file2', {
      type: 'application/octet-stream',
    })
    const data = new FormData()
    data.append('file', file1)
    data.append('file', file2)

    const req = createRequest(FORM_URL, 'POST', data)

    expect(await parseBody(req, { all: true })).toEqual({
      file: [file1, file2],
    })
  })

  it('should parse multiple values if key ends with `[]`', async () => {
    const data = new FormData()
    data.append('file[]', 'aaa')
    data.append('file[]', 'bbb')
    data.append('message', 'hello')

    const req = createRequest(FORM_URL, 'POST', data)

    expect(await parseBody(req, { all: true })).toEqual({
      'file[]': ['aaa', 'bbb'],
      message: 'hello',
    })
  })

  it('should return blank object if body is JSON', async () => {
    const payload = { message: 'hello hono' }

    const req = createRequest('http://localhost/json', 'POST', JSON.stringify(payload), {
      'Content-Type': 'application/json',
    })

    expect(await parseBody(req)).toEqual({})
  })

  describe('Return type', () => {
    let req: Request
    beforeEach(() => {
      req = createRequest(FORM_URL, 'POST', new FormData())
    })

    it('without options', async () => {
      expectTypeOf((await parseBody(req))['key']).toEqualTypeOf<string | File>()
    })

    it('{all: true}', async () => {
      expectTypeOf((await parseBody(req, { all: true }))['key']).toEqualTypeOf<
        string | File | (string | File)[]
      >()
    })

    it('{all: boolean}', async () => {
      expectTypeOf((await parseBody(req, { all: !!Math.random() }))['key']).toEqualTypeOf<
        string | File | (string | File)[]
      >()
    })

    it('{dot: true}', async () => {
      expectTypeOf((await parseBody(req, { dot: true }))['key']).toEqualTypeOf<
        string | File | RecursiveRecord<string, string | File>
      >()
    })

    it('{dot: boolean}', async () => {
      expectTypeOf((await parseBody(req, { dot: !!Math.random() }))['key']).toEqualTypeOf<
        string | File | RecursiveRecord<string, string | File>
      >()
    })

    it('{all: true, dot: true}', async () => {
      expectTypeOf((await parseBody(req, { all: true, dot: true }))['key']).toEqualTypeOf<
        | string
        | File
        | (string | File)[]
        | RecursiveRecord<string, string | File | (string | File)[]>
      >()
    })

    it('{all: boolean, dot: boolean}', async () => {
      expectTypeOf(
        (await parseBody(req, { all: !!Math.random(), dot: !!Math.random() }))['key']
      ).toEqualTypeOf<
        | string
        | File
        | (string | File)[]
        | RecursiveRecord<string, string | File | (string | File)[]>
      >()
    })

    it('specify return type explicitly', async () => {
      expectTypeOf(
        await parseBody<{ key1: string; key2: string }>(req, {
          all: !!Math.random(),
          dot: !!Math.random(),
        })
      ).toEqualTypeOf<{ key1: string; key2: string }>()
    })
  })
})

describe('BodyData', () => {
  it('without options', async () => {
    expectTypeOf(({} as BodyData)['key']).toEqualTypeOf<string | File>()
  })

  it('{all: true}', async () => {
    expectTypeOf(({} as BodyData<{ all: true }>)['key']).toEqualTypeOf<
      string | File | (string | File)[]
    >()
  })

  it('{all: boolean}', async () => {
    expectTypeOf(({} as BodyData<{ all: boolean }>)['key']).toEqualTypeOf<
      string | File | (string | File)[]
    >()
  })

  it('{dot: true}', async () => {
    expectTypeOf(({} as BodyData<{ dot: true }>)['key']).toEqualTypeOf<
      string | File | RecursiveRecord<string, string | File>
    >()
  })

  it('{dot: boolean}', async () => {
    expectTypeOf(({} as BodyData<{ dot: boolean }>)['key']).toEqualTypeOf<
      string | File | RecursiveRecord<string, string | File>
    >()
  })

  it('{all: true, dot: true}', async () => {
    expectTypeOf(({} as BodyData<{ all: true; dot: true }>)['key']).toEqualTypeOf<
      string | File | (string | File)[] | RecursiveRecord<string, string | File | (string | File)[]>
    >()
  })

  it('{all: boolean, dot: boolean}', async () => {
    expectTypeOf(({} as BodyData<{ all: boolean; dot: boolean }>)['key']).toEqualTypeOf<
      string | File | (string | File)[] | RecursiveRecord<string, string | File | (string | File)[]>
    >()
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/body.ts
```typescript
/**
 * @module
 * Body utility.
 */

import { HonoRequest } from '../request'

type BodyDataValueDot = { [x: string]: string | File | BodyDataValueDot }
type BodyDataValueDotAll = {
  [x: string]: string | File | (string | File)[] | BodyDataValueDotAll
}
type SimplifyBodyData<T> = {
  [K in keyof T]: string | File | (string | File)[] | BodyDataValueDotAll extends T[K]
    ? string | File | (string | File)[] | BodyDataValueDotAll
    : string | File | BodyDataValueDot extends T[K]
    ? string | File | BodyDataValueDot
    : string | File | (string | File)[] extends T[K]
    ? string | File | (string | File)[]
    : string | File
} & {}

type BodyDataValueComponent<T> =
  | string
  | File
  | (T extends { all: false }
      ? never // explicitly set to false
      : T extends { all: true } | { all: boolean }
      ? (string | File)[] // use all option
      : never) // without options
type BodyDataValueObject<T> = { [key: string]: BodyDataValueComponent<T> | BodyDataValueObject<T> }
type BodyDataValue<T> =
  | BodyDataValueComponent<T>
  | (T extends { dot: false }
      ? never // explicitly set to false
      : T extends { dot: true } | { dot: boolean }
      ? BodyDataValueObject<T> // use dot option
      : never) // without options
export type BodyData<T extends Partial<ParseBodyOptions> = {}> = SimplifyBodyData<
  Record<string, BodyDataValue<T>>
>

export type ParseBodyOptions = {
  /**
   * Determines whether all fields with multiple values should be parsed as arrays.
   * @default false
   * @example
   * const data = new FormData()
   * data.append('file', 'aaa')
   * data.append('file', 'bbb')
   * data.append('message', 'hello')
   *
   * If all is false:
   * parseBody should return { file: 'bbb', message: 'hello' }
   *
   * If all is true:
   * parseBody should return { file: ['aaa', 'bbb'], message: 'hello' }
   */
  all: boolean
  /**
   * Determines whether all fields with dot notation should be parsed as nested objects.
   * @default false
   * @example
   * const data = new FormData()
   * data.append('obj.key1', 'value1')
   * data.append('obj.key2', 'value2')
   *
   * If dot is false:
   * parseBody should return { 'obj.key1': 'value1', 'obj.key2': 'value2' }
   *
   * If dot is true:
   * parseBody should return { obj: { key1: 'value1', key2: 'value2' } }
   */
  dot: boolean
}

/**
 * Parses the body of a request based on the provided options.
 *
 * @template T - The type of the parsed body data.
 * @param {HonoRequest | Request} request - The request object to parse.
 * @param {Partial<ParseBodyOptions>} [options] - Options for parsing the body.
 * @returns {Promise<T>} The parsed body data.
 */
interface ParseBody {
  <Options extends Partial<ParseBodyOptions>, T extends BodyData<Options>>(
    request: HonoRequest | Request,
    options?: Options
  ): Promise<T>
  <T extends BodyData>(
    request: HonoRequest | Request,
    options?: Partial<ParseBodyOptions>
  ): Promise<T>
}
export const parseBody: ParseBody = async (
  request: HonoRequest | Request,
  options = Object.create(null)
) => {
  const { all = false, dot = false } = options

  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers
  const contentType = headers.get('Content-Type')

  if (
    contentType?.startsWith('multipart/form-data') ||
    contentType?.startsWith('application/x-www-form-urlencoded')
  ) {
    return parseFormData(request, { all, dot })
  }

  return {}
}

/**
 * Parses form data from a request.
 *
 * @template T - The type of the parsed body data.
 * @param {HonoRequest | Request} request - The request object containing form data.
 * @param {ParseBodyOptions} options - Options for parsing the form data.
 * @returns {Promise<T>} The parsed body data.
 */
async function parseFormData<T extends BodyData>(
  request: HonoRequest | Request,
  options: ParseBodyOptions
): Promise<T> {
  const formData = await (request as Request).formData()

  if (formData) {
    return convertFormDataToBodyData<T>(formData, options)
  }

  return {} as T
}

/**
 * Converts form data to body data based on the provided options.
 *
 * @template T - The type of the parsed body data.
 * @param {FormData} formData - The form data to convert.
 * @param {ParseBodyOptions} options - Options for parsing the form data.
 * @returns {T} The converted body data.
 */
function convertFormDataToBodyData<T extends BodyData = BodyData>(
  formData: FormData,
  options: ParseBodyOptions
): T {
  const form: BodyData = Object.create(null)

  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith('[]')

    if (!shouldParseAllValues) {
      form[key] = value
    } else {
      handleParsingAllValues(form, key, value)
    }
  })

  if (options.dot) {
    Object.entries(form).forEach(([key, value]) => {
      const shouldParseDotValues = key.includes('.')

      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key, value)
        delete form[key]
      }
    })
  }

  return form as T
}

/**
 * Handles parsing all values for a given key, supporting multiple values as arrays.
 *
 * @param {BodyData} form - The form data object.
 * @param {string} key - The key to parse.
 * @param {FormDataEntryValue} value - The value to assign.
 */
const handleParsingAllValues = (
  form: BodyData<{ all: true }>,
  key: string,
  value: FormDataEntryValue
): void => {
  if (form[key] !== undefined) {
    if (Array.isArray(form[key])) {
      ;(form[key] as (string | File)[]).push(value)
    } else {
      form[key] = [form[key] as string | File, value]
    }
  } else {
    form[key] = value
  }
}

/**
 * Handles parsing nested values using dot notation keys.
 *
 * @param {BodyData} form - The form data object.
 * @param {string} key - The dot notation key.
 * @param {BodyDataValue} value - The value to assign.
 */
const handleParsingNestedValues = (
  form: BodyData,
  key: string,
  value: BodyDataValue<Partial<ParseBodyOptions>>
): void => {
  let nestedForm = form
  const keys = key.split('.')

  keys.forEach((key, index) => {
    if (index === keys.length - 1) {
      nestedForm[key] = value
    } else {
      if (
        !nestedForm[key] ||
        typeof nestedForm[key] !== 'object' ||
        Array.isArray(nestedForm[key]) ||
        nestedForm[key] instanceof File
      ) {
        nestedForm[key] = Object.create(null)
      }
      nestedForm = nestedForm[key] as unknown as BodyData
    }
  })
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/buffer.test.ts
```typescript
import { createHash } from 'crypto'
import { bufferToFormData, bufferToString, equal, timingSafeEqual } from './buffer'

describe('equal', () => {
  it('should return true for identical ArrayBuffers', () => {
    const buffer1 = new ArrayBuffer(1)
    const buffer2 = buffer1
    expect(equal(buffer1, buffer2)).toBe(true)
  })

  it('should return false for ArrayBuffers of different lengths', () => {
    const buffer1 = new ArrayBuffer(1)
    const buffer2 = new ArrayBuffer(2)
    expect(equal(buffer1, buffer2)).toBe(false)
  })

  it('should return false for ArrayBuffers with different content', () => {
    const buffer1 = new Uint8Array([1, 2, 3, 4]).buffer
    const buffer2 = new Uint8Array([2, 2, 3, 4]).buffer
    expect(equal(buffer1, buffer2)).toBe(false)
  })

  it('should return true for ArrayBuffers with identical content', () => {
    const buffer1 = new Uint8Array([1, 2, 3, 4]).buffer
    const buffer2 = new Uint8Array([1, 2, 3, 4]).buffer
    expect(equal(buffer1, buffer2)).toBe(true)
  })
})

describe('buffer', () => {
  it('positive', async () => {
    expect(
      await timingSafeEqual(
        '127e6fbfe24a750e72930c220a8e138275656b8e5d8f48a98c3c92df2caba935',
        '127e6fbfe24a750e72930c220a8e138275656b8e5d8f48a98c3c92df2caba935'
      )
    ).toBe(true)
    expect(await timingSafeEqual('a', 'a')).toBe(true)
    expect(await timingSafeEqual('', '')).toBe(true)
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    expect(await timingSafeEqual(undefined, undefined)).toBe(true)
    expect(await timingSafeEqual(true, true)).toBe(true)
    expect(await timingSafeEqual(false, false)).toBe(true)
    expect(
      await timingSafeEqual(true, true, (d: boolean) =>
        createHash('sha256').update(d.toString()).digest('hex')
      )
    )
  })

  it('negative', async () => {
    expect(await timingSafeEqual('a', 'b')).toBe(false)
    expect(
      await timingSafeEqual('a', 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')
    ).toBe(false)
    expect(
      await timingSafeEqual('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', 'a')
    ).toBe(false)
    expect(await timingSafeEqual('alpha', 'beta')).toBe(false)
    expect(await timingSafeEqual(false, true)).toBe(false)
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    expect(await timingSafeEqual(false, undefined)).toBe(false)
    expect(
      await timingSafeEqual(
        () => {},
        () => {}
      )
    ).toBe(false)
    expect(await timingSafeEqual({}, {})).toBe(false)
    expect(await timingSafeEqual({ a: 1 }, { a: 1 })).toBe(false)
    expect(await timingSafeEqual({ a: 1 }, { a: 2 })).toBe(false)
    expect(await timingSafeEqual([1, 2], [1, 2])).toBe(false)
    expect(await timingSafeEqual([1, 2], [1, 2, 3])).toBe(false)
    expect(await timingSafeEqual('a', 'b', () => undefined)).toBe(false)
  })
})

describe('bufferToString', () => {
  it('Should return あいうえお', () => {
    const bytes = [227, 129, 130, 227, 129, 132, 227, 129, 134, 227, 129, 136, 227, 129, 138]
    const buffer = Uint8Array.from(bytes).buffer
    expect(bufferToString(buffer)).toBe('あいうえお')
  })
  it('should return the passed arguments as is ', () => {
    const notBuffer = 'あいうえお' as unknown as ArrayBuffer
    expect(bufferToString(notBuffer)).toBe('あいうえお')
  })
})

describe('bufferToFormData', () => {
  it('Should parse multipart/form-data from ArrayBuffer', async () => {
    const encoder = new TextEncoder()
    const testData =
      '--sampleboundary\r\nContent-Disposition: form-data; name="test"\r\n\r\nHello\r\n--sampleboundary--'
    const arrayBuffer = encoder.encode(testData).buffer

    const result = await bufferToFormData(
      arrayBuffer,
      'multipart/form-data; boundary=sampleboundary'
    )

    expect(result.get('test')).toBe('Hello')
  })

  it('Should parse application/x-www-form-urlencoded from ArrayBuffer', async () => {
    const encoder = new TextEncoder()
    const searchParams = new URLSearchParams()
    searchParams.append('id', '123')
    searchParams.append('title', 'Good title')
    const testData = searchParams.toString()
    const arrayBuffer = encoder.encode(testData).buffer

    const result = await bufferToFormData(arrayBuffer, 'application/x-www-form-urlencoded')

    expect(result.get('id')).toBe('123')
    expect(result.get('title')).toBe('Good title')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/buffer.ts
```typescript
/**
 * @module
 * Buffer utility.
 */

import { sha256 } from './crypto'

export const equal = (a: ArrayBuffer, b: ArrayBuffer): boolean => {
  if (a === b) {
    return true
  }
  if (a.byteLength !== b.byteLength) {
    return false
  }

  const va = new DataView(a)
  const vb = new DataView(b)

  let i = va.byteLength
  while (i--) {
    if (va.getUint8(i) !== vb.getUint8(i)) {
      return false
    }
  }

  return true
}

export const timingSafeEqual = async (
  a: string | object | boolean,
  b: string | object | boolean,
  hashFunction?: Function
): Promise<boolean> => {
  if (!hashFunction) {
    hashFunction = sha256
  }

  const [sa, sb] = await Promise.all([hashFunction(a), hashFunction(b)])

  if (!sa || !sb) {
    return false
  }

  return sa === sb && a === b
}

export const bufferToString = (buffer: ArrayBuffer): string => {
  if (buffer instanceof ArrayBuffer) {
    const enc = new TextDecoder('utf-8')
    return enc.decode(buffer)
  }
  return buffer
}

export const bufferToFormData = (
  arrayBuffer: ArrayBuffer,
  contentType: string
): Promise<FormData> => {
  const response = new Response(arrayBuffer, {
    headers: {
      'Content-Type': contentType,
    },
  })
  return response.formData()
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/color.test.ts
```typescript
import { getColorEnabled } from './color'

describe('getColorEnabled() - With colors enabled', () => {
  it('should return true', async () => {
    expect(getColorEnabled()).toBe(true)
  })
})

describe('getColorEnabled() - With NO_COLOR environment variable set', () => {
  beforeAll(() => {
    vi.stubEnv('NO_COLOR', '1')
  })

  afterAll(() => {
    vi.unstubAllEnvs()
  })

  it('should return false', async () => {
    expect(getColorEnabled()).toBe(false)
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/color.ts
```typescript
/**
 * @module
 * Color utility.
 */

/**
 * Get whether color change on terminal is enabled or disabled.
 * If `NO_COLOR` environment variable is set, this function returns `false`.
 * @see {@link https://no-color.org/}
 *
 * @returns {boolean}
 */
export function getColorEnabled(): boolean {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { process, Deno } = globalThis as any

  const isNoColor =
    typeof Deno?.noColor === 'boolean'
      ? (Deno.noColor as boolean)
      : process !== undefined
      ? // eslint-disable-next-line no-unsafe-optional-chaining
        'NO_COLOR' in process?.env
      : false

  return !isNoColor
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/compress.ts
```typescript
/**
 * @module
 * Constants for compression.
 */

/**
 * Match for compressible content type.
 */
export const COMPRESSIBLE_CONTENT_TYPE_REGEX =
  /^\s*(?:text\/(?!event-stream(?:[;\s]|$))[^;\s]+|application\/(?:javascript|json|xml|xml-dtd|ecmascript|dart|postscript|rtf|tar|toml|vnd\.dart|vnd\.ms-fontobject|vnd\.ms-opentype|wasm|x-httpd-php|x-javascript|x-ns-proxy-autoconfig|x-sh|x-tar|x-virtualbox-hdd|x-virtualbox-ova|x-virtualbox-ovf|x-virtualbox-vbox|x-virtualbox-vdi|x-virtualbox-vhd|x-virtualbox-vmdk|x-www-form-urlencoded)|font\/(?:otf|ttf)|image\/(?:bmp|vnd\.adobe\.photoshop|vnd\.microsoft\.icon|vnd\.ms-dds|x-icon|x-ms-bmp)|message\/rfc822|model\/gltf-binary|x-shader\/x-fragment|x-shader\/x-vertex|[^;\s]+?\+(?:json|text|xml|yaml))(?:[;\s]|$)/i

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/concurrent.test.ts
```typescript
import { createPool } from './concurrent'

describe('concurrent execution', () => {
  test.each`
    concurrency | count
    ${1}        | ${10}
    ${10}       | ${10}
    ${100}      | ${10}
    ${Infinity} | ${2000}
  `('concurrency $concurrency, count $count', async ({ concurrency, count }) => {
    const running = new Set()

    const pool = createPool({ concurrency })
    let resolve: (() => void) | undefined
    const promise = new Promise<void>((r) => {
      resolve = r
    })
    const fn = async (i: number) => {
      if (running.size > concurrency) {
        throw new Error('concurrency exceeded')
      }

      running.add(i)
      await promise
      running.delete(i)
      return i
    }

    const jobs = new Array(count).fill(0).map((_, i) => () => fn(i))
    const expectedResults = new Array(count).fill(0).map((_, i) => i)
    const resultPromises = jobs.map((job) => pool.run(job))

    expect(running.size).toBe(Math.min(concurrency, count))
    resolve?.()
    const results = await Promise.all(resultPromises)
    expect(running.size).toBe(0)
    expect(results).toEqual(expectedResults)
  })

  describe('with interval', () => {
    test.each`
      concurrency | interval
      ${1}        | ${10}
      ${2}        | ${10}
    `('concurrency $concurrency, interval $interval', async ({ concurrency, interval }) => {
      const workingTimeQueue: number[] = []
      const pool = createPool({ concurrency, interval })
      const fn = async (i: number) => {
        const now = Date.now()
        if (workingTimeQueue.length >= concurrency) {
          const last = workingTimeQueue.shift()
          // Not so accurate, -1 ms is acceptable
          if (last && now - last < interval - 1) {
            throw new Error('interval violated')
          }
        }
        workingTimeQueue.push(now)
        return i
      }

      const jobs = new Array(10).fill(0).map((_, i) => () => fn(i))
      const expectedResults = new Array(10).fill(0).map((_, i) => i)
      const resultPromises = jobs.map((job) => pool.run(job))

      const results = await Promise.all(resultPromises)
      expect(results).toEqual(expectedResults)
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/concurrent.ts
```typescript
/**
 * @module
 * Concurrent utility.
 */

const DEFAULT_CONCURRENCY = 1024

export interface Pool {
  run<T>(fn: () => T): Promise<T>
}

export const createPool = ({
  concurrency,
  interval,
}: {
  concurrency?: number
  interval?: number
} = {}): Pool => {
  concurrency ||= DEFAULT_CONCURRENCY

  if (concurrency === Infinity) {
    // unlimited
    return {
      run: async (fn) => fn(),
    }
  }

  const pool: Set<{}> = new Set()
  const run = async <T>(
    fn: () => T,
    promise?: Promise<T>,
    resolve?: (result: T) => void
  ): Promise<T> => {
    if (pool.size >= (concurrency as number)) {
      promise ||= new Promise<T>((r) => (resolve = r))
      setTimeout(() => run(fn, promise, resolve))
      return promise
    }
    const marker = {}
    pool.add(marker)
    const result = await fn()
    if (interval) {
      setTimeout(() => pool.delete(marker), interval)
    } else {
      pool.delete(marker)
    }
    if (resolve) {
      resolve(result)
      return promise as Promise<T>
    } else {
      return result
    }
  }
  return { run }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/constants.ts
```typescript
/**
 * Constant used to mark a composed handler.
 */
export const COMPOSED_HANDLER = '__COMPOSED_HANDLER'

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/cookie.test.ts
```typescript
import type { Cookie, SignedCookie } from './cookie'
import { parse, parseSigned, serialize, serializeSigned } from './cookie'

describe('Parse cookie', () => {
  it('Should parse cookies', () => {
    const cookieString = 'yummy_cookie=choco; tasty_cookie = strawberry '
    const cookie: Cookie = parse(cookieString)
    expect(cookie['yummy_cookie']).toBe('choco')
    expect(cookie['tasty_cookie']).toBe('strawberry')
  })

  it('Should parse quoted cookie values', () => {
    const cookieString =
      'yummy_cookie="choco"; tasty_cookie = " strawberry " ; best_cookie="%20sugar%20";'
    const cookie: Cookie = parse(cookieString)
    expect(cookie['yummy_cookie']).toBe('choco')
    expect(cookie['tasty_cookie']).toBe(' strawberry ')
    expect(cookie['best_cookie']).toBe(' sugar ')
  })

  it('Should parse empty cookies', () => {
    const cookie: Cookie = parse('')
    expect(Object.keys(cookie).length).toBe(0)
  })

  it('Should parse one cookie specified by name', () => {
    const cookieString = 'yummy_cookie=choco; tasty_cookie = strawberry '
    const cookie: Cookie = parse(cookieString, 'yummy_cookie')
    expect(cookie['yummy_cookie']).toBe('choco')
    expect(cookie['tasty_cookie']).toBeUndefined()
  })

  it('Should parse one cookie specified by name even if it is not found', () => {
    const cookieString = 'yummy_cookie=choco; tasty_cookie = strawberry '
    const cookie: Cookie = parse(cookieString, 'no_such_cookie')
    expect(cookie['yummy_cookie']).toBeUndefined()
    expect(cookie['tasty_cookie']).toBeUndefined()
    expect(cookie['no_such_cookie']).toBeUndefined()
  })

  it('Should parse cookies with no value', () => {
    const cookieString = 'yummy_cookie=; tasty_cookie = ; best_cookie= ; last_cookie=""'
    const cookie: Cookie = parse(cookieString)
    expect(cookie['yummy_cookie']).toBe('')
    expect(cookie['tasty_cookie']).toBe('')
    expect(cookie['best_cookie']).toBe('')
    expect(cookie['last_cookie']).toBe('')
  })

  it('Should parse cookies but not process signed cookies', () => {
    // also contains another cookie with a '.' in its value to test it is not misinterpreted as signed cookie
    const cookieString =
      'yummy_cookie=choco; tasty_cookie = strawberry.I9qAeGQOvWjCEJgRPmrw90JjYpnnX2C9zoOiGSxh1Ig%3D; great_cookie=rating3.5; best_cookie=sugar.valueShapedLikeASignatureButIsNotASignature%3D'
    const cookie: Cookie = parse(cookieString)
    expect(cookie['yummy_cookie']).toBe('choco')
    expect(cookie['tasty_cookie']).toBe('strawberry.I9qAeGQOvWjCEJgRPmrw90JjYpnnX2C9zoOiGSxh1Ig=')
    expect(cookie['great_cookie']).toBe('rating3.5')
    expect(cookie['best_cookie']).toBe('sugar.valueShapedLikeASignatureButIsNotASignature=')
  })

  it('Should ignore invalid cookie names', () => {
    const cookieString = 'yummy_cookie=choco; tasty cookie=strawberry; best_cookie\\=sugar; =ng'
    const cookie: Cookie = parse(cookieString)
    expect(cookie['yummy_cookie']).toBe('choco')
    expect(cookie['tasty cookie']).toBeUndefined()
    expect(cookie['best_cookie\\']).toBeUndefined()
    expect(cookie['']).toBeUndefined()
  })

  it('Should ignore invalid cookie values', () => {
    const cookieString = 'yummy_cookie=choco\\nchip; tasty_cookie=strawberry; best_cookie="sugar'
    const cookie: Cookie = parse(cookieString)
    expect(cookie['yummy_cookie']).toBeUndefined()
    expect(cookie['tasty_cookie']).toBe('strawberry')
    expect(cookie['best_cookie\\']).toBeUndefined()
  })

  it('Should parse signed cookies', async () => {
    const secret = 'secret ingredient'
    const cookieString =
      'yummy_cookie=choco.UdFR2rBpS1GsHfGlUiYyMIdqxqwuEgplyQIgTJgpGWY%3D; tasty_cookie = strawberry.I9qAeGQOvWjCEJgRPmrw90JjYpnnX2C9zoOiGSxh1Ig%3D'
    const cookie: SignedCookie = await parseSigned(cookieString, secret)
    expect(cookie['yummy_cookie']).toBe('choco')
    expect(cookie['tasty_cookie']).toBe('strawberry')
  })

  it('Should parse signed cookies with binary secret', async () => {
    const secret = new Uint8Array([
      172, 142, 204, 63, 210, 136, 58, 143, 25, 18, 159, 16, 161, 34, 94,
    ])
    const cookieString =
      'yummy_cookie=choco.8Km4IwZETZdwiOfrT7KgYjKXwiO98XIkms0tOtRa2TA%3D; tasty_cookie = strawberry.TbV33P%2Bi1K0JTxMzNYq7FV9fB4s2VlQcBCBFDxTrUSg%3D'
    const cookie: SignedCookie = await parseSigned(cookieString, secret)
    expect(cookie['yummy_cookie']).toBe('choco')
    expect(cookie['tasty_cookie']).toBe('strawberry')
  })

  it('Should parse signed cookies containing the signature separator', async () => {
    const secret = 'secret ingredient'
    const cookieString = 'yummy_cookie=choco.chip.2%2FJA0c68Y3zm0DvSvHyR6IRysDWmHW0LfoaC0AkyOpw%3D'
    const cookie: SignedCookie = await parseSigned(cookieString, secret)
    expect(cookie['yummy_cookie']).toBe('choco.chip')
  })

  it('Should parse signed cookies and return "false" for wrong signature', async () => {
    const secret = 'secret ingredient'
    // tasty_cookie has invalid signature
    const cookieString =
      'yummy_cookie=choco.UdFR2rBpS1GsHfGlUiYyMIdqxqwuEgplyQIgTJgpGWY%3D; tasty_cookie = strawberry.LAa7RX43t2vCrLNcKmNG65H41OkyV02sraRPuY5RuVg%3D'
    const cookie: SignedCookie = await parseSigned(cookieString, secret)
    expect(cookie['yummy_cookie']).toBe('choco')
    expect(cookie['tasty_cookie']).toBe(false)
  })

  it('Should parse signed cookies and return "false" for corrupt signature', async () => {
    const secret = 'secret ingredient'
    // yummy_cookie has corrupt signature (i.e. invalid base64 encoding)
    // best_cookie has a shape that matches the signature format but isn't actually a signature
    const cookieString =
      'yummy_cookie=choco.?dFR2rBpS1GsHfGlUiYyMIdqxqwuEgplyQIgTJgpGWY%3D; tasty_cookie = strawberry.I9qAeGQOvWjCEJgRPmrw90JjYpnnX2C9zoOiGSxh1Ig%3D; best_cookie=sugar.valueShapedLikeASignatureButIsNotASignature%3D'
    const cookie: SignedCookie = await parseSigned(cookieString, secret)
    expect(cookie['yummy_cookie']).toBe(false)
    expect(cookie['tasty_cookie']).toBe('strawberry')
    expect(cookie['best_cookie']).toBe(false)
  })

  it('Should parse one signed cookie specified by name', async () => {
    const secret = 'secret ingredient'
    const cookieString =
      'yummy_cookie=choco.UdFR2rBpS1GsHfGlUiYyMIdqxqwuEgplyQIgTJgpGWY%3D; tasty_cookie = strawberry.I9qAeGQOvWjCEJgRPmrw90JjYpnnX2C9zoOiGSxh1Ig%3D'
    const cookie: SignedCookie = await parseSigned(cookieString, secret, 'tasty_cookie')
    expect(cookie['yummy_cookie']).toBeUndefined()
    expect(cookie['tasty_cookie']).toBe('strawberry')
  })

  it('Should parse one signed cookie specified by name and return "false" for wrong signature', async () => {
    const secret = 'secret ingredient'
    // tasty_cookie has invalid signature
    const cookieString =
      'yummy_cookie=choco.UdFR2rBpS1GsHfGlUiYyMIdqxqwuEgplyQIgTJgpGWY%3D; tasty_cookie = strawberry.LAa7RX43t2vCrLNcKmNG65H41OkyV02sraRPuY5RuVg%3D'
    const cookie: SignedCookie = await parseSigned(cookieString, secret, 'tasty_cookie')
    expect(cookie['yummy_cookie']).toBeUndefined()
    expect(cookie['tasty_cookie']).toBe(false)
  })

  it('Should parse signed cookies and ignore regular cookies', async () => {
    const secret = 'secret ingredient'
    // also contains another cookie with a '.' in its value to test it is not misinterpreted as signed cookie
    const cookieString =
      'yummy_cookie=choco; tasty_cookie = strawberry.I9qAeGQOvWjCEJgRPmrw90JjYpnnX2C9zoOiGSxh1Ig%3D; great_cookie=rating3.5'
    const cookie: SignedCookie = await parseSigned(cookieString, secret)
    expect(cookie['yummy_cookie']).toBeUndefined()
    expect(cookie['tasty_cookie']).toBe('strawberry')
    expect(cookie['great_cookie']).toBeUndefined()
  })
})

describe('Set cookie', () => {
  it('Should serialize cookie', () => {
    const serialized = serialize('delicious_cookie', 'macha')
    expect(serialized).toBe('delicious_cookie=macha')
  })

  it('Should serialize cookie with all options', () => {
    const serialized = serialize('__Secure-great_cookie', 'banana', {
      path: '/',
      secure: true,
      domain: 'example.com',
      httpOnly: true,
      maxAge: 1000,
      expires: new Date(Date.UTC(2000, 11, 24, 10, 30, 59, 900)),
      sameSite: 'Strict',
      priority: 'High',
      partitioned: true,
    })
    expect(serialized).toBe(
      '__Secure-great_cookie=banana; Max-Age=1000; Domain=example.com; Path=/; Expires=Sun, 24 Dec 2000 10:30:59 GMT; HttpOnly; Secure; SameSite=Strict; Priority=High; Partitioned'
    )
  })

  it('Should serialize __Host- cookie with all valid options', () => {
    const serialized = serialize('__Host-great_cookie', 'banana', {
      path: '/',
      secure: true,
      httpOnly: true,
      maxAge: 1000,
      expires: new Date(Date.UTC(2000, 11, 24, 10, 30, 59, 900)),
      sameSite: 'Strict',
      priority: 'High',
      partitioned: true,
    })
    expect(serialized).toBe(
      '__Host-great_cookie=banana; Max-Age=1000; Path=/; Expires=Sun, 24 Dec 2000 10:30:59 GMT; HttpOnly; Secure; SameSite=Strict; Priority=High; Partitioned'
    )
  })

  it('Should serialize a signed cookie', async () => {
    const secret = 'secret chocolate chips'
    const serialized = await serializeSigned('delicious_cookie', 'macha', secret)
    expect(serialized).toBe(
      'delicious_cookie=macha.diubJPY8O7hI1pLa42QSfkPiyDWQ0I4DnlACH%2FN2HaA%3D'
    )
  })

  it('Should serialize signed cookie with all options', async () => {
    const secret = 'secret chocolate chips'
    const serialized = await serializeSigned('great_cookie', 'banana', secret, {
      path: '/',
      secure: true,
      domain: 'example.com',
      httpOnly: true,
      maxAge: 1000,
      expires: new Date(Date.UTC(2000, 11, 24, 10, 30, 59, 900)),
      sameSite: 'Strict',
      priority: 'High',
      partitioned: true,
    })
    expect(serialized).toBe(
      'great_cookie=banana.hSo6gB7YT2db0WBiEAakEmh7dtwEL0DSp76G23WvHuQ%3D; Max-Age=1000; Domain=example.com; Path=/; Expires=Sun, 24 Dec 2000 10:30:59 GMT; HttpOnly; Secure; SameSite=Strict; Priority=High; Partitioned'
    )
  })

  it('Should serialize cookie with maxAge is 0', () => {
    const serialized = serialize('great_cookie', 'banana', {
      maxAge: 0,
    })
    expect(serialized).toBe('great_cookie=banana; Max-Age=0')
  })

  it('Should serialize cookie with maxAge is -1', () => {
    const serialized = serialize('great_cookie', 'banana', {
      maxAge: -1,
    })
    expect(serialized).toBe('great_cookie=banana')
  })

  it('Should throw Error cookie with maxAge grater than 400days', () => {
    expect(() => {
      serialize('great_cookie', 'banana', {
        maxAge: 3600 * 24 * 401,
      })
    }).toThrowError(
      'Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.'
    )
  })

  it('Should throw Error cookie with expires grater than 400days', () => {
    const now = Date.now()
    const day401 = new Date(now + 1000 * 3600 * 24 * 401)
    expect(() => {
      serialize('great_cookie', 'banana', {
        expires: day401,
      })
    }).toThrowError(
      'Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.'
    )
  })

  it('Should throw Error Partitioned cookie without Secure attributes', () => {
    expect(() => {
      serialize('great_cookie', 'banana', {
        partitioned: true,
      })
    }).toThrowError('Partitioned Cookie must have Secure attributes')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/cookie.ts
```typescript
/**
 * @module
 * Cookie utility.
 */

import { decodeURIComponent_ } from './url'

export type Cookie = Record<string, string>
export type SignedCookie = Record<string, string | false>

type PartitionedCookieConstraint =
  | { partitioned: true; secure: true }
  | { partitioned?: boolean; secure?: boolean } // reset to default
type SecureCookieConstraint = { secure: true }
type HostCookieConstraint = { secure: true; path: '/'; domain?: undefined }

export type CookieOptions = {
  domain?: string
  expires?: Date
  httpOnly?: boolean
  maxAge?: number
  path?: string
  secure?: boolean
  signingSecret?: string
  sameSite?: 'Strict' | 'Lax' | 'None' | 'strict' | 'lax' | 'none'
  partitioned?: boolean
  priority?: 'Low' | 'Medium' | 'High'
  prefix?: CookiePrefixOptions
} & PartitionedCookieConstraint
export type CookiePrefixOptions = 'host' | 'secure'

export type CookieConstraint<Name> = Name extends `__Secure-${string}`
  ? CookieOptions & SecureCookieConstraint
  : Name extends `__Host-${string}`
  ? CookieOptions & HostCookieConstraint
  : CookieOptions

const algorithm = { name: 'HMAC', hash: 'SHA-256' }

const getCryptoKey = async (secret: string | BufferSource): Promise<CryptoKey> => {
  const secretBuf = typeof secret === 'string' ? new TextEncoder().encode(secret) : secret
  return await crypto.subtle.importKey('raw', secretBuf, algorithm, false, ['sign', 'verify'])
}

const makeSignature = async (value: string, secret: string | BufferSource): Promise<string> => {
  const key = await getCryptoKey(secret)
  const signature = await crypto.subtle.sign(algorithm.name, key, new TextEncoder().encode(value))
  // the returned base64 encoded signature will always be 44 characters long and end with one or two equal signs
  return btoa(String.fromCharCode(...new Uint8Array(signature)))
}

const verifySignature = async (
  base64Signature: string,
  value: string,
  secret: CryptoKey
): Promise<boolean> => {
  try {
    const signatureBinStr = atob(base64Signature)
    const signature = new Uint8Array(signatureBinStr.length)
    for (let i = 0, len = signatureBinStr.length; i < len; i++) {
      signature[i] = signatureBinStr.charCodeAt(i)
    }
    return await crypto.subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value))
  } catch {
    return false
  }
}

// all alphanumeric chars and all of _!#$%&'*.^`|~+-
// (see: https://datatracker.ietf.org/doc/html/rfc6265#section-4.1.1)
const validCookieNameRegEx = /^[\w!#$%&'*.^`|~+-]+$/

// all ASCII chars 32-126 except 34, 59, and 92 (i.e. space to tilde but not double quote, semicolon, or backslash)
// (see: https://datatracker.ietf.org/doc/html/rfc6265#section-4.1.1)
//
// note: the spec also prohibits comma and space, but we allow both since they are very common in the real world
// (see: https://github.com/golang/go/issues/7243)
const validCookieValueRegEx = /^[ !#-:<-[\]-~]*$/

export const parse = (cookie: string, name?: string): Cookie => {
  if (name && cookie.indexOf(name) === -1) {
    // Fast-path: return immediately if the demanded-key is not in the cookie string
    return {}
  }
  const pairs = cookie.trim().split(';')
  const parsedCookie: Cookie = {}
  for (let pairStr of pairs) {
    pairStr = pairStr.trim()
    const valueStartPos = pairStr.indexOf('=')
    if (valueStartPos === -1) {
      continue
    }

    const cookieName = pairStr.substring(0, valueStartPos).trim()
    if ((name && name !== cookieName) || !validCookieNameRegEx.test(cookieName)) {
      continue
    }

    let cookieValue = pairStr.substring(valueStartPos + 1).trim()
    if (cookieValue.startsWith('"') && cookieValue.endsWith('"')) {
      cookieValue = cookieValue.slice(1, -1)
    }
    if (validCookieValueRegEx.test(cookieValue)) {
      parsedCookie[cookieName] = decodeURIComponent_(cookieValue)
      if (name) {
        // Fast-path: return only the demanded-key immediately. Other keys are not needed.
        break
      }
    }
  }
  return parsedCookie
}

export const parseSigned = async (
  cookie: string,
  secret: string | BufferSource,
  name?: string
): Promise<SignedCookie> => {
  const parsedCookie: SignedCookie = {}
  const secretKey = await getCryptoKey(secret)

  for (const [key, value] of Object.entries(parse(cookie, name))) {
    const signatureStartPos = value.lastIndexOf('.')
    if (signatureStartPos < 1) {
      continue
    }

    const signedValue = value.substring(0, signatureStartPos)
    const signature = value.substring(signatureStartPos + 1)
    if (signature.length !== 44 || !signature.endsWith('=')) {
      continue
    }

    const isVerified = await verifySignature(signature, signedValue, secretKey)
    parsedCookie[key] = isVerified ? signedValue : false
  }

  return parsedCookie
}

const _serialize = (name: string, value: string, opt: CookieOptions = {}): string => {
  let cookie = `${name}=${value}`

  if (name.startsWith('__Secure-') && !opt.secure) {
    // FIXME: replace link to RFC
    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-13#section-4.1.3.1
    throw new Error('__Secure- Cookie must have Secure attributes')
  }

  if (name.startsWith('__Host-')) {
    // FIXME: replace link to RFC
    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-13#section-4.1.3.2
    if (!opt.secure) {
      throw new Error('__Host- Cookie must have Secure attributes')
    }

    if (opt.path !== '/') {
      throw new Error('__Host- Cookie must have Path attributes with "/"')
    }

    if (opt.domain) {
      throw new Error('__Host- Cookie must not have Domain attributes')
    }
  }

  if (opt && typeof opt.maxAge === 'number' && opt.maxAge >= 0) {
    if (opt.maxAge > 34560000) {
      // FIXME: replace link to RFC
      // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-13#section-4.1.2.2
      throw new Error(
        'Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.'
      )
    }
    cookie += `; Max-Age=${opt.maxAge | 0}`
  }

  if (opt.domain && opt.prefix !== 'host') {
    cookie += `; Domain=${opt.domain}`
  }

  if (opt.path) {
    cookie += `; Path=${opt.path}`
  }

  if (opt.expires) {
    if (opt.expires.getTime() - Date.now() > 34560000_000) {
      // FIXME: replace link to RFC
      // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-13#section-4.1.2.1
      throw new Error(
        'Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.'
      )
    }
    cookie += `; Expires=${opt.expires.toUTCString()}`
  }

  if (opt.httpOnly) {
    cookie += '; HttpOnly'
  }

  if (opt.secure) {
    cookie += '; Secure'
  }

  if (opt.sameSite) {
    cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`
  }

  if (opt.priority) {
    cookie += `; Priority=${opt.priority}`
  }

  if (opt.partitioned) {
    // FIXME: replace link to RFC
    // https://www.ietf.org/archive/id/draft-cutler-httpbis-partitioned-cookies-01.html#section-2.3
    if (!opt.secure) {
      throw new Error('Partitioned Cookie must have Secure attributes')
    }
    cookie += '; Partitioned'
  }

  return cookie
}

export const serialize = <Name extends string>(
  name: Name,
  value: string,
  opt?: CookieConstraint<Name>
): string => {
  value = encodeURIComponent(value)
  return _serialize(name, value, opt)
}

export const serializeSigned = async (
  name: string,
  value: string,
  secret: string | BufferSource,
  opt: CookieOptions = {}
): Promise<string> => {
  const signature = await makeSignature(value, secret)
  value = `${value}.${signature}`
  value = encodeURIComponent(value)
  return _serialize(name, value, opt)
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/crypto.test.ts
```typescript
import { createHash } from 'crypto'
import { md5, sha1, sha256 } from './crypto'

describe('crypto', () => {
  it('sha256', async () => {
    expect(await sha256('hono')).toBe(
      '8b3dc17add91b7e8f0b5109a389927d66001139cd9b03fa7b95f83126e1b2b23'
    )
    expect(await sha256('炎')).toBe(
      '1fddc5a562ee1fbeb4fc6def7d4be4911fcdae4273b02ae3a507b170ba0ea169'
    )
    expect(await sha256('abcdedf')).not.toBe('abcdef')
  })

  it('sha1', async () => {
    expect(await sha1('hono')).toBe('28c7e86f5732391917876b45c06c626c04d77f39')
    expect(await sha1('炎')).toBe('d56e09ae2421b2b8a0b5ee5fdceaed663c8c9472')
    expect(await sha1('abcdedf')).not.toBe('abcdef')
  })

  // MD5 is not part of the WebCrypto standard.
  // Node.js' Web Crypto API does not support it (But Cloudflare Workers supports it).
  // We should skip this test in a Node.js environment.
  it.skip('md5', async () => {
    expect(await md5('hono')).toBe('cf22a160789a91dd5f737cd3b2640cc2')
    expect(await md5('炎')).toBe('f620d89a5a782c22b4420acb39121be3')
    expect(await md5('abcdedf')).not.toBe('abcdef')
  })

  it('Should not be the same values - compare difference objects', async () => {
    expect(await sha256({ foo: 'bar' })).not.toEqual(
      await sha256({
        bar: 'foo',
      })
    )
  })

  it('Should create hash for Buffer', async () => {
    const hash = createHash('sha256').update(new Uint8Array(1)).digest('hex')
    expect(await sha256(new Uint8Array(1))).toBe(hash)
    expect(await sha256(new Uint8Array(1))).not.toEqual(await sha256(new Uint8Array(2)))
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/crypto.ts
```typescript
/**
 * @module
 * Crypto utility.
 */

import type { JSONValue } from './types'

type Algorithm = {
  name: string
  alias: string
}

type Data = string | boolean | number | JSONValue | ArrayBufferView | ArrayBuffer

export const sha256 = async (data: Data): Promise<string | null> => {
  const algorithm: Algorithm = { name: 'SHA-256', alias: 'sha256' }
  const hash = await createHash(data, algorithm)
  return hash
}

export const sha1 = async (data: Data): Promise<string | null> => {
  const algorithm: Algorithm = { name: 'SHA-1', alias: 'sha1' }
  const hash = await createHash(data, algorithm)
  return hash
}

export const md5 = async (data: Data): Promise<string | null> => {
  const algorithm: Algorithm = { name: 'MD5', alias: 'md5' }
  const hash = await createHash(data, algorithm)
  return hash
}

export const createHash = async (data: Data, algorithm: Algorithm): Promise<string | null> => {
  let sourceBuffer: ArrayBufferView | ArrayBuffer

  if (ArrayBuffer.isView(data) || data instanceof ArrayBuffer) {
    sourceBuffer = data
  } else {
    if (typeof data === 'object') {
      data = JSON.stringify(data)
    }
    sourceBuffer = new TextEncoder().encode(String(data))
  }

  if (crypto && crypto.subtle) {
    const buffer = await crypto.subtle.digest(
      {
        name: algorithm.name,
      },
      sourceBuffer as ArrayBuffer
    )
    const hash = Array.prototype.map
      .call(new Uint8Array(buffer), (x) => ('00' + x.toString(16)).slice(-2))
      .join('')
    return hash
  }
  return null
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/encode.test.ts
```typescript
import { decodeBase64Url, encodeBase64Url } from './encode'

const toURLBase64 = (base64String: string): string =>
  base64String.replace(/\+|\//g, (m) => ({ '+': '-', '/': '_' }[m] ?? m))

const str2UInt8Array = (s: string): Uint8Array => {
  const buffer = new Uint8Array(new ArrayBuffer(s.length))
  for (let i = 0, len = buffer.byteLength; i < len; i++) {
    buffer[i] = s.charCodeAt(i)
  }
  return buffer
}

describe('base64', () => {
  const utf8Encoder = new TextEncoder()
  describe.each([
    // basic
    [utf8Encoder.encode('Hello, 世界'), 'SGVsbG8sIOS4lueVjA=='],
    [utf8Encoder.encode('炎'), '54KO'],
    [utf8Encoder.encode('🔥'), '8J+UpQ=='],
    [
      utf8Encoder.encode('http://github.com/honojs/hono'),
      'aHR0cDovL2dpdGh1Yi5jb20vaG9ub2pzL2hvbm8=',
    ],

    // RFC 3548 examples
    [str2UInt8Array('\x14\xfb\x9c\x03\xd9\x7e'), 'FPucA9l+'],
    [str2UInt8Array('\x14\xfb\x9c\x03\xd9'), 'FPucA9k='],
    [str2UInt8Array('\x14\xfb\x9c\x03'), 'FPucAw=='],

    // RFC 4648 examples
    [str2UInt8Array(''), ''],
    [str2UInt8Array('f'), 'Zg=='],
    [str2UInt8Array('fo'), 'Zm8='],
    [str2UInt8Array('foo'), 'Zm9v'],
    [str2UInt8Array('foob'), 'Zm9vYg=='],
    [str2UInt8Array('fooba'), 'Zm9vYmE='],
    [str2UInt8Array('foobar'), 'Zm9vYmFy'],

    // Wikipedia examples
    [str2UInt8Array('sure.'), 'c3VyZS4='],
    [str2UInt8Array('sure'), 'c3VyZQ=='],
    [str2UInt8Array('sur'), 'c3Vy'],
    [str2UInt8Array('su'), 'c3U='],
    [str2UInt8Array('leasure.'), 'bGVhc3VyZS4='],
    [str2UInt8Array('easure.'), 'ZWFzdXJlLg=='],
    [str2UInt8Array('asure.'), 'YXN1cmUu'],
    [str2UInt8Array('sure.'), 'c3VyZS4='],
  ])('%s, %s', (stdDecoded, stdEncoded) => {
    it('encode', () => {
      const got = encodeBase64Url(stdDecoded)
      const want = toURLBase64(stdEncoded)
      expect(got).toStrictEqual(want)
    })
    it('decode', () => {
      const got = decodeBase64Url(toURLBase64(stdEncoded))
      const want = stdDecoded
      expect(got).toStrictEqual(want)
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/encode.ts
```typescript
/**
 * @module
 * Encode utility.
 */

export const decodeBase64Url = (str: string): Uint8Array => {
  return decodeBase64(str.replace(/_|-/g, (m) => ({ _: '/', '-': '+' }[m] ?? m)))
}

export const encodeBase64Url = (buf: ArrayBufferLike): string =>
  encodeBase64(buf).replace(/\/|\+/g, (m) => ({ '/': '_', '+': '-' }[m] ?? m))

// This approach is written in MDN.
// btoa does not support utf-8 characters. So we need a little bit hack.
export const encodeBase64 = (buf: ArrayBufferLike): string => {
  let binary = ''
  const bytes = new Uint8Array(buf)
  for (let i = 0, len = bytes.length; i < len; i++) {
    binary += String.fromCharCode(bytes[i])
  }
  return btoa(binary)
}

// atob does not support utf-8 characters. So we need a little bit hack.
export const decodeBase64 = (str: string): Uint8Array => {
  const binary = atob(str)
  const bytes = new Uint8Array(new ArrayBuffer(binary.length))
  const half = binary.length / 2
  for (let i = 0, j = binary.length - 1; i <= half; i++, j--) {
    bytes[i] = binary.charCodeAt(i)
    bytes[j] = binary.charCodeAt(j)
  }
  return bytes
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/filepath.test.ts
```typescript
import { getFilePath, getFilePathWithoutDefaultDocument } from './filepath'

describe('getFilePathWithoutDefaultDocument', () => {
  it('Should return file path correctly', async () => {
    expect(getFilePathWithoutDefaultDocument({ filename: 'foo.txt' })).toBe('foo.txt')
    expect(getFilePathWithoutDefaultDocument({ filename: 'foo.txt', root: 'bar' })).toBe(
      'bar/foo.txt'
    )

    expect(getFilePathWithoutDefaultDocument({ filename: '../foo' })).toBeUndefined()
    expect(getFilePathWithoutDefaultDocument({ filename: '/../foo' })).toBeUndefined()
    expect(getFilePathWithoutDefaultDocument({ filename: './../foo' })).toBeUndefined()
    expect(getFilePathWithoutDefaultDocument({ filename: 'foo..bar.txt' })).toBe('foo..bar.txt')
    expect(getFilePathWithoutDefaultDocument({ filename: '/foo..bar.txt' })).toBe('foo..bar.txt')
    expect(getFilePathWithoutDefaultDocument({ filename: './foo..bar.txt' })).toBe('foo..bar.txt')
    expect(getFilePathWithoutDefaultDocument({ filename: './..foo/bar.txt' })).toBe('..foo/bar.txt')
    expect(getFilePathWithoutDefaultDocument({ filename: './foo../bar.txt' })).toBe('foo../bar.txt')
    expect(getFilePathWithoutDefaultDocument({ filename: './..foo../bar.txt' })).toBe(
      '..foo../bar.txt'
    )

    expect(
      getFilePathWithoutDefaultDocument({ filename: slashToBackslash('/../foo') })
    ).toBeUndefined()
    expect(
      getFilePathWithoutDefaultDocument({ filename: slashToBackslash('./../foo') })
    ).toBeUndefined()
    expect(getFilePathWithoutDefaultDocument({ filename: slashToBackslash('foo..bar.txt') })).toBe(
      'foo..bar.txt'
    )
    expect(getFilePathWithoutDefaultDocument({ filename: slashToBackslash('/foo..bar.txt') })).toBe(
      'foo..bar.txt'
    )
    expect(
      getFilePathWithoutDefaultDocument({ filename: slashToBackslash('./foo..bar.txt') })
    ).toBe('foo..bar.txt')
    expect(
      getFilePathWithoutDefaultDocument({ filename: slashToBackslash('./..foo/bar.txt') })
    ).toBe('..foo/bar.txt')
    expect(
      getFilePathWithoutDefaultDocument({ filename: slashToBackslash('./foo../bar.txt') })
    ).toBe('foo../bar.txt')
    expect(
      getFilePathWithoutDefaultDocument({ filename: slashToBackslash('./..foo../bar.txt') })
    ).toBe('..foo../bar.txt')
  })
})

describe('getFilePath', () => {
  it('Should return file path correctly', async () => {
    expect(getFilePath({ filename: 'foo' })).toBe('foo/index.html')

    expect(getFilePath({ filename: 'foo', root: 'bar' })).toBe('bar/foo/index.html')

    expect(getFilePath({ filename: 'foo', defaultDocument: 'index.txt' })).toBe('foo/index.txt')
    expect(getFilePath({ filename: 'foo', root: 'bar', defaultDocument: 'index.txt' })).toBe(
      'bar/foo/index.txt'
    )

    expect(getFilePath({ filename: 'filename.suffix_index' })).toBe('filename.suffix_index')
    expect(getFilePath({ filename: 'filename.suffix-index' })).toBe('filename.suffix-index')
  })
})

function slashToBackslash(filename: string) {
  return filename.split('/').join('\\')
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/filepath.ts
```typescript
/**
 * @module
 * FilePath utility.
 */

type FilePathOptions = {
  filename: string
  root?: string
  defaultDocument?: string
}

export const getFilePath = (options: FilePathOptions): string | undefined => {
  let filename = options.filename
  const defaultDocument = options.defaultDocument || 'index.html'

  if (filename.endsWith('/')) {
    // /top/ => /top/index.html
    filename = filename.concat(defaultDocument)
  } else if (!filename.match(/\.[a-zA-Z0-9_-]+$/)) {
    // /top => /top/index.html
    filename = filename.concat('/' + defaultDocument)
  }

  const path = getFilePathWithoutDefaultDocument({
    root: options.root,
    filename,
  })

  return path
}

export const getFilePathWithoutDefaultDocument = (
  options: Omit<FilePathOptions, 'defaultDocument'>
): string | undefined => {
  let root = options.root || ''
  let filename = options.filename

  if (/(?:^|[\/\\])\.\.(?:$|[\/\\])/.test(filename)) {
    return
  }

  // /foo.html => foo.html
  filename = filename.replace(/^\.?[\/\\]/, '')

  // foo\bar.txt => foo/bar.txt
  filename = filename.replace(/\\/, '/')

  // assets/ => assets
  root = root.replace(/\/$/, '')

  // ./assets/foo.html => assets/foo.html
  let path = root ? root + '/' + filename : filename
  path = path.replace(/^\.?\//, '')

  if (root[0] !== '/' && path[0] === '/') {
    return
  }

  return path
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/handler.ts
```typescript
/**
 * @module
 * Handler utility.
 */

import { COMPOSED_HANDLER } from './constants'

export const isMiddleware = (handler: Function) => handler.length > 1
export const findTargetHandler = (handler: Function): Function => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return (handler as any)[COMPOSED_HANDLER]
    ? // eslint-disable-next-line @typescript-eslint/no-explicit-any
      findTargetHandler((handler as any)[COMPOSED_HANDLER])
    : handler
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/headers.ts
```typescript
/**
 * @module
 * HTTP Headers utility.
 */

// note: https://www.iana.org/assignments/http-fields/http-fields.xhtml

export type RequestHeader =
  | 'A-IM'
  | 'Accept'
  | 'Accept-Additions'
  | 'Accept-CH'
  | 'Accept-Charset'
  | 'Accept-Datetime'
  | 'Accept-Encoding'
  | 'Accept-Features'
  | 'Accept-Language'
  | 'Accept-Patch'
  | 'Accept-Post'
  | 'Accept-Ranges'
  | 'Accept-Signature'
  | 'Access-Control'
  | 'Access-Control-Allow-Credentials'
  | 'Access-Control-Allow-Headers'
  | 'Access-Control-Allow-Methods'
  | 'Access-Control-Allow-Origin'
  | 'Access-Control-Expose-Headers'
  | 'Access-Control-Max-Age'
  | 'Access-Control-Request-Headers'
  | 'Access-Control-Request-Method'
  | 'Age'
  | 'Allow'
  | 'ALPN'
  | 'Alt-Svc'
  | 'Alt-Used'
  | 'Alternates'
  | 'AMP-Cache-Transform'
  | 'Apply-To-Redirect-Ref'
  | 'Authentication-Control'
  | 'Authentication-Info'
  | 'Authorization'
  | 'Available-Dictionary'
  | 'C-Ext'
  | 'C-Man'
  | 'C-Opt'
  | 'C-PEP'
  | 'C-PEP-Info'
  | 'Cache-Control'
  | 'Cache-Status'
  | 'Cal-Managed-ID'
  | 'CalDAV-Timezones'
  | 'Capsule-Protocol'
  | 'CDN-Cache-Control'
  | 'CDN-Loop'
  | 'Cert-Not-After'
  | 'Cert-Not-Before'
  | 'Clear-Site-Data'
  | 'Client-Cert'
  | 'Client-Cert-Chain'
  | 'Close'
  | 'CMCD-Object'
  | 'CMCD-Request'
  | 'CMCD-Session'
  | 'CMCD-Status'
  | 'CMSD-Dynamic'
  | 'CMSD-Static'
  | 'Concealed-Auth-Export'
  | 'Configuration-Context'
  | 'Connection'
  | 'Content-Base'
  | 'Content-Digest'
  | 'Content-Disposition'
  | 'Content-Encoding'
  | 'Content-ID'
  | 'Content-Language'
  | 'Content-Length'
  | 'Content-Location'
  | 'Content-MD5'
  | 'Content-Range'
  | 'Content-Script-Type'
  | 'Content-Security-Policy'
  | 'Content-Security-Policy-Report-Only'
  | 'Content-Style-Type'
  | 'Content-Type'
  | 'Content-Version'
  | 'Cookie'
  | 'Cookie2'
  | 'Cross-Origin-Embedder-Policy'
  | 'Cross-Origin-Embedder-Policy-Report-Only'
  | 'Cross-Origin-Opener-Policy'
  | 'Cross-Origin-Opener-Policy-Report-Only'
  | 'Cross-Origin-Resource-Policy'
  | 'CTA-Common-Access-Token'
  | 'DASL'
  | 'Date'
  | 'DAV'
  | 'Default-Style'
  | 'Delta-Base'
  | 'Deprecation'
  | 'Depth'
  | 'Derived-From'
  | 'Destination'
  | 'Differential-ID'
  | 'Dictionary-ID'
  | 'Digest'
  | 'DPoP'
  | 'DPoP-Nonce'
  | 'Early-Data'
  | 'EDIINT-Features'
  | 'ETag'
  | 'Expect'
  | 'Expect-CT'
  | 'Expires'
  | 'Ext'
  | 'Forwarded'
  | 'From'
  | 'GetProfile'
  | 'Hobareg'
  | 'Host'
  | 'HTTP2-Settings'
  | 'If'
  | 'If-Match'
  | 'If-Modified-Since'
  | 'If-None-Match'
  | 'If-Range'
  | 'If-Schedule-Tag-Match'
  | 'If-Unmodified-Since'
  | 'IM'
  | 'Include-Referred-Token-Binding-ID'
  | 'Isolation'
  | 'Keep-Alive'
  | 'Label'
  | 'Last-Event-ID'
  | 'Last-Modified'
  | 'Link'
  | 'Link-Template'
  | 'Location'
  | 'Lock-Token'
  | 'Man'
  | 'Max-Forwards'
  | 'Memento-Datetime'
  | 'Meter'
  | 'Method-Check'
  | 'Method-Check-Expires'
  | 'MIME-Version'
  | 'Negotiate'
  | 'NEL'
  | 'OData-EntityId'
  | 'OData-Isolation'
  | 'OData-MaxVersion'
  | 'OData-Version'
  | 'Opt'
  | 'Optional-WWW-Authenticate'
  | 'Ordering-Type'
  | 'Origin'
  | 'Origin-Agent-Cluster'
  | 'OSCORE'
  | 'OSLC-Core-Version'
  | 'Overwrite'
  | 'P3P'
  | 'PEP'
  | 'PEP-Info'
  | 'Permissions-Policy'
  | 'PICS-Label'
  | 'Ping-From'
  | 'Ping-To'
  | 'Position'
  | 'Pragma'
  | 'Prefer'
  | 'Preference-Applied'
  | 'Priority'
  | 'ProfileObject'
  | 'Protocol'
  | 'Protocol-Info'
  | 'Protocol-Query'
  | 'Protocol-Request'
  | 'Proxy-Authenticate'
  | 'Proxy-Authentication-Info'
  | 'Proxy-Authorization'
  | 'Proxy-Features'
  | 'Proxy-Instruction'
  | 'Proxy-Status'
  | 'Public'
  | 'Public-Key-Pins'
  | 'Public-Key-Pins-Report-Only'
  | 'Range'
  | 'Redirect-Ref'
  | 'Referer'
  | 'Referer-Root'
  | 'Referrer-Policy'
  | 'Refresh'
  | 'Repeatability-Client-ID'
  | 'Repeatability-First-Sent'
  | 'Repeatability-Request-ID'
  | 'Repeatability-Result'
  | 'Replay-Nonce'
  | 'Reporting-Endpoints'
  | 'Repr-Digest'
  | 'Retry-After'
  | 'Safe'
  | 'Schedule-Reply'
  | 'Schedule-Tag'
  | 'Sec-GPC'
  | 'Sec-Purpose'
  | 'Sec-Token-Binding'
  | 'Sec-WebSocket-Accept'
  | 'Sec-WebSocket-Extensions'
  | 'Sec-WebSocket-Key'
  | 'Sec-WebSocket-Protocol'
  | 'Sec-WebSocket-Version'
  | 'Security-Scheme'
  | 'Server'
  | 'Server-Timing'
  | 'Set-Cookie'
  | 'Set-Cookie2'
  | 'SetProfile'
  | 'Signature'
  | 'Signature-Input'
  | 'SLUG'
  | 'SoapAction'
  | 'Status-URI'
  | 'Strict-Transport-Security'
  | 'Sunset'
  | 'Surrogate-Capability'
  | 'Surrogate-Control'
  | 'TCN'
  | 'TE'
  | 'Timeout'
  | 'Timing-Allow-Origin'
  | 'Topic'
  | 'Traceparent'
  | 'Tracestate'
  | 'Trailer'
  | 'Transfer-Encoding'
  | 'TTL'
  | 'Upgrade'
  | 'Urgency'
  | 'URI'
  | 'Use-As-Dictionary'
  | 'User-Agent'
  | 'Variant-Vary'
  | 'Vary'
  | 'Via'
  | 'Want-Content-Digest'
  | 'Want-Digest'
  | 'Want-Repr-Digest'
  | 'Warning'
  | 'WWW-Authenticate'
  | 'X-Content-Type-Options'
  | 'X-Frame-Options'

export type ResponseHeader =
  | 'Access-Control-Allow-Credentials'
  | 'Access-Control-Allow-Headers'
  | 'Access-Control-Allow-Methods'
  | 'Access-Control-Allow-Origin'
  | 'Access-Control-Expose-Headers'
  | 'Access-Control-Max-Age'
  | 'Age'
  | 'Allow'
  | 'Cache-Control'
  | 'Clear-Site-Data'
  | 'Content-Disposition'
  | 'Content-Encoding'
  | 'Content-Language'
  | 'Content-Length'
  | 'Content-Location'
  | 'Content-Range'
  | 'Content-Security-Policy'
  | 'Content-Security-Policy-Report-Only'
  | 'Content-Type'
  | 'Cookie'
  | 'Cross-Origin-Embedder-Policy'
  | 'Cross-Origin-Opener-Policy'
  | 'Cross-Origin-Resource-Policy'
  | 'Date'
  | 'ETag'
  | 'Expires'
  | 'Last-Modified'
  | 'Location'
  | 'Permissions-Policy'
  | 'Pragma'
  | 'Retry-After'
  | 'Save-Data'
  | 'Sec-CH-Prefers-Color-Scheme'
  | 'Sec-CH-Prefers-Reduced-Motion'
  | 'Sec-CH-UA'
  | 'Sec-CH-UA-Arch'
  | 'Sec-CH-UA-Bitness'
  | 'Sec-CH-UA-Form-Factor'
  | 'Sec-CH-UA-Full-Version'
  | 'Sec-CH-UA-Full-Version-List'
  | 'Sec-CH-UA-Mobile'
  | 'Sec-CH-UA-Model'
  | 'Sec-CH-UA-Platform'
  | 'Sec-CH-UA-Platform-Version'
  | 'Sec-CH-UA-WoW64'
  | 'Sec-Fetch-Dest'
  | 'Sec-Fetch-Mode'
  | 'Sec-Fetch-Site'
  | 'Sec-Fetch-User'
  | 'Sec-GPC'
  | 'Server'
  | 'Server-Timing'
  | 'Service-Worker-Navigation-Preload'
  | 'Set-Cookie'
  | 'Strict-Transport-Security'
  | 'Timing-Allow-Origin'
  | 'Trailer'
  | 'Transfer-Encoding'
  | 'Upgrade'
  | 'Vary'
  | 'WWW-Authenticate'
  | 'Warning'
  | 'X-Content-Type-Options'
  | 'X-DNS-Prefetch-Control'
  | 'X-Frame-Options'
  | 'X-Permitted-Cross-Domain-Policies'
  | 'X-Powered-By'
  | 'X-Robots-Tag'
  | 'X-XSS-Protection'

export type AcceptHeader =
  | 'Accept'
  | 'Accept-Charset'
  | 'Accept-Encoding'
  | 'Accept-Language'
  | 'Accept-Patch'
  | 'Accept-Post'
  | 'Accept-Ranges'

// note: `X-${string}` is deprecated
export type CustomHeader = string & {}

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/html.test.ts
```typescript
import { escapeToBuffer } from './html'
import type { StringBuffer } from './html'

describe('HTML utilities', () => {
  describe('escapeToBuffer', () => {
    it('Should escape special characters', () => {
      let buffer: StringBuffer = ['']
      escapeToBuffer('I <b>think</b> this is good.', buffer)
      expect(buffer[0]).toBe('I &lt;b&gt;think&lt;/b&gt; this is good.')

      buffer = ['']
      escapeToBuffer('John "Johnny" Smith', buffer)
      expect(buffer[0]).toBe('John &quot;Johnny&quot; Smith')
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/html.ts
```typescript
/**
 * @module
 * HTML utility.
 */

export const HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3,
} as const
type HtmlEscapedCallbackOpts = {
  buffer?: [string]
  phase: (typeof HtmlEscapedCallbackPhase)[keyof typeof HtmlEscapedCallbackPhase]
  context: Readonly<object> // An object unique to each JSX tree. This object is used as the WeakMap key.
}
export type HtmlEscapedCallback = (opts: HtmlEscapedCallbackOpts) => Promise<string> | undefined
export type HtmlEscaped = {
  isEscaped: true
  callbacks?: HtmlEscapedCallback[]
}
export type HtmlEscapedString = string & HtmlEscaped

/**
 * StringBuffer contains string and Promise<string> alternately
 * The length of the array will be odd, the odd numbered element will be a string,
 * and the even numbered element will be a Promise<string>.
 * When concatenating into a single string, it must be processed from the tail.
 * @example
 * [
 *   'framework.',
 *   Promise.resolve('ultra fast'),
 *   'a ',
 *   Promise.resolve('is '),
 *   'Hono',
 * ]
 */
export type StringBuffer = (string | Promise<string>)[]
export type StringBufferWithCallbacks = StringBuffer & { callbacks: HtmlEscapedCallback[] }

export const raw = (value: unknown, callbacks?: HtmlEscapedCallback[]): HtmlEscapedString => {
  const escapedString = new String(value) as HtmlEscapedString
  escapedString.isEscaped = true
  escapedString.callbacks = callbacks

  return escapedString
}

// The `escapeToBuffer` implementation is based on code from the MIT licensed `react-dom` package.
// https://github.com/facebook/react/blob/main/packages/react-dom-bindings/src/server/escapeTextForBrowser.js

const escapeRe = /[&<>'"]/

export const stringBufferToString = async (
  buffer: StringBuffer,
  callbacks: HtmlEscapedCallback[] | undefined
): Promise<HtmlEscapedString> => {
  let str = ''
  callbacks ||= []
  const resolvedBuffer = await Promise.all(buffer)
  for (let i = resolvedBuffer.length - 1; ; i--) {
    str += resolvedBuffer[i]
    i--
    if (i < 0) {
      break
    }

    let r = resolvedBuffer[i]
    if (typeof r === 'object') {
      callbacks.push(...((r as HtmlEscapedString).callbacks || []))
    }

    const isEscaped = (r as HtmlEscapedString).isEscaped
    r = await (typeof r === 'object' ? (r as HtmlEscapedString).toString() : r)
    if (typeof r === 'object') {
      callbacks.push(...((r as HtmlEscapedString).callbacks || []))
    }

    if ((r as HtmlEscapedString).isEscaped ?? isEscaped) {
      str += r
    } else {
      const buf = [str]
      escapeToBuffer(r, buf)
      str = buf[0]
    }
  }

  return raw(str, callbacks)
}

export const escapeToBuffer = (str: string, buffer: StringBuffer): void => {
  const match = str.search(escapeRe)
  if (match === -1) {
    buffer[0] += str
    return
  }

  let escape
  let index
  let lastIndex = 0

  for (index = match; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34: // "
        escape = '&quot;'
        break
      case 39: // '
        escape = '&#39;'
        break
      case 38: // &
        escape = '&amp;'
        break
      case 60: // <
        escape = '&lt;'
        break
      case 62: // >
        escape = '&gt;'
        break
      default:
        continue
    }

    buffer[0] += str.substring(lastIndex, index) + escape
    lastIndex = index + 1
  }

  buffer[0] += str.substring(lastIndex, index)
}

export const resolveCallbackSync = (str: string | HtmlEscapedString): string => {
  const callbacks = (str as HtmlEscapedString).callbacks as HtmlEscapedCallback[]
  if (!callbacks?.length) {
    return str
  }
  const buffer: [string] = [str]
  const context = {}

  callbacks.forEach((c) => c({ phase: HtmlEscapedCallbackPhase.Stringify, buffer, context }))

  return buffer[0]
}

export const resolveCallback = async (
  str: string | HtmlEscapedString | Promise<string>,
  phase: (typeof HtmlEscapedCallbackPhase)[keyof typeof HtmlEscapedCallbackPhase],
  preserveCallbacks: boolean,
  context: object,
  buffer?: [string]
): Promise<string> => {
  if (typeof str === 'object' && !(str instanceof String)) {
    if (!((str as unknown) instanceof Promise)) {
      str = (str as unknown as string).toString() // HtmlEscapedString object to string
    }
    if ((str as string | Promise<string>) instanceof Promise) {
      str = await (str as unknown as Promise<string>)
    }
  }

  const callbacks = (str as HtmlEscapedString).callbacks as HtmlEscapedCallback[]
  if (!callbacks?.length) {
    return Promise.resolve(str)
  }
  if (buffer) {
    buffer[0] += str
  } else {
    buffer = [str as string]
  }

  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then((res) =>
    Promise.all(
      res
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        .filter<string>(Boolean as any)
        .map((str) => resolveCallback(str, phase, false, context, buffer))
    ).then(() => (buffer as [string])[0])
  )

  if (preserveCallbacks) {
    return raw(await resStr, callbacks)
  } else {
    return resStr
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/http-status.ts
````typescript
/**
 * @module
 * HTTP Status utility.
 */

export type InfoStatusCode = 100 | 101 | 102 | 103
export type SuccessStatusCode = 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 226
export type DeprecatedStatusCode = 305 | 306
export type RedirectStatusCode = 300 | 301 | 302 | 303 | 304 | DeprecatedStatusCode | 307 | 308
export type ClientErrorStatusCode =
  | 400
  | 401
  | 402
  | 403
  | 404
  | 405
  | 406
  | 407
  | 408
  | 409
  | 410
  | 411
  | 412
  | 413
  | 414
  | 415
  | 416
  | 417
  | 418
  | 421
  | 422
  | 423
  | 424
  | 425
  | 426
  | 428
  | 429
  | 431
  | 451
export type ServerErrorStatusCode = 500 | 501 | 502 | 503 | 504 | 505 | 506 | 507 | 508 | 510 | 511

/**
 * `UnofficialStatusCode` can be used to specify an unofficial status code.
 * @example
 *
 * ```ts
 * app.get('/unknown', (c) => {
 *   return c.text("Unknown Error", 520 as UnofficialStatusCode)
 * })
 * ```
 */
export type UnofficialStatusCode = -1

/**
 * @deprecated
 * Use `UnofficialStatusCode` instead.
 */
export type UnOfficalStatusCode = UnofficialStatusCode

/**
 * If you want to use an unofficial status, use `UnofficialStatusCode`.
 */
export type StatusCode =
  | InfoStatusCode
  | SuccessStatusCode
  | RedirectStatusCode
  | ClientErrorStatusCode
  | ServerErrorStatusCode
  | UnofficialStatusCode

export type ContentlessStatusCode = 101 | 204 | 205 | 304
export type ContentfulStatusCode = Exclude<StatusCode, ContentlessStatusCode>

````
/Users/josh/Documents/GitHub/honojs/hono/src/utils/ipaddr.test.ts
```typescript
import {
  convertIPv4BinaryToString,
  convertIPv4ToBinary,
  convertIPv6BinaryToString,
  convertIPv6ToBinary,
  distinctRemoteAddr,
  expandIPv6,
} from './ipaddr'

describe('expandIPv6', () => {
  it('Should result be valid', () => {
    expect(expandIPv6('1::1')).toBe('0001:0000:0000:0000:0000:0000:0000:0001')
    expect(expandIPv6('::1')).toBe('0000:0000:0000:0000:0000:0000:0000:0001')
    expect(expandIPv6('2001:2::')).toBe('2001:0002:0000:0000:0000:0000:0000:0000')
    expect(expandIPv6('2001:2::')).toBe('2001:0002:0000:0000:0000:0000:0000:0000')
    expect(expandIPv6('2001:0:0:db8::1')).toBe('2001:0000:0000:0db8:0000:0000:0000:0001')
    expect(expandIPv6('::ffff:127.0.0.1')).toBe('0000:0000:0000:0000:0000:ffff:7f00:0001')
  })
})
describe('distinctRemoteAddr', () => {
  it('Should result be valid', () => {
    expect(distinctRemoteAddr('1::1')).toBe('IPv6')
    expect(distinctRemoteAddr('::1')).toBe('IPv6')
    expect(distinctRemoteAddr('::ffff:127.0.0.1')).toBe('IPv6')

    expect(distinctRemoteAddr('192.168.2.0')).toBe('IPv4')
    expect(distinctRemoteAddr('192.168.2.0')).toBe('IPv4')

    expect(distinctRemoteAddr('example.com')).toBeUndefined()
  })
})

describe('convertIPv4ToBinary', () => {
  it('Should result is valid', () => {
    expect(convertIPv4ToBinary('0.0.0.0')).toBe(0n)
    expect(convertIPv4ToBinary('0.0.0.1')).toBe(1n)

    expect(convertIPv4ToBinary('0.0.1.0')).toBe(1n << 8n)
  })
})

describe('convertIPv4ToString', () => {
  // add tons of test cases here
  test.each`
    input        | expected
    ${'0.0.0.0'} | ${'0.0.0.0'}
    ${'0.0.0.1'} | ${'0.0.0.1'}
    ${'0.0.1.0'} | ${'0.0.1.0'}
  `('convertIPv4ToString($input) === $expected', ({ input, expected }) => {
    expect(convertIPv4BinaryToString(convertIPv4ToBinary(input))).toBe(expected)
  })
})

describe('convertIPv6ToBinary', () => {
  it('Should result is valid', () => {
    expect(convertIPv6ToBinary('::0')).toBe(0n)
    expect(convertIPv6ToBinary('::1')).toBe(1n)

    expect(convertIPv6ToBinary('::f')).toBe(15n)
    expect(convertIPv6ToBinary('1234:::5678')).toBe(24196103360772296748952112894165669496n)
    expect(convertIPv6ToBinary('::ffff:127.0.0.1')).toBe(281472812449793n)
  })
})

describe('convertIPv6ToString', () => {
  // add tons of test cases here
  test.each`
    input                                        | expected
    ${'::1'}                                     | ${'::1'}
    ${'1::'}                                     | ${'1::'}
    ${'1234:::5678'}                             | ${'1234::5678'}
    ${'2001:2::'}                                | ${'2001:2::'}
    ${'2001::db8:0:0:0:0:1'}                     | ${'2001:0:db8::1'}
    ${'1234:5678:9abc:def0:1234:5678:9abc:def0'} | ${'1234:5678:9abc:def0:1234:5678:9abc:def0'}
    ${'::ffff:127.0.0.1'}                        | ${'::ffff:127.0.0.1'}
  `('convertIPv6ToString($input) === $expected', ({ input, expected }) => {
    expect(convertIPv6BinaryToString(convertIPv6ToBinary(input))).toBe(expected)
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/ipaddr.ts
```typescript
/**
 * Utils for IP Addresses
 * @module
 */

import type { AddressType } from '../helper/conninfo'

/**
 * Expand IPv6 Address
 * @param ipV6 Shorten IPv6 Address
 * @return expanded IPv6 Address
 */
export const expandIPv6 = (ipV6: string): string => {
  const sections = ipV6.split(':')
  if (IPV4_REGEX.test(sections.at(-1) as string)) {
    sections.splice(
      -1,
      1,
      ...convertIPv6BinaryToString(convertIPv4ToBinary(sections.at(-1) as string)) // => ::7f00:0001
        .substring(2) // => 7f00:0001
        .split(':') // => ['7f00', '0001']
    )
  }
  for (let i = 0; i < sections.length; i++) {
    const node = sections[i]
    if (node !== '') {
      sections[i] = node.padStart(4, '0')
    } else {
      sections[i + 1] === '' && sections.splice(i + 1, 1)
      sections[i] = new Array(8 - sections.length + 1).fill('0000').join(':')
    }
  }
  return sections.join(':')
}

const IPV4_REGEX = /^[0-9]{0,3}\.[0-9]{0,3}\.[0-9]{0,3}\.[0-9]{0,3}$/

/**
 * Distinct Remote Addr
 * @param remoteAddr Remote Addr
 */
export const distinctRemoteAddr = (remoteAddr: string): AddressType => {
  if (IPV4_REGEX.test(remoteAddr)) {
    return 'IPv4'
  }
  if (remoteAddr.includes(':')) {
    // Domain can't include `:`
    return 'IPv6'
  }
}

/**
 * Convert IPv4 to Uint8Array
 * @param ipv4 IPv4 Address
 * @returns BigInt
 */
export const convertIPv4ToBinary = (ipv4: string): bigint => {
  const parts = ipv4.split('.')
  let result = 0n
  for (let i = 0; i < 4; i++) {
    result <<= 8n
    result += BigInt(parts[i])
  }
  return result
}

/**
 * Convert IPv6 to Uint8Array
 * @param ipv6 IPv6 Address
 * @returns BigInt
 */
export const convertIPv6ToBinary = (ipv6: string): bigint => {
  const sections = expandIPv6(ipv6).split(':')
  let result = 0n
  for (let i = 0; i < 8; i++) {
    result <<= 16n
    result += BigInt(parseInt(sections[i], 16))
  }
  return result
}

/**
 * Convert a binary representation of an IPv4 address to a string.
 * @param ipV4 binary IPv4 Address
 * @return IPv4 Address in string
 */
export const convertIPv4BinaryToString = (ipV4: bigint): string => {
  const sections = []
  for (let i = 0; i < 4; i++) {
    sections.push((ipV4 >> BigInt(8 * (3 - i))) & 0xffn)
  }
  return sections.join('.')
}

/**
 * Convert a binary representation of an IPv6 address to a string.
 * @param ipV6 binary IPv6 Address
 * @return normalized IPv6 Address in string
 */
export const convertIPv6BinaryToString = (ipV6: bigint): string => {
  // IPv6-mapped IPv4 address
  if (ipV6 >> 32n === 0xffffn) {
    return `::ffff:${convertIPv4BinaryToString(ipV6 & 0xffffffffn)}`
  }

  const sections = []
  for (let i = 0; i < 8; i++) {
    sections.push(((ipV6 >> BigInt(16 * (7 - i))) & 0xffffn).toString(16))
  }

  let currentZeroStart = -1
  let maxZeroStart = -1
  let maxZeroEnd = -1
  for (let i = 0; i < 8; i++) {
    if (sections[i] === '0') {
      if (currentZeroStart === -1) {
        currentZeroStart = i
      }
    } else {
      if (currentZeroStart > -1) {
        if (i - currentZeroStart > maxZeroEnd - maxZeroStart) {
          maxZeroStart = currentZeroStart
          maxZeroEnd = i
        }
        currentZeroStart = -1
      }
    }
  }
  if (currentZeroStart > -1) {
    if (8 - currentZeroStart > maxZeroEnd - maxZeroStart) {
      maxZeroStart = currentZeroStart
      maxZeroEnd = 8
    }
  }
  if (maxZeroStart !== -1) {
    sections.splice(maxZeroStart, maxZeroEnd - maxZeroStart, ':')
  }

  return sections.join(':').replace(/:{2,}/g, '::')
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/mime.test.ts
```typescript
import { getExtension, getMimeType } from './mime'

const mime = {
  m3u8: 'application/vnd.apple.mpegurl',
  ts: 'video/mp2t',
}

describe('mime', () => {
  it('getMimeType', () => {
    expect(getMimeType('hello.txt')).toBe('text/plain; charset=utf-8')
    expect(getMimeType('hello.html')).toBe('text/html; charset=utf-8')
    expect(getMimeType('hello.json')).toBe('application/json')
    expect(getMimeType('favicon.ico')).toBe('image/x-icon')
    expect(getMimeType('good.morning.hello.gif')).toBe('image/gif')
    expect(getMimeType('goodmorninghellogif')).toBeUndefined()
    expect(getMimeType('indexjs.abcd')).toBeUndefined()
  })

  it('getMimeType with custom mime', () => {
    expect(getMimeType('morning-routine.m3u8', mime)).toBe('application/vnd.apple.mpegurl')
    expect(getMimeType('morning-routine1.ts', mime)).toBe('video/mp2t')
    expect(getMimeType('readme.txt', mime)).toBeUndefined()
  })

  it('getExtension', () => {
    expect(getExtension('audio/aac')).toBe('aac')
    expect(getExtension('video/x-msvideo')).toBe('avi')
    expect(getExtension('image/avif')).toBe('avif')
    expect(getExtension('text/css')).toBe('css')
    expect(getExtension('text/html')).toBe('htm')
    expect(getExtension('image/jpeg')).toBe('jpeg')
    expect(getExtension('text/javascript')).toBe('js')
    expect(getExtension('application/json')).toBe('json')
    expect(getExtension('audio/mpeg')).toBe('mp3')
    expect(getExtension('video/mp4')).toBe('mp4')
    expect(getExtension('application/pdf')).toBe('pdf')
    expect(getExtension('image/png')).toBe('png')
    expect(getExtension('application/zip')).toBe('zip')
    expect(getExtension('non/existent')).toBeUndefined()
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/mime.ts
```typescript
/**
 * @module
 * MIME utility.
 */

export const getMimeType = (
  filename: string,
  mimes: Record<string, string> = baseMimes
): string | undefined => {
  const regexp = /\.([a-zA-Z0-9]+?)$/
  const match = filename.match(regexp)
  if (!match) {
    return
  }
  let mimeType = mimes[match[1]]
  if (mimeType && mimeType.startsWith('text')) {
    mimeType += '; charset=utf-8'
  }
  return mimeType
}

export const getExtension = (mimeType: string): string | undefined => {
  for (const ext in baseMimes) {
    if (baseMimes[ext] === mimeType) {
      return ext
    }
  }
}

export { baseMimes as mimes }

/**
 * Union types for BaseMime
 */
export type BaseMime = (typeof _baseMimes)[keyof typeof _baseMimes]

const _baseMimes = {
  aac: 'audio/aac',
  avi: 'video/x-msvideo',
  avif: 'image/avif',
  av1: 'video/av1',
  bin: 'application/octet-stream',
  bmp: 'image/bmp',
  css: 'text/css',
  csv: 'text/csv',
  eot: 'application/vnd.ms-fontobject',
  epub: 'application/epub+zip',
  gif: 'image/gif',
  gz: 'application/gzip',
  htm: 'text/html',
  html: 'text/html',
  ico: 'image/x-icon',
  ics: 'text/calendar',
  jpeg: 'image/jpeg',
  jpg: 'image/jpeg',
  js: 'text/javascript',
  json: 'application/json',
  jsonld: 'application/ld+json',
  map: 'application/json',
  mid: 'audio/x-midi',
  midi: 'audio/x-midi',
  mjs: 'text/javascript',
  mp3: 'audio/mpeg',
  mp4: 'video/mp4',
  mpeg: 'video/mpeg',
  oga: 'audio/ogg',
  ogv: 'video/ogg',
  ogx: 'application/ogg',
  opus: 'audio/opus',
  otf: 'font/otf',
  pdf: 'application/pdf',
  png: 'image/png',
  rtf: 'application/rtf',
  svg: 'image/svg+xml',
  tif: 'image/tiff',
  tiff: 'image/tiff',
  ts: 'video/mp2t',
  ttf: 'font/ttf',
  txt: 'text/plain',
  wasm: 'application/wasm',
  webm: 'video/webm',
  weba: 'audio/webm',
  webp: 'image/webp',
  woff: 'font/woff',
  woff2: 'font/woff2',
  xhtml: 'application/xhtml+xml',
  xml: 'application/xml',
  zip: 'application/zip',
  '3gp': 'video/3gpp',
  '3g2': 'video/3gpp2',
  gltf: 'model/gltf+json',
  glb: 'model/gltf-binary',
} as const

const baseMimes: Record<string, BaseMime> = _baseMimes

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/stream.test.ts
```typescript
import { StreamingApi } from './stream'

describe('StreamingApi', () => {
  it('write(string)', async () => {
    const { readable, writable } = new TransformStream()
    const api = new StreamingApi(writable, readable)
    const reader = api.responseReadable.getReader()
    api.write('foo')
    expect((await reader.read()).value).toEqual(new TextEncoder().encode('foo'))
    api.write('bar')
    expect((await reader.read()).value).toEqual(new TextEncoder().encode('bar'))
  })

  it('write(Uint8Array)', async () => {
    const { readable, writable } = new TransformStream()
    const api = new StreamingApi(writable, readable)
    const reader = api.responseReadable.getReader()
    api.write(new Uint8Array([1, 2, 3]))
    expect((await reader.read()).value).toEqual(new Uint8Array([1, 2, 3]))
    api.write(new Uint8Array([4, 5, 6]))
    expect((await reader.read()).value).toEqual(new Uint8Array([4, 5, 6]))
  })

  it('writeln(string)', async () => {
    const { readable, writable } = new TransformStream()
    const api = new StreamingApi(writable, readable)
    const reader = api.responseReadable.getReader()
    api.writeln('foo')
    expect((await reader.read()).value).toEqual(new TextEncoder().encode('foo\n'))
    api.writeln('bar')
    expect((await reader.read()).value).toEqual(new TextEncoder().encode('bar\n'))
  })

  it('pipe()', async () => {
    const { readable: senderReadable, writable: senderWritable } = new TransformStream()

    // send data to readable in other scope
    ;(async () => {
      const writer = senderWritable.getWriter()
      await writer.write(new TextEncoder().encode('foo'))
      await writer.write(new TextEncoder().encode('bar'))
      // await writer.close()
    })()

    const { readable: receiverReadable, writable: receiverWritable } = new TransformStream()

    const api = new StreamingApi(receiverWritable, receiverReadable)

    // pipe readable to api in other scope
    ;(async () => {
      await api.pipe(senderReadable)
    })()

    // read data from api
    const reader = api.responseReadable.getReader()
    expect((await reader.read()).value).toEqual(new TextEncoder().encode('foo'))
    expect((await reader.read()).value).toEqual(new TextEncoder().encode('bar'))
  })

  it('close()', async () => {
    const { readable, writable } = new TransformStream()
    const api = new StreamingApi(writable, readable)
    const reader = api.responseReadable.getReader()
    await api.close()
    expect((await reader.read()).done).toBe(true)
  })

  it('should not throw an error in write()', async () => {
    const { readable, writable } = new TransformStream()
    const api = new StreamingApi(writable, readable)
    await api.close()
    const write = () => api.write('foo')
    expect(write).not.toThrow()
  })

  it('should not throw an error in close()', async () => {
    const { readable, writable } = new TransformStream()
    const api = new StreamingApi(writable, readable)
    const close = async () => {
      await api.close()
      await api.close()
    }
    expect(close).not.toThrow()
  })

  it('onAbort()', async () => {
    const { readable, writable } = new TransformStream()
    const handleAbort1 = vi.fn()
    const handleAbort2 = vi.fn()
    const api = new StreamingApi(writable, readable)
    api.onAbort(handleAbort1)
    api.onAbort(handleAbort2)
    expect(handleAbort1).not.toBeCalled()
    expect(handleAbort2).not.toBeCalled()
    await api.responseReadable.cancel()
    expect(handleAbort1).toBeCalled()
    expect(handleAbort2).toBeCalled()
  })

  it('abort()', async () => {
    const { readable, writable } = new TransformStream()
    const handleAbort1 = vi.fn()
    const handleAbort2 = vi.fn()
    const api = new StreamingApi(writable, readable)
    api.onAbort(handleAbort1)
    api.onAbort(handleAbort2)
    expect(handleAbort1).not.toBeCalled()
    expect(handleAbort2).not.toBeCalled()
    expect(api.aborted).toBe(false)

    api.abort()
    expect(handleAbort1).toHaveBeenCalledOnce()
    expect(handleAbort2).toHaveBeenCalledOnce()
    expect(api.aborted).toBe(true)

    api.abort()
    expect(handleAbort1).toHaveBeenCalledOnce()
    expect(handleAbort2).toHaveBeenCalledOnce()
    expect(api.aborted).toBe(true)
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/stream.ts
```typescript
/**
 * @module
 * Stream utility.
 */

export class StreamingApi {
  private writer: WritableStreamDefaultWriter<Uint8Array>
  private encoder: TextEncoder
  private writable: WritableStream
  private abortSubscribers: (() => void | Promise<void>)[] = []
  responseReadable: ReadableStream
  /**
   * Whether the stream has been aborted.
   */
  aborted: boolean = false
  /**
   * Whether the stream has been closed normally.
   */
  closed: boolean = false

  constructor(writable: WritableStream, _readable: ReadableStream) {
    this.writable = writable
    this.writer = writable.getWriter()
    this.encoder = new TextEncoder()

    const reader = _readable.getReader()

    // in case the user disconnects, let the reader know to cancel
    // this in-turn results in responseReadable being closed
    // and writeSSE method no longer blocks indefinitely
    this.abortSubscribers.push(async () => {
      await reader.cancel()
    })

    this.responseReadable = new ReadableStream({
      async pull(controller) {
        const { done, value } = await reader.read()
        done ? controller.close() : controller.enqueue(value)
      },
      cancel: () => {
        this.abort()
      },
    })
  }

  async write(input: Uint8Array | string): Promise<StreamingApi> {
    try {
      if (typeof input === 'string') {
        input = this.encoder.encode(input)
      }
      await this.writer.write(input)
    } catch {
      // Do nothing. If you want to handle errors, create a stream by yourself.
    }
    return this
  }

  async writeln(input: string): Promise<StreamingApi> {
    await this.write(input + '\n')
    return this
  }

  sleep(ms: number): Promise<unknown> {
    return new Promise((res) => setTimeout(res, ms))
  }

  async close() {
    try {
      await this.writer.close()
    } catch {
      // Do nothing. If you want to handle errors, create a stream by yourself.
    }
    this.closed = true
  }

  async pipe(body: ReadableStream) {
    this.writer.releaseLock()
    await body.pipeTo(this.writable, { preventClose: true })
    this.writer = this.writable.getWriter()
  }

  onAbort(listener: () => void | Promise<void>) {
    this.abortSubscribers.push(listener)
  }

  /**
   * Abort the stream.
   * You can call this method when stream is aborted by external event.
   */
  abort() {
    if (!this.aborted) {
      this.aborted = true
      this.abortSubscribers.forEach((subscriber) => subscriber())
    }
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/types.test.ts
```typescript
import type { Equal, Expect, JSONParsed } from './types'

describe('JSONParsed', () => {
  enum SampleEnum {
    Value1 = 'value1',
    Value2 = 'value2',
  }

  interface Meta {
    metadata: {
      href: string
      sampleEnum: SampleEnum
    }
  }

  interface SampleInterface {
    someMeta: Meta
  }

  type SampleType = {
    someMeta: Meta
  }

  describe('primitives', () => {
    it('should convert number type to number', () => {
      type Actual = JSONParsed<number>
      type Expected = number
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
    it('should convert string type to string', () => {
      type Actual = JSONParsed<string>
      type Expected = string
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
    it('should convert boolean type to boolean', () => {
      type Actual = JSONParsed<boolean>
      type Expected = boolean
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
    it('should convert null type to null', () => {
      type Actual = JSONParsed<null>
      type Expected = null
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
  })

  describe('toJSON', () => {
    it('should convert { toJSON() => T } to T', () => {
      type Actual = JSONParsed<{ toJSON(): number }>
      type Expected = number
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
    it('toJSON is not called recursively', () => {
      type Actual = JSONParsed<{ toJSON(): { toJSON(): number } }>
      type Expected = {}
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
    it('should convert { a: { toJSON() => T } } to { a: T }', () => {
      type Actual = JSONParsed<{ a: { toJSON(): number } }>
      type Expected = { a: number }
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
  })

  describe('invalid types', () => {
    it('should convert undefined type to never', () => {
      type Actual = JSONParsed<undefined>
      type Expected = never
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
    it('should convert symbol type to never', () => {
      type Actual = JSONParsed<symbol>
      type Expected = never
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
    it('should convert function type to never', () => {
      type Actual = JSONParsed<() => void>
      type Expected = never
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
  })

  describe('array', () => {
    it('should convert undefined[] type to null[]', () => {
      type Actual = JSONParsed<undefined[]>
      type Expected = null[]
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
    it('should convert Function[] type to null[]', () => {
      type Actual = JSONParsed<(() => void)[]>
      type Expected = null[]
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
    it('should convert symbol[] type to null[]', () => {
      type Actual = JSONParsed<symbol[]>
      type Expected = null[]
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
    it('should convert (T | undefined)[] type to JSONParsedT | null>[]', () => {
      type Actual = JSONParsed<(number | undefined)[]>
      type Expected = (number | null)[]
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
    it('should convert { key: readonly T[]} correctly', () => {
      type Actual = JSONParsed<{ key: readonly number[] }>
      type Expected = { key: readonly number[] }
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
  })

  describe('tuple', () => {
    it('should convert [T, S] type to [T, S]', () => {
      type Actual = JSONParsed<[number, string]>
      type Expected = [number, string]
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
    it('should convert [T, undefined] type to [T, null]', () => {
      type Actual = JSONParsed<[number, undefined]>
      type Expected = [number, null]
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
  })

  describe('object', () => {
    it('should omit keys with undefined value', () => {
      type Actual = JSONParsed<{ a: number; b: undefined }>
      type Expected = { a: number }
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
    it('should omit keys with symbol value', () => {
      type Actual = JSONParsed<{ a: number; b: symbol }>
      type Expected = { a: number }
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
    it('should omit keys with function value', () => {
      type Actual = JSONParsed<{ a: number; b: () => void }>
      type Expected = { a: number }
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
    it('should omit symbol keys', () => {
      type Actual = JSONParsed<{ a: number; [x: symbol]: number }>
      type Expected = { a: number }
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
    it('should convert T | undefined to T | undefined', () => {
      type Actual = JSONParsed<{ a: number; b: number | undefined }>
      type Expected = { a: number; b: number | undefined }
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
    it('should omit keys with invalid union', () => {
      type Actual = JSONParsed<{ a: number; b: undefined | symbol }>
      type Expected = { a: number }
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
  })

  describe('Set/Map', () => {
    it('should convert Set to empty object', () => {
      type Actual = JSONParsed<Set<number>>
      type Expected = {}
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
    it('should convert Map to empty object', () => {
      type Actual = JSONParsed<Map<number, number>>
      type Expected = {}
      expectTypeOf<Actual>().toEqualTypeOf<Expected>()
    })
  })

  it('Should parse a complex type', () => {
    const sample: JSONParsed<SampleType> = {
      someMeta: {
        metadata: {
          href: '',
          sampleEnum: SampleEnum.Value1,
        },
      },
    }
    expectTypeOf(sample).toEqualTypeOf<SampleType>()
  })

  it('Should parse a complex interface', () => {
    const sample: JSONParsed<SampleInterface> = {
      someMeta: {
        metadata: {
          href: '',
          sampleEnum: SampleEnum.Value1,
        },
      },
    }
    expectTypeOf(sample).toEqualTypeOf<SampleInterface>()
  })

  it('Should convert Date to string', () => {
    type Post = {
      datetime: Date
    }
    type Expected = {
      datetime: string
    }
    type Actual = JSONParsed<Post>
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    type verify = Expect<Equal<Expected, Actual>>
  })

  it('Should convert bigint to never', () => {
    type Post = {
      num: bigint
    }
    type Expected = {
      num: never
    }
    type Actual = JSONParsed<Post>
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    type verify = Expect<Equal<Expected, Actual>>
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/types.ts
```typescript
/**
 * @module
 * Types utility.
 */

/* eslint-disable @typescript-eslint/no-explicit-any */
export type Expect<T extends true> = T
export type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
  ? true
  : false
export type NotEqual<X, Y> = true extends Equal<X, Y> ? false : true

export type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I
) => void
  ? I
  : never

export type RemoveBlankRecord<T> = T extends Record<infer K, unknown>
  ? K extends string
    ? T
    : never
  : never

export type IfAnyThenEmptyObject<T> = 0 extends 1 & T ? {} : T

export type JSONPrimitive = string | boolean | number | null
export type JSONArray = (JSONPrimitive | JSONObject | JSONArray)[]
export type JSONObject = {
  [key: string]: JSONPrimitive | JSONArray | JSONObject | object | InvalidJSONValue
}
export type InvalidJSONValue = undefined | symbol | ((...args: unknown[]) => unknown)

type InvalidToNull<T> = T extends InvalidJSONValue ? null : T

type IsInvalid<T> = T extends InvalidJSONValue ? true : false

/**
 * symbol keys are omitted through `JSON.stringify`
 */
type OmitSymbolKeys<T> = { [K in keyof T as K extends symbol ? never : K]: T[K] }

export type JSONValue = JSONObject | JSONArray | JSONPrimitive
// Non-JSON values such as `Date` implement `.toJSON()`, so they can be transformed to a value assignable to `JSONObject`:
export type JSONParsed<T> = T extends { toJSON(): infer J }
  ? (() => J) extends () => JSONPrimitive
    ? J
    : (() => J) extends () => { toJSON(): unknown }
    ? {}
    : JSONParsed<J>
  : T extends JSONPrimitive
  ? T
  : T extends InvalidJSONValue
  ? never
  : T extends ReadonlyArray<unknown>
  ? { [K in keyof T]: JSONParsed<InvalidToNull<T[K]>> }
  : T extends Set<unknown> | Map<unknown, unknown>
  ? {}
  : T extends object
  ? {
      [K in keyof OmitSymbolKeys<T> as IsInvalid<T[K]> extends true
        ? never
        : K]: boolean extends IsInvalid<T[K]> ? JSONParsed<T[K]> | undefined : JSONParsed<T[K]>
    }
  : never

/**
 * Useful to flatten the type output to improve type hints shown in editors. And also to transform an interface into a type to aide with assignability.
 * @copyright from sindresorhus/type-fest
 */
export type Simplify<T> = { [KeyType in keyof T]: T[KeyType] } & {}

/**
 * A simple extension of Simplify that will deeply traverse array elements.
 */
export type SimplifyDeepArray<T> = T extends any[]
  ? { [E in keyof T]: SimplifyDeepArray<T[E]> }
  : Simplify<T>

export type InterfaceToType<T> = T extends Function ? T : { [K in keyof T]: InterfaceToType<T[K]> }

export type RequiredKeysOf<BaseType extends object> = Exclude<
  {
    [Key in keyof BaseType]: BaseType extends Record<Key, BaseType[Key]> ? Key : never
  }[keyof BaseType],
  undefined
>

export type HasRequiredKeys<BaseType extends object> = RequiredKeysOf<BaseType> extends never
  ? false
  : true

export type IsAny<T> = boolean extends (T extends never ? true : false) ? true : false

/**
 * String literal types with auto-completion
 * @see https://github.com/Microsoft/TypeScript/issues/29729
 */
export type StringLiteralUnion<T> = T | (string & Record<never, never>)

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/url.test.ts
```typescript
import {
  checkOptionalParameter,
  getPath,
  getPathNoStrict,
  getPattern,
  getQueryParam,
  getQueryParams,
  getQueryStrings,
  mergePath,
  splitPath,
  splitRoutingPath,
} from './url'

describe('url', () => {
  it('splitPath', () => {
    let ps = splitPath('/')
    expect(ps).toStrictEqual([''])

    ps = splitPath('/hello')
    expect(ps).toStrictEqual(['hello'])
  })

  it('splitRoutingPath', () => {
    let ps = splitRoutingPath('/')
    expect(ps).toStrictEqual([''])

    ps = splitRoutingPath('/hello')
    expect(ps).toStrictEqual(['hello'])

    ps = splitRoutingPath('*')
    expect(ps).toStrictEqual(['*'])

    ps = splitRoutingPath('/wildcard-abc/*/wildcard-efg')
    expect(ps).toStrictEqual(['wildcard-abc', '*', 'wildcard-efg'])

    ps = splitRoutingPath('/map/:location/events')
    expect(ps).toStrictEqual(['map', ':location', 'events'])

    ps = splitRoutingPath('/js/:location{[a-z/]+.js}')
    expect(ps).toStrictEqual(['js', ':location{[a-z/]+.js}'])

    ps = splitRoutingPath('/users/:name{[0-9a-zA-Z_-]{3,10}}')
    expect(ps).toStrictEqual(['users', ':name{[0-9a-zA-Z_-]{3,10}}'])

    ps = splitRoutingPath('/users/:@name{[0-9a-zA-Z_-]{3,10}}')
    expect(ps).toStrictEqual(['users', ':@name{[0-9a-zA-Z_-]{3,10}}'])

    ps = splitRoutingPath('/users/:dept{\\d+}/:@name{[0-9a-zA-Z_-]{3,10}}')
    expect(ps).toStrictEqual(['users', ':dept{\\d+}', ':@name{[0-9a-zA-Z_-]{3,10}}'])
  })

  describe('getPattern', () => {
    it('no pattern', () => {
      const res = getPattern('id')
      expect(res).toBeNull()
    })

    it('no pattern with next', () => {
      const res = getPattern('id', 'next')
      expect(res).toBeNull()
    })

    it('default pattern', () => {
      const res = getPattern(':id')
      expect(res).toEqual([':id', 'id', true])
    })

    it('default pattern with next', () => {
      const res = getPattern(':id', 'next')
      expect(res).toEqual([':id', 'id', true])
    })

    it('regex pattern', () => {
      const res = getPattern(':id{[0-9]+}')
      expect(res).toEqual([':id{[0-9]+}', 'id', /^[0-9]+$/])
    })

    it('regex pattern with next', () => {
      const res = getPattern(':id{[0-9]+}', 'next')
      expect(res).toEqual([':id{[0-9]+}#next', 'id', /^[0-9]+(?=\/next)/])
    })

    it('wildcard', () => {
      const res = getPattern('*')
      expect(res).toBe('*')
    })

    it('wildcard with next', () => {
      const res = getPattern('*', 'next')
      expect(res).toBe('*')
    })
  })

  describe('getPath', () => {
    it('getPath - no trailing slash', () => {
      let path = getPath(new Request('https://example.com/'))
      expect(path).toBe('/')
      path = getPath(new Request('https://example.com/hello'))
      expect(path).toBe('/hello')
      path = getPath(new Request('https://example.com/hello/hey'))
      expect(path).toBe('/hello/hey')
      path = getPath(new Request('https://example.com/hello?name=foo'))
      expect(path).toBe('/hello')
      path = getPath(new Request('https://example.com/hello/hey?name=foo&name=bar'))
      expect(path).toBe('/hello/hey')
    })

    it('getPath - with trailing slash', () => {
      let path = getPath(new Request('https://example.com/hello/'))
      expect(path).toBe('/hello/')
      path = getPath(new Request('https://example.com/hello/hey/'))
      expect(path).toBe('/hello/hey/')
    })
  })

  describe('getQueryStrings', () => {
    it('getQueryStrings', () => {
      let qs = getQueryStrings('https://example.com/hello?name=foo&name=bar&age=20')
      expect(qs).toBe('?name=foo&name=bar&age=20')
      qs = getQueryStrings('https://example.com/hello?')
      expect(qs).toBe('?')
      qs = getQueryStrings('https://example.com/hello')
      expect(qs).toBe('')
      // Allows to contain hash
      qs = getQueryStrings('https://example.com/hello?name=foo&name=bar&age=20#hash')
      expect(qs).toBe('?name=foo&name=bar&age=20#hash')
    })
  })

  describe('getPathNoStrict', () => {
    it('getPathNoStrict - no strict is false', () => {
      let path = getPathNoStrict(new Request('https://example.com/hello/'))
      expect(path).toBe('/hello')
      path = getPathNoStrict(new Request('https://example.com/hello/hey/'))
      expect(path).toBe('/hello/hey')
    })

    it('getPathNoStrict - return `/` even if strict is false', () => {
      const path = getPathNoStrict(new Request('https://example.com/'))
      expect(path).toBe('/')
    })
  })

  describe('mergePath', () => {
    it('mergePath', () => {
      expect(mergePath('/book', '/')).toBe('/book')
      expect(mergePath('/book/', '/')).toBe('/book/')
      expect(mergePath('/book', '/hey')).toBe('/book/hey')
      expect(mergePath('/book/', '/hey')).toBe('/book/hey')
      expect(mergePath('/book', '/hey/')).toBe('/book/hey/')
      expect(mergePath('/book/', '/hey/')).toBe('/book/hey/')
      expect(mergePath('/book', 'hey', 'say')).toBe('/book/hey/say')
      expect(mergePath('/book', '/hey/', '/say/')).toBe('/book/hey/say/')
      expect(mergePath('/book', '/hey/', '/say/', '/')).toBe('/book/hey/say/')
      expect(mergePath('/book', '/hey', '/say', '/')).toBe('/book/hey/say')
      expect(mergePath('/', '/book', '/hey', '/say', '/')).toBe('/book/hey/say')

      expect(mergePath('book', '/')).toBe('/book')
      expect(mergePath('book/', '/')).toBe('/book/')
      expect(mergePath('book', '/hey')).toBe('/book/hey')
      expect(mergePath('book', 'hey')).toBe('/book/hey')
      expect(mergePath('book', 'hey/')).toBe('/book/hey/')
    })
    it('Should be `/book`', () => {
      expect(mergePath('/', 'book')).toBe('/book')
    })
    it('Should be `/book`', () => {
      expect(mergePath('/', '/book')).toBe('/book')
    })
    it('Should be `/`', () => {
      expect(mergePath('/', '/')).toBe('/')
    })
  })

  describe('checkOptionalParameter', () => {
    it('checkOptionalParameter', () => {
      expect(checkOptionalParameter('/api/animals/:type?')).toEqual([
        '/api/animals',
        '/api/animals/:type',
      ])
      expect(checkOptionalParameter('/api/animals/type?')).toBeNull()
      expect(checkOptionalParameter('/api/animals/:type')).toBeNull()
      expect(checkOptionalParameter('/api/animals')).toBeNull()
      expect(checkOptionalParameter('/api/:animals?/type')).toBeNull()
      expect(checkOptionalParameter('/api/animals/:type?/')).toBeNull()
      expect(checkOptionalParameter('/:optional?')).toEqual(['/', '/:optional'])
      expect(checkOptionalParameter('/v1/leaderboard/:version?/:platform?')).toEqual([
        '/v1/leaderboard',
        '/v1/leaderboard/:version',
        '/v1/leaderboard/:version/:platform',
      ])
      expect(checkOptionalParameter('/api/:version/animal/:type?')).toEqual([
        '/api/:version/animal',
        '/api/:version/animal/:type',
      ])
    })
  })

  describe('getQueryParam', () => {
    it('Parse URL query strings', () => {
      expect(getQueryParam('http://example.com/?name=hey', 'name')).toBe('hey')
      expect(getQueryParam('http://example.com/?name=hey#fragment', 'name')).toBe('hey#fragment')
      expect(getQueryParam('http://example.com/?name=hey&age=20&tall=170', 'age')).toBe('20')
      expect(getQueryParam('http://example.com/?Hono+is=a+web+framework', 'Hono is')).toBe(
        'a web framework'
      )

      expect(getQueryParam('http://example.com/?name0=sam&name1=tom', 'name0')).toBe('sam')
      expect(getQueryParam('http://example.com/?name0=sam&name1=tom', 'name1')).toBe('tom')
      expect(getQueryParam('http://example.com/?name0=sam&name1=tom', 'name')).toBe(undefined)

      let searchParams = new URLSearchParams({ name: '炎' })
      expect(getQueryParam(`http://example.com/?${searchParams.toString()}`, 'name')).toBe('炎')
      searchParams = new URLSearchParams({ '炎 is': 'a web framework' })
      expect(
        getQueryParam(
          `http://example.com/?${searchParams.toString()}`,
          searchParams.keys().next().value
        )
      ).toBe('a web framework')
      expect(getQueryParam('http://example.com/?name=hey&age=20&tall=170', 'weight')).toBe(
        undefined
      )
      expect(getQueryParam('http://example.com/?name=hey&age=20&tall=170')).toEqual({
        name: 'hey',
        age: '20',
        tall: '170',
      })
      expect(getQueryParam('http://example.com/?pretty&&&&q=1%2b1=2')).toEqual({
        pretty: '',
        q: '1+1=2',
      })
      expect(getQueryParam('http://example.com/?pretty', 'pretty')).toBe('')
      expect(getQueryParam('http://example.com/?pretty', 'prtt')).toBe(undefined)
      expect(getQueryParam('http://example.com/?name=sam&name=tom', 'name')).toBe('sam')
      expect(getQueryParam('http://example.com/?name=sam&name=tom')).toEqual({
        name: 'sam',
      })
      searchParams = new URLSearchParams('?name=sam=tom')
      expect(getQueryParam('name', searchParams.get('name')?.toString()))
    })
  })

  describe('getQueryParams', () => {
    it('Parse URL query strings', () => {
      expect(getQueryParams('http://example.com/?name=hey', 'name')).toEqual(['hey'])
      expect(getQueryParams('http://example.com/?name=hey#fragment', 'name')).toEqual([
        'hey#fragment',
      ])
      expect(getQueryParams('http://example.com/?name=hey&name=foo', 'name')).toEqual([
        'hey',
        'foo',
      ])
      expect(getQueryParams('http://example.com/?name=hey&age=20&tall=170', 'age')).toEqual(['20'])
      expect(
        getQueryParams('http://example.com/?name=hey&age=20&tall=170&name=foo&age=30', 'age')
      ).toEqual(['20', '30'])
      expect(getQueryParams('http://example.com/?Hono+is=a+web+framework', 'Hono is')).toEqual([
        'a web framework',
      ])
      let searchParams = new URLSearchParams()
      searchParams.append('tag', '炎')
      searchParams.append('tag', 'ほのお')
      expect(getQueryParams(`http://example.com/?${searchParams.toString()}`, 'tag')).toEqual([
        '炎',
        'ほのお',
      ])
      searchParams = new URLSearchParams()
      searchParams.append('炎 works on', 'Cloudflare Workers')
      searchParams.append('炎 works on', 'Fastly Compute')
      expect(
        getQueryParams(
          `http://example.com/?${searchParams.toString()}`,
          searchParams.keys().next().value
        )
      ).toEqual(['Cloudflare Workers', 'Fastly Compute'])
      expect(getQueryParams('http://example.com/?name=hey&age=20&tall=170', 'weight')).toEqual(
        undefined
      )
      expect(
        getQueryParams('http://example.com/?name=hey&age=20&tall=170&name=foo&age=30&tall=180')
      ).toEqual({
        name: ['hey', 'foo'],
        age: ['20', '30'],
        tall: ['170', '180'],
      })
      expect(getQueryParams('http://example.com/?pretty&&&&q=1%2b1=2&q=2%2b2=4')).toEqual({
        pretty: [''],
        q: ['1+1=2', '2+2=4'],
      })
      expect(getQueryParams('http://example.com/?pretty', 'pretty')).toEqual([''])
      expect(getQueryParams('http://example.com/?pretty', 'prtt')).toBe(undefined)
      expect(getQueryParams('http://example.com/?toString')).toEqual({
        toString: [''],
      })
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/url.ts
```typescript
/**
 * @module
 * URL utility.
 */

export type Pattern = readonly [string, string, RegExp | true] | '*'

export const splitPath = (path: string): string[] => {
  const paths = path.split('/')
  if (paths[0] === '') {
    paths.shift()
  }
  return paths
}

export const splitRoutingPath = (routePath: string): string[] => {
  const { groups, path } = extractGroupsFromPath(routePath)

  const paths = splitPath(path)
  return replaceGroupMarks(paths, groups)
}

const extractGroupsFromPath = (path: string): { groups: [string, string][]; path: string } => {
  const groups: [string, string][] = []

  path = path.replace(/\{[^}]+\}/g, (match, index) => {
    const mark = `@${index}`
    groups.push([mark, match])
    return mark
  })

  return { groups, path }
}

const replaceGroupMarks = (paths: string[], groups: [string, string][]): string[] => {
  for (let i = groups.length - 1; i >= 0; i--) {
    const [mark] = groups[i]

    for (let j = paths.length - 1; j >= 0; j--) {
      if (paths[j].includes(mark)) {
        paths[j] = paths[j].replace(mark, groups[i][1])
        break
      }
    }
  }

  return paths
}

const patternCache: { [key: string]: Pattern } = {}
export const getPattern = (label: string, next?: string): Pattern | null => {
  // *            => wildcard
  // :id{[0-9]+}  => ([0-9]+)
  // :id          => (.+)

  if (label === '*') {
    return '*'
  }

  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/)
  if (match) {
    const cacheKey = `${label}#${next}`
    if (!patternCache[cacheKey]) {
      if (match[2]) {
        patternCache[cacheKey] =
          next && next[0] !== ':' && next[0] !== '*'
            ? [cacheKey, match[1], new RegExp(`^${match[2]}(?=/${next})`)]
            : [label, match[1], new RegExp(`^${match[2]}$`)]
      } else {
        patternCache[cacheKey] = [label, match[1], true]
      }
    }

    return patternCache[cacheKey]
  }

  return null
}

type Decoder = (str: string) => string
export const tryDecode = (str: string, decoder: Decoder): string => {
  try {
    return decoder(str)
  } catch {
    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {
      try {
        return decoder(match)
      } catch {
        return match
      }
    })
  }
}

/**
 * Try to apply decodeURI() to given string.
 * If it fails, skip invalid percent encoding or invalid UTF-8 sequences, and apply decodeURI() to the rest as much as possible.
 * @param str The string to decode.
 * @returns The decoded string that sometimes contains undecodable percent encoding.
 * @example
 * tryDecodeURI('Hello%20World') // 'Hello World'
 * tryDecodeURI('Hello%20World/%A4%A2') // 'Hello World/%A4%A2'
 */
const tryDecodeURI = (str: string) => tryDecode(str, decodeURI)

export const getPath = (request: Request): string => {
  const url = request.url
  const start = url.indexOf('/', 8)
  let i = start
  for (; i < url.length; i++) {
    const charCode = url.charCodeAt(i)
    if (charCode === 37) {
      // '%'
      // If the path contains percent encoding, use `indexOf()` to find '?' and return the result immediately.
      // Although this is a performance disadvantage, it is acceptable since we prefer cases that do not include percent encoding.
      const queryIndex = url.indexOf('?', i)
      const path = url.slice(start, queryIndex === -1 ? undefined : queryIndex)
      return tryDecodeURI(path.includes('%25') ? path.replace(/%25/g, '%2525') : path)
    } else if (charCode === 63) {
      // '?'
      break
    }
  }
  return url.slice(start, i)
}

export const getQueryStrings = (url: string): string => {
  const queryIndex = url.indexOf('?', 8)
  return queryIndex === -1 ? '' : '?' + url.slice(queryIndex + 1)
}

export const getPathNoStrict = (request: Request): string => {
  const result = getPath(request)

  // if strict routing is false => `/hello/hey/` and `/hello/hey` are treated the same
  return result.length > 1 && result.at(-1) === '/' ? result.slice(0, -1) : result
}

/**
 * Merge paths.
 * @param {string[]} ...paths - The paths to merge.
 * @returns {string} The merged path.
 * @example
 * mergePath('/api', '/users') // '/api/users'
 * mergePath('/api/', '/users') // '/api/users'
 * mergePath('/api', '/') // '/api'
 * mergePath('/api/', '/') // '/api/'
 */
export const mergePath: (...paths: string[]) => string = (
  base: string | undefined,
  sub: string | undefined,
  ...rest: string[]
): string => {
  if (rest.length) {
    sub = mergePath(sub as string, ...rest)
  }
  return `${base?.[0] === '/' ? '' : '/'}${base}${
    sub === '/' ? '' : `${base?.at(-1) === '/' ? '' : '/'}${sub?.[0] === '/' ? sub.slice(1) : sub}`
  }`
}

export const checkOptionalParameter = (path: string): string[] | null => {
  /*
   If path is `/api/animals/:type?` it will return:
   [`/api/animals`, `/api/animals/:type`]
   in other cases it will return null
  */

  if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(':')) {
    return null
  }

  const segments = path.split('/')
  const results: string[] = []
  let basePath = ''

  segments.forEach((segment) => {
    if (segment !== '' && !/\:/.test(segment)) {
      basePath += '/' + segment
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === '') {
          results.push('/')
        } else {
          results.push(basePath)
        }
        const optionalSegment = segment.replace('?', '')
        basePath += '/' + optionalSegment
        results.push(basePath)
      } else {
        basePath += '/' + segment
      }
    }
  })

  return results.filter((v, i, a) => a.indexOf(v) === i)
}

// Optimized
const _decodeURI = (value: string) => {
  if (!/[%+]/.test(value)) {
    return value
  }
  if (value.indexOf('+') !== -1) {
    value = value.replace(/\+/g, ' ')
  }
  return value.indexOf('%') !== -1 ? decodeURIComponent_(value) : value
}

const _getQueryParam = (
  url: string,
  key?: string,
  multiple?: boolean
): string | undefined | Record<string, string> | string[] | Record<string, string[]> => {
  let encoded

  if (!multiple && key && !/[%+]/.test(key)) {
    // optimized for unencoded key

    let keyIndex = url.indexOf(`?${key}`, 8)
    if (keyIndex === -1) {
      keyIndex = url.indexOf(`&${key}`, 8)
    }
    while (keyIndex !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex + key.length + 1)
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex + key.length + 2
        const endIndex = url.indexOf('&', valueIndex)
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? undefined : endIndex))
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return ''
      }
      keyIndex = url.indexOf(`&${key}`, keyIndex + 1)
    }

    encoded = /[%+]/.test(url)
    if (!encoded) {
      return undefined
    }
    // fallback to default routine
  }

  const results: Record<string, string> | Record<string, string[]> = {}
  encoded ??= /[%+]/.test(url)

  let keyIndex = url.indexOf('?', 8)
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf('&', keyIndex + 1)
    let valueIndex = url.indexOf('=', keyIndex)
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1
    }
    let name = url.slice(
      keyIndex + 1,
      valueIndex === -1 ? (nextKeyIndex === -1 ? undefined : nextKeyIndex) : valueIndex
    )
    if (encoded) {
      name = _decodeURI(name)
    }

    keyIndex = nextKeyIndex

    if (name === '') {
      continue
    }

    let value
    if (valueIndex === -1) {
      value = ''
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? undefined : nextKeyIndex)
      if (encoded) {
        value = _decodeURI(value)
      }
    }

    if (multiple) {
      if (!(results[name] && Array.isArray(results[name]))) {
        results[name] = []
      }
      ;(results[name] as string[]).push(value)
    } else {
      results[name] ??= value
    }
  }

  return key ? results[key] : results
}

export const getQueryParam: (
  url: string,
  key?: string
) => string | undefined | Record<string, string> = _getQueryParam as (
  url: string,
  key?: string
) => string | undefined | Record<string, string>

export const getQueryParams = (
  url: string,
  key?: string
): string[] | undefined | Record<string, string[]> => {
  return _getQueryParam(url, key, true) as string[] | undefined | Record<string, string[]>
}

// `decodeURIComponent` is a long name.
// By making it a function, we can use it commonly when minified, reducing the amount of code.
export const decodeURIComponent_ = decodeURIComponent

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/jwt/index.ts
```typescript
/**
 * @module
 * JWT utility.
 */

import { decode, sign, verify, verifyFromJwks } from './jwt'
export const Jwt = { sign, verify, decode, verifyFromJwks }

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/jwt/jwa.test.ts
```typescript
import { AlgorithmTypes } from './jwa'

describe('Types', () => {
  it('AlgorithmTypes', () => {
    expect('HS256' as AlgorithmTypes).toBe(AlgorithmTypes.HS256)
    expect('HS384' as AlgorithmTypes).toBe(AlgorithmTypes.HS384)
    expect('HS512' as AlgorithmTypes).toBe(AlgorithmTypes.HS512)
    expect('RS256' as AlgorithmTypes).toBe(AlgorithmTypes.RS256)
    expect('RS384' as AlgorithmTypes).toBe(AlgorithmTypes.RS384)
    expect('RS512' as AlgorithmTypes).toBe(AlgorithmTypes.RS512)

    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    expect(undefined as AlgorithmTypes).toBe(undefined)
    expect('' as AlgorithmTypes).toBe('')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/jwt/jwa.ts
```typescript
/**
 * @module
 * JSON Web Algorithms (JWA)
 * https://datatracker.ietf.org/doc/html/rfc7518
 */

export enum AlgorithmTypes {
  HS256 = 'HS256',
  HS384 = 'HS384',
  HS512 = 'HS512',
  RS256 = 'RS256',
  RS384 = 'RS384',
  RS512 = 'RS512',
  PS256 = 'PS256',
  PS384 = 'PS384',
  PS512 = 'PS512',
  ES256 = 'ES256',
  ES384 = 'ES384',
  ES512 = 'ES512',
  EdDSA = 'EdDSA',
}

export type SignatureAlgorithm = keyof typeof AlgorithmTypes

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/jwt/jws.ts
```typescript
/**
 * @module
 * JSON Web Signature (JWS)
 * https://datatracker.ietf.org/doc/html/rfc7515
 */

import { getRuntimeKey } from '../../helper/adapter'
import { decodeBase64 } from '../encode'
import type { SignatureAlgorithm } from './jwa'
import { CryptoKeyUsage, JwtAlgorithmNotImplemented } from './types'
import { utf8Encoder } from './utf8'

type KeyImporterAlgorithm = Parameters<typeof crypto.subtle.importKey>[2]
type KeyAlgorithm =
  | AlgorithmIdentifier
  | RsaHashedImportParams
  | (RsaPssParams & RsaHashedImportParams)
  | (EcdsaParams & EcKeyImportParams)
  | HmacImportParams

// Extending the JsonWebKey interface to include the "kid" property.
// https://datatracker.ietf.org/doc/html/rfc7515#section-4.1.4
export interface HonoJsonWebKey extends JsonWebKey {
  kid?: string
}

export type SignatureKey = string | HonoJsonWebKey | CryptoKey

export async function signing(
  privateKey: SignatureKey,
  alg: SignatureAlgorithm,
  data: BufferSource
): Promise<ArrayBuffer> {
  const algorithm = getKeyAlgorithm(alg)
  const cryptoKey = await importPrivateKey(privateKey, algorithm)
  return await crypto.subtle.sign(algorithm, cryptoKey, data)
}

export async function verifying(
  publicKey: SignatureKey,
  alg: SignatureAlgorithm,
  signature: BufferSource,
  data: BufferSource
): Promise<boolean> {
  const algorithm = getKeyAlgorithm(alg)
  const cryptoKey = await importPublicKey(publicKey, algorithm)
  return await crypto.subtle.verify(algorithm, cryptoKey, signature, data)
}

function pemToBinary(pem: string): Uint8Array {
  return decodeBase64(pem.replace(/-+(BEGIN|END).*/g, '').replace(/\s/g, ''))
}

async function importPrivateKey(key: SignatureKey, alg: KeyImporterAlgorithm): Promise<CryptoKey> {
  if (!crypto.subtle || !crypto.subtle.importKey) {
    throw new Error('`crypto.subtle.importKey` is undefined. JWT auth middleware requires it.')
  }
  if (isCryptoKey(key)) {
    if (key.type !== 'private' && key.type !== 'secret') {
      throw new Error(
        `unexpected key type: CryptoKey.type is ${key.type}, expected private or secret`
      )
    }
    return key
  }
  const usages = [CryptoKeyUsage.Sign]
  if (typeof key === 'object') {
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key_import
    return await crypto.subtle.importKey('jwk', key, alg, false, usages)
  }
  if (key.includes('PRIVATE')) {
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#pkcs_8_import
    return await crypto.subtle.importKey('pkcs8', pemToBinary(key), alg, false, usages)
  }
  return await crypto.subtle.importKey('raw', utf8Encoder.encode(key), alg, false, usages)
}

async function importPublicKey(key: SignatureKey, alg: KeyImporterAlgorithm): Promise<CryptoKey> {
  if (!crypto.subtle || !crypto.subtle.importKey) {
    throw new Error('`crypto.subtle.importKey` is undefined. JWT auth middleware requires it.')
  }
  if (isCryptoKey(key)) {
    if (key.type === 'public' || key.type === 'secret') {
      return key
    }
    key = await exportPublicJwkFrom(key)
  }
  if (typeof key === 'string' && key.includes('PRIVATE')) {
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#pkcs_8_import
    const privateKey = await crypto.subtle.importKey('pkcs8', pemToBinary(key), alg, true, [
      CryptoKeyUsage.Sign,
    ])
    key = await exportPublicJwkFrom(privateKey)
  }
  const usages = [CryptoKeyUsage.Verify]
  if (typeof key === 'object') {
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key_import
    return await crypto.subtle.importKey('jwk', key, alg, false, usages)
  }
  if (key.includes('PUBLIC')) {
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#subjectpublickeyinfo_import
    return await crypto.subtle.importKey('spki', pemToBinary(key), alg, false, usages)
  }
  return await crypto.subtle.importKey('raw', utf8Encoder.encode(key), alg, false, usages)
}

// https://datatracker.ietf.org/doc/html/rfc7517
async function exportPublicJwkFrom(privateKey: CryptoKey): Promise<JsonWebKey> {
  if (privateKey.type !== 'private') {
    throw new Error(`unexpected key type: ${privateKey.type}`)
  }
  if (!privateKey.extractable) {
    throw new Error('unexpected private key is unextractable')
  }
  const jwk = await crypto.subtle.exportKey('jwk', privateKey)
  const { kty } = jwk // common
  const { alg, e, n } = jwk // rsa
  const { crv, x, y } = jwk // elliptic-curve
  return { kty, alg, e, n, crv, x, y, key_ops: [CryptoKeyUsage.Verify] }
}

function getKeyAlgorithm(name: SignatureAlgorithm): KeyAlgorithm {
  switch (name) {
    case 'HS256':
      return {
        name: 'HMAC',
        hash: {
          name: 'SHA-256',
        },
      } satisfies HmacImportParams
    case 'HS384':
      return {
        name: 'HMAC',
        hash: {
          name: 'SHA-384',
        },
      } satisfies HmacImportParams
    case 'HS512':
      return {
        name: 'HMAC',
        hash: {
          name: 'SHA-512',
        },
      } satisfies HmacImportParams
    case 'RS256':
      return {
        name: 'RSASSA-PKCS1-v1_5',
        hash: {
          name: 'SHA-256',
        },
      } satisfies RsaHashedImportParams
    case 'RS384':
      return {
        name: 'RSASSA-PKCS1-v1_5',
        hash: {
          name: 'SHA-384',
        },
      } satisfies RsaHashedImportParams
    case 'RS512':
      return {
        name: 'RSASSA-PKCS1-v1_5',
        hash: {
          name: 'SHA-512',
        },
      } satisfies RsaHashedImportParams
    case 'PS256':
      return {
        name: 'RSA-PSS',
        hash: {
          name: 'SHA-256',
        },
        saltLength: 32, // 256 >> 3
      } satisfies RsaPssParams & RsaHashedImportParams
    case 'PS384':
      return {
        name: 'RSA-PSS',
        hash: {
          name: 'SHA-384',
        },
        saltLength: 48, // 384 >> 3
      } satisfies RsaPssParams & RsaHashedImportParams
    case 'PS512':
      return {
        name: 'RSA-PSS',
        hash: {
          name: 'SHA-512',
        },
        saltLength: 64, // 512 >> 3,
      } satisfies RsaPssParams & RsaHashedImportParams
    case 'ES256':
      return {
        name: 'ECDSA',
        hash: {
          name: 'SHA-256',
        },
        namedCurve: 'P-256',
      } satisfies EcdsaParams & EcKeyImportParams
    case 'ES384':
      return {
        name: 'ECDSA',
        hash: {
          name: 'SHA-384',
        },
        namedCurve: 'P-384',
      } satisfies EcdsaParams & EcKeyImportParams
    case 'ES512':
      return {
        name: 'ECDSA',
        hash: {
          name: 'SHA-512',
        },
        namedCurve: 'P-521',
      } satisfies EcdsaParams & EcKeyImportParams
    case 'EdDSA':
      // Currently, supported only Safari and Deno, Node.js.
      // See: https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/verify
      return {
        name: 'Ed25519',
        namedCurve: 'Ed25519',
      }
    default:
      throw new JwtAlgorithmNotImplemented(name)
  }
}

function isCryptoKey(key: SignatureKey): key is CryptoKey {
  const runtime = getRuntimeKey()
  // @ts-expect-error CryptoKey hasn't exported to global in node v18
  if (runtime === 'node' && !!crypto.webcrypto) {
    // @ts-expect-error CryptoKey hasn't exported to global in node v18
    return key instanceof crypto.webcrypto.CryptoKey
  }
  return key instanceof CryptoKey
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/jwt/jwt.test.ts
```typescript
/* eslint-disable @typescript-eslint/ban-ts-comment */
import { vi } from 'vitest'
import { encodeBase64 } from '../encode'
import { AlgorithmTypes } from './jwa'
import * as JWT from './jwt'
import {
  JwtAlgorithmNotImplemented,
  JwtTokenExpired,
  JwtTokenInvalid,
  JwtTokenIssuedAt,
  JwtTokenNotBefore,
  JwtTokenSignatureMismatched,
} from './types'

describe('isTokenHeader', () => {
  it('should return true for valid TokenHeader', () => {
    const validTokenHeader: JWT.TokenHeader = {
      alg: AlgorithmTypes.HS256,
      typ: 'JWT',
    }

    expect(JWT.isTokenHeader(validTokenHeader)).toBe(true)
  })

  it('should return false for invalid TokenHeader', () => {
    const invalidTokenHeader = {
      alg: 'invalid',
      typ: 'JWT',
    }

    expect(JWT.isTokenHeader(invalidTokenHeader)).toBe(false)
  })

  it('returns true even if the typ field is absent in a TokenHeader', () => {
    const validTokenHeader: JWT.TokenHeader = {
      alg: AlgorithmTypes.HS256,
    }

    expect(JWT.isTokenHeader(validTokenHeader)).toBe(true)
  })

  it('returns false when the typ field is present but empty', () => {
    const invalidTokenHeader = {
      alg: AlgorithmTypes.HS256,
      typ: '',
    }

    expect(JWT.isTokenHeader(invalidTokenHeader)).toBe(false)
  })
})

describe('JWT', () => {
  it('JwtAlgorithmNotImplemented', async () => {
    const payload = { message: 'hello world' }
    const secret = 'a-secret'
    const alg = ''
    let tok = ''
    let err: JwtAlgorithmNotImplemented
    try {
      tok = await JWT.sign(payload, secret, alg as AlgorithmTypes)
    } catch (e) {
      err = e as JwtAlgorithmNotImplemented
    }
    expect(tok).toBe('')
    // @ts-ignore
    expect(err).toEqual(new JwtAlgorithmNotImplemented(alg))
  })

  it('JwtTokenInvalid', async () => {
    const tok = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ'
    const secret = 'a-secret'
    let err: JwtTokenInvalid
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, AlgorithmTypes.HS256)
    } catch (e) {
      err = e as JwtTokenInvalid
    }
    // @ts-ignore
    expect(err).toEqual(new JwtTokenInvalid(tok))
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenNotBefore', async () => {
    const tok =
      'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE2NjQ2MDYzMzQsImV4cCI6MTY2NDYwOTkzNCwibmJmIjoiMzEwNDYwNjI2NCJ9.hpSDT_cfkxeiLWEpWVT8TDxFP3dFi27q1K7CcMcLXHc'
    const secret = 'a-secret'
    let err: JwtTokenNotBefore
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, AlgorithmTypes.HS256)
    } catch (e) {
      err = e as JwtTokenNotBefore
    }
    // @ts-ignore
    expect(err).toEqual(new JwtTokenNotBefore(tok))
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenExpired', async () => {
    const tok =
      'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE2MzMwNDYxMDAsImV4cCI6MTYzMzA0NjQwMH0.H-OI1TWAbmK8RonvcpPaQcNvOKS9sxinEOsgKwjoiVo'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, AlgorithmTypes.HS256)
    } catch (e) {
      err = e
    }
    expect(err).toEqual(new JwtTokenExpired(tok))
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenIssuedAt', async () => {
    const now = 1633046400
    vi.useFakeTimers().setSystemTime(new Date().setTime(now * 1000))

    const iat = now + 1000 // after 1s
    const payload = { role: 'api_role', iat }
    const secret = 'a-secret'
    const tok = await JWT.sign(payload, secret, AlgorithmTypes.HS256)

    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, AlgorithmTypes.HS256)
    } catch (e) {
      err = e
    }
    expect(err).toEqual(new JwtTokenIssuedAt(now, iat))
    expect(authorized).toBeUndefined()
  })

  it('HS256 sign & verify & decode', async () => {
    const payload = { message: 'hello world' }
    const secret = 'a-secret'
    const tok = await JWT.sign(payload, secret, AlgorithmTypes.HS256)
    const expected =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.B54pAqIiLbu170tGQ1rY06Twv__0qSHTA0ioQPIOvFE'
    expect(tok).toEqual(expected)

    const verifiedPayload = await JWT.verify(tok, secret, AlgorithmTypes.HS256)
    expect(verifiedPayload).not.toBeUndefined()
    expect(verifiedPayload).toEqual(payload)

    expect(JWT.decode(tok)).toEqual({
      header: {
        alg: 'HS256',
        typ: 'JWT',
      },
      payload: {
        message: 'hello world',
      },
    })
  })

  it('HS256 sign & verify', async () => {
    const payload = { message: 'hello world' }
    const secret = 'a-secret'
    const tok = await JWT.sign(payload, secret, AlgorithmTypes.HS256)
    const expected =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.B54pAqIiLbu170tGQ1rY06Twv__0qSHTA0ioQPIOvFE'
    expect(tok).toEqual(expected)

    let err = null
    let authorized
    try {
      authorized = await JWT.verify(tok, secret + 'invalid', AlgorithmTypes.HS256)
    } catch (e) {
      err = e
    }
    expect(authorized).toBeUndefined()
    expect(err instanceof JwtTokenSignatureMismatched).toBe(true)
  })

  it('HS512 sign & verify & decode', async () => {
    const payload = { message: 'hello world' }
    const secret = 'a-secret'
    const tok = await JWT.sign(payload, secret, AlgorithmTypes.HS512)
    const expected =
      'eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.RqVLgExB_GXF1-9T-k4V4HjFmiuQKTEjVSiZd-YL0WERIlywZ7PfzAuTZSJU4gg8cscGamQa030cieEWrYcywg'
    expect(tok).toEqual(expected)

    const verifiedPayload = await JWT.verify(tok, secret, AlgorithmTypes.HS512)
    expect(verifiedPayload).not.toBeUndefined()
    expect(verifiedPayload).toEqual(payload)

    expect(JWT.decode(tok)).toEqual({
      header: {
        alg: 'HS512',
        typ: 'JWT',
      },
      payload: {
        message: 'hello world',
      },
    })
  })

  it('HS512 sign & verify', async () => {
    const payload = { message: 'hello world' }
    const secret = 'a-secret'
    const tok = await JWT.sign(payload, secret, AlgorithmTypes.HS512)
    const expected =
      'eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.RqVLgExB_GXF1-9T-k4V4HjFmiuQKTEjVSiZd-YL0WERIlywZ7PfzAuTZSJU4gg8cscGamQa030cieEWrYcywg'
    expect(tok).toEqual(expected)

    let err = null
    let authorized
    try {
      authorized = await JWT.verify(tok, secret + 'invalid', AlgorithmTypes.HS256)
    } catch (e) {
      err = e
    }
    expect(authorized).toBeUndefined()
    expect(err instanceof JwtTokenSignatureMismatched).toBe(true)
  })

  it('HS384 sign & verify', async () => {
    const payload = { message: 'hello world' }
    const secret = 'a-secret%你好'
    const tok = await JWT.sign(payload, secret, AlgorithmTypes.HS384)
    const expected =
      'eyJhbGciOiJIUzM4NCIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.C1Br1183Oy6O7th4NDCOaI9WB75i3FMCuYlv1tCL9HggsU89T-SNutghwhJykD3r'
    expect(tok).toEqual(expected)

    let err = null
    let authorized
    try {
      authorized = await JWT.verify(tok, secret + 'invalid', AlgorithmTypes.HS256)
    } catch (e) {
      err = e
    }
    expect(authorized).toBeUndefined()
    expect(err instanceof JwtTokenSignatureMismatched).toBe(true)
  })

  it('sign & verify & decode with a custom secret', async () => {
    const payload = { message: 'hello world' }
    const algorithm = {
      name: 'HMAC',
      hash: {
        name: 'SHA-256',
      },
    }
    const secret = await crypto.subtle.importKey(
      'raw',
      Buffer.from('cefb73234d5fae4bf27662900732b52943e8d53e871fe0f353da95de4599c21d', 'hex'),
      algorithm,
      false,
      ['sign', 'verify']
    )
    const tok = await JWT.sign(payload, secret)
    const expected =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.qunGhchNXH_unqWXN6hB0Elhzr5SykSXVhklLti1aFI'
    expect(tok).toEqual(expected)

    const verifiedPayload = await JWT.verify(tok, secret)
    expect(verifiedPayload).not.toBeUndefined()
    expect(verifiedPayload).toEqual(payload)

    const invalidSecret = await crypto.subtle.importKey(
      'raw',
      Buffer.from('cefb73234d5fae4bf27662900732b52943e8d53e871fe0f353da95de41111111', 'hex'),
      algorithm,
      false,
      ['sign', 'verify']
    )
    let err = null
    let authorized
    try {
      authorized = await JWT.verify(tok, invalidSecret)
    } catch (e) {
      err = e
    }
    expect(authorized).toBeUndefined()
    expect(err instanceof JwtTokenSignatureMismatched).toBe(true)
  })

  const rsTestCases = [
    {
      alg: AlgorithmTypes.RS256,
      hash: 'SHA-256',
    },
    {
      alg: AlgorithmTypes.RS384,
      hash: 'SHA-384',
    },
    {
      alg: AlgorithmTypes.RS512,
      hash: 'SHA-512',
    },
  ]
  for (const tc of rsTestCases) {
    it(`${tc.alg} sign & verify`, async () => {
      const alg = tc.alg
      const payload = { message: 'hello world' }
      const keyPair = await generateRSAKey(tc.hash)
      const pemPrivateKey = await exportPEMPrivateKey(keyPair.privateKey)
      const pemPublicKey = await exportPEMPublicKey(keyPair.publicKey)
      const jwkPublicKey = await exportJWK(keyPair.publicKey)

      const tok = await JWT.sign(payload, pemPrivateKey, alg)
      expect(await JWT.verify(tok, pemPublicKey, alg)).toEqual(payload)
      expect(await JWT.verify(tok, pemPrivateKey, alg)).toEqual(payload)
      expect(await JWT.verify(tok, jwkPublicKey, alg)).toEqual(payload)

      const keyPair2 = await generateRSAKey(tc.hash)
      const unexpectedPemPublicKey = await exportPEMPublicKey(keyPair2.publicKey)

      let err = null
      let authorized
      try {
        authorized = await JWT.verify(tok, unexpectedPemPublicKey, alg)
      } catch (e) {
        err = e
      }
      expect(authorized).toBeUndefined()
      expect(err instanceof JwtTokenSignatureMismatched).toBe(true)
    })

    it(`${tc.alg} sign & verify w/ CryptoKey`, async () => {
      const alg = tc.alg
      const payload = { message: 'hello world' }
      const keyPair = await generateRSAKey(tc.hash)

      const tok = await JWT.sign(payload, keyPair.privateKey, alg)
      expect(await JWT.verify(tok, keyPair.privateKey, alg)).toEqual(payload)
      expect(await JWT.verify(tok, keyPair.publicKey, alg)).toEqual(payload)
    })
  }

  const psTestCases = [
    {
      alg: AlgorithmTypes.PS256,
      hash: 'SHA-256',
    },
    {
      alg: AlgorithmTypes.PS384,
      hash: 'SHA-384',
    },
    {
      alg: AlgorithmTypes.PS512,
      hash: 'SHA-512',
    },
  ]
  for (const tc of psTestCases) {
    it(`${tc.alg} sign & verify`, async () => {
      const alg = tc.alg
      const payload = { message: 'hello world' }
      const keyPair = await generateRSAPSSKey(tc.hash)
      const pemPrivateKey = await exportPEMPrivateKey(keyPair.privateKey)
      const pemPublicKey = await exportPEMPublicKey(keyPair.publicKey)
      const jwkPublicKey = await exportJWK(keyPair.publicKey)

      const tok = await JWT.sign(payload, pemPrivateKey, alg)
      expect(await JWT.verify(tok, pemPublicKey, alg)).toEqual(payload)
      expect(await JWT.verify(tok, pemPrivateKey, alg)).toEqual(payload)
      expect(await JWT.verify(tok, jwkPublicKey, alg)).toEqual(payload)

      const keyPair2 = await generateRSAPSSKey(tc.hash)
      const unexpectedPemPublicKey = await exportPEMPublicKey(keyPair2.publicKey)

      let err = null
      let authorized
      try {
        authorized = await JWT.verify(tok, unexpectedPemPublicKey, alg)
      } catch (e) {
        err = e
      }
      expect(authorized).toBeUndefined()
      expect(err instanceof JwtTokenSignatureMismatched).toBe(true)
    })

    it(`${tc.alg} sign & verify w/ CryptoKey`, async () => {
      const alg = tc.alg
      const payload = { message: 'hello world' }
      const keyPair = await generateRSAPSSKey(tc.hash)

      const tok = await JWT.sign(payload, keyPair.privateKey, alg)
      expect(await JWT.verify(tok, keyPair.privateKey, alg)).toEqual(payload)
      expect(await JWT.verify(tok, keyPair.publicKey, alg)).toEqual(payload)
    })
  }

  const esTestCases = [
    {
      alg: AlgorithmTypes.ES256,
      namedCurve: 'P-256',
    },
    {
      alg: AlgorithmTypes.ES384,
      namedCurve: 'P-384',
    },
    {
      alg: AlgorithmTypes.ES512,
      namedCurve: 'P-521',
    },
  ]
  for (const tc of esTestCases) {
    it(`${tc.alg} sign & verify`, async () => {
      const alg = tc.alg
      const payload = { message: 'hello world' }
      const keyPair = await generateECDSAKey(tc.namedCurve)
      const pemPrivateKey = await exportPEMPrivateKey(keyPair.privateKey)
      const pemPublicKey = await exportPEMPublicKey(keyPair.publicKey)
      const jwkPublicKey = await exportJWK(keyPair.publicKey)

      const tok = await JWT.sign(payload, pemPrivateKey, alg)
      expect(await JWT.verify(tok, pemPublicKey, alg)).toEqual(payload)
      expect(await JWT.verify(tok, pemPrivateKey, alg)).toEqual(payload)
      expect(await JWT.verify(tok, jwkPublicKey, alg)).toEqual(payload)

      const keyPair2 = await generateECDSAKey(tc.namedCurve)
      const unexpectedPemPublicKey = await exportPEMPublicKey(keyPair2.publicKey)

      let err = null
      let authorized
      try {
        authorized = await JWT.verify(tok, unexpectedPemPublicKey, alg)
      } catch (e) {
        err = e
      }
      expect(authorized).toBeUndefined()
      expect(err instanceof JwtTokenSignatureMismatched).toBe(true)
    })

    it(`${tc.alg} sign & verify w/ CryptoKey`, async () => {
      const alg = tc.alg
      const payload = { message: 'hello world' }
      const keyPair = await generateECDSAKey(tc.namedCurve)

      const tok = await JWT.sign(payload, keyPair.privateKey, alg)
      expect(await JWT.verify(tok, keyPair.privateKey, alg)).toEqual(payload)
      expect(await JWT.verify(tok, keyPair.publicKey, alg)).toEqual(payload)
    })
  }

  it('EdDSA sign & verify', async () => {
    const alg = 'EdDSA'
    const payload = { message: 'hello world' }
    const keyPair = await generateEd25519Key()
    const pemPrivateKey = await exportPEMPrivateKey(keyPair.privateKey)
    const pemPublicKey = await exportPEMPublicKey(keyPair.publicKey)
    const jwkPublicKey = await exportJWK(keyPair.publicKey)

    const tok = await JWT.sign(payload, pemPrivateKey, alg)
    expect(await JWT.verify(tok, pemPublicKey, alg)).toEqual(payload)
    expect(await JWT.verify(tok, pemPrivateKey, alg)).toEqual(payload)
    expect(await JWT.verify(tok, jwkPublicKey, alg)).toEqual(payload)

    const keyPair2 = await generateEd25519Key()
    const unexpectedPemPublicKey = await exportPEMPublicKey(keyPair2.publicKey)

    let err = null
    let authorized
    try {
      authorized = await JWT.verify(tok, unexpectedPemPublicKey, alg)
    } catch (e) {
      err = e
    }
    expect(authorized).toBeUndefined()
    expect(err instanceof JwtTokenSignatureMismatched).toBe(true)
  })

  it('EdDSA sign & verify w/ CryptoKey', async () => {
    const alg = 'EdDSA'
    const payload = { message: 'hello world' }
    const keyPair = await generateEd25519Key()

    const tok = await JWT.sign(payload, keyPair.privateKey, alg)
    expect(await JWT.verify(tok, keyPair.privateKey, alg)).toEqual(payload)
    expect(await JWT.verify(tok, keyPair.publicKey, alg)).toEqual(payload)
  })
})

async function exportPEMPrivateKey(key: CryptoKey): Promise<string> {
  const exported = await crypto.subtle.exportKey('pkcs8', key)
  const pem = `-----BEGIN PRIVATE KEY-----\n${encodeBase64(exported)}\n-----END PRIVATE KEY-----`
  return pem
}

async function exportPEMPublicKey(key: CryptoKey): Promise<string> {
  const exported = await crypto.subtle.exportKey('spki', key)
  const pem = `-----BEGIN PUBLIC KEY-----\n${encodeBase64(exported)}\n-----END PUBLIC KEY-----`
  return pem
}

async function exportJWK(key: CryptoKey): Promise<JsonWebKey> {
  return await crypto.subtle.exportKey('jwk', key)
}

async function generateRSAKey(hash: string): Promise<CryptoKeyPair> {
  return await crypto.subtle.generateKey(
    {
      hash,
      modulusLength: 2048,
      publicExponent: new Uint8Array([1, 0, 1]),
      name: 'RSASSA-PKCS1-v1_5',
    },
    true,
    ['sign', 'verify']
  )
}

async function generateRSAPSSKey(hash: string): Promise<CryptoKeyPair> {
  return await crypto.subtle.generateKey(
    {
      hash,
      modulusLength: 2048,
      publicExponent: new Uint8Array([1, 0, 1]),
      name: 'RSA-PSS',
    },
    true,
    ['sign', 'verify']
  )
}

async function generateECDSAKey(namedCurve: string): Promise<CryptoKeyPair> {
  return await crypto.subtle.generateKey(
    {
      name: 'ECDSA',
      namedCurve,
    },
    true,
    ['sign', 'verify']
  )
}

async function generateEd25519Key(): Promise<CryptoKeyPair> {
  return await crypto.subtle.generateKey(
    {
      name: 'Ed25519',
      namedCurve: 'Ed25519',
    },
    true,
    ['sign', 'verify']
  )
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/jwt/jwt.ts
```typescript
/**
 * @module
 * JSON Web Token (JWT)
 * https://datatracker.ietf.org/doc/html/rfc7519
 */

import { decodeBase64Url, encodeBase64Url } from '../../utils/encode'
import { AlgorithmTypes } from './jwa'
import type { SignatureAlgorithm } from './jwa'
import { signing, verifying } from './jws'
import type { HonoJsonWebKey, SignatureKey } from './jws'
import {
  JwtHeaderInvalid,
  JwtHeaderRequiresKid,
  JwtTokenExpired,
  JwtTokenInvalid,
  JwtTokenIssuedAt,
  JwtTokenNotBefore,
  JwtTokenSignatureMismatched,
} from './types'
import type { JWTPayload } from './types'
import { utf8Decoder, utf8Encoder } from './utf8'

const encodeJwtPart = (part: unknown): string =>
  encodeBase64Url(utf8Encoder.encode(JSON.stringify(part)).buffer).replace(/=/g, '')

const encodeSignaturePart = (buf: ArrayBufferLike): string => encodeBase64Url(buf).replace(/=/g, '')

const decodeJwtPart = (part: string): TokenHeader | JWTPayload | undefined =>
  JSON.parse(utf8Decoder.decode(decodeBase64Url(part)))

export interface TokenHeader {
  alg: SignatureAlgorithm
  typ?: 'JWT'
  kid?: string
}

export function isTokenHeader(obj: unknown): obj is TokenHeader {
  if (typeof obj === 'object' && obj !== null) {
    const objWithAlg = obj as { [key: string]: unknown }
    return (
      'alg' in objWithAlg &&
      Object.values(AlgorithmTypes).includes(objWithAlg.alg as AlgorithmTypes) &&
      (!('typ' in objWithAlg) || objWithAlg.typ === 'JWT')
    )
  }
  return false
}

export const sign = async (
  payload: JWTPayload,
  privateKey: SignatureKey,
  alg: SignatureAlgorithm = 'HS256'
): Promise<string> => {
  const encodedPayload = encodeJwtPart(payload)
  let encodedHeader
  if (typeof privateKey === 'object' && 'alg' in privateKey) {
    alg = privateKey.alg as SignatureAlgorithm
    encodedHeader = encodeJwtPart({ alg, typ: 'JWT', kid: privateKey.kid })
  } else {
    encodedHeader = encodeJwtPart({ alg, typ: 'JWT' })
  }

  const partialToken = `${encodedHeader}.${encodedPayload}`

  const signaturePart = await signing(privateKey, alg, utf8Encoder.encode(partialToken))
  const signature = encodeSignaturePart(signaturePart)

  return `${partialToken}.${signature}`
}

export const verify = async (
  token: string,
  publicKey: SignatureKey,
  alg: SignatureAlgorithm = 'HS256'
): Promise<JWTPayload> => {
  const tokenParts = token.split('.')
  if (tokenParts.length !== 3) {
    throw new JwtTokenInvalid(token)
  }

  const { header, payload } = decode(token)
  if (!isTokenHeader(header)) {
    throw new JwtHeaderInvalid(header)
  }
  const now = (Date.now() / 1000) | 0
  if (payload.nbf && payload.nbf > now) {
    throw new JwtTokenNotBefore(token)
  }
  if (payload.exp && payload.exp <= now) {
    throw new JwtTokenExpired(token)
  }
  if (payload.iat && now < payload.iat) {
    throw new JwtTokenIssuedAt(now, payload.iat)
  }

  const headerPayload = token.substring(0, token.lastIndexOf('.'))
  const verified = await verifying(
    publicKey,
    alg,
    decodeBase64Url(tokenParts[2]),
    utf8Encoder.encode(headerPayload)
  )
  if (!verified) {
    throw new JwtTokenSignatureMismatched(token)
  }

  return payload
}

export const verifyFromJwks = async (
  token: string,
  options: {
    keys?: HonoJsonWebKey[] | (() => Promise<HonoJsonWebKey[]>)
    jwks_uri?: string
  },
  init?: RequestInit
): Promise<JWTPayload> => {
  const header = decodeHeader(token)

  if (!isTokenHeader(header)) {
    throw new JwtHeaderInvalid(header)
  }
  if (!header.kid) {
    throw new JwtHeaderRequiresKid(header)
  }

  let keys = typeof options.keys === 'function' ? await options.keys() : options.keys

  if (options.jwks_uri) {
    const response = await fetch(options.jwks_uri, init)
    if (!response.ok) {
      throw new Error(`failed to fetch JWKS from ${options.jwks_uri}`)
    }
    const data = (await response.json()) as { keys?: JsonWebKey[] }
    if (!data.keys) {
      throw new Error('invalid JWKS response. "keys" field is missing')
    }
    if (!Array.isArray(data.keys)) {
      throw new Error('invalid JWKS response. "keys" field is not an array')
    }
    if (keys) {
      keys.push(...data.keys)
    } else {
      keys = data.keys
    }
  } else if (!keys) {
    throw new Error('verifyFromJwks requires options for either "keys" or "jwks_uri" or both')
  }

  const matchingKey = keys.find((key) => key.kid === header.kid)
  if (!matchingKey) {
    throw new JwtTokenInvalid(token)
  }

  return await verify(token, matchingKey, matchingKey.alg as SignatureAlgorithm)
}

export const decode = (token: string): { header: TokenHeader; payload: JWTPayload } => {
  try {
    const [h, p] = token.split('.')
    const header = decodeJwtPart(h) as TokenHeader
    const payload = decodeJwtPart(p) as JWTPayload
    return {
      header,
      payload,
    }
  } catch {
    throw new JwtTokenInvalid(token)
  }
}

export const decodeHeader = (token: string): TokenHeader => {
  try {
    const [h] = token.split('.')
    return decodeJwtPart(h) as TokenHeader
  } catch {
    throw new JwtTokenInvalid(token)
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/jwt/types.ts
```typescript
/**
 * @module
 * Type definitions for JWT utilities.
 */

export class JwtAlgorithmNotImplemented extends Error {
  constructor(alg: string) {
    super(`${alg} is not an implemented algorithm`)
    this.name = 'JwtAlgorithmNotImplemented'
  }
}

export class JwtTokenInvalid extends Error {
  constructor(token: string) {
    super(`invalid JWT token: ${token}`)
    this.name = 'JwtTokenInvalid'
  }
}

export class JwtTokenNotBefore extends Error {
  constructor(token: string) {
    super(`token (${token}) is being used before it's valid`)
    this.name = 'JwtTokenNotBefore'
  }
}

export class JwtTokenExpired extends Error {
  constructor(token: string) {
    super(`token (${token}) expired`)
    this.name = 'JwtTokenExpired'
  }
}

export class JwtTokenIssuedAt extends Error {
  constructor(currentTimestamp: number, iat: number) {
    super(`Incorrect "iat" claim must be a older than "${currentTimestamp}" (iat: "${iat}")`)
    this.name = 'JwtTokenIssuedAt'
  }
}

export class JwtHeaderInvalid extends Error {
  constructor(header: object) {
    super(`jwt header is invalid: ${JSON.stringify(header)}`)
    this.name = 'JwtHeaderInvalid'
  }
}

export class JwtHeaderRequiresKid extends Error {
  constructor(header: object) {
    super(`required "kid" in jwt header: ${JSON.stringify(header)}`)
    this.name = 'JwtHeaderRequiresKid'
  }
}

export class JwtTokenSignatureMismatched extends Error {
  constructor(token: string) {
    super(`token(${token}) signature mismatched`)
    this.name = 'JwtTokenSignatureMismatched'
  }
}

export enum CryptoKeyUsage {
  Encrypt = 'encrypt',
  Decrypt = 'decrypt',
  Sign = 'sign',
  Verify = 'verify',
  DeriveKey = 'deriveKey',
  DeriveBits = 'deriveBits',
  WrapKey = 'wrapKey',
  UnwrapKey = 'unwrapKey',
}

/**
 * JWT Payload
 */
export type JWTPayload = {
  [key: string]: unknown
  /**
   * The token is checked to ensure it has not expired.
   */
  exp?: number
  /**
   * The token is checked to ensure it is not being used before a specified time.
   */
  nbf?: number
  /**
   * The token is checked to ensure it is not issued in the future.
   */
  iat?: number
}

export type { HonoJsonWebKey } from './jws'

```
/Users/josh/Documents/GitHub/honojs/hono/src/utils/jwt/utf8.ts
```typescript
/**
 * @module
 * Functions for encoding/decoding UTF8.
 */

export const utf8Encoder: TextEncoder = new TextEncoder()
export const utf8Decoder: TextDecoder = new TextDecoder()

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/deno/conninfo.test.ts
```typescript
import { Context } from '../../context'
import { getConnInfo } from './conninfo'

describe('getConnInfo', () => {
  it('Should info is valid', () => {
    const transport = 'tcp'
    const address = Math.random().toString()
    const port = Math.floor(Math.random() * (65535 + 1))
    const c = new Context(new Request('http://localhost/'), {
      env: {
        remoteAddr: {
          transport,
          hostname: address,
          port,
        },
      },
    })
    const info = getConnInfo(c)

    expect(info.remote.port).toBe(port)
    expect(info.remote.address).toBe(address)
    expect(info.remote.addressType).toBeUndefined()
    expect(info.remote.transport).toBe(transport)
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/deno/conninfo.ts
```typescript
import type { GetConnInfo } from '../../helper/conninfo'

/**
 * Get conninfo with Deno
 * @param c Context
 * @returns ConnInfo
 */
export const getConnInfo: GetConnInfo = (c) => {
  const { remoteAddr } = c.env
  return {
    remote: {
      address: remoteAddr.hostname,
      port: remoteAddr.port,
      transport: remoteAddr.transport,
    },
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/deno/deno.d.ts
```typescript
declare namespace Deno {
  interface FileHandleLike {
    readonly readable: ReadableStream<Uint8Array>
  }

  /**
   * Open the file using the specified path.
   *
   * @param path The path to open the file.
   * @returns FileHandle object.
   */
  export function open(path: string): Promise<FileHandleLike>

  interface StatsLike {
    isDirectory: boolean
  }

  /**
   * Get stats with the specified path.
   *
   * @param path The path to get stats.
   * @returns Stats object.
   */
  export function lstatSync(path: string): StatsLike

  /**
   * Creates a new directory with the specified path.
   *
   * @param path The path to create a directory.
   * @param options Options for creating a directory.
   * @returns A promise that resolves when the directory is created.
   */
  export function mkdir(path: string, options?: { recursive?: boolean }): Promise<void>

  /**
   * Write a new file, with the specified path and data.
   *
   * @param path The path to the file to write.
   * @param data The data to write into the file.
   * @returns A promise that resolves when the file is written.
   */
  export function writeFile(path: string, data: Uint8Array): Promise<void>

  /**
   * Errors of Deno
   */
  export const errors: Record<string, Function>

  export function upgradeWebSocket(
    req: Request,
    options: UpgradeWebSocketOptions
  ): {
    response: Response
    socket: WebSocket
  }

  /**
   * Options of `upgradeWebSocket`
   */
  export interface UpgradeWebSocketOptions {
    /**
     * Sets the `.protocol` property on the client-side web socket to the
     * value provided here, which should be one of the strings specified in the
     * `protocols` parameter when requesting the web socket. This is intended
     * for clients and servers to specify sub-protocols to use to communicate to
     * each other.
     */
    protocol?: string
    /**
     * If the client does not respond to this frame with a
     * `pong` within the timeout specified, the connection is deemed
     * unhealthy and is closed. The `close` and `error` events will be emitted.
     *
     * The unit is seconds, with a default of 30.
     * Set to `0` to disable timeouts.
     */
    idleTimeout?: number
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/deno/index.ts
```typescript
/**
 * @module
 * Deno Adapter for Hono.
 */

export { serveStatic } from './serve-static'
export { toSSG, denoFileSystemModule } from './ssg'
export { upgradeWebSocket } from './websocket'
export { getConnInfo } from './conninfo'

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/deno/serve-static.ts
```typescript
import type { ServeStaticOptions } from '../../middleware/serve-static'
import { serveStatic as baseServeStatic } from '../../middleware/serve-static'
import type { Env, MiddlewareHandler } from '../../types'

const { open, lstatSync, errors } = Deno

export const serveStatic = <E extends Env = Env>(
  options: ServeStaticOptions<E>
): MiddlewareHandler => {
  return async function serveStatic(c, next) {
    const getContent = async (path: string) => {
      try {
        if (isDir(path)) {
          return null
        }

        const file = await open(path)
        return file.readable
      } catch (e) {
        if (!(e instanceof errors.NotFound)) {
          console.warn(`${e}`)
        }
        return null
      }
    }
    const pathResolve = (path: string) => {
      return path.startsWith('/') ? path : `./${path}`
    }
    const isDir = (path: string) => {
      let isDir
      try {
        const stat = lstatSync(path)
        isDir = stat.isDirectory
      } catch {}
      return isDir
    }

    return baseServeStatic({
      ...options,
      getContent,
      pathResolve,
      isDir,
    })(c, next)
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/deno/ssg.ts
```typescript
import { toSSG as baseToSSG } from '../../helper/ssg/index'
import type { FileSystemModule, ToSSGAdaptorInterface } from '../../helper/ssg/index'

/**
 * @experimental
 * `denoFileSystemModule` is an experimental feature.
 * The API might be changed.
 */
export const denoFileSystemModule: FileSystemModule = {
  writeFile: async (path, data) => {
    const uint8Data =
      typeof data === 'string' ? new TextEncoder().encode(data) : new Uint8Array(data)
    await Deno.writeFile(path, uint8Data)
  },
  mkdir: async (path, options) => {
    return Deno.mkdir(path, { recursive: options?.recursive ?? false })
  },
}

/**
 * @experimental
 * `toSSG` is an experimental feature.
 * The API might be changed.
 */
export const toSSG: ToSSGAdaptorInterface = async (app, options) => {
  return baseToSSG(app, denoFileSystemModule, options)
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/deno/websocket.test.ts
```typescript
import { Hono } from '../..'
import { Context } from '../../context'
import { upgradeWebSocket } from './websocket'

globalThis.Deno = {} as typeof Deno

describe('WebSockets', () => {
  let app: Hono
  beforeEach(() => {
    app = new Hono()
  })

  it('Should receive data is valid', async () => {
    const messagePromise = new Promise((resolve) =>
      app.get(
        '/ws',
        upgradeWebSocket(() => ({
          onMessage: (evt) => resolve(evt.data),
        }))
      )
    )
    const socket = new EventTarget() as WebSocket
    Deno.upgradeWebSocket = () => {
      return {
        response: new Response(),
        socket,
      }
    }
    await app.request('/ws', {
      headers: {
        upgrade: 'websocket',
      },
    })
    const data = Math.random().toString()
    socket.onmessage &&
      socket.onmessage(
        new MessageEvent('message', {
          data,
        })
      )
    expect(await messagePromise).toBe(data)
  })

  it('Should receive data is valid with Options', async () => {
    const messagePromise = new Promise((resolve) =>
      app.get(
        '/ws',
        upgradeWebSocket(
          () => ({
            onMessage: (evt) => resolve(evt.data),
          }),
          {
            idleTimeout: 5000,
          }
        )
      )
    )
    const socket = new EventTarget() as WebSocket
    Deno.upgradeWebSocket = () => {
      return {
        response: new Response(),
        socket,
      }
    }
    await app.request('/ws', {
      headers: {
        upgrade: 'websocket',
      },
    })
    const data = Math.random().toString()
    socket.onmessage &&
      socket.onmessage(
        new MessageEvent('message', {
          data,
        })
      )
    expect(await messagePromise).toBe(data)
  })
  it('Should call next() when header does not have upgrade', async () => {
    const next = vi.fn()
    await upgradeWebSocket(() => ({}))(
      new Context(
        new Request('http://localhost', {
          headers: {
            Upgrade: 'example',
          },
        })
      ),
      next
    )
    expect(next).toBeCalled()
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/deno/websocket.ts
```typescript
import type { UpgradeWebSocket, WSReadyState } from '../../helper/websocket'
import { WSContext, defineWebSocketHelper } from '../../helper/websocket'

export const upgradeWebSocket: UpgradeWebSocket<WebSocket, Deno.UpgradeWebSocketOptions> =
  defineWebSocketHelper(async (c, events, options) => {
    if (c.req.header('upgrade') !== 'websocket') {
      return
    }

    const { response, socket } = Deno.upgradeWebSocket(c.req.raw, options ?? {})

    const wsContext: WSContext<WebSocket> = new WSContext({
      close: (code, reason) => socket.close(code, reason),
      get protocol() {
        return socket.protocol
      },
      raw: socket,
      get readyState() {
        return socket.readyState as WSReadyState
      },
      url: socket.url ? new URL(socket.url) : null,
      send: (source) => socket.send(source),
    })
    socket.onopen = (evt) => events.onOpen?.(evt, wsContext)
    socket.onmessage = (evt) => events.onMessage?.(evt, wsContext)
    socket.onclose = (evt) => events.onClose?.(evt, wsContext)
    socket.onerror = (evt) => events.onError?.(evt, wsContext)

    return response
  })

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/lambda-edge/conninfo.test.ts
```typescript
import { Context } from '../../context'
import { getConnInfo } from './conninfo'
import type { CloudFrontEdgeEvent } from './handler'

describe('getConnInfo', () => {
  it('Should info is valid', () => {
    const clientIp = Math.random().toString()
    const env = {
      event: {
        Records: [
          {
            cf: {
              request: {
                clientIp,
              },
            },
          },
        ],
      } as CloudFrontEdgeEvent,
    }

    const c = new Context(new Request('http://localhost/'), { env })
    const info = getConnInfo(c)

    expect(info.remote.address).toBe(clientIp)
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/lambda-edge/conninfo.ts
```typescript
import type { Context } from '../../context'
import type { GetConnInfo } from '../../helper/conninfo'
import type { CloudFrontEdgeEvent } from './handler'

type Env = {
  Bindings: {
    event: CloudFrontEdgeEvent
  }
}

export const getConnInfo: GetConnInfo = (c: Context<Env>) => ({
  remote: {
    address: c.env.event.Records[0].cf.request.clientIp,
  },
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/lambda-edge/handler.test.ts
```typescript
import { describe } from 'vitest'
import { setCookie } from '../../helper/cookie'
import { Hono } from '../../hono'
import { encodeBase64 } from '../../utils/encode'
import type { CloudFrontEdgeEvent } from './handler'
import { createBody, handle, isContentTypeBinary } from './handler'

describe('isContentTypeBinary', () => {
  it('Should determine whether it is binary', () => {
    expect(isContentTypeBinary('image/png')).toBe(true)
    expect(isContentTypeBinary('font/woff2')).toBe(true)
    expect(isContentTypeBinary('image/svg+xml')).toBe(false)
    expect(isContentTypeBinary('image/svg+xml; charset=UTF-8')).toBe(false)
    expect(isContentTypeBinary('text/plain')).toBe(false)
    expect(isContentTypeBinary('text/plain; charset=UTF-8')).toBe(false)
    expect(isContentTypeBinary('text/css')).toBe(false)
    expect(isContentTypeBinary('text/javascript')).toBe(false)
    expect(isContentTypeBinary('application/json')).toBe(false)
    expect(isContentTypeBinary('application/ld+json')).toBe(false)
    expect(isContentTypeBinary('application/json')).toBe(false)
  })
})

describe('createBody', () => {
  it('Should the request be a GET or HEAD, the Request must not include a Body', () => {
    const encoder = new TextEncoder()
    const data = encoder.encode('test')
    const body = {
      action: 'read-only',
      data: encodeBase64(data),
      encoding: 'base64',
      inputTruncated: false,
    }

    expect(createBody('GET', body)).toEqual(undefined)
    expect(createBody('GET', body)).not.toEqual(data)
    expect(createBody('HEAD', body)).toEqual(undefined)
    expect(createBody('HEAD', body)).not.toEqual(data)
    expect(createBody('POST', body)).toEqual(data)
    expect(createBody('POST', body)).not.toEqual(undefined)
  })
})

describe('handle', () => {
  const cloudFrontEdgeEvent: CloudFrontEdgeEvent = {
    Records: [
      {
        cf: {
          config: {
            distributionDomainName: 'd111111abcdef8.cloudfront.net',
            distributionId: 'EDFDVBD6EXAMPLE',
            eventType: 'viewer-request',
            requestId: '4TyzHTaYWb1GX1qTfsHhEqV6HUDd_BzoBZnwfnvQc_1oF26ClkoUSEQ==',
          },
          request: {
            clientIp: '1.2.3.4',
            headers: {
              host: [
                {
                  key: 'Host',
                  value: 'hono.dev',
                },
              ],
              accept: [
                {
                  key: 'accept',
                  value: '*/*',
                },
              ],
            },
            method: 'GET',
            querystring: '',
            uri: '/test-path',
          },
        },
      },
    ],
  }

  it('Should support alternate domain names', async () => {
    const app = new Hono()
    app.get('/test-path', (c) => {
      return c.text(c.req.url)
    })
    const handler = handle(app)

    const res = await handler(cloudFrontEdgeEvent)

    expect(res.body).toBe('https://hono.dev/test-path')
  })

  it('Should support multiple cookies', async () => {
    const app = new Hono()
    app.get('/test-path', (c) => {
      setCookie(c, 'cookie1', 'value1')
      setCookie(c, 'cookie2', 'value2')
      return c.text('')
    })
    const handler = handle(app)

    const res = await handler(cloudFrontEdgeEvent)

    expect(res.headers).toEqual({
      'content-type': [
        {
          key: 'content-type',
          value: 'text/plain; charset=UTF-8',
        },
      ],
      'set-cookie': [
        {
          key: 'set-cookie',
          value: 'cookie1=value1; Path=/',
        },
        {
          key: 'set-cookie',
          value: 'cookie2=value2; Path=/',
        },
      ],
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/lambda-edge/handler.ts
```typescript
import crypto from 'node:crypto'
import type { Hono } from '../../hono'

import { decodeBase64, encodeBase64 } from '../../utils/encode'

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
globalThis.crypto ??= crypto

interface CloudFrontHeader {
  key: string
  value: string
}

interface CloudFrontHeaders {
  [name: string]: CloudFrontHeader[]
}

interface CloudFrontCustomOrigin {
  customHeaders: CloudFrontHeaders
  domainName: string
  keepaliveTimeout: number
  path: string
  port: number
  protocol: string
  readTimeout: number
  sslProtocols: string[]
}
// https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-event-structure.html
interface CloudFrontS3Origin {
  authMethod: 'origin-access-identity' | 'none'
  customHeaders: CloudFrontHeaders
  domainName: string
  path: string
  region: string
}
type CloudFrontOrigin =
  | { s3: CloudFrontS3Origin; custom?: never }
  | { custom: CloudFrontCustomOrigin; s3?: never }

export interface CloudFrontRequest {
  clientIp: string
  headers: CloudFrontHeaders
  method: string
  querystring: string
  uri: string
  body?: {
    inputTruncated: boolean
    action: string
    encoding: string
    data: string
  }
  origin?: CloudFrontOrigin
}

export interface CloudFrontResponse {
  headers: CloudFrontHeaders
  status: string
  statusDescription?: string
}

export interface CloudFrontConfig {
  distributionDomainName: string
  distributionId: string
  eventType: string
  requestId: string
}

interface CloudFrontEvent {
  cf: {
    config: CloudFrontConfig
    request: CloudFrontRequest
    response?: CloudFrontResponse
  }
}

export interface CloudFrontEdgeEvent {
  Records: CloudFrontEvent[]
}

type CloudFrontContext = {}

export interface Callback {
  (err: Error | null, result?: CloudFrontRequest | CloudFrontResult): void
}

// https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-generating-http-responses-in-requests.html#lambda-generating-http-responses-programming-model
interface CloudFrontResult {
  status: string
  statusDescription?: string
  headers?: {
    [header: string]: {
      key: string
      value: string
    }[]
  }
  body?: string
  bodyEncoding?: 'text' | 'base64'
}

/**
 * Accepts events from 'Lambda@Edge' event
 * https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-event-structure.html
 */
const convertHeaders = (headers: Headers): CloudFrontHeaders => {
  const cfHeaders: CloudFrontHeaders = {}
  headers.forEach((value, key) => {
    cfHeaders[key.toLowerCase()] = [
      ...(cfHeaders[key.toLowerCase()] || []),
      { key: key.toLowerCase(), value },
    ]
  })
  return cfHeaders
}

export const handle = (
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  app: Hono<any>
): ((
  event: CloudFrontEdgeEvent,
  context?: CloudFrontContext,
  callback?: Callback
) => Promise<CloudFrontResult>) => {
  return async (event, context?, callback?) => {
    const res = await app.fetch(createRequest(event), {
      event,
      context,
      callback: (err: Error | null, result?: CloudFrontResult | CloudFrontRequest) => {
        callback?.(err, result)
      },
      config: event.Records[0].cf.config,
      request: event.Records[0].cf.request,
      response: event.Records[0].cf.response,
    })
    return createResult(res)
  }
}

const createResult = async (res: Response): Promise<CloudFrontResult> => {
  const isBase64Encoded = isContentTypeBinary(res.headers.get('content-type') || '')
  const body = isBase64Encoded ? encodeBase64(await res.arrayBuffer()) : await res.text()

  return {
    status: res.status.toString(),
    headers: convertHeaders(res.headers),
    body,
    ...(isBase64Encoded && { bodyEncoding: 'base64' }),
  }
}

const createRequest = (event: CloudFrontEdgeEvent): Request => {
  const queryString = event.Records[0].cf.request.querystring
  const host =
    event.Records[0].cf.request.headers?.host?.[0]?.value ||
    event.Records[0].cf.config.distributionDomainName
  const urlPath = `https://${host}${event.Records[0].cf.request.uri}`
  const url = queryString ? `${urlPath}?${queryString}` : urlPath

  const headers = new Headers()
  Object.entries(event.Records[0].cf.request.headers).forEach(([k, v]) => {
    v.forEach((header) => headers.set(k, header.value))
  })

  const requestBody = event.Records[0].cf.request.body
  const method = event.Records[0].cf.request.method
  const body = createBody(method, requestBody)

  return new Request(url, {
    headers,
    method,
    body,
  })
}

export const createBody = (
  method: string,
  requestBody: CloudFrontRequest['body']
): string | Uint8Array | undefined => {
  if (!requestBody || !requestBody.data) {
    return undefined
  }
  if (method === 'GET' || method === 'HEAD') {
    return undefined
  }
  if (requestBody.encoding === 'base64') {
    return decodeBase64(requestBody.data)
  }
  return requestBody.data
}

export const isContentTypeBinary = (contentType: string): boolean => {
  return !/^(text\/(plain|html|css|javascript|csv).*|application\/(.*json|.*xml).*|image\/svg\+xml.*)$/.test(
    contentType
  )
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/lambda-edge/index.ts
```typescript
/**
 * @module
 * Lambda@Edge Adapter for Hono.
 */

export { handle } from './handler'
export { getConnInfo } from './conninfo'
export type {
  Callback,
  CloudFrontConfig,
  CloudFrontRequest,
  CloudFrontResponse,
  CloudFrontEdgeEvent,
} from './handler'

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/vercel/conninfo.test.ts
```typescript
import { Context } from '../../context'
import { getConnInfo } from './conninfo'

describe('getConnInfo', () => {
  it('Should getConnInfo works', () => {
    const address = Math.random().toString()
    const req = new Request('http://localhost/', {
      headers: {
        'x-real-ip': address,
      },
    })
    const c = new Context(req)

    const info = getConnInfo(c)

    expect(info.remote.address).toBe(address)
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/vercel/conninfo.ts
```typescript
import type { GetConnInfo } from '../../helper/conninfo'

export const getConnInfo: GetConnInfo = (c) => ({
  remote: {
    // https://github.com/vercel/vercel/blob/b70bfb5fbf28a4650d4042ce68ca5c636d37cf44/packages/edge/src/edge-headers.ts#L10-L12C32
    address: c.req.header('x-real-ip'),
  },
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/vercel/handler.test.ts
```typescript
import { Hono } from '../../hono'
import { handle } from './handler'

describe('Adapter for Next.js', () => {
  it('Should return 200 response', async () => {
    const app = new Hono()
    app.get('/api/author/:name', async (c) => {
      const name = c.req.param('name')
      return c.json({
        path: '/api/author/:name',
        name,
      })
    })
    const handler = handle(app)
    const req = new Request('http://localhost/api/author/hono')
    const res = await handler(req)
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({
      path: '/api/author/:name',
      name: 'hono',
    })
  })

  it('Should not use `route()` if path argument is not passed', async () => {
    const app = new Hono().basePath('/api')

    app.onError((e) => {
      throw e
    })
    app.get('/error', () => {
      throw new Error('Custom Error')
    })

    const handler = handle(app)
    const req = new Request('http://localhost/api/error')
    expect(() => handler(req)).toThrowError('Custom Error')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/vercel/handler.ts
```typescript
/* eslint-disable @typescript-eslint/no-explicit-any */
import type { Hono } from '../../hono'

export const handle =
  (app: Hono<any, any, any>) =>
  (req: Request): Response | Promise<Response> => {
    return app.fetch(req)
  }

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/vercel/index.ts
```typescript
/**
 * @module
 * Vercel Adapter for Hono.
 */

export { handle } from './handler'
export { getConnInfo } from './conninfo'

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/aws-lambda/handler.test.ts
```typescript
import type { LambdaEvent } from './handler'
import { getProcessor, isContentEncodingBinary, isContentTypeBinary } from './handler'

describe('isContentTypeBinary', () => {
  it('Should determine whether it is binary', () => {
    expect(isContentTypeBinary('image/png')).toBe(true)
    expect(isContentTypeBinary('font/woff2')).toBe(true)
    expect(isContentTypeBinary('image/svg+xml')).toBe(false)
    expect(isContentTypeBinary('image/svg+xml; charset=UTF-8')).toBe(false)
    expect(isContentTypeBinary('text/plain')).toBe(false)
    expect(isContentTypeBinary('text/plain; charset=UTF-8')).toBe(false)
    expect(isContentTypeBinary('text/css')).toBe(false)
    expect(isContentTypeBinary('text/javascript')).toBe(false)
    expect(isContentTypeBinary('application/json')).toBe(false)
    expect(isContentTypeBinary('application/ld+json')).toBe(false)
    expect(isContentTypeBinary('application/json')).toBe(false)
  })
})

describe('isContentEncodingBinary', () => {
  it('Should determine whether it is compressed', () => {
    expect(isContentEncodingBinary('gzip')).toBe(true)
    expect(isContentEncodingBinary('compress')).toBe(true)
    expect(isContentEncodingBinary('deflate')).toBe(true)
    expect(isContentEncodingBinary('br')).toBe(true)
    expect(isContentEncodingBinary('deflate, gzip')).toBe(true)
    expect(isContentEncodingBinary('')).toBe(false)
    expect(isContentEncodingBinary('unknown')).toBe(false)
  })
})

describe('EventProcessor.createRequest', () => {
  it('Should return valid Request object from version 1.0 API Gateway event', () => {
    const event: LambdaEvent = {
      version: '1.0',
      resource: '/my/path',
      path: '/my/path',
      httpMethod: 'GET',
      headers: {
        'content-type': 'application/json',
        header1: 'value1',
        header2: 'value1',
      },
      multiValueHeaders: {
        header1: ['value1'],
        header2: ['value1', 'value2', 'value3'],
      },
      // This value doesn't match multi value's content.
      // We want to assert handler is using the multi value's content when both are available.
      queryStringParameters: {
        parameter2: 'value',
      },
      multiValueQueryStringParameters: {
        parameter1: ['value1', 'value2'],
        parameter2: ['value'],
      },
      requestContext: {
        accountId: '123456789012',
        apiId: 'id',
        authorizer: {
          claims: null,
          scopes: null,
        },
        domainName: 'id.execute-api.us-east-1.amazonaws.com',
        domainPrefix: 'id',
        extendedRequestId: 'request-id',
        httpMethod: 'GET',
        identity: {
          sourceIp: '192.0.2.1',
          userAgent: 'user-agent',
          clientCert: {
            clientCertPem: 'CERT_CONTENT',
            subjectDN: 'www.example.com',
            issuerDN: 'Example issuer',
            serialNumber: 'a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1',
            validity: {
              notBefore: 'May 28 12:30:02 2019 GMT',
              notAfter: 'Aug  5 09:36:04 2021 GMT',
            },
          },
        },
        path: '/my/path',
        protocol: 'HTTP/1.1',
        requestId: 'id=',
        requestTime: '04/Mar/2020:19:15:17 +0000',
        requestTimeEpoch: 1583349317135,
        resourcePath: '/my/path',
        stage: '$default',
      },
      pathParameters: {},
      stageVariables: {},
      body: null,
      isBase64Encoded: false,
    }

    const processor = getProcessor(event)
    const request = processor.createRequest(event)

    expect(request.method).toEqual('GET')
    expect(request.url).toEqual(
      'https://id.execute-api.us-east-1.amazonaws.com/my/path?parameter1=value1&parameter1=value2&parameter2=value'
    )
    expect(Object.fromEntries(request.headers)).toEqual({
      'content-type': 'application/json',
      header1: 'value1',
      header2: 'value1, value2, value3',
    })
  })

  it('Should return valid Request object from version 2.0 API Gateway event', () => {
    const event: LambdaEvent = {
      version: '2.0',
      routeKey: '$default',
      rawPath: '/my/path',
      rawQueryString: 'parameter1=value1&parameter1=value2&parameter2=value',
      cookies: ['cookie1', 'cookie2'],
      headers: {
        'content-type': 'application/json',
        header1: 'value1',
        header2: 'value1,value2',
      },
      queryStringParameters: {
        parameter1: 'value1,value2',
        parameter2: 'value',
      },
      requestContext: {
        accountId: '123456789012',
        apiId: 'api-id',
        authentication: null,
        authorizer: {},
        domainName: 'id.execute-api.us-east-1.amazonaws.com',
        domainPrefix: 'id',
        http: {
          method: 'POST',
          path: '/my/path',
          protocol: 'HTTP/1.1',
          sourceIp: '192.0.2.1',
          userAgent: 'agent',
        },
        requestId: 'id',
        routeKey: '$default',
        stage: '$default',
        time: '12/Mar/2020:19:03:58 +0000',
        timeEpoch: 1583348638390,
      },
      body: 'Hello from Lambda',
      pathParameters: {
        parameter1: 'value1',
      },
      isBase64Encoded: false,
      stageVariables: {
        stageVariable1: 'value1',
        stageVariable2: 'value2',
      },
    }

    const processor = getProcessor(event)
    const request = processor.createRequest(event)

    expect(request.method).toEqual('POST')
    expect(request.url).toEqual(
      'https://id.execute-api.us-east-1.amazonaws.com/my/path?parameter1=value1&parameter1=value2&parameter2=value'
    )
    expect(Object.fromEntries(request.headers)).toEqual({
      'content-type': 'application/json',
      cookie: 'cookie1; cookie2',
      header1: 'value1',
      header2: 'value1,value2',
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/aws-lambda/handler.ts
```typescript
import type { Hono } from '../../hono'
import type { Env, Schema } from '../../types'
import { decodeBase64, encodeBase64 } from '../../utils/encode'
import type {
  ALBRequestContext,
  ApiGatewayRequestContext,
  ApiGatewayRequestContextV2,
  Handler,
  LambdaContext,
} from './types'

export type LambdaEvent = APIGatewayProxyEvent | APIGatewayProxyEventV2 | ALBProxyEvent

// When calling HTTP API or Lambda directly through function urls
export interface APIGatewayProxyEventV2 {
  version: string
  routeKey: string
  headers: Record<string, string | undefined>
  multiValueHeaders?: undefined
  cookies?: string[]
  rawPath: string
  rawQueryString: string
  body: string | null
  isBase64Encoded: boolean
  requestContext: ApiGatewayRequestContextV2
  queryStringParameters?: {
    [name: string]: string | undefined
  }
  pathParameters?: {
    [name: string]: string | undefined
  }
  stageVariables?: {
    [name: string]: string | undefined
  }
}

// When calling Lambda through an API Gateway
export interface APIGatewayProxyEvent {
  version: string
  httpMethod: string
  headers: Record<string, string | undefined>
  multiValueHeaders?: {
    [headerKey: string]: string[]
  }
  path: string
  body: string | null
  isBase64Encoded: boolean
  queryStringParameters?: Record<string, string | undefined>
  requestContext: ApiGatewayRequestContext
  resource: string
  multiValueQueryStringParameters?: {
    [parameterKey: string]: string[]
  }
  pathParameters?: Record<string, string>
  stageVariables?: Record<string, string>
}

// When calling Lambda through an Application Load Balancer
export interface ALBProxyEvent {
  httpMethod: string
  headers?: Record<string, string | undefined>
  multiValueHeaders?: Record<string, string[] | undefined>
  path: string
  body: string | null
  isBase64Encoded: boolean
  queryStringParameters?: Record<string, string | undefined>
  multiValueQueryStringParameters?: {
    [parameterKey: string]: string[]
  }
  requestContext: ALBRequestContext
}

type WithHeaders = {
  headers: Record<string, string>
  multiValueHeaders?: undefined
}
type WithMultiValueHeaders = {
  headers?: undefined
  multiValueHeaders: Record<string, string[]>
}

export type APIGatewayProxyResult = {
  statusCode: number
  statusDescription?: string
  body: string
  cookies?: string[]
  isBase64Encoded: boolean
} & (WithHeaders | WithMultiValueHeaders)

const getRequestContext = (
  event: LambdaEvent
): ApiGatewayRequestContext | ApiGatewayRequestContextV2 | ALBRequestContext => {
  return event.requestContext
}

const streamToNodeStream = async (
  reader: ReadableStreamDefaultReader<Uint8Array>,
  writer: NodeJS.WritableStream
): Promise<void> => {
  let readResult = await reader.read()
  while (!readResult.done) {
    writer.write(readResult.value)
    readResult = await reader.read()
  }
  writer.end()
}

export const streamHandle = <
  E extends Env = Env,
  S extends Schema = {},
  BasePath extends string = '/'
>(
  app: Hono<E, S, BasePath>
): Handler => {
  // @ts-expect-error awslambda is not a standard API
  return awslambda.streamifyResponse(
    async (event: LambdaEvent, responseStream: NodeJS.WritableStream, context: LambdaContext) => {
      const processor = getProcessor(event)
      try {
        const req = processor.createRequest(event)
        const requestContext = getRequestContext(event)

        const res = await app.fetch(req, {
          event,
          requestContext,
          context,
        })

        const headers: Record<string, string> = {}
        const cookies: string[] = []
        res.headers.forEach((value, name) => {
          if (name === 'set-cookie') {
            cookies.push(value)
          } else {
            headers[name] = value
          }
        })

        // Check content type
        const httpResponseMetadata = {
          statusCode: res.status,
          headers,
          cookies,
        }

        // Update response stream
        // @ts-expect-error awslambda is not a standard API
        responseStream = awslambda.HttpResponseStream.from(responseStream, httpResponseMetadata)

        if (res.body) {
          await streamToNodeStream(res.body.getReader(), responseStream)
        } else {
          responseStream.write('')
        }
      } catch (error) {
        console.error('Error processing request:', error)
        responseStream.write('Internal Server Error')
      } finally {
        responseStream.end()
      }
    }
  )
}

/**
 * Accepts events from API Gateway/ELB(`APIGatewayProxyEvent`) and directly through Function Url(`APIGatewayProxyEventV2`)
 */
export const handle = <E extends Env = Env, S extends Schema = {}, BasePath extends string = '/'>(
  app: Hono<E, S, BasePath>
): (<L extends LambdaEvent>(
  event: L,
  lambdaContext?: LambdaContext
) => Promise<
  APIGatewayProxyResult &
    (L extends { multiValueHeaders: Record<string, string[]> }
      ? WithMultiValueHeaders
      : WithHeaders)
>) => {
  // @ts-expect-error FIXME: Fix return typing
  return async (event, lambdaContext?) => {
    const processor = getProcessor(event)

    const req = processor.createRequest(event)
    const requestContext = getRequestContext(event)

    const res = await app.fetch(req, {
      event,
      requestContext,
      lambdaContext,
    })

    return processor.createResult(event, res)
  }
}

export abstract class EventProcessor<E extends LambdaEvent> {
  protected abstract getPath(event: E): string

  protected abstract getMethod(event: E): string

  protected abstract getQueryString(event: E): string

  protected abstract getHeaders(event: E): Headers

  protected abstract getCookies(event: E, headers: Headers): void

  protected abstract setCookiesToResult(result: APIGatewayProxyResult, cookies: string[]): void

  createRequest(event: E): Request {
    const queryString = this.getQueryString(event)
    const domainName =
      event.requestContext && 'domainName' in event.requestContext
        ? event.requestContext.domainName
        : event.headers?.['host'] ?? event.multiValueHeaders?.['host']?.[0]
    const path = this.getPath(event)
    const urlPath = `https://${domainName}${path}`
    const url = queryString ? `${urlPath}?${queryString}` : urlPath

    const headers = this.getHeaders(event)

    const method = this.getMethod(event)
    const requestInit: RequestInit = {
      headers,
      method,
    }

    if (event.body) {
      requestInit.body = event.isBase64Encoded ? decodeBase64(event.body) : event.body
    }

    return new Request(url, requestInit)
  }

  async createResult(event: E, res: Response): Promise<APIGatewayProxyResult> {
    const contentType = res.headers.get('content-type')
    let isBase64Encoded = contentType && isContentTypeBinary(contentType) ? true : false

    if (!isBase64Encoded) {
      const contentEncoding = res.headers.get('content-encoding')
      isBase64Encoded = isContentEncodingBinary(contentEncoding)
    }

    const body = isBase64Encoded ? encodeBase64(await res.arrayBuffer()) : await res.text()

    const result: APIGatewayProxyResult = {
      body: body,
      statusCode: res.status,
      isBase64Encoded,
      ...(event.multiValueHeaders
        ? {
            multiValueHeaders: {},
          }
        : {
            headers: {},
          }),
    }

    this.setCookies(event, res, result)
    if (result.multiValueHeaders) {
      res.headers.forEach((value, key) => {
        result.multiValueHeaders[key] = [value]
      })
    } else {
      res.headers.forEach((value, key) => {
        result.headers[key] = value
      })
    }

    return result
  }

  setCookies(event: E, res: Response, result: APIGatewayProxyResult) {
    if (res.headers.has('set-cookie')) {
      const cookies = res.headers.getSetCookie
        ? res.headers.getSetCookie()
        : Array.from(res.headers.entries())
            .filter(([k]) => k === 'set-cookie')
            .map(([, v]) => v)

      if (Array.isArray(cookies)) {
        this.setCookiesToResult(result, cookies)
        res.headers.delete('set-cookie')
      }
    }
  }
}

export class EventV2Processor extends EventProcessor<APIGatewayProxyEventV2> {
  protected getPath(event: APIGatewayProxyEventV2): string {
    return event.rawPath
  }

  protected getMethod(event: APIGatewayProxyEventV2): string {
    return event.requestContext.http.method
  }

  protected getQueryString(event: APIGatewayProxyEventV2): string {
    return event.rawQueryString
  }

  protected getCookies(event: APIGatewayProxyEventV2, headers: Headers): void {
    if (Array.isArray(event.cookies)) {
      headers.set('Cookie', event.cookies.join('; '))
    }
  }

  protected setCookiesToResult(result: APIGatewayProxyResult, cookies: string[]): void {
    result.cookies = cookies
  }

  protected getHeaders(event: APIGatewayProxyEventV2): Headers {
    const headers = new Headers()
    this.getCookies(event, headers)
    if (event.headers) {
      for (const [k, v] of Object.entries(event.headers)) {
        if (v) {
          headers.set(k, v)
        }
      }
    }
    return headers
  }
}

const v2Processor: EventV2Processor = new EventV2Processor()

export class EventV1Processor extends EventProcessor<Exclude<LambdaEvent, APIGatewayProxyEventV2>> {
  protected getPath(event: Exclude<LambdaEvent, APIGatewayProxyEventV2>): string {
    return event.path
  }

  protected getMethod(event: Exclude<LambdaEvent, APIGatewayProxyEventV2>): string {
    return event.httpMethod
  }

  protected getQueryString(event: Exclude<LambdaEvent, APIGatewayProxyEventV2>): string {
    // In the case of gateway Integration either queryStringParameters or multiValueQueryStringParameters can be present not both
    if (event.multiValueQueryStringParameters) {
      return Object.entries(event.multiValueQueryStringParameters || {})
        .filter(([, value]) => value)
        .map(([key, value]) => `${key}=${value.join(`&${key}=`)}`)
        .join('&')
    } else {
      return Object.entries(event.queryStringParameters || {})
        .filter(([, value]) => value)
        .map(([key, value]) => `${key}=${value}`)
        .join('&')
    }
  }

  protected getCookies(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    event: Exclude<LambdaEvent, APIGatewayProxyEventV2>,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    headers: Headers
  ): void {
    // nop
  }

  protected getHeaders(event: APIGatewayProxyEvent): Headers {
    const headers = new Headers()
    this.getCookies(event, headers)
    if (event.headers) {
      for (const [k, v] of Object.entries(event.headers)) {
        if (v) {
          headers.set(k, v)
        }
      }
    }
    if (event.multiValueHeaders) {
      for (const [k, values] of Object.entries(event.multiValueHeaders)) {
        if (values) {
          // avoid duplicating already set headers
          const foundK = headers.get(k)
          values.forEach((v) => (!foundK || !foundK.includes(v)) && headers.append(k, v))
        }
      }
    }
    return headers
  }

  protected setCookiesToResult(result: APIGatewayProxyResult, cookies: string[]): void {
    result.multiValueHeaders = {
      'set-cookie': cookies,
    }
  }
}

const v1Processor: EventV1Processor = new EventV1Processor()

export class ALBProcessor extends EventProcessor<ALBProxyEvent> {
  protected getHeaders(event: ALBProxyEvent): Headers {
    const headers = new Headers()
    // if multiValueHeaders is present the ALB will use it instead of the headers field
    // https://docs.aws.amazon.com/elasticloadbalancing/latest/application/lambda-functions.html#multi-value-headers
    if (event.multiValueHeaders) {
      for (const [key, values] of Object.entries(event.multiValueHeaders)) {
        if (values && Array.isArray(values)) {
          // https://www.rfc-editor.org/rfc/rfc9110.html#name-common-rules-for-defining-f
          headers.set(key, values.join('; '))
        }
      }
    } else {
      for (const [key, value] of Object.entries(event.headers ?? {})) {
        if (value) {
          headers.set(key, value)
        }
      }
    }
    return headers
  }

  protected getPath(event: ALBProxyEvent): string {
    return event.path
  }

  protected getMethod(event: ALBProxyEvent): string {
    return event.httpMethod
  }

  protected getQueryString(event: ALBProxyEvent): string {
    // In the case of ALB Integration either queryStringParameters or multiValueQueryStringParameters can be present not both
    /*
      In other cases like when using the serverless framework, the event object does contain both queryStringParameters and multiValueQueryStringParameters:
      Below is an example event object for this URL: /payment/b8c55e69?select=amount&select=currency
      {
        ...
        queryStringParameters: { select: 'currency' },
        multiValueQueryStringParameters: { select: [ 'amount', 'currency' ] },
      }
      The expected results is for select to be an array with two items. However the pre-fix code is only returning one item ('currency') in the array.
      A simple fix would be to invert the if statement and check the multiValueQueryStringParameters first.
    */
    if (event.multiValueQueryStringParameters) {
      return Object.entries(event.multiValueQueryStringParameters || {})
        .filter(([, value]) => value)
        .map(([key, value]) => `${key}=${value.join(`&${key}=`)}`)
        .join('&')
    } else {
      return Object.entries(event.queryStringParameters || {})
        .filter(([, value]) => value)
        .map(([key, value]) => `${key}=${value}`)
        .join('&')
    }
  }

  protected getCookies(event: ALBProxyEvent, headers: Headers): void {
    let cookie
    if (event.multiValueHeaders) {
      cookie = event.multiValueHeaders['cookie']?.join('; ')
    } else {
      cookie = event.headers ? event.headers['cookie'] : undefined
    }
    if (cookie) {
      headers.append('Cookie', cookie)
    }
  }

  protected setCookiesToResult(result: APIGatewayProxyResult, cookies: string[]): void {
    // when multi value headers is enabled
    if (result.multiValueHeaders) {
      result.multiValueHeaders['set-cookie'] = cookies
    } else {
      // otherwise serialize the set-cookie
      result.headers['set-cookie'] = cookies.join(', ')
    }
  }
}

const albProcessor: ALBProcessor = new ALBProcessor()

export const getProcessor = (event: LambdaEvent): EventProcessor<LambdaEvent> => {
  if (isProxyEventALB(event)) {
    return albProcessor
  }
  if (isProxyEventV2(event)) {
    return v2Processor
  }
  return v1Processor
}

const isProxyEventALB = (event: LambdaEvent): event is ALBProxyEvent => {
  if (event.requestContext) {
    return Object.hasOwn(event.requestContext, 'elb')
  }
  return false
}

const isProxyEventV2 = (event: LambdaEvent): event is APIGatewayProxyEventV2 => {
  return Object.hasOwn(event, 'rawPath')
}

export const isContentTypeBinary = (contentType: string) => {
  return !/^(text\/(plain|html|css|javascript|csv).*|application\/(.*json|.*xml).*|image\/svg\+xml.*)$/.test(
    contentType
  )
}

export const isContentEncodingBinary = (contentEncoding: string | null) => {
  if (contentEncoding === null) {
    return false
  }
  return /^(gzip|deflate|compress|br)/.test(contentEncoding)
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/aws-lambda/index.ts
```typescript
/**
 * @module
 * AWS Lambda Adapter for Hono.
 */

export { handle, streamHandle } from './handler'
export type { APIGatewayProxyResult, LambdaEvent } from './handler'
export type {
  ApiGatewayRequestContext,
  ApiGatewayRequestContextV2,
  ALBRequestContext,
  LambdaContext,
} from './types'

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/aws-lambda/types.ts
```typescript
/* eslint-disable @typescript-eslint/no-explicit-any */

export interface CognitoIdentity {
  cognitoIdentityId: string
  cognitoIdentityPoolId: string
}

export interface ClientContext {
  client: ClientContextClient

  Custom?: any
  env: ClientContextEnv
}

export interface ClientContextClient {
  installationId: string
  appTitle: string
  appVersionName: string
  appVersionCode: string
  appPackageName: string
}

export interface ClientContextEnv {
  platformVersion: string
  platform: string
  make: string
  model: string
  locale: string
}

/**
 * {@link Handler} context parameter.
 * See {@link https://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-context.html AWS documentation}.
 */
export interface LambdaContext {
  callbackWaitsForEmptyEventLoop: boolean
  functionName: string
  functionVersion: string
  invokedFunctionArn: string
  memoryLimitInMB: string
  awsRequestId: string
  logGroupName: string
  logStreamName: string
  identity?: CognitoIdentity | undefined
  clientContext?: ClientContext | undefined

  getRemainingTimeInMillis(): number
}

type Callback<TResult = any> = (error?: Error | string | null, result?: TResult) => void

export type Handler<TEvent = any, TResult = any> = (
  event: TEvent,
  context: LambdaContext,
  callback: Callback<TResult>
) => void | Promise<TResult>

interface ClientCert {
  clientCertPem: string
  subjectDN: string
  issuerDN: string
  serialNumber: string
  validity: {
    notBefore: string
    notAfter: string
  }
}

interface Identity {
  accessKey?: string
  accountId?: string
  caller?: string
  cognitoAuthenticationProvider?: string
  cognitoAuthenticationType?: string
  cognitoIdentityId?: string
  cognitoIdentityPoolId?: string
  principalOrgId?: string
  sourceIp: string
  user?: string
  userAgent: string
  userArn?: string
  clientCert?: ClientCert
}

export interface ApiGatewayRequestContext {
  accountId: string
  apiId: string
  authorizer: {
    claims?: unknown
    scopes?: unknown
  }
  domainName: string
  domainPrefix: string
  extendedRequestId: string
  httpMethod: string
  identity: Identity
  path: string
  protocol: string
  requestId: string
  requestTime: string
  requestTimeEpoch: number
  resourceId?: string
  resourcePath: string
  stage: string
}

interface Authorizer {
  iam?: {
    accessKey: string
    accountId: string
    callerId: string
    cognitoIdentity: null
    principalOrgId: null
    userArn: string
    userId: string
  }
}

export interface ApiGatewayRequestContextV2 {
  accountId: string
  apiId: string
  authentication: null
  authorizer: Authorizer
  domainName: string
  domainPrefix: string
  http: {
    method: string
    path: string
    protocol: string
    sourceIp: string
    userAgent: string
  }
  requestId: string
  routeKey: string
  stage: string
  time: string
  timeEpoch: number
}

export interface ALBRequestContext {
  elb: {
    targetGroupArn: string
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/cloudflare-pages/handler.test.ts
```typescript
import { getCookie } from '../../helper/cookie'
import { Hono } from '../../hono'
import { HTTPException } from '../../http-exception'
import type { EventContext } from './handler'
import { handle, handleMiddleware, serveStatic } from './handler'

type Env = {
  Bindings: {
    TOKEN: string
  }
}

function createEventContext(
  context: Partial<EventContext<Env['Bindings']>>
): EventContext<Env['Bindings']> {
  return {
    data: {},
    env: {
      ...context.env,
      ASSETS: { fetch: vi.fn(), ...context.env?.ASSETS },
      TOKEN: context.env?.TOKEN ?? 'HONOISHOT',
    },
    functionPath: '_worker.js',
    next: vi.fn(),
    params: {},
    passThroughOnException: vi.fn(),
    request: new Request('http://localhost/api/foo'),
    waitUntil: vi.fn(),
    ...context,
  }
}

describe('Adapter for Cloudflare Pages', () => {
  it('Should return 200 response', async () => {
    const request = new Request('http://localhost/api/foo')
    const env = {
      ASSETS: { fetch },
      TOKEN: 'HONOISHOT',
    }
    const waitUntil = vi.fn()
    const passThroughOnException = vi.fn()
    const eventContext = createEventContext({
      request,
      env,
      waitUntil,
      passThroughOnException,
    })
    const app = new Hono<Env>()
    const appFetchSpy = vi.spyOn(app, 'fetch')
    app.get('/api/foo', (c) => {
      return c.json({ TOKEN: c.env.TOKEN, requestURL: c.req.url })
    })
    const handler = handle(app)
    const res = await handler(eventContext)
    expect(appFetchSpy).toHaveBeenCalledWith(
      request,
      { ...env, eventContext },
      { waitUntil, passThroughOnException }
    )
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({
      TOKEN: 'HONOISHOT',
      requestURL: 'http://localhost/api/foo',
    })
  })

  it('Should not use `basePath()` if path argument is not passed', async () => {
    const request = new Request('http://localhost/api/error')
    const eventContext = createEventContext({ request })
    const app = new Hono().basePath('/api')

    app.onError((e) => {
      throw e
    })
    app.get('/error', () => {
      throw new Error('Custom Error')
    })

    const handler = handle(app)
    // It does throw the error if app is NOT "subApp"
    expect(() => handler(eventContext)).toThrowError('Custom Error')
  })
})

describe('Middleware adapter for Cloudflare Pages', () => {
  it('Should return the middleware response', async () => {
    const request = new Request('http://localhost/api/foo', {
      headers: {
        Cookie: 'my_cookie=1234',
      },
    })
    const next = vi.fn().mockResolvedValue(Response.json('From Cloudflare Pages'))
    const eventContext = createEventContext({ request, next })
    const handler = handleMiddleware(async (c, next) => {
      const cookie = getCookie(c, 'my_cookie')

      await next()

      return c.json({ cookie, response: await c.res.json() })
    })

    const res = await handler(eventContext)

    expect(next).toHaveBeenCalled()

    expect(await res.json()).toEqual({
      cookie: '1234',
      response: 'From Cloudflare Pages',
    })
  })

  it('Should return the middleware response when exceptions are handled', async () => {
    const request = new Request('http://localhost/api/foo')
    const handler = handleMiddleware(async (c, next) => {
      await next()

      return c.json({ error: c.error?.message })
    })

    const next = vi.fn().mockRejectedValue(new Error('Error from next()'))
    const eventContext = createEventContext({ request, next })
    const res = await handler(eventContext)

    expect(next).toHaveBeenCalled()

    expect(await res.json()).toEqual({
      error: 'Error from next()',
    })
  })

  it('Should return the middleware response if next() is not called', async () => {
    const request = new Request('http://localhost/api/foo')
    const handler = handleMiddleware(async (c) => {
      return c.json({ response: 'Skip Cloudflare Pages' })
    })

    const next = vi.fn()
    const eventContext = createEventContext({ request, next })
    const res = await handler(eventContext)

    expect(next).not.toHaveBeenCalled()

    expect(await res.json()).toEqual({
      response: 'Skip Cloudflare Pages',
    })
  })

  it('Should return the Pages response if the middleware does not return a response', async () => {
    const request = new Request('http://localhost/api/foo')
    const handler = handleMiddleware((c, next) => next())

    const next = vi.fn().mockResolvedValue(Response.json('From Cloudflare Pages'))
    const eventContext = createEventContext({ request, next })
    const res = await handler(eventContext)

    expect(next).toHaveBeenCalled()

    expect(await res.json()).toEqual('From Cloudflare Pages')
  })

  it('Should handle a HTTPException by returning error.getResponse()', async () => {
    const request = new Request('http://localhost/api/foo')
    const handler = handleMiddleware(() => {
      const res = new Response('Unauthorized', { status: 401 })
      throw new HTTPException(401, { res })
    })

    const next = vi.fn()
    const eventContext = createEventContext({ request, next })
    const res = await handler(eventContext)

    expect(next).not.toHaveBeenCalled()

    expect(res.status).toBe(401)
    expect(await res.text()).toBe('Unauthorized')
  })

  it('Should handle an HTTPException thrown by next()', async () => {
    const request = new Request('http://localhost/api/foo')
    const handler = handleMiddleware((c, next) => next())

    const next = vi
      .fn()
      .mockRejectedValue(new HTTPException(401, { res: Response.json('Unauthorized') }))
    const eventContext = createEventContext({ request, next })
    const res = await handler(eventContext)

    expect(next).toHaveBeenCalled()

    expect(await res.json()).toEqual('Unauthorized')
  })

  it('Should handle an Error thrown by next()', async () => {
    const request = new Request('http://localhost/api/foo')
    const handler = handleMiddleware((c, next) => next())

    const next = vi.fn().mockRejectedValue(new Error('Error from next()'))
    const eventContext = createEventContext({ request, next })
    await expect(handler(eventContext)).rejects.toThrowError('Error from next()')
    expect(next).toHaveBeenCalled()
  })

  it('Should handle a non-Error thrown by next()', async () => {
    const request = new Request('http://localhost/api/foo')
    const handler = handleMiddleware((c, next) => next())

    const next = vi.fn().mockRejectedValue('Error from next()')
    const eventContext = createEventContext({ request, next })
    await expect(handler(eventContext)).rejects.toThrowError('Error from next()')
    expect(next).toHaveBeenCalled()
  })

  it('Should rethrow an Error', async () => {
    const request = new Request('http://localhost/api/foo')
    const handler = handleMiddleware(() => {
      throw new Error('Something went wrong')
    })

    const next = vi.fn()
    const eventContext = createEventContext({ request, next })
    await expect(handler(eventContext)).rejects.toThrowError('Something went wrong')
    expect(next).not.toHaveBeenCalled()
  })

  it('Should rethrow non-Error exceptions', async () => {
    const request = new Request('http://localhost/api/foo')
    const handler = handleMiddleware(() => Promise.reject('Something went wrong'))
    const next = vi.fn()
    const eventContext = createEventContext({ request, next })
    await expect(handler(eventContext)).rejects.toThrowError('Something went wrong')
    expect(next).not.toHaveBeenCalled()
  })

  it('Should set the data in eventContext.data', async () => {
    const next = vi.fn()
    const eventContext = createEventContext({ next })
    const handler = handleMiddleware(async (c, next) => {
      c.env.eventContext.data.user = 'Joe'
      await next()
    })
    expect(eventContext.data.user).toBeUndefined()
    await handler(eventContext)
    expect(eventContext.data.user).toBe('Joe')
  })
})

describe('serveStatic()', () => {
  it('Should pass the raw request to ASSETS.fetch', async () => {
    const assetsFetch = vi.fn().mockResolvedValue(new Response('foo.png'))
    const request = new Request('http://localhost/foo.png')
    const env = {
      ASSETS: { fetch: assetsFetch },
      TOKEN: 'HONOISHOT',
    }

    const eventContext = createEventContext({ request, env })
    const app = new Hono<Env>()
    app.use(serveStatic())
    const handler = handle(app)
    const res = await handler(eventContext)

    expect(assetsFetch).toHaveBeenCalledWith(request)
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('foo.png')
  })

  it('Should respond with 404 if ASSETS.fetch returns a 404 response', async () => {
    const assetsFetch = vi.fn().mockResolvedValue(new Response(null, { status: 404 }))
    const request = new Request('http://localhost/foo.png')
    const env = {
      ASSETS: { fetch: assetsFetch },
      TOKEN: 'HONOISHOT',
    }

    const eventContext = createEventContext({ request, env })
    const app = new Hono<Env>()
    app.use(serveStatic())
    const handler = handle(app)
    const res = await handler(eventContext)

    expect(assetsFetch).toHaveBeenCalledWith(request)
    expect(res.status).toBe(404)
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/cloudflare-pages/handler.ts
```typescript
import { Context } from '../../context'
import type { Hono } from '../../hono'
import { HTTPException } from '../../http-exception'
import type { BlankSchema, Env, Input, MiddlewareHandler, Schema } from '../../types'

// Ref: https://github.com/cloudflare/workerd/blob/main/types/defines/pages.d.ts

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type Params<P extends string = any> = Record<P, string | string[]>

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type EventContext<Env = {}, P extends string = any, Data = Record<string, unknown>> = {
  request: Request
  functionPath: string
  waitUntil: (promise: Promise<unknown>) => void
  passThroughOnException: () => void
  next: (input?: Request | string, init?: RequestInit) => Promise<Response>
  env: Env & { ASSETS: { fetch: typeof fetch } }
  params: Params<P>
  data: Data
}

declare type PagesFunction<
  Env = unknown,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  Params extends string = any,
  Data extends Record<string, unknown> = Record<string, unknown>
> = (context: EventContext<Env, Params, Data>) => Response | Promise<Response>

export const handle =
  <E extends Env = Env, S extends Schema = BlankSchema, BasePath extends string = '/'>(
    app: Hono<E, S, BasePath>
  ): PagesFunction<E['Bindings']> =>
  (eventContext) => {
    return app.fetch(
      eventContext.request,
      { ...eventContext.env, eventContext },
      {
        waitUntil: eventContext.waitUntil,
        passThroughOnException: eventContext.passThroughOnException,
      }
    )
  }

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function handleMiddleware<E extends Env = {}, P extends string = any, I extends Input = {}>(
  middleware: MiddlewareHandler<
    E & {
      Bindings: {
        eventContext: EventContext
      }
    },
    P,
    I
  >
): PagesFunction<E['Bindings']> {
  return async (executionCtx) => {
    const context = new Context(executionCtx.request, {
      env: { ...executionCtx.env, eventContext: executionCtx },
      executionCtx,
    })

    let response: Response | void = undefined

    try {
      response = await middleware(context, async () => {
        try {
          context.res = await executionCtx.next()
        } catch (error) {
          if (error instanceof Error) {
            context.error = error
          } else {
            throw error
          }
        }
      })
    } catch (error) {
      if (error instanceof Error) {
        context.error = error
      } else {
        throw error
      }
    }

    if (response) {
      return response
    }

    if (context.error instanceof HTTPException) {
      return context.error.getResponse()
    }

    if (context.error) {
      throw context.error
    }

    return context.res
  }
}

declare abstract class FetcherLike {
  fetch(input: RequestInfo, init?: RequestInit): Promise<Response>
}

/**
 *
 * @description `serveStatic()` is for advanced mode:
 * https://developers.cloudflare.com/pages/platform/functions/advanced-mode/#set-up-a-function
 *
 */
export const serveStatic = (): MiddlewareHandler => {
  return async (c) => {
    const env = c.env as { ASSETS: FetcherLike }
    const res = await env.ASSETS.fetch(c.req.raw)
    if (res.status === 404) {
      return c.notFound()
    }
    return res
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/cloudflare-pages/index.ts
```typescript
/**
 * @module
 * Cloudflare Pages Adapter for Hono.
 */

export { handle, handleMiddleware, serveStatic } from './handler'
export type { EventContext } from './handler'

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/bun/conninfo.test.ts
```typescript
import { Context } from '../../context'
import type { AddressType } from '../../helper/conninfo'
import { getConnInfo } from './conninfo'

const createRandomBunServer = ({
  address = Math.random().toString(),
  port = Math.floor(Math.random() * (65535 + 1)),
  family = 'IPv6',
}: {
  address?: string
  port?: number
  family?: AddressType | string
} = {}) => {
  return {
    address,
    port,
    server: {
      requestIP() {
        return {
          address,
          family,
          port,
        }
      },
    },
  }
}
describe('getConnInfo', () => {
  it('Should info is valid', () => {
    const { port, server, address } = createRandomBunServer()
    const c = new Context(new Request('http://localhost/'), { env: server })
    const info = getConnInfo(c)

    expect(info.remote.port).toBe(port)
    expect(info.remote.address).toBe(address)
    expect(info.remote.addressType).toBe('IPv6')
    expect(info.remote.transport).toBeUndefined()
  })
  it('Should getConnInfo works when env is { server: server }', () => {
    const { port, server, address } = createRandomBunServer()
    const c = new Context(new Request('http://localhost/'), { env: { server } })

    const info = getConnInfo(c)

    expect(info.remote.port).toBe(port)
    expect(info.remote.address).toBe(address)
    expect(info.remote.addressType).toBe('IPv6')
    expect(info.remote.transport).toBeUndefined()
  })
  it('should return undefined when addressType is invalid string', () => {
    const { server } = createRandomBunServer({ family: 'invalid' })
    const c = new Context(new Request('http://localhost/'), { env: { server } })

    const info = getConnInfo(c)

    expect(info.remote.addressType).toBeUndefined()
  })
  it('Should throw error when user did not give server', () => {
    const c = new Context(new Request('http://localhost/'), { env: {} })

    expect(() => getConnInfo(c)).toThrowError(TypeError)
  })
  it('Should throw error when requestIP is not function', () => {
    const c = new Context(new Request('http://localhost/'), {
      env: {
        requestIP: 0,
      },
    })
    expect(() => getConnInfo(c)).toThrowError(TypeError)
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/bun/conninfo.ts
```typescript
import type { Context } from '../..'
import type { GetConnInfo } from '../../helper/conninfo'
import { getBunServer } from './server'

/**
 * Get ConnInfo with Bun
 * @param c Context
 * @returns ConnInfo
 */
export const getConnInfo: GetConnInfo = (c: Context) => {
  const server = getBunServer(c)

  if (!server) {
    throw new TypeError('env has to include the 2nd argument of fetch.')
  }
  if (typeof server.requestIP !== 'function') {
    throw new TypeError('server.requestIP is not a function.')
  }
  const info = server.requestIP(c.req.raw)

  return {
    remote: {
      address: info.address,
      addressType: info.family === 'IPv6' || info.family === 'IPv4' ? info.family : undefined,
      port: info.port,
    },
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/bun/index.ts
```typescript
/**
 * @module
 * Bun Adapter for Hono.
 */

export { serveStatic } from './serve-static'
export { bunFileSystemModule, toSSG } from './ssg'
export { createBunWebSocket } from './websocket'
export type { BunWebSocketData, BunWebSocketHandler } from './websocket'
export { getConnInfo } from './conninfo'

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/bun/serve-static.ts
```typescript
/* eslint-disable @typescript-eslint/ban-ts-comment */
import { stat } from 'node:fs/promises'
import { serveStatic as baseServeStatic } from '../../middleware/serve-static'
import type { ServeStaticOptions } from '../../middleware/serve-static'
import type { Env, MiddlewareHandler } from '../../types'

export const serveStatic = <E extends Env = Env>(
  options: ServeStaticOptions<E>
): MiddlewareHandler => {
  return async function serveStatic(c, next) {
    const getContent = async (path: string) => {
      path = path.startsWith('/') ? path : `./${path}`
      // @ts-ignore
      const file = Bun.file(path)
      return (await file.exists()) ? file : null
    }
    const pathResolve = (path: string) => {
      return path.startsWith('/') ? path : `./${path}`
    }
    const isDir = async (path: string) => {
      let isDir
      try {
        const stats = await stat(path)
        isDir = stats.isDirectory()
      } catch {}
      return isDir
    }
    return baseServeStatic({
      ...options,
      getContent,
      pathResolve,
      isDir,
    })(c, next)
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/bun/server.test.ts
```typescript
import { Context } from '../../context'
import { getBunServer } from './server'
import type { BunServer } from './server'

describe('getBunServer', () => {
  it('Should success to pick Server', () => {
    const server = {} as BunServer

    expect(getBunServer(new Context(new Request('http://localhost/'), { env: server }))).toBe(
      server
    )
    expect(getBunServer(new Context(new Request('http://localhost/'), { env: { server } }))).toBe(
      server
    )
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/bun/server.ts
```typescript
/**
 * Getting Bun Server Object for Bun adapters
 * @module
 */
import type { Context } from '../../context'

/**
 * Bun Server Object
 */
export interface BunServer {
  requestIP?: (req: Request) => {
    address: string
    family: string
    port: number
  }
  upgrade<T>(
    req: Request,
    options?: {
      data: T
    }
  ): boolean
}

/**
 * Get Bun Server Object from Context
 * @param c Context
 * @returns Bun Server
 */
export const getBunServer = (c: Context): BunServer | undefined =>
  ('server' in c.env ? c.env.server : c.env) as BunServer | undefined

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/bun/ssg.ts
```typescript
/* eslint-disable @typescript-eslint/ban-ts-comment */
import { toSSG as baseToSSG } from '../../helper/ssg'
import type { FileSystemModule, ToSSGAdaptorInterface } from '../../helper/ssg'

// @ts-ignore
const { write } = Bun

/**
 * @experimental
 * `bunFileSystemModule` is an experimental feature.
 * The API might be changed.
 */
export const bunFileSystemModule: FileSystemModule = {
  writeFile: async (path, data) => {
    await write(path, data)
  },
  mkdir: async () => {},
}

/**
 * @experimental
 * `toSSG` is an experimental feature.
 * The API might be changed.
 */
export const toSSG: ToSSGAdaptorInterface = async (app, options) => {
  return baseToSSG(app, bunFileSystemModule, options)
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/bun/websocket.test.ts
```typescript
import { Context } from '../../context'
import type { BunWebSocketData, BunServerWebSocket } from './websocket'
import { createWSContext, createBunWebSocket } from './websocket'

describe('createWSContext()', () => {
  it('Should send() and close() works', () => {
    const send = vi.fn()
    const close = vi.fn()
    const ws = createWSContext({
      send(data) {
        send(data)
      },
      close(code, reason) {
        close(code, reason)
      },
      data: {},
    } as BunServerWebSocket<BunWebSocketData>)
    ws.send('message')
    expect(send).toBeCalled()
    ws.close()
    expect(close).toBeCalled()
  })
})
describe('upgradeWebSocket()', () => {
  it('Should throw error when server is null', async () => {
    const { upgradeWebSocket } = createBunWebSocket()
    const run = async () =>
      await upgradeWebSocket(() => ({}))(
        new Context(new Request('http://localhost'), {
          env: {
            server: null,
          },
        }),
        () => Promise.resolve()
      )

    await expect(run).rejects.toThrowError(/env has/)
  })
  it('Should response null when upgraded', async () => {
    const { upgradeWebSocket } = createBunWebSocket()
    const upgraded = await upgradeWebSocket(() => ({}))(
      new Context(new Request('http://localhost'), {
        env: {
          upgrade: () => true,
        },
      }),
      () => Promise.resolve()
    )
    expect(upgraded).toBeTruthy()
  })
  it('Should response undefined when upgrade failed', async () => {
    const { upgradeWebSocket } = createBunWebSocket()
    const upgraded = await upgradeWebSocket(() => ({}))(
      new Context(new Request('http://localhost'), {
        env: {
          upgrade: () => undefined,
        },
      }),
      () => Promise.resolve()
    )
    expect(upgraded).toBeFalsy()
  })
})
describe('createBunWebSocket()', () => {
  beforeAll(() => {
    // @ts-expect-error patch global
    globalThis.CloseEvent = Event
  })
  afterAll(() => {
    // @ts-expect-error patch global
    delete globalThis.CloseEvent
  })
  it('Should events are called', async () => {
    const { websocket, upgradeWebSocket } = createBunWebSocket()

    const open = vi.fn()
    const message = vi.fn()
    const close = vi.fn()

    const ws = {
      data: {
        events: {
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          onOpen(evt, ws) {
            open()
          },
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          onMessage(evt, ws) {
            message()
            if (evt.data instanceof ArrayBuffer) {
              receivedArrayBuffer = evt.data
            }
          },
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          onClose(evt, ws) {
            close()
          },
        },
      },
    } as BunServerWebSocket<BunWebSocketData>

    let receivedArrayBuffer: ArrayBuffer | undefined = undefined
    await upgradeWebSocket(() => ({}))(
      new Context(new Request('http://localhost'), {
        env: {
          upgrade() {
            return true
          },
        },
      }),
      () => Promise.resolve()
    )

    websocket.open(ws)
    expect(open).toBeCalled()

    websocket.message(ws, 'message')
    expect(message).toBeCalled()

    websocket.message(ws, new Uint8Array(16))
    expect(receivedArrayBuffer).toBeInstanceOf(ArrayBuffer)
    expect(receivedArrayBuffer!.byteLength).toBe(16)

    websocket.close(ws)
    expect(close).toBeCalled()
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/bun/websocket.ts
```typescript
import type { UpgradeWebSocket, WSEvents, WSMessageReceive } from '../../helper/websocket'
import { createWSMessageEvent, defineWebSocketHelper, WSContext } from '../../helper/websocket'
import { getBunServer } from './server'

/**
 * @internal
 */
export interface BunServerWebSocket<T> {
  send(data: string | ArrayBuffer | Uint8Array, compress?: boolean): void
  close(code?: number, reason?: string): void
  data: T
  readyState: 0 | 1 | 2 | 3
}

export interface BunWebSocketHandler<T> {
  open(ws: BunServerWebSocket<T>): void
  close(ws: BunServerWebSocket<T>, code?: number, reason?: string): void
  message(ws: BunServerWebSocket<T>, message: string | { buffer: ArrayBufferLike }): void
}
interface CreateWebSocket<T> {
  upgradeWebSocket: UpgradeWebSocket<T>
  websocket: BunWebSocketHandler<BunWebSocketData>
}
export interface BunWebSocketData {
  events: WSEvents
  url: URL
  protocol: string
}

/**
 * @internal
 */
export const createWSContext = (ws: BunServerWebSocket<BunWebSocketData>): WSContext => {
  return new WSContext({
    send: (source, options) => {
      ws.send(source, options?.compress)
    },
    raw: ws,
    readyState: ws.readyState,
    url: ws.data.url,
    protocol: ws.data.protocol,
    close(code, reason) {
      ws.close(code, reason)
    },
  })
}

export const createBunWebSocket = <T>(): CreateWebSocket<T> => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const upgradeWebSocket: UpgradeWebSocket<any> = defineWebSocketHelper((c, events) => {
    const server = getBunServer(c)
    if (!server) {
      throw new TypeError('env has to include the 2nd argument of fetch.')
    }
    const upgradeResult = server.upgrade<BunWebSocketData>(c.req.raw, {
      data: {
        events,
        url: new URL(c.req.url),
        protocol: c.req.url,
      },
    })
    if (upgradeResult) {
      return new Response(null)
    }
    return // failed
  })
  const websocket: BunWebSocketHandler<BunWebSocketData> = {
    open(ws) {
      const websocketListeners = ws.data.events
      if (websocketListeners.onOpen) {
        websocketListeners.onOpen(new Event('open'), createWSContext(ws))
      }
    },
    close(ws, code, reason) {
      const websocketListeners = ws.data.events
      if (websocketListeners.onClose) {
        websocketListeners.onClose(
          new CloseEvent('close', {
            code,
            reason,
          }),
          createWSContext(ws)
        )
      }
    },
    message(ws, message) {
      const websocketListeners = ws.data.events
      if (websocketListeners.onMessage) {
        const normalizedReceiveData =
          typeof message === 'string' ? message : (message.buffer satisfies WSMessageReceive)

        websocketListeners.onMessage(
          createWSMessageEvent(normalizedReceiveData),
          createWSContext(ws)
        )
      }
    },
  }
  return {
    upgradeWebSocket,
    websocket,
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/netlify/handler.ts
```typescript
/* eslint-disable @typescript-eslint/no-explicit-any */
import type { Hono } from '../../hono'

export const handle = (
  app: Hono<any, any>
): ((req: Request, context: any) => Response | Promise<Response>) => {
  return (req: Request, context: any) => {
    return app.fetch(req, { context })
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/netlify/index.ts
```typescript
/**
 * @module
 * Netlify Adapter for Hono.
 */

export * from './mod'

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/netlify/mod.ts
```typescript
export { handle } from './handler'

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/cloudflare-workers/conninfo.test.ts
```typescript
import { Context } from '../../context'
import { getConnInfo } from './conninfo'

describe('getConnInfo', () => {
  it('Should getConnInfo works', () => {
    const address = Math.random().toString()
    const req = new Request('http://localhost/', {
      headers: {
        'cf-connecting-ip': address,
      },
    })
    const c = new Context(req)

    const info = getConnInfo(c)

    expect(info.remote.address).toBe(address)
    expect(info.remote.addressType).toBeUndefined()
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/cloudflare-workers/conninfo.ts
```typescript
import type { GetConnInfo } from '../../helper/conninfo'

export const getConnInfo: GetConnInfo = (c) => ({
  remote: {
    address: c.req.header('cf-connecting-ip'),
  },
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/cloudflare-workers/index.ts
```typescript
/**
 * @module
 * Cloudflare Workers Adapter for Hono.
 */

export { serveStatic } from './serve-static-module'
export { upgradeWebSocket } from './websocket'
export { getConnInfo } from './conninfo'

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/cloudflare-workers/serve-static-module.ts
```typescript
// For ES module mode
import type { Env, MiddlewareHandler } from '../../types'
import type { ServeStaticOptions } from './serve-static'
import { serveStatic } from './serve-static'

const module = <E extends Env = Env>(
  options: Omit<ServeStaticOptions<E>, 'namespace'>
): MiddlewareHandler => {
  return serveStatic<E>(options)
}

export { module as serveStatic }

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/cloudflare-workers/serve-static.test.ts
```typescript
import type { Context } from '../../context'
import { Hono } from '../../hono'
import type { Next } from '../../types'
import { serveStatic } from './serve-static'

// Mock
const store: Record<string, string> = {
  'assets/static/plain.abcdef.txt': 'This is plain.txt',
  'assets/static/hono.abcdef.html': '<h1>Hono!</h1>',
  'assets/static/top/index.abcdef.html': '<h1>Top</h1>',
  'static-no-root/plain.abcdef.txt': 'That is plain.txt',
  'assets/static/options/foo.abcdef.txt': 'With options',
  'assets/.static/plain.abcdef.txt': 'In the dot',
  'assets/static/video/morning-routine.abcdef.m3u8': 'Good morning',
  'assets/static/video/morning-routine1.abcdef.ts': 'Good',
  'assets/static/video/introduction.abcdef.mp4': 'Let me introduce myself',
  'assets/static/download': 'download',
}
const manifest = JSON.stringify({
  'assets/static/plain.txt': 'assets/static/plain.abcdef.txt',
  'assets/static/hono.html': 'assets/static/hono.abcdef.html',
  'assets/static/top/index.html': 'assets/static/top/index.abcdef.html',
  'static-no-root/plain.txt': 'static-no-root/plain.abcdef.txt',
  'assets/.static/plain.txt': 'assets/.static/plain.abcdef.txt',
  'assets/static/download': 'assets/static/download',
})

Object.assign(global, { __STATIC_CONTENT_MANIFEST: manifest })
Object.assign(global, {
  __STATIC_CONTENT: {
    get: (path: string) => {
      return store[path]
    },
  },
})

describe('ServeStatic Middleware', () => {
  const app = new Hono()
  const onNotFound = vi.fn(() => {})
  app.use('/static/*', serveStatic({ root: './assets', onNotFound, manifest }))
  app.use('/static-no-root/*', serveStatic({ manifest }))
  app.use(
    '/dot-static/*',
    serveStatic({
      root: './assets',
      rewriteRequestPath: (path) => path.replace(/^\/dot-static/, '/.static'),
      manifest,
    })
  )

  beforeEach(() => onNotFound.mockClear())

  it('Should return plain.txt', async () => {
    const res = await app.request('http://localhost/static/plain.txt')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('This is plain.txt')
    expect(res.headers.get('Content-Type')).toBe('text/plain; charset=utf-8')
    expect(onNotFound).not.toHaveBeenCalled()
  })

  it('Should return hono.html', async () => {
    const res = await app.request('http://localhost/static/hono.html')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('<h1>Hono!</h1>')
    expect(res.headers.get('Content-Type')).toBe('text/html; charset=utf-8')
    expect(onNotFound).not.toHaveBeenCalled()
  })

  it('Should return 404 response', async () => {
    const res = await app.request('http://localhost/static/not-found.html')
    expect(res.status).toBe(404)
    expect(onNotFound).toHaveBeenCalledWith('assets/static/not-found.html', expect.anything())
  })

  it('Should return plan.txt', async () => {
    const res = await app.request('http://localhost/static-no-root/plain.txt')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('That is plain.txt')
    expect(res.headers.get('Content-Type')).toBe('text/plain; charset=utf-8')
  })

  it('Should return index.html', async () => {
    const res = await app.request('http://localhost/static/top')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('<h1>Top</h1>')
    expect(res.headers.get('Content-Type')).toBe('text/html; charset=utf-8')
  })

  it('Should return plain.txt with a rewriteRequestPath option', async () => {
    const res = await app.request('http://localhost/dot-static/plain.txt')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('In the dot')
    expect(res.headers.get('Content-Type')).toBe('text/plain; charset=utf-8')
  })
})

describe('With options', () => {
  const manifest = {
    'assets/static/options/foo.txt': 'assets/static/options/foo.abcdef.txt',
  }

  const app = new Hono()
  app.use('/static/*', serveStatic({ root: './assets', manifest: manifest }))

  it('Should return foo.txt', async () => {
    const res = await app.request('http://localhost/static/options/foo.txt')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('With options')
    expect(res.headers.get('Content-Type')).toBe('text/plain; charset=utf-8')
  })
})

describe('With `file` options', () => {
  const app = new Hono()
  app.get('/foo/*', serveStatic({ path: './assets/static/hono.html', manifest }))
  app.get('/bar/*', serveStatic({ path: './static/hono.html', root: './assets', manifest }))

  it('Should return hono.html', async () => {
    const res = await app.request('http://localhost/foo/fallback')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('<h1>Hono!</h1>')
  })

  it('Should return hono.html - with `root` option', async () => {
    const res = await app.request('http://localhost/bar/fallback')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('<h1>Hono!</h1>')
  })
})

describe('With `mimes` options', () => {
  const mimes = {
    m3u8: 'application/vnd.apple.mpegurl',
    ts: 'video/mp2t',
  }
  const manifest = {
    'assets/static/video/morning-routine.m3u8': 'assets/static/video/morning-routine.abcdef.m3u8',
    'assets/static/video/morning-routine1.ts': 'assets/static/video/morning-routine1.abcdef.ts',
    'assets/static/video/introduction.mp4': 'assets/static/video/introduction.abcdef.mp4',
  }

  const app = new Hono()
  app.use('/static/*', serveStatic({ root: './assets', mimes, manifest }))

  it('Should return content-type of m3u8', async () => {
    const res = await app.request('http://localhost/static/video/morning-routine.m3u8')
    expect(res.status).toBe(200)
    expect(res.headers.get('Content-Type')).toBe('application/vnd.apple.mpegurl')
  })
  it('Should return content-type of ts', async () => {
    const res = await app.request('http://localhost/static/video/morning-routine1.ts')
    expect(res.status).toBe(200)
    expect(res.headers.get('Content-Type')).toBe('video/mp2t')
  })
  it('Should return content-type of default on Hono', async () => {
    const res = await app.request('http://localhost/static/video/introduction.mp4')
    expect(res.status).toBe(200)
    expect(res.headers.get('Content-Type')).toBe('video/mp4')
  })
})

describe('With middleware', () => {
  const app = new Hono()
  const md1 = async (c: Context, next: Next) => {
    await next()
    c.res.headers.append('x-foo', 'bar')
  }
  const md2 = async (c: Context, next: Next) => {
    await next()
    c.res.headers.append('x-foo2', 'bar2')
  }

  app.use('/static/*', md1)
  app.use('/static/*', md2)
  app.use('/static/*', serveStatic({ root: './assets', manifest }))
  app.get('/static/foo', (c) => {
    return c.text('bar')
  })

  it('Should return plain.txt with correct headers', async () => {
    const res = await app.request('http://localhost/static/plain.txt')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('This is plain.txt')
    expect(res.headers.get('Content-Type')).toBe('text/plain; charset=utf-8')
    expect(res.headers.get('x-foo')).toBe('bar')
    expect(res.headers.get('x-foo2')).toBe('bar2')
  })

  it('Should return 200 Response', async () => {
    const res = await app.request('http://localhost/static/foo')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('bar')
  })

  it('Should handle a file without an extension', async () => {
    const res = await app.request('http://localhost/static/download')
    expect(res.status).toBe(200)
  })
})

describe('Types of middleware', () => {
  it('Should pass env type from generics of serveStatic', async () => {
    type Env = {
      Bindings: {
        HOGE: string
      }
    }
    const app = new Hono<Env>()
    app.use(
      '/static/*',
      serveStatic<Env>({
        root: './assets',
        onNotFound: (_, c) => {
          expectTypeOf(c.env).toEqualTypeOf<Env['Bindings']>()
        },
        manifest,
      })
    )
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/cloudflare-workers/serve-static.ts
```typescript
import { serveStatic as baseServeStatic } from '../../middleware/serve-static'
import type { ServeStaticOptions as BaseServeStaticOptions } from '../../middleware/serve-static'
import type { Env, MiddlewareHandler } from '../../types'
import { getContentFromKVAsset } from './utils'

export type ServeStaticOptions<E extends Env = Env> = BaseServeStaticOptions<E> & {
  // namespace is KVNamespace
  namespace?: unknown
  manifest: object | string
}

/**
 * @deprecated
 * `serveStatic` in the Cloudflare Workers adapter is deprecated.
 * You can serve static files directly using Cloudflare Static Assets.
 * @see https://developers.cloudflare.com/workers/static-assets/
 * Cloudflare Static Assets is currently in open beta. If this doesn't work for you,
 * please consider using Cloudflare Pages. You can start to create the Cloudflare Pages
 * application with the `npm create hono@latest` command.
 */
export const serveStatic = <E extends Env = Env>(
  options: ServeStaticOptions<E>
): MiddlewareHandler => {
  return async function serveStatic(c, next) {
    const getContent = async (path: string) => {
      return getContentFromKVAsset(path, {
        manifest: options.manifest,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        namespace: options.namespace
          ? options.namespace
          : c.env
          ? c.env.__STATIC_CONTENT
          : undefined,
      })
    }
    return baseServeStatic({
      ...options,
      getContent,
    })(c, next)
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/cloudflare-workers/utils.test.ts
```typescript
import { getContentFromKVAsset } from './utils'

// Mock
const store: { [key: string]: string } = {
  'index.abcdef.html': 'This is index',
  'assets/static/plain.abcdef.txt': 'Asset text',
}
const manifest = JSON.stringify({
  'index.html': 'index.abcdef.html',
  'assets/static/plain.txt': 'assets/static/plain.abcdef.txt',
})

Object.assign(global, { __STATIC_CONTENT_MANIFEST: manifest })
Object.assign(global, {
  __STATIC_CONTENT: {
    get: (path: string) => {
      return store[path]
    },
  },
})

describe('Utils for Cloudflare Workers', () => {
  it('getContentFromKVAsset', async () => {
    let content = await getContentFromKVAsset('not-found.txt')
    expect(content).toBeFalsy()
    content = await getContentFromKVAsset('index.html')
    expect(content).toBeTruthy()
    expect(content).toBe('This is index')
    content = await getContentFromKVAsset('assets/static/plain.txt')
    expect(content).toBeTruthy()
    expect(content).toBe('Asset text')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/cloudflare-workers/utils.ts
```typescript
// __STATIC_CONTENT is KVNamespace
declare const __STATIC_CONTENT: unknown
declare const __STATIC_CONTENT_MANIFEST: string

export type KVAssetOptions = {
  manifest?: object | string
  // namespace is KVNamespace
  namespace?: unknown
}

export const getContentFromKVAsset = async (
  path: string,
  options?: KVAssetOptions
): Promise<ReadableStream | null> => {
  let ASSET_MANIFEST: Record<string, string>

  if (options && options.manifest) {
    if (typeof options.manifest === 'string') {
      ASSET_MANIFEST = JSON.parse(options.manifest)
    } else {
      ASSET_MANIFEST = options.manifest as Record<string, string>
    }
  } else {
    if (typeof __STATIC_CONTENT_MANIFEST === 'string') {
      ASSET_MANIFEST = JSON.parse(__STATIC_CONTENT_MANIFEST)
    } else {
      ASSET_MANIFEST = __STATIC_CONTENT_MANIFEST
    }
  }

  // ASSET_NAMESPACE is KVNamespace
  let ASSET_NAMESPACE: unknown
  if (options && options.namespace) {
    ASSET_NAMESPACE = options.namespace
  } else {
    ASSET_NAMESPACE = __STATIC_CONTENT
  }

  const key = ASSET_MANIFEST[path] || path
  if (!key) {
    return null
  }

  // @ts-expect-error ASSET_NAMESPACE is not typed
  const content = await ASSET_NAMESPACE.get(key, { type: 'stream' })
  if (!content) {
    return null
  }
  return content as unknown as ReadableStream
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/cloudflare-workers/websocket.test.ts
```typescript
import { Hono } from '../..'
import { Context } from '../../context'
import { upgradeWebSocket } from '.'

describe('upgradeWebSocket middleware', () => {
  const server = new EventTarget()

  // @ts-expect-error Cloudflare API
  globalThis.WebSocketPair = class {
    0: WebSocket // client
    1: WebSocket // server
    constructor() {
      this[0] = {} as WebSocket
      this[1] = server as WebSocket
    }
  }

  const app = new Hono()

  const wsPromise = new Promise((resolve) =>
    app.get(
      '/ws',
      upgradeWebSocket(() => ({
        onMessage(evt, ws) {
          resolve([evt.data, ws.readyState || 1])
        },
      }))
    )
  )
  it('Should receive message and readyState is valid', async () => {
    const sendingData = Math.random().toString()
    await app.request('/ws', {
      headers: {
        Upgrade: 'websocket',
      },
    })
    server.dispatchEvent(
      new MessageEvent('message', {
        data: sendingData,
      })
    )

    expect([sendingData, 1]).toStrictEqual(await wsPromise)
  })
  it('Should call next() when header does not have upgrade', async () => {
    const next = vi.fn()
    await upgradeWebSocket(() => ({}))(
      new Context(
        new Request('http://localhost', {
          headers: {
            Upgrade: 'example',
          },
        })
      ),
      next
    )
    expect(next).toBeCalled()
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/cloudflare-workers/websocket.ts
```typescript
import { WSContext, defineWebSocketHelper } from '../../helper/websocket'
import type { UpgradeWebSocket, WSEvents, WSReadyState } from '../../helper/websocket'

// Based on https://github.com/honojs/hono/issues/1153#issuecomment-1767321332
export const upgradeWebSocket: UpgradeWebSocket<
  WebSocket,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  any,
  Omit<WSEvents<WebSocket>, 'onOpen'>
> = defineWebSocketHelper(async (c, events) => {
  const upgradeHeader = c.req.header('Upgrade')
  if (upgradeHeader !== 'websocket') {
    return
  }

  // @ts-expect-error WebSocketPair is not typed
  const webSocketPair = new WebSocketPair()
  const client: WebSocket = webSocketPair[0]
  const server: WebSocket = webSocketPair[1]

  const wsContext = new WSContext<WebSocket>({
    close: (code, reason) => server.close(code, reason),
    get protocol() {
      return server.protocol
    },
    raw: server,
    get readyState() {
      return server.readyState as WSReadyState
    },
    url: server.url ? new URL(server.url) : null,
    send: (source) => server.send(source),
  })

  // note: cloudflare workers doesn't support 'open' event

  if (events.onClose) {
    server.addEventListener('close', (evt: CloseEvent) => events.onClose?.(evt, wsContext))
  }
  if (events.onMessage) {
    server.addEventListener('message', (evt: MessageEvent) => events.onMessage?.(evt, wsContext))
  }
  if (events.onError) {
    server.addEventListener('error', (evt: Event) => events.onError?.(evt, wsContext))
  }

  // @ts-expect-error - server.accept is not typed
  server.accept?.()
  return new Response(null, {
    status: 101,
    // @ts-expect-error - webSocket is not typed
    webSocket: client,
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/service-worker/handler.test.ts
```typescript
import { Hono } from '../../hono'
import { handle } from './handler'
import type { FetchEvent } from './types'

beforeAll(() => {
  // fetch errors when it's not bound to globalThis in service worker
  // set a fetch stub to emulate that behavior
  vi.stubGlobal(
    'fetch',
    function fetch(this: undefined | typeof globalThis, arg0: string | Request) {
      if (this !== globalThis) {
        const error = new Error(
          "Failed to execute 'fetch' on 'WorkerGlobalScope': Illegal invocation"
        )
        error.name = 'TypeError'
        throw error
      }
      if (arg0 instanceof Request && arg0.url === 'http://localhost/fallback') {
        return new Response('hello world')
      }
      return Response.error()
    }
  )
})
afterAll(() => {
  vi.unstubAllGlobals()
})

describe('handle', () => {
  it('Success to fetch', async () => {
    const app = new Hono()
    app.get('/', (c) => {
      return c.json({ hello: 'world' })
    })
    const handler = handle(app)
    const json = await new Promise<Response>((resolve) => {
      handler({
        request: new Request('http://localhost/'),
        respondWith(res) {
          resolve(res)
        },
      } as FetchEvent)
    }).then((res) => res.json())
    expect(json).toStrictEqual({ hello: 'world' })
  })
  it('Fallback 404', async () => {
    const app = new Hono()
    const handler = handle(app)
    const text = await new Promise<Response>((resolve) => {
      handler({
        request: new Request('http://localhost/fallback'),
        respondWith(res) {
          resolve(res)
        },
      } as FetchEvent)
    }).then((res) => res.text())
    expect(text).toBe('hello world')
  })
  it('Fallback 404 with explicit fetch', async () => {
    const app = new Hono()
    const handler = handle(app, {
      async fetch() {
        return new Response('hello world')
      },
    })
    const text = await new Promise<Response>((resolve) => {
      handler({
        request: new Request('http://localhost/'),
        respondWith(res) {
          resolve(res)
        },
      } as FetchEvent)
    }).then((res) => res.text())
    expect(text).toBe('hello world')
  })
  it('Do not fallback 404 when fetch is undefined', async () => {
    const app = new Hono()
    app.get('/', (c) => c.text('Not found', 404))
    const handler = handle(app, {
      fetch: undefined,
    })
    const result = await new Promise<Response>((resolve) =>
      handler({
        request: new Request('https://localhost/'),
        respondWith(r) {
          resolve(r)
        },
      } as FetchEvent)
    )

    expect(result.status).toBe(404)
    expect(await result.text()).toBe('Not found')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/service-worker/handler.ts
```typescript
/**
 * Handler for Service Worker
 * @module
 */

import type { Hono } from '../../hono'
import type { FetchEvent } from './types'

type Handler = (evt: FetchEvent) => void

/**
 * Adapter for Service Worker
 */
export const handle = (
  app: Hono,
  opts: {
    fetch?: typeof fetch
  } = {
    // To use `fetch` on a Service Worker correctly, bind it to `globalThis`.
    fetch: globalThis.fetch.bind(globalThis),
  }
): Handler => {
  return (evt) => {
    evt.respondWith(
      (async () => {
        const res = await app.fetch(evt.request)
        if (opts.fetch && res.status === 404) {
          return await opts.fetch(evt.request)
        }
        return res
      })()
    )
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/service-worker/index.ts
```typescript
/**
 * Service Worker Adapter for Hono.
 * @module
 */
export { handle } from './handler'

```
/Users/josh/Documents/GitHub/honojs/hono/src/adapter/service-worker/types.ts
```typescript
interface ExtendableEvent extends Event {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  waitUntil(f: Promise<any>): void
}

export interface FetchEvent extends ExtendableEvent {
  readonly clientId: string
  readonly handled: Promise<undefined>
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  readonly preloadResponse: Promise<any>
  readonly request: Request
  readonly resultingClientId: string
  respondWith(r: Response | PromiseLike<Response>): void
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/websocket/index.test.ts
```typescript
import { Context } from '../../context'
import type { WSContextInit } from '.'
import { WSContext, createWSMessageEvent, defineWebSocketHelper } from '.'

describe('`createWSMessageEvent`', () => {
  it('Should `createWSMessageEvent` is working for string', () => {
    const randomString = Math.random().toString()
    const event = createWSMessageEvent(randomString)

    expect(event.data).toBe(randomString)
  })
  it('Should `createWSMessageEvent` type is `message`', () => {
    const event = createWSMessageEvent('')
    expect(event.type).toBe('message')
  })
})
describe('defineWebSocketHelper', () => {
  it('defineWebSocketHelper should work', async () => {
    const upgradeWebSocket = defineWebSocketHelper(() => {
      return new Response('Hello World', {
        status: 200,
      })
    })
    const response = await upgradeWebSocket(() => ({}))(
      new Context(new Request('http://localhost')),
      () => Promise.resolve()
    )
    expect(response).toBeTruthy()
    expect((response as Response).status).toBe(200)
  })
  it('When response is undefined, should call next()', async () => {
    const upgradeWebSocket = defineWebSocketHelper(() => {
      return
    })
    const next = vi.fn()
    await upgradeWebSocket(() => ({}))(new Context(new Request('http://localhost')), next)
    expect(next).toBeCalled()
  })
})
describe('WSContext', () => {
  it('Should close() works', async () => {
    type Result = [number | undefined, string | undefined]
    let ws!: WSContext
    const promise = new Promise<Result>((resolve) => {
      ws = new WSContext({
        close(code, reason) {
          resolve([code, reason])
        },
      } as WSContextInit)
    })
    ws.close(0, 'reason')
    const [code, reason] = await promise
    expect(code).toBe(0)
    expect(reason).toBe('reason')
  })
  it('Should send() works', async () => {
    let ws!: WSContext
    const promise = new Promise<string | ArrayBuffer>((resolve) => {
      ws = new WSContext({
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        send(data, _options) {
          resolve(data)
        },
      } as WSContextInit)
    })
    ws.send('Hello')
    expect(await promise).toBe('Hello')
  })
  it('Should readyState works', () => {
    const ws = new WSContext({
      readyState: 0,
    } as WSContextInit)
    expect(ws.readyState).toBe(0)
  })
  it('Should normalize URL', () => {
    const stringURLWS = new WSContext({
      url: 'http://localhost',
    } as WSContextInit)
    expect(stringURLWS.url).toBeInstanceOf(URL)

    const urlURLWS = new WSContext({
      url: new URL('http://localhost'),
    } as WSContextInit)
    expect(urlURLWS.url).toBeInstanceOf(URL)

    const nullURLWS = new WSContext({
      url: undefined,
    } as WSContextInit)
    expect(nullURLWS.url).toBeNull()
  })
  it('Should normalize message in send()', () => {
    let data: string | ArrayBuffer | Uint8Array | null = null
    const wsContext = new WSContext({
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      send(received, _options) {
        data = received
      },
    } as WSContextInit)

    wsContext.send('string')
    expect(data).toBe('string')

    wsContext.send(new ArrayBuffer(16))
    expect(data).toBeInstanceOf(ArrayBuffer)

    wsContext.send(new Uint8Array(16))
    expect(data).toBeInstanceOf(Uint8Array)
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/websocket/index.ts
```typescript
/**
 * @module
 * WebSocket Helper for Hono.
 */

/* eslint-disable @typescript-eslint/no-explicit-any */
import type { Context } from '../../context'
import type { MiddlewareHandler } from '../../types'

/**
 * WebSocket Event Listeners type
 */
export interface WSEvents<T = unknown> {
  onOpen?: (evt: Event, ws: WSContext<T>) => void
  onMessage?: (evt: MessageEvent<WSMessageReceive>, ws: WSContext<T>) => void
  onClose?: (evt: CloseEvent, ws: WSContext<T>) => void
  onError?: (evt: Event, ws: WSContext<T>) => void
}

/**
 * Upgrade WebSocket Type
 */
export type UpgradeWebSocket<T = unknown, U = any, _WSEvents = WSEvents<T>> = (
  createEvents: (c: Context) => _WSEvents | Promise<_WSEvents>,
  options?: U
) => MiddlewareHandler<
  any,
  string,
  {
    outputFormat: 'ws'
  }
>

/**
 * ReadyState for WebSocket
 */
export type WSReadyState = 0 | 1 | 2 | 3

/**
 * An argument for WSContext class
 */
export interface WSContextInit<T = unknown> {
  send(data: string | ArrayBuffer | Uint8Array, options: SendOptions): void
  close(code?: number, reason?: string): void

  raw?: T
  readyState: WSReadyState
  url?: string | URL | null
  protocol?: string | null
}

/**
 * Options for sending message
 */
export interface SendOptions {
  compress?: boolean
}

/**
 * A context for controlling WebSockets
 */
export class WSContext<T = unknown> {
  #init: WSContextInit<T>
  constructor(init: WSContextInit<T>) {
    this.#init = init
    this.raw = init.raw
    this.url = init.url ? new URL(init.url) : null
    this.protocol = init.protocol ?? null
  }
  send(source: string | ArrayBuffer | Uint8Array, options?: SendOptions): void {
    this.#init.send(source, options ?? {})
  }
  raw?: T
  binaryType: BinaryType = 'arraybuffer'
  get readyState(): WSReadyState {
    return this.#init.readyState
  }
  url: URL | null
  protocol: string | null
  close(code?: number, reason?: string) {
    this.#init.close(code, reason)
  }
}

export type WSMessageReceive = string | Blob | ArrayBufferLike

export const createWSMessageEvent = (source: WSMessageReceive): MessageEvent<WSMessageReceive> => {
  return new MessageEvent<WSMessageReceive>('message', {
    data: source,
  })
}

export interface WebSocketHelperDefineContext {}
export type WebSocketHelperDefineHandler<T, U> = (
  c: Context,
  events: WSEvents<T>,
  options?: U
) => Promise<Response | void> | Response | void

/**
 * Create a WebSocket adapter/helper
 */
export const defineWebSocketHelper = <T = unknown, U = any>(
  handler: WebSocketHelperDefineHandler<T, U>
): UpgradeWebSocket<T, U> => {
  return (createEvents, options) => {
    return async function UpgradeWebSocket(c, next) {
      const events = await createEvents(c)
      const result = await handler(c, events, options)
      if (result) {
        return result
      }
      await next()
    }
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/proxy/index.test.ts
```typescript
import { Hono } from '../../hono'
import { proxy } from '.'

describe('Proxy Middleware', () => {
  describe('proxy', () => {
    beforeEach(() => {
      global.fetch = vi.fn().mockImplementation(async (req) => {
        if (req.url === 'https://example.com/ok') {
          return Promise.resolve(new Response('ok'))
        } else if (req.url === 'https://example.com/disconnect') {
          const reader = req.body.getReader()
          let response

          req.signal.addEventListener('abort', () => {
            response = req.signal.reason
            reader.cancel()
          })

          await reader.read()

          return Promise.resolve(new Response(response))
        } else if (req.url === 'https://example.com/compressed') {
          return Promise.resolve(
            new Response('ok', {
              headers: {
                'Content-Encoding': 'gzip',
                'Content-Length': '1',
                'Content-Range': 'bytes 0-2/1024',
                'X-Response-Id': '456',
              },
            })
          )
        } else if (req.url === 'https://example.com/uncompressed') {
          return Promise.resolve(
            new Response('ok', {
              headers: {
                'Content-Length': '2',
                'Content-Range': 'bytes 0-2/1024',
                'X-Response-Id': '456',
              },
            })
          )
        } else if (req.url === 'https://example.com/post' && req.method === 'POST') {
          return Promise.resolve(new Response(`request body: ${await req.text()}`))
        } else if (req.url === 'https://example.com/hop-by-hop') {
          return Promise.resolve(
            new Response('ok', {
              headers: {
                'Transfer-Encoding': 'chunked',
              },
            })
          )
        } else if (req.url === 'https://example.com/set-cookie') {
          return Promise.resolve(
            new Response('ok', {
              headers: {
                'Set-Cookie': 'test=123',
              },
            })
          )
        }
        return Promise.resolve(new Response('not found', { status: 404 }))
      })
    })

    it('compressed', async () => {
      const app = new Hono()
      app.get('/proxy/:path', (c) =>
        proxy(
          new Request(`https://example.com/${c.req.param('path')}`, {
            headers: {
              'X-Request-Id': '123',
              'Accept-Encoding': 'gzip',
            },
          })
        )
      )
      const res = await app.request('/proxy/compressed')
      const req = (global.fetch as ReturnType<typeof vi.fn>).mock.calls[0][0]

      expect(req.url).toBe('https://example.com/compressed')
      expect(req.headers.get('X-Request-Id')).toBe('123')
      expect(req.headers.get('Accept-Encoding')).toBeNull()

      expect(res.status).toBe(200)
      expect(res.headers.get('X-Response-Id')).toBe('456')
      expect(res.headers.get('Content-Encoding')).toBeNull()
      expect(res.headers.get('Content-Length')).toBeNull()
      expect(res.headers.get('Content-Range')).toBe('bytes 0-2/1024')
    })

    it('uncompressed', async () => {
      const app = new Hono()
      app.get('/proxy/:path', (c) =>
        proxy(
          new Request(`https://example.com/${c.req.param('path')}`, {
            headers: {
              'X-Request-Id': '123',
              'Accept-Encoding': 'gzip',
            },
          })
        )
      )
      const res = await app.request('/proxy/uncompressed')
      const req = (global.fetch as ReturnType<typeof vi.fn>).mock.calls[0][0]

      expect(req.url).toBe('https://example.com/uncompressed')
      expect(req.headers.get('X-Request-Id')).toBe('123')
      expect(req.headers.get('Accept-Encoding')).toBeNull()

      expect(res.status).toBe(200)
      expect(res.headers.get('X-Response-Id')).toBe('456')
      expect(res.headers.get('Content-Length')).toBe('2')
      expect(res.headers.get('Content-Range')).toBe('bytes 0-2/1024')
    })

    it('POST request', async () => {
      const app = new Hono()
      app.all('/proxy/:path', (c) => {
        return proxy(`https://example.com/${c.req.param('path')}`, {
          ...c.req,
          headers: {
            ...c.req.header(),
            'X-Request-Id': '123',
            'Accept-Encoding': 'gzip',
          },
        })
      })
      const res = await app.request('/proxy/post', {
        method: 'POST',
        body: 'test',
      })
      const req = (global.fetch as ReturnType<typeof vi.fn>).mock.calls[0][0]

      expect(req.url).toBe('https://example.com/post')

      expect(res.status).toBe(200)
      expect(await res.text()).toBe('request body: test')
    })

    it('remove hop-by-hop headers', async () => {
      const app = new Hono()
      app.get('/proxy/:path', (c) => proxy(`https://example.com/${c.req.param('path')}`))

      const res = await app.request('/proxy/hop-by-hop', {
        headers: {
          Connection: 'keep-alive',
          'Keep-Alive': 'timeout=5, max=1000',
          'Proxy-Authorization': 'Basic 123456',
        },
      })
      const req = (global.fetch as ReturnType<typeof vi.fn>).mock.calls[0][0]

      expect(req.headers.get('Connection')).toBeNull()
      expect(req.headers.get('Keep-Alive')).toBeNull()
      expect(req.headers.get('Proxy-Authorization')).toBeNull()

      expect(res.headers.get('Transfer-Encoding')).toBeNull()
    })

    it('specify hop-by-hop header by options', async () => {
      const app = new Hono()
      app.get('/proxy/:path', (c) =>
        proxy(`https://example.com/${c.req.param('path')}`, {
          headers: {
            'Proxy-Authorization': 'Basic 123456',
          },
        })
      )

      const res = await app.request('/proxy/hop-by-hop')
      const req = (global.fetch as ReturnType<typeof vi.fn>).mock.calls[0][0]

      expect(req.headers.get('Proxy-Authorization')).toBe('Basic 123456')

      expect(res.headers.get('Transfer-Encoding')).toBeNull()
    })

    it('modify header', async () => {
      const app = new Hono()
      app.get('/proxy/:path', (c) =>
        proxy(`https://example.com/${c.req.param('path')}`, {
          headers: {
            'Set-Cookie': 'test=123',
          },
        }).then((res) => {
          res.headers.delete('Set-Cookie')
          res.headers.set('X-Response-Id', '456')
          return res
        })
      )
      const res = await app.request('/proxy/set-cookie')
      expect(res.headers.get('Set-Cookie')).toBeNull()
      expect(res.headers.get('X-Response-Id')).toBe('456')
    })

    it('does not propagate undefined request headers', async () => {
      const app = new Hono()
      app.get('/proxy/:path', (c) =>
        proxy(`https://example.com/${c.req.param('path')}`, {
          headers: {
            ...c.req.header(),
            Authorization: undefined,
          },
        })
      )
      await app.request('/proxy/ok', {
        headers: {
          Authorization: 'Bearer 123',
        },
      })
      const req = (global.fetch as ReturnType<typeof vi.fn>).mock.calls[0][0]
      expect(req.headers.get('Authorization')).toBeNull()
    })

    it('client disconnect', async () => {
      const app = new Hono()
      const controller = new AbortController()
      app.post('/proxy/:path', (c) => proxy(`https://example.com/${c.req.param('path')}`, c.req))
      const resPromise = app.request('/proxy/disconnect', {
        method: 'POST',
        body: 'test',
        signal: controller.signal,
      })
      controller.abort('client disconnect')
      const res = await resPromise
      expect(await res.text()).toBe('client disconnect')
    })

    it('not found', async () => {
      const app = new Hono()
      app.get('/proxy/:path', (c) => proxy(`https://example.com/${c.req.param('path')}`))
      const res = await app.request('/proxy/404')
      expect(res.status).toBe(404)
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/proxy/index.ts
````typescript
/**
 * @module
 * Proxy Helper for Hono.
 */

import type { RequestHeader } from '../../utils/headers'

// https://datatracker.ietf.org/doc/html/rfc2616#section-13.5.1
const hopByHopHeaders = [
  'connection',
  'keep-alive',
  'proxy-authenticate',
  'proxy-authorization',
  'te',
  'trailers',
  'transfer-encoding',
]

interface ProxyRequestInit extends Omit<RequestInit, 'headers'> {
  raw?: Request
  headers?:
    | HeadersInit
    | [string, string][]
    | Record<RequestHeader, string | undefined>
    | Record<string, string | undefined>
}

interface ProxyFetch {
  (input: string | URL | Request, init?: ProxyRequestInit): Promise<Response>
}

const buildRequestInitFromRequest = (
  request: Request | undefined
): RequestInit & { duplex?: 'half' } => {
  if (!request) {
    return {}
  }

  const headers = new Headers(request.headers)
  hopByHopHeaders.forEach((header) => {
    headers.delete(header)
  })

  return {
    method: request.method,
    body: request.body,
    duplex: request.body ? 'half' : undefined,
    headers,
    signal: request.signal,
  }
}

const preprocessRequestInit = (requestInit: RequestInit): RequestInit => {
  if (
    !requestInit.headers ||
    Array.isArray(requestInit.headers) ||
    requestInit.headers instanceof Headers
  ) {
    return requestInit
  }

  const headers = new Headers()
  for (const [key, value] of Object.entries(requestInit.headers)) {
    if (value == null) {
      // delete header if value is null or undefined
      headers.delete(key)
    } else {
      headers.set(key, value)
    }
  }
  requestInit.headers = headers
  return requestInit
}

/**
 * Fetch API wrapper for proxy.
 * The parameters and return value are the same as for `fetch` (except for the proxy-specific options).
 *
 * The “Accept-Encoding” header is replaced with an encoding that the current runtime can handle.
 * Unnecessary response headers are deleted and a Response object is returned that can be returned
 * as is as a response from the handler.
 *
 * @example
 * ```ts
 * app.get('/proxy/:path', (c) => {
 *   return proxy(`http://${originServer}/${c.req.param('path')}`, {
 *     headers: {
 *       ...c.req.header(), // optional, specify only when forwarding all the request data (including credentials) is necessary.
 *       'X-Forwarded-For': '127.0.0.1',
 *       'X-Forwarded-Host': c.req.header('host'),
 *       Authorization: undefined, // do not propagate request headers contained in c.req.header('Authorization')
 *     },
 *   }).then((res) => {
 *     res.headers.delete('Set-Cookie')
 *     return res
 *   })
 * })
 *
 * app.all('/proxy/:path', (c) => {
 *   return proxy(`http://${originServer}/${c.req.param('path')}`, {
 *     ...c.req, // optional, specify only when forwarding all the request data (including credentials) is necessary.
 *     headers: {
 *       ...c.req.header(),
 *       'X-Forwarded-For': '127.0.0.1',
 *       'X-Forwarded-Host': c.req.header('host'),
 *       Authorization: undefined, // do not propagate request headers contained in c.req.header('Authorization')
 *     },
 *   })
 * })
 * ```
 */
export const proxy: ProxyFetch = async (input, proxyInit) => {
  const { raw, ...requestInit } = proxyInit ?? {}

  const req = new Request(input, {
    ...buildRequestInitFromRequest(raw),
    ...preprocessRequestInit(requestInit as RequestInit),
  })
  req.headers.delete('accept-encoding')

  const res = await fetch(req)
  const resHeaders = new Headers(res.headers)
  hopByHopHeaders.forEach((header) => {
    resHeaders.delete(header)
  })
  if (resHeaders.has('content-encoding')) {
    resHeaders.delete('content-encoding')
    // Content-Length is the size of the compressed content, not the size of the original content
    resHeaders.delete('content-length')
  }

  return new Response(res.body, {
    status: res.status,
    statusText: res.statusText,
    headers: resHeaders,
  })
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/helper/css/common.case.test.tsx
```
/** @jsxImportSource ../../jsx */
import type {
  Style as StyleComponent,
  css as cssHelper,
  keyframes as keyframesHelper,
  rawCssString as rawCssStringHelper,
  viewTransition as viewTransitionHelper,
} from './index'

interface Support {
  nest: boolean
}
export const renderTest = (
  getEnv: () => {
    css: typeof cssHelper
    keyframes: typeof keyframesHelper
    viewTransition: typeof viewTransitionHelper
    rawCssString: typeof rawCssStringHelper
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    toString: (template: any) => Promise<string>
    Style: typeof StyleComponent
    support: Support
  }
) => {
  const { support } = getEnv()

  let css: typeof cssHelper
  let keyframes: typeof keyframesHelper
  let viewTransition: typeof viewTransitionHelper
  let rawCssString: typeof rawCssStringHelper
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let toString: (template: any) => Promise<string>
  let Style: typeof StyleComponent
  beforeEach(() => {
    ;({ css, keyframes, viewTransition, rawCssString, toString, Style } = getEnv())
  })

  describe('render css', () => {
    it('Should render CSS styles with JSX', async () => {
      const headerClass = css`
        background-color: blue;
      `
      const template = (
        <>
          <Style />
          <h1 class={headerClass}>Hello!</h1>
        </>
      )
      expect(await toString(template)).toBe(
        '<style id="hono-css">.css-2458908649{background-color:blue}</style><h1 class="css-2458908649">Hello!</h1>'
      )
    })

    it('Should render CSS with keyframes', async () => {
      const animation = keyframes`
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      `
      const headerClass = css`
        background-color: blue;
        animation: ${animation} 1s ease-in-out;
      `
      const template = (
        <>
          <Style />
          <h1 class={headerClass}>Hello!</h1>
        </>
      )
      expect(await toString(template)).toBe(
        '<style id="hono-css">.css-1580801783{background-color:blue;animation:css-9294673 1s ease-in-out}@keyframes css-9294673{from{opacity:0}to{opacity:1}}</style><h1 class="css-1580801783">Hello!</h1>'
      )
    })

    it('Should not output the same class name multiple times.', async () => {
      const headerClass = css`
        background-color: blue;
      `
      const headerClass2 = css`
        background-color: blue;
      `
      const template = (
        <>
          <Style />
          <h1 class={headerClass}>Hello!</h1>
          <h1 class={headerClass2}>Hello2!</h1>
        </>
      )
      expect(await toString(template)).toBe(
        '<style id="hono-css">.css-2458908649{background-color:blue}</style><h1 class="css-2458908649">Hello!</h1><h1 class="css-2458908649">Hello2!</h1>'
      )
    })

    it('Should render CSS with variable', async () => {
      const headerClass = css`
        background-color: blue;
        content: '${"I'm a variable!"}';
      `
      const template = (
        <>
          <Style />
          <h1 class={headerClass}>Hello!</h1>
        </>
      )
      expect(await toString(template)).toBe(
        '<style id="hono-css">.css-4027435072{background-color:blue;content:\'I\\\'m a variable!\'}</style><h1 class="css-4027435072">Hello!</h1>'
      )
    })

    it('Should escape </style>', async () => {
      const headerClass = css`
        background-color: blue;
        content: '${'</style>'}';
      `
      const template = (
        <>
          <Style />
          <h1 class={headerClass}>Hello!</h1>
        </>
      )
      expect(await toString(template)).toBe(
        '<style id="hono-css">.css-372954897{background-color:blue;content:\'<\\/style>\'}</style><h1 class="css-372954897">Hello!</h1>'
      )
    })

    it('Should not escape URL', async () => {
      const headerClass = css`
        background-color: blue;
        background: url('${'http://www.example.com/path/to/file.jpg'}');
      `
      const template = (
        <>
          <Style />
          <h1 class={headerClass}>Hello!</h1>
        </>
      )
      expect(await toString(template)).toBe(
        '<style id="hono-css">.css-1321888780{background-color:blue;background:url(\'http://www.example.com/path/to/file.jpg\')}</style><h1 class="css-1321888780">Hello!</h1>'
      )
    })

    it('Should render CSS with escaped variable', async () => {
      const headerClass = css`
        background-color: blue;
        content: '${rawCssString('say "Hello!"')}';
      `
      const template = (
        <>
          <Style />
          <h1 class={headerClass}>Hello!</h1>
        </>
      )
      expect(await toString(template)).toBe(
        '<style id="hono-css">.css-2238574885{background-color:blue;content:\'say "Hello!"\'}</style><h1 class="css-2238574885">Hello!</h1>'
      )
    })

    it('Should render CSS with number', async () => {
      const headerClass = css`
        background-color: blue;
        font-size: ${1}rem;
      `
      const template = (
        <>
          <Style />
          <h1 class={headerClass}>Hello!</h1>
        </>
      )
      expect(await toString(template)).toBe(
        '<style id="hono-css">.css-1847536026{background-color:blue;font-size:1rem}</style><h1 class="css-1847536026">Hello!</h1>'
      )
    })

    it('Should render CSS with array', async () => {
      const animation = keyframes`
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      `
      const headerClass = css`
        background-color: blue;
        animation: ${animation} 1s ease-in-out;
      `
      const extendedHeaderClass = css`
        ${headerClass}
        color: red;
      `
      const template = (
        <>
          <Style />
          <h1 class={extendedHeaderClass}>Hello!</h1>
        </>
      )
      expect(await toString(template)).toBe(
        '<style id="hono-css">.css-2558359670{background-color:blue;animation:css-9294673 1s ease-in-out;color:red}@keyframes css-9294673{from{opacity:0}to{opacity:1}}</style><h1 class="css-2558359670">Hello!</h1>'
      )
    })

    it.runIf(support.nest)(
      'Should be used as a class name for syntax `${className} {`',
      async () => {
        const headerClass = css`
          font-weight: bold;
        `
        const containerClass = css`
          ${headerClass} {
            h1 {
              color: red;
            }
          }
        `
        const template = (
          <>
            <Style />
            <div class={containerClass}>
              <h1 class={headerClass}>Hello!</h1>
            </div>
          </>
        )
        expect(await toString(template)).toBe(
          '<style id="hono-css">.css-4220297002{.css-1032195302{h1{color:red}}}.css-1032195302{font-weight:bold}</style><div class="css-4220297002"><h1 class="css-1032195302">Hello!</h1></div>'
        )
      }
    )

    it('Should be inserted to global if style string starts with :-hono-root', async () => {
      const globalClass = css`
        :-hono-global {
          html {
            color: red;
          }
          body {
            display: flex;
          }
        }
      `
      const template = (
        <>
          <Style />
          <div class={globalClass}>
            <h1>Hello!</h1>
          </div>
        </>
      )
      expect(await toString(template)).toBe(
        '<style id="hono-css">html{color:red}body{display:flex}</style><div class=""><h1>Hello!</h1></div>'
      )
    })

    it.runIf(support.nest)(
      'Should be inserted to global if style string starts with :-hono-root and extends class name',
      async () => {
        const headerClass = css`
          display: flex;
        `
        const specialHeaderClass = css`
          :-hono-global {
            ${headerClass} {
              h1 {
                color: red;
              }
            }
          }
        `
        const template = (
          <>
            <Style />
            <div class={specialHeaderClass}>
              <h1>Hello!</h1>
            </div>
          </>
        )
        expect(await toString(template)).toBe(
          '<style id="hono-css">.css-3980466870{h1{color:red}}.css-3980466870{display:flex}</style><div class="css-3980466870"><h1>Hello!</h1></div>'
        )
      }
    )

    it('Should be inserted as global css if passed css`` to Style component', async () => {
      const headerClass = css`
        font-size: 1rem;
      `
      const template = (
        <>
          <Style>{css`
            html {
              color: red;
            }
            body {
              display: flex;
            }
          `}</Style>
          <div>
            <h1 class={headerClass}>Hello!</h1>
          </div>
        </>
      )
      expect(await toString(template)).toBe(
        '<style id="hono-css">html{color:red}body{display:flex}.css-1740067317{font-size:1rem}</style><div><h1 class="css-1740067317">Hello!</h1></div>'
      )
    })

    it('Should be ignored :-hono-root inside Style component', async () => {
      const headerClass = css`
        font-size: 1rem;
      `
      const template = (
        <>
          <Style>{css`
            :-hono-global {
              html {
                color: red;
              }
              body {
                display: flex;
              }
            }
          `}</Style>
          <div>
            <h1 class={headerClass}>Hello!</h1>
          </div>
        </>
      )
      expect(await toString(template)).toBe(
        '<style id="hono-css">html{color:red}body{display:flex}.css-1740067317{font-size:1rem}</style><div><h1 class="css-1740067317">Hello!</h1></div>'
      )
    })

    describe('viewTransition', () => {
      it('Should render CSS with unique view-transition-name', async () => {
        const transition = viewTransition()
        const template = (
          <>
            <Style />
            <h1 class={transition}>Hello!</h1>
          </>
        )
        expect(await toString(template)).toBe(
          '<style id="hono-css">.css-1644952339{view-transition-name:css-1644952339}</style><h1 class="css-1644952339">Hello!</h1>'
        )
      })

      it('Should render CSS with css and keyframes', async () => {
        const kf = keyframes`
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      `
        const transition = viewTransition(css`
          ::view-transition-old() {
            animation-name: ${kf};
          }
          ::view-transition-new() {
            animation-name: ${kf};
          }
        `)
        const headerClass = css`
          ${transition}
          background-color: blue;
        `
        const template = (
          <>
            <Style />
            <h1 class={headerClass}>Hello!</h1>
          </>
        )
        expect(await toString(template)).toBe(
          '<style id="hono-css">.css-1245070278{view-transition-name:css-399742870;background-color:blue}@keyframes css-9294673{from{opacity:0}to{opacity:1}}::view-transition-old(css-399742870){animation-name:css-9294673}::view-transition-new(css-399742870){animation-name:css-9294673}</style><h1 class="css-1245070278">Hello!</h1>'
        )
      })

      it('Should works as a template tag function', async () => {
        const kf = keyframes`
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      `
        const transition = viewTransition`
          ::view-transition-old() {
            animation-name: ${kf};
          }
          ::view-transition-new() {
            animation-name: ${kf};
          }
        `
        const headerClass = css`
          ${transition}
          background-color: blue;
        `
        const template = (
          <>
            <Style />
            <h1 class={headerClass}>Hello!</h1>
          </>
        )
        expect(await toString(template)).toBe(
          '<style id="hono-css">.css-1245070278{view-transition-name:css-399742870;background-color:blue}@keyframes css-9294673{from{opacity:0}to{opacity:1}}::view-transition-old(css-399742870){animation-name:css-9294673}::view-transition-new(css-399742870){animation-name:css-9294673}</style><h1 class="css-1245070278">Hello!</h1>'
        )
      })
    })

    it.runIf(support.nest)('Should render sub CSS with keyframe', async () => {
      const headerClass = css`
        background-color: blue;
        ${[1, 2].map(
          (i) =>
            css`
              :nth-child(${i}) {
                color: red;
              }
            `
        )}
      `
      const template = (
        <>
          <Style />
          <h1 class={headerClass}>Hello!</h1>
        </>
      )
      expect(await toString(template)).toBe(
        '<style id="hono-css">.css-1539881271{background-color:blue;:nth-child(1){color:red}:nth-child(2){color:red}}</style><h1 class="css-1539881271">Hello!</h1>'
      )
    })

    it('Should be generated deferent class name for deferent first line comment even if the content is the same', async () => {
      const headerClassA = css`
        /* class A */
        display: flex;
      `
      const headerClassB = css`
        /* class B */
        display: flex;
      `
      const template = (
        <>
          <Style />
          <h1 class={headerClassA}>Hello!</h1>
          <h1 class={headerClassB}>Hello!</h1>
        </>
      )
      expect(await toString(template)).toBe(
        '<style id="hono-css">.css-3170754153{display:flex}.css-896513246{display:flex}</style><h1 class="css-3170754153">Hello!</h1><h1 class="css-896513246">Hello!</h1>'
      )
    })

    describe('Booleans, Null, and Undefined Are Ignored', () => {
      it.each([true, false, undefined, null])('%s', async (value) => {
        const headerClass = css`
          ${value}
          background-color: blue;
        `
        const template = (
          <>
            <Style />
            <h1 class={headerClass}>Hello!</h1>
          </>
        )
        expect(await toString(template)).toBe(
          '<style id="hono-css">.css-2458908649{background-color:blue}</style><h1 class="css-2458908649">Hello!</h1>'
        )
      })

      it('falsy value', async () => {
        const value = 0
        const headerClass = css`
          padding: ${value};
        `
        const template = (
          <>
            <Style />
            <h1 class={headerClass}>Hello!</h1>
          </>
        )
        expect(await toString(template)).toBe(
          '<style id="hono-css">.css-478287868{padding:0}</style><h1 class="css-478287868">Hello!</h1>'
        )
      })

      it('Should render CSS styles with CSP nonce', async () => {
        const headerClass = css`
          background-color: blue;
        `
        const template = (
          <>
            <Style nonce='1234' />
            <h1 class={headerClass}>Hello!</h1>
          </>
        )
        expect(await toString(template)).toBe(
          '<style id="hono-css" nonce="1234">.css-2458908649{background-color:blue}</style><h1 class="css-2458908649">Hello!</h1>'
        )
      })
    })
  })
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/css/common.ts
```typescript
// provide utility functions for css helper both on server and client
export const PSEUDO_GLOBAL_SELECTOR = ':-hono-global'
export const isPseudoGlobalSelectorRe = new RegExp(`^${PSEUDO_GLOBAL_SELECTOR}{(.*)}$`)
export const DEFAULT_STYLE_ID = 'hono-css'

export const SELECTOR: unique symbol = Symbol()
export const CLASS_NAME: unique symbol = Symbol()
export const STYLE_STRING: unique symbol = Symbol()
export const SELECTORS: unique symbol = Symbol()
export const EXTERNAL_CLASS_NAMES: unique symbol = Symbol()
const CSS_ESCAPED: unique symbol = Symbol()

export interface CssClassName {
  [SELECTOR]: string
  [CLASS_NAME]: string
  [STYLE_STRING]: string
  [SELECTORS]: CssClassName[]
  [EXTERNAL_CLASS_NAMES]: string[]
}

export const IS_CSS_ESCAPED = Symbol()

interface CssEscapedString {
  [CSS_ESCAPED]: string
}

/**
 * @experimental
 * `rawCssString` is an experimental feature.
 * The API might be changed.
 */
export const rawCssString = (value: string): CssEscapedString => {
  return {
    [CSS_ESCAPED]: value,
  }
}

/**
 * Used the goober'code as a reference:
 * https://github.com/cristianbote/goober/blob/master/src/core/to-hash.js
 * MIT License, Copyright (c) 2019 Cristian Bote
 */
const toHash = (str: string): string => {
  let i = 0,
    out = 11
  while (i < str.length) {
    out = (101 * out + str.charCodeAt(i++)) >>> 0
  }
  return 'css-' + out
}

const cssStringReStr: string = [
  '"(?:(?:\\\\[\\s\\S]|[^"\\\\])*)"', // double quoted string

  "'(?:(?:\\\\[\\s\\S]|[^'\\\\])*)'", // single quoted string
].join('|')
const minifyCssRe: RegExp = new RegExp(
  [
    '(' + cssStringReStr + ')', // $1: quoted string

    '(?:' +
      [
        '^\\s+', // head whitespace
        '\\/\\*.*?\\*\\/\\s*', // multi-line comment
        '\\/\\/.*\\n\\s*', // single-line comment
        '\\s+$', // tail whitespace
      ].join('|') +
      ')',

    '\\s*;\\s*(}|$)\\s*', // $2: trailing semicolon
    '\\s*([{};:,])\\s*', // $3: whitespace around { } : , ;
    '(\\s)\\s+', // $4: 2+ spaces
  ].join('|'),
  'g'
)

export const minify = (css: string): string => {
  return css.replace(minifyCssRe, (_, $1, $2, $3, $4) => $1 || $2 || $3 || $4 || '')
}

type CssVariableBasicType =
  | CssClassName
  | CssEscapedString
  | string
  | number
  | boolean
  | null
  | undefined
type CssVariableAsyncType = Promise<CssVariableBasicType>
type CssVariableArrayType = (CssVariableBasicType | CssVariableAsyncType)[]
export type CssVariableType = CssVariableBasicType | CssVariableAsyncType | CssVariableArrayType

export const buildStyleString = (
  strings: TemplateStringsArray,
  values: CssVariableType[]
): [string, string, CssClassName[], string[]] => {
  const selectors: CssClassName[] = []
  const externalClassNames: string[] = []

  const label = strings[0].match(/^\s*\/\*(.*?)\*\//)?.[1] || ''
  let styleString = ''
  for (let i = 0, len = strings.length; i < len; i++) {
    styleString += strings[i]
    let vArray = values[i]
    if (typeof vArray === 'boolean' || vArray === null || vArray === undefined) {
      continue
    }

    if (!Array.isArray(vArray)) {
      vArray = [vArray]
    }
    for (let j = 0, len = vArray.length; j < len; j++) {
      let value = vArray[j]
      if (typeof value === 'boolean' || value === null || value === undefined) {
        continue
      }
      if (typeof value === 'string') {
        if (/([\\"'\/])/.test(value)) {
          styleString += value.replace(/([\\"']|(?<=<)\/)/g, '\\$1')
        } else {
          styleString += value
        }
      } else if (typeof value === 'number') {
        styleString += value
      } else if ((value as CssEscapedString)[CSS_ESCAPED]) {
        styleString += (value as CssEscapedString)[CSS_ESCAPED]
      } else if ((value as CssClassName)[CLASS_NAME].startsWith('@keyframes ')) {
        selectors.push(value as CssClassName)
        styleString += ` ${(value as CssClassName)[CLASS_NAME].substring(11)} `
      } else {
        if (strings[i + 1]?.match(/^\s*{/)) {
          // assume this value is a class name
          selectors.push(value as CssClassName)
          value = `.${(value as CssClassName)[CLASS_NAME]}`
        } else {
          selectors.push(...(value as CssClassName)[SELECTORS])
          externalClassNames.push(...(value as CssClassName)[EXTERNAL_CLASS_NAMES])
          value = (value as CssClassName)[STYLE_STRING]
          const valueLen = value.length
          if (valueLen > 0) {
            const lastChar = value[valueLen - 1]
            if (lastChar !== ';' && lastChar !== '}') {
              value += ';'
            }
          }
        }
        styleString += `${value || ''}`
      }
    }
  }

  return [label, minify(styleString), selectors, externalClassNames]
}

export const cssCommon = (
  strings: TemplateStringsArray,
  values: CssVariableType[]
): CssClassName => {
  let [label, thisStyleString, selectors, externalClassNames] = buildStyleString(strings, values)
  const isPseudoGlobal = isPseudoGlobalSelectorRe.exec(thisStyleString)
  if (isPseudoGlobal) {
    thisStyleString = isPseudoGlobal[1]
  }
  const selector = (isPseudoGlobal ? PSEUDO_GLOBAL_SELECTOR : '') + toHash(label + thisStyleString)
  const className = (
    isPseudoGlobal ? selectors.map((s) => s[CLASS_NAME]) : [selector, ...externalClassNames]
  ).join(' ')

  return {
    [SELECTOR]: selector,
    [CLASS_NAME]: className,
    [STYLE_STRING]: thisStyleString,
    [SELECTORS]: selectors,
    [EXTERNAL_CLASS_NAMES]: externalClassNames,
  }
}

export const cxCommon = (
  args: (string | boolean | null | undefined | CssClassName)[]
): (string | boolean | null | undefined | CssClassName)[] => {
  for (let i = 0, len = args.length; i < len; i++) {
    const arg = args[i]
    if (typeof arg === 'string') {
      args[i] = {
        [SELECTOR]: '',
        [CLASS_NAME]: '',
        [STYLE_STRING]: '',
        [SELECTORS]: [],
        [EXTERNAL_CLASS_NAMES]: [arg],
      }
    }
  }

  return args
}

export const keyframesCommon = (
  strings: TemplateStringsArray,
  ...values: CssVariableType[]
): CssClassName => {
  const [label, styleString] = buildStyleString(strings, values)
  return {
    [SELECTOR]: '',
    [CLASS_NAME]: `@keyframes ${toHash(label + styleString)}`,
    [STYLE_STRING]: styleString,
    [SELECTORS]: [],
    [EXTERNAL_CLASS_NAMES]: [],
  }
}

type ViewTransitionType = {
  (strings: TemplateStringsArray, values: CssVariableType[]): CssClassName
  (content: CssClassName): CssClassName
  (): CssClassName
}

let viewTransitionNameIndex = 0
export const viewTransitionCommon: ViewTransitionType = ((
  strings: TemplateStringsArray | CssClassName | undefined,
  values: CssVariableType[]
): CssClassName => {
  if (!strings) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    strings = [`/* h-v-t ${viewTransitionNameIndex++} */`] as any
  }
  const content = Array.isArray(strings)
    ? cssCommon(strings as TemplateStringsArray, values)
    : (strings as CssClassName)

  const transitionName = content[CLASS_NAME]
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const res = cssCommon(['view-transition-name:', ''] as any, [transitionName])

  content[CLASS_NAME] = PSEUDO_GLOBAL_SELECTOR + content[CLASS_NAME]
  content[STYLE_STRING] = content[STYLE_STRING].replace(
    /(?<=::view-transition(?:[a-z-]*)\()(?=\))/g,
    transitionName
  )
  res[CLASS_NAME] = res[SELECTOR] = transitionName
  res[SELECTORS] = [...content[SELECTORS], content]

  return res
}) as ViewTransitionType

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/css/index.test.tsx
```
/** @jsxImportSource ../../jsx */
import { Hono } from '../../'
import { html } from '../../helper/html'
import type { JSXNode } from '../../jsx'
import { isValidElement } from '../../jsx'
import { Suspense, renderToReadableStream } from '../../jsx/streaming'
import type { HtmlEscapedString } from '../../utils/html'
import { HtmlEscapedCallbackPhase, resolveCallback } from '../../utils/html'
import { renderTest } from './common.case.test'
import { Style, createCssContext, css, cx, keyframes, rawCssString, viewTransition } from './index'

async function toString(
  template: JSXNode | Promise<HtmlEscapedString> | Promise<string> | HtmlEscapedString
) {
  if (template instanceof Promise) {
    template = (await template) as HtmlEscapedString
  }
  if (isValidElement(template)) {
    template = template.toString() as Promise<HtmlEscapedString>
  }
  return resolveCallback(await template, HtmlEscapedCallbackPhase.Stringify, false, template)
}

async function toCSS(
  template: JSXNode | Promise<HtmlEscapedString> | Promise<string> | HtmlEscapedString
) {
  return (await toString(template))
    .replace(/.*?=(".*")<\/script.*/, '$1')
    .replace(/\.css-\d+/g, '.css-123')
}

describe('CSS Helper', () => {
  renderTest(() => {
    return {
      css,
      Style,
      keyframes,
      viewTransition,
      rawCssString,
      createCssContext,
      toString,
      toCSS,
      support: {
        nest: true,
      },
    }
  })

  describe('with `html` tag function', () => {
    it('Should render CSS styles with `html` tag function', async () => {
      const headerClass = css`
        background-color: blue;
      `
      const template = html`${Style()}
        <h1 class="${headerClass}">Hello!</h1>`
      expect(await toString(template)).toBe(
        `<style id="hono-css">.css-2458908649{background-color:blue}</style>
        <h1 class="css-2458908649">Hello!</h1>`
      )
    })

    it('Should render CSS styles with `html` tag function and CSP nonce', async () => {
      const headerClass = css`
        background-color: blue;
      `
      const template = html`${Style({ nonce: '1234' })}
        <h1 class="${headerClass}">Hello!</h1>`
      expect(await toString(template)).toBe(
        `<style id="hono-css" nonce="1234">.css-2458908649{background-color:blue}</style>
        <h1 class="css-2458908649">Hello!</h1>`
      )
    })
  })

  describe('cx()', () => {
    it('Should render CSS with cx()', async () => {
      const btn = css`
        border-radius: 4px;
      `
      const btnPrimary = css`
        background-color: blue;
        color: white;
      `

      const template = (
        <>
          <Style />
          <h1 class={cx(btn, btnPrimary)}>Hello!</h1>
        </>
      )
      expect(await toString(template)).toBe(
        '<style id="hono-css">.css-2395710522{border-radius:4px;background-color:blue;color:white}</style><h1 class="css-2395710522">Hello!</h1>'
      )
    })

    it('Should render CSS with cx() includes external class name', async () => {
      const btn = css`
        border-radius: 4px;
      `

      const template = (
        <>
          <Style />
          <h1 class={cx(btn, 'external-class')}>Hello!</h1>
        </>
      )
      expect(await toString(template)).toBe(
        '<style id="hono-css">.css-3467431616{border-radius:4px}</style><h1 class="css-3467431616 external-class">Hello!</h1>'
      )
    })

    it('Should render CSS with cx() includes nested external class name', async () => {
      const btn = css`
        border-radius: 4px;
      `
      const btn2 = cx(btn, 'external-class')
      const btn3 = css`
        ${btn2}
        color: white;
      `
      const btn4 = cx(btn3, 'external-class2')
      const template = (
        <>
          <Style />
          <h1 class={btn4}>Hello!</h1>
        </>
      )
      expect(await toString(template)).toBe(
        '<style id="hono-css">.css-3358636561{border-radius:4px;color:white}</style><h1 class="css-3358636561 external-class external-class2">Hello!</h1>'
      )
    })
  })

  describe('minify', () => {
    const data: [string, Promise<string>, string][] = [
      [
        'basic CSS styles',
        css`
          background-color: blue;
          color: white;
          padding: 1rem;
        `,
        '.css-123{background-color:blue;color:white;padding:1rem}',
      ],
      [
        'remove comments',
        css`
          /* background-color: blue; */
          color: white;
          padding: 1rem;
          // inline comment
          margin: 1rem;
        `,
        '.css-123{color:white;padding:1rem;margin:1rem}',
      ],
      [
        'preserve string',
        css`
          background-color: blue;
          color: white;
          padding: 1rem;
          content: "Hel  \\\n  \\'  lo!";
          content: 'Hel  \\\n  \\"  lo!';
        `,
        '.css-123{background-color:blue;color:white;padding:1rem;content:"Hel  \\\n  \\\'  lo!";content:\'Hel  \\\n  \\"  lo!\'}',
      ],
      [
        'preserve nested selectors',
        css`
          padding: 1rem;
          &:hover {
            padding: 2rem;
          }
        `,
        '.css-123{padding:1rem;&:hover{padding:2rem}}',
      ],
    ]
    data.forEach(([name, str, expected]) => {
      it(`Should be minified while preserving content accurately: ${name}`, async () => {
        expect(JSON.parse(await toCSS(str))).toBe(expected)
      })
    })
  })

  describe('createCssContext()', () => {
    it('Should create a new CSS context', async () => {
      const { css: css1, Style: Style1 } = createCssContext({ id: 'context1' })
      const { css: css2, Style: Style2 } = createCssContext({ id: 'context2' })
      const headerClass1 = css1`
        background-color: blue;
      `
      const headerClass2 = css2`
        background-color: red;
      `
      const template = (
        <>
          <Style1 />
          <Style2 />
          <h1 class={headerClass1}>Hello!</h1>
          <h1 class={headerClass2}>Hello!</h1>
        </>
      )
      expect(await toString(template)).toBe(
        '<style id="context1">.css-2458908649{background-color:blue}</style><style id="context2">.css-960045552{background-color:red}</style><h1 class="css-2458908649">Hello!</h1><h1 class="css-960045552">Hello!</h1>'
      )
    })
  })

  describe('with application', () => {
    const app = new Hono()

    const headerClass = css`
      background-color: blue;
    `

    app.get('/sync', (c) =>
      c.html(
        <>
          <Style />
          <h1 class={headerClass}>Hello!</h1>
        </>
      )
    )

    app.get('/stream', (c) => {
      const stream = renderToReadableStream(
        <>
          <Style />
          <Suspense fallback={<p>Loading...</p>}>
            <h1 class={headerClass}>Hello!</h1>
          </Suspense>
        </>
      )
      return c.body(stream, {
        headers: {
          'Content-Type': 'text/html; charset=UTF-8',
          'Transfer-Encoding': 'chunked',
        },
      })
    })

    app.get('/stream-with-nonce', (c) => {
      const stream = renderToReadableStream(
        <>
          <Style nonce='1234' />
          <Suspense fallback={<p>Loading...</p>}>
            <h1 class={headerClass}>Hello!</h1>
          </Suspense>
        </>
      )
      return c.body(stream, {
        headers: {
          'Content-Type': 'text/html; charset=UTF-8',
          'Transfer-Encoding': 'chunked',
        },
      })
    })

    it('/sync', async () => {
      const res = await app.request('http://localhost/sync')
      expect(res).not.toBeNull()
      expect(await res.text()).toBe(
        '<style id="hono-css">.css-2458908649{background-color:blue}</style><h1 class="css-2458908649">Hello!</h1>'
      )
    })

    it('/stream', async () => {
      const res = await app.request('http://localhost/stream')
      expect(res).not.toBeNull()
      expect(await res.text()).toBe(
        `<style id="hono-css"></style><template id="H:0"></template><p>Loading...</p><!--/$--><script>document.querySelector('#hono-css').textContent+=".css-2458908649{background-color:blue}"</script><template data-hono-target="H:0"><h1 class="css-2458908649">Hello!</h1></template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:0')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
</script>`
      )
    })

    it('/stream-with-nonce', async () => {
      const res = await app.request('http://localhost/stream-with-nonce')
      expect(res).not.toBeNull()
      expect(await res.text()).toBe(
        `<style id="hono-css" nonce="1234"></style><template id="H:1"></template><p>Loading...</p><!--/$--><script nonce="1234">document.querySelector('#hono-css').textContent+=".css-2458908649{background-color:blue}"</script><template data-hono-target="H:1"><h1 class="css-2458908649">Hello!</h1></template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:1')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
</script>`
      )
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/css/index.ts
```typescript
/**
 * @module
 * css Helper for Hono.
 */

import { raw } from '../../helper/html'
import { DOM_RENDERER } from '../../jsx/constants'
import { createCssJsxDomObjects } from '../../jsx/dom/css'
import type { HtmlEscapedCallback, HtmlEscapedString } from '../../utils/html'
import type { CssClassName as CssClassNameCommon, CssVariableType } from './common'
import {
  CLASS_NAME,
  DEFAULT_STYLE_ID,
  PSEUDO_GLOBAL_SELECTOR,
  SELECTOR,
  SELECTORS,
  STYLE_STRING,
  cssCommon,
  cxCommon,
  keyframesCommon,
  viewTransitionCommon,
} from './common'
export { rawCssString } from './common'

type CssClassName = HtmlEscapedString & CssClassNameCommon

type usedClassNameData = [
  Record<string, string>, // class name to add
  Record<string, true> // class name already added
]

interface CssType {
  (strings: TemplateStringsArray, ...values: CssVariableType[]): Promise<string>
}

interface CxType {
  (
    ...args: (CssClassName | Promise<string> | string | boolean | null | undefined)[]
  ): Promise<string>
}

interface KeyframesType {
  (strings: TemplateStringsArray, ...values: CssVariableType[]): CssClassNameCommon
}

interface ViewTransitionType {
  (strings: TemplateStringsArray, ...values: CssVariableType[]): Promise<string>
  (content: Promise<string>): Promise<string>
  (): Promise<string>
}

interface StyleType {
  (args?: { children?: Promise<string>; nonce?: string }): HtmlEscapedString
}

/**
 * @experimental
 * `createCssContext` is an experimental feature.
 * The API might be changed.
 */
export const createCssContext = ({ id }: { id: Readonly<string> }): DefaultContextType => {
  const [cssJsxDomObject, StyleRenderToDom] = createCssJsxDomObjects({ id })

  const contextMap: WeakMap<object, usedClassNameData> = new WeakMap()
  const nonceMap: WeakMap<object, string | undefined> = new WeakMap()

  const replaceStyleRe = new RegExp(`(<style id="${id}"(?: nonce="[^"]*")?>.*?)(</style>)`)

  const newCssClassNameObject = (cssClassName: CssClassNameCommon): Promise<string> => {
    const appendStyle: HtmlEscapedCallback = ({ buffer, context }): Promise<string> | undefined => {
      const [toAdd, added] = contextMap.get(context) as usedClassNameData
      const names = Object.keys(toAdd)

      if (!names.length) {
        return
      }

      let stylesStr = ''
      names.forEach((className) => {
        added[className] = true
        stylesStr += className.startsWith(PSEUDO_GLOBAL_SELECTOR)
          ? toAdd[className]
          : `${className[0] === '@' ? '' : '.'}${className}{${toAdd[className]}}`
      })
      contextMap.set(context, [{}, added])

      if (buffer && replaceStyleRe.test(buffer[0])) {
        buffer[0] = buffer[0].replace(replaceStyleRe, (_, pre, post) => `${pre}${stylesStr}${post}`)
        return
      }

      const nonce = nonceMap.get(context)
      const appendStyleScript = `<script${
        nonce ? ` nonce="${nonce}"` : ''
      }>document.querySelector('#${id}').textContent+=${JSON.stringify(stylesStr)}</script>`

      if (buffer) {
        buffer[0] = `${appendStyleScript}${buffer[0]}`
        return
      }

      return Promise.resolve(appendStyleScript)
    }

    const addClassNameToContext: HtmlEscapedCallback = ({ context }) => {
      if (!contextMap.has(context)) {
        contextMap.set(context, [{}, {}])
      }
      const [toAdd, added] = contextMap.get(context) as usedClassNameData
      let allAdded = true
      if (!added[cssClassName[SELECTOR]]) {
        allAdded = false
        toAdd[cssClassName[SELECTOR]] = cssClassName[STYLE_STRING]
      }
      cssClassName[SELECTORS].forEach(
        ({ [CLASS_NAME]: className, [STYLE_STRING]: styleString }) => {
          if (!added[className]) {
            allAdded = false
            toAdd[className] = styleString
          }
        }
      )
      if (allAdded) {
        return
      }

      return Promise.resolve(raw('', [appendStyle]))
    }

    const className = new String(cssClassName[CLASS_NAME]) as CssClassName
    Object.assign(className, cssClassName)
    ;(className as HtmlEscapedString).isEscaped = true
    ;(className as HtmlEscapedString).callbacks = [addClassNameToContext]
    const promise = Promise.resolve(className)
    Object.assign(promise, cssClassName)

    promise.toString = cssJsxDomObject.toString
    return promise
  }

  const css: CssType = (strings, ...values) => {
    return newCssClassNameObject(cssCommon(strings, values))
  }

  const cx: CxType = (...args) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    args = cxCommon(args as any) as any
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return css(Array(args.length).fill('') as any, ...args)
  }

  const keyframes = keyframesCommon

  const viewTransition: ViewTransitionType = ((
    strings: TemplateStringsArray | Promise<string> | undefined,
    ...values: CssVariableType[]
  ) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return newCssClassNameObject(viewTransitionCommon(strings as any, values))
  }) as ViewTransitionType

  const Style: StyleType = ({ children, nonce } = {}) =>
    raw(
      `<style id="${id}"${nonce ? ` nonce="${nonce}"` : ''}>${
        children ? (children as unknown as CssClassName)[STYLE_STRING] : ''
      }</style>`,
      [
        ({ context }) => {
          nonceMap.set(context, nonce)
          return undefined
        },
      ]
    )

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ;(Style as any)[DOM_RENDERER] = StyleRenderToDom

  return {
    css,
    cx,
    keyframes,
    viewTransition: viewTransition as ViewTransitionType,
    Style,
  }
}

interface DefaultContextType {
  css: CssType
  cx: CxType
  keyframes: KeyframesType
  viewTransition: ViewTransitionType
  Style: StyleType
}

const defaultContext: DefaultContextType = createCssContext({
  id: DEFAULT_STYLE_ID,
})

/**
 * @experimental
 * `css` is an experimental feature.
 * The API might be changed.
 */
export const css = defaultContext.css

/**
 * @experimental
 * `cx` is an experimental feature.
 * The API might be changed.
 */
export const cx = defaultContext.cx

/**
 * @experimental
 * `keyframes` is an experimental feature.
 * The API might be changed.
 */
export const keyframes = defaultContext.keyframes

/**
 * @experimental
 * `viewTransition` is an experimental feature.
 * The API might be changed.
 */
export const viewTransition = defaultContext.viewTransition

/**
 * @experimental
 * `Style` is an experimental feature.
 * The API might be changed.
 */
export const Style = defaultContext.Style

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/conninfo/index.ts
```typescript
/**
 * @module
 * ConnInfo Helper for Hono.
 */

export type { AddressType, NetAddrInfo, ConnInfo, GetConnInfo } from './types'

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/conninfo/types.ts
```typescript
import type { Context } from '../../context'

export type AddressType = 'IPv6' | 'IPv4' | undefined

export type NetAddrInfo = {
  /**
   * Transport protocol type
   */
  transport?: 'tcp' | 'udp'
  /**
   * Transport port number
   */
  port?: number

  address?: string
  addressType?: AddressType
} & (
  | {
      /**
       * Host name such as IP Addr
       */
      address: string

      /**
       * Host name type
       */
      addressType: AddressType
    }
  | {}
)

/**
 * HTTP Connection information
 */
export interface ConnInfo {
  /**
   * Remote information
   */
  remote: NetAddrInfo
}

/**
 * Helper type
 */
export type GetConnInfo = (c: Context) => ConnInfo

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/html/index.test.ts
```typescript
import { HtmlEscapedCallbackPhase, resolveCallback } from '../../utils/html'
import { html, raw } from '.'

describe('Tagged Template Literals', () => {
  it('Should escape special characters', () => {
    const name = 'John "Johnny" Smith'

    expect(html`<p>I'm ${name}.</p>`.toString()).toBe("<p>I'm John &quot;Johnny&quot; Smith.</p>")
  })

  describe('Booleans, Null, and Undefined Are Ignored', () => {
    it.each([true, false, undefined, null])('%s', (item) => {
      expect(html`${item}`.toString()).toBe('')
    })

    it('falsy value', () => {
      expect(html`${0}`.toString()).toBe('0')
    })
  })

  it('Should call $array.flat(Infinity)', () => {
    const values = [
      'Name:',
      ['John "Johnny" Smith', undefined, null],
      ' Contact:',
      [html`<a href="http://example.com/">My Website</a>`],
    ]
    expect(html`<p>${values}</p>`.toString()).toBe(
      '<p>Name:John &quot;Johnny&quot; Smith Contact:<a href="http://example.com/">My Website</a></p>'
    )
  })

  describe('Promise', () => {
    it('Should return Promise<string> when some variables contains Promise<string> in variables', async () => {
      const name = Promise.resolve('John "Johnny" Smith')
      const res = html`<p>I'm ${name}.</p>`
      expect(res).toBeInstanceOf(Promise)

      expect((await res).toString()).toBe("<p>I'm John &quot;Johnny&quot; Smith.</p>")
    })

    it('Should return raw value when some variables contains Promise<HtmlEscapedString> in variables', async () => {
      const name = Promise.resolve(raw('John "Johnny" Smith'))
      const res = html`<p>I'm ${name}.</p>`
      expect(res).toBeInstanceOf(Promise)
      expect((await res).toString()).toBe('<p>I\'m John "Johnny" Smith.</p>')
    })
  })

  describe('HtmlEscapedString', () => {
    it('Should preserve callbacks', async () => {
      const name = raw('Hono', [
        ({ buffer }) => {
          if (buffer) {
            buffer[0] = buffer[0].replace('Hono', 'Hono!')
          }
          return undefined
        },
      ])
      const res = html`<p>I'm ${name}.</p>`
      expect(res).toBeInstanceOf(Promise)

      expect((await res).toString()).toBe("<p>I'm Hono.</p>")
      expect(await resolveCallback(await res, HtmlEscapedCallbackPhase.Stringify, false, {})).toBe(
        "<p>I'm Hono!.</p>"
      )
    })
  })
})

describe('raw', () => {
  it('Should be marked as escaped.', () => {
    const name = 'John &quot;Johnny&quot; Smith'
    expect(html`<p>I'm ${raw(name)}.</p>`.toString()).toBe(
      "<p>I'm John &quot;Johnny&quot; Smith.</p>"
    )
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/html/index.ts
```typescript
/**
 * @module
 * html Helper for Hono.
 */

import { escapeToBuffer, raw, resolveCallbackSync, stringBufferToString } from '../../utils/html'
import type { HtmlEscaped, HtmlEscapedString, StringBufferWithCallbacks } from '../../utils/html'

export { raw }

export const html = (
  strings: TemplateStringsArray,
  ...values: unknown[]
): HtmlEscapedString | Promise<HtmlEscapedString> => {
  const buffer: StringBufferWithCallbacks = [''] as StringBufferWithCallbacks

  for (let i = 0, len = strings.length - 1; i < len; i++) {
    buffer[0] += strings[i]

    const children = Array.isArray(values[i])
      ? (values[i] as Array<unknown>).flat(Infinity)
      : [values[i]]
    for (let i = 0, len = children.length; i < len; i++) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const child = children[i] as any
      if (typeof child === 'string') {
        escapeToBuffer(child, buffer)
      } else if (typeof child === 'number') {
        ;(buffer[0] as string) += child
      } else if (typeof child === 'boolean' || child === null || child === undefined) {
        continue
      } else if (typeof child === 'object' && (child as HtmlEscaped).isEscaped) {
        if ((child as HtmlEscapedString).callbacks) {
          buffer.unshift('', child)
        } else {
          const tmp = child.toString()
          if (tmp instanceof Promise) {
            buffer.unshift('', tmp)
          } else {
            buffer[0] += tmp
          }
        }
      } else if (child instanceof Promise) {
        buffer.unshift('', child)
      } else {
        escapeToBuffer(child.toString(), buffer)
      }
    }
  }
  buffer[0] += strings.at(-1) as string

  return buffer.length === 1
    ? 'callbacks' in buffer
      ? raw(resolveCallbackSync(raw(buffer[0], buffer.callbacks)))
      : raw(buffer[0])
    : stringBufferToString(buffer, buffer.callbacks)
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/adapter/index.test.ts
```typescript
import { Hono } from '../../hono'
import { env, getRuntimeKey } from '.'

describe('getRuntimeKey', () => {
  it('Should return the current runtime key', () => {
    // Now, using the `bun run test` command.
    // But `vitest` depending Node.js will run this test so the RuntimeKey will be `node`.
    expect(getRuntimeKey()).toBe('node')
  })
})

describe('env', () => {
  describe('Types', () => {
    type Env = {
      Bindings: {
        MY_VAR: string
      }
    }

    it('Should not throw type errors with env has generics', () => {
      const app = new Hono()
      app.get('/var', (c) => {
        const { MY_VAR } = env<{ MY_VAR: string }>(c)
        expectTypeOf<string>(MY_VAR)
        return c.json({
          var: MY_VAR,
        })
      })
    })

    it('Should not throw type errors with Hono has generics', () => {
      const app = new Hono<Env>()

      app.get('/var', (c) => {
        const { MY_VAR } = env(c)
        expectTypeOf<string>(MY_VAR)
        return c.json({
          var: MY_VAR,
        })
      })
    })

    it('Should not throw type errors with env and Hono have generics', () => {
      const app = new Hono<Env>()

      app.get('/var', (c) => {
        const { MY_VAR } = env<{ MY_VAR: string }>(c)
        expectTypeOf<string>(MY_VAR)
        return c.json({
          var: MY_VAR,
        })
      })
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/adapter/index.ts
```typescript
/**
 * @module
 * Adapter Helper for Hono.
 */

import type { Context } from '../../context'

export type Runtime = 'node' | 'deno' | 'bun' | 'workerd' | 'fastly' | 'edge-light' | 'other'

export const env = <
  T extends Record<string, unknown>,
  C extends Context = Context<{
    Bindings: T
  }>
>(
  c: T extends Record<string, unknown> ? Context : C,
  runtime?: Runtime
): T & C['env'] => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const global = globalThis as any
  const globalEnv = global?.process?.env as T

  runtime ??= getRuntimeKey()

  const runtimeEnvHandlers: Record<string, () => T> = {
    bun: () => globalEnv,
    node: () => globalEnv,
    'edge-light': () => globalEnv,
    deno: () => {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      return Deno.env.toObject() as T
    },
    workerd: () => c.env,
    // On Fastly Compute, you can use the ConfigStore to manage user-defined data.
    fastly: () => ({} as T),
    other: () => ({} as T),
  }

  return runtimeEnvHandlers[runtime]()
}

export const knownUserAgents: Partial<Record<Runtime, string>> = {
  deno: 'Deno',
  bun: 'Bun',
  workerd: 'Cloudflare-Workers',
  node: 'Node.js',
}

export const getRuntimeKey = (): Runtime => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const global = globalThis as any

  // check if the current runtime supports navigator.userAgent
  const userAgentSupported =
    typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string'

  // if supported, check the user agent
  if (userAgentSupported) {
    for (const [runtimeKey, userAgent] of Object.entries(knownUserAgents)) {
      if (checkUserAgentEquals(userAgent)) {
        return runtimeKey as Runtime
      }
    }
  }

  // check if running on Edge Runtime
  if (typeof global?.EdgeRuntime === 'string') {
    return 'edge-light'
  }

  // check if running on Fastly
  if (global?.fastly !== undefined) {
    return 'fastly'
  }

  // userAgent isn't supported before Node v21.1.0; so fallback to the old way
  if (global?.process?.release?.name === 'node') {
    return 'node'
  }

  // couldn't detect the runtime
  return 'other'
}

export const checkUserAgentEquals = (platform: string): boolean => {
  const userAgent = navigator.userAgent

  return userAgent.startsWith(platform)
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/streaming/index.ts
```typescript
/**
 * @module
 * Streaming Helper for Hono.
 */

export { stream } from './stream'
export type { SSEMessage } from './sse'
export { streamSSE, SSEStreamingApi } from './sse'
export { streamText } from './text'

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/streaming/sse.test.tsx
```
/** @jsxImportSource ../../jsx */
import { Context } from '../../context'
import { ErrorBoundary } from '../../jsx'
import { streamSSE } from '.'

describe('SSE Streaming helper', () => {
  const req = new Request('http://localhost/')
  let c: Context
  beforeEach(() => {
    c = new Context(req)
  })

  it('Check streamSSE Response', async () => {
    let spy
    const res = streamSSE(c, async (stream) => {
      spy = vi.spyOn(stream, 'close').mockImplementation(async () => {})

      let id = 0
      const maxIterations = 5

      while (id < maxIterations) {
        const message = `Message\nIt is ${id}`
        await stream.writeSSE({ data: message, event: 'time-update', id: String(id++) })
        await stream.sleep(10)
      }
    })

    expect(res).not.toBeNull()
    expect(res.status).toBe(200)
    expect(res.headers.get('Transfer-Encoding')).toEqual('chunked')
    expect(res.headers.get('Content-Type')).toEqual('text/event-stream')
    expect(res.headers.get('Cache-Control')).toEqual('no-cache')
    expect(res.headers.get('Connection')).toEqual('keep-alive')

    if (!res.body) {
      throw new Error('Body is null')
    }
    const reader = res.body.getReader()
    const decoder = new TextDecoder()
    for (let i = 0; i < 5; i++) {
      const { value } = await reader.read()
      const decodedValue = decoder.decode(value)

      // Check the structure and content of the SSE message
      let expectedValue = 'event: time-update\n'
      expectedValue += 'data: Message\n'
      expectedValue += `data: It is ${i}\n`
      expectedValue += `id: ${i}\n\n`
      expect(decodedValue).toBe(expectedValue)
    }
    await new Promise((resolve) => setTimeout(resolve, 100))
    expect(spy).toHaveBeenCalled()
  })

  it('Check streamSSE Response if aborted by client', async () => {
    let aborted = false
    const res = streamSSE(c, async (stream) => {
      stream.onAbort(() => {
        aborted = true
      })
      for (let i = 0; i < 3; i++) {
        await stream.writeSSE({
          data: `Message ${i}`,
        })
        await stream.sleep(1)
      }
    })
    if (!res.body) {
      throw new Error('Body is null')
    }
    const reader = res.body.getReader()
    const { value } = await reader.read()
    expect(value).toEqual(new TextEncoder().encode('data: Message 0\n\n'))
    reader.cancel()
    expect(aborted).toBeTruthy()
  })

  it('Check streamSSE Response if aborted by abort signal', async () => {
    // Emulate an old version of Bun (version 1.1.0) for this specific test case
    // @ts-expect-error Bun is not typed
    global.Bun = {
      version: '1.1.0',
    }
    const ac = new AbortController()
    const req = new Request('http://localhost/', { signal: ac.signal })
    const c = new Context(req)

    let aborted = false
    const res = streamSSE(c, async (stream) => {
      stream.onAbort(() => {
        aborted = true
      })
      for (let i = 0; i < 3; i++) {
        await stream.writeSSE({
          data: `Message ${i}`,
        })
        await stream.sleep(1)
      }
    })
    if (!res.body) {
      throw new Error('Body is null')
    }
    const reader = res.body.getReader()
    const { value } = await reader.read()
    expect(value).toEqual(new TextEncoder().encode('data: Message 0\n\n'))
    ac.abort()
    expect(aborted).toBeTruthy()
  })

  it('Should include retry in the SSE message', async () => {
    const retryTime = 3000 // 3 seconds
    const res = streamSSE(c, async (stream) => {
      await stream.writeSSE({
        data: 'This is a test message',
        retry: retryTime,
      })
    })

    expect(res).not.toBeNull()
    expect(res.status).toBe(200)

    if (!res.body) {
      throw new Error('Body is null')
    }
    const reader = res.body.getReader()
    const decoder = new TextDecoder()
    const { value } = await reader.read()
    const decodedValue = decoder.decode(value)

    // Check if the retry parameter is included in the SSE message
    const expectedRetryValue = `retry: ${retryTime}\n\n`
    expect(decodedValue).toContain(expectedRetryValue)
  })

  it('Check stream Response if error occurred', async () => {
    const onError = vi.fn()
    const res = streamSSE(
      c,
      async () => {
        throw new Error('Test error')
      },
      onError
    )
    if (!res.body) {
      throw new Error('Body is null')
    }
    const reader = res.body.getReader()
    const decoder = new TextDecoder()
    const { value } = await reader.read()
    const decodedValue = decoder.decode(value)
    expect(decodedValue).toBe('event: error\ndata: Test error\n\n')
    expect(onError).toBeCalledTimes(1)
    expect(onError).toBeCalledWith(new Error('Test error'), expect.anything()) // 2nd argument is StreamingApi instance
  })

  it('Check streamSSE Response via Promise<string>', async () => {
    const res = streamSSE(c, async (stream) => {
      await stream.writeSSE({ data: Promise.resolve('Async Message') })
    })

    expect(res).not.toBeNull()
    expect(res.status).toBe(200)

    if (!res.body) {
      throw new Error('Body is null')
    }
    const reader = res.body.getReader()
    const decoder = new TextDecoder()
    const { value } = await reader.read()
    const decodedValue = decoder.decode(value)
    expect(decodedValue).toBe('data: Async Message\n\n')
  })

  it('Check streamSSE Response via JSX.Element', async () => {
    const res = streamSSE(c, async (stream) => {
      await stream.writeSSE({ data: <div>Hello</div> })
    })

    expect(res).not.toBeNull()
    expect(res.status).toBe(200)

    if (!res.body) {
      throw new Error('Body is null')
    }
    const reader = res.body.getReader()
    const decoder = new TextDecoder()
    const { value } = await reader.read()
    const decodedValue = decoder.decode(value)
    expect(decodedValue).toBe('data: <div>Hello</div>\n\n')
  })

  it('Check streamSSE Response via ErrorBoundary in success case', async () => {
    const AsyncComponent = async () => Promise.resolve(<div>Async Hello</div>)
    const res = streamSSE(c, async (stream) => {
      await stream.writeSSE({
        data: (
          <ErrorBoundary fallback={<div>Error</div>}>
            <AsyncComponent />
          </ErrorBoundary>
        ),
      })
    })

    expect(res).not.toBeNull()
    expect(res.status).toBe(200)

    if (!res.body) {
      throw new Error('Body is null')
    }
    const reader = res.body.getReader()
    const decoder = new TextDecoder()
    const { value } = await reader.read()
    const decodedValue = decoder.decode(value)
    expect(decodedValue).toBe('data: <div>Async Hello</div>\n\n')
  })

  it('Check streamSSE Response via ErrorBoundary in error case', async () => {
    const AsyncComponent = async () => Promise.reject()
    const res = streamSSE(c, async (stream) => {
      await stream.writeSSE({
        data: (
          <ErrorBoundary fallback={<div>Error</div>}>
            <AsyncComponent />
          </ErrorBoundary>
        ),
      })
    })

    expect(res).not.toBeNull()
    expect(res.status).toBe(200)

    if (!res.body) {
      throw new Error('Body is null')
    }
    const reader = res.body.getReader()
    const decoder = new TextDecoder()
    const { value } = await reader.read()
    const decodedValue = decoder.decode(value)
    expect(decodedValue).toBe('data: <div>Error</div>\n\n')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/streaming/sse.ts
```typescript
import type { Context } from '../../context'
import { HtmlEscapedCallbackPhase, resolveCallback } from '../../utils/html'
import { StreamingApi } from '../../utils/stream'
import { isOldBunVersion } from './utils'

export interface SSEMessage {
  data: string | Promise<string>
  event?: string
  id?: string
  retry?: number
}

export class SSEStreamingApi extends StreamingApi {
  constructor(writable: WritableStream, readable: ReadableStream) {
    super(writable, readable)
  }

  async writeSSE(message: SSEMessage) {
    const data = await resolveCallback(message.data, HtmlEscapedCallbackPhase.Stringify, false, {})
    const dataLines = (data as string)
      .split('\n')
      .map((line) => {
        return `data: ${line}`
      })
      .join('\n')

    const sseData =
      [
        message.event && `event: ${message.event}`,
        dataLines,
        message.id && `id: ${message.id}`,
        message.retry && `retry: ${message.retry}`,
      ]
        .filter(Boolean)
        .join('\n') + '\n\n'

    await this.write(sseData)
  }
}

const run = async (
  stream: SSEStreamingApi,
  cb: (stream: SSEStreamingApi) => Promise<void>,
  onError?: (e: Error, stream: SSEStreamingApi) => Promise<void>
): Promise<void> => {
  try {
    await cb(stream)
  } catch (e) {
    if (e instanceof Error && onError) {
      await onError(e, stream)

      await stream.writeSSE({
        event: 'error',
        data: e.message,
      })
    } else {
      console.error(e)
    }
  } finally {
    stream.close()
  }
}

const contextStash: WeakMap<ReadableStream, Context> = new WeakMap<ReadableStream, Context>()

export const streamSSE = (
  c: Context,
  cb: (stream: SSEStreamingApi) => Promise<void>,
  onError?: (e: Error, stream: SSEStreamingApi) => Promise<void>
): Response => {
  const { readable, writable } = new TransformStream()
  const stream = new SSEStreamingApi(writable, readable)

  // Until Bun v1.1.27, Bun didn't call cancel() on the ReadableStream for Response objects from Bun.serve()
  if (isOldBunVersion()) {
    c.req.raw.signal.addEventListener('abort', () => {
      if (!stream.closed) {
        stream.abort()
      }
    })
  }

  // in bun, `c` is destroyed when the request is returned, so hold it until the end of streaming
  contextStash.set(stream.responseReadable, c)

  c.header('Transfer-Encoding', 'chunked')
  c.header('Content-Type', 'text/event-stream')
  c.header('Cache-Control', 'no-cache')
  c.header('Connection', 'keep-alive')

  run(stream, cb, onError)

  return c.newResponse(stream.responseReadable)
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/streaming/stream.test.ts
```typescript
import { Context } from '../../context'
import { stream } from '.'

describe('Basic Streaming Helper', () => {
  const req = new Request('http://localhost/')
  let c: Context
  beforeEach(() => {
    c = new Context(req)
  })

  it('Check stream Response', async () => {
    const res = stream(c, async (stream) => {
      for (let i = 0; i < 3; i++) {
        await stream.write(new Uint8Array([i]))
        await stream.sleep(1)
      }
    })
    if (!res.body) {
      throw new Error('Body is null')
    }
    const reader = res.body.getReader()
    for (let i = 0; i < 3; i++) {
      const { value } = await reader.read()
      expect(value).toEqual(new Uint8Array([i]))
    }
  })

  it('Check stream Response if aborted by client', async () => {
    let aborted = false
    const res = stream(c, async (stream) => {
      stream.onAbort(() => {
        aborted = true
      })
      for (let i = 0; i < 3; i++) {
        await stream.write(new Uint8Array([i]))
        await stream.sleep(1)
      }
    })
    if (!res.body) {
      throw new Error('Body is null')
    }
    const reader = res.body.getReader()
    const { value } = await reader.read()
    expect(value).toEqual(new Uint8Array([0]))
    reader.cancel()
    expect(aborted).toBeTruthy()
  })

  it('Check stream Response if aborted by abort signal', async () => {
    // Emulate an old version of Bun (version 1.1.0) for this specific test case
    // @ts-expect-error Bun is not typed
    global.Bun = {
      version: '1.1.0',
    }
    const ac = new AbortController()
    const req = new Request('http://localhost/', { signal: ac.signal })
    const c = new Context(req)

    let aborted = false
    const res = stream(c, async (stream) => {
      stream.onAbort(() => {
        aborted = true
      })
      for (let i = 0; i < 3; i++) {
        await stream.write(new Uint8Array([i]))
        await stream.sleep(1)
      }
    })
    if (!res.body) {
      throw new Error('Body is null')
    }
    const reader = res.body.getReader()
    const { value } = await reader.read()
    expect(value).toEqual(new Uint8Array([0]))
    ac.abort()
    expect(aborted).toBeTruthy()
    // @ts-expect-error Bun is not typed
    delete global.Bun
  })

  it('Check stream Response if pipe is aborted by abort signal', async () => {
    // Emulate an old version of Bun (version 1.1.0) for this specific test case
    // @ts-expect-error Bun is not typed
    global.Bun = {
      version: '1.1.0',
    }
    const ac = new AbortController()
    const req = new Request('http://localhost/', { signal: ac.signal })
    const c = new Context(req)

    let aborted = false
    const res = stream(c, async (stream) => {
      stream.onAbort(() => {
        aborted = true
      })
      await stream.pipe(new ReadableStream())
    })
    if (!res.body) {
      throw new Error('Body is null')
    }
    const reader = res.body.getReader()
    const pReading = reader.read()
    ac.abort()
    await pReading
    expect(aborted).toBeTruthy()
    // @ts-expect-error Bun is not typed
    delete global.Bun
  })

  it('Check stream Response if error occurred', async () => {
    const onError = vi.fn()
    const res = stream(
      c,
      async () => {
        throw new Error('error')
      },
      onError
    )
    if (!res.body) {
      throw new Error('Body is null')
    }
    const reader = res.body.getReader()
    const { value } = await reader.read()
    expect(value).toBeUndefined()
    expect(onError).toBeCalledTimes(1)
    expect(onError).toBeCalledWith(new Error('error'), expect.anything()) // 2nd argument is StreamingApi instance
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/streaming/stream.ts
```typescript
import type { Context } from '../../context'
import { StreamingApi } from '../../utils/stream'
import { isOldBunVersion } from './utils'

const contextStash: WeakMap<ReadableStream, Context> = new WeakMap<ReadableStream, Context>()

export const stream = (
  c: Context,
  cb: (stream: StreamingApi) => Promise<void>,
  onError?: (e: Error, stream: StreamingApi) => Promise<void>
): Response => {
  const { readable, writable } = new TransformStream()
  const stream = new StreamingApi(writable, readable)

  // Until Bun v1.1.27, Bun didn't call cancel() on the ReadableStream for Response objects from Bun.serve()
  if (isOldBunVersion()) {
    c.req.raw.signal.addEventListener('abort', () => {
      if (!stream.closed) {
        stream.abort()
      }
    })
  }

  // in bun, `c` is destroyed when the request is returned, so hold it until the end of streaming
  contextStash.set(stream.responseReadable, c)
  ;(async () => {
    try {
      await cb(stream)
    } catch (e) {
      if (e === undefined) {
        // If reading is canceled without a reason value (e.g. by StreamingApi)
        // then the .pipeTo() promise will reject with undefined.
        // In this case, do nothing because the stream is already closed.
      } else if (e instanceof Error && onError) {
        await onError(e, stream)
      } else {
        console.error(e)
      }
    } finally {
      stream.close()
    }
  })()

  return c.newResponse(stream.responseReadable)
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/streaming/text.test.ts
```typescript
import { Context } from '../../context'
import { streamText } from '.'

describe('Text Streaming Helper', () => {
  const req = new Request('http://localhost/')
  let c: Context
  beforeEach(() => {
    c = new Context(req)
  })

  it('Check streamText Response', async () => {
    const res = streamText(c, async (stream) => {
      for (let i = 0; i < 3; i++) {
        await stream.write(`${i}`)
        await stream.sleep(1)
      }
    })

    expect(res.status).toBe(200)
    expect(res.headers.get('content-type')).toMatch(/^text\/plain/)
    expect(res.headers.get('x-content-type-options')).toBe('nosniff')
    expect(res.headers.get('transfer-encoding')).toBe('chunked')

    if (!res.body) {
      throw new Error('Body is null')
    }
    const reader = res.body.getReader()
    const decoder = new TextDecoder()
    for (let i = 0; i < 3; i++) {
      const { value } = await reader.read()
      expect(decoder.decode(value)).toEqual(`${i}`)
    }
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/streaming/text.ts
```typescript
import type { Context } from '../../context'
import { TEXT_PLAIN } from '../../context'
import type { StreamingApi } from '../../utils/stream'
import { stream } from './'

export const streamText = (
  c: Context,
  cb: (stream: StreamingApi) => Promise<void>,
  onError?: (e: Error, stream: StreamingApi) => Promise<void>
): Response => {
  c.header('Content-Type', TEXT_PLAIN)
  c.header('X-Content-Type-Options', 'nosniff')
  c.header('Transfer-Encoding', 'chunked')
  return stream(c, cb, onError)
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/streaming/utils.ts
```typescript
export let isOldBunVersion = (): boolean => {
  // @ts-expect-error @types/bun is not installed
  const version: string = typeof Bun !== 'undefined' ? Bun.version : undefined
  if (version === undefined) {
    return false
  }
  const result = version.startsWith('1.1') || version.startsWith('1.0') || version.startsWith('0.')
  // Avoid running this check on every call
  isOldBunVersion = () => result
  return result
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/ssg/index.ts
```typescript
/**
 * @module
 * SSG Helper for Hono.
 */

export * from './ssg'
export {
  X_HONO_DISABLE_SSG_HEADER_KEY,
  ssgParams,
  isSSGContext,
  disableSSG,
  onlySSG,
} from './middleware'

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/ssg/middleware.ts
```typescript
import type { Context } from '../../context'
import type { Env, MiddlewareHandler } from '../../types'

export const SSG_CONTEXT = 'HONO_SSG_CONTEXT'
export const X_HONO_DISABLE_SSG_HEADER_KEY = 'x-hono-disable-ssg'

/**
 * @deprecated
 * Use `X_HONO_DISABLE_SSG_HEADER_KEY` instead.
 * This constant will be removed in the next minor version.
 */
export const SSG_DISABLED_RESPONSE = (() => {
  try {
    return new Response('SSG is disabled', {
      status: 404,
      headers: { [X_HONO_DISABLE_SSG_HEADER_KEY]: 'true' },
    })
  } catch {
    return null
  }
})() as Response

interface SSGParam {
  [key: string]: string
}
export type SSGParams = SSGParam[]

interface SSGParamsMiddleware {
  <E extends Env = Env>(
    generateParams: (c: Context<E>) => SSGParams | Promise<SSGParams>
  ): MiddlewareHandler<E>
  <E extends Env = Env>(params: SSGParams): MiddlewareHandler<E>
}

export type AddedSSGDataRequest = Request & {
  ssgParams?: SSGParams
}

/**
 * Define SSG Route
 */
export const ssgParams: SSGParamsMiddleware = (params) => async (c, next) => {
  ;(c.req.raw as AddedSSGDataRequest).ssgParams = Array.isArray(params) ? params : await params(c)
  await next()
}

/**
 * @experimental
 * `isSSGContext` is an experimental feature.
 * The API might be changed.
 */
export const isSSGContext = (c: Context): boolean => !!c.env?.[SSG_CONTEXT]

/**
 * @experimental
 * `disableSSG` is an experimental feature.
 * The API might be changed.
 */
export const disableSSG = (): MiddlewareHandler =>
  async function disableSSG(c, next) {
    if (isSSGContext(c)) {
      c.header(X_HONO_DISABLE_SSG_HEADER_KEY, 'true')
      return c.notFound()
    }
    await next()
  }

/**
 * @experimental
 * `onlySSG` is an experimental feature.
 * The API might be changed.
 */
export const onlySSG = (): MiddlewareHandler =>
  async function onlySSG(c, next) {
    if (!isSSGContext(c)) {
      return c.notFound()
    }
    await next()
  }

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/ssg/ssg.test.tsx
```
/* eslint-disable @typescript-eslint/no-unused-vars */
/** @jsxImportSource ../../jsx */
import { Hono } from '../../hono'
import { poweredBy } from '../../middleware/powered-by'
import {
  X_HONO_DISABLE_SSG_HEADER_KEY,
  disableSSG,
  isSSGContext,
  onlySSG,
  ssgParams,
} from './middleware'
import { defaultExtensionMap, fetchRoutesContent, saveContentToFile, toSSG } from './ssg'
import type {
  AfterGenerateHook,
  AfterResponseHook,
  BeforeRequestHook,
  FileSystemModule,
  ToSSGResult,
} from './ssg'

const resolveRoutesContent = async (res: ReturnType<typeof fetchRoutesContent>) => {
  const htmlMap = new Map<string, { content: string | ArrayBuffer; mimeType: string }>()
  for (const getInfoPromise of res) {
    const getInfo = await getInfoPromise
    if (!getInfo) {
      continue
    }
    for (const dataPromise of getInfo) {
      const data = await dataPromise
      if (!data) {
        continue
      }
      htmlMap.set(data.routePath, {
        content: data.content,
        mimeType: data.mimeType,
      })
    }
  }
  return htmlMap
}

describe('toSSG function', () => {
  let app: Hono
  let fsMock: FileSystemModule

  const postParams = [{ post: '1' }, { post: '2' }]

  beforeEach(() => {
    app = new Hono()
    app.all('/', (c) => c.html('Hello, World!'))
    app.get('/about', (c) => c.html('About Page'))
    app.get('/about/some', (c) => c.text('About Page 2tier'))
    app.post('/about/some/thing', (c) => c.text('About Page 3tier'))
    app.get('/bravo', (c) => c.html('Bravo Page'))
    app.get('/Charlie', async (c, next) => {
      c.setRenderer((content, head) => {
        return c.html(
          <html>
            <head>
              <title>{head.title || ''}</title>
            </head>
            <body>
              <p>{content}</p>
            </body>
          </html>
        )
      })
      await next()
    })
    app.get('/Charlie', (c) => {
      return c.render('Hello!', { title: 'Charlies Page' })
    })

    // Included params
    app.get(
      '/post/:post',
      ssgParams(() => postParams),
      (c) => c.html(<h1>{c.req.param('post')}</h1>)
    )

    app.get(
      '/user/:user_id',
      ssgParams([{ user_id: '1' }, { user_id: '2' }, { user_id: '3' }]),
      (c) => c.html(<h1>{c.req.param('user_id')}</h1>)
    )

    type Env = {
      Bindings: {
        FOO_DB: string
      }
      Variables: {
        FOO_VAR: string
      }
    }

    app.get(
      '/env-type-check',
      ssgParams<Env>((c) => {
        expectTypeOf<typeof c.env.FOO_DB>().toBeString()
        expectTypeOf<typeof c.var.FOO_VAR>().toBeString()
        return []
      })
    )

    fsMock = {
      writeFile: vi.fn(() => Promise.resolve()),
      mkdir: vi.fn(() => Promise.resolve()),
    }
  })
  it('Should correctly generate static HTML files for Hono routes', async () => {
    const writtenFiles: Record<string, string> = {}
    const fsMock: FileSystemModule = {
      writeFile: (path, data) => {
        writtenFiles[path] = typeof data === 'string' ? data : data.toString()
        return Promise.resolve()
      },
      mkdir: vi.fn(() => Promise.resolve()),
    }

    const result = await toSSG(app, fsMock, { dir: './static' })

    for (const postParam of postParams) {
      const html = writtenFiles[`static/post/${postParam.post}.html`]
      expect(html).toBe(`<h1>${postParam.post}</h1>`)
    }

    for (let i = 1; i <= 3; i++) {
      const html = writtenFiles[`static/user/${i}.html`]
      expect(html).toBe(`<h1>${i}</h1>`)
    }

    expect(result.files.length).toBe(10)
    expect(fsMock.mkdir).toHaveBeenCalledWith(expect.any(String), {
      recursive: true,
    })
  })

  it('Should handle file system errors correctly in saveContentToFiles', async () => {
    const fsMock: FileSystemModule = {
      writeFile: vi.fn(() => Promise.reject(new Error('Write error'))),
      mkdir: vi.fn(() => Promise.resolve()),
    }

    const result = await toSSG(app, fsMock, { dir: './static' })
    expect(result.success).toBe(false)
    expect(result.files).toStrictEqual([])
    expect(result.error?.message).toBe('Write error')
  })

  it('Should handle overall process errors correctly in toSSG', async () => {
    const fsMock: FileSystemModule = {
      writeFile: vi.fn(() => Promise.reject(new Error('Write error'))),
      mkdir: vi.fn(() => Promise.resolve()),
    }

    const result = await toSSG(app, fsMock, { dir: './static' })

    expect(result.success).toBe(false)
    expect(result.error).toBeDefined()
    expect(result.files).toStrictEqual([])
  })

  it('Should correctly generate files with the expected paths', async () => {
    await toSSG(app, fsMock, { dir: './static' })

    expect(fsMock.writeFile).toHaveBeenCalledWith('static/index.html', expect.any(String))
    expect(fsMock.writeFile).toHaveBeenCalledWith('static/about.html', expect.any(String))
    expect(fsMock.writeFile).toHaveBeenCalledWith('static/about/some.txt', expect.any(String))
    expect(fsMock.writeFile).not.toHaveBeenCalledWith(
      'static/about/some/thing.txt',
      expect.any(String)
    )
    expect(fsMock.writeFile).toHaveBeenCalledWith('static/about.html', expect.any(String))
    expect(fsMock.writeFile).toHaveBeenCalledWith('static/bravo.html', expect.any(String))
    expect(fsMock.writeFile).toHaveBeenCalledWith('static/Charlie.html', expect.any(String))
  })

  it('should modify the request if the hook is provided', async () => {
    const beforeRequestHook: BeforeRequestHook = (req) => {
      if (req.method === 'GET') {
        return req
      }
      return false
    }
    const result = await toSSG(app, fsMock, { beforeRequestHook })
    expect(result.files).toHaveLength(10)
  })

  it('should skip the route if the request hook returns false', async () => {
    const beforeRequest: BeforeRequestHook = () => false
    const result = await toSSG(app, fsMock, { beforeRequestHook: beforeRequest })
    expect(result.success).toBe(true)
    expect(result.files).toStrictEqual([])
  })

  it('should modify the response if the hook is provided', async () => {
    const afterResponseHook: AfterResponseHook = (res) => {
      if (res.status === 200 || res.status === 500) {
        return res
      }
      return false
    }
    const result = await toSSG(app, fsMock, { afterResponseHook })
    expect(result.files).toHaveLength(10)
  })

  it('should skip the route if the response hook returns false', async () => {
    const afterResponse: AfterResponseHook = () => false
    const result = await toSSG(app, fsMock, { afterResponseHook: afterResponse })
    expect(result.success).toBe(true)
    expect(result.files).toStrictEqual([])
  })

  it('should execute additional processing using afterGenerateHook', async () => {
    const fsMock: FileSystemModule = {
      writeFile: vi.fn(() => Promise.resolve()),
      mkdir: vi.fn(() => Promise.resolve()),
    }
    const afterGenerateHookMock: AfterGenerateHook = vi.fn<AfterGenerateHook>((result) => {
      if (result.files) {
        result.files.forEach((file) => console.log(file))
      }
    })

    await toSSG(app, fsMock, { dir: './static', afterGenerateHook: afterGenerateHookMock })

    expect(afterGenerateHookMock).toHaveBeenCalled()
    expect(afterGenerateHookMock).toHaveBeenCalledWith(expect.anything())
  })

  it('should handle asynchronous beforeRequestHook correctly', async () => {
    const beforeRequestHook: BeforeRequestHook = async (req) => {
      await new Promise((resolve) => setTimeout(resolve, 10))
      if (req.url.includes('/skip')) {
        return false
      }
      return req
    }

    const result = await toSSG(app, fsMock, { beforeRequestHook })
    expect(result.files).not.toContain(expect.stringContaining('/skip'))
    expect(result.success).toBe(true)
    expect(result.files.length).toBeGreaterThan(0)
  })

  it('should handle asynchronous afterResponseHook correctly', async () => {
    const afterResponseHook: AfterResponseHook = async (res) => {
      await new Promise((resolve) => setTimeout(resolve, 10))
      if (res.headers.get('X-Skip') === 'true') {
        return false
      }
      return res
    }

    const result = await toSSG(app, fsMock, { afterResponseHook })
    expect(result.files).not.toContain(expect.stringContaining('/skip'))
    expect(result.success).toBe(true)
    expect(result.files.length).toBeGreaterThan(0)
  })

  it('should handle asynchronous afterGenerateHook correctly', async () => {
    const afterGenerateHook: AfterGenerateHook = async (result) => {
      await new Promise((resolve) => setTimeout(resolve, 10))
      console.log(`Generated ${result.files.length} files.`)
    }

    const result = await toSSG(app, fsMock, { afterGenerateHook })
    expect(result.success).toBe(true)
    expect(result.files.length).toBeGreaterThan(0)
  })

  it('should avoid memory leak from `req.signal.addEventListener()`', async () => {
    const fsMock: FileSystemModule = {
      writeFile: vi.fn(() => Promise.resolve()),
      mkdir: vi.fn(() => Promise.resolve()),
    }

    const signalAddEventListener = vi.fn(() => {})
    const app = new Hono()
    app.get('/post/:post', ssgParams([{ post: '1' }, { post: '2' }]), (c) =>
      c.html(<h1>{c.req.param('post')}</h1>)
    )
    await toSSG(app, fsMock, {
      beforeRequestHook: (req) => {
        req.signal.addEventListener = signalAddEventListener
        return req
      },
    })

    expect(signalAddEventListener).not.toHaveBeenCalled()
  })
})

describe('fetchRoutesContent function', () => {
  let app: Hono

  beforeEach(() => {
    app = new Hono()
    app.get('/text', (c) => c.text('Text Response'))
    app.get('/text-utf8', (c) => {
      return c.text('Text Response', 200, { 'Content-Type': 'text/plain;charset=UTF-8' })
    })
    app.get('/html', (c) => c.html('<p>HTML Response</p>'))
    app.get('/json', (c) => c.json({ message: 'JSON Response' }))
    app.use('*', poweredBy())
  })

  it('should fetch the correct content and MIME type for each route', async () => {
    const htmlMap = await resolveRoutesContent(fetchRoutesContent(app))

    expect(htmlMap.get('/text')).toEqual({
      content: 'Text Response',
      mimeType: 'text/plain',
    })
    expect(htmlMap.get('/text-utf8')).toEqual({
      content: 'Text Response',
      mimeType: 'text/plain',
    })
    expect(htmlMap.get('/html')).toEqual({
      content: '<p>HTML Response</p>',
      mimeType: 'text/html',
    })
    expect(htmlMap.get('/json')).toEqual({
      content: '{"message":"JSON Response"}',
      mimeType: 'application/json',
    })
  })

  it('should skip middleware routes', async () => {
    const htmlMap = await resolveRoutesContent(fetchRoutesContent(app))
    expect(htmlMap.has('*')).toBeFalsy()
  })

  it('should handle errors correctly', async () => {
    vi.spyOn(app, 'fetch').mockRejectedValue(new Error('Network error'))
    await expect(resolveRoutesContent(fetchRoutesContent(app))).rejects.toThrow('Network error')
    vi.restoreAllMocks()
  })
})

describe('saveContentToFile function', () => {
  // tar.gz, testdir/test.txt
  const gzFileBuffer = Buffer.from(
    'H4sIAAAAAAAAA+3SQQrCMBSE4aw9RU6gSc3LO0/FLgqukgj29qZgsQgqCEHE/9vMIoEMTMqQy3FMO9OQq1RkTq/i1rkwPkiMUXWvnXG+U/XGSstSi3MufbLWHIZ0mvLYP7v37vxHldv+c27LpbR4Yx44hvBi/3DfX3zdP0j9Eta1KPPoz/ef+mnz7Q4AAAAAAAAAAAAAAAAAPnMFqt1/BQAoAAA=',
    'base64'
  )
  const gzFileArrayBuffer = gzFileBuffer.buffer.slice(
    gzFileBuffer.byteOffset,
    gzFileBuffer.byteLength + gzFileBuffer.byteOffset
  )
  // PNG, red dot (1x1)
  const pngFileBuffer = Buffer.from(
    'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAADElEQVR4nGP4z8AAAAMBAQDJ/pLvAAAAAElFTkSuQmCCAAAALw',
    'base64'
  )
  const pngFileArrayBuffer = pngFileBuffer.buffer.slice(
    pngFileBuffer.byteOffset,
    pngFileBuffer.byteLength + pngFileBuffer.byteOffset
  )

  const fileData = [
    { routePath: '/', content: 'Home Page', mimeType: 'text/html' },
    { routePath: '/index.html', content: 'Home Page2', mimeType: 'text/html' },
    { routePath: '/about', content: 'About Page', mimeType: 'text/html' },
    { routePath: '/about/', content: 'About Page', mimeType: 'text/html' },
    { routePath: '/bravo/index.html', content: 'About Page', mimeType: 'text/html' },
    { routePath: '/bravo/release-4.0.0', content: 'Release 4.0.0', mimeType: 'text/html' },
    {
      routePath: '/bravo/2024.02.18-sweet-memories',
      content: 'Sweet Memories',
      mimeType: 'text/html',
    },
    { routePath: '/bravo/deep.dive.to.html', content: 'Deep Dive To HTML', mimeType: 'text/html' },
    { routePath: '/bravo/alert.js', content: 'alert("evil content")', mimeType: 'text/html' },
    { routePath: '/bravo.text/index.html', content: 'About Page', mimeType: 'text/html' },
    { routePath: '/bravo.text/', content: 'Bravo Page', mimeType: 'text/html' },
    {
      routePath: '/bravo/index.tar.gz',
      content: gzFileArrayBuffer,
      mimeType: 'application/gzip',
    },
    {
      routePath: '/bravo/dot.png',
      content: pngFileArrayBuffer,
      mimeType: 'image/png',
    },
  ]

  let fsMock: FileSystemModule

  beforeEach(() => {
    fsMock = {
      writeFile: vi.fn(() => Promise.resolve()),
      mkdir: vi.fn(() => Promise.resolve()),
    }
  })

  it('should correctly create files with the right content and paths', async () => {
    for (const data of fileData) {
      await saveContentToFile(Promise.resolve(data), fsMock, './static')
    }

    expect(fsMock.writeFile).toHaveBeenCalledWith('static/index.html', 'Home Page')
    expect(fsMock.writeFile).toHaveBeenCalledWith('static/index.html', 'Home Page2')
    expect(fsMock.writeFile).toHaveBeenCalledWith('static/about.html', 'About Page')
    expect(fsMock.writeFile).toHaveBeenCalledWith('static/about/index.html', 'About Page')
    expect(fsMock.writeFile).toHaveBeenCalledWith('static/bravo/index.html', 'About Page')
    expect(fsMock.writeFile).toHaveBeenCalledWith(
      'static/bravo/release-4.0.0.html',
      'Release 4.0.0'
    )
    expect(fsMock.writeFile).toHaveBeenCalledWith(
      'static/bravo/deep.dive.to.html',
      'Deep Dive To HTML'
    )
    expect(fsMock.writeFile).toHaveBeenCalledWith(
      'static/bravo/2024.02.18-sweet-memories.html',
      'Sweet Memories'
    )
    expect(fsMock.writeFile).toHaveBeenCalledWith(
      'static/bravo/alert.js.html',
      'alert("evil content")'
    )
    expect(fsMock.writeFile).toHaveBeenCalledWith('static/bravo.text/index.html', 'About Page')
    expect(fsMock.writeFile).toHaveBeenCalledWith('static/bravo.text/index.html', 'Bravo Page')
    // binary files
    expect(fsMock.writeFile).toHaveBeenCalledWith(
      'static/bravo/index.tar.gz',
      new Uint8Array(gzFileArrayBuffer)
    )
    expect(fsMock.writeFile).toHaveBeenCalledWith(
      'static/bravo/dot.png',
      new Uint8Array(pngFileArrayBuffer)
    )
  })

  it('should correctly create directories if they do not exist', async () => {
    await saveContentToFile(
      Promise.resolve({
        routePath: '/new-dir/index.html',
        content: 'New Page',
        mimeType: 'text/html',
      }),
      fsMock,
      './static'
    )
    expect(fsMock.mkdir).toHaveBeenCalledWith('static/new-dir', { recursive: true })
  })

  it('should handle file writing or directory creation errors', async () => {
    const fsMock: FileSystemModule = {
      writeFile: vi.fn(() => Promise.resolve()),
      mkdir: vi.fn(() => Promise.reject(new Error('File write error'))),
    }

    await expect(
      saveContentToFile(
        Promise.resolve({
          routePath: '/error-dir/index.html',
          content: 'New Page',
          mimeType: 'text/html',
        }),
        fsMock,
        './static'
      )
    ).rejects.toThrow('File write error')
  })
  it('check extensions', async () => {
    for (const data of fileData) {
      await saveContentToFile(Promise.resolve(data), fsMock, './static-check-extensions')
    }
    expect(fsMock.mkdir).toHaveBeenCalledWith('static-check-extensions', { recursive: true })
  })

  it('should correctly create .yaml files for YAML content', async () => {
    const yamlContent = 'title: YAML Example\nvalue: This is a YAML file.'
    const mimeType = 'application/yaml'
    const routePath = '/example'

    const yamlData = {
      routePath: routePath,
      content: yamlContent,
      mimeType: mimeType,
    }

    const fsMock: FileSystemModule = {
      writeFile: vi.fn(() => Promise.resolve()),
      mkdir: vi.fn(() => Promise.resolve()),
    }

    await saveContentToFile(Promise.resolve(yamlData), fsMock, './static')

    expect(fsMock.writeFile).toHaveBeenCalledWith('static/example.yaml', yamlContent)
  })

  it('should correctly create .yml files for YAML content', async () => {
    const yamlContent = 'title: YAML Example\nvalue: This is a YAML file.'
    const yamlMimeType = 'application/yaml'
    const yamlRoutePath = '/yaml'

    const yamlData = {
      routePath: yamlRoutePath,
      content: yamlContent,
      mimeType: yamlMimeType,
    }

    const yamlMimeType2 = 'x-yaml'
    const yamlRoutePath2 = '/yaml2'
    const yamlData2 = {
      routePath: yamlRoutePath2,
      content: yamlContent,
      mimeType: yamlMimeType2,
    }

    const htmlMimeType = 'text/html'
    const htmlRoutePath = '/html'

    const htmlData = {
      routePath: htmlRoutePath,
      content: yamlContent,
      mimeType: htmlMimeType,
    }

    const fsMock: FileSystemModule = {
      writeFile: vi.fn(() => Promise.resolve()),
      mkdir: vi.fn(() => Promise.resolve()),
    }

    const extensionMap = {
      'application/yaml': 'yml',
      'x-yaml': 'xyml',
    }
    await saveContentToFile(Promise.resolve(yamlData), fsMock, './static', extensionMap)
    await saveContentToFile(Promise.resolve(yamlData2), fsMock, './static', extensionMap)
    await saveContentToFile(Promise.resolve(htmlData), fsMock, './static', extensionMap)
    await saveContentToFile(Promise.resolve(htmlData), fsMock, './static', {
      ...defaultExtensionMap,
      ...extensionMap,
    })

    expect(fsMock.writeFile).toHaveBeenCalledWith('static/yaml.yml', yamlContent)
    expect(fsMock.writeFile).toHaveBeenCalledWith('static/yaml2.xyml', yamlContent)
    expect(fsMock.writeFile).toHaveBeenCalledWith('static/html.htm', yamlContent) // extensionMap
    expect(fsMock.writeFile).toHaveBeenCalledWith('static/html.html', yamlContent) // default + extensionMap
  })
})

describe('Dynamic route handling', () => {
  let app: Hono
  beforeEach(() => {
    app = new Hono()
    app.get('/shops/:id', (c) => c.html('Shop Page'))
    app.get('/shops/:id/:comments([0-9]+)', (c) => c.html('Comments Page'))
    app.get('/foo/*', (c) => c.html('Foo Page'))
    app.get('/foo:bar', (c) => c.html('Foo Bar Page'))
  })

  it('should skip /shops/:id dynamic route', async () => {
    const htmlMap = await resolveRoutesContent(fetchRoutesContent(app))
    expect(htmlMap.has('/shops/:id')).toBeFalsy()
  })

  it('should skip /shops/:id/:comments([0-9]+) dynamic route', async () => {
    const htmlMap = await resolveRoutesContent(fetchRoutesContent(app))
    expect(htmlMap.has('/shops/:id/:comments([0-9]+)')).toBeFalsy()
  })

  it('should skip /foo/* dynamic route', async () => {
    const htmlMap = await resolveRoutesContent(fetchRoutesContent(app))
    expect(htmlMap.has('/foo/*')).toBeFalsy()
  })

  it('should not skip /foo:bar dynamic route', async () => {
    const htmlMap = await resolveRoutesContent(fetchRoutesContent(app))
    expect(htmlMap.has('/foo:bar')).toBeTruthy()
  })
})

describe('isSSGContext()', () => {
  const app = new Hono()
  app.get('/', (c) => c.html(<h1>{isSSGContext(c) ? 'SSG' : 'noSSG'}</h1>))

  const fsMock: FileSystemModule = {
    writeFile: vi.fn(() => Promise.resolve()),
    mkdir: vi.fn(() => Promise.resolve()),
  }

  it('Should not generate the page if disableSSG is set', async () => {
    await toSSG(app, fsMock, { dir: './static' })
    expect(fsMock.writeFile).toHaveBeenCalledWith('static/index.html', '<h1>SSG</h1>')
  })

  it('Should return 404 response if onlySSG() is set', async () => {
    const res = await app.request('/')
    expect(await res.text()).toBe('<h1>noSSG</h1>')
  })
})

describe('disableSSG/onlySSG middlewares', () => {
  const app = new Hono()
  app.get('/', (c) => c.html(<h1>Hello</h1>))
  app.get('/api', disableSSG(), (c) => c.text('an-api'))
  app.get('/disable-by-response', (c) =>
    c.text('', 404, { [X_HONO_DISABLE_SSG_HEADER_KEY]: 'true' })
  )
  app.get('/static-page', onlySSG(), (c) => c.html(<h1>Welcome to my site</h1>))

  const fsMock: FileSystemModule = {
    writeFile: vi.fn(() => Promise.resolve()),
    mkdir: vi.fn(() => Promise.resolve()),
  }

  it('Should not generate the page if disableSSG is set', async () => {
    await toSSG(app, fsMock, { dir: './static' })
    expect(fsMock.writeFile).toHaveBeenCalledWith('static/index.html', expect.any(String))
    expect(fsMock.writeFile).toHaveBeenCalledWith('static/static-page.html', expect.any(String))
    expect(fsMock.writeFile).not.toHaveBeenCalledWith('static/api.html', expect.any(String))
    expect(fsMock.writeFile).not.toHaveBeenCalledWith(
      'static/disable-by-response.html',
      expect.any(String)
    )
  })

  it('Should return 404 response if onlySSG() is set', async () => {
    const res = await app.request('/static-page')
    expect(res.status).toBe(404)
  })
})

describe('Request hooks - filterPathsBeforeRequestHook and denyPathsBeforeRequestHook', () => {
  let app: Hono
  let fsMock: FileSystemModule

  const filterPathsBeforeRequestHook = (allowedPaths: string | string[]): BeforeRequestHook => {
    const baseURL = 'http://localhost'
    return async (req: Request): Promise<Request | false> => {
      const paths = Array.isArray(allowedPaths) ? allowedPaths : [allowedPaths]
      const pathname = new URL(req.url, baseURL).pathname

      if (paths.some((path) => pathname === path || pathname.startsWith(`${path}/`))) {
        return req
      }

      return false
    }
  }

  const denyPathsBeforeRequestHook = (deniedPaths: string | string[]): BeforeRequestHook => {
    const baseURL = 'http://localhost'
    return async (req: Request): Promise<Request | false> => {
      const paths = Array.isArray(deniedPaths) ? deniedPaths : [deniedPaths]
      const pathname = new URL(req.url, baseURL).pathname

      if (!paths.some((path) => pathname === path || pathname.startsWith(`${path}/`))) {
        return req
      }
      return false
    }
  }

  beforeEach(() => {
    app = new Hono()
    app.get('/allowed-path', (c) => c.html('Allowed Path Page'))
    app.get('/denied-path', (c) => c.html('Denied Path Page'))
    app.get('/other-path', (c) => c.html('Other Path Page'))

    fsMock = {
      writeFile: vi.fn(() => Promise.resolve()),
      mkdir: vi.fn(() => Promise.resolve()),
    }
  })

  it('should only process requests for allowed paths with filterPathsBeforeRequestHook', async () => {
    const allowedPathsHook = filterPathsBeforeRequestHook(['/allowed-path'])

    const result = await toSSG(app, fsMock, {
      dir: './static',
      beforeRequestHook: allowedPathsHook,
    })

    expect(result.files.some((file) => file.includes('allowed-path.html'))).toBe(true)
    expect(result.files.some((file) => file.includes('other-path.html'))).toBe(false)
  })

  it('should deny requests for specified paths with denyPathsBeforeRequestHook', async () => {
    const deniedPathsHook = denyPathsBeforeRequestHook(['/denied-path'])

    const result = await toSSG(app, fsMock, { dir: './static', beforeRequestHook: deniedPathsHook })

    expect(result.files.some((file) => file.includes('denied-path.html'))).toBe(false)

    expect(result.files.some((file) => file.includes('allowed-path.html'))).toBe(true)
    expect(result.files.some((file) => file.includes('other-path.html'))).toBe(true)
  })
})

describe('Combined Response hooks - modify response content', () => {
  let app: Hono
  let fsMock: FileSystemModule

  const prependContentAfterResponseHook = (prefix: string): AfterResponseHook => {
    return async (res: Response): Promise<Response> => {
      const originalText = await res.text()
      return new Response(`${prefix}${originalText}`, res)
    }
  }

  const appendContentAfterResponseHook = (suffix: string): AfterResponseHook => {
    return async (res: Response): Promise<Response> => {
      const originalText = await res.text()
      return new Response(`${originalText}${suffix}`, res)
    }
  }

  beforeEach(() => {
    app = new Hono()
    app.get('/content-path', (c) => c.text('Original Content'))

    fsMock = {
      writeFile: vi.fn(() => Promise.resolve()),
      mkdir: vi.fn(() => Promise.resolve()),
    }
  })

  it('should modify response content with combined AfterResponseHooks', async () => {
    const prefixHook = prependContentAfterResponseHook('Prefix-')
    const suffixHook = appendContentAfterResponseHook('-Suffix')

    const combinedHook = [prefixHook, suffixHook]

    await toSSG(app, fsMock, {
      dir: './static',
      afterResponseHook: combinedHook,
    })

    // Assert that the response content is modified by both hooks
    // This assumes you have a way to inspect the content of saved files or you need to mock/stub the Response text method correctly.
    expect(fsMock.writeFile).toHaveBeenCalledWith(
      'static/content-path.txt',
      'Prefix-Original Content-Suffix'
    )
  })
})

describe('Combined Generate hooks - AfterGenerateHook', () => {
  let app: Hono
  let fsMock: FileSystemModule

  const logResultAfterGenerateHook = (): AfterGenerateHook => {
    return async (result: ToSSGResult): Promise<void> => {
      console.log('Generation completed with status:', result.success) // Log the generation success
    }
  }

  const appendFilesAfterGenerateHook = (additionalFiles: string[]): AfterGenerateHook => {
    return async (result: ToSSGResult): Promise<void> => {
      result.files = result.files.concat(additionalFiles) // Append additional files to the result
    }
  }

  beforeEach(() => {
    app = new Hono()
    app.get('/path', (c) => c.text('Page Content'))

    fsMock = {
      writeFile: vi.fn(() => Promise.resolve()),
      mkdir: vi.fn(() => Promise.resolve()),
    }
  })

  it('should execute combined AfterGenerateHooks affecting the result', async () => {
    const logHook = logResultAfterGenerateHook()
    const appendHook = appendFilesAfterGenerateHook(['/extra/file1.html', '/extra/file2.html'])

    const combinedHook = [logHook, appendHook]

    const consoleSpy = vi.spyOn(console, 'log')
    const result = await toSSG(app, fsMock, {
      dir: './static',
      afterGenerateHook: combinedHook,
    })

    // Check that the log function was called correctly
    expect(consoleSpy).toHaveBeenCalledWith('Generation completed with status:', true)

    // Check that additional files were appended to the result
    expect(result.files).toContain('/extra/file1.html')
    expect(result.files).toContain('/extra/file2.html')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/ssg/ssg.ts
```typescript
import { replaceUrlParam } from '../../client/utils'
import type { Hono } from '../../hono'
import type { Env, Schema } from '../../types'
import { createPool } from '../../utils/concurrent'
import { getExtension } from '../../utils/mime'
import type { AddedSSGDataRequest, SSGParams } from './middleware'
import { SSG_CONTEXT, X_HONO_DISABLE_SSG_HEADER_KEY } from './middleware'
import { dirname, filterStaticGenerateRoutes, joinPaths } from './utils'

const DEFAULT_CONCURRENCY = 2 // default concurrency for ssg

// 'default_content_type' is designed according to Bun's performance optimization,
//  which omits Content-Type by default for text responses.
//  This is based on benchmarks showing performance gains without Content-Type.
//  In Hono, using `c.text()` without a Content-Type implicitly assumes 'text/plain; charset=UTF-8'.
//  This approach maintains performance consistency across different environments.
//  For details, see GitHub issues: oven-sh/bun#8530 and https://github.com/honojs/hono/issues/2284.
const DEFAULT_CONTENT_TYPE = 'text/plain'

/**
 * @experimental
 * `FileSystemModule` is an experimental feature.
 * The API might be changed.
 */
export interface FileSystemModule {
  writeFile(path: string, data: string | Uint8Array): Promise<void>
  mkdir(path: string, options: { recursive: boolean }): Promise<void | string>
}

/**
 * @experimental
 * `ToSSGResult` is an experimental feature.
 * The API might be changed.
 */
export interface ToSSGResult {
  success: boolean
  files: string[]
  error?: Error
}

const generateFilePath = (
  routePath: string,
  outDir: string,
  mimeType: string,
  extensionMap?: Record<string, string>
): string => {
  const extension = determineExtension(mimeType, extensionMap)

  if (routePath.endsWith(`.${extension}`)) {
    return joinPaths(outDir, routePath)
  }

  if (routePath === '/') {
    return joinPaths(outDir, `index.${extension}`)
  }
  if (routePath.endsWith('/')) {
    return joinPaths(outDir, routePath, `index.${extension}`)
  }
  return joinPaths(outDir, `${routePath}.${extension}`)
}

const parseResponseContent = async (response: Response): Promise<string | ArrayBuffer> => {
  const contentType = response.headers.get('Content-Type')

  try {
    if (contentType?.includes('text') || contentType?.includes('json')) {
      return await response.text()
    } else {
      return await response.arrayBuffer()
    }
  } catch (error) {
    throw new Error(
      `Error processing response: ${error instanceof Error ? error.message : 'Unknown error'}`
    )
  }
}

export const defaultExtensionMap: Record<string, string> = {
  'text/html': 'html',
  'text/xml': 'xml',
  'application/xml': 'xml',
  'application/yaml': 'yaml',
}

const determineExtension = (
  mimeType: string,
  userExtensionMap?: Record<string, string>
): string => {
  const extensionMap = userExtensionMap || defaultExtensionMap
  if (mimeType in extensionMap) {
    return extensionMap[mimeType]
  }
  return getExtension(mimeType) || 'html'
}

export type BeforeRequestHook = (req: Request) => Request | false | Promise<Request | false>
export type AfterResponseHook = (res: Response) => Response | false | Promise<Response | false>
export type AfterGenerateHook = (result: ToSSGResult) => void | Promise<void>

export const combineBeforeRequestHooks = (
  hooks: BeforeRequestHook | BeforeRequestHook[]
): BeforeRequestHook => {
  if (!Array.isArray(hooks)) {
    return hooks
  }
  return async (req: Request): Promise<Request | false> => {
    let currentReq = req
    for (const hook of hooks) {
      const result = await hook(currentReq)
      if (result === false) {
        return false
      }
      if (result instanceof Request) {
        currentReq = result
      }
    }
    return currentReq
  }
}

export const combineAfterResponseHooks = (
  hooks: AfterResponseHook | AfterResponseHook[]
): AfterResponseHook => {
  if (!Array.isArray(hooks)) {
    return hooks
  }
  return async (res: Response): Promise<Response | false> => {
    let currentRes = res
    for (const hook of hooks) {
      const result = await hook(currentRes)
      if (result === false) {
        return false
      }
      if (result instanceof Response) {
        currentRes = result
      }
    }
    return currentRes
  }
}

export const combineAfterGenerateHooks = (
  hooks: AfterGenerateHook | AfterGenerateHook[]
): AfterGenerateHook => {
  if (!Array.isArray(hooks)) {
    return hooks
  }
  return async (result: ToSSGResult): Promise<void> => {
    for (const hook of hooks) {
      await hook(result)
    }
  }
}

export interface ToSSGOptions {
  dir?: string
  beforeRequestHook?: BeforeRequestHook | BeforeRequestHook[]
  afterResponseHook?: AfterResponseHook | AfterResponseHook[]
  afterGenerateHook?: AfterGenerateHook | AfterGenerateHook[]
  concurrency?: number
  extensionMap?: Record<string, string>
}

/**
 * @experimental
 * `fetchRoutesContent` is an experimental feature.
 * The API might be changed.
 */
export const fetchRoutesContent = function* <
  E extends Env = Env,
  S extends Schema = {},
  BasePath extends string = '/'
>(
  app: Hono<E, S, BasePath>,
  beforeRequestHook?: BeforeRequestHook,
  afterResponseHook?: AfterResponseHook,
  concurrency?: number
): Generator<
  Promise<
    | Generator<
        Promise<{ routePath: string; mimeType: string; content: string | ArrayBuffer } | undefined>
      >
    | undefined
  >
> {
  const baseURL = 'http://localhost'
  const pool = createPool({ concurrency })

  for (const route of filterStaticGenerateRoutes(app)) {
    // GET Route Info
    const thisRouteBaseURL = new URL(route.path, baseURL).toString()

    let forGetInfoURLRequest = new Request(thisRouteBaseURL) as AddedSSGDataRequest

    // eslint-disable-next-line no-async-promise-executor
    yield new Promise(async (resolveGetInfo, rejectGetInfo) => {
      try {
        if (beforeRequestHook) {
          const maybeRequest = await beforeRequestHook(forGetInfoURLRequest)
          if (!maybeRequest) {
            resolveGetInfo(undefined)
            return
          }
          forGetInfoURLRequest = maybeRequest as unknown as AddedSSGDataRequest
        }

        await pool.run(() => app.fetch(forGetInfoURLRequest))

        if (!forGetInfoURLRequest.ssgParams) {
          if (isDynamicRoute(route.path)) {
            resolveGetInfo(undefined)
            return
          }
          forGetInfoURLRequest.ssgParams = [{}]
        }

        const requestInit = {
          method: forGetInfoURLRequest.method,
          headers: forGetInfoURLRequest.headers,
        }

        resolveGetInfo(
          (function* () {
            for (const param of forGetInfoURLRequest.ssgParams as SSGParams) {
              // eslint-disable-next-line no-async-promise-executor
              yield new Promise(async (resolveReq, rejectReq) => {
                try {
                  const replacedUrlParam = replaceUrlParam(route.path, param)
                  let response = await pool.run(() =>
                    app.request(replacedUrlParam, requestInit, {
                      [SSG_CONTEXT]: true,
                    })
                  )
                  if (response.headers.get(X_HONO_DISABLE_SSG_HEADER_KEY)) {
                    resolveReq(undefined)
                    return
                  }
                  if (afterResponseHook) {
                    const maybeResponse = await afterResponseHook(response)
                    if (!maybeResponse) {
                      resolveReq(undefined)
                      return
                    }
                    response = maybeResponse
                  }
                  const mimeType =
                    response.headers.get('Content-Type')?.split(';')[0] || DEFAULT_CONTENT_TYPE
                  const content = await parseResponseContent(response)
                  resolveReq({
                    routePath: replacedUrlParam,
                    mimeType,
                    content,
                  })
                } catch (error) {
                  rejectReq(error)
                }
              })
            }
          })()
        )
      } catch (error) {
        rejectGetInfo(error)
      }
    })
  }
}

const isDynamicRoute = (path: string): boolean => {
  return path.split('/').some((segment) => segment.startsWith(':') || segment.includes('*'))
}

/**
 * @experimental
 * `saveContentToFile` is an experimental feature.
 * The API might be changed.
 */
const createdDirs: Set<string> = new Set()
export const saveContentToFile = async (
  data: Promise<{ routePath: string; content: string | ArrayBuffer; mimeType: string } | undefined>,
  fsModule: FileSystemModule,
  outDir: string,
  extensionMap?: Record<string, string>
): Promise<string | undefined> => {
  const awaitedData = await data
  if (!awaitedData) {
    return
  }
  const { routePath, content, mimeType } = awaitedData
  const filePath = generateFilePath(routePath, outDir, mimeType, extensionMap)
  const dirPath = dirname(filePath)

  if (!createdDirs.has(dirPath)) {
    await fsModule.mkdir(dirPath, { recursive: true })
    createdDirs.add(dirPath)
  }
  if (typeof content === 'string') {
    await fsModule.writeFile(filePath, content)
  } else if (content instanceof ArrayBuffer) {
    await fsModule.writeFile(filePath, new Uint8Array(content))
  }
  return filePath
}

/**
 * @experimental
 * `ToSSGInterface` is an experimental feature.
 * The API might be changed.
 */
export interface ToSSGInterface {
  (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    app: Hono<any, any, any>,
    fsModule: FileSystemModule,
    options?: ToSSGOptions
  ): Promise<ToSSGResult>
}

/**
 * @experimental
 * `ToSSGAdaptorInterface` is an experimental feature.
 * The API might be changed.
 */
export interface ToSSGAdaptorInterface<
  E extends Env = Env,
  S extends Schema = {},
  BasePath extends string = '/'
> {
  (app: Hono<E, S, BasePath>, options?: ToSSGOptions): Promise<ToSSGResult>
}

/**
 * @experimental
 * `toSSG` is an experimental feature.
 * The API might be changed.
 */
export const toSSG: ToSSGInterface = async (app, fs, options) => {
  let result: ToSSGResult | undefined
  const getInfoPromises: Promise<unknown>[] = []
  const savePromises: Promise<string | undefined>[] = []
  try {
    const outputDir = options?.dir ?? './static'
    const concurrency = options?.concurrency ?? DEFAULT_CONCURRENCY

    const combinedBeforeRequestHook = combineBeforeRequestHooks(
      options?.beforeRequestHook || ((req) => req)
    )
    const combinedAfterResponseHook = combineAfterResponseHooks(
      options?.afterResponseHook || ((req) => req)
    )
    const getInfoGen = fetchRoutesContent(
      app,
      combinedBeforeRequestHook,
      combinedAfterResponseHook,
      concurrency
    )
    for (const getInfo of getInfoGen) {
      getInfoPromises.push(
        getInfo.then((getContentGen) => {
          if (!getContentGen) {
            return
          }
          for (const content of getContentGen) {
            savePromises.push(saveContentToFile(content, fs, outputDir).catch((e) => e))
          }
        })
      )
    }
    await Promise.all(getInfoPromises)
    const files: string[] = []
    for (const savePromise of savePromises) {
      const fileOrError = await savePromise
      if (typeof fileOrError === 'string') {
        files.push(fileOrError)
      } else if (fileOrError) {
        throw fileOrError
      }
    }
    result = { success: true, files }
  } catch (error) {
    const errorObj = error instanceof Error ? error : new Error(String(error))
    result = { success: false, files: [], error: errorObj }
  }
  if (options?.afterGenerateHook) {
    const combinedAfterGenerateHooks = combineAfterGenerateHooks(options?.afterGenerateHook)
    await combinedAfterGenerateHooks(result)
  }
  return result
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/ssg/utils.test.ts
```typescript
import { describe, expect, it } from 'vitest'
import { dirname, joinPaths } from './utils'

describe('joinPath', () => {
  it('Should joined path is valid.', () => {
    expect(joinPaths('test')).toBe('test') //single
    expect(joinPaths('.test')).toBe('.test') //single with dot
    expect(joinPaths('/.test')).toBe('/.test') //single with dot with root
    expect(joinPaths('test', 'test2')).toBe('test/test2') // single and single
    expect(joinPaths('test', 'test2', '../test3')).toBe('test/test3') // single and single and single with parent
    expect(joinPaths('.', '../')).toBe('..') // dot and parent
    expect(joinPaths('test/', 'test2/')).toBe('test/test2') // trailing slashes
    expect(joinPaths('./test', './test2')).toBe('test/test2') // dot and slash
    expect(joinPaths('', 'test')).toBe('test') // empty path
    expect(joinPaths('/test', '/test2')).toBe('/test/test2') // root path
    expect(joinPaths('../', 'test')).toBe('../test') // parent and single
    expect(joinPaths('test', '..', 'test2')).toBe('test2') // single triple dot and single
    expect(joinPaths('test', '...', 'test2')).toBe('test/.../test2') // single triple dot and single
    expect(joinPaths('test', './test2', '.test3.')).toBe('test/test2/.test3.') // single and single with slash and single with dot
    expect(joinPaths('test', '../', '.test2')).toBe('.test2') // single and parent and single with dot
    expect(joinPaths('..', '..', 'test')).toBe('../../test') // parent and parent and single
    expect(joinPaths('..', '..')).toBe('../..') // parent and parent
    expect(joinPaths('.test../test2/../')).toBe('.test..') //shuffle
    expect(joinPaths('.test./.test2/../')).toBe('.test.') //shuffle2
  })
  it('Should windows path is valid.', () => {
    expect(joinPaths('a\\b\\c', 'd\\e')).toBe('a/b/c/d/e')
  })
})
describe('dirname', () => {
  it('Should dirname is valid.', () => {
    expect(dirname('parent/child')).toBe('parent')
    expect(dirname('windows\\test.txt')).toBe('windows')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/ssg/utils.ts
```typescript
import type { Hono } from '../../hono'
import { METHOD_NAME_ALL } from '../../router'
import type { Env, RouterRoute } from '../../types'
import { findTargetHandler, isMiddleware } from '../../utils/handler'

/**
 * Get dirname
 * @param path File Path
 * @returns Parent dir path
 */
export const dirname = (path: string): string => {
  const separatedPath = path.split(/[\/\\]/)
  return separatedPath.slice(0, -1).join('/') // Windows supports slash path
}

const normalizePath = (path: string): string => {
  return path.replace(/(\\)/g, '/').replace(/\/$/g, '')
}

const handleParent = (resultPaths: string[], beforeParentFlag: boolean): void => {
  if (resultPaths.length === 0 || beforeParentFlag) {
    resultPaths.push('..')
  } else {
    resultPaths.pop()
  }
}

const handleNonDot = (path: string, resultPaths: string[]): void => {
  path = path.replace(/^\.(?!.)/, '')
  if (path !== '') {
    resultPaths.push(path)
  }
}

const handleSegments = (paths: string[], resultPaths: string[]): void => {
  let beforeParentFlag = false
  for (const path of paths) {
    // Handle `..`
    if (path === '..') {
      handleParent(resultPaths, beforeParentFlag)
      beforeParentFlag = true
    } else {
      // Handle `.` or `abc`
      handleNonDot(path, resultPaths)
      beforeParentFlag = false
    }
  }
}

export const joinPaths = (...paths: string[]): string => {
  paths = paths.map(normalizePath)
  const resultPaths: string[] = []
  handleSegments(paths.join('/').split('/'), resultPaths)
  return (paths[0][0] === '/' ? '/' : '') + resultPaths.join('/')
}

interface FilterStaticGenerateRouteData {
  path: string
}

export const filterStaticGenerateRoutes = <E extends Env>(
  hono: Hono<E>
): FilterStaticGenerateRouteData[] => {
  return hono.routes.reduce((acc, { method, handler, path }: RouterRoute) => {
    const targetHandler = findTargetHandler(handler)
    if (['GET', METHOD_NAME_ALL].includes(method) && !isMiddleware(targetHandler)) {
      acc.push({ path })
    }
    return acc
  }, [] as FilterStaticGenerateRouteData[])
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/testing/index.test.ts
```typescript
import { Hono } from '../../hono'
import { testClient } from '.'

describe('hono testClient', () => {
  it('Should return the correct search result', async () => {
    const app = new Hono().get('/search', (c) => c.json({ hello: 'world' }))
    const res = await testClient(app).search.$get()
    expect(await res.json()).toEqual({ hello: 'world' })
  })

  it('Should return the correct environment variables value', async () => {
    type Bindings = { hello: string }
    const app = new Hono<{ Bindings: Bindings }>().get('/search', (c) => {
      return c.json({ hello: c.env.hello })
    })
    const res = await testClient(app, { hello: 'world' }).search.$get()
    expect(await res.json()).toEqual({ hello: 'world' })
  })

  it('Should return a correct URL with out throwing an error', async () => {
    const app = new Hono().get('/abc', (c) => c.json(0))
    const url = testClient(app).abc.$url()
    expect(url.pathname).toBe('/abc')
  })

  it('Should not throw an error with $ws()', async () => {
    vi.stubGlobal('WebSocket', class {})
    const app = new Hono().get('/ws', (c) => c.text('Fake response of a WebSocket'))
    // @ts-expect-error $ws is not typed correctly
    expect(() => testClient(app).ws.$ws()).not.toThrowError()
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/testing/index.ts
```typescript
/**
 * @module
 * Testing Helper for Hono.
 */

import { hc } from '../../client'
import type { Client } from '../../client/types'
import type { ExecutionContext } from '../../context'
import type { Hono } from '../../hono'
import type { Schema } from '../../types'
import type { UnionToIntersection } from '../../utils/types'

type ExtractEnv<T> = T extends Hono<infer E, Schema, string> ? E : never

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const testClient = <T extends Hono<any, Schema, string>>(
  app: T,
  Env?: ExtractEnv<T>['Bindings'] | {},
  executionCtx?: ExecutionContext
): UnionToIntersection<Client<T>> => {
  const customFetch = (input: RequestInfo | URL, init?: RequestInit) => {
    return app.request(input, init, Env, executionCtx)
  }

  return hc<typeof app>('http://localhost', { fetch: customFetch })
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/accepts/accepts.test.ts
```typescript
import { Hono } from '../..'
import { parseAccept } from '../../utils/accept'
import type { Accept, acceptsConfig, acceptsOptions } from './accepts'
import { accepts, defaultMatch } from './accepts'

describe('parseAccept', () => {
  test('should parse accept header', () => {
    const acceptHeader =
      'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8;level=1;foo=bar'
    const accepts = parseAccept(acceptHeader)
    expect(accepts).toEqual([
      { type: 'text/html', params: {}, q: 1 },
      { type: 'application/xhtml+xml', params: {}, q: 1 },
      { type: 'image/webp', params: {}, q: 1 },
      { type: 'application/xml', params: { q: '0.9' }, q: 0.9 },
      { type: '*/*', params: { q: '0.8', level: '1', foo: 'bar' }, q: 0.8 },
    ])
  })
})

describe('defaultMatch', () => {
  test('should return default support', () => {
    const accepts: Accept[] = [
      { type: 'text/html', params: {}, q: 1 },
      { type: 'application/xhtml+xml', params: {}, q: 1 },
      { type: 'application/xml', params: { q: '0.9' }, q: 0.9 },
      { type: 'image/webp', params: {}, q: 1 },
      { type: '*/*', params: { q: '0.8' }, q: 0.8 },
    ]
    const config: acceptsConfig = {
      header: 'Accept',
      supports: ['text/html'],
      default: 'text/html',
    }
    const result = defaultMatch(accepts, config)
    expect(result).toBe('text/html')
  })
})

describe('accepts', () => {
  test('should return matched support', () => {
    const c = {
      req: {
        header: () => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } as any
    const options: acceptsConfig = {
      header: 'Accept',
      supports: ['application/xml', 'text/html'],
      default: 'application/json',
    }
    const result = accepts(c, options)
    expect(result).toBe('text/html')
  })

  test('should return default support if no matched support', () => {
    const c = {
      req: {
        header: () => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } as any
    const options: acceptsConfig = {
      header: 'Accept',
      supports: ['application/json'],
      default: 'text/html',
    }
    const result = accepts(c, options)
    expect(result).toBe('text/html')
  })

  test('should return default support if no accept header', () => {
    const c = {
      req: {
        header: () => undefined,
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } as any
    const options: acceptsConfig = {
      header: 'Accept',
      supports: ['application/json'],
      default: 'text/html',
    }
    const result = accepts(c, options)
    expect(result).toBe('text/html')
  })

  test('should return matched support with custom match function', () => {
    const c = {
      req: {
        header: () => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } as any
    // this match function will return the least q value
    const match = (accepts: Accept[], config: acceptsConfig) => {
      const { supports, default: defaultSupport } = config
      const accept = accepts
        .sort((a, b) => a.q - b.q)
        .find((accept) => supports.includes(accept.type))
      return accept ? accept.type : defaultSupport
    }
    const options: acceptsOptions = {
      header: 'Accept',
      supports: ['application/xml', 'text/html'],
      default: 'application/json',
      match,
    }
    const result = accepts(c, options)
    expect(result).toBe('application/xml')
  })
})

describe('Usage', () => {
  test('decide compression by Accept-Encoding header', async () => {
    const app = new Hono()
    app.get('/compressed', async (c) => {
      const encoding = accepts(c, {
        header: 'Accept-Encoding',
        supports: ['gzip', 'deflate'],
        default: 'identity',
      })
      const COMPRESS_DATA = 'COMPRESS_DATA'
      const readable = new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode(COMPRESS_DATA))
          controller.close()
        },
      })

      if (encoding === 'gzip') {
        c.header('Content-Encoding', 'gzip')
        return c.body(readable.pipeThrough(new CompressionStream('gzip')))
      }
      if (encoding === 'deflate') {
        c.header('Content-Encoding', 'deflate')
        return c.body(readable.pipeThrough(new CompressionStream('deflate')))
      }

      c.body(COMPRESS_DATA)
    })

    const req1 = await app.request('/compressed', { headers: { 'Accept-Encoding': 'deflate' } })
    const req2 = await app.request('/compressed', { headers: { 'Accept-Encoding': 'gzip' } })
    const req3 = await app.request('/compressed', {
      headers: { 'Accept-Encoding': 'gzip;q=0.5,deflate' },
    })
    const req4 = await app.request('/compressed', { headers: { 'Accept-Encoding': 'br' } })

    expect(req1.headers.get('Content-Encoding')).toBe('deflate')
    expect(req2.headers.get('Content-Encoding')).toBe('gzip')
    expect(req3.headers.get('Content-Encoding')).toBe('deflate')
    expect(req4.headers.get('Content-Encoding')).toBeNull()
  })

  test('decide language by Accept-Language header', async () => {
    const app = new Hono()
    const SUPPORTED_LANGS = ['en', 'ja', 'zh']
    app.get('/*', async (c) => {
      const lang = accepts(c, {
        header: 'Accept-Language',
        supports: SUPPORTED_LANGS,
        default: 'en',
      })
      const isLangedPath = SUPPORTED_LANGS.some((l) => c.req.path.startsWith(`/${l}`))
      if (isLangedPath) {
        return c.body(`lang: ${lang}`)
      }

      return c.redirect(`/${lang}${c.req.path}`)
    })

    const req1 = await app.request('/foo', { headers: { 'Accept-Language': 'en=0.8,ja' } })
    const req2 = await app.request('/en/foo', { headers: { 'Accept-Language': 'en' } })

    expect(req1.status).toBe(302)
    expect(req1.headers.get('Location')).toBe('/ja/foo')
    expect(await req2.text()).toBe('lang: en')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/accepts/accepts.ts
````typescript
import type { Context } from '../../context'
import { parseAccept } from '../../utils/accept'
import type { AcceptHeader } from '../../utils/headers'

export interface Accept {
  type: string
  params: Record<string, string>
  q: number
}

export interface acceptsConfig {
  header: AcceptHeader
  supports: string[]
  default: string
}

export interface acceptsOptions extends acceptsConfig {
  match?: (accepts: Accept[], config: acceptsConfig) => string
}

export const defaultMatch = (accepts: Accept[], config: acceptsConfig): string => {
  const { supports, default: defaultSupport } = config
  const accept = accepts.sort((a, b) => b.q - a.q).find((accept) => supports.includes(accept.type))
  return accept ? accept.type : defaultSupport
}

/**
 * Match the accept header with the given options.
 * @example
 * ```ts
 * app.get('/users', (c) => {
 *   const lang = accepts(c, {
 *     header: 'Accept-Language',
 *     supports: ['en', 'zh'],
 *     default: 'en',
 *   })
 * })
 * ```
 */
export const accepts = (c: Context, options: acceptsOptions): string => {
  const acceptHeader = c.req.header(options.header)
  if (!acceptHeader) {
    return options.default
  }
  const accepts = parseAccept(acceptHeader)
  const match = options.match || defaultMatch

  return match(accepts, options)
}

````
/Users/josh/Documents/GitHub/honojs/hono/src/helper/accepts/index.ts
```typescript
/**
 * @module
 * Accepts Helper for Hono.
 */

export { accepts } from './accepts'

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/dev/index.test.ts
```typescript
import { Hono } from '../../hono'
import { RegExpRouter } from '../../router/reg-exp-router'
import type { Handler, MiddlewareHandler } from '../../types'
import { getRouterName, inspectRoutes, showRoutes } from '.'

const namedMiddleware: MiddlewareHandler = (_, next) => next()
const namedHandler: Handler = (c) => c.text('hi')
const app = new Hono()
  .use('*', (c, next) => next())
  .get(
    '/',
    (_, next) => next(),
    (c) => c.text('hi')
  )
  .get('/named', namedMiddleware, namedHandler)
  .post('/', (c) => c.text('hi'))
  .put('/', (c) => c.text('hi'))
  .patch('/', (c) => c.text('hi'))
  .delete('/', (c) => c.text('hi'))
  .options('/', (c) => c.text('hi'))
  .get('/static', () => new Response('hi'))

describe('inspectRoutes()', () => {
  it('should return correct data', async () => {
    expect(inspectRoutes(app)).toEqual([
      { path: '/*', method: 'ALL', name: '[middleware]', isMiddleware: true },
      { path: '/', method: 'GET', name: '[middleware]', isMiddleware: true },
      { path: '/', method: 'GET', name: '[handler]', isMiddleware: false },
      { path: '/named', method: 'GET', name: 'namedMiddleware', isMiddleware: true },
      { path: '/named', method: 'GET', name: 'namedHandler', isMiddleware: false },
      { path: '/', method: 'POST', name: '[handler]', isMiddleware: false },
      { path: '/', method: 'PUT', name: '[handler]', isMiddleware: false },
      { path: '/', method: 'PATCH', name: '[handler]', isMiddleware: false },
      { path: '/', method: 'DELETE', name: '[handler]', isMiddleware: false },
      { path: '/', method: 'OPTIONS', name: '[handler]', isMiddleware: false },
      { path: '/static', method: 'GET', name: '[handler]', isMiddleware: false },
    ])
  })

  it('should return [handler] also for sub app', async () => {
    const subApp = new Hono()

    subApp.get('/', (c) => c.json(0))
    subApp.onError((_, c) => c.json(0))

    const mainApp = new Hono()
    mainApp.route('/', subApp)
    expect(inspectRoutes(mainApp)).toEqual([
      {
        isMiddleware: false,
        method: 'GET',
        name: '[handler]',
        path: '/',
      },
    ])
  })
})

describe('showRoutes()', () => {
  let logs: string[] = []

  let originalLog: typeof console.log
  beforeAll(() => {
    originalLog = console.log
    console.log = (...args) => logs.push(...args)
  })
  afterAll(() => {
    console.log = originalLog
  })

  beforeEach(() => {
    logs = []
  })
  it('should render simple output', async () => {
    showRoutes(app)
    expect(logs).toEqual([
      '\x1b[32mGET\x1b[0m      /',
      '\x1b[32mGET\x1b[0m      /named',
      '\x1b[32mPOST\x1b[0m     /',
      '\x1b[32mPUT\x1b[0m      /',
      '\x1b[32mPATCH\x1b[0m    /',
      '\x1b[32mDELETE\x1b[0m   /',
      '\x1b[32mOPTIONS\x1b[0m  /',
      '\x1b[32mGET\x1b[0m      /static',
    ])
  })

  it('should render output includes handlers and middlewares', async () => {
    showRoutes(app, { verbose: true })
    expect(logs).toEqual([
      '\x1b[32mALL\x1b[0m      /*',
      '           [middleware]',
      '\x1b[32mGET\x1b[0m      /',
      '           [middleware]',
      '           [handler]',
      '\x1b[32mGET\x1b[0m      /named',
      '           namedMiddleware',
      '           namedHandler',
      '\x1b[32mPOST\x1b[0m     /',
      '           [handler]',
      '\x1b[32mPUT\x1b[0m      /',
      '           [handler]',
      '\x1b[32mPATCH\x1b[0m    /',
      '           [handler]',
      '\x1b[32mDELETE\x1b[0m   /',
      '           [handler]',
      '\x1b[32mOPTIONS\x1b[0m  /',
      '           [handler]',
      '\x1b[32mGET\x1b[0m      /static',
      '           [handler]',
    ])
  })

  it('should render not colorized output', async () => {
    showRoutes(app, { colorize: false })
    expect(logs).toEqual([
      'GET      /',
      'GET      /named',
      'POST     /',
      'PUT      /',
      'PATCH    /',
      'DELETE   /',
      'OPTIONS  /',
      'GET      /static',
    ])
  })
})

describe('showRoutes() in NO_COLOR', () => {
  let logs: string[] = []

  let originalLog: typeof console.log
  beforeAll(() => {
    vi.stubEnv('NO_COLOR', '1')
    originalLog = console.log
    console.log = (...args) => logs.push(...args)
  })
  afterAll(() => {
    vi.unstubAllEnvs()
    console.log = originalLog
  })

  beforeEach(() => {
    logs = []
  })
  it('should render not colorized output', async () => {
    showRoutes(app)
    expect(logs).toEqual([
      'GET      /',
      'GET      /named',
      'POST     /',
      'PUT      /',
      'PATCH    /',
      'DELETE   /',
      'OPTIONS  /',
      'GET      /static',
    ])
  })
  it('should render colorized output if colorize: true', async () => {
    showRoutes(app, { colorize: true })
    expect(logs).toEqual([
      '\x1b[32mGET\x1b[0m      /',
      '\x1b[32mGET\x1b[0m      /named',
      '\x1b[32mPOST\x1b[0m     /',
      '\x1b[32mPUT\x1b[0m      /',
      '\x1b[32mPATCH\x1b[0m    /',
      '\x1b[32mDELETE\x1b[0m   /',
      '\x1b[32mOPTIONS\x1b[0m  /',
      '\x1b[32mGET\x1b[0m      /static',
    ])
  })
})

describe('getRouterName()', () => {
  it('Should return the correct router name', async () => {
    const app = new Hono({
      router: new RegExpRouter(),
    })
    expect(getRouterName(app)).toBe('RegExpRouter')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/dev/index.ts
```typescript
/**
 * @module
 * Dev Helper for Hono.
 */

import type { Hono } from '../../hono'
import type { Env, RouterRoute } from '../../types'
import { getColorEnabled } from '../../utils/color'
import { findTargetHandler, isMiddleware } from '../../utils/handler'

interface ShowRoutesOptions {
  verbose?: boolean
  colorize?: boolean
}

interface RouteData {
  path: string
  method: string
  name: string
  isMiddleware: boolean
}

const handlerName = (handler: Function): string => {
  return handler.name || (isMiddleware(handler) ? '[middleware]' : '[handler]')
}

export const inspectRoutes = <E extends Env>(hono: Hono<E>): RouteData[] => {
  return hono.routes.map(({ path, method, handler }: RouterRoute) => {
    const targetHandler = findTargetHandler(handler)
    return {
      path,
      method,
      name: handlerName(targetHandler),
      isMiddleware: isMiddleware(targetHandler),
    }
  })
}

export const showRoutes = <E extends Env>(hono: Hono<E>, opts?: ShowRoutesOptions): void => {
  const colorEnabled = opts?.colorize ?? getColorEnabled()
  const routeData: Record<string, RouteData[]> = {}
  let maxMethodLength = 0
  let maxPathLength = 0

  inspectRoutes(hono)
    .filter(({ isMiddleware }) => opts?.verbose || !isMiddleware)
    .map((route) => {
      const key = `${route.method}-${route.path}`
      ;(routeData[key] ||= []).push(route)
      if (routeData[key].length > 1) {
        return
      }
      maxMethodLength = Math.max(maxMethodLength, route.method.length)
      maxPathLength = Math.max(maxPathLength, route.path.length)
      return { method: route.method, path: route.path, routes: routeData[key] }
    })
    .forEach((data) => {
      if (!data) {
        return
      }
      const { method, path, routes } = data

      const methodStr = colorEnabled ? `\x1b[32m${method}\x1b[0m` : method
      console.log(`${methodStr} ${' '.repeat(maxMethodLength - method.length)} ${path}`)

      if (!opts?.verbose) {
        return
      }

      routes.forEach(({ name }) => {
        console.log(`${' '.repeat(maxMethodLength + 3)} ${name}`)
      })
    })
}

export const getRouterName = <E extends Env>(app: Hono<E>): string => {
  app.router.match('GET', '/')
  return app.router.name
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/cookie/index.test.ts
```typescript
import { Hono } from '../../hono'
import { deleteCookie, getCookie, getSignedCookie, setCookie, setSignedCookie } from '.'

describe('Cookie Middleware', () => {
  describe('Parse cookie', () => {
    const apps: Record<string, Hono> = {}
    apps['get by name'] = (() => {
      const app = new Hono()

      app.get('/cookie', (c) => {
        const yummyCookie = getCookie(c, 'yummy_cookie')
        const tastyCookie = getCookie(c, 'tasty_cookie')
        const res = new Response('Good cookie')
        if (yummyCookie && tastyCookie) {
          res.headers.set('Yummy-Cookie', yummyCookie)
          res.headers.set('Tasty-Cookie', tastyCookie)
        }
        return res
      })

      return app
    })()

    apps['get all as an object'] = (() => {
      const app = new Hono()

      app.get('/cookie', (c) => {
        const { yummy_cookie: yummyCookie, tasty_cookie: tastyCookie } = getCookie(c)
        const res = new Response('Good cookie')
        res.headers.set('Yummy-Cookie', yummyCookie)
        res.headers.set('Tasty-Cookie', tastyCookie)
        return res
      })

      return app
    })()

    describe.each(Object.keys(apps))('%s', (name) => {
      const app = apps[name]
      it('Parse cookie with getCookie()', async () => {
        const req = new Request('http://localhost/cookie')
        const cookieString = 'yummy_cookie=choco; tasty_cookie = strawberry'
        req.headers.set('Cookie', cookieString)
        const res = await app.request(req)

        expect(res.headers.get('Yummy-Cookie')).toBe('choco')
        expect(res.headers.get('Tasty-Cookie')).toBe('strawberry')
      })
    })

    const app = new Hono()

    app.get('/cookie-signed-get-all', async (c) => {
      const secret = 'secret lucky charm'
      const { fortune_cookie: fortuneCookie, fruit_cookie: fruitCookie } = await getSignedCookie(
        c,
        secret
      )
      const res = new Response('Signed fortune cookie')
      if (typeof fortuneCookie !== 'undefined' && typeof fruitCookie !== 'undefined') {
        // just examples for tests sake
        res.headers.set('Fortune-Cookie', fortuneCookie || 'INVALID')
        res.headers.set('Fruit-Cookie', fruitCookie || 'INVALID')
      }
      return res
    })

    app.get('/cookie-signed-get-one', async (c) => {
      const secret = 'secret lucky charm'
      const fortuneCookie = await getSignedCookie(c, secret, 'fortune_cookie')
      const res = new Response('Signed fortune cookie')
      if (typeof fortuneCookie !== 'undefined') {
        // just an example for tests sake
        res.headers.set('Fortune-Cookie', fortuneCookie || 'INVALID')
      }
      return res
    })

    it('Get signed cookies', async () => {
      const req = new Request('http://localhost/cookie-signed-get-all')
      const cookieString =
        'fortune_cookie=lots-of-money.UO6vMygDM6NCDU4LdvBnzdVb2Xcdj+h+ZTnmS8X7iH8%3D; fruit_cookie=mango.lRwgtW9ooM9%2Fd9ZZA%2FInNRG64CbQsfWGXQyFLPM9520%3D'
      req.headers.set('Cookie', cookieString)
      const res = await app.request(req)
      expect(res.headers.get('Fortune-Cookie')).toBe('lots-of-money')
      expect(res.headers.get('Fruit-Cookie')).toBe('mango')
    })

    it('Get signed cookies invalid signature', async () => {
      const req = new Request('http://localhost/cookie-signed-get-all')
      // fruit_cookie has invalid signature
      const cookieString =
        'fortune_cookie=lots-of-money.UO6vMygDM6NCDU4LdvBnzdVb2Xcdj+h+ZTnmS8X7iH8%3D; fruit_cookie=mango.LAa7RX43t2vCrLNcKmNG65H41OkyV02sraRPuY5RuVg%3D'
      req.headers.set('Cookie', cookieString)
      const res = await app.request(req)
      expect(res.headers.get('Fortune-Cookie')).toBe('lots-of-money')
      expect(res.headers.get('Fruit-Cookie')).toBe('INVALID')
    })

    it('Get signed cookie', async () => {
      const req = new Request('http://localhost/cookie-signed-get-one')
      const cookieString =
        'fortune_cookie=lots-of-money.UO6vMygDM6NCDU4LdvBnzdVb2Xcdj+h+ZTnmS8X7iH8%3D; fruit_cookie=mango.lRwgtW9ooM9%2Fd9ZZA%2FInNRG64CbQsfWGXQyFLPM9520%3D'
      req.headers.set('Cookie', cookieString)
      const res = await app.request(req)
      expect(res.headers.get('Fortune-Cookie')).toBe('lots-of-money')
    })

    it('Get signed cookie with invalid signature', async () => {
      const req = new Request('http://localhost/cookie-signed-get-one')
      // fortune_cookie has invalid signature
      const cookieString =
        'fortune_cookie=lots-of-money.LAa7RX43t2vCrLNcKmNG65H41OkyV02sraRPuY5RuVg=; fruit_cookie=mango.lRwgtW9ooM9%2Fd9ZZA%2FInNRG64CbQsfWGXQyFLPM9520%3D'
      req.headers.set('Cookie', cookieString)
      const res = await app.request(req)
      expect(res.headers.get('Fortune-Cookie')).toBe('INVALID')
    })

    describe('get null if the value is undefined', () => {
      const app = new Hono()

      app.get('/cookie', (c) => {
        const yummyCookie = getCookie(c, 'yummy_cookie')
        const res = new Response('Good cookie')
        if (yummyCookie) {
          res.headers.set('Yummy-Cookie', yummyCookie)
        }
        return res
      })

      it('Should be null', async () => {
        const req = new Request('http://localhost/cookie')
        const cookieString = 'yummy_cookie='
        req.headers.set('Cookie', cookieString)
        const res = await app.request(req)
        expect(res.headers.get('Yummy-Cookie')).toBe(null)
      })
    })
  })

  describe('Set cookie', () => {
    const app = new Hono()

    app.get('/set-cookie', (c) => {
      setCookie(c, 'delicious_cookie', 'macha')
      return c.text('Give cookie')
    })

    it('Set cookie with setCookie()', async () => {
      const res = await app.request('http://localhost/set-cookie')
      expect(res.status).toBe(200)
      const header = res.headers.get('Set-Cookie')
      expect(header).toBe('delicious_cookie=macha; Path=/')
    })

    app.get('/a/set-cookie-path', (c) => {
      setCookie(c, 'delicious_cookie', 'macha', { path: '/a' })
      return c.text('Give cookie')
    })

    it('Set cookie with setCookie() and path option', async () => {
      const res = await app.request('http://localhost/a/set-cookie-path')
      expect(res.status).toBe(200)
      const header = res.headers.get('Set-Cookie')
      expect(header).toBe('delicious_cookie=macha; Path=/a')
    })

    app.get('/set-signed-cookie', async (c) => {
      const secret = 'secret chocolate chips'
      await setSignedCookie(c, 'delicious_cookie', 'macha', secret)
      return c.text('Give signed cookie')
    })

    it('Set signed cookie with setSignedCookie()', async () => {
      const res = await app.request('http://localhost/set-signed-cookie')
      expect(res.status).toBe(200)
      const header = res.headers.get('Set-Cookie')
      expect(header).toBe(
        'delicious_cookie=macha.diubJPY8O7hI1pLa42QSfkPiyDWQ0I4DnlACH%2FN2HaA%3D; Path=/'
      )
    })

    app.get('/a/set-signed-cookie-path', async (c) => {
      const secret = 'secret chocolate chips'
      await setSignedCookie(c, 'delicious_cookie', 'macha', secret, { path: '/a' })
      return c.text('Give signed cookie')
    })

    it('Set signed cookie with setSignedCookie() and path option', async () => {
      const res = await app.request('http://localhost/a/set-signed-cookie-path')
      expect(res.status).toBe(200)
      const header = res.headers.get('Set-Cookie')
      expect(header).toBe(
        'delicious_cookie=macha.diubJPY8O7hI1pLa42QSfkPiyDWQ0I4DnlACH%2FN2HaA%3D; Path=/a'
      )
    })

    app.get('/get-secure-prefix-cookie', async (c) => {
      const cookie = getCookie(c, 'delicious_cookie', 'secure')
      if (cookie) {
        return c.text(cookie)
      } else {
        return c.notFound()
      }
    })

    app.get('/get-host-prefix-cookie', async (c) => {
      const cookie = getCookie(c, 'delicious_cookie', 'host')
      if (cookie) {
        return c.text(cookie)
      } else {
        return c.notFound()
      }
    })

    app.get('/set-secure-prefix-cookie', (c) => {
      setCookie(c, 'delicious_cookie', 'macha', {
        prefix: 'secure',
        secure: false, // this will be ignore
      })
      return c.text('Set secure prefix cookie')
    })

    it('Set cookie with secure prefix', async () => {
      const res = await app.request('http://localhost/set-secure-prefix-cookie')
      expect(res.status).toBe(200)
      const header = res.headers.get('Set-Cookie')
      expect(header).toBe('__Secure-delicious_cookie=macha; Path=/; Secure')
    })

    it('Get cookie with secure prefix', async () => {
      const setCookie = await app.request('http://localhost/set-secure-prefix-cookie')
      const header = setCookie.headers.get('Set-Cookie')
      if (!header) {
        assert.fail('invalid header')
      }
      const res = await app.request('http://localhost/get-secure-prefix-cookie', {
        headers: {
          Cookie: header,
        },
      })
      const response = await res.text()
      expect(res.status).toBe(200)
      expect(response).toBe('macha')
    })

    app.get('/set-host-prefix-cookie', (c) => {
      setCookie(c, 'delicious_cookie', 'macha', {
        prefix: 'host',
        path: '/foo', // this will be ignored
        domain: 'example.com', // this will be ignored
        secure: false, // this will be ignored
      })
      return c.text('Set host prefix cookie')
    })

    it('Set cookie with host prefix', async () => {
      const res = await app.request('http://localhost/set-host-prefix-cookie')
      expect(res.status).toBe(200)
      const header = res.headers.get('Set-Cookie')
      expect(header).toBe('__Host-delicious_cookie=macha; Path=/; Secure')
    })

    it('Get cookie with host prefix', async () => {
      const setCookie = await app.request('http://localhost/set-host-prefix-cookie')
      const header = setCookie.headers.get('Set-Cookie')
      if (!header) {
        assert.fail('invalid header')
      }
      const res = await app.request('http://localhost/get-host-prefix-cookie', {
        headers: {
          Cookie: header,
        },
      })
      const response = await res.text()
      expect(res.status).toBe(200)
      expect(response).toBe('macha')
    })

    app.get('/set-signed-secure-prefix-cookie', async (c) => {
      await setSignedCookie(c, 'delicious_cookie', 'macha', 'secret choco chips', {
        prefix: 'secure',
      })
      return c.text('Set secure prefix cookie')
    })

    it('Set signed cookie with secure prefix', async () => {
      const res = await app.request('http://localhost/set-signed-secure-prefix-cookie')
      expect(res.status).toBe(200)
      const header = res.headers.get('Set-Cookie')
      expect(header).toBe(
        '__Secure-delicious_cookie=macha.i225faTyCrJUY8TvpTuJHI20HBWbQ89B4GV7lT4E%2FB0%3D; Path=/; Secure'
      )
    })

    app.get('/set-signed-host-prefix-cookie', async (c) => {
      await setSignedCookie(c, 'delicious_cookie', 'macha', 'secret choco chips', {
        prefix: 'host',
        domain: 'example.com', // this will be ignored
        path: 'example.com', // thi will be ignored
        secure: false, // this will be ignored
      })
      return c.text('Set host prefix cookie')
    })

    it('Set signed cookie with host prefix', async () => {
      const res = await app.request('http://localhost/set-signed-host-prefix-cookie')
      expect(res.status).toBe(200)
      const header = res.headers.get('Set-Cookie')
      expect(header).toBe(
        '__Host-delicious_cookie=macha.i225faTyCrJUY8TvpTuJHI20HBWbQ89B4GV7lT4E%2FB0%3D; Path=/; Secure'
      )
    })

    app.get('/set-cookie-complex', (c) => {
      setCookie(c, 'great_cookie', 'banana', {
        path: '/',
        secure: true,
        domain: 'example.com',
        httpOnly: true,
        maxAge: 1000,
        expires: new Date(Date.UTC(2000, 11, 24, 10, 30, 59, 900)),
        sameSite: 'Strict',
      })
      return c.text('Give cookie')
    })

    it('Complex pattern', async () => {
      const res = await app.request('http://localhost/set-cookie-complex')
      expect(res.status).toBe(200)
      const header = res.headers.get('Set-Cookie')
      expect(header).toBe(
        'great_cookie=banana; Max-Age=1000; Domain=example.com; Path=/; Expires=Sun, 24 Dec 2000 10:30:59 GMT; HttpOnly; Secure; SameSite=Strict'
      )
    })

    app.get('/set-signed-cookie-complex', async (c) => {
      const secret = 'secret chocolate chips'
      await setSignedCookie(c, 'great_cookie', 'banana', secret, {
        path: '/',
        secure: true,
        domain: 'example.com',
        httpOnly: true,
        maxAge: 1000,
        expires: new Date(Date.UTC(2000, 11, 24, 10, 30, 59, 900)),
        sameSite: 'Strict',
      })
      return c.text('Give signed cookie')
    })

    it('Complex pattern (signed)', async () => {
      const res = await app.request('http://localhost/set-signed-cookie-complex')
      expect(res.status).toBe(200)
      const header = res.headers.get('Set-Cookie')
      expect(header).toBe(
        'great_cookie=banana.hSo6gB7YT2db0WBiEAakEmh7dtwEL0DSp76G23WvHuQ%3D; Max-Age=1000; Domain=example.com; Path=/; Expires=Sun, 24 Dec 2000 10:30:59 GMT; HttpOnly; Secure; SameSite=Strict'
      )
    })

    app.get('/set-cookie-multiple', (c) => {
      setCookie(c, 'delicious_cookie', 'macha')
      setCookie(c, 'delicious_cookie', 'choco')
      return c.text('Give cookie')
    })

    it('Multiple values', async () => {
      const res = await app.request('http://localhost/set-cookie-multiple')
      expect(res.status).toBe(200)
      const header = res.headers.get('Set-Cookie')
      expect(header).toBe('delicious_cookie=macha; Path=/, delicious_cookie=choco; Path=/')
    })
  })

  describe('Delete cookie', () => {
    const app = new Hono()

    app.get('/delete-cookie', (c) => {
      deleteCookie(c, 'delicious_cookie')
      return c.text('Give cookie')
    })

    it('Delete cookie', async () => {
      const res2 = await app.request('http://localhost/delete-cookie')
      expect(res2.status).toBe(200)
      const header2 = res2.headers.get('Set-Cookie')
      expect(header2).toBe('delicious_cookie=; Max-Age=0; Path=/')
    })

    app.get('/delete-cookie-multiple', (c) => {
      deleteCookie(c, 'delicious_cookie')
      deleteCookie(c, 'delicious_cookie2')
      return c.text('Give cookie')
    })

    it('Delete multiple cookies', async () => {
      const res2 = await app.request('http://localhost/delete-cookie-multiple')
      expect(res2.status).toBe(200)
      const header2 = res2.headers.get('Set-Cookie')
      expect(header2).toBe(
        'delicious_cookie=; Max-Age=0; Path=/, delicious_cookie2=; Max-Age=0; Path=/'
      )
    })

    app.get('/delete-cookie-with-options', (c) => {
      deleteCookie(c, 'delicious_cookie', {
        path: '/',
        secure: true,
        domain: 'example.com',
      })
      return c.text('Give cookie')
    })

    it('Delete cookie with options', async () => {
      const res2 = await app.request('http://localhost/delete-cookie-with-options')
      expect(res2.status).toBe(200)
      const header2 = res2.headers.get('Set-Cookie')
      expect(header2).toBe('delicious_cookie=; Max-Age=0; Domain=example.com; Path=/; Secure')
    })

    app.get('/delete-cookie-with-deleted-value', (c) => {
      const deleted = deleteCookie(c, 'delicious_cookie')
      return c.text(deleted || '')
    })

    it('Get deleted value', async () => {
      const cookieString = 'delicious_cookie=choco'
      const req = new Request('http://localhost/delete-cookie-with-deleted-value')
      req.headers.set('Cookie', cookieString)
      const res = await app.request(req)
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('choco')
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/cookie/index.ts
```typescript
/**
 * @module
 * Cookie Helper for Hono.
 */

import type { Context } from '../../context'
import { parse, parseSigned, serialize, serializeSigned } from '../../utils/cookie'
import type { Cookie, CookieOptions, CookiePrefixOptions, SignedCookie } from '../../utils/cookie'

interface GetCookie {
  (c: Context, key: string): string | undefined
  (c: Context): Cookie
  (c: Context, key: string, prefixOptions: CookiePrefixOptions): string | undefined
}

interface GetSignedCookie {
  (c: Context, secret: string | BufferSource, key: string): Promise<string | undefined | false>
  (c: Context, secret: string): Promise<SignedCookie>
  (
    c: Context,
    secret: string | BufferSource,
    key: string,
    prefixOptions: CookiePrefixOptions
  ): Promise<string | undefined | false>
}

export const getCookie: GetCookie = (c, key?, prefix?: CookiePrefixOptions) => {
  const cookie = c.req.raw.headers.get('Cookie')
  if (typeof key === 'string') {
    if (!cookie) {
      return undefined
    }
    let finalKey = key
    if (prefix === 'secure') {
      finalKey = '__Secure-' + key
    } else if (prefix === 'host') {
      finalKey = '__Host-' + key
    }
    const obj = parse(cookie, finalKey)
    return obj[finalKey]
  }
  if (!cookie) {
    return {}
  }
  const obj = parse(cookie)
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return obj as any
}

export const getSignedCookie: GetSignedCookie = async (
  c,
  secret,
  key?,
  prefix?: CookiePrefixOptions
) => {
  const cookie = c.req.raw.headers.get('Cookie')
  if (typeof key === 'string') {
    if (!cookie) {
      return undefined
    }
    let finalKey = key
    if (prefix === 'secure') {
      finalKey = '__Secure-' + key
    } else if (prefix === 'host') {
      finalKey = '__Host-' + key
    }
    const obj = await parseSigned(cookie, secret, finalKey)
    return obj[finalKey]
  }
  if (!cookie) {
    return {}
  }
  const obj = await parseSigned(cookie, secret)
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return obj as any
}

export const setCookie = (c: Context, name: string, value: string, opt?: CookieOptions): void => {
  // Cookie names prefixed with __Secure- can be used only if they are set with the secure attribute.
  // Cookie names prefixed with __Host- can be used only if they are set with the secure attribute, must have a path of / (meaning any path at the host)
  // and must not have a Domain attribute.
  // Read more at https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#cookie_prefixes'
  let cookie
  if (opt?.prefix === 'secure') {
    cookie = serialize('__Secure-' + name, value, { path: '/', ...opt, secure: true })
  } else if (opt?.prefix === 'host') {
    cookie = serialize('__Host-' + name, value, {
      ...opt,
      path: '/',
      secure: true,
      domain: undefined,
    })
  } else {
    cookie = serialize(name, value, { path: '/', ...opt })
  }
  c.header('Set-Cookie', cookie, { append: true })
}

export const setSignedCookie = async (
  c: Context,
  name: string,
  value: string,
  secret: string | BufferSource,
  opt?: CookieOptions
): Promise<void> => {
  let cookie
  if (opt?.prefix === 'secure') {
    cookie = await serializeSigned('__Secure-' + name, value, secret, {
      path: '/',
      ...opt,
      secure: true,
    })
  } else if (opt?.prefix === 'host') {
    cookie = await serializeSigned('__Host-' + name, value, secret, {
      ...opt,
      path: '/',
      secure: true,
      domain: undefined,
    })
  } else {
    cookie = await serializeSigned(name, value, secret, { path: '/', ...opt })
  }
  c.header('set-cookie', cookie, { append: true })
}

export const deleteCookie = (c: Context, name: string, opt?: CookieOptions): string | undefined => {
  const deletedCookie = getCookie(c, name)
  setCookie(c, name, '', { ...opt, maxAge: 0 })
  return deletedCookie
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/factory/index.test.ts
```typescript
/* eslint-disable @typescript-eslint/no-unused-vars */
import { expectTypeOf } from 'vitest'
import { hc } from '../../client'
import type { ClientRequest } from '../../client/types'
import { Hono } from '../../index'
import type { ExtractSchema, ToSchema, TypedResponse } from '../../types'
import type { ContentfulStatusCode } from '../../utils/http-status'
import type { Equal, Expect } from '../../utils/types'
import { validator } from '../../validator'
import { createFactory, createMiddleware } from './index'

describe('createMiddleware', () => {
  type Env = { Variables: { foo: string } }
  const app = new Hono()

  const mw = (message: string) =>
    createMiddleware<Env>(async (c, next) => {
      expectTypeOf(c.var.foo).toEqualTypeOf<string>()
      c.set('foo', 'bar')
      await next()
      c.header('X-Message', message)
    })

  const route = app.get('/message', mw('Hello Middleware'), (c) => {
    return c.text(`Hey, ${c.var.foo}`)
  })

  it('Should return the correct header and the content', async () => {
    const res = await app.request('/message')
    expect(res.status).toBe(200)
    expect(res.headers.get('x-message')).toBe('Hello Middleware')
    expect(await res.text()).toBe('Hey, bar')
  })

  it('Should provide the correct types', async () => {
    const client = hc<typeof route>('http://localhost')
    const url = client.message.$url()
    expect(url.pathname).toBe('/message')
  })

  it('Should pass generics types to chained handlers', () => {
    type Bindings = {
      MY_VAR_IN_BINDINGS: string
    }

    type Variables = {
      MY_VAR: string
    }

    const app = new Hono<{ Bindings: Bindings }>()

    app.get(
      '/',
      createMiddleware<{ Variables: Variables }>(async (c, next) => {
        await next()
      }),
      createMiddleware(async (c, next) => {
        await next()
      }),
      async (c) => {
        const v = c.get('MY_VAR')
        expectTypeOf(v).toEqualTypeOf<string>()
      }
    )
  })
})

describe('createHandler', () => {
  const mw = (message: string) =>
    createMiddleware(async (c, next) => {
      await next()
      c.header('x-message', message)
    })

  describe('Basic', () => {
    const factory = createFactory()
    const app = new Hono()

    const handlersA = factory.createHandlers((c) => {
      return c.text('A')
    })
    const routesA = app.get('/a', ...handlersA)

    const handlersB = factory.createHandlers(mw('B'), (c) => {
      return c.text('B')
    })
    app.get('/b', ...handlersB)

    it('Should return 200 response - GET /a', async () => {
      const res = await app.request('/a')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('A')
    })

    it('Should return 200 response with a custom header - GET /b', async () => {
      const res = await app.request('/b')
      expect(res.status).toBe(200)
      expect(res.headers.get('x-message')).toBe('B')
      expect(await res.text()).toBe('B')
    })

    it('Should return correct path types - /a', () => {
      const client = hc<typeof routesA>('/')
      expectTypeOf(client).toEqualTypeOf<{
        a: ClientRequest<{
          $get: {
            input: {}
            output: 'A'
            outputFormat: 'text'
            status: ContentfulStatusCode
          }
        }>
      }>()
    })
  })

  describe('Types', () => {
    type Env = { Variables: { foo: string } }

    const factory = createFactory<Env>()
    const app = new Hono<Env>()

    const handlers = factory.createHandlers(
      validator('query', () => {
        return {
          page: '1',
        }
      }),
      (c) => {
        const foo = c.var.foo
        const { page } = c.req.valid('query')
        return c.json({ page, foo })
      }
    )
    const routes = app.get('/posts', ...handlers)

    type Expected = Hono<
      Env,
      ToSchema<
        'get',
        '/posts',
        {
          in: {
            query: {
              page: string
            }
          }
        },
        TypedResponse<{
          page: string
          foo: string
        }>
      >,
      '/'
    >

    it('Should return correct types', () => {
      expectTypeOf(routes).toEqualTypeOf<Expected>()
    })
  })

  // It's difficult to cover all possible patterns,
  // so these tests will only cover the minimal cases.

  describe('Types - Complex', () => {
    type Env = { Variables: { foo: string } }

    const factory = createFactory<Env>()
    const app = new Hono<Env>()

    const handlers = factory.createHandlers(
      validator('header', () => {
        return {
          auth: 'token',
        }
      }),
      validator('query', () => {
        return {
          page: '1',
        }
      }),
      validator('json', () => {
        return {
          id: 123,
        }
      }),
      (c) => {
        const foo = c.var.foo
        const { auth } = c.req.valid('header')
        const { page } = c.req.valid('query')
        const { id } = c.req.valid('json')
        return c.json({ auth, page, foo, id })
      }
    )
    const routes = app.get('/posts', ...handlers)

    type Expected = Hono<
      Env,
      ToSchema<
        'get',
        '/posts',
        {
          in: {
            header: {
              auth: string
            }
          } & {
            query: {
              page: string
            }
          } & {
            json: {
              id: number
            }
          }
        },
        TypedResponse<{
          auth: string
          page: string
          foo: string
          id: number
        }>
      >,
      '/'
    >

    it('Should return correct types', () => {
      expectTypeOf(routes).toEqualTypeOf<Expected>()
    })
  })

  describe('Types - Context Env with Multiple Middlewares', () => {
    const factory = createFactory()

    const mw1 = createMiddleware<
      { Variables: { foo1: string } },
      string,
      { out: { query: { bar1: number } } }
    >(async () => {})
    const mw2 = createMiddleware<
      { Variables: { foo2: string } },
      string,
      { out: { query: { bar2: number } } }
    >(async () => {})
    const mw3 = createMiddleware<
      { Variables: { foo3: string } },
      string,
      { out: { query: { bar3: number } } }
    >(async () => {})
    const mw4 = createMiddleware<
      { Variables: { foo4: string } },
      string,
      { out: { query: { bar4: number } } }
    >(async () => {})
    const mw5 = createMiddleware<
      { Variables: { foo5: string } },
      string,
      { out: { query: { bar5: number } } }
    >(async () => {})
    const mw6 = createMiddleware<
      { Variables: { foo6: string } },
      string,
      { out: { query: { bar6: number } } }
    >(async () => {})
    const mw7 = createMiddleware<
      { Variables: { foo7: string } },
      string,
      { out: { query: { bar7: number } } }
    >(async () => {})
    const mw8 = createMiddleware<
      { Variables: { foo8: string } },
      string,
      { out: { query: { bar8: number } } }
    >(async () => {})
    const mw9 = createMiddleware<
      { Variables: { foo9: string } },
      string,
      { out: { query: { bar9: number } } }
    >(async () => {})

    it('Should not throw type error', () => {
      factory.createHandlers(
        mw1,
        mw2,
        mw3,
        mw4,
        mw5,
        mw6,
        mw7,
        mw8,
        async (c) => {
          expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
          expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
          expectTypeOf(c.var.foo3).toEqualTypeOf<string>()
          expectTypeOf(c.var.foo4).toEqualTypeOf<string>()
          expectTypeOf(c.var.foo5).toEqualTypeOf<string>()
          expectTypeOf(c.var.foo6).toEqualTypeOf<string>()
          expectTypeOf(c.var.foo7).toEqualTypeOf<string>()
          expectTypeOf(c.var.foo8).toEqualTypeOf<string>()
        },
        (c) => c.json(0)
      )

      factory.createHandlers(mw1, mw2, mw3, mw4, mw5, mw6, mw7, mw8, mw9, (c) => {
        expectTypeOf(c.var.foo1).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo2).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo3).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo4).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo5).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo6).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo7).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo8).toEqualTypeOf<string>()
        expectTypeOf(c.var.foo9).toEqualTypeOf<string>()

        return c.json({
          foo1: c.get('foo1'),
          foo2: c.get('foo2'),
          foo3: c.get('foo3'),
          foo4: c.get('foo4'),
          foo5: c.get('foo5'),
          foo6: c.get('foo6'),
          foo7: c.get('foo7'),
          foo8: c.get('foo8'),
          foo9: c.get('foo9'),
        })
      })
    })
  })
})

describe('createFactory', () => {
  describe('createApp', () => {
    type Env = { Variables: { foo: string } }
    const factory = createFactory<Env>({
      initApp: (app) => {
        app.use((c, next) => {
          c.set('foo', 'bar')
          return next()
        })
      },
    })
    const app = factory.createApp()
    it('Should set the correct type and initialize the app', async () => {
      app.get('/', (c) => {
        expectTypeOf(c.var.foo).toEqualTypeOf<string>()
        return c.text(c.var.foo)
      })
      const res = await app.request('/')
      expect(res.status).toBe(200)
      expect(await res.text()).toBe('bar')
    })
  })

  describe('createMiddleware', () => {
    it('Should set the correct type', () => {
      const factory = createFactory()

      const middleware = factory.createMiddleware(async (_, next) => {
        await next()
      })

      const routes = new Hono().use('*', middleware)
      type Actual = ExtractSchema<typeof routes>
      type Expected = {
        '*': {}
      }
      type verify = Expect<Equal<Expected, Actual>>
    })
  })

  it('Should use the default app options', async () => {
    const app = createFactory({ defaultAppOptions: { strict: false } }).createApp()
    app.get('/hello', (c) => c.text('hello'))
    const res = await app.request('/hello/')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hello')
  })

  it('Should override the default app options when creating', async () => {
    const app = createFactory({ defaultAppOptions: { strict: true } }).createApp({ strict: false })
    app.get('/hello', (c) => c.text('hello'))
    const res = await app.request('/hello/')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('hello')
  })
})

describe('Lint rules', () => {
  it('Should not throw a eslint `unbound-method` error if destructed', () => {
    const { createApp, createHandlers, createMiddleware } = createFactory()
    expect(createApp).toBeDefined()
    expect(createHandlers).toBeDefined()
    expect(createMiddleware).toBeDefined()
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/helper/factory/index.ts
```typescript
/**
 * @module
 * Factory Helper for Hono.
 */

/* eslint-disable @typescript-eslint/no-explicit-any */
import { Hono } from '../../hono'
import type { HonoOptions } from '../../hono-base'
import type {
  Env,
  H,
  HandlerResponse,
  Input,
  IntersectNonAnyTypes,
  MiddlewareHandler,
} from '../../types'

type InitApp<E extends Env = Env> = (app: Hono<E>) => void

export interface CreateHandlersInterface<E extends Env, P extends string> {
  <I extends Input = {}, R extends HandlerResponse<any> = any, E2 extends Env = E>(
    handler1: H<E2, P, I, R>
  ): [H<E2, P, I, R>]

  // handler x2
  <
    I extends Input = {},
    I2 extends Input = I,
    R extends HandlerResponse<any> = any,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>
  >(
    handler1: H<E2, P, I, R>,
    handler2: H<E3, P, I2, R>
  ): [H<E2, P, I, R>, H<E3, P, I2, R>]

  // handler x3
  <
    I extends Input = {},
    I2 extends Input = I,
    I3 extends Input = I & I2,
    R extends HandlerResponse<any> = any,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>
  >(
    handler1: H<E2, P, I, R>,
    handler2: H<E3, P, I2, R>,
    handler3: H<E4, P, I3, R>
  ): [H<E2, P, I, R>, H<E3, P, I2, R>, H<E4, P, I3, R>]

  // handler x4
  <
    I extends Input = {},
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    R extends HandlerResponse<any> = any,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>
  >(
    handler1: H<E2, P, I, R>,
    handler2: H<E3, P, I2, R>,
    handler3: H<E4, P, I3, R>,
    handler4: H<E5, P, I4, R>
  ): [H<E2, P, I, R>, H<E3, P, I2, R>, H<E4, P, I3, R>, H<E5, P, I4, R>]

  // handler x5
  <
    I extends Input = {},
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    R extends HandlerResponse<any> = any,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>
  >(
    handler1: H<E2, P, I, R>,
    handler2: H<E3, P, I2, R>,
    handler3: H<E4, P, I3, R>,
    handler4: H<E5, P, I4, R>,
    handler5: H<E6, P, I5, R>
  ): [H<E2, P, I, R>, H<E3, P, I2, R>, H<E4, P, I3, R>, H<E5, P, I4, R>, H<E6, P, I5, R>]

  // handler x6
  <
    I extends Input = {},
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    R extends HandlerResponse<any> = any,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>
  >(
    handler1: H<E2, P, I, R>,
    handler2: H<E3, P, I2, R>,
    handler3: H<E4, P, I3, R>,
    handler4: H<E5, P, I4, R>,
    handler5: H<E6, P, I5, R>,
    handler6: H<E7, P, I6, R>
  ): [
    H<E2, P, I, R>,
    H<E3, P, I2, R>,
    H<E4, P, I3, R>,
    H<E5, P, I4, R>,
    H<E6, P, I5, R>,
    H<E7, P, I6, R>
  ]

  // handler x7
  <
    I extends Input = {},
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    I7 extends Input = I & I2 & I3 & I4 & I5 & I6,
    R extends HandlerResponse<any> = any,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>
  >(
    handler1: H<E2, P, I, R>,
    handler2: H<E3, P, I2, R>,
    handler3: H<E4, P, I3, R>,
    handler4: H<E5, P, I4, R>,
    handler5: H<E6, P, I5, R>,
    handler6: H<E7, P, I6, R>,
    handler7: H<E8, P, I7, R>
  ): [
    H<E2, P, I, R>,
    H<E3, P, I2, R>,
    H<E4, P, I3, R>,
    H<E5, P, I4, R>,
    H<E6, P, I5, R>,
    H<E7, P, I6, R>,
    H<E8, P, I7, R>
  ]

  // handler x8
  <
    I extends Input = {},
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    I7 extends Input = I & I2 & I3 & I4 & I5 & I6,
    I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7,
    R extends HandlerResponse<any> = any,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    E9 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>
  >(
    handler1: H<E2, P, I, R>,
    handler2: H<E3, P, I2, R>,
    handler3: H<E4, P, I3, R>,
    handler4: H<E5, P, I4, R>,
    handler5: H<E6, P, I5, R>,
    handler6: H<E7, P, I6, R>,
    handler7: H<E8, P, I7, R>,
    handler8: H<E9, P, I8, R>
  ): [
    H<E2, P, I, R>,
    H<E3, P, I2, R>,
    H<E4, P, I3, R>,
    H<E5, P, I4, R>,
    H<E6, P, I5, R>,
    H<E7, P, I6, R>,
    H<E8, P, I7, R>,
    H<E9, P, I8, R>
  ]

  // handler x9
  <
    I extends Input = {},
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    I7 extends Input = I & I2 & I3 & I4 & I5 & I6,
    I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7,
    I9 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8,
    R extends HandlerResponse<any> = any,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    E9 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>,
    E10 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9]>
  >(
    handler1: H<E2, P, I, R>,
    handler2: H<E3, P, I2, R>,
    handler3: H<E4, P, I3, R>,
    handler4: H<E5, P, I4, R>,
    handler5: H<E6, P, I5, R>,
    handler6: H<E7, P, I6, R>,
    handler7: H<E8, P, I7, R>,
    handler8: H<E9, P, I8, R>,
    handler9: H<E10, P, I9, R>
  ): [
    H<E2, P, I, R>,
    H<E3, P, I2, R>,
    H<E4, P, I3, R>,
    H<E5, P, I4, R>,
    H<E6, P, I5, R>,
    H<E7, P, I6, R>,
    H<E8, P, I7, R>,
    H<E9, P, I8, R>,
    H<E10, P, I9, R>
  ]

  // handler x10
  <
    I extends Input = {},
    I2 extends Input = I,
    I3 extends Input = I & I2,
    I4 extends Input = I & I2 & I3,
    I5 extends Input = I & I2 & I3 & I4,
    I6 extends Input = I & I2 & I3 & I4 & I5,
    I7 extends Input = I & I2 & I3 & I4 & I5 & I6,
    I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7,
    I9 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8,
    I10 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8 & I9,
    R extends HandlerResponse<any> = any,
    E2 extends Env = E,
    E3 extends Env = IntersectNonAnyTypes<[E, E2]>,
    E4 extends Env = IntersectNonAnyTypes<[E, E2, E3]>,
    E5 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4]>,
    E6 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5]>,
    E7 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6]>,
    E8 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7]>,
    E9 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8]>,
    E10 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9]>,
    E11 extends Env = IntersectNonAnyTypes<[E, E2, E3, E4, E5, E6, E7, E8, E9, E10]>
  >(
    handler1: H<E2, P, I, R>,
    handler2: H<E3, P, I2, R>,
    handler3: H<E4, P, I3, R>,
    handler4: H<E5, P, I4, R>,
    handler5: H<E6, P, I5, R>,
    handler6: H<E7, P, I6, R>,
    handler7: H<E8, P, I7, R>,
    handler8: H<E9, P, I8, R>,
    handler9: H<E10, P, I9, R>,
    handler10: H<E11, P, I10, R>
  ): [
    H<E2, P, I, R>,
    H<E3, P, I2, R>,
    H<E4, P, I3, R>,
    H<E5, P, I4, R>,
    H<E6, P, I5, R>,
    H<E7, P, I6, R>,
    H<E8, P, I7, R>,
    H<E9, P, I8, R>,
    H<E10, P, I9, R>,
    H<E11, P, I10, R>
  ]
}

export class Factory<E extends Env = Env, P extends string = string> {
  private initApp?: InitApp<E>
  #defaultAppOptions?: HonoOptions<E>

  constructor(init?: { initApp?: InitApp<E>; defaultAppOptions?: HonoOptions<E> }) {
    this.initApp = init?.initApp
    this.#defaultAppOptions = init?.defaultAppOptions
  }

  createApp = (options?: HonoOptions<E>): Hono<E> => {
    const app = new Hono<E>(
      options && this.#defaultAppOptions
        ? { ...this.#defaultAppOptions, ...options }
        : options ?? this.#defaultAppOptions
    )
    if (this.initApp) {
      this.initApp(app)
    }
    return app
  }

  createMiddleware = <I extends Input = {}>(
    middleware: MiddlewareHandler<E, P, I>
  ): MiddlewareHandler<E, P, I> => middleware

  createHandlers: CreateHandlersInterface<E, P> = (...handlers: any) => {
    // @ts-expect-error this should not be typed
    return handlers.filter((handler) => handler !== undefined)
  }
}

export const createFactory = <E extends Env = Env, P extends string = string>(init?: {
  initApp?: InitApp<E>
  defaultAppOptions?: HonoOptions<E>
}): Factory<E, P> => new Factory<E, P>(init)

export const createMiddleware = <
  E extends Env = any,
  P extends string = string,
  I extends Input = {}
>(
  middleware: MiddlewareHandler<E, P, I>
): MiddlewareHandler<E, P, I> => middleware

```
/Users/josh/Documents/GitHub/honojs/hono/src/client/client.test.ts
```typescript
/* eslint-disable @typescript-eslint/no-unused-vars */

/* eslint-disable @typescript-eslint/ban-ts-comment */
import { HttpResponse, http } from 'msw'
import { setupServer } from 'msw/node'
import { expectTypeOf, vi } from 'vitest'
import { upgradeWebSocket } from '../adapter/deno/websocket'
import { Hono } from '../hono'
import { parse } from '../utils/cookie'
import type { Equal, Expect, JSONValue, SimplifyDeepArray } from '../utils/types'
import { validator } from '../validator'
import { hc } from './client'
import type { ClientResponse, InferRequestType, InferResponseType } from './types'

describe('Basic - JSON', () => {
  const app = new Hono()

  const route = app
    .post(
      '/posts',
      validator('cookie', () => {
        return {} as {
          debug: string
        }
      }),
      validator('header', () => {
        return {} as {
          'x-message': string
        }
      }),
      validator('json', () => {
        return {} as {
          id: number
          title: string
        }
      }),
      (c) => {
        return c.json({
          success: true,
          message: 'dummy',
          requestContentType: 'dummy',
          requestHono: 'dummy',
          requestMessage: 'dummy',
          requestBody: {
            id: 123,
            title: 'dummy',
          },
        })
      }
    )
    .get('/hello-not-found', (c) => c.notFound())
    .get('/null', (c) => c.json(null))
    .get('/empty', (c) => c.json({}))

  type AppType = typeof route

  const server = setupServer(
    http.post('http://localhost/posts', async ({ request }) => {
      const requestContentType = request.headers.get('content-type')
      const requestHono = request.headers.get('x-hono')
      const requestMessage = request.headers.get('x-message')
      const requestBody = await request.json()
      const payload = {
        message: 'Hello!',
        success: true,
        requestContentType,
        requestHono,
        requestMessage,
        requestBody,
      }
      return HttpResponse.json(payload)
    }),
    http.get('http://localhost/hello-not-found', () => {
      return HttpResponse.text(null, {
        status: 404,
      })
    }),
    http.get('http://localhost/null', () => {
      return HttpResponse.json(null)
    }),
    http.get('http://localhost/empty', () => {
      return HttpResponse.json({})
    }),
    http.get('http://localhost/api/string', () => {
      return HttpResponse.json('a-string')
    }),
    http.get('http://localhost/api/number', async () => {
      return HttpResponse.json(37)
    }),
    http.get('http://localhost/api/boolean', async () => {
      return HttpResponse.json(true)
    }),
    http.get('http://localhost/api/generic', async () => {
      return HttpResponse.json(Math.random() > 0.5 ? Boolean(Math.random()) : Math.random())
    })
  )

  beforeAll(() => server.listen())
  afterEach(() => server.resetHandlers())
  afterAll(() => server.close())

  const payload = {
    id: 123,
    title: 'Hello! Hono!',
  }

  const client = hc<AppType>('http://localhost', { headers: { 'x-hono': 'hono' } })

  it('Should get 200 response', async () => {
    const res = await client.posts.$post(
      {
        json: payload,
        header: {
          'x-message': 'foobar',
        },
        cookie: {
          debug: 'true',
        },
      },
      {}
    )

    expect(res.ok).toBe(true)
    const data = await res.json()
    expect(data.success).toBe(true)
    expect(data.message).toBe('Hello!')
    expect(data.requestContentType).toBe('application/json')
    expect(data.requestHono).toBe('hono')
    expect(data.requestMessage).toBe('foobar')
    expect(data.requestBody).toEqual(payload)
  })

  it('Should get 404 response', async () => {
    const res = await client['hello-not-found'].$get()
    expect(res.status).toBe(404)
  })

  it('Should get a `null` content', async () => {
    const client = hc<AppType>('http://localhost')
    const res = await client.null.$get()
    const data = await res.json()
    expectTypeOf(data).toMatchTypeOf<null>()
    expect(data).toBe(null)
  })

  it('Should get a `{}` content', async () => {
    const client = hc<AppType>('http://localhost')
    const res = await client.empty.$get()
    const data = await res.json()
    expectTypeOf(data).toMatchTypeOf<{}>()
    expect(data).toStrictEqual({})
  })

  it('Should have correct types - primitives', async () => {
    const app = new Hono()
    const route = app
      .get('/api/string', (c) => c.json('a-string'))
      .get('/api/number', (c) => c.json(37))
      .get('/api/boolean', (c) => c.json(true))
      .get('/api/generic', (c) =>
        c.json(Math.random() > 0.5 ? Boolean(Math.random()) : Math.random())
      )
    type AppType = typeof route
    const client = hc<AppType>('http://localhost')
    const stringFetch = await client.api.string.$get()
    const stringRes = await stringFetch.json()
    const numberFetch = await client.api.number.$get()
    const numberRes = await numberFetch.json()
    const booleanFetch = await client.api.boolean.$get()
    const booleanRes = await booleanFetch.json()
    const genericFetch = await client.api.generic.$get()
    const genericRes = await genericFetch.json()
    type stringVerify = Expect<Equal<'a-string', typeof stringRes>>
    expect(stringRes).toBe('a-string')
    type numberVerify = Expect<Equal<37, typeof numberRes>>
    expect(numberRes).toBe(37)
    type booleanVerify = Expect<Equal<true, typeof booleanRes>>
    expect(booleanRes).toBe(true)
    type genericVerify = Expect<Equal<number | boolean, typeof genericRes>>
    expect(typeof genericRes === 'number' || typeof genericRes === 'boolean').toBe(true)

    // using .text() on json endpoint should return string
    type textTest = Expect<Equal<Promise<string>, ReturnType<typeof genericFetch.text>>>
  })
})

describe('Basic - query, queries, form, path params, header and cookie', () => {
  const app = new Hono()

  const route = app
    .get(
      '/search',
      validator('query', () => {
        return {} as { q: string; tag: string[]; filter: string }
      }),
      (c) => {
        return c.json({
          q: 'fake',
          tag: ['fake'],
          filter: 'fake',
        })
      }
    )
    .put(
      '/posts/:id',
      validator('form', () => {
        return {
          title: 'Hello',
        }
      }),
      (c) => {
        const data = c.req.valid('form')
        return c.json(data)
      }
    )
    .get(
      '/header',
      validator('header', () => {
        return {
          'x-message-id': 'Hello',
        }
      }),
      (c) => {
        const data = c.req.valid('header')
        return c.json(data)
      }
    )
    .get(
      '/cookie',
      validator('cookie', () => {
        return {
          hello: 'world',
        }
      }),
      (c) => {
        const data = c.req.valid('cookie')
        return c.json(data)
      }
    )

  const server = setupServer(
    http.get('http://localhost/api/search', ({ request }) => {
      const url = new URL(request.url)
      const query = url.searchParams.get('q')
      const tag = url.searchParams.getAll('tag')
      const filter = url.searchParams.get('filter')
      return HttpResponse.json({
        q: query,
        tag,
        filter,
      })
    }),
    http.get('http://localhost/api/posts', ({ request }) => {
      const url = new URL(request.url)
      const tags = url.searchParams.getAll('tags')
      return HttpResponse.json({
        tags: tags,
      })
    }),
    http.put('http://localhost/api/posts/123', async ({ request }) => {
      const buffer = await request.arrayBuffer()
      // @ts-ignore
      const string = String.fromCharCode.apply('', new Uint8Array(buffer))
      return HttpResponse.text(string)
    }),
    http.get('http://localhost/api/header', async ({ request }) => {
      const message = await request.headers.get('x-message-id')
      return HttpResponse.json({ 'x-message-id': message })
    }),
    http.get('http://localhost/api/cookie', async ({ request }) => {
      const obj = parse(request.headers.get('cookie') || '')
      const value = obj['hello']
      return HttpResponse.json({ hello: value })
    })
  )

  beforeAll(() => server.listen())
  afterEach(() => server.resetHandlers())
  afterAll(() => server.close())

  type AppType = typeof route

  const client = hc<AppType>('http://localhost/api')

  it('Should get 200 response - query', async () => {
    const res = await client.search.$get({
      query: {
        q: 'foobar',
        tag: ['a', 'b'],
        // @ts-expect-error
        filter: undefined,
      },
    })

    expect(res.status).toBe(200)
    expect(await res.json()).toEqual({
      q: 'foobar',
      tag: ['a', 'b'],
      filter: null,
    })
  })

  it('Should get 200 response - form, params', async () => {
    const res = await client.posts[':id'].$put({
      form: {
        title: 'Good Night',
      },
      param: {
        id: '123',
      },
    })

    expect(res.status).toBe(200)
    expect(await res.text()).toMatch('Good Night')
  })

  it('Should get 200 response - header', async () => {
    const header = {
      'x-message-id': 'Hello',
    }
    const res = await client.header.$get({
      header,
    })

    expect(res.status).toBe(200)
    expect(await res.json()).toEqual(header)
  })

  it('Should get 200 response - cookie', async () => {
    const cookie = {
      hello: 'world',
    }
    const res = await client.cookie.$get({
      cookie,
    })

    expect(res.status).toBe(200)
    expect(await res.json()).toEqual(cookie)
  })
})

describe('Form - Multiple Values', () => {
  const server = setupServer(
    http.post('http://localhost/multiple-values', async ({ request }) => {
      const data = await request.formData()
      return HttpResponse.json(data.getAll('key'))
    })
  )

  beforeAll(() => server.listen())
  afterEach(() => server.resetHandlers())
  afterAll(() => server.close())

  const client = hc('http://localhost/')

  it('Should get 200 response - query', async () => {
    // @ts-expect-error `client['multiple-values'].$post` is not typed
    const res = await client['multiple-values'].$post({
      form: {
        key: ['foo', 'bar'],
      },
    })
    expect(res.status).toBe(200)
    expect(await res.json()).toEqual(['foo', 'bar'])
  })
})

describe('Infer the response/request type', () => {
  const app = new Hono()
  const route = app.get(
    '/',
    validator('query', () => {
      return {
        name: 'dummy',
        age: 'dummy',
      }
    }),
    validator('header', () => {
      return {
        'x-request-id': 'dummy',
      }
    }),
    validator('cookie', () => {
      return {
        name: 'dummy',
      }
    }),
    (c) =>
      c.json({
        id: 123,
        title: 'Morning!',
      })
  )

  type AppType = typeof route

  it('Should infer response type the type correctly', () => {
    const client = hc<AppType>('/')
    const req = client.index.$get

    type Actual = InferResponseType<typeof req>
    type Expected = {
      id: number
      title: string
    }
    type verify = Expect<Equal<Expected, Actual>>
  })

  it('Should infer request type the type correctly', () => {
    const client = hc<AppType>('/')
    const req = client.index.$get

    type Actual = InferRequestType<typeof req>
    type Expected = {
      age: string | string[]
      name: string | string[]
    }
    type verify = Expect<Equal<Expected, Actual['query']>>
  })

  it('Should infer request header type the type correctly', () => {
    const client = hc<AppType>('/')
    const req = client.index.$get
    type c = typeof req

    type Actual = InferRequestType<c>
    type Expected = {
      'x-request-id': string
    }
    type verify = Expect<Equal<Expected, Actual['header']>>
  })

  it('Should infer request cookie type the type correctly', () => {
    const client = hc<AppType>('/')
    const req = client.index.$get
    type c = typeof req

    type Actual = InferRequestType<c>
    type Expected = {
      name: string
    }
    type verify = Expect<Equal<Expected, Actual['cookie']>>
  })

  describe('Without input', () => {
    const route = app.get('/', (c) => c.json({ ok: true }))
    type AppType = typeof route

    it('Should infer response type the type correctly', () => {
      const client = hc<AppType>('/')
      const req = client.index.$get

      type Actual = InferResponseType<typeof req>
      type Expected = { ok: boolean }
      type verify = Expect<Equal<Expected, Actual>>
    })

    it('Should infer request type the type correctly', () => {
      const client = hc<AppType>('/')
      const req = client.index.$get

      type Actual = InferRequestType<typeof req>
      type Expected = {}
      type verify = Expect<Equal<Expected, Actual>>
    })
  })
})

describe('Merge path with `app.route()`', () => {
  const server = setupServer(
    http.get('http://localhost/api/search', async () => {
      return HttpResponse.json({
        ok: true,
      })
    }),
    http.get('http://localhost/api/searchArray', async () => {
      return HttpResponse.json([
        {
          ok: true,
        },
      ])
    }),
    http.get('http://localhost/api/foo', async () => {
      return HttpResponse.json({
        ok: true,
      })
    }),
    http.post('http://localhost/api/bar', async () => {
      return HttpResponse.json({
        ok: true,
      })
    }),
    http.get('http://localhost/v1/book', async () => {
      return HttpResponse.json({
        ok: true,
      })
    })
  )

  beforeAll(() => server.listen())
  afterEach(() => server.resetHandlers())
  afterAll(() => server.close())

  type Env = {
    Bindings: {
      TOKEN: string
    }
  }

  it('Should have correct types', async () => {
    const api = new Hono<Env>().get('/search', (c) => c.json({ ok: true }))
    const app = new Hono<Env>().route('/api', api)
    type AppType = typeof app
    const client = hc<AppType>('http://localhost')
    const res = await client.api.search.$get()
    const data = await res.json()
    type verify = Expect<Equal<boolean, typeof data.ok>>
    expect(data.ok).toBe(true)
  })

  it('Should have correct types - basePath() then get()', async () => {
    const base = new Hono<Env>().basePath('/api')
    const app = base.get('/search', (c) => c.json({ ok: true }))
    type AppType = typeof app
    const client = hc<AppType>('http://localhost')
    const res = await client.api.search.$get()
    const data = await res.json()
    type verify = Expect<Equal<boolean, typeof data.ok>>
    expect(data.ok).toBe(true)
  })

  it('Should have correct types - basePath(), route(), get()', async () => {
    const book = new Hono().get('/', (c) => c.json({ ok: true }))
    const app = new Hono().basePath('/v1').route('/book', book)
    type AppType = typeof app
    const client = hc<AppType>('http://localhost')
    const res = await client.v1.book.$get()
    const data = await res.json()
    type verify = Expect<Equal<boolean, typeof data.ok>>
    expect(data.ok).toBe(true)
  })

  it('Should have correct types - with interface', async () => {
    interface Result {
      ok: boolean
      okUndefined?: boolean
    }
    const result: Result = { ok: true }
    const base = new Hono<Env>().basePath('/api')
    const app = base.get('/search', (c) => c.json(result))
    type AppType = typeof app
    const client = hc<AppType>('http://localhost')
    const res = await client.api.search.$get()
    const data = await res.json()
    type verify = Expect<Equal<Result, typeof data>>
    expect(data.ok).toBe(true)

    // A few more types only tests
    interface DeepInterface {
      l2: {
        l3: Result
      }
    }
    interface ExtraDeepInterface {
      l4: DeepInterface
    }
    type verifyDeepInterface = Expect<
      Equal<SimplifyDeepArray<DeepInterface> extends JSONValue ? true : false, true>
    >
    type verifyExtraDeepInterface = Expect<
      Equal<SimplifyDeepArray<ExtraDeepInterface> extends JSONValue ? true : false, true>
    >
  })

  it('Should have correct types - with array of interfaces', async () => {
    interface Result {
      ok: boolean
      okUndefined?: boolean
    }
    type Results = Result[]

    const results: Results = [{ ok: true }]
    const base = new Hono<Env>().basePath('/api')
    const app = base.get('/searchArray', (c) => c.json(results))
    type AppType = typeof app
    const client = hc<AppType>('http://localhost')
    const res = await client.api.searchArray.$get()
    const data = await res.json()
    type verify = Expect<Equal<Results, typeof data>>
    expect(data[0].ok).toBe(true)

    // A few more types only tests
    type verifyNestedArrayTyped = Expect<
      Equal<SimplifyDeepArray<[string, Results]> extends JSONValue ? true : false, true>
    >
    type verifyNestedArrayInterfaceArray = Expect<
      Equal<SimplifyDeepArray<[string, Result[]]> extends JSONValue ? true : false, true>
    >
    type verifyExtraNestedArrayTyped = Expect<
      Equal<SimplifyDeepArray<[string, Results[]]> extends JSONValue ? true : false, true>
    >
    type verifyExtraNestedArrayInterfaceArray = Expect<
      Equal<SimplifyDeepArray<[string, Result[][]]> extends JSONValue ? true : false, true>
    >
  })

  it('Should allow a Date object and return it as a string', async () => {
    const app = new Hono()
    const route = app.get('/api/foo', (c) => c.json({ datetime: new Date() }))
    type AppType = typeof route
    const client = hc<AppType>('http://localhost')
    const res = await client.api.foo.$get()
    const { datetime } = await res.json()
    type verify = Expect<Equal<string, typeof datetime>>
  })

  describe('Multiple endpoints', () => {
    const api = new Hono()
      .get('/foo', (c) => c.json({ foo: '' }))
      .post('/bar', (c) => c.json({ bar: 0 }))
    const app = new Hono().route('/api', api)
    type AppType = typeof app
    const client = hc<typeof app>('http://localhost')

    it('Should return correct types - GET /api/foo', async () => {
      const res = await client.api.foo.$get()
      const data = await res.json()
      type verify = Expect<Equal<string, typeof data.foo>>
    })

    it('Should return correct types - POST /api/bar', async () => {
      const res = await client.api.bar.$post()
      const data = await res.json()
      type verify = Expect<Equal<number, typeof data.bar>>
    })
    it('Should work with $url', async () => {
      const url = client.api.bar.$url()
      expect(url.href).toBe('http://localhost/api/bar')
    })
  })

  describe('With a blank path', () => {
    const app = new Hono().basePath('/api/v1')
    const routes = app.route(
      '/me',
      new Hono().route(
        '',
        new Hono().get('', async (c) => {
          return c.json({ name: 'hono' })
        })
      )
    )
    const client = hc<typeof routes>('http://localhost')

    it('Should infer paths correctly', async () => {
      // Should not a throw type error
      const url = client.api.v1.me.$url()
      expectTypeOf<URL>(url)
      expect(url.href).toBe('http://localhost/api/v1/me')
    })
  })
})

describe('Use custom fetch method', () => {
  it('Should call the custom fetch method when provided', async () => {
    const fetchMock = vi.fn()

    const api = new Hono().get('/search', (c) => c.json({ ok: true }))
    const app = new Hono().route('/api', api)
    type AppType = typeof app
    const client = hc<AppType>('http://localhost', { fetch: fetchMock })
    await client.api.search.$get()
    expect(fetchMock).toHaveBeenCalledTimes(1)
  })

  it('Should return Response from custom fetch method', async () => {
    const fetchMock = vi.fn()
    const returnValue = new Response(null, { status: 200 })
    fetchMock.mockReturnValueOnce(returnValue)

    const api = new Hono().get('/search', (c) => c.json({ ok: true }))
    const app = new Hono().route('/api', api)
    type AppType = typeof app
    const client = hc<AppType>('http://localhost', { fetch: fetchMock })
    const res = await client.api.search.$get()
    expect(res.ok).toBe(true)
    expect(res).toEqual(returnValue)
  })
})

describe('Use custom fetch (app.request) method', () => {
  it('Should return Response from app request method', async () => {
    const app = new Hono().get('/search', (c) => c.json({ ok: true }))
    type AppType = typeof app
    const client = hc<AppType>('', { fetch: app.request })
    const res = await client.search.$get()
    expect(res.ok).toBe(true)
  })
})

describe('Optional parameters in JSON response', () => {
  it('Should return the correct type', async () => {
    const app = new Hono().get('/', (c) => {
      return c.json({ message: 'foo' } as { message?: string })
    })
    type AppType = typeof app
    const client = hc<AppType>('', { fetch: app.request })
    const res = await client.index.$get()
    const data = await res.json()
    expectTypeOf(data).toEqualTypeOf<{
      message?: string
    }>()
  })
})

describe('ClientResponse<T>.json() returns a Union type correctly', () => {
  const condition = () => true
  const app = new Hono().get('/', async (c) => {
    const ok = condition()
    if (ok) {
      return c.json({ data: 'foo' })
    }
    return c.json({ message: 'error' })
  })

  const client = hc<typeof app>('', { fetch: app.request })
  it('Should be a Union type', async () => {
    const res = await client.index.$get()
    const json = await res.json()
    expectTypeOf(json).toEqualTypeOf<{ data: string } | { message: string }>()
  })
})

describe('Response with different status codes', () => {
  const condition = () => true
  const app = new Hono().get('/', async (c) => {
    const ok = condition()
    if (ok) {
      return c.json({ data: 'foo' }, 200)
    }
    if (!ok) {
      return c.json({ message: 'error' }, 400)
    }
    return c.json(null)
  })

  const client = hc<typeof app>('', { fetch: app.request })

  it('all', async () => {
    const res = await client.index.$get()
    const json = await res.json()
    expectTypeOf(json).toEqualTypeOf<{ data: string } | { message: string } | null>()
  })

  it('status 200', async () => {
    const res = await client.index.$get()
    if (res.status === 200) {
      const json = await res.json()
      expectTypeOf(json).toEqualTypeOf<{ data: string } | null>()
    }
  })

  it('status 400', async () => {
    const res = await client.index.$get()
    if (res.status === 400) {
      const json = await res.json()
      expectTypeOf(json).toEqualTypeOf<{ message: string } | null>()
    }
  })

  it('response is ok', async () => {
    const res = await client.index.$get()
    if (res.ok) {
      const json = await res.json()
      expectTypeOf(json).toEqualTypeOf<{ data: string } | null>()
    }
  })

  it('response is not ok', async () => {
    const res = await client.index.$get()
    if (!res.ok) {
      const json = await res.json()
      expectTypeOf(json).toEqualTypeOf<{ message: string } | null>()
    }
  })
})

describe('Infer the response type with different status codes', () => {
  const condition = () => true
  const app = new Hono().get('/', async (c) => {
    const ok = condition()
    if (ok) {
      return c.json({ data: 'foo' }, 200)
    }
    if (!ok) {
      return c.json({ message: 'error' }, 400)
    }
    return c.json(null)
  })

  const client = hc<typeof app>('', { fetch: app.request })

  it('Should infer response type correctly', () => {
    const req = client.index.$get

    type Actual = InferResponseType<typeof req>
    type Expected =
      | {
          data: string
        }
      | {
          message: string
        }
      | null
    type verify = Expect<Equal<Expected, Actual>>
  })

  it('Should infer response type of status 200 correctly', () => {
    const req = client.index.$get

    type Actual = InferResponseType<typeof req, 200>
    type Expected = {
      data: string
    } | null
    type verify = Expect<Equal<Expected, Actual>>
  })
})

describe('$url() with a param option', () => {
  const app = new Hono()
    .get('/posts/:id/comments', (c) => c.json({ ok: true }))
    .get('/something/:firstId/:secondId/:version?', (c) => c.json({ ok: true }))
  type AppType = typeof app
  const client = hc<AppType>('http://localhost')

  it('Should return the correct path - /posts/123/comments', async () => {
    const url = client.posts[':id'].comments.$url({
      param: {
        id: '123',
      },
    })
    expect(url.pathname).toBe('/posts/123/comments')
  })

  it('Should return the correct path - /posts/:id/comments', async () => {
    const url = client.posts[':id'].comments.$url()
    expect(url.pathname).toBe('/posts/:id/comments')
  })

  it('Should return the correct path - /something/123/456', async () => {
    const url = client.something[':firstId'][':secondId'][':version?'].$url({
      param: {
        firstId: '123',
        secondId: '456',
        version: undefined,
      },
    })
    expect(url.pathname).toBe('/something/123/456')
  })
})

describe('$url() with a query option', () => {
  const app = new Hono().get(
    '/posts',
    validator('query', () => {
      return {} as { filter: 'test' }
    }),
    (c) => c.json({ ok: true })
  )
  type AppType = typeof app
  const client = hc<AppType>('http://localhost')

  it('Should return the correct path - /posts?filter=test', async () => {
    const url = client.posts.$url({
      query: {
        filter: 'test',
      },
    })
    expect(url.search).toBe('?filter=test')
  })
})

describe('Client can be awaited', () => {
  it('Can be awaited without side effects', async () => {
    const client = hc('http://localhost')

    const awaited = await client

    expect(awaited).toEqual(client)
  })
})

describe('Dynamic headers', () => {
  const app = new Hono()

  const route = app.post('/posts', (c) => {
    return c.json({
      requestDynamic: 'dummy',
    })
  })

  type AppType = typeof route

  const server = setupServer(
    http.post('http://localhost/posts', async ({ request }) => {
      const requestDynamic = request.headers.get('x-dynamic')
      const payload = {
        requestDynamic,
      }
      return HttpResponse.json(payload)
    })
  )

  beforeAll(() => server.listen())
  afterEach(() => server.resetHandlers())
  afterAll(() => server.close())

  let dynamic = ''

  const client = hc<AppType>('http://localhost', {
    headers: () => ({ 'x-hono': 'hono', 'x-dynamic': dynamic }),
  })

  it('Should have "x-dynamic": "one"', async () => {
    dynamic = 'one'

    const res = await client.posts.$post()

    expect(res.ok).toBe(true)
    const data = await res.json()
    expect(data.requestDynamic).toEqual('one')
  })

  it('Should have "x-dynamic": "two"', async () => {
    dynamic = 'two'

    const res = await client.posts.$post()

    expect(res.ok).toBe(true)
    const data = await res.json()
    expect(data.requestDynamic).toEqual('two')
  })
})

describe('RequestInit work as expected', () => {
  const app = new Hono()

  const route = app
    .get('/credentials', (c) => {
      return c.text('' as RequestCredentials)
    })
    .get('/headers', (c) => {
      return c.json({} as Record<string, string>)
    })
    .post('/headers', (c) => c.text('Not found', 404))

  type AppType = typeof route

  const server = setupServer(
    http.get('http://localhost/credentials', ({ request }) => {
      return HttpResponse.text(request.credentials)
    }),
    http.get('http://localhost/headers', ({ request }) => {
      const allHeaders: Record<string, string> = {}
      for (const [k, v] of request.headers.entries()) {
        allHeaders[k] = v
      }

      return HttpResponse.json(allHeaders)
    }),
    http.post('http://localhost/headers', () => {
      return HttpResponse.text('Should not be here', {
        status: 400,
      })
    })
  )

  beforeAll(() => server.listen())
  afterEach(() => server.resetHandlers())
  afterAll(() => server.close())

  const client = hc<AppType>('http://localhost', {
    headers: { 'x-hono': 'fire' },
    init: {
      credentials: 'include',
    },
  })

  it('Should overwrite method and fail', async () => {
    const res = await client.headers.$get(undefined, { init: { method: 'POST' } })

    expect(res.ok).toBe(false)
  })

  it('Should clear headers', async () => {
    const res = await client.headers.$get(undefined, { init: { headers: undefined } })

    expect(res.ok).toBe(true)
    const data = await res.json()
    expect(data).toEqual({})
  })

  it('Should overwrite headers', async () => {
    const res = await client.headers.$get(undefined, {
      init: { headers: new Headers({ 'x-hono': 'awesome' }) },
    })

    expect(res.ok).toBe(true)
    const data = await res.json()
    expect(data).toEqual({ 'x-hono': 'awesome' })
  })

  it('credentials is include', async () => {
    const res = await client.credentials.$get()

    expect(res.ok).toBe(true)
    const data = await res.text()
    expect(data).toEqual('include')
  })

  it('deepMerge should works and not unset credentials', async () => {
    const res = await client.credentials.$get(undefined, { init: { headers: { hi: 'hello' } } })

    expect(res.ok).toBe(true)
    const data = await res.text()
    expect(data).toEqual('include')
  })

  it('Should unset credentials', async () => {
    const res = await client.credentials.$get(undefined, { init: { credentials: undefined } })

    expect(res.ok).toBe(true)
    const data = await res.text()
    expect(data).toEqual('same-origin')
  })
})

describe('WebSocket URL Protocol Translation', () => {
  const app = new Hono()
  const route = app.get(
    '/',
    upgradeWebSocket((c) => ({
      onMessage(event, ws) {
        console.log(`Message from client: ${event.data}`)
        ws.send('Hello from server!')
      },
      onClose: () => {
        console.log('Connection closed')
      },
    }))
  )

  type AppType = typeof route

  const server = setupServer()
  const webSocketMock = vi.fn()

  beforeAll(() => server.listen())
  beforeEach(() => {
    vi.stubGlobal('WebSocket', webSocketMock)
  })
  afterEach(() => {
    vi.clearAllMocks()
    server.resetHandlers()
  })
  afterAll(() => server.close())

  it('Translates HTTP to ws', async () => {
    const client = hc<AppType>('http://localhost')
    client.index.$ws()
    expect(webSocketMock).toHaveBeenCalledWith('ws://localhost/index')
  })

  it('Translates HTTPS to wss', async () => {
    const client = hc<AppType>('https://localhost')
    client.index.$ws()
    expect(webSocketMock).toHaveBeenCalledWith('wss://localhost/index')
  })

  it('Keeps ws unchanged', async () => {
    const client = hc<AppType>('ws://localhost')
    client.index.$ws()
    expect(webSocketMock).toHaveBeenCalledWith('ws://localhost/index')
  })

  it('Keeps wss unchanged', async () => {
    const client = hc<AppType>('wss://localhost')
    client.index.$ws()
    expect(webSocketMock).toHaveBeenCalledWith('wss://localhost/index')
  })
})

describe('WebSocket URL Protocol Translation with Query Parameters', () => {
  const app = new Hono()
  const route = app.get(
    '/',
    upgradeWebSocket((c) => ({
      onMessage(event, ws) {
        ws.send('Hello from server!')
      },
      onClose: () => {
        console.log('Connection closed')
      },
    }))
  )

  type AppType = typeof route

  const server = setupServer()
  const webSocketMock = vi.fn()

  beforeAll(() => server.listen())
  beforeEach(() => {
    vi.stubGlobal('WebSocket', webSocketMock)
  })
  afterEach(() => {
    vi.clearAllMocks()
    server.resetHandlers()
  })
  afterAll(() => server.close())

  it('Translates HTTP to ws and includes query parameters', async () => {
    const client = hc<AppType>('http://localhost')
    client.index.$ws({
      query: {
        id: '123',
        type: 'test',
        tag: ['a', 'b'],
      },
    })
    expect(webSocketMock).toHaveBeenCalledWith('ws://localhost/index?id=123&type=test&tag=a&tag=b')
  })

  it('Translates HTTPS to wss and includes query parameters', async () => {
    const client = hc<AppType>('https://localhost')
    client.index.$ws({
      query: {
        id: '456',
        type: 'secure',
      },
    })
    expect(webSocketMock).toHaveBeenCalledWith('wss://localhost/index?id=456&type=secure')
  })

  it('Keeps ws unchanged and includes query parameters', async () => {
    const client = hc<AppType>('ws://localhost')
    client.index.$ws({
      query: {
        id: '789',
        type: 'plain',
      },
    })
    expect(webSocketMock).toHaveBeenCalledWith('ws://localhost/index?id=789&type=plain')
  })

  it('Keeps wss unchanged and includes query parameters', async () => {
    const client = hc<AppType>('wss://localhost')
    client.index.$ws({
      query: {
        id: '1011',
        type: 'secure',
      },
    })
    expect(webSocketMock).toHaveBeenCalledWith('wss://localhost/index?id=1011&type=secure')
  })
})

describe('Client can be console.log in react native', () => {
  it('Returns a function name with function.name.toString', async () => {
    const client = hc('http://localhost')
    // @ts-ignore
    expect(client.posts.name.toString()).toEqual('posts')
  })

  it('Returns a function name with function.name.valueOf', async () => {
    const client = hc('http://localhost')
    // @ts-ignore
    expect(client.posts.name.valueOf()).toEqual('posts')
  })

  it('Returns a function with function.valueOf', async () => {
    const client = hc('http://localhost')
    expect(typeof client.posts.valueOf()).toEqual('function')
  })

  it('Returns a function source with function.toString', async () => {
    const client = hc('http://localhost')
    expect(client.posts.toString()).toMatch('function proxyCallback')
  })
})

describe('Text response', () => {
  const text = 'My name is Hono'
  const obj = { ok: true }
  const server = setupServer(
    http.get('http://localhost/about/me', async () => {
      return HttpResponse.text(text)
    }),
    http.get('http://localhost/api', async ({ request }) => {
      return HttpResponse.json(obj)
    })
  )

  beforeAll(() => server.listen())
  afterEach(() => server.resetHandlers())
  afterAll(() => server.close())

  const app = new Hono().get('/about/me', (c) => c.text(text)).get('/api', (c) => c.json(obj))
  const client = hc<typeof app>('http://localhost/')

  it('Should be never with res.json() - /about/me', async () => {
    const res = await client.about.me.$get()
    type Actual = ReturnType<typeof res.json>
    type Expected = Promise<never>
    type verify = Expect<Equal<Expected, Actual>>
  })

  it('Should be "Hello, World!" with res.text() - /about/me', async () => {
    const res = await client.about.me.$get()
    const data = await res.text()
    expectTypeOf(data).toEqualTypeOf<'My name is Hono'>()
    expect(data).toBe(text)
  })

  /**
   * Also check the type of JSON response with res.text().
   */
  it('Should be string with res.text() - /api', async () => {
    const res = await client.api.$get()
    type Actual = ReturnType<typeof res.text>
    type Expected = Promise<string>
    type verify = Expect<Equal<Expected, Actual>>
  })
})

describe('Redirect response - only types', () => {
  const server = setupServer(
    http.get('http://localhost/', async () => {
      return HttpResponse.redirect('/')
    })
  )

  beforeAll(() => server.listen())
  afterEach(() => server.resetHandlers())
  afterAll(() => server.close())

  const condition = () => true
  const app = new Hono().get('/', async (c) => {
    const ok = condition()
    const temporary = condition()
    if (ok) {
      return c.json({ ok: true }, 200)
    }
    if (temporary) {
      return c.redirect('/302')
    }
    return c.redirect('/301', 301)
  })

  const client = hc<typeof app>('http://localhost/')
  const req = client.index.$get

  it('Should infer request type the type correctly', () => {
    type Actual = InferResponseType<typeof req>
    type Expected =
      | {
          ok: boolean
        }
      | undefined
    type verify = Expect<Equal<Expected, Actual>>
  })

  it('Should infer response type correctly', async () => {
    const res = await req()
    if (res.ok) {
      const data = await res.json()
      expectTypeOf(data).toMatchTypeOf({ ok: true })
    }
    if (res.status === 301) {
      type Expected = ClientResponse<undefined, 301, 'redirect'>
      type verify = Expect<Equal<Expected, typeof res>>
    }
    if (res.status === 302) {
      type Expected = ClientResponse<undefined, 302, 'redirect'>
      type verify = Expect<Equal<Expected, typeof res>>
    }
  })
})

describe('WebSocket Provider Integration', () => {
  const app = new Hono()
  const route = app.get(
    '/',
    upgradeWebSocket((c) => ({
      onMessage(event, ws) {
        ws.send('Hello from server!')
      },
      onClose() {
        console.log('Connection closed')
      },
    }))
  )

  type AppType = typeof route

  const server = setupServer()
  beforeAll(() => server.listen())
  afterEach(() => {
    vi.clearAllMocks()
    server.resetHandlers()
  })
  afterAll(() => server.close())

  it.each([
    {
      description: 'should initialize the WebSocket provider correctly',
      url: 'http://localhost',
      query: undefined,
      expectedUrl: 'ws://localhost/index',
    },
    {
      description: 'should correctly add query parameters to the WebSocket URL',
      url: 'http://localhost',
      query: { id: '123', type: 'test', tag: ['a', 'b'] },
      expectedUrl: 'ws://localhost/index?id=123&type=test&tag=a&tag=b',
    },
  ])('$description', ({ url, expectedUrl, query }) => {
    const webSocketMock = vi.fn()
    const client = hc<AppType>(url, {
      webSocket(url, options) {
        return webSocketMock(url, options)
      },
    })
    client.index.$ws({ query })
    expect(webSocketMock).toHaveBeenCalledWith(expectedUrl, undefined)
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/client/client.ts
```typescript
import type { Hono } from '../hono'
import type { FormValue, ValidationTargets } from '../types'
import { serialize } from '../utils/cookie'
import type { UnionToIntersection } from '../utils/types'
import type { Callback, Client, ClientRequestOptions } from './types'
import {
  buildSearchParams,
  deepMerge,
  mergePath,
  removeIndexString,
  replaceUrlParam,
  replaceUrlProtocol,
} from './utils'

const createProxy = (callback: Callback, path: string[]) => {
  const proxy: unknown = new Proxy(() => {}, {
    get(_obj, key) {
      if (typeof key !== 'string' || key === 'then') {
        return undefined
      }
      return createProxy(callback, [...path, key])
    },
    apply(_1, _2, args) {
      return callback({
        path,
        args,
      })
    },
  })
  return proxy
}

class ClientRequestImpl {
  private url: string
  private method: string
  private queryParams: URLSearchParams | undefined = undefined
  private pathParams: Record<string, string> = {}
  private rBody: BodyInit | undefined
  private cType: string | undefined = undefined

  constructor(url: string, method: string) {
    this.url = url
    this.method = method
  }
  fetch = async (
    args?: ValidationTargets<FormValue> & {
      param?: Record<string, string>
    },
    opt?: ClientRequestOptions
  ) => {
    if (args) {
      if (args.query) {
        this.queryParams = buildSearchParams(args.query)
      }

      if (args.form) {
        const form = new FormData()
        for (const [k, v] of Object.entries(args.form)) {
          if (Array.isArray(v)) {
            for (const v2 of v) {
              form.append(k, v2)
            }
          } else {
            form.append(k, v)
          }
        }
        this.rBody = form
      }

      if (args.json) {
        this.rBody = JSON.stringify(args.json)
        this.cType = 'application/json'
      }

      if (args.param) {
        this.pathParams = args.param
      }
    }

    let methodUpperCase = this.method.toUpperCase()

    const headerValues: Record<string, string> = {
      ...args?.header,
      ...(typeof opt?.headers === 'function' ? await opt.headers() : opt?.headers),
    }

    if (args?.cookie) {
      const cookies: string[] = []
      for (const [key, value] of Object.entries(args.cookie)) {
        cookies.push(serialize(key, value, { path: '/' }))
      }
      headerValues['Cookie'] = cookies.join(',')
    }

    if (this.cType) {
      headerValues['Content-Type'] = this.cType
    }

    const headers = new Headers(headerValues ?? undefined)
    let url = this.url

    url = removeIndexString(url)
    url = replaceUrlParam(url, this.pathParams)

    if (this.queryParams) {
      url = url + '?' + this.queryParams.toString()
    }
    methodUpperCase = this.method.toUpperCase()
    const setBody = !(methodUpperCase === 'GET' || methodUpperCase === 'HEAD')

    // Pass URL string to 1st arg for testing with MSW and node-fetch
    return (opt?.fetch || fetch)(url, {
      body: setBody ? this.rBody : undefined,
      method: methodUpperCase,
      headers: headers,
      ...opt?.init,
    })
  }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const hc = <T extends Hono<any, any, any>>(
  baseUrl: string,
  options?: ClientRequestOptions
) =>
  createProxy(function proxyCallback(opts) {
    const parts = [...opts.path]

    // allow calling .toString() and .valueOf() on the proxy
    if (parts.at(-1) === 'toString') {
      if (parts.at(-2) === 'name') {
        // e.g. hc().somePath.name.toString() -> "somePath"
        return parts.at(-3) || ''
      }
      // e.g. hc().somePath.toString()
      return proxyCallback.toString()
    }

    if (parts.at(-1) === 'valueOf') {
      if (parts.at(-2) === 'name') {
        // e.g. hc().somePath.name.valueOf() -> "somePath"
        return parts.at(-3) || ''
      }
      // e.g. hc().somePath.valueOf()
      return proxyCallback
    }

    let method = ''
    if (/^\$/.test(parts.at(-1) as string)) {
      const last = parts.pop()
      if (last) {
        method = last.replace(/^\$/, '')
      }
    }

    const path = parts.join('/')
    const url = mergePath(baseUrl, path)
    if (method === 'url') {
      let result = url
      if (opts.args[0]) {
        if (opts.args[0].param) {
          result = replaceUrlParam(url, opts.args[0].param)
        }
        if (opts.args[0].query) {
          result = result + '?' + buildSearchParams(opts.args[0].query).toString()
        }
      }
      return new URL(result)
    }
    if (method === 'ws') {
      const webSocketUrl = replaceUrlProtocol(
        opts.args[0] && opts.args[0].param ? replaceUrlParam(url, opts.args[0].param) : url,
        'ws'
      )
      const targetUrl = new URL(webSocketUrl)

      const queryParams: Record<string, string | string[]> | undefined = opts.args[0]?.query
      if (queryParams) {
        Object.entries(queryParams).forEach(([key, value]) => {
          if (Array.isArray(value)) {
            value.forEach((item) => targetUrl.searchParams.append(key, item))
          } else {
            targetUrl.searchParams.set(key, value)
          }
        })
      }
      const establishWebSocket = (...args: ConstructorParameters<typeof WebSocket>) => {
        if (options?.webSocket !== undefined && typeof options.webSocket === 'function') {
          return options.webSocket(...args)
        }
        return new WebSocket(...args)
      }

      return establishWebSocket(targetUrl.toString())
    }

    const req = new ClientRequestImpl(url, method)
    if (method) {
      options ??= {}
      const args = deepMerge<ClientRequestOptions>(options, { ...opts.args[1] })
      return req.fetch(opts.args[0], args)
    }
    return req
  }, []) as UnionToIntersection<Client<T>>

```
/Users/josh/Documents/GitHub/honojs/hono/src/client/index.ts
```typescript
/**
 * @module
 * The HTTP Client for Hono.
 */

export { hc } from './client'
export type {
  InferResponseType,
  InferRequestType,
  Fetch,
  ClientRequestOptions,
  ClientRequest,
  ClientResponse,
} from './types'

```
/Users/josh/Documents/GitHub/honojs/hono/src/client/types.test.ts
```typescript
/* eslint-disable @typescript-eslint/no-unused-vars */
import { expectTypeOf } from 'vitest'
import { Hono } from '..'
import { upgradeWebSocket } from '../adapter/deno/websocket'
import { hc } from '.'

describe('WebSockets', () => {
  const app = new Hono()
    .get(
      '/ws',
      upgradeWebSocket(() => ({}))
    )
    .get('/', (c) => c.json({}))
  const client = hc<typeof app>('/')

  it('WebSocket route', () => {
    expectTypeOf(client.ws).toMatchTypeOf<{
      $ws: () => WebSocket
    }>()
  })
  it('Not WebSocket Route', () => {
    expectTypeOf<
      typeof client.index extends { $ws: () => WebSocket } ? false : true
    >().toEqualTypeOf(true)
  })
})

describe('without the leading slash', () => {
  const app = new Hono()
    .get('foo', (c) => c.json({}))
    .get('foo/bar', (c) => c.json({}))
    .get('foo/:id/baz', (c) => c.json({}))
  const client = hc<typeof app>('')
  it('`foo` should have `$get`', () => {
    expectTypeOf(client.foo).toHaveProperty('$get')
  })
  it('`foo.bar` should not have `$get`', () => {
    expectTypeOf(client.foo.bar).toHaveProperty('$get')
  })
  it('`foo[":id"].baz` should have `$get`', () => {
    expectTypeOf(client.foo[':id'].baz).toHaveProperty('$get')
  })
})

describe('with the leading slash', () => {
  const app = new Hono()
    .get('/foo', (c) => c.json({}))
    .get('/foo/bar', (c) => c.json({}))
    .get('/foo/:id/baz', (c) => c.json({}))
  const client = hc<typeof app>('')
  it('`foo` should have `$get`', () => {
    expectTypeOf(client.foo).toHaveProperty('$get')
  })
  it('`foo.bar` should not have `$get`', () => {
    expectTypeOf(client.foo.bar).toHaveProperty('$get')
  })
  it('`foo[":id"].baz` should have `$get`', () => {
    expectTypeOf(client.foo[':id'].baz).toHaveProperty('$get')
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/client/types.ts
```typescript
import type { Hono } from '../hono'
import type { HonoBase } from '../hono-base'
import type { Endpoint, ResponseFormat, Schema } from '../types'
import type { StatusCode, SuccessStatusCode } from '../utils/http-status'
import type { HasRequiredKeys } from '../utils/types'

type HonoRequest = (typeof Hono.prototype)['request']

export type ClientRequestOptions<T = unknown> = {
  fetch?: typeof fetch | HonoRequest
  webSocket?: (...args: ConstructorParameters<typeof WebSocket>) => WebSocket
  /**
   * Standard `RequestInit`, caution that this take highest priority
   * and could be used to overwrite things that Hono sets for you, like `body | method | headers`.
   *
   * If you want to add some headers, use in `headers` instead of `init`
   */
  init?: RequestInit
} & (keyof T extends never
  ? {
      headers?:
        | Record<string, string>
        | (() => Record<string, string> | Promise<Record<string, string>>)
    }
  : {
      headers: T | (() => T | Promise<T>)
    })

export type ClientRequest<S extends Schema> = {
  [M in keyof S]: S[M] extends Endpoint & { input: infer R }
    ? R extends object
      ? HasRequiredKeys<R> extends true
        ? (args: R, options?: ClientRequestOptions) => Promise<ClientResponseOfEndpoint<S[M]>>
        : (args?: R, options?: ClientRequestOptions) => Promise<ClientResponseOfEndpoint<S[M]>>
      : never
    : never
} & {
  $url: (
    arg?: S[keyof S] extends { input: infer R }
      ? R extends { param: infer P }
        ? R extends { query: infer Q }
          ? { param: P; query: Q }
          : { param: P }
        : R extends { query: infer Q }
        ? { query: Q }
        : {}
      : {}
  ) => URL
} & (S['$get'] extends { outputFormat: 'ws' }
    ? S['$get'] extends { input: infer I }
      ? {
          $ws: (args?: I) => WebSocket
        }
      : {}
    : {})

type ClientResponseOfEndpoint<T extends Endpoint = Endpoint> = T extends {
  output: infer O
  outputFormat: infer F
  status: infer S
}
  ? ClientResponse<O, S extends number ? S : never, F extends ResponseFormat ? F : never>
  : never

export interface ClientResponse<
  T,
  U extends number = StatusCode,
  F extends ResponseFormat = ResponseFormat
> extends globalThis.Response {
  readonly body: ReadableStream | null
  readonly bodyUsed: boolean
  ok: U extends SuccessStatusCode
    ? true
    : U extends Exclude<StatusCode, SuccessStatusCode>
    ? false
    : boolean
  status: U
  statusText: string
  headers: Headers
  url: string
  redirect(url: string, status: number): Response
  clone(): Response
  json(): F extends 'text' ? Promise<never> : F extends 'json' ? Promise<T> : Promise<unknown>
  text(): F extends 'text' ? (T extends string ? Promise<T> : Promise<never>) : Promise<string>
  blob(): Promise<Blob>
  formData(): Promise<FormData>
  arrayBuffer(): Promise<ArrayBuffer>
}

export interface Response extends ClientResponse<unknown> {}

export type Fetch<T> = (
  args?: InferRequestType<T>,
  opt?: ClientRequestOptions
) => Promise<ClientResponseOfEndpoint<InferEndpointType<T>>>

type InferEndpointType<T> = T extends (
  args: infer R,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  options: any | undefined
) => Promise<infer U>
  ? U extends ClientResponse<infer O, infer S, infer F>
    ? { input: NonNullable<R>; output: O; outputFormat: F; status: S } extends Endpoint
      ? { input: NonNullable<R>; output: O; outputFormat: F; status: S }
      : never
    : never
  : never

export type InferResponseType<T, U extends StatusCode = StatusCode> = InferResponseTypeFromEndpoint<
  InferEndpointType<T>,
  U
>

type InferResponseTypeFromEndpoint<T extends Endpoint, U extends StatusCode> = T extends {
  output: infer O
  status: infer S
}
  ? S extends U
    ? O
    : never
  : never

export type InferRequestType<T> = T extends (
  args: infer R,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  options: any | undefined
) => Promise<ClientResponse<unknown>>
  ? NonNullable<R>
  : never

export type InferRequestOptionsType<T> = T extends (
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  args: any,
  options: infer R
) => Promise<ClientResponse<unknown>>
  ? NonNullable<R>
  : never

type PathToChain<
  Path extends string,
  E extends Schema,
  Original extends string = Path
> = Path extends `/${infer P}`
  ? PathToChain<P, E, Path>
  : Path extends `${infer P}/${infer R}`
  ? { [K in P]: PathToChain<R, E, Original> }
  : {
      [K in Path extends '' ? 'index' : Path]: ClientRequest<
        E extends Record<string, unknown> ? E[Original] : never
      >
    }

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type Client<T> = T extends HonoBase<any, infer S, any>
  ? S extends Record<infer K, Schema>
    ? K extends string
      ? PathToChain<K, S>
      : never
    : never
  : never

export type Callback = (opts: CallbackOptions) => unknown

interface CallbackOptions {
  path: string[]
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  args: any[]
}

export type ObjectType<T = unknown> = {
  [key: string]: T
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/client/utils.test.ts
```typescript
import {
  buildSearchParams,
  deepMerge,
  mergePath,
  removeIndexString,
  replaceUrlParam,
  replaceUrlProtocol,
} from './utils'

describe('mergePath', () => {
  it('Should merge paths correctly', () => {
    expect(mergePath('http://localhost', '/api')).toBe('http://localhost/api')
    expect(mergePath('http://localhost/', '/api')).toBe('http://localhost/api')
    expect(mergePath('http://localhost', 'api')).toBe('http://localhost/api')
    expect(mergePath('http://localhost/', 'api')).toBe('http://localhost/api')
    expect(mergePath('http://localhost/', '/')).toBe('http://localhost/')
  })
})

describe('replaceUrlParams', () => {
  it('Should replace correctly', () => {
    const url = 'http://localhost/posts/:postId/comments/:commentId'
    const params = {
      postId: '123',
      commentId: '456',
    }
    const replacedUrl = replaceUrlParam(url, params)
    expect(replacedUrl).toBe('http://localhost/posts/123/comments/456')
  })

  it('Should replace correctly when there is regex pattern', () => {
    const url = 'http://localhost/posts/:postId{[abc]+}/comments/:commentId{[0-9]+}'
    const params = {
      postId: 'abc',
      commentId: '456',
    }
    const replacedUrl = replaceUrlParam(url, params)
    expect(replacedUrl).toBe('http://localhost/posts/abc/comments/456')
  })

  it('Should replace correctly when there is regex pattern with length limit', () => {
    const url = 'http://localhost/year/:year{[1-9]{1}[0-9]{3}}/month/:month{[0-9]{2}}'
    const params = {
      year: '2024',
      month: '2',
    }
    const replacedUrl = replaceUrlParam(url, params)
    expect(replacedUrl).toBe('http://localhost/year/2024/month/2')
  })

  it('Should replace correctly when it has optional parameters', () => {
    const url = 'http://localhost/something/:firstId/:secondId/:version?'
    const params = {
      firstId: '123',
      secondId: '456',
      version: undefined,
    }
    const replacedUrl = replaceUrlParam(url, params)
    expect(replacedUrl).toBe('http://localhost/something/123/456')
  })
})

describe('buildSearchParams', () => {
  it('Should build URLSearchParams correctly', () => {
    const query = {
      id: '123',
      type: 'test',
      tag: ['a', 'b'],
    }
    const searchParams = buildSearchParams(query)
    expect(searchParams.toString()).toBe('id=123&type=test&tag=a&tag=b')
  })
})

describe('replaceUrlProtocol', () => {
  it('Should replace http to ws', () => {
    const url = 'http://localhost'
    const newUrl = replaceUrlProtocol(url, 'ws')
    expect(newUrl).toBe('ws://localhost')
  })

  it('Should replace https to wss', () => {
    const url = 'https://localhost'
    const newUrl = replaceUrlProtocol(url, 'ws')
    expect(newUrl).toBe('wss://localhost')
  })

  it('Should replace ws to http', () => {
    const url = 'ws://localhost'
    const newUrl = replaceUrlProtocol(url, 'http')
    expect(newUrl).toBe('http://localhost')
  })

  it('Should replace wss to https', () => {
    const url = 'wss://localhost'
    const newUrl = replaceUrlProtocol(url, 'http')
    expect(newUrl).toBe('https://localhost')
  })
})

describe('removeIndexString', () => {
  it('Should remove last `/index` string', () => {
    let url = 'http://localhost/index'
    let newUrl = removeIndexString(url)
    expect(newUrl).toBe('http://localhost/')

    url = '/index'
    newUrl = removeIndexString(url)
    expect(newUrl).toBe('')

    url = '/sub/index'
    newUrl = removeIndexString(url)
    expect(newUrl).toBe('/sub')

    url = '/subindex'
    newUrl = removeIndexString(url)
    expect(newUrl).toBe('/subindex')
  })
})

describe('deepMerge', () => {
  it('should return the source object if the target object is not an object', () => {
    const target = null
    const source = 'not an object' as unknown as Record<string, unknown>
    const result = deepMerge(target, source)
    expect(result).toEqual(source)
  })

  it('should merge two objects with object properties', () => {
    expect(
      deepMerge(
        { headers: { hono: '1' }, timeout: 2, params: {} },
        { headers: { hono: '2', demo: 2 }, params: undefined }
      )
    ).toStrictEqual({
      params: undefined,
      headers: { hono: '2', demo: 2 },
      timeout: 2,
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/client/utils.ts
```typescript
import type { ObjectType } from './types'

export const mergePath = (base: string, path: string) => {
  base = base.replace(/\/+$/, '')
  base = base + '/'
  path = path.replace(/^\/+/, '')
  return base + path
}

export const replaceUrlParam = (urlString: string, params: Record<string, string | undefined>) => {
  for (const [k, v] of Object.entries(params)) {
    const reg = new RegExp('/:' + k + '(?:{[^/]+})?\\??')
    urlString = urlString.replace(reg, v ? `/${v}` : '')
  }
  return urlString
}

export const buildSearchParams = (query: Record<string, string | string[]>) => {
  const searchParams = new URLSearchParams()

  for (const [k, v] of Object.entries(query)) {
    if (v === undefined) {
      continue
    }

    if (Array.isArray(v)) {
      for (const v2 of v) {
        searchParams.append(k, v2)
      }
    } else {
      searchParams.set(k, v)
    }
  }

  return searchParams
}

export const replaceUrlProtocol = (urlString: string, protocol: 'ws' | 'http') => {
  switch (protocol) {
    case 'ws':
      return urlString.replace(/^http/, 'ws')
    case 'http':
      return urlString.replace(/^ws/, 'http')
  }
}

export const removeIndexString = (urlSting: string) => {
  if (/^https?:\/\/[^\/]+?\/index$/.test(urlSting)) {
    return urlSting.replace(/\/index$/, '/')
  }
  return urlSting.replace(/\/index$/, '')
}

function isObject(item: unknown): item is ObjectType {
  return typeof item === 'object' && item !== null && !Array.isArray(item)
}

export function deepMerge<T>(target: T, source: Record<string, unknown>): T {
  if (!isObject(target) && !isObject(source)) {
    return source as T
  }
  const merged = { ...target } as ObjectType<T>

  for (const key in source) {
    const value = source[key]
    if (isObject(merged[key]) && isObject(value)) {
      merged[key] = deepMerge(merged[key], value)
    } else {
      merged[key] = value as T[keyof T] & T
    }
  }

  return merged as T
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/base.ts
```typescript
import { raw } from '../helper/html'
import { escapeToBuffer, resolveCallbackSync, stringBufferToString } from '../utils/html'
import type { HtmlEscaped, HtmlEscapedString, StringBufferWithCallbacks } from '../utils/html'
import { DOM_RENDERER, DOM_MEMO } from './constants'
import type { Context } from './context'
import { createContext, globalContexts, useContext } from './context'
import { domRenderers } from './intrinsic-element/common'
import * as intrinsicElementTags from './intrinsic-element/components'
import type {
  JSX as HonoJSX,
  IntrinsicElements as IntrinsicElementsDefined,
} from './intrinsic-elements'
import { normalizeIntrinsicElementKey, styleObjectForEach } from './utils'

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type Props = Record<string, any>
export type FC<P = Props> = {
  (props: P): HtmlEscapedString | Promise<HtmlEscapedString> | null
  defaultProps?: Partial<P> | undefined
  displayName?: string | undefined
}
export type DOMAttributes = HonoJSX.HTMLAttributes

// eslint-disable-next-line @typescript-eslint/no-namespace
export namespace JSX {
  export type Element = HtmlEscapedString | Promise<HtmlEscapedString>
  export interface ElementChildrenAttribute {
    children: Child
  }
  export interface IntrinsicElements extends IntrinsicElementsDefined {
    [tagName: string]: Props
  }
  export interface IntrinsicAttributes {
    key?: string | number | bigint | null | undefined
  }
}

let nameSpaceContext: Context<string> | undefined = undefined
export const getNameSpaceContext = () => nameSpaceContext

const toSVGAttributeName = (key: string): string =>
  /[A-Z]/.test(key) &&
  // Presentation attributes are findable in style object. "clip-path", "font-size", "stroke-width", etc.
  // Or other un-deprecated kebab-case attributes. "overline-position", "paint-order", "strikethrough-position", etc.
  key.match(
    /^(?:al|basel|clip(?:Path|Rule)$|co|do|fill|fl|fo|gl|let|lig|i|marker[EMS]|o|pai|pointe|sh|st[or]|text[^L]|tr|u|ve|w)/
  )
    ? key.replace(/([A-Z])/g, '-$1').toLowerCase()
    : key

const emptyTags = [
  'area',
  'base',
  'br',
  'col',
  'embed',
  'hr',
  'img',
  'input',
  'keygen',
  'link',
  'meta',
  'param',
  'source',
  'track',
  'wbr',
]
export const booleanAttributes = [
  'allowfullscreen',
  'async',
  'autofocus',
  'autoplay',
  'checked',
  'controls',
  'default',
  'defer',
  'disabled',
  'download',
  'formnovalidate',
  'hidden',
  'inert',
  'ismap',
  'itemscope',
  'loop',
  'multiple',
  'muted',
  'nomodule',
  'novalidate',
  'open',
  'playsinline',
  'readonly',
  'required',
  'reversed',
  'selected',
]

const childrenToStringToBuffer = (children: Child[], buffer: StringBufferWithCallbacks): void => {
  for (let i = 0, len = children.length; i < len; i++) {
    const child = children[i]
    if (typeof child === 'string') {
      escapeToBuffer(child, buffer)
    } else if (typeof child === 'boolean' || child === null || child === undefined) {
      continue
    } else if (child instanceof JSXNode) {
      child.toStringToBuffer(buffer)
    } else if (
      typeof child === 'number' ||
      (child as unknown as { isEscaped: boolean }).isEscaped
    ) {
      ;(buffer[0] as string) += child
    } else if (child instanceof Promise) {
      buffer.unshift('', child)
    } else {
      // `child` type is `Child[]`, so stringify recursively
      childrenToStringToBuffer(child, buffer)
    }
  }
}

type LocalContexts = [Context<unknown>, unknown][]
export type Child =
  | string
  | Promise<string>
  | number
  | JSXNode
  | null
  | undefined
  | boolean
  | Child[]
export class JSXNode implements HtmlEscaped {
  tag: string | Function
  props: Props
  key?: string
  children: Child[]
  isEscaped: true = true as const
  localContexts?: LocalContexts
  constructor(tag: string | Function, props: Props, children: Child[]) {
    this.tag = tag
    this.props = props
    this.children = children
  }

  get type(): string | Function {
    return this.tag as string
  }

  // Added for compatibility with libraries that rely on React's internal structure
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get ref(): any {
    return this.props.ref || null
  }

  toString(): string | Promise<string> {
    const buffer: StringBufferWithCallbacks = [''] as StringBufferWithCallbacks
    this.localContexts?.forEach(([context, value]) => {
      context.values.push(value)
    })
    try {
      this.toStringToBuffer(buffer)
    } finally {
      this.localContexts?.forEach(([context]) => {
        context.values.pop()
      })
    }
    return buffer.length === 1
      ? 'callbacks' in buffer
        ? resolveCallbackSync(raw(buffer[0], buffer.callbacks)).toString()
        : buffer[0]
      : stringBufferToString(buffer, buffer.callbacks)
  }

  toStringToBuffer(buffer: StringBufferWithCallbacks): void {
    const tag = this.tag as string
    const props = this.props
    let { children } = this

    buffer[0] += `<${tag}`

    const normalizeKey: (key: string) => string =
      nameSpaceContext && useContext(nameSpaceContext) === 'svg'
        ? (key) => toSVGAttributeName(normalizeIntrinsicElementKey(key))
        : (key) => normalizeIntrinsicElementKey(key)
    for (let [key, v] of Object.entries(props)) {
      key = normalizeKey(key)
      if (key === 'children') {
        // skip children
      } else if (key === 'style' && typeof v === 'object') {
        // object to style strings
        let styleStr = ''
        styleObjectForEach(v, (property, value) => {
          if (value != null) {
            styleStr += `${styleStr ? ';' : ''}${property}:${value}`
          }
        })
        buffer[0] += ' style="'
        escapeToBuffer(styleStr, buffer)
        buffer[0] += '"'
      } else if (typeof v === 'string') {
        buffer[0] += ` ${key}="`
        escapeToBuffer(v, buffer)
        buffer[0] += '"'
      } else if (v === null || v === undefined) {
        // Do nothing
      } else if (typeof v === 'number' || (v as HtmlEscaped).isEscaped) {
        buffer[0] += ` ${key}="${v}"`
      } else if (typeof v === 'boolean' && booleanAttributes.includes(key)) {
        if (v) {
          buffer[0] += ` ${key}=""`
        }
      } else if (key === 'dangerouslySetInnerHTML') {
        if (children.length > 0) {
          throw 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.'
        }

        children = [raw(v.__html)]
      } else if (v instanceof Promise) {
        buffer[0] += ` ${key}="`
        buffer.unshift('"', v)
      } else if (typeof v === 'function') {
        if (!key.startsWith('on')) {
          throw `Invalid prop '${key}' of type 'function' supplied to '${tag}'.`
        }
        // maybe event handler for client components, just ignore in server components
      } else {
        buffer[0] += ` ${key}="`
        escapeToBuffer(v.toString(), buffer)
        buffer[0] += '"'
      }
    }

    if (emptyTags.includes(tag as string) && children.length === 0) {
      buffer[0] += '/>'
      return
    }

    buffer[0] += '>'

    childrenToStringToBuffer(children, buffer)

    buffer[0] += `</${tag}>`
  }
}

class JSXFunctionNode extends JSXNode {
  override toStringToBuffer(buffer: StringBufferWithCallbacks): void {
    const { children } = this

    const res = (this.tag as Function).call(null, {
      ...this.props,
      children: children.length <= 1 ? children[0] : children,
    })

    if (typeof res === 'boolean' || res == null) {
      // boolean or null or undefined
      return
    } else if (res instanceof Promise) {
      if (globalContexts.length === 0) {
        buffer.unshift('', res)
      } else {
        // save current contexts for resuming
        const currentContexts: LocalContexts = globalContexts.map((c) => [c, c.values.at(-1)])
        buffer.unshift(
          '',
          res.then((childRes) => {
            if (childRes instanceof JSXNode) {
              childRes.localContexts = currentContexts
            }
            return childRes
          })
        )
      }
    } else if (res instanceof JSXNode) {
      res.toStringToBuffer(buffer)
    } else if (typeof res === 'number' || (res as HtmlEscaped).isEscaped) {
      buffer[0] += res
      if (res.callbacks) {
        buffer.callbacks ||= []
        buffer.callbacks.push(...res.callbacks)
      }
    } else {
      escapeToBuffer(res, buffer)
    }
  }
}

export class JSXFragmentNode extends JSXNode {
  override toStringToBuffer(buffer: StringBufferWithCallbacks): void {
    childrenToStringToBuffer(this.children, buffer)
  }
}

export const jsx = (
  tag: string | Function,
  props: Props | null,
  ...children: (string | number | HtmlEscapedString)[]
): JSXNode => {
  props ??= {}
  if (children.length) {
    props.children = children.length === 1 ? children[0] : children
  }

  const key = props.key
  delete props['key']

  const node = jsxFn(tag, props, children)
  node.key = key
  return node
}

let initDomRenderer = false
export const jsxFn = (
  tag: string | Function,
  props: Props,
  children: (string | number | HtmlEscapedString)[]
): JSXNode => {
  if (!initDomRenderer) {
    for (const k in domRenderers) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ;(intrinsicElementTags[k as keyof typeof intrinsicElementTags] as any)[DOM_RENDERER] =
        domRenderers[k]
    }
    initDomRenderer = true
  }

  if (typeof tag === 'function') {
    return new JSXFunctionNode(tag, props, children)
  } else if (intrinsicElementTags[tag as keyof typeof intrinsicElementTags]) {
    return new JSXFunctionNode(
      intrinsicElementTags[tag as keyof typeof intrinsicElementTags],
      props,
      children
    )
  } else if (tag === 'svg' || tag === 'head') {
    nameSpaceContext ||= createContext('')
    return new JSXNode(tag, props, [
      new JSXFunctionNode(
        nameSpaceContext,
        {
          value: tag,
        },
        children
      ),
    ])
  } else {
    return new JSXNode(tag, props, children)
  }
}

export const shallowEqual = (a: Props, b: Props): boolean => {
  if (a === b) {
    return true
  }

  const aKeys = Object.keys(a).sort()
  const bKeys = Object.keys(b).sort()
  if (aKeys.length !== bKeys.length) {
    return false
  }

  for (let i = 0, len = aKeys.length; i < len; i++) {
    if (
      aKeys[i] === 'children' &&
      bKeys[i] === 'children' &&
      !a.children?.length &&
      !b.children?.length
    ) {
      continue
    } else if (a[aKeys[i]] !== b[aKeys[i]]) {
      return false
    }
  }

  return true
}

export type MemorableFC<T> = FC<T> & {
  [DOM_MEMO]: (prevProps: Readonly<T>, nextProps: Readonly<T>) => boolean
}
export const memo = <T>(
  component: FC<T>,
  propsAreEqual: (prevProps: Readonly<T>, nextProps: Readonly<T>) => boolean = shallowEqual
): FC<T> => {
  let computed: ReturnType<FC<T>> = null
  let prevProps: T | undefined = undefined
  const wrapper: MemorableFC<T> = ((props: T) => {
    if (prevProps && !propsAreEqual(prevProps, props)) {
      computed = null
    }
    prevProps = props
    return (computed ||= component(props))
  }) as MemorableFC<T>

  // This function is for toString(), but it can also be used for DOM renderer.
  // So, set DOM_MEMO and DOM_RENDERER for DOM renderer.
  wrapper[DOM_MEMO] = propsAreEqual
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ;(wrapper as any)[DOM_RENDERER] = component

  return wrapper as FC<T>
}

export const Fragment = ({
  children,
}: {
  key?: string
  children?: Child | HtmlEscapedString
}): HtmlEscapedString => {
  return new JSXFragmentNode(
    '',
    {
      children,
    },
    Array.isArray(children) ? children : children ? [children] : []
  ) as never
}

export const isValidElement = (element: unknown): element is JSXNode => {
  return !!(element && typeof element === 'object' && 'tag' in element && 'props' in element)
}

export const cloneElement = <T extends JSXNode | JSX.Element>(
  element: T,
  props: Partial<Props>,
  ...children: Child[]
): T => {
  return jsx(
    (element as JSXNode).tag,
    { ...(element as JSXNode).props, ...props },
    ...(children as (string | number | HtmlEscapedString)[])
  ) as T
}

export const reactAPICompatVersion = '19.0.0-hono-jsx'

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/children.test.ts
```typescript
import { Children } from './children'
import { createElement } from '.'

describe('map', () => {
  it('should map children', () => {
    const element = createElement('div', null, 1, 2, 3)
    const result = Children.map(element.children, (child) => (child as number) * 2)
    expect(result).toEqual([2, 4, 6])
  })
})

describe('forEach', () => {
  it('should iterate children', () => {
    const element = createElement('div', null, 1, 2, 3)
    const result: number[] = []
    Children.forEach(element.children, (child) => {
      result.push(child as number)
    })
    expect(result).toEqual([1, 2, 3])
  })
})

describe('count', () => {
  it('should count children', () => {
    const element = createElement('div', null, 1, 2, 3)
    const result = Children.count(element.children)
    expect(result).toBe(3)
  })
})

describe('only', () => {
  it('should return the only child', () => {
    const element = createElement('div', null, 1)
    const result = Children.only(element.children)
    expect(result).toBe(1)
  })

  it('should throw an error if there are multiple children', () => {
    const element = createElement('div', null, 1, 2)
    expect(() => Children.only(element.children)).toThrowError(
      'Children.only() expects only one child'
    )
  })
})

describe('toArray', () => {
  it('should convert children to an array', () => {
    const element = createElement('div', null, 1, 2, 3)
    const result = Children.toArray(element.children)
    expect(result).toEqual([1, 2, 3])
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/children.ts
```typescript
import type { Child } from './base'

export const toArray = (children: Child): Child[] =>
  Array.isArray(children) ? children : [children]
export const Children = {
  map: (children: Child[], fn: (child: Child, index: number) => Child): Child[] =>
    toArray(children).map(fn),
  forEach: (children: Child[], fn: (child: Child, index: number) => void): void => {
    toArray(children).forEach(fn)
  },
  count: (children: Child[]): number => toArray(children).length,
  only: (_children: Child[]): Child => {
    const children = toArray(_children)
    if (children.length !== 1) {
      throw new Error('Children.only() expects only one child')
    }
    return children[0]
  },
  toArray,
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/components.test.tsx
```
/* eslint-disable @typescript-eslint/no-explicit-any */
/** @jsxImportSource ./ */
import { JSDOM } from 'jsdom'
import type { HtmlEscapedString } from '../utils/html'
import { HtmlEscapedCallbackPhase, resolveCallback as rawResolveCallback } from '../utils/html'
import { ErrorBoundary } from './components'
import { Suspense, renderToReadableStream } from './streaming'

function resolveCallback(template: string | HtmlEscapedString) {
  return rawResolveCallback(template, HtmlEscapedCallbackPhase.Stream, false, {})
}

function replacementResult(html: string) {
  const document = new JSDOM(html, { runScripts: 'dangerously' }).window.document
  document.querySelectorAll('template, script').forEach((e) => e.remove())
  return document.body.innerHTML
}

const Fallback = () => <div>Out Of Service</div>

describe('ErrorBoundary', () => {
  let errorBoundaryCounter = 0
  let suspenseCounter = 0
  afterEach(() => {
    errorBoundaryCounter++
    suspenseCounter++
  })

  describe('sync', async () => {
    const Component = ({ error }: { error?: boolean }) => {
      if (error) {
        throw new Error('Error')
      }
      return <div>Hello</div>
    }

    it('no error', async () => {
      const html = (
        <ErrorBoundary fallback={<Fallback />}>
          <Component />
        </ErrorBoundary>
      )

      expect((await resolveCallback(await html.toString())).toString()).toEqual('<div>Hello</div>')

      errorBoundaryCounter--
      suspenseCounter--
    })

    it('error', async () => {
      const html = (
        <ErrorBoundary fallback={<Fallback />}>
          <Component error={true} />
        </ErrorBoundary>
      )

      expect((await resolveCallback(await html.toString())).toString()).toEqual(
        '<div>Out Of Service</div>'
      )

      suspenseCounter--
    })

    it('nullish', async () => {
      const html = (
        <div>
          <ErrorBoundary fallback={<Fallback />}>{[null, undefined]}</ErrorBoundary>
        </div>
      )

      expect((await resolveCallback(await html.toString())).toString()).toEqual('<div></div>')

      errorBoundaryCounter--
      suspenseCounter--
    })

    it('boolean', async () => {
      const html = (
        <div>
          <ErrorBoundary fallback={<Fallback />}>{[true, false]}</ErrorBoundary>
        </div>
      )

      expect((await resolveCallback(await html.toString())).toString()).toEqual('<div></div>')

      errorBoundaryCounter--
      suspenseCounter--
    })
  })

  describe('async', async () => {
    const Component = async ({ error }: { error?: boolean }) => {
      await new Promise((resolve) => setTimeout(resolve, 10))
      if (error) {
        throw new Error('Error')
      }
      return <div>Hello</div>
    }

    it('no error', async () => {
      const html = (
        <ErrorBoundary fallback={<Fallback />}>
          <Component />
        </ErrorBoundary>
      )

      expect((await resolveCallback(await html.toString())).toString()).toEqual('<div>Hello</div>')

      errorBoundaryCounter--
      suspenseCounter--
    })

    it('error', async () => {
      const html = (
        <ErrorBoundary fallback={<Fallback />}>
          <Component error={true} />
        </ErrorBoundary>
      )

      expect((await resolveCallback(await html.toString())).toString()).toEqual(
        '<div>Out Of Service</div>'
      )

      suspenseCounter--
    })
  })

  describe('async : nested', async () => {
    const handlers: Record<number, { resolve: (value: unknown) => void; reject: () => void }> = {}
    const Component = async ({ id }: { id: number }) => {
      await new Promise((resolve, reject) => (handlers[id] = { resolve, reject }))
      return <div>{id}</div>
    }

    it('no error', async () => {
      const html = (
        <ErrorBoundary fallback={<Fallback />}>
          <Component id={1} />
          <ErrorBoundary fallback={<Fallback />}>
            <Component id={2} />
          </ErrorBoundary>
        </ErrorBoundary>
      ).toString()

      Object.values(handlers).forEach(({ resolve }) => resolve(undefined))

      expect((await resolveCallback(await html)).toString()).toEqual('<div>1</div><div>2</div>')

      errorBoundaryCounter++
      suspenseCounter--
    })

    it('error in parent', async () => {
      const html = (
        <ErrorBoundary fallback={<Fallback />}>
          <Component id={1} />
          <ErrorBoundary fallback={<Fallback />}>
            <Component id={2} />
          </ErrorBoundary>
        </ErrorBoundary>
      ).toString()

      handlers[2].resolve(undefined)
      handlers[1].reject()

      expect((await resolveCallback(await html)).toString()).toEqual('<div>Out Of Service</div>')

      errorBoundaryCounter++
      suspenseCounter--
    })

    it('error in child', async () => {
      const html = (
        <ErrorBoundary fallback={<Fallback />}>
          <Component id={1} />
          <ErrorBoundary fallback={<Fallback />}>
            <Component id={2} />
          </ErrorBoundary>
        </ErrorBoundary>
      ).toString()

      handlers[1].resolve(undefined)
      handlers[2].reject()

      expect((await resolveCallback(await html)).toString()).toEqual(
        '<div>1</div><div>Out Of Service</div>'
      )

      errorBoundaryCounter++
      suspenseCounter--
    })
  })

  describe('async : setTimeout', async () => {
    const TimeoutSuccessComponent = async () => {
      await new Promise((resolve) => setTimeout(resolve, 10))
      return <div>OK</div>
    }
    const TimeoutErrorComponent = async () => {
      await new Promise((resolve) => setTimeout(resolve, 0))
      throw new Error('Error')
    }

    it('fallback', async () => {
      const html = (
        <>
          <TimeoutSuccessComponent />
          <ErrorBoundary fallback={<Fallback />}>
            <TimeoutErrorComponent />
          </ErrorBoundary>
        </>
      ).toString()

      expect((await resolveCallback(await html)).toString()).toEqual(
        '<div>OK</div><div>Out Of Service</div>'
      )

      suspenseCounter--
    })
  })

  describe('streaming', async () => {
    const Component = async ({ error }: { error?: boolean }) => {
      await new Promise((resolve) => setTimeout(resolve, 10))
      if (error) {
        throw new Error('Error')
      }
      return <div>Hello</div>
    }

    it('no error', async () => {
      const stream = renderToReadableStream(
        <ErrorBoundary fallback={<Fallback />}>
          <Suspense fallback={<p>Loading...</p>}>
            <Component />
          </Suspense>
        </ErrorBoundary>
      )
      const chunks = []
      const textDecoder = new TextDecoder()
      for await (const chunk of stream as any) {
        chunks.push(textDecoder.decode(chunk))
      }

      expect(chunks).toEqual([
        `<template id="E:${errorBoundaryCounter}"></template><!--E:${errorBoundaryCounter}-->`,
        `<template data-hono-target="E:${errorBoundaryCounter}"><template id="H:${suspenseCounter}"></template><p>Loading...</p><!--/$--></template><script>
((d,c) => {
c=d.currentScript.previousSibling
d=d.getElementById('E:${errorBoundaryCounter}')
if(!d)return
d.parentElement.insertBefore(c.content,d.nextSibling)
})(document)
</script>`,
        `<template data-hono-target="H:${suspenseCounter}"><div>Hello</div></template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:${suspenseCounter}')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
</script><script>
((d,c,n) => {
d=d.getElementById('E:${errorBoundaryCounter}')
if(!d)return
n=d.nextSibling
while(n.nodeType!=8||n.nodeValue!='E:${errorBoundaryCounter}'){n=n.nextSibling}
n.remove()
d.remove()
})(document)
</script>`,
      ])

      expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual(
        '<div>Hello</div>'
      )
    })

    it('error', async () => {
      const html = (
        <ErrorBoundary fallback={<Fallback />}>
          <Component error={true} />
        </ErrorBoundary>
      )

      expect((await resolveCallback(await html.toString())).toString()).toEqual(
        '<div>Out Of Service</div>'
      )
    })
  })

  describe('streaming : contains multiple suspense', async () => {
    const handlers: Record<number, { resolve: (value: unknown) => void; reject: () => void }> = {}
    const Component = async ({ id }: { id: number }) => {
      await new Promise((resolve, reject) => (handlers[id] = { resolve, reject }))
      return <div>{id}</div>
    }

    it('no error', async () => {
      const stream = renderToReadableStream(
        <ErrorBoundary fallback={<Fallback />}>
          <Suspense fallback={<p>Loading...</p>}>
            <Component id={1} />
          </Suspense>
          <Suspense fallback={<p>Loading...</p>}>
            <Component id={2} />
          </Suspense>
          <Suspense fallback={<p>Loading...</p>}>
            <Component id={3} />
          </Suspense>
        </ErrorBoundary>
      )

      Object.values(handlers).forEach(({ resolve }) => resolve(undefined))

      const chunks = []
      const textDecoder = new TextDecoder()
      for await (const chunk of stream as any) {
        chunks.push(textDecoder.decode(chunk))
      }

      expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual(
        '<div>1</div><div>2</div><div>3</div>'
      )
    })

    it('error', async () => {
      const stream = renderToReadableStream(
        <ErrorBoundary fallback={<Fallback />}>
          <Suspense fallback={<p>Loading...</p>}>
            <Component id={1} />
          </Suspense>
          <Suspense fallback={<p>Loading...</p>}>
            <Component id={2} />
          </Suspense>
          <Suspense fallback={<p>Loading...</p>}>
            <Component id={3} />
          </Suspense>
        </ErrorBoundary>
      )

      handlers[1].resolve(undefined)
      handlers[2].resolve(undefined)
      handlers[3].reject()

      const chunks = []
      const textDecoder = new TextDecoder()
      for await (const chunk of stream as any) {
        chunks.push(textDecoder.decode(chunk))
      }

      expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual(
        '<div>Out Of Service</div>'
      )
    })
  })

  describe('streaming : nested', async () => {
    const handlers: Record<number, { resolve: (value: unknown) => void; reject: () => void }> = {}
    const Component = async ({ id }: { id: number }) => {
      await new Promise((resolve, reject) => (handlers[id] = { resolve, reject }))
      return <div>{id}</div>
    }

    it('no error', async () => {
      const stream = renderToReadableStream(
        <ErrorBoundary fallback={<Fallback />}>
          <Suspense fallback={<p>Loading...</p>}>
            <Component id={1} />
          </Suspense>
          <ErrorBoundary fallback={<Fallback />}>
            <Suspense fallback={<p>Loading...</p>}>
              <Component id={2} />
            </Suspense>
          </ErrorBoundary>
        </ErrorBoundary>
      )

      Object.values(handlers).forEach(({ resolve }) => resolve(undefined))

      const chunks = []
      const textDecoder = new TextDecoder()
      for await (const chunk of stream as any) {
        chunks.push(textDecoder.decode(chunk))
      }

      expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual(
        '<div>1</div><div>2</div>'
      )
    })

    it('error in parent', async () => {
      const stream = renderToReadableStream(
        <ErrorBoundary fallback={<Fallback />}>
          <Suspense fallback={<p>Loading...</p>}>
            <Component id={1} />
          </Suspense>
          <ErrorBoundary fallback={<Fallback />}>
            <Suspense fallback={<p>Loading...</p>}>
              <Component id={2} />
            </Suspense>
          </ErrorBoundary>
        </ErrorBoundary>
      )

      handlers[2].resolve(undefined)
      handlers[1].reject()

      const chunks = []
      const textDecoder = new TextDecoder()
      for await (const chunk of stream as any) {
        chunks.push(textDecoder.decode(chunk))
      }

      expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual(
        '<div>Out Of Service</div>'
      )
    })

    it('error in child', async () => {
      const stream = renderToReadableStream(
        <ErrorBoundary fallback={<Fallback />}>
          <Suspense fallback={<p>Loading...</p>}>
            <Component id={1} />
          </Suspense>
          <ErrorBoundary fallback={<Fallback />}>
            <Suspense fallback={<p>Loading...</p>}>
              <Component id={2} />
            </Suspense>
          </ErrorBoundary>
        </ErrorBoundary>
      )

      handlers[1].resolve(undefined)
      handlers[2].reject()

      const chunks = []
      const textDecoder = new TextDecoder()
      for await (const chunk of stream as any) {
        chunks.push(textDecoder.decode(chunk))
      }

      expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual(
        '<div>1</div><div>Out Of Service</div>'
      )
    })
  })

  describe('onError', async () => {
    const Component = ({ error }: { error?: boolean }) => {
      if (error) {
        throw new Error('Error')
      }
      return <div>Hello</div>
    }

    it('no error', async () => {
      const errors: Error[] = []
      const html = (
        <ErrorBoundary fallback={<Fallback />} onError={(err) => errors.push(err)}>
          <Component />
        </ErrorBoundary>
      )

      expect((await resolveCallback(await html.toString())).toString()).toEqual('<div>Hello</div>')

      errorBoundaryCounter--
      suspenseCounter--

      expect(errors).toEqual([])
    })

    it('error', async () => {
      const errors: Error[] = []
      const html = (
        <ErrorBoundary fallback={<Fallback />} onError={(err) => errors.push(err)}>
          <Component error={true} />
        </ErrorBoundary>
      )

      expect((await resolveCallback(await html.toString())).toString()).toEqual(
        '<div>Out Of Service</div>'
      )

      suspenseCounter--

      expect(errors[0]).toEqual(new Error('Error'))
    })
  })

  describe('fallbackRender', async () => {
    const fallbackRenderer = (error: Error) => <div data-error>{error.message}</div>
    const Component = ({ error }: { error?: boolean }) => {
      if (error) {
        throw new Error('Error')
      }
      return <div>Hello</div>
    }

    it('no error', async () => {
      const errors: Error[] = []
      const html = (
        <ErrorBoundary fallbackRender={fallbackRenderer}>
          <Component />
        </ErrorBoundary>
      )

      expect((await resolveCallback(await html.toString())).toString()).toEqual('<div>Hello</div>')

      errorBoundaryCounter--
      suspenseCounter--

      expect(errors).toEqual([])
    })

    it('error', async () => {
      const html = (
        <ErrorBoundary fallbackRender={fallbackRenderer}>
          <Component error={true} />
        </ErrorBoundary>
      )

      expect((await resolveCallback(await html.toString())).toString()).toEqual(
        '<div data-error="true">Error</div>'
      )

      suspenseCounter--
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/components.ts
```typescript
import { raw } from '../helper/html'
import type { HtmlEscapedCallback, HtmlEscapedString } from '../utils/html'
import { HtmlEscapedCallbackPhase, resolveCallback } from '../utils/html'
import { DOM_RENDERER } from './constants'
import { ErrorBoundary as ErrorBoundaryDomRenderer } from './dom/components'
import type { HasRenderToDom } from './dom/render'
import type { Child, FC, PropsWithChildren } from './'

let errorBoundaryCounter = 0

export const childrenToString = async (children: Child[]): Promise<HtmlEscapedString[]> => {
  try {
    return children
      .flat()
      .map((c) => (c == null || typeof c === 'boolean' ? '' : c.toString())) as HtmlEscapedString[]
  } catch (e) {
    if (e instanceof Promise) {
      await e
      return childrenToString(children)
    } else {
      throw e
    }
  }
}

export type ErrorHandler = (error: Error) => void
export type FallbackRender = (error: Error) => Child

/**
 * @experimental
 * `ErrorBoundary` is an experimental feature.
 * The API might be changed.
 */
export const ErrorBoundary: FC<
  PropsWithChildren<{
    fallback?: Child
    fallbackRender?: FallbackRender
    onError?: ErrorHandler
  }>
> = async ({ children, fallback, fallbackRender, onError }) => {
  if (!children) {
    return raw('')
  }

  if (!Array.isArray(children)) {
    children = [children]
  }

  let fallbackStr: string | undefined
  const fallbackRes = (error: Error): HtmlEscapedString => {
    onError?.(error)
    return (fallbackStr || fallbackRender?.(error) || '').toString() as HtmlEscapedString
  }
  let resArray: HtmlEscapedString[] | Promise<HtmlEscapedString[]>[] = []
  try {
    resArray = children.map((c) =>
      c == null || typeof c === 'boolean' ? '' : c.toString()
    ) as HtmlEscapedString[]
  } catch (e) {
    fallbackStr = await fallback?.toString()
    if (e instanceof Promise) {
      resArray = [
        e.then(() => childrenToString(children as Child[])).catch((e) => fallbackRes(e)),
      ] as Promise<HtmlEscapedString[]>[]
    } else {
      resArray = [fallbackRes(e as Error)]
    }
  }

  if (resArray.some((res) => (res as {}) instanceof Promise)) {
    fallbackStr ||= await fallback?.toString()
    const index = errorBoundaryCounter++
    const replaceRe = RegExp(`(<template id="E:${index}"></template>.*?)(.*?)(<!--E:${index}-->)`)
    const caught = false
    const catchCallback = ({ error, buffer }: { error: Error; buffer?: [string] }) => {
      if (caught) {
        return ''
      }

      const fallbackResString = fallbackRes(error)
      if (buffer) {
        buffer[0] = buffer[0].replace(replaceRe, fallbackResString)
      }
      return buffer
        ? ''
        : `<template data-hono-target="E:${index}">${fallbackResString}</template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('E:${index}')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='E:${index}')
d.replaceWith(c.content)
})(document)
</script>`
    }

    let error: unknown
    const promiseAll = Promise.all(resArray).catch((e) => (error = e))
    return raw(`<template id="E:${index}"></template><!--E:${index}-->`, [
      ({ phase, buffer, context }) => {
        if (phase === HtmlEscapedCallbackPhase.BeforeStream) {
          return
        }
        return promiseAll
          .then(async (htmlArray: HtmlEscapedString[]) => {
            if (error) {
              throw error
            }
            htmlArray = htmlArray.flat()
            const content = htmlArray.join('')
            let html = buffer
              ? ''
              : `<template data-hono-target="E:${index}">${content}</template><script>
((d,c) => {
c=d.currentScript.previousSibling
d=d.getElementById('E:${index}')
if(!d)return
d.parentElement.insertBefore(c.content,d.nextSibling)
})(document)
</script>`

            if (htmlArray.every((html) => !(html as HtmlEscapedString).callbacks?.length)) {
              if (buffer) {
                buffer[0] = buffer[0].replace(replaceRe, content)
              }
              return html
            }

            if (buffer) {
              buffer[0] = buffer[0].replace(
                replaceRe,
                (_all, pre, _, post) => `${pre}${content}${post}`
              )
            }

            const callbacks = htmlArray
              .map((html) => (html as HtmlEscapedString).callbacks || [])
              .flat()

            if (phase === HtmlEscapedCallbackPhase.Stream) {
              html = await resolveCallback(
                html,
                HtmlEscapedCallbackPhase.BeforeStream,
                true,
                context
              )
            }

            let resolvedCount = 0
            const promises = callbacks.map<HtmlEscapedCallback>(
              (c) =>
                (...args) =>
                  c(...args)
                    ?.then((content) => {
                      resolvedCount++

                      if (buffer) {
                        if (resolvedCount === callbacks.length) {
                          buffer[0] = buffer[0].replace(replaceRe, (_all, _pre, content) => content)
                        }
                        buffer[0] += content
                        return raw('', (content as HtmlEscapedString).callbacks)
                      }

                      return raw(
                        content +
                          (resolvedCount !== callbacks.length
                            ? ''
                            : `<script>
((d,c,n) => {
d=d.getElementById('E:${index}')
if(!d)return
n=d.nextSibling
while(n.nodeType!=8||n.nodeValue!='E:${index}'){n=n.nextSibling}
n.remove()
d.remove()
})(document)
</script>`),
                        (content as HtmlEscapedString).callbacks
                      )
                    })
                    .catch((error) => catchCallback({ error, buffer }))
            )

            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return raw(html, promises as any)
          })
          .catch((error) => catchCallback({ error, buffer }))
      },
    ])
  } else {
    return raw(resArray.join(''))
  }
}
;(ErrorBoundary as HasRenderToDom)[DOM_RENDERER] = ErrorBoundaryDomRenderer

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/constants.ts
```typescript
export const DOM_RENDERER = Symbol('RENDERER')
export const DOM_ERROR_HANDLER = Symbol('ERROR_HANDLER')
export const DOM_STASH = Symbol('STASH')
export const DOM_INTERNAL_TAG = Symbol('INTERNAL')
export const DOM_MEMO = Symbol('MEMO')
export const PERMALINK = Symbol('PERMALINK')

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/context.ts
```typescript
import { raw } from '../helper/html'
import type { HtmlEscapedString } from '../utils/html'
import { JSXFragmentNode } from './base'
import { DOM_RENDERER } from './constants'
import { createContextProviderFunction } from './dom/context'
import type { FC, PropsWithChildren } from './'

export interface Context<T> extends FC<PropsWithChildren<{ value: T }>> {
  values: T[]
  Provider: FC<PropsWithChildren<{ value: T }>>
}

export const globalContexts: Context<unknown>[] = []

export const createContext = <T>(defaultValue: T): Context<T> => {
  const values = [defaultValue]
  const context: Context<T> = ((props): HtmlEscapedString | Promise<HtmlEscapedString> => {
    values.push(props.value)
    let string
    try {
      string = props.children
        ? (Array.isArray(props.children)
            ? new JSXFragmentNode('', {}, props.children)
            : props.children
          ).toString()
        : ''
    } finally {
      values.pop()
    }

    if (string instanceof Promise) {
      return string.then((resString) => raw(resString, (resString as HtmlEscapedString).callbacks))
    } else {
      return raw(string)
    }
  }) as Context<T>
  context.values = values
  context.Provider = context

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ;(context as any)[DOM_RENDERER] = createContextProviderFunction(values)

  globalContexts.push(context as Context<unknown>)

  return context
}

export const useContext = <T>(context: Context<T>): T => {
  return context.values.at(-1) as T
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/index.test.tsx
```
/** @jsxImportSource ./ */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { html } from '../helper/html'
import { Hono } from '../hono'
import { Suspense, renderToReadableStream } from './streaming'
import DefaultExport, { Fragment, StrictMode, createContext, memo, useContext, version } from '.'
import type { Context, FC, PropsWithChildren } from '.'

interface SiteData {
  title: string
  children?: any
}

describe('JSX middleware', () => {
  let app: Hono

  beforeEach(() => {
    app = new Hono()
  })

  it('Should render HTML strings', async () => {
    app.get('/', (c) => {
      return c.html(<h1>Hello</h1>)
    })
    const res = await app.request('http://localhost/')
    expect(res.status).toBe(200)
    expect(res.headers.get('Content-Type')).toBe('text/html; charset=UTF-8')
    expect(await res.text()).toBe('<h1>Hello</h1>')
  })

  it('Should be able to be used with html middleware', async () => {
    const Layout = (props: SiteData) => html`<!DOCTYPE html>
      <html>
        <head>
          <title>${props.title}</title>
        </head>
        <body>
          ${props.children}
        </body>
      </html>`

    const Content = (props: { siteData: SiteData; name: string }) => (
      <Layout {...props.siteData}>
        <h1>{props.name}</h1>
      </Layout>
    )

    app.get('/', (c) => {
      const props = {
        name: 'JSX',
        siteData: {
          title: 'with html middleware',
        },
      }
      return c.html(<Content {...props} />)
    })
    const res = await app.request('http://localhost/')
    expect(res.status).toBe(200)
    expect(res.headers.get('Content-Type')).toBe('text/html; charset=UTF-8')
    expect(await res.text()).toBe(`<!DOCTYPE html>
      <html>
        <head>
          <title>with html middleware</title>
        </head>
        <body>
          <h1>JSX</h1>
        </body>
      </html>`)
  })

  it('Should render async component', async () => {
    const ChildAsyncComponent = async () => {
      await new Promise((resolve) => setTimeout(resolve, 10))
      return <span>child async component</span>
    }

    const AsyncComponent = async () => {
      await new Promise((resolve) => setTimeout(resolve, 10))
      return (
        <h1>
          Hello from async component
          <ChildAsyncComponent />
        </h1>
      )
    }

    app.get('/', (c) => {
      return c.html(<AsyncComponent />)
    })
    const res = await app.request('http://localhost/')
    expect(res.status).toBe(200)
    expect(res.headers.get('Content-Type')).toBe('text/html; charset=UTF-8')
    expect(await res.text()).toBe(
      '<h1>Hello from async component<span>child async component</span></h1>'
    )
  })

  it('Should render async component with "html" tagged template strings', async () => {
    const AsyncComponent = async () => {
      await new Promise((resolve) => setTimeout(resolve, 10))
      return <h1>Hello from async component</h1>
    }

    app.get('/', (c) => {
      // prettier-ignore
      return c.html(
        html`<html><body>${(<AsyncComponent />)}</body></html>`
      )
    })
    const res = await app.request('http://localhost/')
    expect(res.status).toBe(200)
    expect(res.headers.get('Content-Type')).toBe('text/html; charset=UTF-8')
    expect(await res.text()).toBe('<html><body><h1>Hello from async component</h1></body></html>')
  })

  it('Should handle async component error', async () => {
    const componentError = new Error('Error from async error component')

    const AsyncComponent = async () => {
      await new Promise((resolve) => setTimeout(resolve, 10))
      return <h1>Hello from async component</h1>
    }
    const AsyncErrorComponent = async () => {
      await new Promise((resolve) => setTimeout(resolve, 0))
      throw componentError
    }

    let raisedError: any
    app.onError((e, c) => {
      raisedError = e
      return c.html('<html><body><h1>Error from onError</h1></body></html>', 500)
    })
    app.get('/', (c) => {
      return c.html(
        <>
          <AsyncComponent />
          <AsyncErrorComponent />
        </>
      )
    })

    const res = await app.request('http://localhost/')
    expect(res.status).toBe(500)
    expect(res.headers.get('Content-Type')).toBe('text/html; charset=UTF-8')
    expect(await res.text()).toBe('<html><body><h1>Error from onError</h1></body></html>')
    expect(raisedError).toBe(componentError)
  })
})

describe('render to string', () => {
  it('Nested array', () => {
    const template = (
      <p>
        {[[['a']], [['b']]].map((item1) =>
          item1.map((item2) => item2.map((item3) => <span>{item3}</span>))
        )}
      </p>
    )
    expect(template.toString()).toBe('<p><span>a</span><span>b</span></p>')
  })

  it('Empty elements are rended without closing tag', () => {
    const template = <input />
    expect(template.toString()).toBe('<input/>')
  })

  it('Empty elements with children are rended with children and closing tag', () => {
    const template = <link>https://example.com</link>
    expect(template.toString()).toBe('<link>https://example.com</link>')
  })

  it('Props value is null', () => {
    const template = <span data-hello={null}>Hello</span>
    expect(template.toString()).toBe('<span>Hello</span>')
  })

  it('Props value is undefined', () => {
    const template = <span data-hello={undefined}>Hello</span>
    expect(template.toString()).toBe('<span>Hello</span>')
  })

  describe('dangerouslySetInnerHTML', () => {
    it('Should render dangerouslySetInnerHTML', () => {
      const template = <span dangerouslySetInnerHTML={{ __html: '" is allowed here' }}></span>
      expect(template.toString()).toBe('<span>" is allowed here</span>')
    })

    it('Should get an error if both dangerouslySetInnerHTML and children are specified', () => {
      expect(() =>
        (<span dangerouslySetInnerHTML={{ __html: '" is allowed here' }}>Hello</span>).toString()
      ).toThrow()
    })
  })

  // https://en.reactjs.org/docs/jsx-in-depth.html#booleans-null-and-undefined-are-ignored
  describe('Booleans, Null, and Undefined Are Ignored', () => {
    it.each([true, false, undefined, null])('%s', (item) => {
      expect((<span>{item}</span>).toString()).toBe('<span></span>')
    })

    it('falsy value', () => {
      const template = <span>{0}</span>
      expect(template.toString()).toBe('<span>0</span>')
    })
  })

  // https://en.reactjs.org/docs/jsx-in-depth.html#props-default-to-true
  describe('Props Default to “True”', () => {
    it('default prop value', () => {
      const template = <span data-hello>Hello</span>
      expect(template.toString()).toBe('<span data-hello="true">Hello</span>')
    })
  })

  // https://html.spec.whatwg.org/#attributes-3
  describe('Boolean attribute', () => {
    it('default prop value for checked', () => {
      const template = <input type='checkbox' checked />
      expect(template.toString()).toBe('<input type="checkbox" checked=""/>')
    })

    it('default prop value for checked={true}', () => {
      const template = <input type='checkbox' checked={true} />
      expect(template.toString()).toBe('<input type="checkbox" checked=""/>')
    })

    it('no prop for checked={false}', () => {
      const template = <input type='checkbox' checked={false} />
      expect(template.toString()).toBe('<input type="checkbox"/>')
    })

    it('default prop value for disabled', () => {
      const template = <input type='checkbox' disabled />
      expect(template.toString()).toBe('<input type="checkbox" disabled=""/>')
    })

    it('default prop value for disabled={true}', () => {
      const template = <input type='checkbox' disabled={true} />
      expect(template.toString()).toBe('<input type="checkbox" disabled=""/>')
    })

    it('no prop for disabled={false}', () => {
      const template = <input type='checkbox' disabled={false} />
      expect(template.toString()).toBe('<input type="checkbox"/>')
    })

    it('default prop value for readonly', () => {
      const template = <input type='checkbox' readonly />
      expect(template.toString()).toBe('<input type="checkbox" readonly=""/>')
    })

    it('default prop value for readonly={true}', () => {
      const template = <input type='checkbox' readonly={true} />
      expect(template.toString()).toBe('<input type="checkbox" readonly=""/>')
    })

    it('no prop for readonly={false}', () => {
      const template = <input type='checkbox' readonly={false} />
      expect(template.toString()).toBe('<input type="checkbox"/>')
    })

    it('default prop value for selected', () => {
      const template = (
        <option value='test' selected>
          Test
        </option>
      )
      expect(template.toString()).toBe('<option value="test" selected="">Test</option>')
    })

    it('default prop value for selected={true}', () => {
      const template = (
        <option value='test' selected={true}>
          Test
        </option>
      )
      expect(template.toString()).toBe('<option value="test" selected="">Test</option>')
    })

    it('no prop for selected={false}', () => {
      const template = (
        <option value='test' selected={false}>
          Test
        </option>
      )
      expect(template.toString()).toBe('<option value="test">Test</option>')
    })

    it('default prop value for multiple select', () => {
      const template = (
        <select multiple>
          <option>test</option>
        </select>
      )
      expect(template.toString()).toBe('<select multiple=""><option>test</option></select>')
    })

    it('default prop value for select multiple={true}', () => {
      const template = (
        <select multiple={true}>
          <option>test</option>
        </select>
      )
      expect(template.toString()).toBe('<select multiple=""><option>test</option></select>')
    })

    it('no prop for select multiple={false}', () => {
      const template = (
        <select multiple={false}>
          <option>test</option>
        </select>
      )
      expect(template.toString()).toBe('<select><option>test</option></select>')
    })

    it('should render "false" value properly for other non-defined keys', () => {
      const template = <input type='checkbox' testkey={false} />
      expect(template.toString()).toBe('<input type="checkbox" testkey="false"/>')
    })

    it('should support attributes for elements other than input', () => {
      const template = (
        <video controls autoplay>
          <source src='movie.mp4' type='video/mp4' />
        </video>
      )
      expect(template.toString()).toBe(
        '<video controls="" autoplay=""><source src="movie.mp4" type="video/mp4"/></video>'
      )
    })
  })

  describe('download attribute', () => {
    it('<a download={true}></a> should be rendered as <a download=""></a>', () => {
      const template = <a download={true}></a>
      expect(template.toString()).toBe('<a download=""></a>')
    })

    it('<a download={false}></a> should be rendered as <a></a>', () => {
      const template = <a download={false}></a>
      expect(template.toString()).toBe('<a></a>')
    })

    it('<a download></a> should be rendered as <a download=""></a>', () => {
      const template = <a download></a>
      expect(template.toString()).toBe('<a download=""></a>')
    })

    it('<a download="test"></a> should be rendered as <a download="test"></a>', () => {
      const template = <a download='test'></a>
      expect(template.toString()).toBe('<a download="test"></a>')
    })
  })

  describe('Function', () => {
    it('should be ignored used in on* props', () => {
      const onClick = () => {}
      const template = <button onClick={onClick}>Click</button>
      expect(template.toString()).toBe('<button>Click</button>')
    })

    it('should raise an error if used in other props', () => {
      const onClick = () => {}
      const template = <button data-handler={onClick}>Click</button>
      expect(() => template.toString()).toThrow()
    })
  })

  // https://en.reactjs.org/docs/jsx-in-depth.html#functions-as-children
  describe('Functions as Children', () => {
    it('Function', () => {
      function Repeat(props: any) {
        const items = []
        for (let i = 0; i < props.numTimes; i++) {
          items.push((props.children as Function)(i))
        }
        return <div>{items}</div>
      }

      function ListOfTenThings() {
        return (
          <Repeat numTimes={10}>
            {(index: string) => <div key={index}>This is item {index} in the list</div>}
          </Repeat>
        )
      }

      const template = <ListOfTenThings />
      expect(template.toString()).toBe(
        '<div><div>This is item 0 in the list</div><div>This is item 1 in the list</div><div>This is item 2 in the list</div><div>This is item 3 in the list</div><div>This is item 4 in the list</div><div>This is item 5 in the list</div><div>This is item 6 in the list</div><div>This is item 7 in the list</div><div>This is item 8 in the list</div><div>This is item 9 in the list</div></div>'
      )
    })
  })

  describe('FC', () => {
    it('Should define the type correctly', () => {
      const Layout: FC<PropsWithChildren<{ title: string }>> = (props) => {
        return (
          <html>
            <head>
              <title>{props.title}</title>
            </head>
            <body>{props.children}</body>
          </html>
        )
      }

      const Top = (
        <Layout title='Home page'>
          <h1>Hono</h1>
          <p>Hono is great</p>
        </Layout>
      )

      expect(Top.toString()).toBe(
        '<html><head><title>Home page</title></head><body><h1>Hono</h1><p>Hono is great</p></body></html>'
      )
    })

    describe('Booleans, Null, and Undefined Are Ignored', () => {
      it.each([true, false, undefined, null])('%s', (item) => {
        const Component: FC = (() => {
          return item
        }) as FC
        const template = <Component />
        expect(template.toString()).toBe('')
      })

      it('falsy value', () => {
        const Component: FC = (() => {
          return 0
        }) as unknown as FC
        const template = <Component />
        expect(template.toString()).toBe('0')
      })
    })
  })

  describe('style attribute', () => {
    it('should convert the object to strings', () => {
      const template = (
        <h1
          style={{
            color: 'red',
            fontSize: 'small',
            fontFamily: 'Menlo, Consolas, "DejaVu Sans Mono", monospace',
          }}
        >
          Hello
        </h1>
      )
      expect(template.toString()).toBe(
        '<h1 style="color:red;font-size:small;font-family:Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace">Hello</h1>'
      )
    })
    it('should not convert the strings', () => {
      const template = <h1 style='color:red;font-size:small'>Hello</h1>
      expect(template.toString()).toBe('<h1 style="color:red;font-size:small">Hello</h1>')
    })
    it('should render variable without any name conversion', () => {
      const template = <h1 style={{ '--myVar': 1 }}>Hello</h1>
      expect(template.toString()).toBe('<h1 style="--myVar:1px">Hello</h1>')
    })
  })

  describe('HtmlEscaped in props', () => {
    it('should not be double-escaped', () => {
      const escapedString = html`${'<html-escaped-string>'}`
      const template = <span data-text={escapedString}>Hello</span>
      expect(template.toString()).toBe('<span data-text="&lt;html-escaped-string&gt;">Hello</span>')
    })
  })

  describe('head', () => {
    it('Simple head elements should be rendered as is', () => {
      const template = (
        <head>
          <title>Hono!</title>
          <meta name='description' content='A description' />
          <script src='script.js'></script>
        </head>
      )
      expect(template.toString()).toBe(
        '<head><title>Hono!</title><meta name="description" content="A description"/><script src="script.js"></script></head>'
      )
    })
  })
})

describe('className', () => {
  it('should convert to class attribute for intrinsic elements', () => {
    const template = <h1 className='h1'>Hello</h1>
    expect(template.toString()).toBe('<h1 class="h1">Hello</h1>')
  })

  it('should convert to class attribute for custom elements', () => {
    const template = <custom-element className='h1'>Hello</custom-element>
    expect(template.toString()).toBe('<custom-element class="h1">Hello</custom-element>')
  })

  it('should not convert to class attribute for custom components', () => {
    const CustomComponent: FC<{ className: string }> = ({ className }) => (
      <div data-class-name={className}>Hello</div>
    )
    const template = <CustomComponent className='h1' />
    expect(template.toString()).toBe('<div data-class-name="h1">Hello</div>')
  })
})

describe('memo', () => {
  it('memoized', () => {
    let counter = 0
    const Header = memo(() => <title>Test Site {counter}</title>)
    const Body = () => <span>{counter}</span>

    let template = (
      <html>
        <head>
          <Header />
        </head>
        <body>
          <Body />
        </body>
      </html>
    )
    expect(template.toString()).toBe(
      '<html><head><title>Test Site 0</title></head><body><span>0</span></body></html>'
    )

    counter++
    template = (
      <html>
        <head>
          <Header />
        </head>
        <body>
          <Body />
        </body>
      </html>
    )
    expect(template.toString()).toBe(
      '<html><head><title>Test Site 0</title></head><body><span>1</span></body></html>'
    )
  })

  it('props are updated', () => {
    const Body = memo(({ counter }: { counter: number }) => <span>{counter}</span>)

    let template = <Body counter={0} />
    expect(template.toString()).toBe('<span>0</span>')

    template = <Body counter={1} />
    expect(template.toString()).toBe('<span>1</span>')
  })

  it('custom propsAreEqual', () => {
    const Body = memo(
      ({ counter }: { counter: number; refresh?: boolean }) => <span>{counter}</span>,
      (_, nextProps) => (typeof nextProps.refresh == 'undefined' ? true : !nextProps.refresh)
    )

    let template = <Body counter={0} />
    expect(template.toString()).toBe('<span>0</span>')

    template = <Body counter={1} />
    expect(template.toString()).toBe('<span>0</span>')

    template = <Body counter={2} refresh={true} />
    expect(template.toString()).toBe('<span>2</span>')
  })
})

describe('Fragment', () => {
  it('Should render children', () => {
    const template = (
      <>
        <p>1</p>
        <p>2</p>
      </>
    )
    expect(template.toString()).toBe('<p>1</p><p>2</p>')
  })

  it('Should render children - with `Fragment`', () => {
    const template = (
      <Fragment>
        <p>1</p>
        <p>2</p>
      </Fragment>
    )
    expect(template.toString()).toBe('<p>1</p><p>2</p>')
  })

  it('Should render a child', () => {
    const template = (
      <>
        <p>1</p>
      </>
    )
    expect(template.toString()).toBe('<p>1</p>')
  })

  it('Should render a child - with `Fragment`', () => {
    const template = (
      <Fragment>
        <p>1</p>
      </Fragment>
    )
    expect(template.toString()).toBe('<p>1</p>')
  })

  it('Should render nothing for empty Fragment', () => {
    const template = <></>
    expect(template.toString()).toBe('')
  })

  it('Should render nothing for undefined', () => {
    const template = <>{undefined}</>
    expect(template.toString()).toBe('')
  })
})

describe('StrictMode', () => {
  it('Should render children', () => {
    const template = (
      <StrictMode>
        <p>1</p>
        <p>2</p>
      </StrictMode>
    )
    expect(template.toString()).toBe('<p>1</p><p>2</p>')
  })
})

describe('SVG', () => {
  it('simple', () => {
    const template = (
      <svg>
        <circle cx='50' cy='50' r='40' stroke='black' stroke-width='3' fill='red' />
      </svg>
    )
    expect(template.toString()).toBe(
      '<svg><circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red"></circle></svg>'
    )
  })

  it('title element', () => {
    const template = (
      <>
        <head>
          <title>Document Title</title>
        </head>
        <svg>
          <title>SVG Title</title>
        </svg>
      </>
    )
    expect(template.toString()).toBe(
      '<head><title>Document Title</title></head><svg><title>SVG Title</title></svg>'
    )
  })

  describe('attribute', () => {
    describe('camelCase', () => {
      test.each`
        key
        ${'attributeName'}
        ${'baseFrequency'}
        ${'calcMode'}
        ${'clipPathUnits'}
        ${'diffuseConstant'}
        ${'edgeMode'}
        ${'filterUnits'}
        ${'gradientTransform'}
        ${'gradientUnits'}
        ${'kernelMatrix'}
        ${'kernelUnitLength'}
        ${'keyPoints'}
        ${'keySplines'}
        ${'keyTimes'}
        ${'lengthAdjust'}
        ${'limitingConeAngle'}
        ${'markerHeight'}
        ${'markerUnits'}
        ${'markerWidth'}
        ${'maskContentUnits'}
        ${'maskUnits'}
        ${'numOctaves'}
        ${'pathLength'}
        ${'patternContentUnits'}
        ${'patternTransform'}
        ${'patternUnits'}
        ${'pointsAtX'}
        ${'pointsAtY'}
        ${'pointsAtZ'}
        ${'preserveAlpha'}
        ${'preserveAspectRatio'}
        ${'primitiveUnits'}
        ${'refX'}
        ${'refY'}
        ${'repeatCount'}
        ${'repeatDur'}
        ${'specularConstant'}
        ${'specularExponent'}
        ${'spreadMethod'}
        ${'startOffset'}
        ${'stdDeviation'}
        ${'stitchTiles'}
        ${'surfaceScale'}
        ${'crossorigin'}
        ${'systemLanguage'}
        ${'tableValues'}
        ${'targetX'}
        ${'targetY'}
        ${'textLength'}
        ${'viewBox'}
        ${'xChannelSelector'}
        ${'yChannelSelector'}
      `('$key', ({ key }) => {
        const template = (
          <svg>
            <g {...{ [key]: 'test' }} />
          </svg>
        )
        expect(template.toString()).toBe(`<svg><g ${key}="test"></g></svg>`)
      })
    })

    describe('kebab-case', () => {
      test.each`
        key
        ${'alignmentBaseline'}
        ${'baselineShift'}
        ${'clipPath'}
        ${'clipRule'}
        ${'colorInterpolation'}
        ${'colorInterpolationFilters'}
        ${'dominantBaseline'}
        ${'fillOpacity'}
        ${'fillRule'}
        ${'floodColor'}
        ${'floodOpacity'}
        ${'fontFamily'}
        ${'fontSize'}
        ${'fontSizeAdjust'}
        ${'fontStretch'}
        ${'fontStyle'}
        ${'fontVariant'}
        ${'fontWeight'}
        ${'imageRendering'}
        ${'letterSpacing'}
        ${'lightingColor'}
        ${'markerEnd'}
        ${'markerMid'}
        ${'markerStart'}
        ${'overlinePosition'}
        ${'overlineThickness'}
        ${'paintOrder'}
        ${'pointerEvents'}
        ${'shapeRendering'}
        ${'stopColor'}
        ${'stopOpacity'}
        ${'strikethroughPosition'}
        ${'strikethroughThickness'}
        ${'strokeDasharray'}
        ${'strokeDashoffset'}
        ${'strokeLinecap'}
        ${'strokeLinejoin'}
        ${'strokeMiterlimit'}
        ${'strokeOpacity'}
        ${'strokeWidth'}
        ${'textAnchor'}
        ${'textDecoration'}
        ${'textRendering'}
        ${'transformOrigin'}
        ${'underlinePosition'}
        ${'underlineThickness'}
        ${'unicodeBidi'}
        ${'vectorEffect'}
        ${'wordSpacing'}
        ${'writingMode'}
      `('$key', ({ key }) => {
        const template = (
          <svg>
            <g {...{ [key]: 'test' }} />
          </svg>
        )
        expect(template.toString()).toBe(
          `<svg><g ${key.replace(/([A-Z])/g, '-$1').toLowerCase()}="test"></g></svg>`
        )
      })
    })

    describe('data-*', () => {
      test.each`
        key
        ${'data-foo'}
        ${'data-foo-bar'}
        ${'data-fooBar'}
      `('$key', ({ key }) => {
        const template = (
          <svg>
            <g {...{ [key]: 'test' }} />
          </svg>
        )
        expect(template.toString()).toBe(`<svg><g ${key}="test"></g></svg>`)
      })
    })
  })
})

describe('Context', () => {
  let ThemeContext: Context<string>
  let Consumer: FC
  let ErrorConsumer: FC
  let AsyncConsumer: FC
  let AsyncErrorConsumer: FC
  beforeAll(() => {
    ThemeContext = createContext('light')
    Consumer = () => {
      const theme = useContext(ThemeContext)
      return <span>{theme}</span>
    }
    ErrorConsumer = () => {
      throw new Error('ErrorConsumer')
    }
    AsyncConsumer = async () => {
      const theme = useContext(ThemeContext)
      return <span>{theme}</span>
    }
    AsyncErrorConsumer = async () => {
      throw new Error('AsyncErrorConsumer')
    }
  })

  describe('with .Provider', () => {
    it('has a child', () => {
      const template = (
        <ThemeContext.Provider value='dark'>
          <Consumer />
        </ThemeContext.Provider>
      )
      expect(template.toString()).toBe('<span>dark</span>')
    })

    it('has children', () => {
      const template = (
        <ThemeContext.Provider value='dark'>
          <div>
            <Consumer />!
          </div>
          <div>
            <Consumer />!
          </div>
        </ThemeContext.Provider>
      )
      expect(template.toString()).toBe('<div><span>dark</span>!</div><div><span>dark</span>!</div>')
    })

    it('nested', () => {
      const template = (
        <ThemeContext.Provider value='dark'>
          <Consumer />
          <ThemeContext.Provider value='black'>
            <Consumer />
          </ThemeContext.Provider>
          <Consumer />
        </ThemeContext.Provider>
      )
      expect(template.toString()).toBe('<span>dark</span><span>black</span><span>dark</span>')
    })

    it('should reset context by error', () => {
      const template = (
        <ThemeContext.Provider value='dark'>
          <ErrorConsumer />
        </ThemeContext.Provider>
      )
      expect(() => template.toString()).toThrow()

      const nextRequest = <Consumer />
      expect(nextRequest.toString()).toBe('<span>light</span>')
    })
  })

  describe('<Context> as a provider ', () => {
    it('has a child', () => {
      const template = (
        <ThemeContext value='dark'>
          <Consumer />
        </ThemeContext>
      )
      expect(template.toString()).toBe('<span>dark</span>')
    })
  })

  it('default value', () => {
    const template = <Consumer />
    expect(template.toString()).toBe('<span>light</span>')
  })

  describe('with Suspence', () => {
    const RedTheme = () => (
      <ThemeContext.Provider value='red'>
        <Consumer />
      </ThemeContext.Provider>
    )

    it('Should preserve context in sync component', async () => {
      const template = (
        <ThemeContext.Provider value='dark'>
          <Suspense fallback={<RedTheme />}>
            <Consumer />
            <ThemeContext.Provider value='black'>
              <Consumer />
            </ThemeContext.Provider>
          </Suspense>
        </ThemeContext.Provider>
      )
      const stream = renderToReadableStream(template)

      const chunks = []
      const textDecoder = new TextDecoder()
      for await (const chunk of stream as any) {
        chunks.push(textDecoder.decode(chunk))
      }

      expect(chunks).toEqual(['<span>dark</span><span>black</span>'])
    })

    it('Should preserve context in async component', async () => {
      const template = (
        <ThemeContext.Provider value='dark'>
          <Suspense fallback={<RedTheme />}>
            <Consumer />
            <ThemeContext.Provider value='black'>
              <AsyncConsumer />
            </ThemeContext.Provider>
          </Suspense>
        </ThemeContext.Provider>
      )
      const stream = renderToReadableStream(template)

      const chunks = []
      const textDecoder = new TextDecoder()
      for await (const chunk of stream as any) {
        chunks.push(textDecoder.decode(chunk))
      }

      expect(chunks).toEqual([
        '<template id="H:0"></template><span>red</span><!--/$-->',
        `<template data-hono-target="H:0"><span>dark</span><span>black</span></template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:0')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
</script>`,
      ])
    })
  })

  describe('async component', () => {
    const ParentAsyncConsumer = async () => {
      const theme = useContext(ThemeContext)
      return (
        <div>
          <span>{theme}</span>
          <AsyncConsumer />
        </div>
      )
    }

    const ParentAsyncErrorConsumer = async () => {
      const theme = useContext(ThemeContext)
      return (
        <div>
          <span>{theme}</span>
          <AsyncErrorConsumer />
        </div>
      )
    }

    it('simple', async () => {
      const template = (
        <ThemeContext.Provider value='dark'>
          <AsyncConsumer />
        </ThemeContext.Provider>
      )
      expect((await template.toString()).toString()).toBe('<span>dark</span>')
    })

    it('nested', async () => {
      const template = (
        <ThemeContext.Provider value='dark'>
          <ParentAsyncConsumer />
        </ThemeContext.Provider>
      )
      expect((await template.toString()).toString()).toBe(
        '<div><span>dark</span><span>dark</span></div>'
      )
    })

    it('should reset context by error', async () => {
      const template = (
        <ThemeContext.Provider value='dark'>
          <ParentAsyncErrorConsumer />
        </ThemeContext.Provider>
      )
      await expect(async () => (await template.toString()).toString()).rejects.toThrow()

      const nextRequest = <Consumer />
      expect(nextRequest.toString()).toBe('<span>light</span>')
    })
  })
})

describe('version', () => {
  it('should be defined with semantic versioning format', () => {
    expect(version).toMatch(/^\d+\.\d+\.\d+-hono-jsx$/)
  })
})

describe('default export', () => {
  ;[
    'version',
    'memo',
    'Fragment',
    'isValidElement',
    'createElement',
    'cloneElement',
    'ErrorBoundary',
    'createContext',
    'useContext',
    'useState',
    'useEffect',
    'useRef',
    'useCallback',
    'useReducer',
    'useDebugValue',
    'createRef',
    'forwardRef',
    'useImperativeHandle',
    'useSyncExternalStore',
    'use',
    'startTransition',
    'useTransition',
    'useDeferredValue',
    'startViewTransition',
    'useViewTransition',
    'useMemo',
    'useLayoutEffect',
    'useInsertionEffect',
    'useActionState',
    'useOptimistic',
    'Suspense',
    'StrictMode',
  ].forEach((key) => {
    it(key, () => {
      expect((DefaultExport as any)[key]).toBeDefined()
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/index.ts
```typescript
/**
 * @module
 * JSX for Hono.
 */

import { Fragment, cloneElement, isValidElement, jsx, memo, reactAPICompatVersion } from './base'
import type { DOMAttributes } from './base'
import { Children } from './children'
import { ErrorBoundary } from './components'
import { createContext, useContext } from './context'
import { useActionState, useOptimistic } from './dom/hooks'
import {
  createRef,
  forwardRef,
  startTransition,
  startViewTransition,
  use,
  useCallback,
  useDebugValue,
  useDeferredValue,
  useEffect,
  useId,
  useImperativeHandle,
  useInsertionEffect,
  useLayoutEffect,
  useMemo,
  useReducer,
  useRef,
  useState,
  useSyncExternalStore,
  useTransition,
  useViewTransition,
} from './hooks'
import { Suspense } from './streaming'

export {
  reactAPICompatVersion as version,
  jsx,
  memo,
  Fragment,
  Fragment as StrictMode,
  isValidElement,
  jsx as createElement,
  cloneElement,
  ErrorBoundary,
  createContext,
  useContext,
  useState,
  useEffect,
  useRef,
  useCallback,
  useReducer,
  useId,
  useDebugValue,
  use,
  startTransition,
  useTransition,
  useDeferredValue,
  startViewTransition,
  useViewTransition,
  useMemo,
  useLayoutEffect,
  useInsertionEffect,
  createRef,
  forwardRef,
  useImperativeHandle,
  useSyncExternalStore,
  useActionState,
  useOptimistic,
  Suspense,
  Children,
  DOMAttributes,
}

export default {
  version: reactAPICompatVersion,
  memo,
  Fragment,
  StrictMode: Fragment,
  isValidElement,
  createElement: jsx,
  cloneElement,
  ErrorBoundary,
  createContext,
  useContext,
  useState,
  useEffect,
  useRef,
  useCallback,
  useReducer,
  useId,
  useDebugValue,
  use,
  startTransition,
  useTransition,
  useDeferredValue,
  startViewTransition,
  useViewTransition,
  useMemo,
  useLayoutEffect,
  useInsertionEffect,
  createRef,
  forwardRef,
  useImperativeHandle,
  useSyncExternalStore,
  useActionState,
  useOptimistic,
  Suspense,
  Children,
}

export type * from './types'

export type { JSX } from './intrinsic-elements'

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/intrinsic-elements.ts
```typescript
/* eslint-disable @typescript-eslint/no-explicit-any */

import type { BaseMime } from '../utils/mime'
import type { StringLiteralUnion } from '../utils/types'

/**
 * This code is based on React.
 * https://github.com/facebook/react
 * MIT License
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 */

// eslint-disable-next-line @typescript-eslint/no-namespace
export namespace JSX {
  export type CrossOrigin = 'anonymous' | 'use-credentials' | '' | undefined
  export interface CSSProperties {
    [propertyKey: string]: unknown
  }
  type AnyAttributes = { [attributeName: string]: any }

  interface JSXAttributes {
    dangerouslySetInnerHTML?: {
      __html: string
    }
  }

  interface EventAttributes {
    onScroll?: (event: Event) => void
    onScrollCapture?: (event: Event) => void
    onScrollEnd?: (event: Event) => void
    onScrollEndCapture?: (event: Event) => void
    onWheel?: (event: WheelEvent) => void
    onWheelCapture?: (event: WheelEvent) => void
    onAnimationCancel?: (event: AnimationEvent) => void
    onAnimationCancelCapture?: (event: AnimationEvent) => void
    onAnimationEnd?: (event: AnimationEvent) => void
    onAnimationEndCapture?: (event: AnimationEvent) => void
    onAnimationIteration?: (event: AnimationEvent) => void
    onAnimationIterationCapture?: (event: AnimationEvent) => void
    onAnimationStart?: (event: AnimationEvent) => void
    onAnimationStartCapture?: (event: AnimationEvent) => void
    onCopy?: (event: ClipboardEvent) => void
    onCopyCapture?: (event: ClipboardEvent) => void
    onCut?: (event: ClipboardEvent) => void
    onCutCapture?: (event: ClipboardEvent) => void
    onPaste?: (event: ClipboardEvent) => void
    onPasteCapture?: (event: ClipboardEvent) => void
    onCompositionEnd?: (event: CompositionEvent) => void
    onCompositionEndCapture?: (event: CompositionEvent) => void
    onCompositionStart?: (event: CompositionEvent) => void
    onCompositionStartCapture?: (event: CompositionEvent) => void
    onCompositionUpdate?: (event: CompositionEvent) => void
    onCompositionUpdateCapture?: (event: CompositionEvent) => void
    onBlur?: (event: FocusEvent) => void
    onBlurCapture?: (event: FocusEvent) => void
    onFocus?: (event: FocusEvent) => void
    onFocusCapture?: (event: FocusEvent) => void
    onFocusIn?: (event: FocusEvent) => void
    onFocusInCapture?: (event: FocusEvent) => void
    onFocusOut?: (event: FocusEvent) => void
    onFocusOutCapture?: (event: FocusEvent) => void
    onFullscreenChange?: (event: Event) => void
    onFullscreenChangeCapture?: (event: Event) => void
    onFullscreenError?: (event: Event) => void
    onFullscreenErrorCapture?: (event: Event) => void
    onKeyDown?: (event: KeyboardEvent) => void
    onKeyDownCapture?: (event: KeyboardEvent) => void
    onKeyPress?: (event: KeyboardEvent) => void
    onKeyPressCapture?: (event: KeyboardEvent) => void
    onKeyUp?: (event: KeyboardEvent) => void
    onKeyUpCapture?: (event: KeyboardEvent) => void
    onAuxClick?: (event: MouseEvent) => void
    onAuxClickCapture?: (event: MouseEvent) => void
    onClick?: (event: MouseEvent) => void
    onClickCapture?: (event: MouseEvent) => void
    onContextMenu?: (event: MouseEvent) => void
    onContextMenuCapture?: (event: MouseEvent) => void
    onDoubleClick?: (event: MouseEvent) => void
    onDoubleClickCapture?: (event: MouseEvent) => void
    onMouseDown?: (event: MouseEvent) => void
    onMouseDownCapture?: (event: MouseEvent) => void
    onMouseEnter?: (event: MouseEvent) => void
    onMouseEnterCapture?: (event: MouseEvent) => void
    onMouseLeave?: (event: MouseEvent) => void
    onMouseLeaveCapture?: (event: MouseEvent) => void
    onMouseMove?: (event: MouseEvent) => void
    onMouseMoveCapture?: (event: MouseEvent) => void
    onMouseOut?: (event: MouseEvent) => void
    onMouseOutCapture?: (event: MouseEvent) => void
    onMouseOver?: (event: MouseEvent) => void
    onMouseOverCapture?: (event: MouseEvent) => void
    onMouseUp?: (event: MouseEvent) => void
    onMouseUpCapture?: (event: MouseEvent) => void
    onMouseWheel?: (event: WheelEvent) => void
    onMouseWheelCapture?: (event: WheelEvent) => void
    onGotPointerCapture?: (event: PointerEvent) => void
    onGotPointerCaptureCapture?: (event: PointerEvent) => void
    onLostPointerCapture?: (event: PointerEvent) => void
    onLostPointerCaptureCapture?: (event: PointerEvent) => void
    onPointerCancel?: (event: PointerEvent) => void
    onPointerCancelCapture?: (event: PointerEvent) => void
    onPointerDown?: (event: PointerEvent) => void
    onPointerDownCapture?: (event: PointerEvent) => void
    onPointerEnter?: (event: PointerEvent) => void
    onPointerEnterCapture?: (event: PointerEvent) => void
    onPointerLeave?: (event: PointerEvent) => void
    onPointerLeaveCapture?: (event: PointerEvent) => void
    onPointerMove?: (event: PointerEvent) => void
    onPointerMoveCapture?: (event: PointerEvent) => void
    onPointerOut?: (event: PointerEvent) => void
    onPointerOutCapture?: (event: PointerEvent) => void
    onPointerOver?: (event: PointerEvent) => void
    onPointerOverCapture?: (event: PointerEvent) => void
    onPointerUp?: (event: PointerEvent) => void
    onPointerUpCapture?: (event: PointerEvent) => void
    onTouchCancel?: (event: TouchEvent) => void
    onTouchCancelCapture?: (event: TouchEvent) => void
    onTouchEnd?: (event: TouchEvent) => void
    onTouchEndCapture?: (event: TouchEvent) => void
    onTouchMove?: (event: TouchEvent) => void
    onTouchMoveCapture?: (event: TouchEvent) => void
    onTouchStart?: (event: TouchEvent) => void
    onTouchStartCapture?: (event: TouchEvent) => void
    onTransitionCancel?: (event: TransitionEvent) => void
    onTransitionCancelCapture?: (event: TransitionEvent) => void
    onTransitionEnd?: (event: TransitionEvent) => void
    onTransitionEndCapture?: (event: TransitionEvent) => void
    onTransitionRun?: (event: TransitionEvent) => void
    onTransitionRunCapture?: (event: TransitionEvent) => void
    onTransitionStart?: (event: TransitionEvent) => void
    onTransitionStartCapture?: (event: TransitionEvent) => void
    onFormData?: (event: FormDataEvent) => void
    onFormDataCapture?: (event: FormDataEvent) => void
    onReset?: (event: Event) => void
    onResetCapture?: (event: Event) => void
    onSubmit?: (event: Event) => void
    onSubmitCapture?: (event: Event) => void
    onInvalid?: (event: Event) => void
    onInvalidCapture?: (event: Event) => void
    onSelect?: (event: Event) => void
    onSelectCapture?: (event: Event) => void
    onSelectChange?: (event: Event) => void
    onSelectChangeCapture?: (event: Event) => void
    onInput?: (event: InputEvent) => void
    onInputCapture?: (event: InputEvent) => void
    onBeforeInput?: (event: InputEvent) => void
    onBeforeInputCapture?: (event: InputEvent) => void
    onChange?: (event: Event) => void
    onChangeCapture?: (event: Event) => void
  }

  export interface HTMLAttributes extends JSXAttributes, EventAttributes, AnyAttributes {
    accesskey?: string | undefined
    autocapitalize?: 'off' | 'none' | 'on' | 'sentences' | 'words' | 'characters' | undefined
    autofocus?: boolean | undefined
    class?: string | Promise<string> | undefined
    contenteditable?: boolean | 'inherit' | undefined
    contextmenu?: string | undefined
    dir?: string | undefined
    draggable?: 'true' | 'false' | boolean | undefined
    enterkeyhint?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send' | undefined
    hidden?: boolean | undefined
    id?: string | undefined
    inert?: boolean | undefined
    inputmode?:
      | 'none'
      | 'text'
      | 'tel'
      | 'url'
      | 'email'
      | 'numeric'
      | 'decimal'
      | 'search'
      | undefined
    is?: string | undefined
    itemid?: string | undefined
    itemprop?: string | undefined
    itemref?: string | undefined
    itemscope?: boolean | undefined
    itemtype?: string | undefined
    lang?: string | undefined
    nonce?: string | undefined
    placeholder?: string | undefined
    /** @see https://developer.mozilla.org/en-US/docs/Web/API/Popover_API */
    popover?: boolean | 'auto' | 'manual' | undefined
    slot?: string | undefined
    spellcheck?: boolean | undefined
    style?: CSSProperties | string | undefined
    tabindex?: number | undefined
    title?: string | undefined
    translate?: 'yes' | 'no' | undefined
    itemProp?: string | undefined
  }

  type HTMLAttributeReferrerPolicy =
    | ''
    | 'no-referrer'
    | 'no-referrer-when-downgrade'
    | 'origin'
    | 'origin-when-cross-origin'
    | 'same-origin'
    | 'strict-origin'
    | 'strict-origin-when-cross-origin'
    | 'unsafe-url'

  type HTMLAttributeAnchorTarget = StringLiteralUnion<'_self' | '_blank' | '_parent' | '_top'>

  interface AnchorHTMLAttributes extends HTMLAttributes {
    download?: string | boolean | undefined
    href?: string | undefined
    hreflang?: string | undefined
    media?: string | undefined
    ping?: string | undefined
    target?: HTMLAttributeAnchorTarget | undefined
    type?: StringLiteralUnion<BaseMime> | undefined
    referrerpolicy?: HTMLAttributeReferrerPolicy | undefined
  }

  interface AudioHTMLAttributes extends MediaHTMLAttributes {}

  interface AreaHTMLAttributes extends HTMLAttributes {
    alt?: string | undefined
    coords?: string | undefined
    download?: string | boolean | undefined
    href?: string | undefined
    hreflang?: string | undefined
    media?: string | undefined
    referrerpolicy?: HTMLAttributeReferrerPolicy | undefined
    shape?: string | undefined
    target?: HTMLAttributeAnchorTarget | undefined
  }

  interface BaseHTMLAttributes extends HTMLAttributes {
    href?: string | undefined
    target?: HTMLAttributeAnchorTarget | undefined
  }

  interface BlockquoteHTMLAttributes extends HTMLAttributes {
    cite?: string | undefined
  }

  /** @see https://developer.mozilla.org/en-US/docs/Web/API/Popover_API */
  type HTMLAttributePopoverTargetAction = 'show' | 'hide' | 'toggle'

  interface ButtonHTMLAttributes extends HTMLAttributes {
    disabled?: boolean | undefined
    form?: string | undefined
    formenctype?: HTMLAttributeFormEnctype | undefined
    formmethod?: HTMLAttributeFormMethod | undefined
    formnovalidate?: boolean | undefined
    formtarget?: HTMLAttributeAnchorTarget | undefined
    name?: string | undefined
    type?: 'submit' | 'reset' | 'button' | undefined
    value?: string | ReadonlyArray<string> | number | undefined
    popovertarget?: string | undefined
    popovertargetaction?: HTMLAttributePopoverTargetAction | undefined

    // React 19 compatibility
    formAction?: string | Function | undefined
  }

  interface CanvasHTMLAttributes extends HTMLAttributes {
    height?: number | string | undefined
    width?: number | string | undefined
  }

  interface ColHTMLAttributes extends HTMLAttributes {
    span?: number | undefined
    width?: number | string | undefined
  }

  interface ColgroupHTMLAttributes extends HTMLAttributes {
    span?: number | undefined
  }

  interface DataHTMLAttributes extends HTMLAttributes {
    value?: string | ReadonlyArray<string> | number | undefined
  }

  interface DetailsHTMLAttributes extends HTMLAttributes {
    open?: boolean | undefined
  }

  interface DelHTMLAttributes extends HTMLAttributes {
    cite?: string | undefined
    dateTime?: string | undefined
  }

  interface DialogHTMLAttributes extends HTMLAttributes {
    open?: boolean | undefined
  }

  interface EmbedHTMLAttributes extends HTMLAttributes {
    height?: number | string | undefined
    src?: string | undefined
    type?: StringLiteralUnion<BaseMime> | undefined
    width?: number | string | undefined
  }

  interface FieldsetHTMLAttributes extends HTMLAttributes {
    disabled?: boolean | undefined
    form?: string | undefined
    name?: string | undefined
  }

  /** @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#method */
  type HTMLAttributeFormMethod = 'get' | 'post' | 'dialog'
  /** @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#enctype */
  type HTMLAttributeFormEnctype =
    | 'application/x-www-form-urlencoded'
    | 'multipart/form-data'
    | 'text/plain'
  /** @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#autocomplete */
  type HTMLAttributeFormAutocomplete = 'on' | 'off'

  interface FormHTMLAttributes extends HTMLAttributes {
    'accept-charset'?: StringLiteralUnion<'utf-8'> | undefined
    autocomplete?: HTMLAttributeFormAutocomplete | undefined
    enctype?: HTMLAttributeFormEnctype | undefined
    method?: HTMLAttributeFormMethod | undefined
    name?: string | undefined
    novalidate?: boolean | undefined
    target?: HTMLAttributeAnchorTarget | undefined

    // React 19 compatibility
    action?: string | Function | undefined
  }

  interface HtmlHTMLAttributes extends HTMLAttributes {
    manifest?: string | undefined
  }

  interface IframeHTMLAttributes extends HTMLAttributes {
    allow?: string | undefined
    allowfullscreen?: boolean | undefined
    height?: number | string | undefined
    loading?: 'eager' | 'lazy' | undefined
    name?: string | undefined
    referrerpolicy?: HTMLAttributeReferrerPolicy | undefined
    sandbox?: string | undefined
    seamless?: boolean | undefined
    src?: string | undefined
    srcdoc?: string | undefined
    width?: number | string | undefined
  }

  interface ImgHTMLAttributes extends HTMLAttributes {
    alt?: string | undefined
    crossorigin?: CrossOrigin
    decoding?: 'async' | 'auto' | 'sync' | undefined
    height?: number | string | undefined
    loading?: 'eager' | 'lazy' | undefined
    referrerpolicy?: HTMLAttributeReferrerPolicy | undefined
    sizes?: string | undefined
    src?: string | undefined
    srcset?: string | undefined
    usemap?: string | undefined
    width?: number | string | undefined
  }

  interface InsHTMLAttributes extends HTMLAttributes {
    cite?: string | undefined
    datetime?: string | undefined
  }

  type HTMLInputTypeAttribute = StringLiteralUnion<
    | 'button'
    | 'checkbox'
    | 'color'
    | 'date'
    | 'datetime-local'
    | 'email'
    | 'file'
    | 'hidden'
    | 'image'
    | 'month'
    | 'number'
    | 'password'
    | 'radio'
    | 'range'
    | 'reset'
    | 'search'
    | 'submit'
    | 'tel'
    | 'text'
    | 'time'
    | 'url'
    | 'week'
  >
  type AutoFillAddressKind = 'billing' | 'shipping'
  type AutoFillBase = '' | 'off' | 'on'
  type AutoFillContactField =
    | 'email'
    | 'tel'
    | 'tel-area-code'
    | 'tel-country-code'
    | 'tel-extension'
    | 'tel-local'
    | 'tel-local-prefix'
    | 'tel-local-suffix'
    | 'tel-national'
  type AutoFillContactKind = 'home' | 'mobile' | 'work'
  type AutoFillCredentialField = 'webauthn'
  type AutoFillNormalField =
    | 'additional-name'
    | 'address-level1'
    | 'address-level2'
    | 'address-level3'
    | 'address-level4'
    | 'address-line1'
    | 'address-line2'
    | 'address-line3'
    | 'bday-day'
    | 'bday-month'
    | 'bday-year'
    | 'cc-csc'
    | 'cc-exp'
    | 'cc-exp-month'
    | 'cc-exp-year'
    | 'cc-family-name'
    | 'cc-given-name'
    | 'cc-name'
    | 'cc-number'
    | 'cc-type'
    | 'country'
    | 'country-name'
    | 'current-password'
    | 'family-name'
    | 'given-name'
    | 'honorific-prefix'
    | 'honorific-suffix'
    | 'name'
    | 'new-password'
    | 'one-time-code'
    | 'organization'
    | 'postal-code'
    | 'street-address'
    | 'transaction-amount'
    | 'transaction-currency'
    | 'username'
  type OptionalPrefixToken<T extends string> = `${T} ` | ''
  type OptionalPostfixToken<T extends string> = ` ${T}` | ''
  type AutoFillField =
    | AutoFillNormalField
    | `${OptionalPrefixToken<AutoFillContactKind>}${AutoFillContactField}`
  type AutoFillSection = `section-${string}`
  type AutoFill =
    | AutoFillBase
    | `${OptionalPrefixToken<AutoFillSection>}${OptionalPrefixToken<AutoFillAddressKind>}${AutoFillField}${OptionalPostfixToken<AutoFillCredentialField>}`

  interface InputHTMLAttributes extends HTMLAttributes {
    accept?: string | undefined
    alt?: string | undefined
    autocomplete?: StringLiteralUnion<AutoFill> | undefined
    capture?: boolean | 'user' | 'environment' | undefined // https://www.w3.org/TR/html-media-capture/#the-capture-attribute
    checked?: boolean | undefined
    disabled?: boolean | undefined
    form?: string | undefined
    formenctype?: HTMLAttributeFormEnctype | undefined
    formmethod?: HTMLAttributeFormMethod | undefined
    formnovalidate?: boolean | undefined
    formtarget?: HTMLAttributeAnchorTarget | undefined
    height?: number | string | undefined
    list?: string | undefined
    max?: number | string | undefined
    maxlength?: number | undefined
    min?: number | string | undefined
    minlength?: number | undefined
    multiple?: boolean | undefined
    name?: string | undefined
    pattern?: string | undefined
    placeholder?: string | undefined
    readonly?: boolean | undefined
    required?: boolean | undefined
    size?: number | undefined
    src?: string | undefined
    step?: number | string | undefined
    type?: HTMLInputTypeAttribute | undefined
    value?: string | ReadonlyArray<string> | number | undefined
    width?: number | string | undefined
    popovertarget?: string | undefined
    popovertargetaction?: HTMLAttributePopoverTargetAction | undefined

    // React 19 compatibility
    formAction?: string | Function | undefined
  }

  interface KeygenHTMLAttributes extends HTMLAttributes {
    challenge?: string | undefined
    disabled?: boolean | undefined
    form?: string | undefined
    keytype?: string | undefined
    name?: string | undefined
  }

  interface LabelHTMLAttributes extends HTMLAttributes {
    form?: string | undefined
    for?: string | undefined
  }

  interface LiHTMLAttributes extends HTMLAttributes {
    value?: string | ReadonlyArray<string> | number | undefined
  }

  interface LinkHTMLAttributes extends HTMLAttributes {
    as?: string | undefined
    crossorigin?: CrossOrigin
    href?: string | undefined
    hreflang?: string | undefined
    integrity?: string | undefined
    media?: string | undefined
    imagesrcset?: string | undefined
    imagesizes?: string | undefined
    referrerpolicy?: HTMLAttributeReferrerPolicy | undefined
    sizes?: string | undefined
    type?: StringLiteralUnion<BaseMime> | undefined
    charSet?: string | undefined

    // React 19 compatibility
    rel?: string | undefined
    precedence?: string | undefined
    title?: string | undefined
    disabled?: boolean | undefined
    onError?: ((event: Event) => void) | undefined
    onLoad?: ((event: Event) => void) | undefined
    blocking?: 'render' | undefined
  }

  interface MapHTMLAttributes extends HTMLAttributes {
    name?: string | undefined
  }

  interface MenuHTMLAttributes extends HTMLAttributes {
    type?: string | undefined
  }

  interface MediaHTMLAttributes extends HTMLAttributes {
    autoplay?: boolean | undefined
    controls?: boolean | undefined
    controlslist?: string | undefined
    crossorigin?: CrossOrigin
    loop?: boolean | undefined
    mediagroup?: string | undefined
    muted?: boolean | undefined
    playsinline?: boolean | undefined
    preload?: string | undefined
    src?: string | undefined
  }

  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#http-equiv
   */
  type MetaHttpEquiv =
    | 'content-security-policy'
    | 'content-type'
    | 'default-style'
    | 'x-ua-compatible'
    | 'refresh'
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta/name
   */
  type MetaName =
    | 'application-name'
    | 'author'
    | 'description'
    | 'generator'
    | 'keywords'
    | 'referrer'
    | 'theme-color'
    | 'color-scheme'
    | 'viewport'
    | 'creator'
    | 'googlebot'
    | 'publisher'
    | 'robots'
  /**
   * @see https://ogp.me/
   */
  type MetaProperty =
    | 'og:title'
    | 'og:type'
    | 'og:image'
    | 'og:url'
    | 'og:audio'
    | 'og:description'
    | 'og:determiner'
    | 'og:locale'
    | 'og:locale:alternate'
    | 'og:site_name'
    | 'og:video'
    | 'og:image:url'
    | 'og:image:secure_url'
    | 'og:image:type'
    | 'og:image:width'
    | 'og:image:height'
    | 'og:image:alt'
  interface MetaHTMLAttributes extends HTMLAttributes {
    charset?: StringLiteralUnion<'utf-8'> | undefined
    'http-equiv'?: StringLiteralUnion<MetaHttpEquiv> | undefined
    name?: StringLiteralUnion<MetaName> | undefined
    media?: string | undefined
    content?: string | undefined
    property?: StringLiteralUnion<MetaProperty> | undefined

    // React 19 compatibility
    httpEquiv?: StringLiteralUnion<MetaHttpEquiv> | undefined
  }

  interface MeterHTMLAttributes extends HTMLAttributes {
    form?: string | undefined
    high?: number | undefined
    low?: number | undefined
    max?: number | string | undefined
    min?: number | string | undefined
    optimum?: number | undefined
    value?: string | ReadonlyArray<string> | number | undefined
  }

  interface QuoteHTMLAttributes extends HTMLAttributes {
    cite?: string | undefined
  }

  interface ObjectHTMLAttributes extends HTMLAttributes {
    data?: string | undefined
    form?: string | undefined
    height?: number | string | undefined
    name?: string | undefined
    type?: StringLiteralUnion<BaseMime> | undefined
    usemap?: string | undefined
    width?: number | string | undefined
  }

  interface OlHTMLAttributes extends HTMLAttributes {
    reversed?: boolean | undefined
    start?: number | undefined
    type?: '1' | 'a' | 'A' | 'i' | 'I' | undefined
  }

  interface OptgroupHTMLAttributes extends HTMLAttributes {
    disabled?: boolean | undefined
    label?: string | undefined
  }

  interface OptionHTMLAttributes extends HTMLAttributes {
    disabled?: boolean | undefined
    label?: string | undefined
    selected?: boolean | undefined
    value?: string | ReadonlyArray<string> | number | undefined
  }

  interface OutputHTMLAttributes extends HTMLAttributes {
    form?: string | undefined
    for?: string | undefined
    name?: string | undefined
  }

  interface ParamHTMLAttributes extends HTMLAttributes {
    name?: string | undefined
    value?: string | ReadonlyArray<string> | number | undefined
  }

  interface ProgressHTMLAttributes extends HTMLAttributes {
    max?: number | string | undefined
    value?: string | ReadonlyArray<string> | number | undefined
  }

  interface SlotHTMLAttributes extends HTMLAttributes {
    name?: string | undefined
  }

  interface ScriptHTMLAttributes extends HTMLAttributes {
    async?: boolean | undefined
    crossorigin?: CrossOrigin
    defer?: boolean | undefined
    integrity?: string | undefined
    nomodule?: boolean | undefined
    referrerpolicy?: HTMLAttributeReferrerPolicy | undefined
    src?: string | undefined
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type
     */
    type?: StringLiteralUnion<'' | 'text/javascript' | 'importmap' | 'module'> | undefined

    // React 19 compatibility
    crossOrigin?: CrossOrigin
    fetchPriority?: string | undefined
    noModule?: boolean | undefined
    referrer?: HTMLAttributeReferrerPolicy | undefined
    onError?: ((event: Event) => void) | undefined
    onLoad?: ((event: Event) => void) | undefined
    blocking?: 'render' | undefined
  }

  interface SelectHTMLAttributes extends HTMLAttributes {
    autocomplete?: string | undefined
    disabled?: boolean | undefined
    form?: string | undefined
    multiple?: boolean | undefined
    name?: string | undefined
    required?: boolean | undefined
    size?: number | undefined
    value?: string | ReadonlyArray<string> | number | undefined
  }

  type MediaMime = BaseMime & (`image/${string}` | `audio/${string}` | `video/${string}`)
  interface SourceHTMLAttributes extends HTMLAttributes {
    height?: number | string | undefined
    media?: string | undefined
    sizes?: string | undefined
    src?: string | undefined
    srcset?: string | undefined
    type?: StringLiteralUnion<MediaMime> | undefined
    width?: number | string | undefined
  }

  interface StyleHTMLAttributes extends HTMLAttributes {
    media?: string | undefined
    scoped?: boolean | undefined
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style#type
     */
    type?: '' | 'text/css' | undefined

    // React 19 compatibility
    href?: string | undefined
    precedence?: string | undefined
    title?: string | undefined
    disabled?: boolean | undefined
    blocking?: 'render' | undefined
  }

  interface TableHTMLAttributes extends HTMLAttributes {
    align?: 'left' | 'center' | 'right' | undefined
    bgcolor?: string | undefined
    border?: number | undefined
    cellpadding?: number | string | undefined
    cellspacing?: number | string | undefined
    frame?: boolean | undefined
    rules?: 'none' | 'groups' | 'rows' | 'columns' | 'all' | undefined
    summary?: string | undefined
    width?: number | string | undefined
  }

  interface TextareaHTMLAttributes extends HTMLAttributes {
    autocomplete?: string | undefined
    cols?: number | undefined
    dirname?: string | undefined
    disabled?: boolean | undefined
    form?: string | undefined
    maxlength?: number | undefined
    minlength?: number | undefined
    name?: string | undefined
    placeholder?: string | undefined
    readonly?: boolean | undefined
    required?: boolean | undefined
    rows?: number | undefined
    value?: string | ReadonlyArray<string> | number | undefined
    wrap?: string | undefined
  }

  interface TdHTMLAttributes extends HTMLAttributes {
    align?: 'left' | 'center' | 'right' | 'justify' | 'char' | undefined
    colspan?: number | undefined
    headers?: string | undefined
    rowspan?: number | undefined
    scope?: string | undefined
    abbr?: string | undefined
    height?: number | string | undefined
    width?: number | string | undefined
    valign?: 'top' | 'middle' | 'bottom' | 'baseline' | undefined
  }

  interface ThHTMLAttributes extends HTMLAttributes {
    align?: 'left' | 'center' | 'right' | 'justify' | 'char' | undefined
    colspan?: number | undefined
    headers?: string | undefined
    rowspan?: number | undefined
    scope?: 'row' | 'col' | 'rowgroup' | 'colgroup' | string | undefined
    abbr?: string | undefined
  }

  interface TimeHTMLAttributes extends HTMLAttributes {
    datetime?: string | undefined
  }

  interface TrackHTMLAttributes extends HTMLAttributes {
    default?: boolean | undefined
    kind?: string | undefined
    label?: string | undefined
    src?: string | undefined
    srclang?: string | undefined
  }

  interface VideoHTMLAttributes extends MediaHTMLAttributes {
    height?: number | string | undefined
    playsinline?: boolean | undefined
    poster?: string | undefined
    width?: number | string | undefined
    disablePictureInPicture?: boolean | undefined
    disableRemotePlayback?: boolean | undefined
  }

  export interface IntrinsicElements {
    a: AnchorHTMLAttributes
    abbr: HTMLAttributes
    address: HTMLAttributes
    area: AreaHTMLAttributes
    article: HTMLAttributes
    aside: HTMLAttributes
    audio: AudioHTMLAttributes
    b: HTMLAttributes
    base: BaseHTMLAttributes
    bdi: HTMLAttributes
    bdo: HTMLAttributes
    big: HTMLAttributes
    blockquote: BlockquoteHTMLAttributes
    body: HTMLAttributes
    br: HTMLAttributes
    button: ButtonHTMLAttributes
    canvas: CanvasHTMLAttributes
    caption: HTMLAttributes
    center: HTMLAttributes
    cite: HTMLAttributes
    code: HTMLAttributes
    col: ColHTMLAttributes
    colgroup: ColgroupHTMLAttributes
    data: DataHTMLAttributes
    datalist: HTMLAttributes
    dd: HTMLAttributes
    del: DelHTMLAttributes
    details: DetailsHTMLAttributes
    dfn: HTMLAttributes
    dialog: DialogHTMLAttributes
    div: HTMLAttributes
    dl: HTMLAttributes
    dt: HTMLAttributes
    em: HTMLAttributes
    embed: EmbedHTMLAttributes
    fieldset: FieldsetHTMLAttributes
    figcaption: HTMLAttributes
    figure: HTMLAttributes
    footer: HTMLAttributes
    form: FormHTMLAttributes
    h1: HTMLAttributes
    h2: HTMLAttributes
    h3: HTMLAttributes
    h4: HTMLAttributes
    h5: HTMLAttributes
    h6: HTMLAttributes
    head: HTMLAttributes
    header: HTMLAttributes
    hgroup: HTMLAttributes
    hr: HTMLAttributes
    html: HtmlHTMLAttributes
    i: HTMLAttributes
    iframe: IframeHTMLAttributes
    img: ImgHTMLAttributes
    input: InputHTMLAttributes
    ins: InsHTMLAttributes
    kbd: HTMLAttributes
    keygen: KeygenHTMLAttributes
    label: LabelHTMLAttributes
    legend: HTMLAttributes
    li: LiHTMLAttributes
    link: LinkHTMLAttributes
    main: HTMLAttributes
    map: MapHTMLAttributes
    mark: HTMLAttributes
    menu: MenuHTMLAttributes
    menuitem: HTMLAttributes
    meta: MetaHTMLAttributes
    meter: MeterHTMLAttributes
    nav: HTMLAttributes
    noscript: HTMLAttributes
    object: ObjectHTMLAttributes
    ol: OlHTMLAttributes
    optgroup: OptgroupHTMLAttributes
    option: OptionHTMLAttributes
    output: OutputHTMLAttributes
    p: HTMLAttributes
    param: ParamHTMLAttributes
    picture: HTMLAttributes
    pre: HTMLAttributes
    progress: ProgressHTMLAttributes
    q: QuoteHTMLAttributes
    rp: HTMLAttributes
    rt: HTMLAttributes
    ruby: HTMLAttributes
    s: HTMLAttributes
    samp: HTMLAttributes
    search: HTMLAttributes
    slot: SlotHTMLAttributes
    script: ScriptHTMLAttributes
    section: HTMLAttributes
    select: SelectHTMLAttributes
    small: HTMLAttributes
    source: SourceHTMLAttributes
    span: HTMLAttributes
    strong: HTMLAttributes
    style: StyleHTMLAttributes
    sub: HTMLAttributes
    summary: HTMLAttributes
    sup: HTMLAttributes
    table: TableHTMLAttributes
    template: HTMLAttributes
    tbody: HTMLAttributes
    td: TdHTMLAttributes
    textarea: TextareaHTMLAttributes
    tfoot: HTMLAttributes
    th: ThHTMLAttributes
    thead: HTMLAttributes
    time: TimeHTMLAttributes
    title: HTMLAttributes
    tr: HTMLAttributes
    track: TrackHTMLAttributes
    u: HTMLAttributes
    ul: HTMLAttributes
    var: HTMLAttributes
    video: VideoHTMLAttributes
    wbr: HTMLAttributes
  }
}

export interface IntrinsicElements extends JSX.IntrinsicElements {}

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/jsx-dev-runtime.ts
```typescript
/**
 * @module
 * This module provides Hono's JSX dev runtime.
 */

import type { HtmlEscapedString } from '../utils/html'
import { jsxFn } from './base'
import type { JSXNode } from './base'
export { Fragment } from './base'
export type { JSX } from './base'

export function jsxDEV(
  tag: string | Function,
  props: Record<string, unknown>,
  key?: string
): JSXNode {
  let node: JSXNode
  if (!props || !('children' in props)) {
    node = jsxFn(tag, props, [])
  } else {
    const children = props.children as string | HtmlEscapedString
    node = Array.isArray(children) ? jsxFn(tag, props, children) : jsxFn(tag, props, [children])
  }
  node.key = key
  return node
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/jsx-runtime.test.tsx
```
/** @jsxRuntime automatic **/
/** @jsxImportSource . **/
import { Hono } from '../hono'

describe('jsx-runtime', () => {
  let app: Hono

  beforeEach(() => {
    app = new Hono()
  })

  it('Should render HTML strings', async () => {
    app.get('/', (c) => {
      return c.html(<h1>Hello</h1>)
    })
    const res = await app.request('http://localhost/')
    expect(res.status).toBe(200)
    expect(res.headers.get('Content-Type')).toBe('text/html; charset=UTF-8')
    expect(await res.text()).toBe('<h1>Hello</h1>')
  })

  // https://en.reactjs.org/docs/jsx-in-depth.html#booleans-null-and-undefined-are-ignored
  describe('Booleans, Null, and Undefined Are Ignored', () => {
    it.each([true, false, undefined, null])('%s', (item) => {
      expect((<span>{item}</span>).toString()).toBe('<span></span>')
    })

    it('falsy value', () => {
      const template = <span>{0}</span>
      expect(template.toString()).toBe('<span>0</span>')
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/jsx-runtime.ts
```typescript
/**
 * @module
 * This module provides Hono's JSX runtime.
 */

export { jsxDEV as jsx, Fragment } from './jsx-dev-runtime'
export { jsxDEV as jsxs } from './jsx-dev-runtime'
export type { JSX } from './jsx-dev-runtime'
import { html, raw } from '../helper/html'
import type { HtmlEscapedString, StringBuffer, HtmlEscaped } from '../utils/html'
import { escapeToBuffer, stringBufferToString } from '../utils/html'
import { styleObjectForEach } from './utils'

export { html as jsxTemplate }

export const jsxAttr = (
  key: string,
  v: string | Promise<string> | Record<string, string | number | null | undefined | boolean>
): HtmlEscapedString | Promise<HtmlEscapedString> => {
  const buffer: StringBuffer = [`${key}="`] as StringBuffer
  if (key === 'style' && typeof v === 'object') {
    // object to style strings
    let styleStr = ''
    styleObjectForEach(v as Record<string, string | number>, (property, value) => {
      if (value != null) {
        styleStr += `${styleStr ? ';' : ''}${property}:${value}`
      }
    })
    escapeToBuffer(styleStr, buffer)
    buffer[0] += '"'
  } else if (typeof v === 'string') {
    escapeToBuffer(v, buffer)
    buffer[0] += '"'
  } else if (v === null || v === undefined) {
    return raw('')
  } else if (typeof v === 'number' || (v as unknown as HtmlEscaped).isEscaped) {
    buffer[0] += `${v}"`
  } else if (v instanceof Promise) {
    buffer.unshift('"', v)
  } else {
    escapeToBuffer(v.toString(), buffer)
    buffer[0] += '"'
  }

  return buffer.length === 1 ? raw(buffer[0]) : stringBufferToString(buffer, undefined)
}

export const jsxEscape = (value: string) => value

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/streaming.test.tsx
```
/** @jsxImportSource ./ */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { JSDOM } from 'jsdom'
import { raw } from '../helper/html'
import { HtmlEscapedCallbackPhase, resolveCallback } from '../utils/html'
import type { HtmlEscapedString } from '../utils/html'
import { use } from './hooks'
import { Suspense, renderToReadableStream } from './streaming'

function replacementResult(html: string) {
  const document = new JSDOM(html, { runScripts: 'dangerously' }).window.document
  document.querySelectorAll('template, script').forEach((e) => e.remove())
  return document.body.innerHTML
}

describe('Streaming', () => {
  let suspenseCounter = 0
  afterEach(() => {
    suspenseCounter++
  })

  it('Suspense / renderToReadableStream', async () => {
    let contentEvaluatedCount = 0
    const Content = () => {
      contentEvaluatedCount++
      const content = new Promise<HtmlEscapedString>((resolve) =>
        setTimeout(() => resolve(<h1>Hello</h1>), 10)
      )
      return content
    }

    const stream = renderToReadableStream(
      <Suspense fallback={<p>Loading...</p>}>
        <Content />
      </Suspense>
    )

    const chunks = []
    const textDecoder = new TextDecoder()
    for await (const chunk of stream as any) {
      chunks.push(textDecoder.decode(chunk))
    }

    expect(chunks).toEqual([
      `<template id="H:${suspenseCounter}"></template><p>Loading...</p><!--/$-->`,
      `<template data-hono-target="H:${suspenseCounter}"><h1>Hello</h1></template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:${suspenseCounter}')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
</script>`,
    ])

    expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual(
      '<h1>Hello</h1>'
    )

    expect(contentEvaluatedCount).toEqual(1)
  })

  it('`throw promise` inside Suspense', async () => {
    let contentEvaluatedCount = 0
    let resolvedContent: HtmlEscapedString | undefined = undefined
    const Content = () => {
      contentEvaluatedCount++
      if (!resolvedContent) {
        throw new Promise<void>((resolve) =>
          setTimeout(() => {
            resolvedContent = (<p>thrown a promise then resolved</p>) as HtmlEscapedString
            resolve()
          }, 10)
        )
      }
      return resolvedContent
    }

    const stream = renderToReadableStream(
      <Suspense fallback={<p>Loading...</p>}>
        <Content />
      </Suspense>
    )

    const chunks = []
    const textDecoder = new TextDecoder()
    for await (const chunk of stream as any) {
      chunks.push(textDecoder.decode(chunk))
    }

    expect(chunks).toEqual([
      `<template id="H:${suspenseCounter}"></template><p>Loading...</p><!--/$-->`,
      `<template data-hono-target="H:${suspenseCounter}"><p>thrown a promise then resolved</p></template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:${suspenseCounter}')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
</script>`,
    ])

    expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual(
      '<p>thrown a promise then resolved</p>'
    )

    expect(contentEvaluatedCount).toEqual(2)
  })

  it('simple content inside Suspense', async () => {
    const Content = () => {
      return <h1>Hello</h1>
    }

    const stream = renderToReadableStream(
      <Suspense fallback={<p>Loading...</p>}>
        <Content />
      </Suspense>
    )

    const chunks = []
    const textDecoder = new TextDecoder()
    for await (const chunk of stream as any) {
      chunks.push(textDecoder.decode(chunk))
    }

    expect(chunks).toEqual(['<h1>Hello</h1>'])

    suspenseCounter -= 1 // fallback is not rendered
  })

  it('nullish children', async () => {
    const stream = renderToReadableStream(
      <div>
        <Suspense fallback={<p>Loading...</p>}>{[null, undefined]}</Suspense>
      </div>
    )

    const chunks = []
    const textDecoder = new TextDecoder()
    for await (const chunk of stream as any) {
      chunks.push(textDecoder.decode(chunk))
    }

    expect(chunks).toEqual(['<div></div>'])

    suspenseCounter -= 1 // fallback is not rendered
  })

  it('async nullish children', async () => {
    let resolved = false
    const Content = () => {
      if (!resolved) {
        resolved = true
        throw new Promise<void>((r) =>
          setTimeout(() => {
            resolved = true
            r()
          }, 10)
        )
      }
      return <h1>Hello</h1>
    }

    const stream = renderToReadableStream(
      <Suspense fallback={<p>Loading...</p>}>
        <Content />
        {[null, undefined]}
      </Suspense>
    )

    const chunks = []
    const textDecoder = new TextDecoder()
    for await (const chunk of stream as any) {
      chunks.push(textDecoder.decode(chunk))
    }

    expect(chunks).toEqual([
      `<template id="H:${suspenseCounter}"></template><p>Loading...</p><!--/$-->`,
      `<template data-hono-target="H:${suspenseCounter}"><h1>Hello</h1></template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:${suspenseCounter}')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
</script>`,
    ])

    expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual(
      '<h1>Hello</h1>'
    )
  })

  it('boolean children', async () => {
    const stream = renderToReadableStream(
      <div>
        <Suspense fallback={<p>Loading...</p>}>{[true, false]}</Suspense>
      </div>
    )

    const chunks = []
    const textDecoder = new TextDecoder()
    for await (const chunk of stream as any) {
      chunks.push(textDecoder.decode(chunk))
    }

    expect(chunks).toEqual(['<div></div>'])

    suspenseCounter -= 1 // fallback is not rendered
  })

  it('async boolean children', async () => {
    let resolved = false
    const Content = () => {
      if (!resolved) {
        resolved = true
        throw new Promise<void>((r) =>
          setTimeout(() => {
            resolved = true
            r()
          }, 10)
        )
      }
      return <h1>Hello</h1>
    }

    const stream = renderToReadableStream(
      <Suspense fallback={<p>Loading...</p>}>
        <Content />
        {[true, false]}
      </Suspense>
    )

    const chunks = []
    const textDecoder = new TextDecoder()
    for await (const chunk of stream as any) {
      chunks.push(textDecoder.decode(chunk))
    }

    expect(chunks).toEqual([
      `<template id="H:${suspenseCounter}"></template><p>Loading...</p><!--/$-->`,
      `<template data-hono-target="H:${suspenseCounter}"><h1>Hello</h1></template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:${suspenseCounter}')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
</script>`,
    ])

    expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual(
      '<h1>Hello</h1>'
    )
  })

  it('children Suspense', async () => {
    const Content1 = () =>
      new Promise<HtmlEscapedString>((resolve) => setTimeout(() => resolve(<h1>Hello</h1>), 10))
    const Content2 = () =>
      new Promise<HtmlEscapedString>((resolve) => setTimeout(() => resolve(<h2>Hono</h2>), 10))

    const stream = renderToReadableStream(
      <Suspense fallback={<p>Loading...</p>}>
        <Suspense fallback={<p>Loading sub content1...</p>}>
          <Content1 />
        </Suspense>
        <Suspense fallback={<p>Loading sub content2...</p>}>
          <Content2 />
        </Suspense>
      </Suspense>
    )

    const chunks = []
    const textDecoder = new TextDecoder()
    for await (const chunk of stream as any) {
      chunks.push(textDecoder.decode(chunk))
    }

    expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual(
      '<h1>Hello</h1><h2>Hono</h2>'
    )

    suspenseCounter += 2
  })

  it('children Suspense: Suspense and string', async () => {
    const Content1 = () =>
      new Promise<HtmlEscapedString>((resolve) => setTimeout(() => resolve(<h1>Hello</h1>), 10))

    const stream = renderToReadableStream(
      <Suspense fallback={<p>Loading...</p>}>
        <Suspense fallback={<p>Loading sub content1...</p>}>
          <Content1 />
        </Suspense>
        Hono
      </Suspense>
    )

    const chunks = []
    const textDecoder = new TextDecoder()
    for await (const chunk of stream as any) {
      chunks.push(textDecoder.decode(chunk))
    }

    expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual(
      '<h1>Hello</h1>Hono'
    )

    suspenseCounter += 1
  })

  it('resolve(undefined)', async () => {
    const Content = async () => {
      const content = await Promise.resolve(undefined)
      return <p>{content}</p>
    }

    const stream = renderToReadableStream(
      <Suspense fallback={<p>Loading...</p>}>
        <Content />
      </Suspense>
    )

    const chunks = []
    const textDecoder = new TextDecoder()
    for await (const chunk of stream as any) {
      chunks.push(textDecoder.decode(chunk))
    }

    expect(chunks).toEqual([
      `<template id="H:${suspenseCounter}"></template><p>Loading...</p><!--/$-->`,
      `<template data-hono-target="H:${suspenseCounter}"><p></p></template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:${suspenseCounter}')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
</script>`,
    ])

    expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual('<p></p>')
  })

  it('resolve(null)', async () => {
    const Content = async () => {
      const content = await Promise.resolve(null)
      return <p>{content}</p>
    }

    const stream = renderToReadableStream(
      <Suspense fallback={<p>Loading...</p>}>
        <Content />
      </Suspense>
    )

    const chunks = []
    const textDecoder = new TextDecoder()
    for await (const chunk of stream as any) {
      chunks.push(textDecoder.decode(chunk))
    }

    expect(chunks).toEqual([
      `<template id="H:${suspenseCounter}"></template><p>Loading...</p><!--/$-->`,
      `<template data-hono-target="H:${suspenseCounter}"><p></p></template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:${suspenseCounter}')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
</script>`,
    ])

    expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual('<p></p>')
  })

  it('reject()', async () => {
    const Content = async () => {
      const content = await Promise.reject()
      return <p>{content}</p>
    }

    const onError = vi.fn()
    const stream = renderToReadableStream(
      <Suspense fallback={<p>Loading...</p>}>
        <Content />
      </Suspense>,
      onError
    )

    const chunks = []
    const textDecoder = new TextDecoder()
    for await (const chunk of stream as any) {
      chunks.push(textDecoder.decode(chunk))
    }

    expect(onError).toBeCalledTimes(1)

    expect(chunks).toEqual([
      `<template id="H:${suspenseCounter}"></template><p>Loading...</p><!--/$-->`,
      '',
    ])

    expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual(
      '<p>Loading...</p><!--/$-->'
    )
  })

  it('closed()', async () => {
    const Content = async () => {
      await new Promise<void>((resolve) =>
        setTimeout(() => {
          vi.spyOn(ReadableStreamDefaultController.prototype, 'enqueue').mockImplementation(() => {
            throw new Error('closed')
          })
          resolve()
        }, 10)
      )
      return <p>content</p>
    }

    const onError = vi.fn()
    const stream = renderToReadableStream(
      <>
        <Suspense fallback={<p>Loading...</p>}>
          <Content />
        </Suspense>
        <Suspense fallback={<p>Loading...</p>}>
          <Content />
        </Suspense>
      </>,
      onError
    )

    const chunks = []
    const textDecoder = new TextDecoder()
    for await (const chunk of stream as any) {
      chunks.push(textDecoder.decode(chunk))
    }

    expect(onError).toBeCalledTimes(1)

    expect(chunks).toEqual([
      `<template id="H:${suspenseCounter}"></template><p>Loading...</p><!--/$--><template id="H:${
        suspenseCounter + 1
      }"></template><p>Loading...</p><!--/$-->`,
    ])

    expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual(
      '<p>Loading...</p><!--/$--><p>Loading...</p><!--/$-->'
    )

    suspenseCounter++
    await new Promise((resolve) => setTimeout(resolve, 10))
    vi.restoreAllMocks()
  })

  it('Multiple "await" call', async () => {
    const delayedContent = new Promise<HtmlEscapedString>((resolve) =>
      setTimeout(() => resolve(<h1>Hello</h1>), 10)
    )
    const delayedContent2 = new Promise<HtmlEscapedString>((resolve) =>
      setTimeout(() => resolve(<h2>World</h2>), 10)
    )
    const Content = async () => {
      const content = await delayedContent
      const content2 = await delayedContent2
      return (
        <>
          {content}
          {content2}
        </>
      )
    }

    const stream = renderToReadableStream(
      <Suspense fallback={<p>Loading...</p>}>
        <Content />
      </Suspense>
    )

    const chunks = []
    const textDecoder = new TextDecoder()
    for await (const chunk of stream as any) {
      chunks.push(textDecoder.decode(chunk))
    }

    expect(chunks).toEqual([
      `<template id="H:${suspenseCounter}"></template><p>Loading...</p><!--/$-->`,
      `<template data-hono-target="H:${suspenseCounter}"><h1>Hello</h1><h2>World</h2></template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:${suspenseCounter}')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
</script>`,
    ])

    expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual(
      '<h1>Hello</h1><h2>World</h2>'
    )
  })

  it('Complex fallback content', async () => {
    const delayedContent = new Promise<HtmlEscapedString>((resolve) =>
      setTimeout(() => resolve(<h1>Hello</h1>), 10)
    )

    const Content = async () => {
      const content = await delayedContent
      return content
    }

    const stream = renderToReadableStream(
      <Suspense
        fallback={
          <>
            Loading<span>...</span>
          </>
        }
      >
        <Content />
      </Suspense>
    )

    const chunks = []
    const textDecoder = new TextDecoder()
    for await (const chunk of stream as any) {
      chunks.push(textDecoder.decode(chunk))
    }

    expect(chunks).toEqual([
      `<template id="H:${suspenseCounter}"></template>Loading<span>...</span><!--/$-->`,
      `<template data-hono-target="H:${suspenseCounter}"><h1>Hello</h1></template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:${suspenseCounter}')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
</script>`,
    ])

    expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual(
      '<h1>Hello</h1>'
    )
  })

  it('nested Suspense', async () => {
    const SubContent = () => {
      const content = new Promise<HtmlEscapedString>((resolve) =>
        setTimeout(() => resolve(<h2>World</h2>), 10)
      )
      return content
    }

    const Content = () => {
      const content = new Promise<HtmlEscapedString>((resolve) =>
        setTimeout(
          () =>
            resolve(
              <>
                <h1>Hello</h1>
                <Suspense fallback={<p>Loading sub content...</p>}>
                  <SubContent />
                </Suspense>
              </>
            ),
          10
        )
      )
      return content
    }

    const stream = renderToReadableStream(
      <Suspense fallback={<p>Loading...</p>}>
        <Content />
      </Suspense>
    )

    const chunks = []
    const textDecoder = new TextDecoder()
    for await (const chunk of stream as any) {
      chunks.push(textDecoder.decode(chunk))
    }

    expect(chunks).toEqual([
      `<template id="H:${suspenseCounter}"></template><p>Loading...</p><!--/$-->`,
      `<template data-hono-target="H:${suspenseCounter}"><h1>Hello</h1><template id=\"H:${
        suspenseCounter + 1
      }\"></template><p>Loading sub content...</p><!--/$--></template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:${suspenseCounter}')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
</script>`,
      `<template data-hono-target="H:${suspenseCounter + 1}"><h2>World</h2></template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:${suspenseCounter + 1}')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
</script>`,
    ])

    expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual(
      '<h1>Hello</h1><h2>World</h2>'
    )
    suspenseCounter++
  })

  it('In multiple Suspense, go ahead in the order of resolved', async () => {
    const SubContent2 = () => {
      const content = new Promise<HtmlEscapedString>((resolve) =>
        setTimeout(() => resolve(<p>first</p>), 20)
      )
      return content
    }
    const SubContent1 = () => {
      const content = new Promise<HtmlEscapedString>((resolve) =>
        setTimeout(
          () =>
            resolve(
              <Suspense fallback={<p>Loading content2...</p>}>
                <SubContent2 />
              </Suspense>
            ),
          10
        )
      )
      return content
    }
    const SubContent3 = () => {
      const content = new Promise<HtmlEscapedString>((resolve) =>
        setTimeout(() => resolve(<p>last</p>), 40)
      )
      return content
    }

    const Content = () => {
      const content = new Promise<HtmlEscapedString>((resolve) =>
        setTimeout(
          () =>
            resolve(
              <>
                <Suspense fallback={<p>Loading content1...</p>}>
                  <SubContent1 />
                </Suspense>
                <Suspense fallback={<p>Loading content3...</p>}>
                  <SubContent3 />
                </Suspense>
              </>
            ),
          10
        )
      )
      return content
    }

    const stream = renderToReadableStream(
      <Suspense fallback={<p>Loading...</p>}>
        <Content />
      </Suspense>
    )

    const chunks = []
    const textDecoder = new TextDecoder()
    for await (const chunk of stream as any) {
      chunks.push(textDecoder.decode(chunk))
    }

    expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual(
      '<p>first</p><p>last</p>'
    )
  })

  it('Suspense with resolveStream', async () => {
    let contentEvaluatedCount = 0
    const Content = () => {
      contentEvaluatedCount++
      const content = new Promise<HtmlEscapedString>((resolve) =>
        setTimeout(() => resolve(<h1>Hello</h1>), 10)
      )
      return content
    }

    const str = await resolveCallback(
      await (
        <Suspense fallback={<p>Loading...</p>}>
          <Content />
        </Suspense>
      ).toString(),
      HtmlEscapedCallbackPhase.Stream,
      false,
      {}
    )

    expect(str).toEqual('<h1>Hello</h1>')
    expect(contentEvaluatedCount).toEqual(1)
  })

  it('renderToReadableStream(str: string)', async () => {
    const str = '<h1>Hello</h1>'
    const stream = renderToReadableStream(raw(str))

    const chunks = []
    const textDecoder = new TextDecoder()
    for await (const chunk of stream as any) {
      chunks.push(textDecoder.decode(chunk))
    }

    expect(chunks).toEqual([str])
  })

  it('renderToReadableStream(promise: Promise<HtmlEscapedString>)', async () => {
    const stream = renderToReadableStream(Promise.resolve(raw('<h1>Hello</h1>')))

    const chunks = []
    const textDecoder = new TextDecoder()
    for await (const chunk of stream as any) {
      chunks.push(textDecoder.decode(chunk))
    }

    expect(chunks).toEqual(['<h1>Hello</h1>'])

    suspenseCounter++
  })

  describe('use()', async () => {
    it('render to string', async () => {
      const promise = new Promise((resolve) => setTimeout(() => resolve('Hello from use()'), 0))
      const Content = () => {
        const message = use(promise)
        return <h1>{message}</h1>
      }

      const str = await resolveCallback(
        await (
          <Suspense fallback={<p>Loading...</p>}>
            <Content />
          </Suspense>
        ).toString(),
        HtmlEscapedCallbackPhase.Stream,
        false,
        {}
      )
      expect(str).toEqual('<h1>Hello from use()</h1>')
    })

    it('render to stream', async () => {
      const promise = new Promise((resolve) => setTimeout(() => resolve('Hello from use()'), 0))
      const Content = () => {
        const message = use(promise)
        return <h1>{message}</h1>
      }

      const stream = renderToReadableStream(
        <Suspense fallback={<p>Loading...</p>}>
          <Content />
        </Suspense>
      )

      const chunks = []
      const textDecoder = new TextDecoder()
      for await (const chunk of stream as any) {
        chunks.push(textDecoder.decode(chunk))
      }

      expect(chunks).toEqual([
        `<template id="H:${suspenseCounter}"></template><p>Loading...</p><!--/$-->`,
        `<template data-hono-target="H:${suspenseCounter}"><h1>Hello from use()</h1></template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:${suspenseCounter}')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
</script>`,
      ])

      expect(replacementResult(`<html><body>${chunks.join('')}</body></html>`)).toEqual(
        '<h1>Hello from use()</h1>'
      )
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/streaming.ts
```typescript
/**
 * @module
 * This module enables JSX to supports streaming Response.
 */

import { raw } from '../helper/html'
import { HtmlEscapedCallbackPhase, resolveCallback } from '../utils/html'
import type { HtmlEscapedString } from '../utils/html'
import { JSXNode } from './base'
import { childrenToString } from './components'
import { DOM_RENDERER, DOM_STASH } from './constants'
import { Suspense as SuspenseDomRenderer } from './dom/components'
import { buildDataStack } from './dom/render'
import type { HasRenderToDom, NodeObject } from './dom/render'
import type { Child, FC, PropsWithChildren } from './'

let suspenseCounter = 0

/**
 * @experimental
 * `Suspense` is an experimental feature.
 * The API might be changed.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const Suspense: FC<PropsWithChildren<{ fallback: any }>> = async ({
  children,
  fallback,
}) => {
  if (!children) {
    return fallback.toString()
  }
  if (!Array.isArray(children)) {
    children = [children]
  }

  let resArray: HtmlEscapedString[] | Promise<HtmlEscapedString[]>[] = []

  // for use() hook
  const stackNode = { [DOM_STASH]: [0, []] } as unknown as NodeObject
  const popNodeStack = (value?: unknown) => {
    buildDataStack.pop()
    return value
  }

  try {
    stackNode[DOM_STASH][0] = 0
    buildDataStack.push([[], stackNode])
    resArray = children.map((c) =>
      c == null || typeof c === 'boolean' ? '' : c.toString()
    ) as HtmlEscapedString[]
  } catch (e) {
    if (e instanceof Promise) {
      resArray = [
        e.then(() => {
          stackNode[DOM_STASH][0] = 0
          buildDataStack.push([[], stackNode])
          return childrenToString(children as Child[]).then(popNodeStack)
        }),
      ] as Promise<HtmlEscapedString[]>[]
    } else {
      throw e
    }
  } finally {
    popNodeStack()
  }

  if (resArray.some((res) => (res as {}) instanceof Promise)) {
    const index = suspenseCounter++
    const fallbackStr = await fallback.toString()
    return raw(`<template id="H:${index}"></template>${fallbackStr}<!--/$-->`, [
      ...(fallbackStr.callbacks || []),
      ({ phase, buffer, context }) => {
        if (phase === HtmlEscapedCallbackPhase.BeforeStream) {
          return
        }
        return Promise.all(resArray).then(async (htmlArray) => {
          htmlArray = htmlArray.flat()
          const content = htmlArray.join('')
          if (buffer) {
            buffer[0] = buffer[0].replace(
              new RegExp(`<template id="H:${index}"></template>.*?<!--/\\$-->`),
              content
            )
          }
          let html = buffer
            ? ''
            : `<template data-hono-target="H:${index}">${content}</template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:${index}')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
</script>`

          const callbacks = htmlArray
            .map((html) => (html as HtmlEscapedString).callbacks || [])
            .flat()
          if (!callbacks.length) {
            return html
          }

          if (phase === HtmlEscapedCallbackPhase.Stream) {
            html = await resolveCallback(html, HtmlEscapedCallbackPhase.BeforeStream, true, context)
          }

          return raw(html, callbacks)
        })
      },
    ])
  } else {
    return raw(resArray.join(''))
  }
}
;(Suspense as HasRenderToDom)[DOM_RENDERER] = SuspenseDomRenderer

const textEncoder = new TextEncoder()
/**
 * @experimental
 * `renderToReadableStream()` is an experimental feature.
 * The API might be changed.
 */
export const renderToReadableStream = (
  content: HtmlEscapedString | JSXNode | Promise<HtmlEscapedString>,
  onError: (e: unknown) => string | void = console.trace
): ReadableStream<Uint8Array> => {
  const reader = new ReadableStream<Uint8Array>({
    async start(controller) {
      try {
        if (content instanceof JSXNode) {
          // aJSXNode.toString() returns a string or Promise<string> and string is already escaped
          content = content.toString() as HtmlEscapedString | Promise<HtmlEscapedString>
        }
        const context = typeof content === 'object' ? content : {}
        const resolved = await resolveCallback(
          content,
          HtmlEscapedCallbackPhase.BeforeStream,
          true,
          context
        )
        controller.enqueue(textEncoder.encode(resolved))

        let resolvedCount = 0
        const callbacks: Promise<void>[] = []
        const then = (promise: Promise<string>) => {
          callbacks.push(
            promise
              .catch((err) => {
                console.log(err)
                onError(err)
                return ''
              })
              .then(async (res) => {
                res = await resolveCallback(
                  res,
                  HtmlEscapedCallbackPhase.BeforeStream,
                  true,
                  context
                )
                ;(res as HtmlEscapedString).callbacks
                  ?.map((c) => c({ phase: HtmlEscapedCallbackPhase.Stream, context }))
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  .filter<Promise<string>>(Boolean as any)
                  .forEach(then)
                resolvedCount++
                controller.enqueue(textEncoder.encode(res))
              })
          )
        }
        ;(resolved as HtmlEscapedString).callbacks
          ?.map((c) => c({ phase: HtmlEscapedCallbackPhase.Stream, context }))
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          .filter<Promise<string>>(Boolean as any)
          .forEach(then)
        while (resolvedCount !== callbacks.length) {
          await Promise.all(callbacks)
        }
      } catch (e) {
        // maybe the connection was closed
        onError(e)
      }

      controller.close()
    },
  })
  return reader
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/types.ts
```typescript
/**
 * All types exported from "hono/jsx" are in this file.
 */
import type { Child, JSXNode } from './base'
import type { JSX } from './intrinsic-elements'

export type { Child, JSXNode, FC } from './base'
export type { RefObject } from './hooks'
export type { Context } from './context'

export type PropsWithChildren<P = unknown> = P & { children?: Child | undefined }
export type CSSProperties = JSX.CSSProperties

/**
 * React types
 */

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type ReactElement<P = any, T = string | Function> = JSXNode & {
  type: T
  props: P
  key: string | null
}
type ReactNode = ReactElement | string | number | boolean | null | undefined
// eslint-disable-next-line @typescript-eslint/no-unused-vars
type ComponentClass<P = {}, S = {}> = unknown

export type { ReactElement, ReactNode, ComponentClass }

export type Event = globalThis.Event
export type MouseEvent = globalThis.MouseEvent
export type KeyboardEvent = globalThis.KeyboardEvent
export type FocusEvent = globalThis.FocusEvent
export type ClipboardEvent = globalThis.ClipboardEvent
export type InputEvent = globalThis.InputEvent
export type PointerEvent = globalThis.PointerEvent
export type TouchEvent = globalThis.TouchEvent
export type WheelEvent = globalThis.WheelEvent
export type AnimationEvent = globalThis.AnimationEvent
export type TransitionEvent = globalThis.TransitionEvent
export type DragEvent = globalThis.DragEvent

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/utils.test.ts
```typescript
import { normalizeIntrinsicElementKey, styleObjectForEach } from './utils'

describe('normalizeIntrinsicElementKey', () => {
  test.each`
    key                | expected
    ${'className'}     | ${'class'}
    ${'htmlFor'}       | ${'for'}
    ${'crossOrigin'}   | ${'crossorigin'}
    ${'httpEquiv'}     | ${'http-equiv'}
    ${'itemProp'}      | ${'itemprop'}
    ${'fetchPriority'} | ${'fetchpriority'}
    ${'noModule'}      | ${'nomodule'}
    ${'formAction'}    | ${'formaction'}
    ${'href'}          | ${'href'}
  `('should convert $key to $expected', ({ key, expected }) => {
    expect(normalizeIntrinsicElementKey(key)).toBe(expected)
  })
})

describe('styleObjectForEach', () => {
  describe('Should output the number as it is, when a number type is passed', () => {
    test.each`
      property
      ${'animationIterationCount'}
      ${'aspectRatio'}
      ${'borderImageOutset'}
      ${'borderImageSlice'}
      ${'borderImageWidth'}
      ${'columnCount'}
      ${'columns'}
      ${'flex'}
      ${'flexGrow'}
      ${'flexPositive'}
      ${'flexShrink'}
      ${'flexNegative'}
      ${'flexOrder'}
      ${'gridArea'}
      ${'gridRow'}
      ${'gridRowEnd'}
      ${'gridRowSpan'}
      ${'gridRowStart'}
      ${'gridColumn'}
      ${'gridColumnEnd'}
      ${'gridColumnSpan'}
      ${'gridColumnStart'}
      ${'fontWeight'}
      ${'lineClamp'}
      ${'lineHeight'}
      ${'opacity'}
      ${'order'}
      ${'orphans'}
      ${'scale'}
      ${'tabSize'}
      ${'widows'}
      ${'zIndex'}
      ${'zoom'}
      ${'fillOpacity'}
      ${'floodOpacity'}
      ${'stopOpacity'}
      ${'strokeDasharray'}
      ${'strokeDashoffset'}
      ${'strokeMiterlimit'}
      ${'strokeOpacity'}
      ${'strokeWidth'}
    `('$property', ({ property }) => {
      const fn = vi.fn()
      styleObjectForEach({ [property]: 1 }, fn)
      expect(fn).toBeCalledWith(
        property.replace(/[A-Z]/g, (m: string) => `-${m.toLowerCase()}`),
        '1'
      )
    })
  })
  describe('Should output with px suffix, when a number type is passed', () => {
    test.each`
      property
      ${'borderBottomWidth'}
      ${'borderLeftWidth'}
      ${'borderRightWidth'}
      ${'borderTopWidth'}
      ${'borderWidth'}
      ${'bottom'}
      ${'fontSize'}
      ${'height'}
      ${'left'}
      ${'margin'}
      ${'marginBottom'}
      ${'marginLeft'}
      ${'marginRight'}
      ${'marginTop'}
      ${'padding'}
      ${'paddingBottom'}
      ${'paddingLeft'}
      ${'paddingRight'}
      ${'paddingTop'}
      ${'right'}
      ${'top'}
      ${'width'}
    `('$property', ({ property }) => {
      const fn = vi.fn()
      styleObjectForEach({ [property]: 1 }, fn)
      expect(fn).toBeCalledWith(
        property.replace(/[A-Z]/g, (m: string) => `-${m.toLowerCase()}`),
        '1px'
      )
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/utils.ts
```typescript
const normalizeElementKeyMap: Map<string, string> = new Map([
  ['className', 'class'],
  ['htmlFor', 'for'],
  ['crossOrigin', 'crossorigin'],
  ['httpEquiv', 'http-equiv'],
  ['itemProp', 'itemprop'],
  ['fetchPriority', 'fetchpriority'],
  ['noModule', 'nomodule'],
  ['formAction', 'formaction'],
])
export const normalizeIntrinsicElementKey = (key: string): string =>
  normalizeElementKeyMap.get(key) || key

export const styleObjectForEach = (
  style: Record<string, string | number>,
  fn: (key: string, value: string | null) => void
): void => {
  for (const [k, v] of Object.entries(style)) {
    const key =
      k[0] === '-' || !/[A-Z]/.test(k)
        ? k // a CSS variable or a lowercase only property
        : k.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`) // a camelCase property. convert to kebab-case
    fn(
      key,
      v == null
        ? null
        : typeof v === 'number'
        ? !key.match(
            /^(?:a|border-im|column(?:-c|s)|flex(?:$|-[^b])|grid-(?:ar|[^a])|font-w|li|or|sca|st|ta|wido|z)|ty$/
          )
          ? `${v}px`
          : `${v}`
        : v
    )
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/hooks/dom.test.tsx
```
/** @jsxImportSource ../ */
import { JSDOM } from 'jsdom'
// run tests by old style jsx default
// hono/jsx/jsx-runtime and hono/jsx/dom/jsx-runtime are tested in their respective settings
import { ErrorBoundary, Suspense, render } from '../dom'
import {
  createRef,
  forwardRef,
  startTransition,
  startViewTransition,
  use,
  useDebugValue,
  useDeferredValue,
  useId,
  useImperativeHandle,
  useReducer,
  useState,
  useSyncExternalStore,
  useTransition,
  useViewTransition,
} from '.'

describe('Hooks', () => {
  beforeAll(() => {
    global.requestAnimationFrame = (cb) => setTimeout(cb)
  })

  let dom: JSDOM
  let root: HTMLElement
  beforeEach(() => {
    dom = new JSDOM('<html><body><div id="root"></div></body></html>', {
      runScripts: 'dangerously',
    })
    global.document = dom.window.document
    global.HTMLElement = dom.window.HTMLElement
    global.SVGElement = dom.window.SVGElement
    global.Text = dom.window.Text
    root = document.getElementById('root') as HTMLElement
  })

  describe('useReducer()', () => {
    it('simple', async () => {
      const reducer = (state: number, action: number) => state + action
      const functions: Function[] = []
      const App = () => {
        const [state, dispatch] = useReducer(reducer, 0)
        functions.push(dispatch)
        return (
          <div>
            <button onClick={() => dispatch(1)}>{state}</button>
          </div>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button>0</button></div>')
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><button>1</button></div>')
      expect(functions[0]).toBe(functions[1])
    })
  })

  describe('startTransition()', () => {
    it('no error', async () => {
      const App = () => {
        const [count, setCount] = useState(0)
        return (
          <Suspense fallback={<div>Loading...</div>}>
            <div>
              <button
                onClick={() => {
                  startTransition(() => {
                    setCount((c) => c + 1)
                  })
                }}
              >
                {count}
              </button>
            </div>
          </Suspense>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button>0</button></div>')
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><button>1</button></div>')
    })

    it('got an error', async () => {
      let resolve: () => void
      const promise = new Promise<void>((r) => (resolve = r))

      const Counter = ({ count }: { count: number }) => {
        use(promise)
        return <div>{count}</div>
      }

      const App = () => {
        const [count, setCount] = useState(0)
        return (
          <Suspense fallback={<div>Loading...</div>}>
            <div>
              <button
                onClick={() => {
                  startTransition(() => {
                    setCount((c) => c + 1)
                  })
                }}
              >
                {count ? <Counter count={count} /> : count}
              </button>
            </div>
          </Suspense>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button>0</button></div>')
      root.querySelector('button')?.click()
      expect(root.innerHTML).toBe('<div><button>0</button></div>')
      resolve!()
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<div><button><div>1</div></button></div>')
    })
  })

  describe('useTransition()', () => {
    it('pending', async () => {
      let called = 0
      const App = () => {
        const [count, setCount] = useState(0)
        const [isPending, startTransition] = useTransition()
        called++

        return (
          <div>
            <button
              onClick={() => {
                startTransition(() => {
                  setCount((c) => c + 1)
                })
              }}
            >
              {isPending ? 'Pending...' : count}
            </button>
          </div>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button>0</button></div>')
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><button>Pending...</button></div>')
      expect(called).toBe(2)
      await new Promise((r) => setTimeout(r))
      await new Promise((r) => setTimeout(r))
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<div><button>1</button></div>')
      expect(called).toBe(3)
    })

    it('pending', async () => {
      let resolve: (() => void) | undefined
      const promise = new Promise<void>((r) => (resolve = r))
      let called = 0
      const App = () => {
        const [isPending, startTransition] = useTransition()
        called++

        return (
          <div>
            <button
              onClick={() => {
                startTransition(async () => await promise)
              }}
            >
              {isPending ? 'Pending...' : 'Click me'}
            </button>
          </div>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button>Click me</button></div>')
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><button>Pending...</button></div>')
      expect(called).toBe(2)
      resolve!()
      await new Promise((r) => setTimeout(r))
      await new Promise((r) => setTimeout(r))
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<div><button>Click me</button></div>')
      expect(called).toBe(3)
    })

    it('pending - error', async () => {
      let reject: (() => void) | undefined
      const promise = new Promise<void>((_, r) => (reject = r))
      let called = 0
      const Component = () => {
        const [isPending, startTransition] = useTransition()
        called++

        return (
          <div>
            <button
              onClick={() => {
                startTransition(async () => await promise)
              }}
            >
              {isPending ? 'Pending...' : 'Click me'}
            </button>
          </div>
        )
      }
      const App = () => (
        <ErrorBoundary fallback={<div>Error</div>}>
          <Component />
        </ErrorBoundary>
      )
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button>Click me</button></div>')
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><button>Pending...</button></div>')
      expect(called).toBe(2)
      reject!()
      await new Promise((r) => setTimeout(r))
      await new Promise((r) => setTimeout(r))
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<div>Error</div>')
      expect(called).toBe(2)
    })

    it('multiple setState at once', async () => {
      let called = 0
      const App = () => {
        const [count1, setCount1] = useState(0)
        const [count2, setCount2] = useState(0)
        const [isPending, startTransition] = useTransition()
        called++

        return (
          <div>
            <button
              onClick={() => {
                startTransition(() => {
                  setCount1((c) => c + 1)
                  setCount2((c) => c + 2)
                })
              }}
            >
              {isPending ? 'Pending...' : count1 + count2}
            </button>
          </div>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button>0</button></div>')
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><button>Pending...</button></div>')
      expect(called).toBe(2)
      await new Promise((r) => setTimeout(r))
      await new Promise((r) => setTimeout(r))
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<div><button>3</button></div>')
      expect(called).toBe(3)
    })

    it('multiple startTransaction at once', async () => {
      let called = 0
      const App = () => {
        const [count1, setCount1] = useState(0)
        const [count2, setCount2] = useState(0)
        const [isPending, startTransition] = useTransition()
        called++

        return (
          <div>
            <button
              onClick={() => {
                startTransition(() => {
                  setCount1((c) => c + 1)
                })
                startTransition(() => {
                  setCount2((c) => c + 2)
                })
              }}
            >
              {isPending ? 'Pending...' : count1 + count2}
            </button>
          </div>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button>0</button></div>')
      expect(called).toBe(1)
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><button>Pending...</button></div>')
      expect(called).toBe(2)
      await new Promise((r) => setTimeout(r))
      await new Promise((r) => setTimeout(r))
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<div><button>3</button></div>')
      expect(called).toBe(3) // + isPending=true + isPending=false
    })
  })

  describe('useDeferredValue()', () => {
    it('deferred', async () => {
      const promiseMap = {} as Record<number, Promise<number>>
      const getPromise = (count: number) => {
        return (promiseMap[count] ||= new Promise((r) => setTimeout(() => r(count + 1))))
      }
      const ShowCount = ({ count }: { count: number }) => {
        if (count === 0) {
          return <div>0</div>
        }

        const c = use(getPromise(count))
        return <div>{c}</div>
      }

      const App = () => {
        const [count, setCount] = useState(0)
        const c = useDeferredValue(count)
        return (
          <>
            <div>
              <button onClick={() => setCount((c) => c + 1)}>+1</button>
            </div>
            <Suspense fallback={<div>Loading...</div>}>
              <ShowCount count={c} />
            </Suspense>
          </>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button>+1</button></div><div>0</div>')
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><button>+1</button></div><div>0</div>')
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<div><button>+1</button></div><div>0</div>')
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<div><button>+1</button></div><div>0</div>')
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<div><button>+1</button></div><div>0</div>')
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<div><button>+1</button></div><div>2</div>')
    })

    it('initial value', async () => {
      const promiseMap = {} as Record<number, Promise<number>>
      const getPromise = (count: number) => {
        return (promiseMap[count] ||= new Promise((r) => setTimeout(() => r(count + 1))))
      }
      const ShowCount = ({ count }: { count: number }) => {
        if (count === 0 || count === 99) {
          return <div>{count}</div>
        }

        const c = use(getPromise(count))
        return <div>{c}</div>
      }

      const App = () => {
        const [count, setCount] = useState(1)
        const c = useDeferredValue(count, 99)
        return (
          <>
            <div>
              <button onClick={() => setCount((c) => c + 1)}>+1</button>
            </div>
            <Suspense fallback={<div>Loading...</div>}>
              <ShowCount count={c} />
            </Suspense>
          </>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button>+1</button></div><div>99</div>')
      await new Promise((r) => setTimeout(r))
      await new Promise((r) => setTimeout(r))
      await new Promise((r) => setTimeout(r))
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<div><button>+1</button></div><div>2</div>')
      root.querySelector('button')?.click()
      await new Promise((r) => setTimeout(r))
      await new Promise((r) => setTimeout(r))
      await new Promise((r) => setTimeout(r))
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<div><button>+1</button></div><div>3</div>')
    })
  })

  describe('startViewTransition()', () => {
    afterEach(() => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      delete (dom.window.document as any).startViewTransition
    })

    it('supported browser', async () => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ;(dom.window.document as any).startViewTransition = vi.fn((cb: Function) => {
        Promise.resolve().then(() => cb())
        return { finished: Promise.resolve() }
      })

      const App = () => {
        const [count, setCount] = useState(0)
        return (
          <Suspense fallback={<div>Loading...</div>}>
            <div>
              <button
                onClick={() => {
                  startViewTransition(() => {
                    setCount((c) => c + 1)
                  })
                }}
              >
                {count}
              </button>
            </div>
          </Suspense>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button>0</button></div>')
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><button>0</button></div>')
      await Promise.resolve() // updated in microtask
      expect(root.innerHTML).toBe('<div><button>1</button></div>')
    })

    it('unsupported browser', async () => {
      const App = () => {
        const [count, setCount] = useState(0)
        return (
          <Suspense fallback={<div>Loading...</div>}>
            <div>
              <button
                onClick={() => {
                  startViewTransition(() => {
                    setCount((c) => c + 1)
                  })
                }}
              >
                {count}
              </button>
            </div>
          </Suspense>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button>0</button></div>')
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><button>1</button></div>')
    })

    it('with useTransition()', async () => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ;(dom.window.document as any).startViewTransition = vi.fn((cb: Function) => {
        Promise.resolve().then(() => cb())
        return { finished: Promise.resolve() }
      })

      let called = 0
      const App = () => {
        const [count, setCount] = useState(0)
        const [isPending, startTransition] = useTransition()
        called++

        return (
          <div>
            <button
              onClick={() => {
                startViewTransition(() => {
                  startTransition(() => {
                    setCount((c) => c + 1)
                  })
                })
              }}
            >
              {isPending ? 'Pending...' : count}
            </button>
          </div>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button>0</button></div>')
      root.querySelector('button')?.click()
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<div><button>Pending...</button></div>')
      expect(called).toBe(2)
      await new Promise((r) => setTimeout(r))
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<div><button>1</button></div>')
      expect(called).toBe(3)
    })
  })

  describe('useViewTransition()', () => {
    afterEach(() => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      delete (dom.window.document as any).startViewTransition
    })

    it('supported browser', async () => {
      let resolved: (() => void) | undefined
      const promise = new Promise<void>((r) => (resolved = r))
      let called = 0
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ;(global.document as any).startViewTransition = vi.fn((cb: Function) => {
        Promise.resolve().then(() => cb())
        return { finished: promise }
      })

      const App = () => {
        const [count, setCount] = useState(0)
        const [isUpdating, startViewTransition] = useViewTransition()
        called++

        return (
          <div>
            <button
              onClick={() => {
                startViewTransition(() => {
                  setCount((c) => c + 1)
                })
              }}
            >
              {isUpdating ? 'Pending...' : count}
            </button>
          </div>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button>0</button></div>')
      root.querySelector('button')?.click()
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<div><button>Pending...</button></div>')
      expect(called).toBe(2)
      resolved?.()
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<div><button>1</button></div>')
      expect(called).toBe(3)
    })
  })

  describe('useId()', () => {
    let dom: JSDOM
    let root: HTMLElement
    beforeEach(() => {
      dom = new JSDOM('<html><body><div id="root"></div></body></html>', {
        runScripts: 'dangerously',
      })
      global.document = dom.window.document
      global.HTMLElement = dom.window.HTMLElement
      global.Text = dom.window.Text
      root = document.getElementById('root') as HTMLElement
    })

    it('simple', () => {
      const App = () => {
        const id = useId()
        return <div id={id} />
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div id=":r0:"></div>')
    })

    it('memoized', async () => {
      let setCount: (c: number) => void = () => {}
      const App = () => {
        const id = useId()
        const [count, _setCount] = useState(0)
        setCount = _setCount
        return <div id={id}>{count}</div>
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div id=":r1:">0</div>')
      setCount(1)
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div id=":r1:">1</div>')
    })
  })

  describe('useDebugValue()', () => {
    it('simple', () => {
      const spy = vi.fn()
      const App = () => {
        useDebugValue('hello', spy)
        return <div />
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div></div>')
      expect(spy).not.toBeCalled()
    })
  })

  describe('createRef()', () => {
    it('simple', () => {
      const ref: { current: HTMLElement | null } = createRef<HTMLDivElement>()
      const App = () => {
        return <div ref={ref} />
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div></div>')
      expect(ref.current).toBeInstanceOf(HTMLElement)
    })
  })

  describe('forwardRef()', () => {
    it('simple', () => {
      const ref: { current: HTMLElement | null } = createRef<HTMLDivElement>()
      const App = forwardRef((props, ref) => {
        return <div {...props} ref={ref} />
      })
      render(<App ref={ref} />, root)
      expect(root.innerHTML).toBe('<div></div>')
      expect(ref.current).toBeInstanceOf(HTMLElement)
    })

    it('can run without ref', () => {
      const App = forwardRef((props) => {
        return <div {...props} />
      })
      render(<App />, root)
      expect(root.innerHTML).toBe('<div></div>')
    })
  })

  describe('useImperativeHandle()', () => {
    it('simple', async () => {
      const ref: { current: { focus: () => void } | null } = createRef()
      const SubApp = () => {
        useImperativeHandle(
          ref,
          () => ({
            focus: () => {
              console.log('focus')
            },
          }),
          []
        )
        return <div />
      }
      const App = () => {
        const [show, setShow] = useState(true)
        return (
          <>
            {show && <SubApp />}
            <button onClick={() => setShow((s) => !s)}>toggle</button>
          </>
        )
      }
      render(<App />, root)
      expect(ref.current).toBe(null)
      await new Promise((r) => setTimeout(r))
      expect(ref.current).toEqual({ focus: expect.any(Function) })
      root.querySelector('button')?.click()
      await new Promise((r) => setTimeout(r))
      expect(ref.current).toBe(null)
    })
  })

  describe('useSyncExternalStore()', () => {
    it('simple', async () => {
      let count = 0
      const unsubscribe = vi.fn()
      const subscribe = vi.fn(() => unsubscribe)
      const getSnapshot = vi.fn(() => count++)
      const SubApp = () => {
        const count = useSyncExternalStore(subscribe, getSnapshot)
        return <div>{count}</div>
      }
      const App = () => {
        const [show, setShow] = useState(true)
        return (
          <>
            {show && <SubApp />}
            <button onClick={() => setShow((s) => !s)}>toggle</button>
          </>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div>0</div><button>toggle</button>')
      await new Promise((r) => setTimeout(r))
      root.querySelector('button')?.click()
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<button>toggle</button>')
      expect(unsubscribe).toBeCalled()
      root.querySelector('button')?.click()
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<div>1</div><button>toggle</button>')
    })

    it('with getServerSnapshot', async () => {
      let count = 0
      const unsubscribe = vi.fn()
      const subscribe = vi.fn(() => unsubscribe)
      const getSnapshot = vi.fn(() => count++)
      const getServerSnapshot = vi.fn(() => 100)
      const SubApp = () => {
        const count = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot)
        return <div>{count}</div>
      }
      const App = () => {
        const [show, setShow] = useState(true)
        return (
          <>
            {show && <SubApp />}
            <button onClick={() => setShow((s) => !s)}>toggle</button>
          </>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div>100</div><button>toggle</button>')
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<div>0</div><button>toggle</button>')
      root.querySelector('button')?.click()
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<button>toggle</button>')
      expect(unsubscribe).toBeCalled()
      root.querySelector('button')?.click()
      await new Promise((r) => setTimeout(r))
      expect(root.innerHTML).toBe('<div>1</div><button>toggle</button>')
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/hooks/index.ts
```typescript
import type { JSX } from '../base'
import { DOM_STASH } from '../constants'
import { buildDataStack, update } from '../dom/render'
import type { Context, Node, NodeObject, PendingType, UpdateHook } from '../dom/render'

type UpdateStateFunction<T> = (newState: T | ((currentState: T) => T)) => void

const STASH_SATE = 0
export const STASH_EFFECT = 1
const STASH_CALLBACK = 2
const STASH_MEMO = 3
const STASH_REF = 4

export type EffectData = [
  readonly unknown[] | undefined, // deps
  (() => void | (() => void)) | undefined, // layout effect
  (() => void) | undefined, // cleanup
  (() => void) | undefined, // effect
  (() => void) | undefined // insertion effect
]

const resolvedPromiseValueMap: WeakMap<Promise<unknown>, unknown> = new WeakMap<
  Promise<unknown>,
  unknown
>()

const isDepsChanged = (
  prevDeps: readonly unknown[] | undefined,
  deps: readonly unknown[] | undefined
): boolean =>
  !prevDeps ||
  !deps ||
  prevDeps.length !== deps.length ||
  deps.some((dep, i) => dep !== prevDeps[i])

let viewTransitionState:
  | [
      boolean, // isUpdating
      boolean // useViewTransition() is called
    ]
  | undefined = undefined

const documentStartViewTransition: (cb: () => void) => { finished: Promise<void> } = (cb) => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  if ((document as any)?.startViewTransition) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (document as any).startViewTransition(cb)
  } else {
    cb()
    return { finished: Promise.resolve() }
  }
}

let updateHook: UpdateHook | undefined = undefined
const viewTransitionHook = (
  context: Context,
  node: Node,
  cb: (context: Context) => void
): Promise<void> => {
  const state: [boolean, boolean] = [true, false]
  let lastVC = node.vC
  return documentStartViewTransition(() => {
    if (lastVC === node.vC) {
      viewTransitionState = state
      cb(context)
      viewTransitionState = undefined
      lastVC = node.vC
    }
  }).finished.then(() => {
    if (state[1] && lastVC === node.vC) {
      state[0] = false
      viewTransitionState = state
      cb(context)
      viewTransitionState = undefined
    }
  })
}

export const startViewTransition = (callback: () => void): void => {
  updateHook = viewTransitionHook

  try {
    callback()
  } finally {
    updateHook = undefined
  }
}

export const useViewTransition = (): [boolean, (callback: () => void) => void] => {
  const buildData = buildDataStack.at(-1) as [Context, NodeObject]
  if (!buildData) {
    return [false, () => {}]
  }

  if (viewTransitionState) {
    viewTransitionState[1] = true
  }
  return [!!viewTransitionState?.[0], startViewTransition]
}

// PendingType is defined in "../dom/render", 3 is used for useDeferredValue
const pendingStack: [PendingType | 3, Promise<void>][] = []
const runCallback = (type: PendingType, callback: Function): void => {
  let resolve: (() => void) | undefined
  const promise = new Promise<void>((r) => (resolve = r))
  pendingStack.push([type, promise])
  try {
    const res = callback()
    if (res instanceof Promise) {
      res.then(resolve, resolve)
    } else {
      resolve!()
    }
  } finally {
    pendingStack.pop()
  }
}

export const startTransition = (callback: () => void): void => {
  runCallback(1, callback)
}
const startTransitionHook = (callback: () => void | Promise<void>): void => {
  runCallback(2, callback)
}

export const useTransition = (): [boolean, (callback: () => void | Promise<void>) => void] => {
  const buildData = buildDataStack.at(-1) as [Context, NodeObject]
  if (!buildData) {
    return [false, () => {}]
  }

  const [error, setError] = useState<[Error]>()
  const [state, updateState] = useState<boolean>()
  if (error) {
    throw error[0]
  }
  const startTransitionLocalHook = useCallback<typeof startTransitionHook>(
    (callback) => {
      startTransitionHook(() => {
        updateState((state) => !state)
        let res = callback()
        if (res instanceof Promise) {
          res = res.catch((e) => {
            setError([e])
          })
        }
        return res
      })
    },
    [state]
  )

  const [context] = buildData
  return [context[0] === 2, startTransitionLocalHook]
}

type UseDeferredValue = <T>(value: T, initialValue?: T) => T
export const useDeferredValue: UseDeferredValue = <T>(value: T, ...rest: [T | undefined]): T => {
  const [values, setValues] = useState<[T, T]>(
    (rest.length ? [rest[0], rest[0]] : [value, value]) as [T, T]
  )
  if (Object.is(values[1], value)) {
    return values[1]
  }

  pendingStack.push([3, Promise.resolve()])
  updateHook = async (context: Context, _, cb: (context: Context) => void) => {
    cb(context)
    values[0] = value
  }
  setValues([values[0], value])
  updateHook = undefined
  pendingStack.pop()

  return values[0]
}

type UseStateType = {
  <T>(initialState: T | (() => T)): [T, UpdateStateFunction<T>]
  <T = undefined>(): [T | undefined, UpdateStateFunction<T | undefined>]
}
export const useState: UseStateType = <T>(
  initialState?: T | (() => T)
): [T, UpdateStateFunction<T>] => {
  const resolveInitialState = () =>
    typeof initialState === 'function' ? (initialState as () => T)() : (initialState as T)

  const buildData = buildDataStack.at(-1) as [unknown, NodeObject]
  if (!buildData) {
    return [resolveInitialState(), () => {}]
  }
  const [, node] = buildData

  const stateArray = (node[DOM_STASH][1][STASH_SATE] ||= [])
  const hookIndex = node[DOM_STASH][0]++

  return (stateArray[hookIndex] ||= [
    resolveInitialState(),
    (newState: T | ((currentState: T) => T)) => {
      const localUpdateHook = updateHook
      const stateData = stateArray[hookIndex]
      if (typeof newState === 'function') {
        newState = (newState as (currentState: T) => T)(stateData[0])
      }

      if (!Object.is(newState, stateData[0])) {
        stateData[0] = newState
        if (pendingStack.length) {
          const [pendingType, pendingPromise] = pendingStack.at(-1) as [
            PendingType | 3,
            Promise<void>
          ]
          Promise.all([
            pendingType === 3
              ? node
              : update([pendingType, false, localUpdateHook as UpdateHook], node),
            pendingPromise,
          ]).then(([node]) => {
            if (!node || !(pendingType === 2 || pendingType === 3)) {
              return
            }

            const lastVC = node.vC

            const addUpdateTask = () => {
              setTimeout(() => {
                // return if `node` is rerendered after current transition
                if (lastVC !== node.vC) {
                  return
                }
                update([pendingType === 3 ? 1 : 0, false, localUpdateHook as UpdateHook], node)
              })
            }

            requestAnimationFrame(addUpdateTask)
          })
        } else {
          update([0, false, localUpdateHook as UpdateHook], node)
        }
      }
    },
  ])
}

export const useReducer = <T, A>(
  reducer: (state: T, action: A) => T,
  initialArg: T,
  init?: (initialState: T) => T
): [T, (action: A) => void] => {
  const handler = useCallback(
    (action: A) => {
      setState((state) => reducer(state, action))
    },
    [reducer]
  )
  const [state, setState] = useState(() => (init ? init(initialArg) : initialArg))
  return [state, handler]
}

const useEffectCommon = (
  index: number,
  effect: () => void | (() => void),
  deps?: readonly unknown[]
): void => {
  const buildData = buildDataStack.at(-1) as [unknown, NodeObject]
  if (!buildData) {
    return
  }
  const [, node] = buildData

  const effectDepsArray = (node[DOM_STASH][1][STASH_EFFECT] ||= [])
  const hookIndex = node[DOM_STASH][0]++

  const [prevDeps, , prevCleanup] = (effectDepsArray[hookIndex] ||= [])
  if (isDepsChanged(prevDeps, deps)) {
    if (prevCleanup) {
      prevCleanup()
    }
    const runner = () => {
      data[index] = undefined // clear this effect in order to avoid calling effect twice
      data[2] = effect() as (() => void) | undefined
    }
    const data: EffectData = [deps, undefined, undefined, undefined, undefined]
    data[index] = runner
    effectDepsArray[hookIndex] = data
  }
}
export const useEffect = (effect: () => void | (() => void), deps?: readonly unknown[]): void =>
  useEffectCommon(3, effect, deps)
export const useLayoutEffect = (
  effect: () => void | (() => void),
  deps?: readonly unknown[]
): void => useEffectCommon(1, effect, deps)
export const useInsertionEffect = (
  effect: () => void | (() => void),
  deps?: readonly unknown[]
): void => useEffectCommon(4, effect, deps)

export const useCallback = <T extends Function>(callback: T, deps: readonly unknown[]): T => {
  const buildData = buildDataStack.at(-1) as [unknown, NodeObject]
  if (!buildData) {
    return callback
  }
  const [, node] = buildData

  const callbackArray = (node[DOM_STASH][1][STASH_CALLBACK] ||= [])
  const hookIndex = node[DOM_STASH][0]++

  const prevDeps = callbackArray[hookIndex]
  if (isDepsChanged(prevDeps?.[1], deps)) {
    callbackArray[hookIndex] = [callback, deps]
  } else {
    callback = callbackArray[hookIndex][0] as T
  }
  return callback
}

export type RefObject<T> = { current: T | null }
export const useRef = <T>(initialValue: T | null): RefObject<T> => {
  const buildData = buildDataStack.at(-1) as [unknown, NodeObject]
  if (!buildData) {
    return { current: initialValue }
  }
  const [, node] = buildData

  const refArray = (node[DOM_STASH][1][STASH_REF] ||= [])
  const hookIndex = node[DOM_STASH][0]++

  return (refArray[hookIndex] ||= { current: initialValue })
}

export const use = <T>(promise: Promise<T>): T => {
  const cachedRes = resolvedPromiseValueMap.get(promise) as [T] | [undefined, unknown] | undefined
  if (cachedRes) {
    if (cachedRes.length === 2) {
      throw cachedRes[1]
    }
    return cachedRes[0] as T
  }
  promise.then(
    (res) => resolvedPromiseValueMap.set(promise, [res]),
    (e) => resolvedPromiseValueMap.set(promise, [undefined, e])
  )

  throw promise
}

export const useMemo = <T>(factory: () => T, deps: readonly unknown[]): T => {
  const buildData = buildDataStack.at(-1) as [unknown, NodeObject]
  if (!buildData) {
    return factory()
  }
  const [, node] = buildData

  const memoArray = (node[DOM_STASH][1][STASH_MEMO] ||= [])
  const hookIndex = node[DOM_STASH][0]++

  const prevDeps = memoArray[hookIndex]
  if (isDepsChanged(prevDeps?.[1], deps)) {
    memoArray[hookIndex] = [factory(), deps]
  }
  return memoArray[hookIndex][0] as T
}

let idCounter = 0
export const useId = (): string => useMemo(() => `:r${(idCounter++).toString(32)}:`, [])

// Define to avoid errors. This hook currently does nothing.
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export const useDebugValue = (_value: unknown, _formatter?: (value: unknown) => string): void => {}

export const createRef = <T>(): RefObject<T> => {
  return { current: null }
}

export const forwardRef = <T, P = {}>(
  Component: (props: P, ref?: RefObject<T>) => JSX.Element
): ((props: P & { ref?: RefObject<T> }) => JSX.Element) => {
  return (props) => {
    const { ref, ...rest } = props
    return Component(rest as P, ref)
  }
}

export const useImperativeHandle = <T>(
  ref: RefObject<T>,
  createHandle: () => T,
  deps: readonly unknown[]
): void => {
  useEffect(() => {
    ref.current = createHandle()
    return () => {
      ref.current = null
    }
  }, deps)
}

export const useSyncExternalStore = <T>(
  subscribe: (callback: () => void) => () => void,
  getSnapshot: () => T,
  getServerSnapshot?: () => T
): T => {
  const buildData = buildDataStack.at(-1) as [Context, unknown]
  if (!buildData) {
    // now a stringify process, maybe in server side
    if (!getServerSnapshot) {
      throw new Error('getServerSnapshot is required for server side rendering')
    }
    return getServerSnapshot()
  }

  const [serverSnapshotIsUsed] = useState<boolean>(!!(buildData[0][4] && getServerSnapshot))
  const [state, setState] = useState(() =>
    serverSnapshotIsUsed ? (getServerSnapshot as () => T)() : getSnapshot()
  )
  useEffect(() => {
    if (serverSnapshotIsUsed) {
      setState(getSnapshot())
    }
    return subscribe(() => {
      setState(getSnapshot())
    })
  }, [])

  return state
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/hooks/string.test.tsx
```
/** @jsxImportSource ../ */
import { useState, useSyncExternalStore } from '..'

describe('useState', () => {
  it('should be rendered with initial state', () => {
    const Component = () => {
      const [state] = useState('hello')
      return <span>{state}</span>
    }
    const template = <Component />
    expect(template.toString()).toBe('<span>hello</span>')
  })
})

describe('useSyncExternalStore', () => {
  it('should be rendered with result of getServerSnapshot()', () => {
    const unsubscribe = vi.fn()
    const subscribe = vi.fn(() => unsubscribe)
    const getSnapshot = vi.fn()
    const getServerSnapshot = vi.fn(() => 100)
    const App = () => {
      const count = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot)
      return <div>{count}</div>
    }
    const template = <App />
    expect(template.toString()).toBe('<div>100</div>')
    expect(unsubscribe).not.toBeCalled()
    expect(subscribe).not.toBeCalled()
    expect(getSnapshot).not.toBeCalled()
  })

  it('should raise an error if getServerShot() is not provided', () => {
    const App = () => {
      const count = useSyncExternalStore(vi.fn(), vi.fn())
      return <div>{count}</div>
    }
    const template = <App />
    expect(() => template.toString()).toThrowError()
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/intrinsic-element/common.ts
```typescript
export const deDupeKeyMap: Record<string, string[]> = {
  title: [],
  script: ['src'],
  style: ['data-href'],
  link: ['href'],
  meta: ['name', 'httpEquiv', 'charset', 'itemProp'],
}

export const domRenderers: Record<string, Function> = {}

export const dataPrecedenceAttr = 'data-precedence'

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/intrinsic-element/components.test.tsx
```
/** @jsxImportSource ../ */
import { useActionState } from '../'

describe('intrinsic element', () => {
  describe('document metadata', () => {
    describe('title element', () => {
      it('should be hoisted title tag', async () => {
        const template = (
          <html>
            <head></head>
            <body>
              <title>Hello</title>
              <h1>World</h1>
            </body>
          </html>
        )
        expect(template.toString()).toBe(
          '<html><head><title>Hello</title></head><body><h1>World</h1></body></html>'
        )
      })
    })

    describe('link element', () => {
      it('should be hoisted link tag', async () => {
        const template = (
          <html>
            <head></head>
            <body>
              <link rel='stylesheet' href='style.css' precedence='default' />
              <h1>World</h1>
            </body>
          </html>
        )
        expect(template.toString()).toBe(
          '<html><head><link rel="stylesheet" href="style.css" data-precedence="default"/></head><body><h1>World</h1></body></html>'
        )
      })

      it('should be ordered by precedence attribute', () => {
        const template = (
          <html>
            <head></head>
            <body>
              <link rel='stylesheet' href='style1.css' precedence='default' />
              <link rel='stylesheet' href='style2.css' precedence='high' />
              <link rel='stylesheet' href='style3.css' precedence='default' />
              <h1>World</h1>
            </body>
          </html>
        )
        expect(template.toString()).toBe(
          '<html><head><link rel="stylesheet" href="style1.css" data-precedence="default"/><link rel="stylesheet" href="style3.css" data-precedence="default"/><link rel="stylesheet" href="style2.css" data-precedence="high"/></head><body><h1>World</h1></body></html>'
        )
      })

      it('should be de-duped by href', () => {
        const template = (
          <html>
            <head></head>
            <body>
              <link rel='stylesheet' href='style1.css' precedence='default' />
              <link rel='stylesheet' href='style2.css' precedence='high' />
              <link rel='stylesheet' href='style1.css' precedence='default' />
              <h1>World</h1>
            </body>
          </html>
        )
        expect(template.toString()).toBe(
          '<html><head><link rel="stylesheet" href="style1.css" data-precedence="default"/><link rel="stylesheet" href="style2.css" data-precedence="high"/></head><body><h1>World</h1></body></html>'
        )
      })

      it('should be inserted as is if <head> is not present', () => {
        const template = (
          <html>
            <body>
              <link rel='stylesheet' href='style1.css' precedence='default' />
              <link rel='stylesheet' href='style2.css' precedence='high' />
              <h1>World</h1>
            </body>
          </html>
        )
        expect(template.toString()).toBe(
          '<html><body><link rel="stylesheet" href="style1.css" data-precedence="default"/><link rel="stylesheet" href="style2.css" data-precedence="high"/><h1>World</h1></body></html>'
        )
      })

      it('should not do special behavior if disabled is present', () => {
        const template = (
          <html>
            <head></head>
            <body>
              <link rel='stylesheet' href='style1.css' precedence='default' />
              <link rel='stylesheet' href='style2.css' precedence='default' disabled />
              <h1>World</h1>
            </body>
          </html>
        )
        expect(template.toString()).toBe(
          '<html><head><link rel="stylesheet" href="style1.css" data-precedence="default"/></head><body><link rel="stylesheet" href="style2.css" precedence="default" disabled=""/><h1>World</h1></body></html>'
        )
      })

      it('should not be hoisted if has no precedence attribute', () => {
        const template = (
          <html>
            <head></head>
            <body>
              <link rel='stylesheet' href='style1.css' />
              <h1>World</h1>
            </body>
          </html>
        )
        expect(template.toString()).toBe(
          '<html><head></head><body><link rel="stylesheet" href="style1.css"/><h1>World</h1></body></html>'
        )
      })
    })

    describe('meta element', () => {
      it('should be hoisted meta tag', async () => {
        const template = (
          <html>
            <head></head>
            <body>
              <meta name='description' content='Hello' />
              <h1>World</h1>
            </body>
          </html>
        )
        expect(template.toString()).toBe(
          '<html><head><meta name="description" content="Hello"/></head><body><h1>World</h1></body></html>'
        )
      })

      it('should be de-duped by name', () => {
        const template = (
          <html>
            <head></head>
            <body>
              <meta name='description' content='Hello' />
              <meta name='description' content='World' />
              <h1>World</h1>
            </body>
          </html>
        )
        expect(template.toString()).toBe(
          '<html><head><meta name="description" content="Hello"/></head><body><h1>World</h1></body></html>'
        )
      })

      it('should not do special behavior if itemProp is present', () => {
        const template = (
          <html>
            <head></head>
            <body>
              <meta name='description' content='Hello' itemProp='test' />
              <h1>World</h1>
            </body>
          </html>
        )
        expect(template.toString()).toBe(
          '<html><head></head><body><meta name="description" content="Hello" itemprop="test"/><h1>World</h1></body></html>'
        )
      })
    })

    describe('script element', () => {
      it('should be hoisted script tag', async () => {
        const template = (
          <html>
            <head></head>
            <body>
              <script src='script.js' async={true} />
              <h1>World</h1>
            </body>
          </html>
        )
        expect(template.toString()).toBe(
          '<html><head><script src="script.js" async=""></script></head><body><h1>World</h1></body></html>'
        )
      })

      it('should be de-duped by href with async={true}', () => {
        const template = (
          <html>
            <head></head>
            <body>
              <script src='script.js' async />
              <script src='script.js' async />
              <h1>World</h1>
            </body>
          </html>
        )
        expect(template.toString()).toBe(
          '<html><head><script src="script.js" async=""></script></head><body><h1>World</h1></body></html>'
        )
      })

      it('should be omitted "blocking", "onLoad" and "onError" props', () => {
        const template = (
          <html>
            <head></head>
            <body>
              <script
                src='script.js'
                async={true}
                onLoad={() => {}}
                onError={() => {}}
                blocking='render'
              />
              <h1>World</h1>
            </body>
          </html>
        )
        expect(template.toString()).toBe(
          '<html><head><script src="script.js" async=""></script></head><body><h1>World</h1></body></html>'
        )
      })

      it('should not do special behavior if async is not present', () => {
        const template = (
          <html>
            <head></head>
            <body>
              <script src='script.js' />
              <h1>World</h1>
            </body>
          </html>
        )
        expect(template.toString()).toBe(
          '<html><head></head><body><script src="script.js"></script><h1>World</h1></body></html>'
        )
      })
    })

    describe('style element', () => {
      it('should be hoisted style tag', async () => {
        const template = (
          <html>
            <head></head>
            <body>
              <style href='red' precedence='default'>
                {'body { color: red; }'}
              </style>
              <h1>World</h1>
            </body>
          </html>
        )
        expect(template.toString()).toBe(
          '<html><head><style data-href="red" data-precedence="default">body { color: red; }</style></head><body><h1>World</h1></body></html>'
        )
      })

      it('should be sorted by precedence attribute', async () => {
        const template = (
          <html>
            <head></head>
            <body>
              <style href='red' precedence='default'>
                {'body { color: red; }'}
              </style>
              <style href='green' precedence='high'>
                {'body { color: green; }'}
              </style>
              <style href='blue' precedence='default'>
                {'body { color: blue; }'}
              </style>
              <h1>World</h1>
            </body>
          </html>
        )
        expect(template.toString()).toBe(
          '<html><head><style data-href="red" data-precedence="default">body { color: red; }</style><style data-href="blue" data-precedence="default">body { color: blue; }</style><style data-href="green" data-precedence="high">body { color: green; }</style></head><body><h1>World</h1></body></html>'
        )
      })

      it('should not be hoisted if href is not present', () => {
        const template = (
          <html>
            <head></head>
            <body>
              <style>{'body { color: red; }'}</style>
              <h1>World</h1>
            </body>
          </html>
        )
        expect(template.toString()).toBe(
          '<html><head></head><body><style>body { color: red; }</style><h1>World</h1></body></html>'
        )
      })
    })
  })

  describe('form element', () => {
    it('should be omitted "action" prop if it is a function', () => {
      const template = (
        <html>
          <head></head>
          <body>
            <form action={() => {}} method='get'>
              <input type='text' />
            </form>
          </body>
        </html>
      )
      expect(template.toString()).toBe(
        '<html><head></head><body><form method="get"><input type="text"/></form></body></html>'
      )
    })

    it('should be rendered permalink', () => {
      const [, action] = useActionState(() => {}, {}, 'permalink')
      const template = (
        <html>
          <head></head>
          <body>
            <form action={action} method='get'>
              <input type='text' />
            </form>
          </body>
        </html>
      )
      expect(template.toString()).toBe(
        '<html><head></head><body><form action="permalink" method="get"><input type="text"/></form></body></html>'
      )
    })

    it('should not do special behavior if action is a string', () => {
      const template = (
        <html>
          <head></head>
          <body>
            <form action='/entries' method='get'>
              <input type='text' />
            </form>
          </body>
        </html>
      )
      expect(template.toString()).toBe(
        '<html><head></head><body><form action="/entries" method="get"><input type="text"/></form></body></html>'
      )
    })

    it('should not do special behavior if no action prop', () => {
      const template = (
        <html>
          <head></head>
          <body>
            <form>
              <input type='text' />
            </form>
          </body>
        </html>
      )
      expect(template.toString()).toBe(
        '<html><head></head><body><form><input type="text"/></form></body></html>'
      )
    })

    describe('input element', () => {
      it('should be rendered as is', () => {
        const template = <input type='text' />
        expect(template.toString()).toBe('<input type="text"/>')
      })

      it('should be omitted "formAction" prop if it is a function', () => {
        const template = (
          <html>
            <head></head>
            <body>
              <input type='text' formAction={() => {}} />
            </body>
          </html>
        )
        expect(template.toString()).toBe(
          '<html><head></head><body><input type="text"/></body></html>'
        )
      })

      it('should be rendered permalink', () => {
        const [, formAction] = useActionState(() => {}, {}, 'permalink')
        const template = (
          <html>
            <head></head>
            <body>
              <input type='text' formAction={formAction} />
            </body>
          </html>
        )
        expect(template.toString()).toBe(
          '<html><head></head><body><input type="text" formaction="permalink"/></body></html>'
        )
      })
    })
  })
})

export {}

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/intrinsic-element/components.ts
```typescript
import { raw } from '../../helper/html'
import type { HtmlEscapedCallback, HtmlEscapedString } from '../../utils/html'
import { JSXNode, getNameSpaceContext } from '../base'
import type { Child, Props } from '../base'
import { toArray } from '../children'
import { PERMALINK } from '../constants'
import { useContext } from '../context'
import type { IntrinsicElements } from '../intrinsic-elements'
import type { FC, PropsWithChildren } from '../types'
import { dataPrecedenceAttr, deDupeKeyMap } from './common'

const metaTagMap: WeakMap<
  object,
  Record<string, [string, Props, string | undefined][]>
> = new WeakMap()
const insertIntoHead: (
  tagName: string,
  tag: string,
  props: Props,
  precedence: string | undefined
) => HtmlEscapedCallback =
  (tagName, tag, props, precedence) =>
  ({ buffer, context }): undefined => {
    if (!buffer) {
      return
    }
    const map = metaTagMap.get(context) || {}
    metaTagMap.set(context, map)
    const tags = (map[tagName] ||= [])

    let duped = false
    const deDupeKeys = deDupeKeyMap[tagName]
    if (deDupeKeys.length > 0) {
      LOOP: for (const [, tagProps] of tags) {
        for (const key of deDupeKeys) {
          if ((tagProps?.[key] ?? null) === props?.[key]) {
            duped = true
            break LOOP
          }
        }
      }
    }

    if (duped) {
      buffer[0] = buffer[0].replaceAll(tag, '')
    } else if (deDupeKeys.length > 0) {
      tags.push([tag, props, precedence])
    } else {
      tags.unshift([tag, props, precedence])
    }

    if (buffer[0].indexOf('</head>') !== -1) {
      let insertTags
      if (precedence === undefined) {
        insertTags = tags.map(([tag]) => tag)
      } else {
        const precedences: string[] = []
        insertTags = tags
          .map(([tag, , precedence]) => {
            let order = precedences.indexOf(precedence as string)
            if (order === -1) {
              precedences.push(precedence as string)
              order = precedences.length - 1
            }
            return [tag, order] as [string, number]
          })
          .sort((a, b) => a[1] - b[1])
          .map(([tag]) => tag)
      }

      insertTags.forEach((tag) => {
        buffer[0] = buffer[0].replaceAll(tag, '')
      })
      buffer[0] = buffer[0].replace(/(?=<\/head>)/, insertTags.join(''))
    }
  }

const returnWithoutSpecialBehavior = (tag: string, children: Child, props: Props) =>
  raw(new JSXNode(tag, props, toArray(children ?? [])).toString())

const documentMetadataTag = (tag: string, children: Child, props: Props, sort: boolean) => {
  if ('itemProp' in props) {
    return returnWithoutSpecialBehavior(tag, children, props)
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  let { precedence, blocking, ...restProps } = props
  precedence = sort ? precedence ?? '' : undefined
  if (sort) {
    restProps[dataPrecedenceAttr] = precedence
  }

  const string = new JSXNode(tag, restProps, toArray(children || [])).toString()

  if (string instanceof Promise) {
    return string.then((resString) =>
      raw(string, [
        ...((resString as HtmlEscapedString).callbacks || []),
        insertIntoHead(tag, resString, restProps, precedence),
      ])
    )
  } else {
    return raw(string, [insertIntoHead(tag, string, restProps, precedence)])
  }
}

export const title: FC<PropsWithChildren> = ({ children, ...props }) => {
  const nameSpaceContext = getNameSpaceContext()
  if (nameSpaceContext) {
    const context = useContext(nameSpaceContext)
    if (context === 'svg' || context === 'head') {
      return new JSXNode(
        'title',
        props,
        toArray(children ?? []) as Child[]
      ) as unknown as HtmlEscapedString
    }
  }

  return documentMetadataTag('title', children, props, false)
}
export const script: FC<PropsWithChildren<IntrinsicElements['script']>> = ({
  children,
  ...props
}) => {
  const nameSpaceContext = getNameSpaceContext()
  if (
    ['src', 'async'].some((k) => !props[k]) ||
    (nameSpaceContext && useContext(nameSpaceContext) === 'head')
  ) {
    return returnWithoutSpecialBehavior('script', children, props)
  }

  return documentMetadataTag('script', children, props, false)
}

export const style: FC<PropsWithChildren<IntrinsicElements['style']>> = ({
  children,
  ...props
}) => {
  if (!['href', 'precedence'].every((k) => k in props)) {
    return returnWithoutSpecialBehavior('style', children, props)
  }
  props['data-href'] = props.href
  delete props.href
  return documentMetadataTag('style', children, props, true)
}
export const link: FC<PropsWithChildren<IntrinsicElements['link']>> = ({ children, ...props }) => {
  if (
    ['onLoad', 'onError'].some((k) => k in props) ||
    (props.rel === 'stylesheet' && (!('precedence' in props) || 'disabled' in props))
  ) {
    return returnWithoutSpecialBehavior('link', children, props)
  }
  return documentMetadataTag('link', children, props, 'precedence' in props)
}
export const meta: FC<PropsWithChildren> = ({ children, ...props }) => {
  const nameSpaceContext = getNameSpaceContext()
  if (nameSpaceContext && useContext(nameSpaceContext) === 'head') {
    return returnWithoutSpecialBehavior('meta', children, props)
  }
  return documentMetadataTag('meta', children, props, false)
}

const newJSXNode = (tag: string, { children, ...props }: PropsWithChildren<unknown>) =>
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  new JSXNode(tag, props, toArray(children ?? []) as Child[]) as any
export const form: FC<
  PropsWithChildren<{
    action?: Function | string
    method?: 'get' | 'post'
  }>
> = (props) => {
  if (typeof props.action === 'function') {
    props.action = PERMALINK in props.action ? (props.action[PERMALINK] as string) : undefined
  }
  return newJSXNode('form', props)
}

const formActionableElement = (
  tag: string,
  props: PropsWithChildren<{
    formAction?: Function | string
  }>
) => {
  if (typeof props.formAction === 'function') {
    props.formAction =
      PERMALINK in props.formAction ? (props.formAction[PERMALINK] as string) : undefined
  }
  return newJSXNode(tag, props)
}

export const input: (props: PropsWithChildren) => unknown = (props) =>
  formActionableElement('input', props)
export const button: (props: PropsWithChildren) => unknown = (props) =>
  formActionableElement('button', props)

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/dom/client.test.tsx
```
/** @jsxImportSource ../ */
import { JSDOM } from 'jsdom'
import DefaultExport, { createRoot, hydrateRoot } from './client'
import { useEffect } from '.'

describe('createRoot', () => {
  beforeAll(() => {
    global.requestAnimationFrame = (cb) => setTimeout(cb)
  })

  let dom: JSDOM
  let rootElement: HTMLElement
  beforeEach(() => {
    dom = new JSDOM('<html><body><div id="root"></div></body></html>', {
      runScripts: 'dangerously',
    })
    global.document = dom.window.document
    global.HTMLElement = dom.window.HTMLElement
    global.SVGElement = dom.window.SVGElement
    global.Text = dom.window.Text
    rootElement = document.getElementById('root') as HTMLElement
  })

  it('render / unmount', async () => {
    const cleanup = vi.fn()
    const App = () => {
      useEffect(() => cleanup, [])
      return <h1>Hello</h1>
    }
    const root = createRoot(rootElement)
    root.render(<App />)
    expect(rootElement.innerHTML).toBe('<h1>Hello</h1>')
    await new Promise((resolve) => setTimeout(resolve))
    root.unmount()
    await Promise.resolve()
    expect(rootElement.innerHTML).toBe('')
    expect(cleanup).toHaveBeenCalled()
  })

  it('call render twice', async () => {
    const App = <h1>Hello</h1>
    const App2 = <h1>World</h1>
    const root = createRoot(rootElement)
    root.render(App)
    expect(rootElement.innerHTML).toBe('<h1>Hello</h1>')

    const createElementSpy = vi.spyOn(dom.window.document, 'createElement')

    root.render(App2)
    await Promise.resolve()
    expect(rootElement.innerHTML).toBe('<h1>World</h1>')

    expect(createElementSpy).not.toHaveBeenCalled()
  })

  it('call render after unmount', async () => {
    const App = <h1>Hello</h1>
    const App2 = <h1>World</h1>
    const root = createRoot(rootElement)
    root.render(App)
    expect(rootElement.innerHTML).toBe('<h1>Hello</h1>')
    root.unmount()
    expect(() => root.render(App2)).toThrow('Cannot update an unmounted root')
  })
})

describe('hydrateRoot', () => {
  let dom: JSDOM
  let rootElement: HTMLElement
  beforeEach(() => {
    dom = new JSDOM('<html><body><div id="root"></div></body></html>', {
      runScripts: 'dangerously',
    })
    global.document = dom.window.document
    global.HTMLElement = dom.window.HTMLElement
    global.SVGElement = dom.window.SVGElement
    global.Text = dom.window.Text
    rootElement = document.getElementById('root') as HTMLElement
  })

  it('should return root object', async () => {
    const cleanup = vi.fn()
    const App = () => {
      useEffect(() => cleanup, [])
      return <h1>Hello</h1>
    }
    const root = hydrateRoot(rootElement, <App />)
    expect(rootElement.innerHTML).toBe('<h1>Hello</h1>')
    await new Promise((resolve) => setTimeout(resolve))
    root.unmount()
    await Promise.resolve()
    expect(rootElement.innerHTML).toBe('')
    expect(cleanup).toHaveBeenCalled()
  })

  it('call render', async () => {
    const App = <h1>Hello</h1>
    const App2 = <h1>World</h1>
    const root = hydrateRoot(rootElement, App)
    expect(rootElement.innerHTML).toBe('<h1>Hello</h1>')

    const createElementSpy = vi.spyOn(dom.window.document, 'createElement')

    root.render(App2)
    await Promise.resolve()
    expect(rootElement.innerHTML).toBe('<h1>World</h1>')

    expect(createElementSpy).not.toHaveBeenCalled()
  })

  it('call render after unmount', async () => {
    const App = <h1>Hello</h1>
    const App2 = <h1>World</h1>
    const root = hydrateRoot(rootElement, App)
    expect(rootElement.innerHTML).toBe('<h1>Hello</h1>')
    root.unmount()
    expect(() => root.render(App2)).toThrow('Cannot update an unmounted root')
  })
})

describe('default export', () => {
  ;['createRoot', 'hydrateRoot'].forEach((key) => {
    it(key, () => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      expect((DefaultExport as any)[key]).toBeDefined()
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/dom/client.ts
```typescript
/**
 * @module
 * This module provides APIs for `hono/jsx/dom/client`, which is compatible with `react-dom/client`.
 */

import type { Child } from '../base'
import { useState } from '../hooks'
import { buildNode, renderNode } from './render'
import type { NodeObject } from './render'

export interface Root {
  render(children: Child): void
  unmount(): void
}
export type RootOptions = Record<string, unknown>

/**
 * Create a root object for rendering
 * @param element Render target
 * @param options Options for createRoot (not supported yet)
 * @returns Root object has `render` and `unmount` methods
 */
export const createRoot = (
  element: HTMLElement | DocumentFragment,
  options: RootOptions = {}
): Root => {
  let setJsxNode:
    | undefined // initial state
    | ((jsxNode: unknown) => void) // rendered
    | null = // unmounted
    undefined

  if (Object.keys(options).length > 0) {
    console.warn('createRoot options are not supported yet')
  }

  return {
    render(jsxNode: unknown) {
      if (setJsxNode === null) {
        // unmounted
        throw new Error('Cannot update an unmounted root')
      }
      if (setJsxNode) {
        // rendered
        setJsxNode(jsxNode)
      } else {
        renderNode(
          buildNode({
            tag: () => {
              const [_jsxNode, _setJsxNode] = useState(jsxNode)
              setJsxNode = _setJsxNode
              return _jsxNode
            },
            props: {},
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
          } as any) as NodeObject,
          element
        )
      }
    },
    unmount() {
      setJsxNode?.(null)
      setJsxNode = null
    },
  }
}

/**
 * Create a root object and hydrate app to the target element.
 * In hono/jsx/dom, hydrate is equivalent to render.
 * @param element Render target
 * @param reactNode A JSXNode to render
 * @param options Options for createRoot (not supported yet)
 * @returns Root object has `render` and `unmount` methods
 */
export const hydrateRoot = (
  element: HTMLElement | DocumentFragment,
  reactNode: Child,
  options: RootOptions = {}
): Root => {
  const root = createRoot(element, options)
  root.render(reactNode)
  return root
}

export default {
  createRoot,
  hydrateRoot,
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/dom/components.test.tsx
```
/** @jsxImportSource ../ */
import { JSDOM } from 'jsdom'
import { ErrorBoundary as ErrorBoundaryCommon, Suspense as SuspenseCommon } from '..' // for common
// run tests by old style jsx default
// hono/jsx/jsx-runtime and hono/jsx/dom/jsx-runtime are tested in their respective settings
import { use, useState } from '../hooks'
import { ErrorBoundary as ErrorBoundaryDom, Suspense as SuspenseDom, render } from '.' // for dom

runner('Common', SuspenseCommon, ErrorBoundaryCommon)
runner('DOM', SuspenseDom, ErrorBoundaryDom)

function runner(
  name: string,
  Suspense: typeof SuspenseDom,
  ErrorBoundary: typeof ErrorBoundaryDom
) {
  describe(name, () => {
    beforeAll(() => {
      global.requestAnimationFrame = (cb) => setTimeout(cb)
    })

    describe('Suspense', () => {
      let dom: JSDOM
      let root: HTMLElement
      beforeEach(() => {
        dom = new JSDOM('<html><body><div id="root"></div></body></html>', {
          runScripts: 'dangerously',
        })
        global.document = dom.window.document
        global.HTMLElement = dom.window.HTMLElement
        global.Text = dom.window.Text
        root = document.getElementById('root') as HTMLElement
      })

      it('has no lazy load content', async () => {
        const App = <Suspense fallback={<div>Loading...</div>}>Hello</Suspense>
        render(App, root)
        expect(root.innerHTML).toBe('Hello')
      })

      it('with use()', async () => {
        let resolve: (value: number) => void = () => {}
        const promise = new Promise<number>((_resolve) => (resolve = _resolve))
        const Content = () => {
          const num = use(promise)
          return <p>{num}</p>
        }
        const Component = () => {
          return (
            <Suspense fallback={<div>Loading...</div>}>
              <Content />
            </Suspense>
          )
        }
        const App = <Component />
        render(App, root)
        expect(root.innerHTML).toBe('<div>Loading...</div>')
        resolve(1)
        await new Promise((resolve) => setTimeout(resolve))
        expect(root.innerHTML).toBe('<p>1</p>')
      })

      it('with use() update', async () => {
        const counterMap: Record<number, Promise<number>> = {}
        const getCounter = (count: number) => (counterMap[count] ||= Promise.resolve(count + 1))
        const Content = ({ count }: { count: number }) => {
          const num = use(getCounter(count))
          return (
            <>
              <div>{num}</div>
            </>
          )
        }
        const Component = () => {
          const [count, setCount] = useState(0)
          return (
            <Suspense fallback={<div>Loading...</div>}>
              <Content count={count} />
              <button onClick={() => setCount(count + 1)}>Increment</button>
            </Suspense>
          )
        }
        const App = <Component />
        render(App, root)
        expect(root.innerHTML).toBe('<div>Loading...</div>')
        await Promise.resolve()
        await Promise.resolve()
        expect(root.innerHTML).toBe('<div>1</div><button>Increment</button>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(root.innerHTML).toBe('<div>Loading...</div>')
        await Promise.resolve()
        await Promise.resolve()
        expect(root.innerHTML).toBe('<div>2</div><button>Increment</button>')
      })

      it('with use() nested', async () => {
        let resolve: (value: number) => void = () => {}
        const promise = new Promise<number>((_resolve) => (resolve = _resolve))
        const Content = () => {
          const num = use(promise)
          return <p>{num}</p>
        }
        let resolve2: (value: number) => void = () => {}
        const promise2 = new Promise<number>((_resolve) => (resolve2 = _resolve))
        const Content2 = () => {
          const num = use(promise2)
          return <p>{num}</p>
        }
        const Component = () => {
          return (
            <Suspense fallback={<div>Loading...</div>}>
              <Content />
              <Suspense fallback={<div>More...</div>}>
                <Content2 />
              </Suspense>
            </Suspense>
          )
        }
        const App = <Component />
        render(App, root)
        expect(root.innerHTML).toBe('<div>Loading...</div>')
        resolve(1)
        await new Promise((resolve) => setTimeout(resolve))
        expect(root.innerHTML).toBe('<p>1</p><div>More...</div>')
        resolve2(2)
        await new Promise((resolve) => setTimeout(resolve))
        expect(root.innerHTML).toBe('<p>1</p><p>2</p>')
      })

      it('race condition', async () => {
        let resolve: (value: number) => void = () => {}
        const promise = new Promise<number>((_resolve) => (resolve = _resolve))
        const Content = () => {
          const num = use(promise)
          return <p>{num}</p>
        }
        const Component = () => {
          const [show, setShow] = useState(false)
          return (
            <div>
              <button onClick={() => setShow((s) => !s)}>{show ? 'Hide' : 'Show'}</button>
              {show && (
                <Suspense fallback={<div>Loading...</div>}>
                  <Content />
                </Suspense>
              )}
            </div>
          )
        }
        const App = <Component />
        render(App, root)
        expect(root.innerHTML).toBe('<div><button>Show</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(root.innerHTML).toBe('<div><button>Hide</button><div>Loading...</div></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(root.innerHTML).toBe('<div><button>Show</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(root.innerHTML).toBe('<div><button>Hide</button><div>Loading...</div></div>')
        resolve(2)
        await Promise.resolve()
        await Promise.resolve()
        expect(root.innerHTML).toBe('<div><button>Hide</button><p>2</p></div>')
      })

      it('Suspense at child', async () => {
        let resolve: (value: number) => void = () => {}
        const promise = new Promise<number>((_resolve) => (resolve = _resolve))
        const Content = () => {
          const num = use(promise)
          return <p>{num}</p>
        }

        const Component = () => {
          return (
            <Suspense fallback={<div>Loading...</div>}>
              <Content />
            </Suspense>
          )
        }
        const App = () => {
          const [show, setShow] = useState(false)
          return (
            <div>
              {show && <Component />}
              <button onClick={() => setShow(true)}>Show</button>
            </div>
          )
        }
        render(<App />, root)
        expect(root.innerHTML).toBe('<div><button>Show</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(root.innerHTML).toBe('<div><div>Loading...</div><button>Show</button></div>')
        resolve(2)
        await Promise.resolve()
        await Promise.resolve()
        expect(root.innerHTML).toBe('<div><p>2</p><button>Show</button></div>')
      })

      it('Suspense at child counter', async () => {
        const promiseMap: Record<number, Promise<number>> = {}
        const Counter = () => {
          const [count, setCount] = useState(0)
          const promise = (promiseMap[count] ||= Promise.resolve(count))
          const value = use(promise)
          return (
            <>
              <p>{value}</p>
              <button onClick={() => setCount(count + 1)}>Increment</button>
            </>
          )
        }
        const Component = () => {
          return (
            <Suspense fallback={<div>Loading...</div>}>
              <Counter />
            </Suspense>
          )
        }
        const App = () => {
          return (
            <div>
              <Component />
            </div>
          )
        }
        render(<App />, root)
        expect(root.innerHTML).toBe('<div><div>Loading...</div></div>')
        await Promise.resolve()
        await Promise.resolve()
        expect(root.innerHTML).toBe('<div><p>0</p><button>Increment</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(root.innerHTML).toBe('<div><div>Loading...</div></div>')
        await Promise.resolve()
        await Promise.resolve()
        expect(root.innerHTML).toBe('<div><p>1</p><button>Increment</button></div>')
      })
    })

    describe('ErrorBoundary', () => {
      let dom: JSDOM
      let root: HTMLElement
      beforeEach(() => {
        dom = new JSDOM('<html><body><div id="root"></div></body></html>', {
          runScripts: 'dangerously',
        })
        global.document = dom.window.document
        global.HTMLElement = dom.window.HTMLElement
        global.Text = dom.window.Text
        root = document.getElementById('root') as HTMLElement
      })

      it('has no error', async () => {
        const App = (
          <ErrorBoundary fallback={<div>Error</div>}>
            <div>OK</div>
          </ErrorBoundary>
        )
        render(App, root)
        expect(root.innerHTML).toBe('<div>OK</div>')
      })

      it('has error', async () => {
        const Component = () => {
          throw new Error('error')
        }
        const App = (
          <ErrorBoundary fallback={<div>Error</div>}>
            <Component />
          </ErrorBoundary>
        )
        render(App, root)
        expect(root.innerHTML).toBe('<div>Error</div>')
      })

      it('has no error with Suspense', async () => {
        let resolve: (value: number) => void = () => {}
        const promise = new Promise<number>((_resolve) => (resolve = _resolve))
        const Content = () => {
          const num = use(promise)
          return <p>{num}</p>
        }
        const Component = () => {
          return (
            <ErrorBoundary fallback={<div>Error</div>}>
              <Suspense fallback={<div>Loading...</div>}>
                <Content />
              </Suspense>
            </ErrorBoundary>
          )
        }
        const App = <Component />
        render(App, root)
        expect(root.innerHTML).toBe('<div>Loading...</div>')
        resolve(1)
        await new Promise((resolve) => setTimeout(resolve))
        expect(root.innerHTML).toBe('<p>1</p>')
      })

      it('has error with Suspense', async () => {
        let resolve: (value: number) => void = () => {}
        const promise = new Promise<number>((_resolve) => (resolve = _resolve))
        const Content = () => {
          use(promise)
          throw new Error('error')
        }
        const Component = () => {
          return (
            <ErrorBoundary fallback={<div>Error</div>}>
              <Suspense fallback={<div>Loading...</div>}>
                <Content />
              </Suspense>
            </ErrorBoundary>
          )
        }
        const App = <Component />
        render(App, root)
        expect(root.innerHTML).toBe('<div>Loading...</div>')
        resolve(1)
        await new Promise((resolve) => setTimeout(resolve))
        expect(root.innerHTML).toBe('<div>Error</div>')
      })
    })
  })
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/dom/components.ts
```typescript
import type { Child, FC, PropsWithChildren } from '../'
import type { ErrorHandler, FallbackRender } from '../components'
import { DOM_ERROR_HANDLER } from '../constants'
import { Fragment } from './jsx-runtime'

/* eslint-disable @typescript-eslint/no-explicit-any */
export const ErrorBoundary: FC<
  PropsWithChildren<{
    fallback?: Child
    fallbackRender?: FallbackRender
    onError?: ErrorHandler
  }>
> = (({ children, fallback, fallbackRender, onError }: any) => {
  const res = Fragment({ children })
  ;(res as any)[DOM_ERROR_HANDLER] = (err: any) => {
    if (err instanceof Promise) {
      throw err
    }
    onError?.(err)
    return fallbackRender?.(err) || fallback
  }
  return res
}) as any

export const Suspense: FC<PropsWithChildren<{ fallback: any }>> = (({
  children,
  fallback,
}: any) => {
  const res = Fragment({ children })
  ;(res as any)[DOM_ERROR_HANDLER] = (err: any, retry: () => void) => {
    if (!(err instanceof Promise)) {
      throw err
    }
    err.finally(retry)
    return fallback
  }
  return res
}) as any
/* eslint-enable @typescript-eslint/no-explicit-any */

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/dom/context.test.tsx
```
/** @jsxImportSource ../ */
import { JSDOM } from 'jsdom'
import {
  Suspense,
  createContext as createContextCommon,
  use,
  useContext as useContextCommon,
} from '..' // for common
// run tests by old style jsx default
// hono/jsx/jsx-runtime and hono/jsx/dom/jsx-runtime are tested in their respective settings
import { createContext as createContextDom, render, useContext as useContextDom, useState } from '.' // for dom

runner('Common', createContextCommon, useContextCommon)
runner('DOM', createContextDom, useContextDom)

function runner(
  name: string,
  createContext: typeof createContextCommon,
  useContext: typeof useContextCommon
) {
  describe(name, () => {
    beforeAll(() => {
      global.requestAnimationFrame = (cb) => setTimeout(cb)
    })

    describe('Context', () => {
      let dom: JSDOM
      let root: HTMLElement
      beforeEach(() => {
        dom = new JSDOM('<html><body><div id="root"></div></body></html>', {
          runScripts: 'dangerously',
        })
        global.document = dom.window.document
        global.HTMLElement = dom.window.HTMLElement
        global.Text = dom.window.Text
        root = document.getElementById('root') as HTMLElement
      })

      it('simple context', async () => {
        const Context = createContext(0)
        const Content = () => {
          const num = useContext(Context)
          return <p>{num}</p>
        }
        const Component = () => {
          return (
            <Context.Provider value={1}>
              <Content />
            </Context.Provider>
          )
        }
        const App = <Component />
        render(App, root)
        expect(root.innerHTML).toBe('<p>1</p>')
      })

      it('<Context> as a provider ', async () => {
        const Context = createContext(0)
        const Content = () => {
          const num = useContext(Context)
          return <p>{num}</p>
        }
        const Component = () => {
          return (
            <Context value={1}>
              <Content />
            </Context>
          )
        }
        const App = <Component />
        render(App, root)
        expect(root.innerHTML).toBe('<p>1</p>')
      })

      it('simple context with state', async () => {
        const Context = createContext(0)
        const Content = () => {
          const [count, setCount] = useState(0)
          const num = useContext(Context)
          return (
            <>
              <p>
                {num} - {count}
              </p>
              <button onClick={() => setCount(count + 1)}>+</button>
            </>
          )
        }
        const Component = () => {
          return (
            <Context.Provider value={1}>
              <Content />
            </Context.Provider>
          )
        }
        const App = <Component />
        render(App, root)
        expect(root.innerHTML).toBe('<p>1 - 0</p><button>+</button>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(root.innerHTML).toBe('<p>1 - 1</p><button>+</button>')
      })

      it('multiple provider', async () => {
        const Context = createContext(0)
        const Content = () => {
          const num = useContext(Context)
          return <p>{num}</p>
        }
        const Component = () => {
          return (
            <>
              <Context.Provider value={1}>
                <Content />
              </Context.Provider>
              <Context.Provider value={2}>
                <Content />
              </Context.Provider>
            </>
          )
        }
        const App = <Component />
        render(App, root)
        expect(root.innerHTML).toBe('<p>1</p><p>2</p>')
      })

      it('nested provider', async () => {
        const Context = createContext(0)
        const Content = () => {
          const num = useContext(Context)
          return <p>{num}</p>
        }
        const Component = () => {
          return (
            <>
              <Context.Provider value={1}>
                <Content />
                <Context.Provider value={3}>
                  <Content />
                </Context.Provider>
                <Content />
              </Context.Provider>
            </>
          )
        }
        const App = <Component />
        render(App, root)
        expect(root.innerHTML).toBe('<p>1</p><p>3</p><p>1</p>')
      })

      it('inside Suspense', async () => {
        const promise = Promise.resolve(2)
        const AsyncComponent = () => {
          const num = use(promise)
          return <p>{num}</p>
        }
        const Context = createContext(0)
        const Content = () => {
          const num = useContext(Context)
          return <p>{num}</p>
        }
        const Component = () => {
          return (
            <>
              <Context.Provider value={1}>
                <Content />
                <Suspense fallback={<div>Loading...</div>}>
                  <Context.Provider value={3}>
                    <Content />
                    <AsyncComponent />
                  </Context.Provider>
                </Suspense>
                <Content />
              </Context.Provider>
            </>
          )
        }
        const App = <Component />
        render(App, root)
        expect(root.innerHTML).toBe('<p>1</p><div>Loading...</div><p>1</p>')
      })
    })
  })
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/dom/context.ts
```typescript
import type { Child } from '../base'
import { DOM_ERROR_HANDLER } from '../constants'
import type { Context } from '../context'
import { globalContexts } from '../context'
import { setInternalTagFlag } from './utils'

export const createContextProviderFunction =
  <T>(values: T[]): Function =>
  ({ value, children }: { value: T; children: Child[] }) => {
    if (!children) {
      return undefined
    }

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const props: { children: any } = {
      children: [
        {
          tag: setInternalTagFlag(() => {
            values.push(value)
          }),
          props: {},
        },
      ],
    }
    if (Array.isArray(children)) {
      props.children.push(...children.flat())
    } else {
      props.children.push(children)
    }
    props.children.push({
      tag: setInternalTagFlag(() => {
        values.pop()
      }),
      props: {},
    })
    const res = { tag: '', props, type: '' }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ;(res as any)[DOM_ERROR_HANDLER] = (err: unknown) => {
      values.pop()
      throw err
    }
    return res
  }

export const createContext = <T>(defaultValue: T): Context<T> => {
  const values = [defaultValue]
  const context: Context<T> = createContextProviderFunction(values) as Context<T>
  context.values = values
  context.Provider = context
  globalContexts.push(context as Context<unknown>)
  return context
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/dom/css.test.tsx
```
/** @jsxImportSource ../ */
import { JSDOM } from 'jsdom'
// run tests by old style jsx default
// hono/jsx/jsx-runtime and hono/jsx/dom/jsx-runtime are tested in their respective settings

import type { JSXNode } from '..'
import { Style, createCssContext, css, rawCssString } from '../../helper/css'
import { minify } from '../../helper/css/common'
import { renderTest } from '../../helper/css/common.case.test'
import { render } from '.'

describe('Style and css for jsx/dom', () => {
  beforeAll(() => {
    global.requestAnimationFrame = (cb) => setTimeout(cb)
  })

  let dom: JSDOM
  let root: HTMLElement
  beforeEach(() => {
    dom = new JSDOM('<html><body><div id="root"></div></body></html>', {
      runScripts: 'dangerously',
    })
    global.document = dom.window.document
    global.HTMLElement = dom.window.HTMLElement
    global.SVGElement = dom.window.SVGElement
    global.Text = dom.window.Text
    root = document.getElementById('root') as HTMLElement
  })

  it('<Style />', async () => {
    const App = () => {
      return (
        <div>
          <Style />
          <div
            class={css`
              color: red;
            `}
          >
            red
          </div>
        </div>
      )
    }
    render(<App />, root)
    expect(root.innerHTML).toBe(
      '<div><style id="hono-css"></style><div class="css-3142110215">red</div></div>'
    )
    await Promise.resolve()
    expect(root.querySelector('style')?.sheet?.cssRules[0].cssText).toBe(
      '.css-3142110215 {color: red;}'
    )
  })

  it('<Style nonce="1234" />', async () => {
    const App = () => {
      return (
        <div>
          <Style nonce='1234' />
        </div>
      )
    }
    render(<App />, root)
    expect(root.innerHTML).toBe('<div><style id="hono-css" nonce="1234"></style></div>')
  })

  it('<Style>{css`global`}</Style>', async () => {
    const App = () => {
      return (
        <div>
          <Style>{css`
            color: red;
          `}</Style>
          <div
            class={css`
              color: red;
            `}
          >
            red
          </div>
        </div>
      )
    }
    render(<App />, root)
    expect(root.innerHTML).toBe(
      '<div><style id="hono-css">color:red</style><div class="css-3142110215">red</div></div>'
    )
  })
})

describe('render', () => {
  renderTest(() => {
    const cssContext = createCssContext({ id: 'hono-css' })

    const dom = new JSDOM('<html><body><div id="root"></div></body></html>', {
      runScripts: 'dangerously',
    })
    global.document = dom.window.document
    global.HTMLElement = dom.window.HTMLElement
    global.Text = dom.window.Text
    const root = document.getElementById('root') as HTMLElement

    const toString = async (node: JSXNode) => {
      render(node, root)
      await Promise.resolve()
      const style = root.querySelector('style')
      if (style) {
        style.textContent = minify(
          [...(style.sheet?.cssRules || [])].map((r) => r.cssText).join('') || ''
        )
      }
      return root.innerHTML
    }

    return {
      toString,
      rawCssString,
      ...cssContext,
      support: { nest: false },
    }
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/dom/css.ts
```typescript
/**
 * @module
 * This module provides APIs that enable `hono/jsx/dom` to support.
 */

import type { FC, PropsWithChildren } from '../'
import type { CssClassName, CssVariableType } from '../../helper/css/common'
import {
  CLASS_NAME,
  DEFAULT_STYLE_ID,
  PSEUDO_GLOBAL_SELECTOR,
  SELECTOR,
  SELECTORS,
  STYLE_STRING,
  cssCommon,
  cxCommon,
  keyframesCommon,
  viewTransitionCommon,
} from '../../helper/css/common'
export { rawCssString } from '../../helper/css/common'

const splitRule = (rule: string): string[] => {
  const result: string[] = []
  let startPos = 0
  let depth = 0
  for (let i = 0, len = rule.length; i < len; i++) {
    const char = rule[i]

    // consume quote

    if (char === "'" || char === '"') {
      const quote = char
      i++
      for (; i < len; i++) {
        if (rule[i] === '\\') {
          i++
          continue
        }
        if (rule[i] === quote) {
          break
        }
      }
      continue
    }

    // comments are removed from the rule in advance
    if (char === '{') {
      depth++
      continue
    }
    if (char === '}') {
      depth--
      if (depth === 0) {
        result.push(rule.slice(startPos, i + 1))
        startPos = i + 1
      }
      continue
    }
  }
  return result
}

interface CreateCssJsxDomObjectsType {
  (args: { id: Readonly<string> }): readonly [
    {
      toString(this: CssClassName): string
    },
    FC<PropsWithChildren<void>>
  ]
}

export const createCssJsxDomObjects: CreateCssJsxDomObjectsType = ({ id }) => {
  let styleSheet: CSSStyleSheet | null | undefined = undefined
  const findStyleSheet = (): [CSSStyleSheet, Set<string>] | [] => {
    if (!styleSheet) {
      styleSheet = document.querySelector<HTMLStyleElement>(`style#${id}`)
        ?.sheet as CSSStyleSheet | null
      if (styleSheet) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        ;(styleSheet as any).addedStyles = new Set<string>()
      }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return styleSheet ? [styleSheet, (styleSheet as any).addedStyles] : []
  }

  const insertRule = (className: string, styleString: string) => {
    const [sheet, addedStyles] = findStyleSheet()
    if (!sheet || !addedStyles) {
      Promise.resolve().then(() => {
        if (!findStyleSheet()[0]) {
          throw new Error('style sheet not found')
        }
        insertRule(className, styleString)
      })
      return
    }

    if (!addedStyles.has(className)) {
      addedStyles.add(className)
      ;(className.startsWith(PSEUDO_GLOBAL_SELECTOR)
        ? splitRule(styleString)
        : [`${className[0] === '@' ? '' : '.'}${className}{${styleString}}`]
      ).forEach((rule) => {
        sheet.insertRule(rule, sheet.cssRules.length)
      })
    }
  }

  const cssObject = {
    toString(this: CssClassName): string {
      const selector = this[SELECTOR]
      insertRule(selector, this[STYLE_STRING])
      this[SELECTORS].forEach(({ [CLASS_NAME]: className, [STYLE_STRING]: styleString }) => {
        insertRule(className, styleString)
      })

      return this[CLASS_NAME]
    },
  }

  const Style: FC<PropsWithChildren<{ nonce?: string }>> = ({ children, nonce }) =>
    ({
      tag: 'style',
      props: {
        id,
        nonce,
        children:
          children &&
          (Array.isArray(children) ? children : [children]).map(
            (c) => (c as unknown as CssClassName)[STYLE_STRING]
          ),
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } as any)

  return [cssObject, Style] as const
}

interface CssType {
  (strings: TemplateStringsArray, ...values: CssVariableType[]): string
}

interface CxType {
  (...args: (string | boolean | null | undefined)[]): string
}

interface KeyframesType {
  (strings: TemplateStringsArray, ...values: CssVariableType[]): CssClassName
}

interface ViewTransitionType {
  (strings: TemplateStringsArray, ...values: CssVariableType[]): string
  (content: string): string
  (): string
}

interface DefaultContextType {
  css: CssType
  cx: CxType
  keyframes: KeyframesType
  viewTransition: ViewTransitionType
  Style: FC<PropsWithChildren<void>>
}

/**
 * @experimental
 * `createCssContext` is an experimental feature.
 * The API might be changed.
 */
export const createCssContext = ({ id }: { id: Readonly<string> }): DefaultContextType => {
  const [cssObject, Style] = createCssJsxDomObjects({ id })

  const newCssClassNameObject = (cssClassName: CssClassName): string => {
    cssClassName.toString = cssObject.toString
    return cssClassName as unknown as string
  }

  const css: CssType = (strings, ...values) => {
    return newCssClassNameObject(cssCommon(strings, values))
  }

  const cx: CxType = (...args) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    args = cxCommon(args as any) as any
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return css(Array(args.length).fill('') as any, ...args)
  }

  const keyframes: KeyframesType = keyframesCommon

  const viewTransition: ViewTransitionType = ((
    strings: TemplateStringsArray | string | undefined,
    ...values: CssVariableType[]
  ) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return newCssClassNameObject(viewTransitionCommon(strings as any, values))
  }) as ViewTransitionType

  return {
    css,
    cx,
    keyframes,
    viewTransition,
    Style,
  }
}

const defaultContext: DefaultContextType = createCssContext({ id: DEFAULT_STYLE_ID })

/**
 * @experimental
 * `css` is an experimental feature.
 * The API might be changed.
 */
export const css = defaultContext.css

/**
 * @experimental
 * `cx` is an experimental feature.
 * The API might be changed.
 */
export const cx = defaultContext.cx

/**
 * @experimental
 * `keyframes` is an experimental feature.
 * The API might be changed.
 */
export const keyframes = defaultContext.keyframes

/**
 * @experimental
 * `viewTransition` is an experimental feature.
 * The API might be changed.
 */
export const viewTransition = defaultContext.viewTransition

/**
 * @experimental
 * `Style` is an experimental feature.
 * The API might be changed.
 */
export const Style = defaultContext.Style

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/dom/index.test.tsx
```
/** @jsxImportSource ../ */
import { JSDOM } from 'jsdom'
import type { Child, FC } from '..'
// run tests by old style jsx default
// hono/jsx/jsx-runtime and hono/jsx/dom/jsx-runtime are tested in their respective settings
import { createElement, jsx } from '..'
import type { RefObject } from '../hooks'
import {
  createRef,
  useCallback,
  useEffect,
  useInsertionEffect,
  useLayoutEffect,
  useMemo,
  useRef,
  useState,
} from '../hooks'
import DefaultExport, {
  cloneElement,
  cloneElement as cloneElementForDom,
  createElement as createElementForDom,
  createContext,
  useContext,
  createPortal,
  flushSync,
  isValidElement,
  memo,
  render,
  version,
} from '.'

describe('Common', () => {
  ;[createElement, createElementForDom].forEach((createElement) => {
    describe('createElement', () => {
      it('simple', () => {
        const element = createElement('div', { id: 'app' })
        expect(element).toEqual(expect.objectContaining({ tag: 'div', props: { id: 'app' } }))
      })

      it('children', () => {
        const element = createElement('div', { id: 'app' }, 'Hello')
        expect(element).toEqual(
          expect.objectContaining({ tag: 'div', props: { id: 'app', children: 'Hello' } })
        )
      })

      it('multiple children', () => {
        const element = createElement('div', { id: 'app' }, 'Hello', 'World')
        expect(element).toEqual(
          expect.objectContaining({
            tag: 'div',
            props: { id: 'app', children: ['Hello', 'World'] },
          })
        )
      })

      it('key', () => {
        const element = createElement('div', { id: 'app', key: 'key' })
        expect(element).toEqual(
          expect.objectContaining({ tag: 'div', props: { id: 'app' }, key: 'key' })
        )
      })

      it('ref', () => {
        const ref = { current: null }
        const element = createElement('div', { id: 'app', ref })
        expect(element).toEqual(expect.objectContaining({ tag: 'div', props: { id: 'app', ref } }))
        expect(element.ref).toBe(ref)
      })

      it('type', () => {
        const element = createElement('div', { id: 'app' })
        expect(element.type).toBe('div')
      })

      it('null props', () => {
        const element = createElement('div', null)
        expect(element).toEqual(expect.objectContaining({ tag: 'div', props: {} }))
      })
    })
  })
})

describe('DOM', () => {
  beforeAll(() => {
    global.requestAnimationFrame = (cb) => setTimeout(cb)
  })

  let dom: JSDOM
  let root: HTMLElement
  beforeEach(() => {
    dom = new JSDOM('<html><body><div id="root"></div></body></html>', {
      runScripts: 'dangerously',
    })
    global.document = dom.window.document
    global.HTMLElement = dom.window.HTMLElement
    global.SVGElement = dom.window.SVGElement
    global.Text = dom.window.Text
    root = document.getElementById('root') as HTMLElement
  })

  it('simple App', () => {
    const App = <h1>Hello</h1>
    render(App, root)
    expect(root.innerHTML).toBe('<h1>Hello</h1>')
  })

  it('replace', () => {
    dom.window.document.body.innerHTML = '<div id="root">Existing content</div>'
    root = document.getElementById('root') as HTMLElement
    const App = <h1>Hello</h1>
    render(App, root)
    expect(root.innerHTML).toBe('<h1>Hello</h1>')
  })

  it('render text directly', () => {
    const App = () => <>{'Hello'}</>
    render(<App />, root)
    expect(root.innerHTML).toBe('Hello')
  })

  describe('performance', () => {
    it('should be O(N) for each additional element', () => {
      const App = () => (
        <>
          {Array.from({ length: 1000 }, (_, i) => (
            <div>
              <span>{i}</span>
            </div>
          ))}
        </>
      )
      render(<App />, root)
      expect(root.innerHTML).toBe(
        Array.from({ length: 1000 }, (_, i) => `<div><span>${i}</span></div>`).join('')
      )
    })
  })

  describe('attribute', () => {
    it('simple', () => {
      const App = () => <div id='app' class='app' />
      render(<App />, root)
      expect(root.innerHTML).toBe('<div id="app" class="app"></div>')
    })

    it('boolean', () => {
      const App = () => <div hidden />
      render(<App />, root)
      expect(root.innerHTML).toBe('<div hidden=""></div>')
    })

    it('style', () => {
      const App = () => <div style={{ fontSize: '10px' }} />
      render(<App />, root)
      expect(root.innerHTML).toBe('<div style="font-size: 10px;"></div>')
    })

    it('update style', () => {
      const App = () => <div style={{ fontSize: '10px' }} />
      render(<App />, root)
      expect(root.innerHTML).toBe('<div style="font-size: 10px;"></div>')
    })

    it('style with CSS variables - 1', () => {
      const App = () => <div style={{ '--my-var-1': '15px' }} />
      render(<App />, root)
      expect(root.innerHTML).toBe('<div style="--my-var-1: 15px;"></div>')
    })

    it('style with CSS variables - 2', () => {
      const App = () => <div style={{ '--myVar-2': '20px' }} />
      render(<App />, root)
      expect(root.innerHTML).toBe('<div style="--myVar-2: 20px;"></div>')
    })

    it('style with string', async () => {
      const App = () => {
        const [style, setStyle] = useState<{ fontSize?: string; color?: string }>({
          fontSize: '10px',
        })
        return <div style={style} onClick={() => setStyle({ color: 'red' })} />
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div style="font-size: 10px;"></div>')
      root.querySelector('div')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div style="color: red;"></div>')
    })

    it('toString() is called', () => {
      const App = () => <div x-value={{ toString: () => 'value' }} />
      render(<App />, root)
      expect(root.innerHTML).toBe('<div x-value="value"></div>')
    })

    it('ref', () => {
      const App = () => {
        const ref = useRef<HTMLDivElement>(null)
        return <div ref={ref} />
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div></div>')
    })

    it('ref with callback', () => {
      const ref = useRef<HTMLDivElement>(null)
      const App = () => {
        return <div ref={(node: HTMLDivElement) => (ref.current = node)} />
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div></div>')
      expect(ref.current).toBeInstanceOf(HTMLElement)
    })

    it('ref with null', () => {
      const App = () => {
        return <div ref={null} />
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div></div>')
    })

    it('remove node with ref object', async () => {
      const ref = createRef<HTMLDivElement>()
      const App = () => {
        const [show, setShow] = useState(true)
        return (
          <>
            {show && <div ref={ref} />}
            <button onClick={() => setShow(false)}>remove</button>
          </>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div></div><button>remove</button>')
      expect(ref.current).toBeInstanceOf(dom.window.HTMLDivElement)
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<button>remove</button>')
      expect(ref.current).toBe(null)
    })

    it('remove node with ref function', async () => {
      const ref = vi.fn()
      const App = () => {
        const [show, setShow] = useState(true)
        return (
          <>
            {show && <div ref={ref} />}
            <button onClick={() => setShow(false)}>remove</button>
          </>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div></div><button>remove</button>')
      expect(ref).toHaveBeenLastCalledWith(expect.any(dom.window.HTMLDivElement))
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<button>remove</button>')
      expect(ref).toHaveBeenLastCalledWith(null)
    })

    it('ref cleanup function', async () => {
      const cleanup = vi.fn()
      const ref = vi.fn().mockReturnValue(cleanup)
      const App = () => {
        const [show, setShow] = useState(true)
        return (
          <>
            {show && <div ref={ref} />}
            <button onClick={() => setShow(false)}>remove</button>
          </>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div></div><button>remove</button>')
      expect(ref).toHaveBeenLastCalledWith(expect.any(dom.window.HTMLDivElement))
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<button>remove</button>')
      expect(ref).toBeCalledTimes(1)
      expect(cleanup).toBeCalledTimes(1)
    })
  })

  describe('child component', () => {
    it('simple', async () => {
      const Child = vi.fn(({ count }: { count: number }) => <div>{count}</div>)
      const App = () => {
        const [count, setCount] = useState(0)
        return (
          <>
            <div>{count}</div>
            <Child count={Math.floor(count / 2)} />
            <button onClick={() => setCount(count + 1)}>+</button>
          </>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div>0</div><div>0</div><button>+</button>')
      expect(Child).toBeCalledTimes(1)
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div>1</div><div>0</div><button>+</button>')
      expect(Child).toBeCalledTimes(2)
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div>2</div><div>1</div><button>+</button>')
      expect(Child).toBeCalledTimes(3)
    })
  })

  describe('defaultProps', () => {
    it('simple', () => {
      const App: FC<{ name?: string }> = ({ name }) => <div>{name}</div>
      App.defaultProps = { name: 'default' }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div>default</div>')
    })

    it('override', () => {
      const App: FC<{ name: string }> = ({ name }) => <div>{name}</div>
      App.defaultProps = { name: 'default' }
      render(<App name='override' />, root)
      expect(root.innerHTML).toBe('<div>override</div>')
    })
  })

  describe('replace content', () => {
    it('text to text', async () => {
      let setCount: (count: number) => void = () => {}
      const App = () => {
        const [count, _setCount] = useState(0)
        setCount = _setCount
        return <>{count}</>
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('0')
      setCount(1)
      await Promise.resolve()
      expect(root.innerHTML).toBe('1')
    })

    it('text to element', async () => {
      let setCount: (count: number) => void = () => {}
      const App = () => {
        const [count, _setCount] = useState(0)
        setCount = _setCount
        return count === 0 ? <>{count}</> : <div>{count}</div>
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('0')
      setCount(1)
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div>1</div>')
    })

    it('element to element', async () => {
      let setCount: (count: number) => void = () => {}
      const App = () => {
        const [count, _setCount] = useState(0)
        setCount = _setCount
        return <div>{count}</div>
      }
      const app = <App />
      render(app, root)
      expect(root.innerHTML).toBe('<div>0</div>')

      const insertBeforeSpy = vi.spyOn(dom.window.Node.prototype, 'insertBefore')
      setCount(1)
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div>1</div>')
      expect(insertBeforeSpy).not.toHaveBeenCalled()
    })

    it('element to text to element', async () => {
      let setCount: (count: number) => void = () => {}
      const App = () => {
        const [count, _setCount] = useState(0)
        setCount = _setCount
        return count % 2 === 0 ? <div>{count}</div> : <>{count}</>
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div>0</div>')
      setCount(1)
      await Promise.resolve()
      expect(root.innerHTML).toBe('1')
      setCount(2)
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div>2</div>')
    })

    it('text to child component to text', async () => {
      let setCount: (count: number) => void = () => {}
      const Child = () => {
        return <div>Child</div>
      }
      const App = () => {
        const [count, _setCount] = useState(0)
        setCount = _setCount
        return count % 2 === 0 ? <>{count}</> : <Child />
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('0')
      setCount(1)
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div>Child</div>')
      setCount(2)
      await Promise.resolve()
      expect(root.innerHTML).toBe('2')
    })

    it('one child is updated', async () => {
      let setCount: (count: number) => void = () => {}
      const App = () => {
        const [count, _setCount] = useState(0)
        setCount = _setCount
        return <div>{count}</div>
      }
      const app = (
        <>
          <App />
          <div>Footer</div>
        </>
      )
      render(app, root)
      expect(root.innerHTML).toBe('<div>0</div><div>Footer</div>')

      const insertBeforeSpy = vi.spyOn(dom.window.Node.prototype, 'insertBefore')
      setCount(1)
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div>1</div><div>Footer</div>')
      expect(insertBeforeSpy).not.toHaveBeenCalled()
    })

    it('should not call insertBefore for unchanged complex dom tree', async () => {
      let setCount: (count: number) => void = () => {}
      const App = () => {
        const [count, _setCount] = useState(0)
        setCount = _setCount
        return (
          <form>
            <div>
              <label>label</label>
              <input />
            </div>
            <p>{count}</p>
          </form>
        )
      }
      const app = <App />

      render(app, root)
      expect(root.innerHTML).toBe('<form><div><label>label</label><input></div><p>0</p></form>')

      const insertBeforeSpy = vi.spyOn(dom.window.Node.prototype, 'insertBefore')
      setCount(1)
      await Promise.resolve()
      expect(root.innerHTML).toBe('<form><div><label>label</label><input></div><p>1</p></form>')
      expect(insertBeforeSpy).not.toHaveBeenCalled()
    })

    it('should not call textContent for unchanged text', async () => {
      let setCount: (count: number) => void = () => {}
      const App = () => {
        const [count, _setCount] = useState(0)
        setCount = _setCount
        return (
          <>
            <span>hono</span>
            <input value={count} />
          </>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<span>hono</span><input value="0">')
      setCount(1)

      const textContentSpy = vi.fn()
      Object.defineProperty(dom.window.Text.prototype, 'textContent', {
        set: textContentSpy,
      })
      await Promise.resolve()
      expect(root.innerHTML).toBe('<span>hono</span><input value="1">')
      expect(textContentSpy).not.toHaveBeenCalled()
    })
  })

  describe('children', () => {
    it('element', async () => {
      const Container = ({ children }: { children: Child }) => <div>{children}</div>
      const App = () => (
        <Container>
          <span>Content</span>
        </Container>
      )
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><span>Content</span></div>')
    })

    it('array', async () => {
      const Container = ({ children }: { children: Child }) => <div>{children}</div>
      const App = () => <Container>{[<span>1</span>, <span>2</span>]}</Container>
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><span>1</span><span>2</span></div>')
    })

    it('use the same children multiple times', async () => {
      const MultiChildren = ({ children }: { children: Child }) => (
        <>
          {children}
          <div>{children}</div>
        </>
      )
      const App = () => (
        <MultiChildren>
          <span>Content</span>
        </MultiChildren>
      )
      render(<App />, root)
      expect(root.innerHTML).toBe('<span>Content</span><div><span>Content</span></div>')
    })
  })

  describe('update properties', () => {
    describe('input', () => {
      it('value', async () => {
        let setValue: (value: string) => void = () => {}
        const App = () => {
          const [value, _setValue] = useState('a')
          setValue = _setValue
          return <input value={value} />
        }
        render(<App />, root)
        expect(root.innerHTML).toBe('<input value="a">')
        const valueSpy = vi.fn()
        Object.defineProperty(dom.window.HTMLInputElement.prototype, 'value', {
          set: valueSpy,
        })
        setValue('b')
        await Promise.resolve()
        expect(root.innerHTML).toBe('<input value="b">')
        expect(valueSpy).toHaveBeenCalledWith('b')
      })

      it('assign undefined', async () => {
        let setValue: (value: string | undefined) => void = () => {}
        const App = () => {
          const [value, _setValue] = useState<string | undefined>('a')
          setValue = _setValue
          return <input value={value} />
        }
        render(<App />, root)
        expect(root.innerHTML).toBe('<input value="a">')
        const valueSpy = vi.fn()
        Object.defineProperty(dom.window.HTMLInputElement.prototype, 'value', {
          set: valueSpy,
        })
        setValue(undefined)
        await Promise.resolve()
        expect(root.innerHTML).toBe('<input>')
        expect(valueSpy).toHaveBeenCalledWith(null) // assign null means empty string
      })

      it('checked', async () => {
        let setValue: (value: string) => void = () => {}
        const App = () => {
          const [value, _setValue] = useState('a')
          setValue = _setValue
          return <input type='checkbox' checked={value === 'b'} />
        }
        render(<App />, root)
        expect(root.innerHTML).toBe('<input type="checkbox">')
        const checkedSpy = vi.fn()
        Object.defineProperty(dom.window.HTMLInputElement.prototype, 'checked', {
          set: checkedSpy,
        })
        setValue('b')
        await Promise.resolve()
        expect(root.innerHTML).toBe('<input type="checkbox" checked="">')
        expect(checkedSpy).toHaveBeenCalledWith(true)
        setValue('a')
        await Promise.resolve()
        expect(root.innerHTML).toBe('<input type="checkbox">')
        expect(checkedSpy).toHaveBeenCalledWith(false)
      })
    })

    describe('textarea', () => {
      it('value', async () => {
        let setValue: (value: string) => void = () => {}
        const App = () => {
          const [value, _setValue] = useState('a')
          setValue = _setValue
          return <textarea value={value} />
        }
        render(<App />, root)
        expect(root.innerHTML).toBe('<textarea>a</textarea>')
        const valueSpy = vi.fn()
        Object.defineProperty(dom.window.HTMLTextAreaElement.prototype, 'value', {
          set: valueSpy,
        })
        setValue('b')
        await Promise.resolve()
        expect(root.innerHTML).toBe('<textarea>b</textarea>')
        expect(valueSpy).toHaveBeenCalledWith('b')
      })

      it('assign undefined', async () => {
        let setValue: (value: string | undefined) => void = () => {}
        const App = () => {
          const [value, _setValue] = useState<string | undefined>('a')
          setValue = _setValue
          return <textarea value={value} />
        }
        render(<App />, root)
        expect(root.innerHTML).toBe('<textarea>a</textarea>')
        const valueSpy = vi.fn()
        Object.defineProperty(dom.window.HTMLTextAreaElement.prototype, 'value', {
          set: valueSpy,
        })
        setValue(undefined)
        await Promise.resolve()
        expect(root.innerHTML).toBe('<textarea></textarea>')
        expect(valueSpy).toHaveBeenCalledWith(null) // assign null means empty string
      })
    })

    describe('select', () => {
      it('value', async () => {
        let setValue: (value: string) => void = () => {}
        const App = () => {
          const [value, _setValue] = useState('a')
          setValue = _setValue
          return (
            <select value={value}>
              <option value='a'>A</option>
              <option value='b'>B</option>
              <option value='c'>C</option>
            </select>
          )
        }
        render(<App />, root)
        expect(root.innerHTML).toBe(
          '<select><option value="a">A</option><option value="b">B</option><option value="c">C</option></select>'
        )
        const valueSpy = vi.fn()
        Object.defineProperty(dom.window.HTMLSelectElement.prototype, 'value', {
          set: valueSpy,
        })
        setValue('b')
        await Promise.resolve()
        expect(valueSpy).toHaveBeenCalledWith('b')
      })

      it('invalid value', async () => {
        let setValue: (value: string) => void = () => {}
        const App = () => {
          const [value, _setValue] = useState('a')
          setValue = _setValue
          return (
            <select value={value}>
              <option value='a'>A</option>
              <option value='b'>B</option>
              <option value='c'>C</option>
            </select>
          )
        }
        render(<App />, root)
        expect(root.innerHTML).toBe(
          '<select><option value="a">A</option><option value="b">B</option><option value="c">C</option></select>'
        )
        setValue('z')
        await Promise.resolve()
        const select = root.querySelector('select') as HTMLSelectElement
        expect(select.value).toBe('a') // invalid value is ignored
      })

      it('assign undefined', async () => {
        let setValue: (value: string | undefined) => void = () => {}
        const App = () => {
          const [value, _setValue] = useState<string | undefined>('a')
          setValue = _setValue
          return (
            <select value={value}>
              <option value='a'>A</option>
              <option value='b'>B</option>
              <option value='c'>C</option>
            </select>
          )
        }
        render(<App />, root)
        expect(root.innerHTML).toBe(
          '<select><option value="a">A</option><option value="b">B</option><option value="c">C</option></select>'
        )
        setValue(undefined)
        await Promise.resolve()
        const select = root.querySelector('select') as HTMLSelectElement
        expect(select.value).toBe('a') // select the first option
      })
    })

    describe('option', () => {
      it('selected', async () => {
        let setValue: (value: string) => void = () => {}
        const App = () => {
          const [value, _setValue] = useState('a')
          setValue = _setValue
          return (
            <select>
              <option value='a'>A</option>
              <option value='b' selected={value === 'b'}>
                B
              </option>
              <option value='c'>C</option>
            </select>
          )
        }
        render(<App />, root)
        expect(root.innerHTML).toBe(
          '<select><option value="a">A</option><option value="b">B</option><option value="c">C</option></select>'
        )
        setValue('b')
        await Promise.resolve()
        expect(root.innerHTML).toBe(
          '<select><option value="a">A</option><option value="b" selected="">B</option><option value="c">C</option></select>'
        )
        const select = root.querySelector('select') as HTMLSelectElement
        expect(select.value).toBe('b')
        setValue('a')
        await Promise.resolve()
        expect(root.innerHTML).toBe(
          '<select><option value="a">A</option><option value="b">B</option><option value="c">C</option></select>'
        )
        expect(select.value).toBe('a')
      })
    })
  })

  describe('dangerouslySetInnerHTML', () => {
    it('string', () => {
      const App = () => {
        return <div dangerouslySetInnerHTML={{ __html: '<p>Hello</p>' }} />
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><p>Hello</p></div>')
    })
  })

  describe('Event', () => {
    it('bubbling phase', async () => {
      const clicked: string[] = []
      const App = () => {
        return (
          <div
            onClick={() => {
              clicked.push('div')
            }}
          >
            <button
              onClick={() => {
                clicked.push('button')
              }}
            >
              Click
            </button>
          </div>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button>Click</button></div>')
      root.querySelector('button')?.click()
      expect(clicked).toEqual(['button', 'div'])
    })

    it('ev.stopPropagation()', async () => {
      const clicked: string[] = []
      const App = () => {
        return (
          <div
            onClick={() => {
              clicked.push('div')
            }}
          >
            <button
              onClick={(ev) => {
                ev.stopPropagation()
                clicked.push('button')
              }}
            >
              Click
            </button>
          </div>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button>Click</button></div>')
      root.querySelector('button')?.click()
      expect(clicked).toEqual(['button'])
    })

    it('capture phase', async () => {
      const clicked: string[] = []
      const App = () => {
        return (
          <div
            onClickCapture={(ev) => {
              ev.stopPropagation()
              clicked.push('div')
            }}
          >
            <button
              onClickCapture={() => {
                clicked.push('button')
              }}
            >
              Click
            </button>
          </div>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button>Click</button></div>')
      root.querySelector('button')?.click()
      expect(clicked).toEqual(['div'])
    })

    it('remove capture phase event', async () => {
      const clicked: string[] = []
      const App = () => {
        const [canceled, setCanceled] = useState(false)
        return (
          <div
            {...(canceled
              ? {}
              : {
                  onClickCapture: () => {
                    clicked.push('div')
                  },
                })}
          >
            <button
              onClickCapture={() => {
                setCanceled(true)
                clicked.push('button')
              }}
            >
              Click
            </button>
          </div>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button>Click</button></div>')
      root.querySelector('button')?.click()
      expect(clicked).toEqual(['div', 'button'])
      await Promise.resolve()
      root.querySelector('button')?.click()
      expect(clicked).toEqual(['div', 'button', 'button'])
    })

    it('onGotPointerCapture', async () => {
      const App = () => {
        return <div onGotPointerCapture={() => {}}></div>
      }
      const addEventListenerSpy = vi.spyOn(dom.window.Node.prototype, 'addEventListener')
      render(<App />, root)
      expect(addEventListenerSpy).toHaveBeenCalledOnce()
      expect(addEventListenerSpy).toHaveBeenCalledWith(
        'gotpointercapture',
        expect.any(Function),
        false
      )
    })

    it('onGotPointerCaptureCapture', async () => {
      const App = () => {
        return <div onGotPointerCaptureCapture={() => {}}></div>
      }
      const addEventListenerSpy = vi.spyOn(dom.window.Node.prototype, 'addEventListener')
      render(<App />, root)
      expect(addEventListenerSpy).toHaveBeenCalledOnce()
      expect(addEventListenerSpy).toHaveBeenCalledWith(
        'gotpointercapture',
        expect.any(Function),
        true
      )
    })

    it('undefined', async () => {
      const App = () => {
        return <div onClick={undefined}></div>
      }
      const addEventListenerSpy = vi.spyOn(dom.window.Node.prototype, 'addEventListener')
      render(<App />, root)
      expect(addEventListenerSpy).not.toHaveBeenCalled()
    })

    it('invalid event handler value', async () => {
      const App = () => {
        return <div onClick={1 as unknown as () => void}></div>
      }
      expect(() => render(<App />, root)).toThrow()
    })
  })

  it('simple Counter', async () => {
    const Counter = () => {
      const [count, setCount] = useState(0)
      return (
        <div>
          <p>Count: {count}</p>
          <button onClick={() => setCount(count + 1)}>+</button>
        </div>
      )
    }
    const app = <Counter />
    render(app, root)
    expect(root.innerHTML).toBe('<div><p>Count: 0</p><button>+</button></div>')
    const button = root.querySelector('button') as HTMLButtonElement
    button.click()
    await Promise.resolve()
    expect(root.innerHTML).toBe('<div><p>Count: 1</p><button>+</button></div>')
  })

  it('multiple useState()', async () => {
    let called = 0
    const Counter = () => {
      const [countA, setCountA] = useState(0)
      const [countB, setCountB] = useState(0)
      called++
      return (
        <div>
          <p>A: {countA}</p>
          <button onClick={() => setCountA(countA + 1)}>+</button>
          <p>B: {countB}</p>
          <button onClick={() => setCountB(countB + 1)}>+</button>
        </div>
      )
    }
    const app = <Counter />
    render(app, root)
    expect(root.innerHTML).toBe(
      '<div><p>A: 0</p><button>+</button><p>B: 0</p><button>+</button></div>'
    )
    expect(called).toBe(1)
    const [buttonA, buttonB] = root.querySelectorAll('button')
    for (let i = 0; i < 3; i++) {
      buttonA.click()
      await Promise.resolve()
    }
    for (let i = 0; i < 4; i++) {
      buttonB.click()
      await Promise.resolve()
    }
    expect(root.innerHTML).toBe(
      '<div><p>A: 3</p><button>+</button><p>B: 4</p><button>+</button></div>'
    )
    expect(called).toBe(8)
  })

  it('multiple update state calls at once in onClick attributes', async () => {
    let called = 0
    const Counter = () => {
      const [countA, setCountA] = useState(0)
      const [countB, setCountB] = useState(0)
      called++
      return (
        <div>
          <button
            onClick={() => {
              setCountA(countA + 1)
              setCountB(countB + 2)
            }}
          >
            +
          </button>
          {countA} {countB}
        </div>
      )
    }
    const app = <Counter />
    render(app, root)
    expect(root.innerHTML).toBe('<div><button>+</button>0 0</div>')
    expect(called).toBe(1)
    root.querySelector('button')?.click()
    expect(called).toBe(1)
    await Promise.resolve()
    expect(called).toBe(2)
  })

  it('multiple update state calls at once in dom events', async () => {
    let called = 0
    const Counter = () => {
      const [countA, setCountA] = useState(0)
      const [countB, setCountB] = useState(0)
      const buttonRef = useRef<HTMLButtonElement>(null)
      called++

      useEffect(() => {
        buttonRef.current?.addEventListener('click', () => {
          setCountA(countA + 1)
          setCountB(countB + 2)
        })
      }, [])

      return (
        <div>
          <button ref={buttonRef}>+</button>
          {countA} {countB}
        </div>
      )
    }
    const app = <Counter />
    render(app, root)
    expect(root.innerHTML).toBe('<div><button>+</button>0 0</div>')
    expect(called).toBe(1)
    await new Promise((resolve) => setTimeout(resolve))
    root.querySelector('button')?.click()
    expect(called).toBe(1)
    await Promise.resolve()
    expect(called).toBe(2)
  })

  it('nested useState()', async () => {
    const ChildCounter = () => {
      const [count, setCount] = useState(0)
      return (
        <div>
          <p>Child Count: {count}</p>
          <button onClick={() => setCount(count + 1)}>+</button>
        </div>
      )
    }
    const Counter = () => {
      const [count, setCount] = useState(0)
      return (
        <div>
          <p>Count: {count}</p>
          <button onClick={() => setCount(count + 1)}>+</button>
          <ChildCounter />
        </div>
      )
    }
    const app = <Counter />
    render(app, root)
    expect(root.innerHTML).toBe(
      '<div><p>Count: 0</p><button>+</button><div><p>Child Count: 0</p><button>+</button></div></div>'
    )
    const [button, childButton] = root.querySelectorAll('button')
    for (let i = 0; i < 3; i++) {
      childButton.click()
      await Promise.resolve()
    }
    for (let i = 0; i < 2; i++) {
      button.click()
      await Promise.resolve()
    }
    for (let i = 0; i < 3; i++) {
      childButton.click()
      await Promise.resolve()
    }
    for (let i = 0; i < 3; i++) {
      button.click()
      await Promise.resolve()
    }
    expect(root.innerHTML).toBe(
      '<div><p>Count: 5</p><button>+</button><div><p>Child Count: 6</p><button>+</button></div></div>'
    )
  })

  it('nested useState() with children', async () => {
    const ChildCounter = () => {
      const [count, setCount] = useState(0)
      return (
        <div>
          <p>Child Count: {count}</p>
          <button onClick={() => setCount(count + 1)}>+</button>
        </div>
      )
    }
    const Counter = ({ children }: { children: Child }) => {
      const [count, setCount] = useState(0)
      return (
        <div>
          <p>Count: {count}</p>
          <button onClick={() => setCount(count + 1)}>+</button>
          {children}
        </div>
      )
    }
    const app = (
      <Counter>
        <ChildCounter />
      </Counter>
    )
    render(app, root)
    expect(root.innerHTML).toBe(
      '<div><p>Count: 0</p><button>+</button><div><p>Child Count: 0</p><button>+</button></div></div>'
    )
    const [button, childButton] = root.querySelectorAll('button')
    for (let i = 0; i < 3; i++) {
      childButton.click()
      await Promise.resolve()
    }
    for (let i = 0; i < 2; i++) {
      button.click()
      await Promise.resolve()
    }
    for (let i = 0; i < 3; i++) {
      childButton.click()
      await Promise.resolve()
    }
    for (let i = 0; i < 3; i++) {
      button.click()
      await Promise.resolve()
    }
    expect(root.innerHTML).toBe(
      '<div><p>Count: 5</p><button>+</button><div><p>Child Count: 6</p><button>+</button></div></div>'
    )
  })

  it('consecutive fragment', async () => {
    const ComponentA = () => {
      const [count, setCount] = useState(0)
      return (
        <>
          <div>A: {count}</div>
          <button id='a-button' onClick={() => setCount(count + 1)}>
            A: +
          </button>
        </>
      )
    }
    const App = () => {
      const [count, setCount] = useState(0)
      return (
        <>
          <ComponentA />
          <div>B: {count}</div>
          <button id='b-button' onClick={() => setCount(count + 1)}>
            B: +
          </button>
        </>
      )
    }
    render(<App />, root)
    expect(root.innerHTML).toBe(
      '<div>A: 0</div><button id="a-button">A: +</button><div>B: 0</div><button id="b-button">B: +</button>'
    )
    root.querySelector<HTMLButtonElement>('#b-button')?.click()
    await Promise.resolve()
    expect(root.innerHTML).toBe(
      '<div>A: 0</div><button id="a-button">A: +</button><div>B: 1</div><button id="b-button">B: +</button>'
    )
    root.querySelector<HTMLButtonElement>('#a-button')?.click()
    await Promise.resolve()
    expect(root.innerHTML).toBe(
      '<div>A: 1</div><button id="a-button">A: +</button><div>B: 1</div><button id="b-button">B: +</button>'
    )
  })

  it('switch child component', async () => {
    const Even = () => <p>Even</p>
    const Odd = () => <div>Odd</div>
    const Counter = () => {
      const [count, setCount] = useState(0)
      return (
        <div>
          {count % 2 === 0 ? <Even /> : <Odd />}
          <button onClick={() => setCount(count + 1)}>+</button>
        </div>
      )
    }
    const app = <Counter />
    render(app, root)
    expect(root.innerHTML).toBe('<div><p>Even</p><button>+</button></div>')
    const button = root.querySelector('button') as HTMLButtonElement
    button.click()
    await Promise.resolve()
    expect(root.innerHTML).toBe('<div><div>Odd</div><button>+</button></div>')
    button.click()
    await Promise.resolve()
    expect(root.innerHTML).toBe('<div><p>Even</p><button>+</button></div>')
  })

  it('add/remove/swap item', async () => {
    const TodoApp = () => {
      const [todos, setTodos] = useState(['a', 'b', 'c'])
      return (
        <div>
          {todos.map((todo) => (
            <div key={todo}>{todo}</div>
          ))}
          <button onClick={() => setTodos([...todos, 'd'])}>add</button>
          <button onClick={() => setTodos(todos.slice(0, -1))}>remove</button>
          <button onClick={() => setTodos([todos[0], todos[2], todos[1], todos[3] || ''])}>
            swap
          </button>
        </div>
      )
    }
    const app = <TodoApp />
    render(app, root)
    expect(root.innerHTML).toBe(
      '<div><div>a</div><div>b</div><div>c</div><button>add</button><button>remove</button><button>swap</button></div>'
    )
    const [addButton] = root.querySelectorAll('button')
    addButton.click()
    await Promise.resolve()
    expect(root.innerHTML).toBe(
      '<div><div>a</div><div>b</div><div>c</div><div>d</div><button>add</button><button>remove</button><button>swap</button></div>'
    )
    const [, , swapButton] = root.querySelectorAll('button')
    swapButton.click()
    await Promise.resolve()
    expect(root.innerHTML).toBe(
      '<div><div>a</div><div>c</div><div>b</div><div>d</div><button>add</button><button>remove</button><button>swap</button></div>'
    )
    const [, removeButton] = root.querySelectorAll('button')
    removeButton.click()
    await Promise.resolve()
    expect(root.innerHTML).toBe(
      '<div><div>a</div><div>c</div><div>b</div><button>add</button><button>remove</button><button>swap</button></div>'
    )
  })

  it('swap deferent type of child component', async () => {
    const Even = () => <p>Even</p>
    const Odd = () => <div>Odd</div>
    const Counter = () => {
      const [count, setCount] = useState(0)
      return (
        <div>
          {count % 2 === 0 ? (
            <>
              <Even />
              <Odd />
            </>
          ) : (
            <>
              <Odd />
              <Even />
            </>
          )}
          <button onClick={() => setCount(count + 1)}>+</button>
        </div>
      )
    }
    const app = <Counter />
    render(app, root)
    expect(root.innerHTML).toBe('<div><p>Even</p><div>Odd</div><button>+</button></div>')
    const button = root.querySelector('button') as HTMLButtonElement

    const createElementSpy = vi.spyOn(dom.window.document, 'createElement')

    button.click()
    await Promise.resolve()
    expect(root.innerHTML).toBe('<div><div>Odd</div><p>Even</p><button>+</button></div>')
    button.click()
    await Promise.resolve()
    expect(root.innerHTML).toBe('<div><p>Even</p><div>Odd</div><button>+</button></div>')

    expect(createElementSpy).not.toHaveBeenCalled()
  })

  it('useState for unnamed function', async () => {
    const Input = ({ label, onInput }: { label: string; onInput: (value: string) => void }) => {
      return (
        <div>
          <label>{label}</label>
          <input
            onInput={(e: InputEvent) => onInput((e.target as HTMLInputElement)?.value || '')}
          />
        </div>
      )
    }
    const Form = () => {
      const [values, setValues] = useState<{ [key: string]: string }>({})
      return (
        <form>
          <Input label='Name' onInput={(value) => setValues({ ...values, name: value })} />
          <Input label='Email' onInput={(value) => setValues({ ...values, email: value })} />
          <span>{JSON.stringify(values)}</span>
        </form>
      )
    }
    const app = <Form />
    render(app, root)
    expect(root.innerHTML).toBe(
      '<form><div><label>Name</label><input></div><div><label>Email</label><input></div><span>{}</span></form>'
    )
    const [nameInput] = root.querySelectorAll('input')
    nameInput.value = 'John'
    nameInput.dispatchEvent(new dom.window.Event('input'))
    await Promise.resolve()
    expect(root.innerHTML).toBe(
      '<form><div><label>Name</label><input></div><div><label>Email</label><input></div><span>{"name":"John"}</span></form>'
    )
    const [, emailInput] = root.querySelectorAll('input')
    emailInput.value = 'john@example.com'
    emailInput.dispatchEvent(new dom.window.Event('input'))
    await Promise.resolve()
    expect(root.innerHTML).toBe(
      '<form><div><label>Name</label><input></div><div><label>Email</label><input></div><span>{"name":"John","email":"john@example.com"}</span></form>'
    )
  })

  it('useState for grand child function', async () => {
    const GrandChild = () => {
      const [count, setCount] = useState(0)
      return (
        <>
          {count === 0 ? <p>Zero</p> : <span>Not Zero</span>}
          <button onClick={() => setCount(count + 1)}>+</button>
        </>
      )
    }
    const Child = () => {
      return <GrandChild />
    }
    const App = () => {
      const [show, setShow] = useState(false)
      return (
        <div>
          {show && <Child />}
          <button onClick={() => setShow(!show)}>toggle</button>
        </div>
      )
    }
    render(<App />, root)
    expect(root.innerHTML).toBe('<div><button>toggle</button></div>')
    root.querySelector('button')?.click()
    await Promise.resolve()
    expect(root.innerHTML).toBe('<div><p>Zero</p><button>+</button><button>toggle</button></div>')
    root.querySelector('button')?.click()
    await Promise.resolve()
    expect(root.innerHTML).toBe(
      '<div><span>Not Zero</span><button>+</button><button>toggle</button></div>'
    )
  })

  describe('className', () => {
    it('should convert to class attribute for intrinsic elements', () => {
      const App = <h1 className='h1'>Hello</h1>
      render(App, root)
      expect(root.innerHTML).toBe('<h1 class="h1">Hello</h1>')
    })

    it('should convert to class attribute for custom elements', () => {
      const App = <custom-element className='h1'>Hello</custom-element>
      render(App, root)
      expect(root.innerHTML).toBe('<custom-element class="h1">Hello</custom-element>')
    })

    it('should not convert to class attribute for custom components', () => {
      const App: FC<{ className: string }> = ({ className }) => (
        <div data-class-name={className}>Hello</div>
      )
      render(<App className='h1' />, root)
      expect(root.innerHTML).toBe('<div data-class-name="h1">Hello</div>')
    })
  })

  describe('memo', () => {
    it('simple', async () => {
      let renderCount = 0
      const Counter = ({ count }: { count: number }) => {
        renderCount++
        return (
          <div>
            <p>Count: {count}</p>
          </div>
        )
      }
      const MemoCounter = memo(Counter)
      const App = () => {
        const [count, setCount] = useState(0)
        return (
          <div>
            <MemoCounter count={Math.min(count, 1)} />
            <button onClick={() => setCount(count + 1)}>+</button>
          </div>
        )
      }
      const app = <App />
      render(app, root)
      expect(root.innerHTML).toBe('<div><div><p>Count: 0</p></div><button>+</button></div>')
      expect(renderCount).toBe(1)
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><div><p>Count: 1</p></div><button>+</button></div>')
      expect(renderCount).toBe(2)
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><div><p>Count: 1</p></div><button>+</button></div>')
      expect(renderCount).toBe(2)
    })

    it('useState', async () => {
      const Child = vi.fn(({ count }: { count: number }) => {
        const [count2, setCount2] = useState(0)
        return (
          <>
            <div>
              {count} : {count2}
            </div>
            <button id='child-button' onClick={() => setCount2(count2 + 1)}>
              Child +
            </button>
          </>
        )
      })
      const MemoChild = memo(Child)
      const App = () => {
        const [count, setCount] = useState(0)
        return (
          <>
            <button id='app-button' onClick={() => setCount(count + 1)}>
              App +
            </button>
            <MemoChild count={Math.floor(count / 2)} />
          </>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe(
        '<button id="app-button">App +</button><div>0 : 0</div><button id="child-button">Child +</button>'
      )
      root.querySelector<HTMLButtonElement>('button#app-button')?.click()
      await Promise.resolve()
      expect(Child).toBeCalledTimes(1)
      expect(root.innerHTML).toBe(
        '<button id="app-button">App +</button><div>0 : 0</div><button id="child-button">Child +</button>'
      )
      root.querySelector<HTMLButtonElement>('button#app-button')?.click()
      await Promise.resolve()
      expect(Child).toBeCalledTimes(2)
      expect(root.innerHTML).toBe(
        '<button id="app-button">App +</button><div>1 : 0</div><button id="child-button">Child +</button>'
      )
      root.querySelector<HTMLButtonElement>('button#child-button')?.click()
      await Promise.resolve()
      expect(Child).toBeCalledTimes(3)
      expect(root.innerHTML).toBe(
        '<button id="app-button">App +</button><div>1 : 1</div><button id="child-button">Child +</button>'
      )
    })

    // The react compiler generates code like the following for memoization.
    it('react compiler', async () => {
      let renderCount = 0
      const Counter = ({ count }: { count: number }) => {
        renderCount++
        return (
          <div>
            <p>Count: {count}</p>
          </div>
        )
      }

      const App = () => {
        const [cache] = useState<unknown[]>(() => [])
        const [count, setCount] = useState(0)
        const countForDisplay = Math.floor(count / 2)

        let localCounter
        if (cache[0] !== countForDisplay) {
          localCounter = <Counter count={countForDisplay} />
          cache[0] = countForDisplay
          cache[1] = localCounter
        } else {
          localCounter = cache[1]
        }

        return (
          <div>
            {localCounter}
            <button onClick={() => setCount(count + 1)}>+</button>
          </div>
        )
      }
      const app = <App />
      render(app, root)
      expect(root.innerHTML).toBe('<div><div><p>Count: 0</p></div><button>+</button></div>')
      expect(renderCount).toBe(1)
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><div><p>Count: 0</p></div><button>+</button></div>')
      expect(renderCount).toBe(1)
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><div><p>Count: 1</p></div><button>+</button></div>')
      expect(renderCount).toBe(2)
    })

    it('should not return memoized result when context is not changed', async () => {
      const Context = createContext<[number, (arg: number | ((value: number) => number)) => void]>([
        0,
        () => {},
      ])
      const Container: FC<{ children: Child }> = ({ children }) => {
        const [count, setCount] = useState(0)
        return <Context.Provider value={[count, setCount]}>{children}</Context.Provider>
      }
      const Content = () => {
        const [count, setCount] = useContext(Context)
        return (
          <>
            <span>{count}</span>
            <button onClick={() => setCount((c) => c + 1)}>+</button>
          </>
        )
      }
      const app = (
        <Container>
          <Content />
        </Container>
      )
      render(app, root)
      expect(root.innerHTML).toBe('<span>0</span><button>+</button>')
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<span>1</span><button>+</button>')
    })
  })

  describe('useRef', async () => {
    it('simple', async () => {
      const Input = ({ label, ref }: { label: string; ref: RefObject<HTMLInputElement> }) => {
        return (
          <div>
            <label>{label}</label>
            <input ref={ref} />
          </div>
        )
      }
      const Form = () => {
        const [values, setValues] = useState<{ [key: string]: string }>({})
        const nameRef = useRef<HTMLInputElement>(null)
        const emailRef = useRef<HTMLInputElement>(null)
        return (
          <form>
            <Input label='Name' ref={nameRef} />
            <Input label='Email' ref={emailRef} />
            <button
              onClick={(ev: Event) => {
                ev.preventDefault()
                setValues({
                  name: nameRef.current?.value || '',
                  email: emailRef.current?.value || '',
                })
              }}
            >
              serialize
            </button>
            <span>{JSON.stringify(values)}</span>
          </form>
        )
      }
      const app = <Form />
      render(app, root)
      expect(root.innerHTML).toBe(
        '<form><div><label>Name</label><input></div><div><label>Email</label><input></div><button>serialize</button><span>{}</span></form>'
      )
      const [nameInput, emailInput] = root.querySelectorAll('input')
      nameInput.value = 'John'
      emailInput.value = 'john@example.com'
      const [button] = root.querySelectorAll('button')
      button.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe(
        '<form><div><label>Name</label><input></div><div><label>Email</label><input></div><button>serialize</button><span>{"name":"John","email":"john@example.com"}</span></form>'
      )
    })

    it('update current', async () => {
      const App = () => {
        const [, setState] = useState(0)
        const ref = useRef<boolean>(false)
        return (
          <>
            <button
              onClick={() => {
                setState((c) => c + 1)
                ref.current = true
              }}
            >
              update
            </button>
            <span>{String(ref.current)}</span>
          </>
        )
      }
      const app = <App />
      render(app, root)
      expect(root.innerHTML).toBe('<button>update</button><span>false</span>')
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<button>update</button><span>true</span>')
    })
  })

  describe('useEffect', () => {
    it('simple', async () => {
      const Counter = () => {
        const [count, setCount] = useState(0)
        useEffect(() => {
          setCount(count + 1)
        }, [])
        return <div>{count}</div>
      }
      const app = <Counter />
      render(app, root)
      await new Promise((resolve) => setTimeout(resolve))
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div>1</div>')
    })

    it('multiple', async () => {
      const Counter = () => {
        const [count, setCount] = useState(0)
        useEffect(() => {
          setCount((c) => c + 1)
        }, [])
        useEffect(() => {
          setCount((c) => c + 1)
        }, [])
        return <div>{count}</div>
      }
      const app = <Counter />
      render(app, root)
      await new Promise((resolve) => setTimeout(resolve))
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div>2</div>')
    })

    it('cleanup', async () => {
      const Child = ({ parent }: { parent: RefObject<HTMLElement> }) => {
        useEffect(() => {
          return () => {
            parent.current?.setAttribute('data-cleanup', 'true')
          }
        }, [])
        return <div>Child</div>
      }
      const Parent = () => {
        const [show, setShow] = useState(true)
        const ref = useRef<HTMLElement>(null)
        return (
          <div ref={ref}>
            {show && <Child parent={ref} />}
            <button onClick={() => setShow(false)}>hide</button>
          </div>
        )
      }
      const app = <Parent />
      render(app, root)
      expect(root.innerHTML).toBe('<div><div>Child</div><button>hide</button></div>')
      await new Promise((resolve) => setTimeout(resolve))
      const [button] = root.querySelectorAll('button')
      button.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div data-cleanup="true"><button>hide</button></div>')
    })

    it('cleanup for deps', async () => {
      let effectCount = 0
      let cleanupCount = 0

      const App = () => {
        const [count, setCount] = useState(0)
        const [count2, setCount2] = useState(0)
        useEffect(() => {
          effectCount++
          return () => {
            cleanupCount++
          }
        }, [count])
        return (
          <div>
            <p>{count}</p>
            <p>{count2}</p>
            <button onClick={() => setCount(count + 1)}>+</button>
            <button onClick={() => setCount2(count2 + 1)}>+</button>
          </div>
        )
      }
      const app = <App />
      render(app, root)
      await new Promise((resolve) => setTimeout(resolve))
      expect(effectCount).toBe(1)
      expect(cleanupCount).toBe(0)
      root.querySelectorAll('button')[0].click() // count++
      await Promise.resolve()
      await new Promise((resolve) => setTimeout(resolve))
      expect(effectCount).toBe(2)
      expect(cleanupCount).toBe(1)
      root.querySelectorAll('button')[1].click() // count2++
      await Promise.resolve()
      expect(effectCount).toBe(2)
      expect(cleanupCount).toBe(1)
    })
  })

  describe('useLayoutEffect', () => {
    it('simple', async () => {
      const Counter = () => {
        const [count, setCount] = useState(0)
        useLayoutEffect(() => {
          setCount(count + 1)
        }, [])
        return <div>{count}</div>
      }
      const app = <Counter />
      render(app, root)
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div>1</div>')
    })

    it('multiple', async () => {
      const Counter = () => {
        const [count, setCount] = useState(0)
        useLayoutEffect(() => {
          setCount((c) => c + 1)
        }, [])
        useLayoutEffect(() => {
          setCount((c) => c + 1)
        }, [])
        return <div>{count}</div>
      }
      const app = <Counter />
      render(app, root)
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div>2</div>')
    })

    it('cleanup', async () => {
      const Child = ({ parent }: { parent: RefObject<HTMLElement> }) => {
        useLayoutEffect(() => {
          return () => {
            parent.current?.setAttribute('data-cleanup', 'true')
          }
        }, [])
        return <div>Child</div>
      }
      const Parent = () => {
        const [show, setShow] = useState(true)
        const ref = useRef<HTMLElement>(null)
        return (
          <div ref={ref}>
            {show && <Child parent={ref} />}
            <button onClick={() => setShow(false)}>hide</button>
          </div>
        )
      }
      const app = <Parent />
      render(app, root)
      expect(root.innerHTML).toBe('<div><div>Child</div><button>hide</button></div>')
      const [button] = root.querySelectorAll('button')
      button.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div data-cleanup="true"><button>hide</button></div>')
    })

    it('cleanup for deps', async () => {
      let effectCount = 0
      let cleanupCount = 0

      const App = () => {
        const [count, setCount] = useState(0)
        const [count2, setCount2] = useState(0)
        useLayoutEffect(() => {
          effectCount++
          return () => {
            cleanupCount++
          }
        }, [count])
        return (
          <div>
            <p>{count}</p>
            <p>{count2}</p>
            <button onClick={() => setCount(count + 1)}>+</button>
            <button onClick={() => setCount2(count2 + 1)}>+</button>
          </div>
        )
      }
      const app = <App />
      render(app, root)
      expect(effectCount).toBe(1)
      expect(cleanupCount).toBe(0)
      root.querySelectorAll('button')[0].click() // count++
      await Promise.resolve()
      expect(effectCount).toBe(2)
      expect(cleanupCount).toBe(1)
      root.querySelectorAll('button')[1].click() // count2++
      await Promise.resolve()
      expect(effectCount).toBe(2)
      expect(cleanupCount).toBe(1)
    })
  })

  describe('useInsertionEffect', () => {
    it('simple', async () => {
      const Counter = () => {
        const [count, setCount] = useState(0)
        useInsertionEffect(() => {
          setCount(count + 1)
        }, [])
        return <div>{count}</div>
      }
      const app = <Counter />
      render(app, root)
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div>1</div>')
    })

    it('multiple', async () => {
      const Counter = () => {
        const [count, setCount] = useState(0)
        useInsertionEffect(() => {
          setCount((c) => c + 1)
        }, [])
        useInsertionEffect(() => {
          setCount((c) => c + 1)
        }, [])
        return <div>{count}</div>
      }
      const app = <Counter />
      render(app, root)
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div>2</div>')
    })

    it('with useLayoutEffect', async () => {
      const Counter = () => {
        const [data, setData] = useState<string[]>([])
        useLayoutEffect(() => {
          setData((d) => [...d, 'useLayoutEffect'])
        }, [])
        useInsertionEffect(() => {
          setData((d) => [...d, 'useInsertionEffect'])
        }, [])
        return <div>{data.join(',')}</div>
      }
      const app = <Counter />
      render(app, root)
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div>useInsertionEffect,useLayoutEffect</div>')
    })

    it('cleanup', async () => {
      const Child = ({ parent }: { parent: RefObject<HTMLElement> }) => {
        useInsertionEffect(() => {
          return () => {
            parent.current?.setAttribute('data-cleanup', 'true')
          }
        }, [])
        return <div>Child</div>
      }
      const Parent = () => {
        const [show, setShow] = useState(true)
        const ref = useRef<HTMLElement>(null)
        return (
          <div ref={ref}>
            {show && <Child parent={ref} />}
            <button onClick={() => setShow(false)}>hide</button>
          </div>
        )
      }
      const app = <Parent />
      render(app, root)
      expect(root.innerHTML).toBe('<div><div>Child</div><button>hide</button></div>')
      const [button] = root.querySelectorAll('button')
      button.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div data-cleanup="true"><button>hide</button></div>')
    })

    it('cleanup for deps', async () => {
      let effectCount = 0
      let cleanupCount = 0

      const App = () => {
        const [count, setCount] = useState(0)
        const [count2, setCount2] = useState(0)
        useInsertionEffect(() => {
          effectCount++
          return () => {
            cleanupCount++
          }
        }, [count])
        return (
          <div>
            <p>{count}</p>
            <p>{count2}</p>
            <button onClick={() => setCount(count + 1)}>+</button>
            <button onClick={() => setCount2(count2 + 1)}>+</button>
          </div>
        )
      }
      const app = <App />
      render(app, root)
      expect(effectCount).toBe(1)
      expect(cleanupCount).toBe(0)
      root.querySelectorAll('button')[0].click() // count++
      await Promise.resolve()
      expect(effectCount).toBe(2)
      expect(cleanupCount).toBe(1)
      root.querySelectorAll('button')[1].click() // count2++
      await Promise.resolve()
      expect(effectCount).toBe(2)
      expect(cleanupCount).toBe(1)
    })
  })

  describe('useCallback', () => {
    it('deferent callbacks', async () => {
      const callbackSet = new Set<Function>()
      const Counter = () => {
        const [count, setCount] = useState(0)
        const increment = useCallback(() => {
          setCount(count + 1)
        }, [count])
        callbackSet.add(increment)
        return (
          <div>
            <p>{count}</p>
            <button onClick={increment}>+</button>
          </div>
        )
      }
      const app = <Counter />
      render(app, root)
      expect(root.innerHTML).toBe('<div><p>0</p><button>+</button></div>')
      const button = root.querySelector('button') as HTMLButtonElement
      button.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><p>1</p><button>+</button></div>')
      expect(callbackSet.size).toBe(2)
    })

    it('same callback', async () => {
      const callbackSet = new Set<Function>()
      const Counter = () => {
        const [count, setCount] = useState(0)
        const increment = useCallback(() => {
          setCount(count + 1)
        }, [count])
        callbackSet.add(increment)

        const [count2, setCount2] = useState(0)
        return (
          <div>
            <p>{count}</p>
            <button onClick={increment}>+</button>
            <p>{count2}</p>
            <button onClick={() => setCount2(count2 + 1)}>+</button>
          </div>
        )
      }
      const app = <Counter />
      render(app, root)
      expect(root.innerHTML).toBe('<div><p>0</p><button>+</button><p>0</p><button>+</button></div>')
      const [, button] = root.querySelectorAll('button')
      button.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><p>0</p><button>+</button><p>1</p><button>+</button></div>')
      expect(callbackSet.size).toBe(1)
    })

    it('deferent callbacks', async () => {
      const callbackSet = new Set<Function>()
      const Counter = () => {
        const [count, setCount] = useState(0)
        const double = useCallback((input: number): number => {
          return input * 2
        }, [])
        callbackSet.add(double)
        return (
          <div>
            <p>{double(count)}</p>
            <button onClick={() => setCount((c) => c + 1)}>+</button>
          </div>
        )
      }
      const app = <Counter />
      render(app, root)
      expect(root.innerHTML).toBe('<div><p>0</p><button>+</button></div>')
      const button = root.querySelector('button') as HTMLButtonElement
      button.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><p>2</p><button>+</button></div>')
      expect(callbackSet.size).toBe(1)
    })
  })

  describe('useMemo', () => {
    it('simple', async () => {
      let factoryCalled = 0
      const Counter = () => {
        const [count, setCount] = useState(0)
        const [count2, setCount2] = useState(0)
        const memo = useMemo(() => {
          factoryCalled++
          return count + 1
        }, [count])
        return (
          <div>
            <p>{count}</p>
            <p>{count2}</p>
            <p>{memo}</p>
            <button onClick={() => setCount(count + 1)}>+</button>
            <button onClick={() => setCount2(count2 + 1)}>+</button>
          </div>
        )
      }
      const app = <Counter />
      render(app, root)
      expect(root.innerHTML).toBe(
        '<div><p>0</p><p>0</p><p>1</p><button>+</button><button>+</button></div>'
      )
      expect(factoryCalled).toBe(1)
      root.querySelectorAll('button')[0].click()
      await Promise.resolve()
      expect(root.innerHTML).toBe(
        '<div><p>1</p><p>0</p><p>2</p><button>+</button><button>+</button></div>'
      )
      expect(factoryCalled).toBe(2)
      root.querySelectorAll('button')[1].click()
      await Promise.resolve()
      expect(root.innerHTML).toBe(
        '<div><p>1</p><p>1</p><p>2</p><button>+</button><button>+</button></div>'
      )
      expect(factoryCalled).toBe(2)
    })
  })

  describe('isValidElement', () => {
    it('valid', () => {
      expect(isValidElement(<div />)).toBe(true)
    })

    it('invalid', () => {
      expect(isValidElement({})).toBe(false)
    })
  })

  describe('createElement', () => {
    it('simple', async () => {
      const App = () => {
        const [count, setCount] = useState(0)
        return (
          <div>{createElement('p', { onClick: () => setCount(count + 1) }, String(count))}</div>
        )
      }
      const app = <App />
      render(app, root)
      expect(root.innerHTML).toBe('<div><p>0</p></div>')
      root.querySelector('p')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><p>1</p></div>')
    })

    it('title', async () => {
      const App = () => {
        return <div>{createElement('title', {}, 'Hello')}</div>
      }
      const app = <App />
      render(app, root)
      expect(document.head.innerHTML).toBe('<title>Hello</title>')
      expect(root.innerHTML).toBe('<div></div>')
    })
  })

  describe('dom-specific createElement', () => {
    it('simple', async () => {
      const App = () => {
        const [count, setCount] = useState(0)
        return <div>{createElementForDom('p', { onClick: () => setCount(count + 1) }, count)}</div>
      }
      const app = <App />
      render(app, root)
      expect(root.innerHTML).toBe('<div><p>0</p></div>')
      root.querySelector('p')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><p>1</p></div>')
    })

    it('title', async () => {
      const App = () => {
        return <div>{createElementForDom('title', {}, 'Hello')}</div>
      }
      const app = <App />
      render(app, root)
      expect(document.head.innerHTML).toBe('<title>Hello</title>')
      expect(root.innerHTML).toBe('<div></div>')
    })
  })

  describe('cloneElement', () => {
    it('simple', async () => {
      const App = () => {
        const [count, setCount] = useState(0)
        return <div>{cloneElement(<p>{count}</p>, { onClick: () => setCount(count + 1) })}</div>
      }
      const app = <App />
      render(app, root)
      expect(root.innerHTML).toBe('<div><p>0</p></div>')
      root.querySelector('p')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><p>1</p></div>')
    })
  })

  describe('dom-specific cloneElement', () => {
    it('simple', async () => {
      const App = () => {
        const [count, setCount] = useState(0)
        return (
          <div>{cloneElementForDom(<p>{count}</p>, { onClick: () => setCount(count + 1) })}</div>
        )
      }
      const app = <App />
      render(app, root)
      expect(root.innerHTML).toBe('<div><p>0</p></div>')
      root.querySelector('p')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><p>1</p></div>')
    })
  })

  describe('flushSync', () => {
    it('simple', async () => {
      const SubApp = ({ id }: { id: string }) => {
        const [count, setCount] = useState(0)
        return (
          <div id={id}>
            <p>{count}</p>
            <button onClick={() => setCount(count + 1)}>+</button>
          </div>
        )
      }
      const App = () => {
        return (
          <div>
            <SubApp id='a' />
            <SubApp id='b' />
          </div>
        )
      }
      const app = <App />
      render(app, root)
      expect(root.innerHTML).toBe(
        '<div><div id="a"><p>0</p><button>+</button></div><div id="b"><p>0</p><button>+</button></div></div>'
      )
      root.querySelector<HTMLButtonElement>('#b button')?.click()
      flushSync(() => {
        root.querySelector<HTMLButtonElement>('#a button')?.click()
      })
      expect(root.innerHTML).toBe(
        '<div><div id="a"><p>1</p><button>+</button></div><div id="b"><p>0</p><button>+</button></div></div>'
      )
      await Promise.resolve()
      expect(root.innerHTML).toBe(
        '<div><div id="a"><p>1</p><button>+</button></div><div id="b"><p>1</p><button>+</button></div></div>'
      )
    })
  })

  describe('createPortal', () => {
    it('simple', async () => {
      const App = () => {
        const [count, setCount] = useState(0)
        return (
          <div>
            <button onClick={() => setCount(count + 1)}>+</button>
            {count <= 1 && createPortal(<p>{count}</p>, document.body)}
          </div>
        )
      }
      const app = <App />
      render(app, root)
      expect(root.innerHTML).toBe('<div><button>+</button></div>')
      expect(document.body.innerHTML).toBe(
        '<div id="root"><div><button>+</button></div></div><p>0</p>'
      )
      document.body.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><button>+</button></div>')
      expect(document.body.innerHTML).toBe(
        '<div id="root"><div><button>+</button></div></div><p>1</p>'
      )
      document.body.querySelector('button')?.click()
      await Promise.resolve()
      expect(document.body.innerHTML).toBe('<div id="root"><div><button>+</button></div></div>')
    })

    it('update', async () => {
      const App = () => {
        const [count, setCount] = useState(0)
        return (
          <div>
            {createPortal(<p>{count}</p>, document.body)}
            <button onClick={() => setCount(count + 1)}>+</button>
            <div>
              <p>{count}</p>
            </div>
          </div>
        )
      }
      const app = <App />
      render(app, root)
      expect(root.innerHTML).toBe('<div><button>+</button><div><p>0</p></div></div>')
      expect(document.body.innerHTML).toBe(
        '<div id="root"><div><button>+</button><div><p>0</p></div></div></div><p>0</p>'
      )

      const createElementSpy = vi.spyOn(dom.window.document, 'createElement')

      document.body.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><button>+</button><div><p>1</p></div></div>')
      expect(document.body.innerHTML).toBe(
        '<div id="root"><div><button>+</button><div><p>1</p></div></div></div><p>1</p>'
      )
      document.body.querySelector('button')?.click()
      await Promise.resolve()
      expect(document.body.innerHTML).toBe(
        '<div id="root"><div><button>+</button><div><p>2</p></div></div></div><p>2</p>'
      )

      expect(createElementSpy).not.toHaveBeenCalled()
    })
  })

  describe('SVG', () => {
    it('simple', () => {
      const App = () => {
        return (
          <svg>
            <circle cx='50' cy='50' r='40' stroke='black' stroke-width='3' fill='red' />
          </svg>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe(
        '<svg><circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red"></circle></svg>'
      )
    })

    it('title element', () => {
      const App = () => {
        return (
          <>
            <title>Document Title</title>
            <svg>
              <title>SVG Title</title>
            </svg>
          </>
        )
      }
      render(<App />, root)
      expect(document.head.innerHTML).toBe('<title>Document Title</title>')
      expect(root.innerHTML).toBe('<svg><title>SVG Title</title></svg>')
      expect(document.querySelector('title')).toBeInstanceOf(dom.window.HTMLTitleElement)
      expect(document.querySelector('svg title')).toBeInstanceOf(dom.window.SVGTitleElement)
    })

    describe('attribute', () => {
      describe('camelCase', () => {
        test.each`
          key
          ${'attributeName'}
          ${'baseFrequency'}
          ${'calcMode'}
          ${'clipPathUnits'}
          ${'diffuseConstant'}
          ${'edgeMode'}
          ${'filterUnits'}
          ${'gradientTransform'}
          ${'gradientUnits'}
          ${'kernelMatrix'}
          ${'kernelUnitLength'}
          ${'keyPoints'}
          ${'keySplines'}
          ${'keyTimes'}
          ${'lengthAdjust'}
          ${'limitingConeAngle'}
          ${'markerHeight'}
          ${'markerUnits'}
          ${'markerWidth'}
          ${'maskContentUnits'}
          ${'maskUnits'}
          ${'numOctaves'}
          ${'pathLength'}
          ${'patternContentUnits'}
          ${'patternTransform'}
          ${'patternUnits'}
          ${'pointsAtX'}
          ${'pointsAtY'}
          ${'pointsAtZ'}
          ${'preserveAlpha'}
          ${'preserveAspectRatio'}
          ${'primitiveUnits'}
          ${'refX'}
          ${'refY'}
          ${'repeatCount'}
          ${'repeatDur'}
          ${'specularConstant'}
          ${'specularExponent'}
          ${'spreadMethod'}
          ${'startOffset'}
          ${'stdDeviation'}
          ${'stitchTiles'}
          ${'surfaceScale'}
          ${'crossorigin'}
          ${'systemLanguage'}
          ${'tableValues'}
          ${'targetX'}
          ${'targetY'}
          ${'textLength'}
          ${'viewBox'}
          ${'xChannelSelector'}
          ${'yChannelSelector'}
        `('$key', ({ key }) => {
          const App = () => {
            return (
              <svg>
                <g {...{ [key]: 'test' }} />
              </svg>
            )
          }
          render(<App />, root)
          expect(root.innerHTML).toBe(`<svg><g ${key}="test"></g></svg>`)
        })
      })

      describe('kebab-case', () => {
        test.each`
          key
          ${'alignmentBaseline'}
          ${'baselineShift'}
          ${'clipPath'}
          ${'clipRule'}
          ${'colorInterpolation'}
          ${'colorInterpolationFilters'}
          ${'dominantBaseline'}
          ${'fillOpacity'}
          ${'fillRule'}
          ${'floodColor'}
          ${'floodOpacity'}
          ${'fontFamily'}
          ${'fontSize'}
          ${'fontSizeAdjust'}
          ${'fontStretch'}
          ${'fontStyle'}
          ${'fontVariant'}
          ${'fontWeight'}
          ${'imageRendering'}
          ${'letterSpacing'}
          ${'lightingColor'}
          ${'markerEnd'}
          ${'markerMid'}
          ${'markerStart'}
          ${'overlinePosition'}
          ${'overlineThickness'}
          ${'paintOrder'}
          ${'pointerEvents'}
          ${'shapeRendering'}
          ${'stopColor'}
          ${'stopOpacity'}
          ${'strikethroughPosition'}
          ${'strikethroughThickness'}
          ${'strokeDasharray'}
          ${'strokeDashoffset'}
          ${'strokeLinecap'}
          ${'strokeLinejoin'}
          ${'strokeMiterlimit'}
          ${'strokeOpacity'}
          ${'strokeWidth'}
          ${'textAnchor'}
          ${'textDecoration'}
          ${'textRendering'}
          ${'transformOrigin'}
          ${'underlinePosition'}
          ${'underlineThickness'}
          ${'unicodeBidi'}
          ${'vectorEffect'}
          ${'wordSpacing'}
          ${'writingMode'}
        `('$key', ({ key }) => {
          const App = () => {
            return (
              <svg>
                <g {...{ [key]: 'test' }} />
              </svg>
            )
          }
          render(<App />, root)
          expect(root.innerHTML).toBe(
            `<svg><g ${key.replace(/([A-Z])/g, '-$1').toLowerCase()}="test"></g></svg>`
          )
        })
      })

      describe('data-*', () => {
        test.each`
          key
          ${'data-foo'}
          ${'data-foo-bar'}
          ${'data-fooBar'}
        `('$key', ({ key }) => {
          const App = () => {
            return (
              <svg>
                <g {...{ [key]: 'test' }} />
              </svg>
            )
          }
          render(<App />, root)
          expect(root.innerHTML).toBe(`<svg><g ${key}="test"></g></svg>`)
        })
      })
    })
  })

  describe('MathML', () => {
    it('simple', () => {
      const createElementSpy = vi.spyOn(dom.window.document, 'createElement')
      const createElementNSSpy = vi.spyOn(dom.window.document, 'createElementNS')

      const App = () => {
        return (
          <math>
            <mrow>
              <mn>1</mn>
            </mrow>
          </math>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<math><mrow><mn>1</mn></mrow></math>')

      expect(createElementSpy).not.toHaveBeenCalled()
      expect(createElementNSSpy).toHaveBeenCalledWith('http://www.w3.org/1998/Math/MathML', 'math')
      expect(createElementNSSpy).toHaveBeenCalledWith('http://www.w3.org/1998/Math/MathML', 'mrow')
    })
  })
})

describe('jsx', () => {
  it('exported as an alias of createElement', () => {
    expect(jsx).toBeDefined()
    expect(jsx('div', {}, 'Hello')).toBeInstanceOf(Object)
  })
})

describe('version', () => {
  it('should be defined with semantic versioning format', () => {
    expect(version).toMatch(/^\d+\.\d+\.\d+-hono-jsx$/)
  })
})

describe('default export', () => {
  ;[
    'version',
    'memo',
    'Fragment',
    'isValidElement',
    'createElement',
    'cloneElement',
    'ErrorBoundary',
    'createContext',
    'useContext',
    'useState',
    'useEffect',
    'useRef',
    'useCallback',
    'useReducer',
    'useDebugValue',
    'createRef',
    'forwardRef',
    'useImperativeHandle',
    'useSyncExternalStore',
    'use',
    'startTransition',
    'useTransition',
    'useDeferredValue',
    'startViewTransition',
    'useViewTransition',
    'useActionState',
    'useFormStatus',
    'useOptimistic',
    'useMemo',
    'useLayoutEffect',
    'Suspense',
    'Fragment',
    'flushSync',
    'createPortal',
    'StrictMode',
  ].forEach((key) => {
    it(key, () => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      expect((DefaultExport as any)[key]).toBeDefined()
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/dom/index.ts
```typescript
/**
 * @module
 * This module provides APIs for `hono/jsx/dom`.
 */

import { isValidElement, reactAPICompatVersion, shallowEqual } from '../base'
import type { Child, DOMAttributes, JSX, JSXNode, Props, FC, MemorableFC } from '../base'
import { Children } from '../children'
import { DOM_MEMO } from '../constants'
import { useContext } from '../context'
import {
  createRef,
  forwardRef,
  startTransition,
  startViewTransition,
  use,
  useCallback,
  useDebugValue,
  useDeferredValue,
  useEffect,
  useId,
  useImperativeHandle,
  useInsertionEffect,
  useLayoutEffect,
  useMemo,
  useReducer,
  useRef,
  useState,
  useSyncExternalStore,
  useTransition,
  useViewTransition,
} from '../hooks'
import { ErrorBoundary, Suspense } from './components'
import { createContext } from './context'
import { useActionState, useFormStatus, useOptimistic } from './hooks'
import { Fragment, jsx } from './jsx-runtime'
import { createPortal, flushSync } from './render'

export { render } from './render'

const createElement = (
  tag: string | ((props: Props) => JSXNode),
  props: Props | null,
  ...children: Child[]
): JSXNode => {
  const jsxProps: Props = props ? { ...props } : {}
  if (children.length) {
    jsxProps.children = children.length === 1 ? children[0] : children
  }

  let key = undefined
  if ('key' in jsxProps) {
    key = jsxProps.key
    delete jsxProps.key
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return jsx(tag, jsxProps, key) as any
}

const cloneElement = <T extends JSXNode | JSX.Element>(
  element: T,
  props: Props,
  ...children: Child[]
): T => {
  return jsx(
    (element as JSXNode).tag,
    {
      ...(element as JSXNode).props,
      ...props,
      children: children.length ? children : (element as JSXNode).props.children,
    },
    (element as JSXNode).key
  ) as T
}

const memo = <T>(
  component: FC<T>,
  propsAreEqual: (prevProps: Readonly<T>, nextProps: Readonly<T>) => boolean = shallowEqual
): FC<T> => {
  const wrapper = ((props: T) => component(props)) as MemorableFC<T>
  wrapper[DOM_MEMO] = propsAreEqual
  return wrapper as FC<T>
}

export {
  reactAPICompatVersion as version,
  createElement as jsx,
  useState,
  useEffect,
  useRef,
  useCallback,
  use,
  startTransition,
  useTransition,
  useDeferredValue,
  startViewTransition,
  useViewTransition,
  useMemo,
  useLayoutEffect,
  useInsertionEffect,
  useReducer,
  useId,
  useDebugValue,
  createRef,
  forwardRef,
  useImperativeHandle,
  useSyncExternalStore,
  useFormStatus,
  useActionState,
  useOptimistic,
  Suspense,
  ErrorBoundary,
  createContext,
  useContext,
  memo,
  isValidElement,
  createElement,
  cloneElement,
  Children,
  Fragment,
  Fragment as StrictMode,
  DOMAttributes,
  flushSync,
  createPortal,
}

export default {
  version: reactAPICompatVersion,
  useState,
  useEffect,
  useRef,
  useCallback,
  use,
  startTransition,
  useTransition,
  useDeferredValue,
  startViewTransition,
  useViewTransition,
  useMemo,
  useLayoutEffect,
  useInsertionEffect,
  useReducer,
  useId,
  useDebugValue,
  createRef,
  forwardRef,
  useImperativeHandle,
  useSyncExternalStore,
  useFormStatus,
  useActionState,
  useOptimistic,
  Suspense,
  ErrorBoundary,
  createContext,
  useContext,
  memo,
  isValidElement,
  createElement,
  cloneElement,
  Children,
  Fragment,
  StrictMode: Fragment,
  flushSync,
  createPortal,
}

export type { Context } from '../context'

export type * from '../types'

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/dom/jsx-dev-runtime.ts
```typescript
/**
 * @module
 * This module provides the `hono/jsx/dom` dev runtime.
 */

import type { JSXNode, Props } from '../base'
import * as intrinsicElementTags from './intrinsic-element/components'

export const jsxDEV = (tag: string | Function, props: Props, key?: string): JSXNode => {
  if (typeof tag === 'string' && intrinsicElementTags[tag as keyof typeof intrinsicElementTags]) {
    tag = intrinsicElementTags[tag as keyof typeof intrinsicElementTags]
  }
  return {
    tag,
    type: tag,
    props,
    key,
    ref: props.ref,
  } as JSXNode
}

export const Fragment = (props: Record<string, unknown>): JSXNode => jsxDEV('', props, undefined)

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/dom/jsx-runtime.ts
```typescript
/**
 * @module
 * This module provides the `hono/jsx/dom` runtime.
 */

export { jsxDEV as jsx, Fragment } from './jsx-dev-runtime'
export { jsxDEV as jsxs } from './jsx-dev-runtime'

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/dom/render.ts
```typescript
import type { Child, FC, JSXNode, Props, MemorableFC } from '../base'
import { toArray } from '../children'
import {
  DOM_ERROR_HANDLER,
  DOM_INTERNAL_TAG,
  DOM_MEMO,
  DOM_RENDERER,
  DOM_STASH,
} from '../constants'
import type { Context as JSXContext } from '../context'
import { globalContexts as globalJSXContexts, useContext } from '../context'
import type { EffectData } from '../hooks'
import { STASH_EFFECT } from '../hooks'
import { normalizeIntrinsicElementKey, styleObjectForEach } from '../utils'
import { createContext } from './context' // import dom-specific versions

const HONO_PORTAL_ELEMENT = '_hp'

const eventAliasMap: Record<string, string> = {
  Change: 'Input',
  DoubleClick: 'DblClick',
} as const

const nameSpaceMap: Record<string, string> = {
  svg: '2000/svg',
  math: '1998/Math/MathML',
} as const

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type HasRenderToDom = FC<any> & { [DOM_RENDERER]: FC<any> }
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type ErrorHandler = (error: any, retry: () => void) => Child | undefined

type Container = HTMLElement | DocumentFragment
type LocalJSXContexts = [JSXContext<unknown>, unknown][] | undefined
type SupportedElement = HTMLElement | SVGElement | MathMLElement
export type PreserveNodeType =
  | 1 // preserve only self
  | 2 // preserve self and children

export type NodeObject = {
  pP: Props | undefined // previous props
  nN: Node | undefined // next node
  vC: Node[] // virtual dom children
  pC?: Node[] // previous virtual dom children
  vR: Node[] // virtual dom children to remove
  n?: string // namespace
  f?: boolean // force build
  s?: boolean // skip build and apply
  c: Container | undefined // container
  e: SupportedElement | Text | undefined // rendered element
  p?: PreserveNodeType // preserve HTMLElement if it will be unmounted
  a?: boolean // cancel apply() if true
  o?: NodeObject // original node
  [DOM_STASH]:
    | [
        number, // current hook index
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        any[][], // stash for hooks
        LocalJSXContexts, // context
        [Context, Function, NodeObject] // [context, error handler, node] for closest error boundary or suspense
      ]
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    | [number, any[][]]
} & JSXNode
type NodeString = {
  t: string // text content
  d: boolean // is dirty
  s?: boolean // skip build and apply
} & {
  e?: Text
  // like a NodeObject
  vC: undefined
  nN: undefined
  p?: true
  // from JSXNode
  key: undefined
  tag: undefined
}
export type Node = NodeString | NodeObject

export type PendingType =
  | 0 // no pending
  | 1 // global
  | 2 // hook
export type UpdateHook = (
  context: Context,
  node: Node,
  cb: (context: Context) => void
) => Promise<void>
export type Context =
  | [
      PendingType, // PendingType
      boolean, // got an error
      UpdateHook, // update hook
      boolean, // is in view transition
      boolean, // is in top level render
      [Context, Function, NodeObject][] //  [context, error handler, node] stack for this context
    ]
  | [PendingType, boolean, UpdateHook, boolean]
  | [PendingType, boolean, UpdateHook]
  | [PendingType, boolean]
  | [PendingType]
  | []

export const buildDataStack: [Context, Node][] = []

const refCleanupMap: WeakMap<Element, () => void> = new WeakMap()

let nameSpaceContext: JSXContext<string> | undefined = undefined
export const getNameSpaceContext = () => nameSpaceContext

const isNodeString = (node: Node): node is NodeString => 't' in (node as NodeString)

const eventCache: Record<string, [string, boolean]> = {
  // pre-define events that are used very frequently
  onClick: ['click', false],
}
const getEventSpec = (key: string): [string, boolean] | undefined => {
  if (!key.startsWith('on')) {
    return undefined
  }
  if (eventCache[key]) {
    return eventCache[key]
  }

  const match = key.match(/^on([A-Z][a-zA-Z]+?(?:PointerCapture)?)(Capture)?$/)
  if (match) {
    const [, eventName, capture] = match
    return (eventCache[key] = [(eventAliasMap[eventName] || eventName).toLowerCase(), !!capture])
  }
  return undefined
}

const toAttributeName = (element: SupportedElement, key: string): string =>
  nameSpaceContext &&
  element instanceof SVGElement &&
  /[A-Z]/.test(key) &&
  (key in element.style || // Presentation attributes are findable in style object. "clip-path", "font-size", "stroke-width", etc.
    key.match(/^(?:o|pai|str|u|ve)/)) // Other un-deprecated kebab-case attributes. "overline-position", "paint-order", "strikethrough-position", etc.
    ? key.replace(/([A-Z])/g, '-$1').toLowerCase()
    : key

const applyProps = (
  container: SupportedElement,
  attributes: Props,
  oldAttributes?: Props
): void => {
  attributes ||= {}
  for (let key in attributes) {
    const value = attributes[key]
    if (key !== 'children' && (!oldAttributes || oldAttributes[key] !== value)) {
      key = normalizeIntrinsicElementKey(key)
      const eventSpec = getEventSpec(key)
      if (eventSpec) {
        if (oldAttributes?.[key] !== value) {
          if (oldAttributes) {
            container.removeEventListener(eventSpec[0], oldAttributes[key], eventSpec[1])
          }
          if (value != null) {
            if (typeof value !== 'function') {
              throw new Error(`Event handler for "${key}" is not a function`)
            }
            container.addEventListener(eventSpec[0], value, eventSpec[1])
          }
        }
      } else if (key === 'dangerouslySetInnerHTML' && value) {
        container.innerHTML = value.__html
      } else if (key === 'ref') {
        let cleanup
        if (typeof value === 'function') {
          cleanup = value(container) || (() => value(null))
        } else if (value && 'current' in value) {
          value.current = container
          cleanup = () => (value.current = null)
        }
        refCleanupMap.set(container, cleanup)
      } else if (key === 'style') {
        const style = container.style
        if (typeof value === 'string') {
          style.cssText = value
        } else {
          style.cssText = ''
          if (value != null) {
            styleObjectForEach(value, style.setProperty.bind(style))
          }
        }
      } else {
        if (key === 'value') {
          const nodeName = container.nodeName
          if (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || nodeName === 'SELECT') {
            ;(container as unknown as HTMLInputElement).value =
              value === null || value === undefined || value === false ? null : value

            if (nodeName === 'TEXTAREA') {
              container.textContent = value
              continue
            } else if (nodeName === 'SELECT') {
              if ((container as unknown as HTMLSelectElement).selectedIndex === -1) {
                ;(container as unknown as HTMLSelectElement).selectedIndex = 0
              }
              continue
            }
          }
        } else if (
          (key === 'checked' && container.nodeName === 'INPUT') ||
          (key === 'selected' && container.nodeName === 'OPTION')
        ) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          ;(container as any)[key] = value
        }

        const k = toAttributeName(container, key)

        if (value === null || value === undefined || value === false) {
          container.removeAttribute(k)
        } else if (value === true) {
          container.setAttribute(k, '')
        } else if (typeof value === 'string' || typeof value === 'number') {
          container.setAttribute(k, value as string)
        } else {
          container.setAttribute(k, value.toString())
        }
      }
    }
  }
  if (oldAttributes) {
    for (let key in oldAttributes) {
      const value = oldAttributes[key]
      if (key !== 'children' && !(key in attributes)) {
        key = normalizeIntrinsicElementKey(key)
        const eventSpec = getEventSpec(key)
        if (eventSpec) {
          container.removeEventListener(eventSpec[0], value, eventSpec[1])
        } else if (key === 'ref') {
          refCleanupMap.get(container)?.()
        } else {
          container.removeAttribute(toAttributeName(container, key))
        }
      }
    }
  }
}

const invokeTag = (context: Context, node: NodeObject): Child[] => {
  node[DOM_STASH][0] = 0
  buildDataStack.push([context, node])
  const func = (node.tag as HasRenderToDom)[DOM_RENDERER] || node.tag
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const props = (func as any).defaultProps
    ? {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        ...(func as any).defaultProps,
        ...node.props,
      }
    : node.props
  try {
    return [func.call(null, props)]
  } finally {
    buildDataStack.pop()
  }
}

const getNextChildren = (
  node: NodeObject,
  container: Container,
  nextChildren: Node[],
  childrenToRemove: Node[],
  callbacks: EffectData[]
): void => {
  if (node.vR?.length) {
    childrenToRemove.push(...node.vR)
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    delete (node as any).vR
  }
  if (typeof node.tag === 'function') {
    node[DOM_STASH][1][STASH_EFFECT]?.forEach((data: EffectData) => callbacks.push(data))
  }
  node.vC.forEach((child) => {
    if (isNodeString(child)) {
      nextChildren.push(child)
    } else {
      if (typeof child.tag === 'function' || child.tag === '') {
        child.c = container
        const currentNextChildrenIndex = nextChildren.length
        getNextChildren(child, container, nextChildren, childrenToRemove, callbacks)
        if (child.s) {
          for (let i = currentNextChildrenIndex; i < nextChildren.length; i++) {
            nextChildren[i].s = true
          }
          child.s = false
        }
      } else {
        nextChildren.push(child)
        if (child.vR?.length) {
          childrenToRemove.push(...child.vR)
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          delete (child as any).vR
        }
      }
    }
  })
}

const findInsertBefore = (node: Node | undefined): SupportedElement | Text | null => {
  for (; ; node = node.tag === HONO_PORTAL_ELEMENT || !node.vC || !node.pP ? node.nN : node.vC[0]) {
    if (!node) {
      return null
    }
    if (node.tag !== HONO_PORTAL_ELEMENT && node.e) {
      return node.e
    }
  }
}

const removeNode = (node: Node): void => {
  if (!isNodeString(node)) {
    node[DOM_STASH]?.[1][STASH_EFFECT]?.forEach((data: EffectData) => data[2]?.())

    refCleanupMap.get(node.e as Element)?.()
    if (node.p === 2) {
      node.vC?.forEach((n) => (n.p = 2))
    }
    node.vC?.forEach(removeNode)
  }
  if (!node.p) {
    node.e?.remove()
    delete node.e
  }
  if (typeof node.tag === 'function') {
    updateMap.delete(node)
    fallbackUpdateFnArrayMap.delete(node)
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    delete (node as any)[DOM_STASH][3] // delete explicitly for avoid circular reference
    node.a = true
  }
}

const apply = (node: NodeObject, container: Container, isNew: boolean): void => {
  node.c = container
  applyNodeObject(node, container, isNew)
}

const findChildNodeIndex = (
  childNodes: NodeListOf<ChildNode>,
  child: ChildNode | null | undefined
): number | undefined => {
  if (!child) {
    return
  }

  for (let i = 0, len = childNodes.length; i < len; i++) {
    if (childNodes[i] === child) {
      return i
    }
  }

  return
}

const cancelBuild: symbol = Symbol()
const applyNodeObject = (node: NodeObject, container: Container, isNew: boolean): void => {
  const next: Node[] = []
  const remove: Node[] = []
  const callbacks: EffectData[] = []
  getNextChildren(node, container, next, remove, callbacks)
  remove.forEach(removeNode)

  const childNodes = (isNew ? undefined : container.childNodes) as NodeListOf<ChildNode>
  let offset: number
  let insertBeforeNode: ChildNode | null = null
  if (isNew) {
    offset = -1
  } else if (!childNodes.length) {
    offset = 0
  } else {
    const offsetByNextNode = findChildNodeIndex(childNodes, findInsertBefore(node.nN))
    if (offsetByNextNode !== undefined) {
      insertBeforeNode = childNodes[offsetByNextNode]
      offset = offsetByNextNode
    } else {
      offset =
        findChildNodeIndex(childNodes, next.find((n) => n.tag !== HONO_PORTAL_ELEMENT && n.e)?.e) ??
        -1
    }

    if (offset === -1) {
      isNew = true
    }
  }

  for (let i = 0, len = next.length; i < len; i++, offset++) {
    const child = next[i]

    let el: SupportedElement | Text
    if (child.s && child.e) {
      el = child.e
      child.s = false
    } else {
      const isNewLocal = isNew || !child.e
      if (isNodeString(child)) {
        if (child.e && child.d) {
          child.e.textContent = child.t
        }
        child.d = false
        el = child.e ||= document.createTextNode(child.t)
      } else {
        el = child.e ||= child.n
          ? (document.createElementNS(child.n, child.tag as string) as SVGElement | MathMLElement)
          : document.createElement(child.tag as string)
        applyProps(el as HTMLElement, child.props, child.pP)
        applyNodeObject(child, el as HTMLElement, isNewLocal)
      }
    }
    if (child.tag === HONO_PORTAL_ELEMENT) {
      offset--
    } else if (isNew) {
      if (!el.parentNode) {
        container.appendChild(el)
      }
    } else if (childNodes[offset] !== el && childNodes[offset - 1] !== el) {
      if (childNodes[offset + 1] === el) {
        // Move extra elements to the back of the container. This is to be done efficiently when elements are swapped.
        container.appendChild(childNodes[offset])
      } else {
        container.insertBefore(el, insertBeforeNode || childNodes[offset] || null)
      }
    }
  }
  if (node.pP) {
    delete node.pP
  }
  if (callbacks.length) {
    const useLayoutEffectCbs: Array<() => void> = []
    const useEffectCbs: Array<() => void> = []
    callbacks.forEach(([, useLayoutEffectCb, , useEffectCb, useInsertionEffectCb]) => {
      if (useLayoutEffectCb) {
        useLayoutEffectCbs.push(useLayoutEffectCb)
      }
      if (useEffectCb) {
        useEffectCbs.push(useEffectCb)
      }
      useInsertionEffectCb?.() // invoke useInsertionEffect callbacks
    })
    useLayoutEffectCbs.forEach((cb) => cb()) // invoke useLayoutEffect callbacks
    if (useEffectCbs.length) {
      requestAnimationFrame(() => {
        useEffectCbs.forEach((cb) => cb()) // invoke useEffect callbacks
      })
    }
  }
}

const isSameContext = (
  oldContexts: LocalJSXContexts,
  newContexts: NonNullable<LocalJSXContexts>
): boolean =>
  !!(
    oldContexts &&
    oldContexts.length === newContexts.length &&
    oldContexts.every((ctx, i) => ctx[1] === newContexts[i][1])
  )

const fallbackUpdateFnArrayMap: WeakMap<
  NodeObject,
  Array<() => Promise<NodeObject | undefined>>
> = new WeakMap<NodeObject, Array<() => Promise<NodeObject | undefined>>>()
export const build = (context: Context, node: NodeObject, children?: Child[]): void => {
  const buildWithPreviousChildren = !children && node.pC
  if (children) {
    node.pC ||= node.vC
  }

  let foundErrorHandler: ErrorHandler | undefined
  try {
    children ||=
      typeof node.tag == 'function' ? invokeTag(context, node) : toArray(node.props.children)
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if ((children[0] as JSXNode)?.tag === '' && (children[0] as any)[DOM_ERROR_HANDLER]) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      foundErrorHandler = (children[0] as any)[DOM_ERROR_HANDLER] as ErrorHandler
      context[5]!.push([context, foundErrorHandler, node])
    }
    const oldVChildren: Node[] | undefined = buildWithPreviousChildren
      ? [...(node.pC as Node[])]
      : node.vC
      ? [...node.vC]
      : undefined
    const vChildren: Node[] = []
    let prevNode: Node | undefined
    for (let i = 0; i < children.length; i++) {
      if (Array.isArray(children[i])) {
        children.splice(i, 1, ...(children[i] as Child[]).flat())
      }
      let child = buildNode(children[i])
      if (child) {
        if (
          typeof child.tag === 'function' &&
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          !(child.tag as any)[DOM_INTERNAL_TAG]
        ) {
          if (globalJSXContexts.length > 0) {
            child[DOM_STASH][2] = globalJSXContexts.map((c) => [c, c.values.at(-1)])
          }
          if (context[5]?.length) {
            child[DOM_STASH][3] = context[5].at(-1) as [Context, ErrorHandler, NodeObject]
          }
        }

        let oldChild: NodeObject | undefined
        if (oldVChildren && oldVChildren.length) {
          const i = oldVChildren.findIndex(
            isNodeString(child)
              ? (c) => isNodeString(c)
              : child.key !== undefined
              ? (c) => c.key === (child as Node).key && c.tag === (child as Node).tag
              : (c) => c.tag === (child as Node).tag
          )

          if (i !== -1) {
            oldChild = oldVChildren[i] as NodeObject
            oldVChildren.splice(i, 1)
          }
        }

        if (oldChild) {
          if (isNodeString(child)) {
            if ((oldChild as unknown as NodeString).t !== child.t) {
              ;(oldChild as unknown as NodeString).t = child.t // update text content
              ;(oldChild as unknown as NodeString).d = true
            }
            child = oldChild
          } else {
            const pP = (oldChild.pP = oldChild.props)
            oldChild.props = child.props
            oldChild.f ||= child.f || node.f
            if (typeof child.tag === 'function') {
              const oldContexts = oldChild[DOM_STASH][2]
              oldChild[DOM_STASH][2] = child[DOM_STASH][2] || []
              oldChild[DOM_STASH][3] = child[DOM_STASH][3]

              if (
                !oldChild.f &&
                ((oldChild.o || oldChild) === child.o || // The code generated by the react compiler is memoized under this condition.
                  (oldChild.tag as MemorableFC<unknown>)[DOM_MEMO]?.(pP, oldChild.props)) && // The `memo` function is memoized under this condition.
                isSameContext(oldContexts, oldChild[DOM_STASH][2])
              ) {
                oldChild.s = true
              }
            }
            child = oldChild
          }
        } else if (!isNodeString(child) && nameSpaceContext) {
          const ns = useContext(nameSpaceContext)
          if (ns) {
            child.n = ns
          }
        }

        if (!isNodeString(child) && !child.s) {
          build(context, child)
          delete child.f
        }
        vChildren.push(child)

        if (prevNode && !prevNode.s && !child.s) {
          for (let p = prevNode; p && !isNodeString(p); p = p.vC?.at(-1) as NodeObject) {
            p.nN = child
          }
        }
        prevNode = child
      }
    }
    node.vR = buildWithPreviousChildren ? [...node.vC, ...(oldVChildren || [])] : oldVChildren || []
    node.vC = vChildren
    if (buildWithPreviousChildren) {
      delete node.pC
    }
  } catch (e) {
    node.f = true
    if (e === cancelBuild) {
      if (foundErrorHandler) {
        return
      } else {
        throw e
      }
    }

    const [errorHandlerContext, errorHandler, errorHandlerNode] =
      node[DOM_STASH]?.[3] || ([] as unknown as [undefined, undefined])

    if (errorHandler) {
      const fallbackUpdateFn = () =>
        update([0, false, context[2] as UpdateHook], errorHandlerNode as NodeObject)
      const fallbackUpdateFnArray =
        fallbackUpdateFnArrayMap.get(errorHandlerNode as NodeObject) || []
      fallbackUpdateFnArray.push(fallbackUpdateFn)
      fallbackUpdateFnArrayMap.set(errorHandlerNode as NodeObject, fallbackUpdateFnArray)
      const fallback = errorHandler(e, () => {
        const fnArray = fallbackUpdateFnArrayMap.get(errorHandlerNode as NodeObject)
        if (fnArray) {
          const i = fnArray.indexOf(fallbackUpdateFn)
          if (i !== -1) {
            fnArray.splice(i, 1)
            return fallbackUpdateFn()
          }
        }
      })
      if (fallback) {
        if (context[0] === 1) {
          // low priority render
          context[1] = true
        } else {
          build(context, errorHandlerNode, [fallback])
          if (
            (errorHandler.length === 1 || context !== errorHandlerContext) &&
            errorHandlerNode.c
          ) {
            // render error boundary immediately
            apply(errorHandlerNode, errorHandlerNode.c as Container, false)
            return
          }
        }
        throw cancelBuild
      }
    }

    throw e
  } finally {
    if (foundErrorHandler) {
      context[5]!.pop()
    }
  }
}

export const buildNode = (node: Child): Node | undefined => {
  if (node === undefined || node === null || typeof node === 'boolean') {
    return undefined
  } else if (typeof node === 'string' || typeof node === 'number') {
    return { t: node.toString(), d: true } as NodeString
  } else {
    if ('vR' in node) {
      node = {
        tag: (node as NodeObject).tag,
        props: (node as NodeObject).props,
        key: (node as NodeObject).key,
        f: (node as NodeObject).f,
        type: (node as NodeObject).tag,
        ref: (node as NodeObject).props.ref,
        o: (node as NodeObject).o || node,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      } as any
    }
    if (typeof (node as JSXNode).tag === 'function') {
      ;(node as NodeObject)[DOM_STASH] = [0, []]
    } else {
      const ns = nameSpaceMap[(node as JSXNode).tag as string]
      if (ns) {
        nameSpaceContext ||= createContext('')
        ;(node as JSXNode).props.children = [
          {
            tag: nameSpaceContext,
            props: {
              value: ((node as NodeObject).n = `http://www.w3.org/${ns}`),
              children: (node as JSXNode).props.children,
            },
          },
        ]
      }
    }
    return node as NodeObject
  }
}

const replaceContainer = (node: NodeObject, from: DocumentFragment, to: Container): void => {
  if (node.c === from) {
    node.c = to
    node.vC.forEach((child) => replaceContainer(child as NodeObject, from, to))
  }
}

const updateSync = (context: Context, node: NodeObject): void => {
  node[DOM_STASH][2]?.forEach(([c, v]) => {
    c.values.push(v)
  })
  try {
    build(context, node, undefined)
  } catch {
    return
  }
  if (node.a) {
    delete node.a
    return
  }
  node[DOM_STASH][2]?.forEach(([c]) => {
    c.values.pop()
  })
  if (context[0] !== 1 || !context[1]) {
    apply(node, node.c as Container, false)
  }
}

type UpdateMapResolve = (node: NodeObject | undefined) => void
const updateMap: WeakMap<NodeObject, [UpdateMapResolve, Function]> = new WeakMap<
  NodeObject,
  [UpdateMapResolve, Function]
>()
const currentUpdateSets: Set<NodeObject>[] = []
export const update = async (
  context: Context,
  node: NodeObject
): Promise<NodeObject | undefined> => {
  context[5] ||= []

  const existing = updateMap.get(node)
  if (existing) {
    // execute only the last update() call, so the previous update will be canceled.
    existing[0](undefined)
  }

  let resolve: UpdateMapResolve | undefined
  const promise = new Promise<NodeObject | undefined>((r) => (resolve = r))
  updateMap.set(node, [
    resolve as UpdateMapResolve,
    () => {
      if (context[2]) {
        context[2](context, node, (context) => {
          updateSync(context, node)
        }).then(() => (resolve as UpdateMapResolve)(node))
      } else {
        updateSync(context, node)
        ;(resolve as UpdateMapResolve)(node)
      }
    },
  ])

  if (currentUpdateSets.length) {
    ;(currentUpdateSets.at(-1) as Set<NodeObject>).add(node)
  } else {
    await Promise.resolve()

    const latest = updateMap.get(node)
    if (latest) {
      updateMap.delete(node)
      latest[1]()
    }
  }

  return promise
}

export const renderNode = (node: NodeObject, container: Container): void => {
  const context: Context = []
  ;(context as Context)[5] = [] // error handler stack
  ;(context as Context)[4] = true // start top level render
  build(context, node, undefined)
  ;(context as Context)[4] = false // finish top level render

  const fragment = document.createDocumentFragment()
  apply(node, fragment, true)
  replaceContainer(node, fragment, container)
  container.replaceChildren(fragment)
}

export const render = (jsxNode: Child, container: Container): void => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  renderNode(buildNode({ tag: '', props: { children: jsxNode } } as any) as NodeObject, container)
}

export const flushSync = (callback: () => void): void => {
  const set = new Set<NodeObject>()
  currentUpdateSets.push(set)
  callback()
  set.forEach((node) => {
    const latest = updateMap.get(node)
    if (latest) {
      updateMap.delete(node)
      latest[1]()
    }
  })
  currentUpdateSets.pop()
}

export const createPortal = (children: Child, container: HTMLElement, key?: string): Child =>
  ({
    tag: HONO_PORTAL_ELEMENT,
    props: {
      children,
    },
    key,
    e: container,
    p: 1,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } as any)

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/dom/server.test.tsx
```
/** @jsxImportSource ../ */
import { renderToReadableStream, renderToString } from './server'

describe('renderToString', () => {
  it('Should be able to render HTML element', () => {
    expect(renderToString(<h1>Hello</h1>)).toBe('<h1>Hello</h1>')
  })

  it('Should be able to render null', () => {
    expect(renderToString(null)).toBe('')
  })

  it('Should be able to render undefined', () => {
    expect(renderToString(undefined)).toBe('')
  })

  it('Should be able to render number', () => {
    expect(renderToString(1)).toBe('1')
  })

  it('Should be able to render string', () => {
    expect(renderToString('Hono')).toBe('Hono')
  })

  it('Should omit options', () => {
    expect(renderToString('Hono', { identifierPrefix: 'test' })).toBe('Hono')
  })

  it('Should raise error for async component', async () => {
    const AsyncComponent = async () => <h1>Hello from async component</h1>
    expect(() => renderToString(<AsyncComponent />)).toThrowError()
  })
})

describe('renderToReadableStream', () => {
  const textDecoder = new TextDecoder()
  const getStringFromStream = async (stream: ReadableStream<Uint8Array>): Promise<string> => {
    const reader = stream.getReader()
    let str = ''
    for (;;) {
      const { done, value } = await reader.read()
      if (done) {
        break
      }
      str += textDecoder.decode(value)
    }
    return str
  }

  it('Should be able to render HTML element', async () => {
    const stream = await renderToReadableStream(<h1>Hello</h1>)
    const reader = stream.getReader()
    let { done, value } = await reader.read()
    expect(done).toBe(false)
    expect(textDecoder.decode(value)).toBe('<h1>Hello</h1>')
    done = (await reader.read()).done
    expect(done).toBe(true)
  })

  it('Should be able to render null', async () => {
    expect(await getStringFromStream(await renderToReadableStream(null))).toBe('')
  })

  it('Should be able to render undefined', async () => {
    expect(await getStringFromStream(await renderToReadableStream(undefined))).toBe('')
  })

  it('Should be able to render number', async () => {
    expect(await getStringFromStream(await renderToReadableStream(1))).toBe('1')
  })

  it('Should be able to render string', async () => {
    expect(await getStringFromStream(await renderToReadableStream('Hono'))).toBe('Hono')
  })

  it('Should be called `onError` if there is an error', async () => {
    const ErrorComponent = async () => {
      throw new Error('Server error')
    }

    const onError = vi.fn()
    expect(
      await getStringFromStream(await renderToReadableStream(<ErrorComponent />, { onError }))
    ).toBe('')
    expect(onError).toBeCalledWith(new Error('Server error'))
  })

  it('Should not be called `onError` if there is no error', async () => {
    const onError = vi.fn(() => 'error')
    expect(await getStringFromStream(await renderToReadableStream('Hono', { onError }))).toBe(
      'Hono'
    )
    expect(onError).toBeCalledTimes(0)
  })

  it('Should omit options, except onError', async () => {
    expect(
      await getStringFromStream(await renderToReadableStream('Hono', { identifierPrefix: 'test' }))
    ).toBe('Hono')
  })

  it('Should be able to render async component', async () => {
    const ChildAsyncComponent = async () => {
      await new Promise((resolve) => setTimeout(resolve, 10))
      return <span>child async component</span>
    }

    const AsyncComponent = async () => {
      await new Promise((resolve) => setTimeout(resolve, 10))
      return (
        <h1>
          Hello from async component
          <ChildAsyncComponent />
        </h1>
      )
    }

    const stream = await renderToReadableStream(<AsyncComponent />)
    const reader = stream.getReader()
    let { done, value } = await reader.read()
    expect(done).toBe(false)
    expect(textDecoder.decode(value)).toBe(
      '<h1>Hello from async component<span>child async component</span></h1>'
    )
    done = (await reader.read()).done
    expect(done).toBe(true)
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/dom/server.ts
```typescript
/**
 * @module
 * This module provides APIs for `hono/jsx/server`, which is compatible with `react-dom/server`.
 */

import type { HtmlEscapedString } from '../../utils/html'
import type { Child } from '../base'
import { renderToReadableStream as renderToReadableStreamHono } from '../streaming'
import version from './'

export interface RenderToStringOptions {
  identifierPrefix?: string
}

/**
 * Render JSX element to string.
 * @param element JSX element to render.
 * @param options Options for rendering.
 * @returns Rendered string.
 */
const renderToString = (element: Child, options: RenderToStringOptions = {}): string => {
  if (Object.keys(options).length > 0) {
    console.warn('options are not supported yet')
  }
  const res = element?.toString() ?? ''
  if (typeof res !== 'string') {
    throw new Error('Async component is not supported in renderToString')
  }
  return res
}

export interface RenderToReadableStreamOptions {
  identifierPrefix?: string
  namespaceURI?: string
  nonce?: string
  bootstrapScriptContent?: string
  bootstrapScripts?: string[]
  bootstrapModules?: string[]
  progressiveChunkSize?: number
  signal?: AbortSignal
  onError?: (error: unknown) => string | void
}

/**
 * Render JSX element to readable stream.
 * @param element JSX element to render.
 * @param options Options for rendering.
 * @returns Rendered readable stream.
 */
const renderToReadableStream = async (
  element: Child,
  options: RenderToReadableStreamOptions = {}
): Promise<ReadableStream<Uint8Array>> => {
  if (Object.keys(options).some((key) => key !== 'onError')) {
    console.warn('options are not supported yet, except onError')
  }

  if (!element || typeof element !== 'object') {
    element = element?.toString() ?? ''
  }

  return renderToReadableStreamHono(element as HtmlEscapedString, options.onError)
}

export { renderToString, renderToReadableStream, version }
export default {
  renderToString,
  renderToReadableStream,
  version,
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/dom/utils.ts
```typescript
import { DOM_INTERNAL_TAG } from '../constants'

export const setInternalTagFlag = (fn: Function): Function => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ;(fn as any)[DOM_INTERNAL_TAG] = true
  return fn
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/dom/hooks/index.test.tsx
```
/** @jsxImportSource ../../ */
import { JSDOM } from 'jsdom'
import { render, useCallback, useState } from '..'
import { useActionState, useFormStatus, useOptimistic } from '.'

describe('Hooks', () => {
  beforeAll(() => {
    global.requestAnimationFrame = (cb) => setTimeout(cb)
  })

  let dom: JSDOM
  let root: HTMLElement
  beforeEach(() => {
    dom = new JSDOM('<html><body><div id="root"></div></body></html>', {
      runScripts: 'dangerously',
    })
    global.document = dom.window.document
    global.HTMLElement = dom.window.HTMLElement
    global.SVGElement = dom.window.SVGElement
    global.Text = dom.window.Text
    global.FormData = dom.window.FormData
    root = document.getElementById('root') as HTMLElement
  })

  describe('useActionState', () => {
    it('should return initial state', () => {
      const [state] = useActionState(() => {}, 'initial')
      expect(state).toBe('initial')
    })

    it('should return updated state', async () => {
      const action = vi.fn().mockReturnValue('updated')

      const App = () => {
        const [state, formAction] = useActionState(action, 'initial')
        return (
          <>
            <div>{state}</div>
            <form action={formAction}>
              <input type='text' name='name' value='updated' />
              <button>Submit</button>
            </form>
          </>
        )
      }

      render(<App />, root)
      expect(root.innerHTML).toBe(
        '<div>initial</div><form><input type="text" name="name" value="updated"><button>Submit</button></form>'
      )
      root.querySelector('button')?.click()
      await Promise.resolve()
      await Promise.resolve()
      expect(root.innerHTML).toBe(
        '<div>updated</div><form><input type="text" name="name" value="updated"><button>Submit</button></form>'
      )

      expect(action).toHaveBeenCalledOnce()
      const [initialState, formData] = action.mock.calls[0]
      expect(initialState).toBe('initial')
      expect(formData).toBeInstanceOf(FormData)
      expect(formData.get('name')).toBe('updated')
    })
  })

  describe('useFormStatus', () => {
    it('should return initial state', () => {
      const status = useFormStatus()
      expect(status).toEqual({
        pending: false,
        data: null,
        method: null,
        action: null,
      })
    })

    it('should return updated state', async () => {
      let formResolve: () => void = () => {}
      const formPromise = new Promise<void>((r) => (formResolve = r))
      let status: ReturnType<typeof useFormStatus> | undefined
      const Status = () => {
        status = useFormStatus()
        return null
      }
      const App = () => {
        const [, setCount] = useState(0)
        const action = useCallback(() => {
          setCount((count) => count + 1)
          return formPromise
        }, [])
        return (
          <>
            <form action={action}>
              <Status />
              <input type='text' name='name' value='updated' />
              <button>Submit</button>
            </form>
          </>
        )
      }

      render(<App />, root)
      expect(root.innerHTML).toBe(
        '<form><input type="text" name="name" value="updated"><button>Submit</button></form>'
      )
      root.querySelector('button')?.click()
      await Promise.resolve()
      await Promise.resolve()
      await Promise.resolve()
      await Promise.resolve()
      expect(status).toEqual({
        pending: true,
        data: expect.any(FormData),
        method: 'post',
        action: expect.any(Function),
      })
      formResolve?.()
      await Promise.resolve()
      await Promise.resolve()
      expect(status).toEqual({
        pending: false,
        data: null,
        method: null,
        action: null,
      })
    })
  })

  describe('useOptimistic', () => {
    it('should return updated state', async () => {
      let formResolve: () => void = () => {}
      const formPromise = new Promise<void>((r) => (formResolve = r))
      const App = () => {
        const [count, setCount] = useState(0)
        const [optimisticCount, setOptimisticCount] = useOptimistic(count, (c, n: number) => n)
        const action = useCallback(async () => {
          setOptimisticCount(count + 1)
          await formPromise
          setCount((count) => count + 2)
        }, [])

        return (
          <>
            <form action={action}>
              <div>{optimisticCount}</div>
              <input type='text' name='name' value='updated' />
              <button>Submit</button>
            </form>
          </>
        )
      }

      render(<App />, root)
      expect(root.innerHTML).toBe(
        '<form><div>0</div><input type="text" name="name" value="updated"><button>Submit</button></form>'
      )
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe(
        '<form><div>1</div><input type="text" name="name" value="updated"><button>Submit</button></form>'
      )
      formResolve?.()
      await Promise.resolve()
      await Promise.resolve()
      await Promise.resolve()
      await Promise.resolve()
      expect(root.innerHTML).toBe(
        '<form><div>2</div><input type="text" name="name" value="updated"><button>Submit</button></form>'
      )
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/dom/hooks/index.ts
```typescript
/**
 * Provide hooks used only in jsx/dom
 */

import { PERMALINK } from '../../constants'
import type { Context } from '../../context'
import { useContext } from '../../context'
import { useCallback, useState } from '../../hooks'
import { createContext } from '../context'

type FormStatus =
  | {
      pending: false
      data: null
      method: null
      action: null
    }
  | {
      pending: true
      data: FormData
      method: 'get' | 'post'
      action: string | ((formData: FormData) => void | Promise<void>)
    }
export const FormContext: Context<FormStatus> = createContext<FormStatus>({
  pending: false,
  data: null,
  method: null,
  action: null,
})

const actions: Set<Promise<unknown>> = new Set()
export const registerAction = (action: Promise<unknown>) => {
  actions.add(action)
  action.finally(() => actions.delete(action))
}

/**
 * This hook returns the current form status
 * @returns FormStatus
 */
export const useFormStatus = (): FormStatus => {
  return useContext(FormContext)
}

/**
 * This hook returns the current state and a function to update the state optimistically
 * The current state is updated optimistically and then reverted to the original state when all actions are resolved
 * @param state
 * @param updateState
 * @returns [T, (action: N) => void]
 */
export const useOptimistic = <T, N>(
  state: T,
  updateState: (currentState: T, action: N) => T
): [T, (action: N) => void] => {
  const [optimisticState, setOptimisticState] = useState(state)
  if (actions.size > 0) {
    Promise.all(actions).finally(() => {
      setOptimisticState(state)
    })
  } else {
    setOptimisticState(state)
  }

  const cb = useCallback((newData: N) => {
    setOptimisticState((currentState) => updateState(currentState, newData))
  }, [])

  return [optimisticState, cb]
}

/**
 * This hook returns the current state and a function to update the state by form action
 * @param fn
 * @param initialState
 * @param permalink
 * @returns [T, (data: FormData) => void]
 */
export const useActionState = <T>(
  fn: Function,
  initialState: T,
  permalink?: string
): [T, Function] => {
  const [state, setState] = useState(initialState)
  const actionState = async (data: FormData) => {
    setState(await fn(state, data))
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ;(actionState as any)[PERMALINK] = permalink
  return [state, actionState]
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/dom/intrinsic-element/components.test.tsx
```
/** @jsxImportSource ../../ */
import { JSDOM, ResourceLoader } from 'jsdom'
import { Suspense, render } from '..'
import { useState } from '../../hooks'
import { clearCache, composeRef } from './components'

describe('intrinsic element', () => {
  let CustomResourceLoader: typeof ResourceLoader
  beforeAll(() => {
    global.requestAnimationFrame = (cb) => setTimeout(cb)

    CustomResourceLoader = class CustomResourceLoader extends ResourceLoader {
      fetch(url: string) {
        return url.includes('invalid')
          ? Promise.reject('Invalid URL')
          : // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (Promise.resolve(Buffer.from('')) as any)
      }
    }
  })

  let dom: JSDOM
  let root: HTMLElement
  beforeEach(() => {
    clearCache()

    dom = new JSDOM('<html><head></head><body><div id="root"></div></body></html>', {
      runScripts: 'dangerously',
      resources: new CustomResourceLoader(),
    })
    global.document = dom.window.document
    global.HTMLElement = dom.window.HTMLElement
    global.SVGElement = dom.window.SVGElement
    global.Text = dom.window.Text
    global.FormData = dom.window.FormData
    global.CustomEvent = dom.window.CustomEvent
    root = document.getElementById('root') as HTMLElement
  })

  describe('document metadata', () => {
    describe('title element', () => {
      it('should be inserted into head', () => {
        const App = () => {
          return (
            <div>
              <title>Document Title</title>
              Content
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe('<title>Document Title</title>')
        expect(root.innerHTML).toBe('<div>Content</div>')
      })

      it('should be updated', async () => {
        const App = () => {
          const [count, setCount] = useState(0)
          return (
            <div>
              <title>Document Title {count}</title>
              <button onClick={() => setCount(count + 1)}>+</button>
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe('<title>Document Title 0</title>')
        expect(root.innerHTML).toBe('<div><button>+</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(document.head.innerHTML).toBe('<title>Document Title 1</title>')
      })

      it('should be removed when unmounted', async () => {
        const App = () => {
          const [count, setCount] = useState(0)
          return (
            <div>
              {count === 1 && <title>Document Title {count}</title>}
              <div>{count}</div>
              <button onClick={() => setCount(count + 1)}>+</button>
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe('')
        expect(root.innerHTML).toBe('<div><div>0</div><button>+</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(document.head.innerHTML).toBe('<title>Document Title 1</title>')
        expect(root.innerHTML).toBe('<div><div>1</div><button>+</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(document.head.innerHTML).toBe('')
        expect(root.innerHTML).toBe('<div><div>2</div><button>+</button></div>')
      })

      it('should be inserted bottom of head if existing element is removed', async () => {
        document.head.innerHTML = '<title>Existing Title</title>'

        const App = () => {
          const [count, setCount] = useState(0)
          return (
            <div>
              {count === 1 && <title>Document Title {count}</title>}
              <div>{count}</div>
              <button onClick={() => setCount(count + 1)}>+</button>
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe('<title>Existing Title</title>')
        expect(root.innerHTML).toBe('<div><div>0</div><button>+</button></div>')
        root.querySelector('button')?.click()
        document.head.querySelector('title')?.remove()
        await Promise.resolve()
        expect(document.head.innerHTML).toBe('<title>Document Title 1</title>')
        expect(root.innerHTML).toBe('<div><div>1</div><button>+</button></div>')
      })

      it('should be inserted before existing title element', async () => {
        document.head.innerHTML = '<title>Existing Title</title>'

        const App = () => {
          const [count, setCount] = useState(0)
          return (
            <div>
              {count === 1 && <title>Document Title {count}</title>}
              <div>{count}</div>
              <button onClick={() => setCount(count + 1)}>+</button>
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe('<title>Existing Title</title>')
        expect(root.innerHTML).toBe('<div><div>0</div><button>+</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(document.head.innerHTML).toBe(
          '<title>Document Title 1</title><title>Existing Title</title>'
        )
        expect(root.innerHTML).toBe('<div><div>1</div><button>+</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(document.head.innerHTML).toBe('<title>Existing Title</title>')
        expect(root.innerHTML).toBe('<div><div>2</div><button>+</button></div>')
      })
    })

    describe('link element', () => {
      it('should be inserted into head', () => {
        const App = () => {
          return (
            <div>
              <link rel='stylesheet' href='style.css' precedence='default' />
              Content
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe(
          '<link href="style.css" rel="stylesheet" data-precedence="default">'
        )
        expect(root.innerHTML).toBe('<div>Content</div>')
      })

      it('should be updated', async () => {
        const App = () => {
          const [count, setCount] = useState(0)
          return (
            <div>
              <link rel='stylesheet' href={`style${count}.css`} precedence='default' />
              <button onClick={() => setCount(count + 1)}>+</button>
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe(
          '<link href="style0.css" rel="stylesheet" data-precedence="default">'
        )
        expect(root.innerHTML).toBe('<div><button>+</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(document.head.innerHTML).toBe(
          '<link href="style1.css" rel="stylesheet" data-precedence="default">'
        )
      })

      it('should not do special behavior if disabled is present', () => {
        const App = () => {
          return (
            <div>
              <link rel='stylesheet' href={'style.css'} precedence='default' disabled={true} />
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe('')
        expect(root.innerHTML).toBe(
          '<div><link rel="stylesheet" href="style.css" precedence="default" disabled=""></div>'
        )
      })

      it('should be ordered by precedence attribute', () => {
        const App = () => {
          return (
            <div>
              <link rel='stylesheet' href='style-a.css' precedence='default' />
              <link rel='stylesheet' href='style-b.css' precedence='high' />
              <link rel='stylesheet' href='style-c.css' precedence='default' />
              Content
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe(
          '<link href="style-a.css" rel="stylesheet" data-precedence="default"><link href="style-c.css" rel="stylesheet" data-precedence="default"><link href="style-b.css" rel="stylesheet" data-precedence="high">'
        )
        expect(root.innerHTML).toBe('<div>Content</div>')
      })

      it('should be de-duplicated by href attribute', async () => {
        const App = () => {
          const [count, setCount] = useState(0)
          return (
            <div>
              <link rel='stylesheet' href='style-a.css' precedence='default' />
              <link rel='stylesheet' href='style-b.css' precedence='high' />
              {count === 1 && (
                <>
                  <link rel='stylesheet' href='style-a.css' precedence='default' />
                  <link rel='stylesheet' href='style-c.css' precedence='other' />
                </>
              )}
              <button onClick={() => setCount(count + 1)}>+</button>
              {count}
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe(
          '<link href="style-a.css" rel="stylesheet" data-precedence="default"><link href="style-b.css" rel="stylesheet" data-precedence="high">'
        )
        expect(root.innerHTML).toBe('<div><button>+</button>0</div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(document.head.innerHTML).toBe(
          '<link href="style-a.css" rel="stylesheet" data-precedence="default"><link href="style-b.css" rel="stylesheet" data-precedence="high"><link href="style-c.css" rel="stylesheet" data-precedence="other">'
        )
        expect(root.innerHTML).toBe('<div><button>+</button>1</div>')
      })

      it('should be preserved when unmounted', async () => {
        const App = () => {
          const [count, setCount] = useState(0)
          return (
            <div>
              {count === 1 && <link rel='stylesheet' href='style.css' precedence='default' />}
              <div>{count}</div>
              <button onClick={() => setCount(count + 1)}>+</button>
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe('')
        expect(root.innerHTML).toBe('<div><div>0</div><button>+</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(document.head.innerHTML).toBe(
          '<link href="style.css" rel="stylesheet" data-precedence="default">'
        )
        expect(root.innerHTML).toBe('<div><div>1</div><button>+</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(document.head.innerHTML).toBe(
          '<link href="style.css" rel="stylesheet" data-precedence="default">'
        )
        expect(root.innerHTML).toBe('<div><div>2</div><button>+</button></div>')
      })

      it('should be blocked by blocking attribute', async () => {
        const Component = () => {
          return (
            <Suspense fallback={<div>Loading...</div>}>
              <div>
                <link
                  rel='stylesheet'
                  href='http://localhost/style.css'
                  precedence='default'
                  blocking='render'
                />
                Content
              </div>
            </Suspense>
          )
        }
        const App = () => {
          const [show, setShow] = useState(false)
          return (
            <div>
              {show && <Component />}
              <button onClick={() => setShow(true)}>Show</button>
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe('')
        expect(root.innerHTML).toBe('<div><button>Show</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(root.innerHTML).toBe('<div><div>Loading...</div><button>Show</button></div>')
        await new Promise((resolve) => setTimeout(resolve))
        await Promise.resolve()
        expect(root.innerHTML).toBe('<div><div>Content</div><button>Show</button></div>')
      })
    })

    describe('style element', () => {
      it('should be inserted into head', () => {
        const App = () => {
          return (
            <div>
              <style href='red' precedence='default'>
                {'body { color: red; }'}
              </style>
              Content
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe(
          '<style data-href="red" data-precedence="default">body { color: red; }</style>'
        )
        expect(root.innerHTML).toBe('<div>Content</div>')
      })

      it('should be updated', async () => {
        const App = () => {
          const [count, setCount] = useState(0)
          return (
            <div>
              <style href='color' precedence='default'>{`body { color: ${
                count % 2 ? 'red' : 'blue'
              }; }`}</style>
              <button onClick={() => setCount(count + 1)}>+</button>
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe(
          '<style data-href="color" data-precedence="default">body { color: blue; }</style>'
        )
        expect(root.innerHTML).toBe('<div><button>+</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(document.head.innerHTML).toBe(
          '<style data-href="color" data-precedence="default">body { color: red; }</style>'
        )
      })

      it('should be preserved when unmounted', async () => {
        const App = () => {
          const [count, setCount] = useState(0)
          return (
            <div>
              {count === 1 && (
                <style href='red' precedence='default'>
                  {'body { color: red; }'}
                </style>
              )}
              <div>{count}</div>
              <button onClick={() => setCount(count + 1)}>+</button>
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe('')
        expect(root.innerHTML).toBe('<div><div>0</div><button>+</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(document.head.innerHTML).toBe(
          '<style data-href="red" data-precedence="default">body { color: red; }</style>'
        )
        expect(root.innerHTML).toBe('<div><div>1</div><button>+</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(document.head.innerHTML).toBe(
          '<style data-href="red" data-precedence="default">body { color: red; }</style>'
        )
        expect(root.innerHTML).toBe('<div><div>2</div><button>+</button></div>')
      })

      it('should be de-duplicated by href attribute', async () => {
        const App = () => {
          const [count, setCount] = useState(0)
          return (
            <div>
              <style href='red' precedence='default'>
                {'body { color: red; }'}
              </style>
              <style href='blue' precedence='default'>
                {'body { color: blue; }'}
              </style>
              <style href='green' precedence='default'>
                {'body { color: green; }'}
              </style>
              {count === 1 && (
                <>
                  <style href='blue' precedence='default'>
                    {'body { color: blue; }'}
                  </style>
                  <style href='yellow' precedence='default'>
                    {'body { color: yellow; }'}
                  </style>
                </>
              )}
              <button onClick={() => setCount(count + 1)}>+</button>
              {count}
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe(
          '<style data-href="red" data-precedence="default">body { color: red; }</style><style data-href="blue" data-precedence="default">body { color: blue; }</style><style data-href="green" data-precedence="default">body { color: green; }</style>'
        )
        expect(root.innerHTML).toBe('<div><button>+</button>0</div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(document.head.innerHTML).toBe(
          '<style data-href="red" data-precedence="default">body { color: red; }</style><style data-href="blue" data-precedence="default">body { color: blue; }</style><style data-href="green" data-precedence="default">body { color: green; }</style><style data-href="yellow" data-precedence="default">body { color: yellow; }</style>'
        )
        expect(root.innerHTML).toBe('<div><button>+</button>1</div>')
      })

      it('should be ordered by precedence attribute', () => {
        const App = () => {
          return (
            <div>
              <style href='red' precedence='default'>
                {'body { color: red; }'}
              </style>
              <style href='green' precedence='high'>
                {'body { color: green; }'}
              </style>
              <style href='blue' precedence='default'>
                {'body { color: blue; }'}
              </style>
              Content
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe(
          '<style data-href="red" data-precedence="default">body { color: red; }</style><style data-href="blue" data-precedence="default">body { color: blue; }</style><style data-href="green" data-precedence="high">body { color: green; }</style>'
        )
        expect(root.innerHTML).toBe('<div>Content</div>')
      })

      it('should not do special behavior if href is present', () => {
        const template = (
          <html>
            <head></head>
            <body>
              <style>{'body { color: red; }'}</style>
              <h1>World</h1>
            </body>
          </html>
        )
        render(template, root)
        expect(document.head.innerHTML).toBe('')
        expect(root.innerHTML).toBe(
          '<html><head></head><body><style>body { color: red; }</style><h1>World</h1></body></html>'
        )
      })
    })

    describe('meta element', () => {
      it('should be inserted into head', () => {
        const App = () => {
          return (
            <div>
              <meta name='description' content='description' />
              Content
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe('<meta name="description" content="description">')
        expect(root.innerHTML).toBe('<div>Content</div>')
      })

      it('should be updated', async () => {
        const App = () => {
          const [count, setCount] = useState(0)
          return (
            <div>
              <meta name='description' content={`description ${count}`} />
              <button onClick={() => setCount(count + 1)}>+</button>
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe('<meta name="description" content="description 0">')
        expect(root.innerHTML).toBe('<div><button>+</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(document.head.innerHTML).toBe('<meta name="description" content="description 1">')
      })

      it('should not do special behavior if itemProp is present', () => {
        const App = () => {
          return (
            <div>
              <meta name='description' content='description' itemProp='test' />
              Content
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe('')
        expect(root.innerHTML).toBe(
          '<div><meta name="description" content="description" itemprop="test">Content</div>'
        )
      })

      it('should ignore precedence attribute', () => {
        const App = () => {
          return (
            <div>
              <meta name='description-a' content='description-a' precedence='default' />
              <meta name='description-b' content='description-b' precedence='high' />
              <meta name='description-c' content='description-c' precedence='default' />
              Content
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe(
          '<meta name="description-a" content="description-a"><meta name="description-b" content="description-b"><meta name="description-c" content="description-c">'
        )
        expect(root.innerHTML).toBe('<div>Content</div>')
      })

      it('should be de-duplicated by name attribute', async () => {
        const App = () => {
          const [count, setCount] = useState(0)
          return (
            <div>
              <meta name='description-a' content='description-a' />
              <meta name='description-b' content='description-b' />
              {count === 1 && (
                <>
                  <meta name='description-a' content='description-a' />
                  <meta name='description-c' content='description-c' />
                </>
              )}
              <button onClick={() => setCount(count + 1)}>+</button>
              {count}
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe(
          '<meta name="description-a" content="description-a"><meta name="description-b" content="description-b">'
        )
        expect(root.innerHTML).toBe('<div><button>+</button>0</div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(document.head.innerHTML).toBe(
          '<meta name="description-a" content="description-a"><meta name="description-b" content="description-b"><meta name="description-c" content="description-c">'
        )
        expect(root.innerHTML).toBe('<div><button>+</button>1</div>')
      })
    })

    describe('script element', () => {
      it('should be inserted into head', async () => {
        const App = () => {
          return (
            <div>
              <script src='script.js' async={true} />
              Content
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe('<script src="script.js" async=""></script>')
        expect(root.innerHTML).toBe('<div>Content</div>')
      })

      it('should be updated', async () => {
        const App = () => {
          const [count, setCount] = useState(0)
          return (
            <div>
              <script src={`script${count}.js`} async={true} />
              <button onClick={() => setCount(count + 1)}>+</button>
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe('<script src="script0.js" async=""></script>')
        expect(root.innerHTML).toBe('<div><button>+</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(document.head.innerHTML).toBe('<script src="script1.js" async=""></script>')
      })

      it('should be de-duplicated by src attribute with async=true', async () => {
        const App = () => {
          const [count, setCount] = useState(0)
          return (
            <div>
              <script src='script-a.js' async={true} />
              <script src='script-b.js' async={true} />
              {count === 1 && (
                <>
                  <script src='script-a.js' async={true} />
                  <script src='script-c.js' async={true} />
                </>
              )}
              <button onClick={() => setCount(count + 1)}>+</button>
              {count}
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe(
          '<script src="script-a.js" async=""></script><script src="script-b.js" async=""></script>'
        )
        expect(root.innerHTML).toBe('<div><button>+</button>0</div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(document.head.innerHTML).toBe(
          '<script src="script-a.js" async=""></script><script src="script-b.js" async=""></script><script src="script-c.js" async=""></script>'
        )
        expect(root.innerHTML).toBe('<div><button>+</button>1</div>')
      })

      it('should be preserved when unmounted', async () => {
        const App = () => {
          const [count, setCount] = useState(0)
          return (
            <div>
              {count === 1 && <script src='script.js' async={true} />}
              <div>{count}</div>
              <button onClick={() => setCount(count + 1)}>+</button>
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe('')
        expect(root.innerHTML).toBe('<div><div>0</div><button>+</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(document.head.innerHTML).toBe('<script src="script.js" async=""></script>')
        expect(root.innerHTML).toBe('<div><div>1</div><button>+</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(document.head.innerHTML).toBe('<script src="script.js" async=""></script>')
        expect(root.innerHTML).toBe('<div><div>2</div><button>+</button></div>')
      })

      it('should be fired onLoad event', async () => {
        const onLoad = vi.fn()
        const onError = vi.fn()
        const App = () => {
          return (
            <div>
              <script
                src='http://localhost/script.js'
                async={true}
                onLoad={onLoad}
                onError={onError}
              />
              Content
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe(
          '<script src="http://localhost/script.js" async=""></script>'
        )
        await Promise.resolve()
        await new Promise((resolve) => setTimeout(resolve))
        expect(onLoad).toBeCalledTimes(1)
        expect(onError).not.toBeCalled()
      })

      it('should be fired onError event', async () => {
        const onLoad = vi.fn()
        const onError = vi.fn()
        const App = () => {
          return (
            <div>
              <script
                src='http://localhost/invalid.js'
                async={true}
                onLoad={onLoad}
                onError={onError}
              />
              Content
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe(
          '<script src="http://localhost/invalid.js" async=""></script>'
        )
        await Promise.resolve()
        await new Promise((resolve) => setTimeout(resolve))
        await Promise.resolve()
        await new Promise((resolve) => setTimeout(resolve))
        await Promise.resolve()
        await new Promise((resolve) => setTimeout(resolve))
        await Promise.resolve()
        await new Promise((resolve) => setTimeout(resolve))
        expect(onLoad).not.toBeCalled()
        expect(onError).toBeCalledTimes(1)
      })

      it('should be blocked by blocking attribute', async () => {
        const Component = () => {
          return (
            <Suspense fallback={<div>Loading...</div>}>
              <div>
                <script src='http://localhost/script.js' async={true} blocking='render' />
                Content
              </div>
            </Suspense>
          )
        }
        const App = () => {
          const [show, setShow] = useState(false)
          return (
            <div>
              {show && <Component />}
              <button onClick={() => setShow(true)}>Show</button>
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe('')
        expect(root.innerHTML).toBe('<div><button>Show</button></div>')
        root.querySelector('button')?.click()
        await Promise.resolve()
        expect(root.innerHTML).toBe('<div><div>Loading...</div><button>Show</button></div>')
        await new Promise((resolve) => setTimeout(resolve))
        await Promise.resolve()
        expect(root.innerHTML).toBe('<div><div>Content</div><button>Show</button></div>')
      })

      it('should be inserted into body if has no props', async () => {
        const App = () => {
          return (
            <div>
              <script>alert('Hello')</script>
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe('')
        // prettier-ignore
        expect(root.innerHTML).toBe('<div><script>alert(\'Hello\')</script></div>')
      })

      it('should be inserted into body if has only src prop', async () => {
        const App = () => {
          return (
            <div>
              <script src='script.js'></script>
            </div>
          )
        }
        render(<App />, root)
        expect(document.head.innerHTML).toBe('')
        expect(root.innerHTML).toBe('<div><script src="script.js"></script></div>')
      })
    })

    it('accept ref object', async () => {
      const ref = { current: null }
      const App = () => {
        return (
          <div>
            <script src='script-a.js' ref={ref} async={true} />
          </div>
        )
      }
      render(<App />, root)
      expect(ref.current).toBe(document.head.querySelector('script'))
    })

    it('accept ref function', async () => {
      const ref = vi.fn()
      const App = () => {
        return (
          <div>
            <script src='script-a.js' ref={ref} async={true} />
          </div>
        )
      }
      render(<App />, root)
      expect(ref).toHaveBeenCalledTimes(1)
    })
  })

  describe('form element', () => {
    it('should accept Function as action', () => {
      const action = vi.fn()
      const App = () => {
        return (
          <form action={action} method='post'>
            <input type='text' name='name' value='Hello' />
            <button type='submit'>Submit</button>
          </form>
        )
      }
      render(<App />, root)
      root.querySelector('button')?.click()
      expect(action).toBeCalledTimes(1)
      const formData = action.mock.calls[0][0]
      expect(formData.get('name')).toBe('Hello')
    })

    it('should accept string as action', () => {
      const App = () => {
        return (
          <form action={'/entries'} method='post'>
            <button type='submit'>Submit</button>
          </form>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe(
        '<form method="post" action="/entries"><button type="submit">Submit</button></form>'
      )
    })

    it('toggle show / hide form', async () => {
      const action = vi.fn()
      const App = () => {
        const [show, setShow] = useState(false)
        return (
          <div>
            {show && (
              <form action={action} method='post'>
                <input type='text' name='name' value='Hello' />
              </form>
            )}
            <button onClick={() => setShow((status) => !status)}>Toggle</button>
          </div>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button>Toggle</button></div>')
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe(
        '<div><form method="post"><input type="text" name="name" value="Hello"></form><button>Toggle</button></div>'
      )
      root.querySelector('button')?.click()
      await Promise.resolve()
      await Promise.resolve()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><button>Toggle</button></div>')
    })
  })

  describe('input element', () => {
    it('should accept Function as formAction', () => {
      const action = vi.fn()
      const App = () => {
        return (
          <form>
            <input type='text' name='name' value='Hello' />
            <input type='submit' value='Submit' formAction={action} />
          </form>
        )
      }
      render(<App />, root)
      root.querySelector<HTMLInputElement>('input[type="submit"]')?.click()
      expect(action).toBeCalledTimes(1)
      const formData = action.mock.calls[0][0]
      expect(formData.get('name')).toBe('Hello')
    })

    it('should accept string as formAction', () => {
      const App = () => {
        return (
          <form method='post'>
            <input type='submit' formAction={'/entries'} value='Submit' />
          </form>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<form method="post"><input type="submit" value="Submit"></form>')
    })

    it('toggle show / hide input', async () => {
      const action = vi.fn()
      const App = () => {
        const [show, setShow] = useState(false)
        return (
          <div>
            {show && (
              <form method='post'>
                <input type='submit' formAction={action} value='Submit' />
              </form>
            )}
            <button onClick={() => setShow((status) => !status)}>Toggle</button>
          </div>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button>Toggle</button></div>')
      root.querySelector('button')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe(
        '<div><form method="post"><input type="submit" value="Submit"></form><button>Toggle</button></div>'
      )
      root.querySelector('button')?.click()
      await Promise.resolve()
      await Promise.resolve()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><button>Toggle</button></div>')
    })
  })

  describe('button element', () => {
    it('should accept Function as formAction', () => {
      const action = vi.fn()
      const App = () => {
        return (
          <form>
            <input type='text' name='name' value='Hello' />
            <button type='submit' formAction={action}>
              Submit
            </button>
          </form>
        )
      }
      render(<App />, root)
      root.querySelector('button')?.click()
      expect(action).toBeCalledTimes(1)
      const formData = action.mock.calls[0][0]
      expect(formData.get('name')).toBe('Hello')
    })

    it('should accept string as formAction', () => {
      const App = () => {
        return (
          <form method='post'>
            <button type='submit' formAction={'/entries'}>
              Submit
            </button>
          </form>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe(
        '<form method="post"><button type="submit">Submit</button></form>'
      )
    })

    it('toggle show / hide', async () => {
      const action = vi.fn()
      const App = () => {
        const [show, setShow] = useState(false)
        return (
          <div>
            {show && (
              <form method='post'>
                <button formAction={action}>Submit</button>
              </form>
            )}
            <button id='toggle' onClick={() => setShow((status) => !status)}>
              Toggle
            </button>
          </div>
        )
      }
      render(<App />, root)
      expect(root.innerHTML).toBe('<div><button id="toggle">Toggle</button></div>')
      root.querySelector<HTMLButtonElement>('#toggle')?.click()
      await Promise.resolve()
      expect(root.innerHTML).toBe(
        '<div><form method="post"><button>Submit</button></form><button id="toggle">Toggle</button></div>'
      )
      root.querySelector<HTMLButtonElement>('#toggle')?.click()
      await Promise.resolve()
      await Promise.resolve()
      await Promise.resolve()
      expect(root.innerHTML).toBe('<div><button id="toggle">Toggle</button></div>')
    })
  })
})

describe('internal utility method', () => {
  describe('composeRef()', () => {
    it('should compose a ref object', () => {
      const ref = { current: null }
      const cbCleanUp = vi.fn()
      const cb = vi.fn().mockReturnValue(cbCleanUp)
      const composed = composeRef(ref, cb)
      const cleanup = composed('ref')
      expect(ref.current).toBe('ref')
      expect(cb).toBeCalledWith('ref')
      expect(cbCleanUp).not.toBeCalled()
      cleanup()
      expect(ref.current).toBe(null)
      expect(cbCleanUp).toBeCalledTimes(1)
    })

    it('should compose a function', () => {
      const ref = vi.fn()
      const cbCleanUp = vi.fn()
      const cb = vi.fn().mockReturnValue(cbCleanUp)
      const composed = composeRef(ref, cb)
      const cleanup = composed('ref')
      expect(ref).toBeCalledWith('ref')
      expect(cb).toBeCalledWith('ref')
      expect(cbCleanUp).not.toBeCalled()
      cleanup()
      expect(ref).toBeCalledWith(null)
      expect(cbCleanUp).toBeCalledTimes(1)
    })

    it('should compose a function returns a cleanup function', () => {
      const refCleanUp = vi.fn()
      const ref = vi.fn().mockReturnValue(refCleanUp)
      const cbCleanUp = vi.fn()
      const cb = vi.fn().mockReturnValue(cbCleanUp)
      const composed = composeRef(ref, cb)
      const cleanup = composed('ref')
      expect(ref).toBeCalledWith('ref')
      expect(cb).toBeCalledWith('ref')
      expect(refCleanUp).not.toBeCalled()
      expect(cbCleanUp).not.toBeCalled()
      cleanup()
      expect(ref).toHaveBeenCalledTimes(1)
      expect(refCleanUp).toBeCalledTimes(1)
      expect(cbCleanUp).toBeCalledTimes(1)
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/jsx/dom/intrinsic-element/components.ts
```typescript
import type { Props } from '../../base'
import { useContext } from '../../context'
import { use, useCallback, useMemo, useState } from '../../hooks'
import { dataPrecedenceAttr, deDupeKeyMap, domRenderers } from '../../intrinsic-element/common'
import type { IntrinsicElements } from '../../intrinsic-elements'
import type { FC, JSXNode, PropsWithChildren, RefObject } from '../../types'
import { FormContext, registerAction } from '../hooks'
import type { PreserveNodeType } from '../render'
import { createPortal, getNameSpaceContext } from '../render'

// this function is a testing utility and should not be exported to the user
export const clearCache = () => {
  blockingPromiseMap = Object.create(null)
  createdElements = Object.create(null)
}

// this function is exported for testing and should not be used by the user
export const composeRef = <T>(
  ref: RefObject<T> | Function | undefined,
  cb: (e: T) => void | (() => void)
): ((e: T) => () => void) => {
  return useMemo(
    () => (e: T) => {
      let refCleanup: (() => void) | undefined
      if (ref) {
        if (typeof ref === 'function') {
          refCleanup =
            ref(e) ||
            (() => {
              ref(null)
            })
        } else if (ref && 'current' in ref) {
          ref.current = e
          refCleanup = () => {
            ref.current = null
          }
        }
      }

      const cbCleanup = cb(e)
      return () => {
        cbCleanup?.()
        refCleanup?.()
      }
    },
    [ref]
  )
}

let blockingPromiseMap: Record<string, Promise<Event> | undefined> = Object.create(null)
let createdElements: Record<string, HTMLElement> = Object.create(null)
const documentMetadataTag = (
  tag: string,
  props: Props,
  preserveNodeType: PreserveNodeType | undefined,
  supportSort: boolean,
  supportBlocking: boolean
) => {
  if (props?.itemProp) {
    return {
      tag,
      props,
      type: tag,
      ref: props.ref,
    }
  }

  const head = document.head

  let { onLoad, onError, precedence, blocking, ...restProps } = props
  let element: HTMLElement | null = null
  let created = false

  const deDupeKeys = deDupeKeyMap[tag]
  let existingElements: NodeListOf<HTMLElement> | undefined = undefined
  if (deDupeKeys.length > 0) {
    const tags = head.querySelectorAll<HTMLElement>(tag)
    LOOP: for (const e of tags) {
      for (const key of deDupeKeyMap[tag]) {
        if (e.getAttribute(key) === props[key]) {
          element = e
          break LOOP
        }
      }
    }

    if (!element) {
      const cacheKey = deDupeKeys.reduce(
        (acc, key) => (props[key] === undefined ? acc : `${acc}-${key}-${props[key]}`),
        tag
      )
      created = !createdElements[cacheKey]
      element = createdElements[cacheKey] ||= (() => {
        const e = document.createElement(tag)
        for (const key of deDupeKeys) {
          if (props[key] !== undefined) {
            e.setAttribute(key, props[key] as string)
          }
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          if ((props as any).rel) {
            e.setAttribute('rel', props.rel)
          }
        }
        return e
      })()
    }
  } else {
    existingElements = head.querySelectorAll<HTMLElement>(tag)
  }

  precedence = supportSort ? precedence ?? '' : undefined
  if (supportSort) {
    restProps[dataPrecedenceAttr] = precedence
  }

  const insert = useCallback(
    (e: HTMLElement) => {
      if (deDupeKeys.length > 0) {
        let found = false
        for (const existingElement of head.querySelectorAll<HTMLElement>(tag)) {
          if (found && existingElement.getAttribute(dataPrecedenceAttr) !== precedence) {
            head.insertBefore(e, existingElement)
            return
          }
          if (existingElement.getAttribute(dataPrecedenceAttr) === precedence) {
            found = true
          }
        }

        // if sentinel is not found, append to the end
        head.appendChild(e)
      } else if (existingElements) {
        let found = false
        for (const existingElement of existingElements!) {
          if (existingElement === e) {
            found = true
            break
          }
        }
        if (!found) {
          // newly created element
          head.insertBefore(
            e,
            head.contains(existingElements[0]) ? existingElements[0] : head.querySelector(tag)
          )
        }
        existingElements = undefined
      }
    },
    [precedence]
  )

  const ref = composeRef(props.ref, (e: HTMLElement) => {
    const key = deDupeKeys[0]

    if (preserveNodeType === 2) {
      e.innerHTML = ''
    }

    if (created || existingElements) {
      insert(e)
    }

    if (!onError && !onLoad) {
      return
    }

    let promise = (blockingPromiseMap[e.getAttribute(key) as string] ||= new Promise<Event>(
      (resolve, reject) => {
        e.addEventListener('load', resolve)
        e.addEventListener('error', reject)
      }
    ))
    if (onLoad) {
      promise = promise.then(onLoad)
    }
    if (onError) {
      promise = promise.catch(onError)
    }
    promise.catch(() => {})
  })

  if (supportBlocking && blocking === 'render') {
    const key = deDupeKeyMap[tag][0]
    if (props[key]) {
      const value = props[key]
      const promise = (blockingPromiseMap[value] ||= new Promise<Event>((resolve, reject) => {
        insert(element as HTMLElement)
        element!.addEventListener('load', resolve)
        element!.addEventListener('error', reject)
      }))
      use(promise)
    }
  }

  const jsxNode = {
    tag,
    type: tag,
    props: {
      ...restProps,
      ref,
    },
    ref,
  } as unknown as JSXNode & { e?: HTMLElement; p?: PreserveNodeType }

  jsxNode.p = preserveNodeType // preserve for unmounting
  if (element) {
    jsxNode.e = element
  }

  return createPortal(
    jsxNode,
    head
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ) as any
}
export const title: FC<PropsWithChildren> = (props) => {
  const nameSpaceContext = getNameSpaceContext()
  const ns = nameSpaceContext && useContext(nameSpaceContext)
  if (ns?.endsWith('svg')) {
    return {
      tag: 'title',
      props,
      type: 'title',
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ref: (props as any).ref,
    } as unknown as JSXNode
  }
  return documentMetadataTag('title', props, undefined, false, false)
}

export const script: FC<PropsWithChildren<IntrinsicElements['script']>> = (props) => {
  if (!props || ['src', 'async'].some((k) => !props[k])) {
    return {
      tag: 'script',
      props,
      type: 'script',
      ref: props.ref,
    } as unknown as JSXNode
  }
  return documentMetadataTag('script', props, 1, false, true)
}

export const style: FC<PropsWithChildren<IntrinsicElements['style']>> = (props) => {
  if (!props || !['href', 'precedence'].every((k) => k in props)) {
    return {
      tag: 'style',
      props,
      type: 'style',
      ref: props.ref,
    } as unknown as JSXNode
  }
  props['data-href'] = props.href
  delete props.href
  return documentMetadataTag('style', props, 2, true, true)
}

export const link: FC<PropsWithChildren<IntrinsicElements['link']>> = (props) => {
  if (
    !props ||
    ['onLoad', 'onError'].some((k) => k in props) ||
    (props.rel === 'stylesheet' && (!('precedence' in props) || 'disabled' in props))
  ) {
    return {
      tag: 'link',
      props,
      type: 'link',
      ref: props.ref,
    } as unknown as JSXNode
  }
  return documentMetadataTag('link', props, 1, 'precedence' in props, true)
}

export const meta: FC<PropsWithChildren> = (props) => {
  return documentMetadataTag('meta', props, undefined, false, false)
}

const customEventFormAction = Symbol()
export const form: FC<
  PropsWithChildren<{
    action?: Function | string
    method?: 'get' | 'post'
    ref?: RefObject<HTMLFormElement> | ((e: HTMLFormElement | null) => void | (() => void))
  }>
> = (props) => {
  const { action, ...restProps } = props
  if (typeof action !== 'function') {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ;(restProps as any).action = action
  }

  const [state, setState] = useState<[FormData | null, boolean]>([null, false]) // [FormData, isDirty]
  const onSubmit = useCallback<(ev: SubmitEvent | CustomEvent) => void>(
    async (ev: SubmitEvent | CustomEvent) => {
      const currentAction = ev.isTrusted
        ? action
        : (ev as CustomEvent).detail[customEventFormAction]
      if (typeof currentAction !== 'function') {
        return
      }

      ev.preventDefault()
      const formData = new FormData(ev.target as HTMLFormElement)
      setState([formData, true])
      const actionRes = currentAction(formData)
      if (actionRes instanceof Promise) {
        registerAction(actionRes)
        await actionRes
      }
      setState([null, true])
    },
    []
  )

  const ref = composeRef(props.ref, (el: HTMLFormElement) => {
    el.addEventListener('submit', onSubmit)
    return () => {
      el.removeEventListener('submit', onSubmit)
    }
  })

  const [data, isDirty] = state
  state[1] = false
  return {
    tag: FormContext as unknown as Function,
    props: {
      value: {
        pending: data !== null,
        data,
        method: data ? 'post' : null,
        action: data ? action : null,
      },
      children: {
        tag: 'form',
        props: {
          ...restProps,
          ref,
        },
        type: 'form',
        ref,
      },
    },
    f: isDirty,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } as any
}

const formActionableElement = (
  tag: string,
  {
    formAction,
    ...props
  }: {
    formAction?: Function | string
    ref?: RefObject<HTMLInputElement> | ((e: HTMLInputElement) => void | (() => void))
  }
) => {
  if (typeof formAction === 'function') {
    const onClick = useCallback<(ev: MouseEvent) => void>((ev: MouseEvent) => {
      ev.preventDefault()
      ;(ev.currentTarget! as HTMLInputElement).form!.dispatchEvent(
        new CustomEvent('submit', { detail: { [customEventFormAction]: formAction } })
      )
    }, [])

    props.ref = composeRef(props.ref, (el: HTMLInputElement) => {
      el.addEventListener('click', onClick)
      return () => {
        el.removeEventListener('click', onClick)
      }
    })
  }

  return {
    tag,
    props,
    type: tag,
    ref: props.ref,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } as any
}

export const input: FC<PropsWithChildren<IntrinsicElements['input']>> = (props) =>
  formActionableElement('input', props)

export const button: FC<PropsWithChildren<IntrinsicElements['button']>> = (props) =>
  formActionableElement('button', props)

Object.assign(domRenderers, {
  title,
  script,
  style,
  link,
  meta,
  form,
  input,
  button,
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/router/common.case.test.ts
```typescript
import type { RunnerTestSuite } from 'vitest'
import type { ParamIndexMap, Params, Router } from '../router'

const getSuiteHierarchy = (suite?: RunnerTestSuite) => {
  const res: RunnerTestSuite[] = []
  let s: RunnerTestSuite | undefined = suite
  while (s) {
    res.unshift(s)
    s = s.suite
  }
  return res
}

export const runTest = ({
  skip = [],
  newRouter,
}: {
  skip?: {
    reason: string
    tests: string[]
  }[]
  newRouter: <T>() => Router<T>
}) => {
  describe('Common', () => {
    type Match = (method: string, path: string) => { handler: string; params: Params }[]
    let router: Router<string>
    let match: Match

    beforeEach(({ task, skip: skipTask }) => {
      const suites = getSuiteHierarchy(task.suite)
      const name = [...suites.slice(2).map((s) => s.name), task.name].join(' > ')
      const isSkip = skip.find((s) => s.tests.includes(name))
      if (isSkip) {
        console.log(`Skip: ${isSkip.reason}`)
        skipTask()
        return
      }

      router = newRouter()
      match = (method: string, path: string) => {
        const [matchRes, stash] = router.match(method, path)
        const res = matchRes.map((r) =>
          stash
            ? {
                handler: r[0],
                params: Object.keys(r[1]).reduce((acc, key) => {
                  acc[key] = stash[(r[1] as ParamIndexMap)[key]]
                  return acc
                }, Object.create(null) as Params),
              }
            : { handler: r[0], params: r[1] as Params }
        )
        return res
      }
    })

    describe('Basic Usage', () => {
      beforeEach(() => {
        router.add('GET', '/hello', 'get hello')
        router.add('POST', '/hello', 'post hello')
        router.add('PURGE', '/hello', 'purge hello')
      })

      it('GET, post hello', async () => {
        let res = match('GET', '/hello')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('get hello')
        res = match('POST', '/hello')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('post hello')
        res = match('PURGE', '/hello')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('purge hello')
        res = match('PUT', '/hello')
        expect(res.length).toBe(0)
        res = match('GET', '/')
        expect(res.length).toBe(0)
      })
    })

    describe('Reserved words', () => {
      it('Reserved words and named parameter', async () => {
        router.add('GET', '/entry/:constructor', 'get entry')
        const res = match('GET', '/entry/123')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('get entry')
        expect(res[0].params['constructor']).toBe('123')
      })

      it('Reserved words and wildcard', async () => {
        router.add('GET', '/wild/*/card', 'get wildcard')
        const res = match('GET', '/wild/constructor/card')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('get wildcard')
      })

      it('Reserved words and optional named parameter', async () => {
        router.add('GET', '/api/animals/:constructor?', 'animals')
        const res = match('GET', '/api/animals')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('animals')
        expect(res[0].params['constructor']).toBeUndefined()
      })
    })

    describe('Complex', () => {
      it('Named Param', async () => {
        router.add('GET', '/entry/:id', 'get entry')
        const res = match('GET', '/entry/123')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('get entry')
        expect(res[0].params['id']).toBe('123')
      })

      it('Wildcard', async () => {
        router.add('GET', '/wild/*/card', 'get wildcard')
        const res = match('GET', '/wild/xxx/card')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('get wildcard')
      })

      it('Default', async () => {
        router.add('GET', '/api/abc', 'get api')
        router.add('GET', '/api/*', 'fallback')
        let res = match('GET', '/api/abc')
        expect(res.length).toBe(2)
        expect(res[0].handler).toEqual('get api')
        expect(res[1].handler).toEqual('fallback')
        res = match('GET', '/api/def')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('fallback')
      })

      it('Regexp', async () => {
        router.add('GET', '/post/:date{[0-9]+}/:title{[a-z]+}', 'get post')
        let res = match('GET', '/post/20210101/hello')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('get post')
        expect(res[0].params['date']).toBe('20210101')
        expect(res[0].params['title']).toBe('hello')
        res = match('GET', '/post/onetwothree')
        expect(res.length).toBe(0)
        res = match('GET', '/post/123/123')
        expect(res.length).toBe(0)
      })

      it('/*', async () => {
        router.add('GET', '/api/*', 'auth middleware')
        router.add('GET', '/api', 'top')
        router.add('GET', '/api/posts', 'posts')
        router.add('GET', '/api/*', 'fallback')

        let res = match('GET', '/api')
        expect(res.length).toBe(3)
        expect(res[0].handler).toEqual('auth middleware')
        expect(res[1].handler).toEqual('top')
        expect(res[2].handler).toEqual('fallback')
        res = match('GET', '/api/posts')
        expect(res.length).toBe(3)
        expect(res[0].handler).toEqual('auth middleware')
        expect(res[1].handler).toEqual('posts')
        expect(res[2].handler).toEqual('fallback')
      })
    })

    describe('Registration order', () => {
      it('middleware -> handler', async () => {
        router.add('GET', '*', 'bar')
        router.add('GET', '/:type/:action', 'foo')
        const res = match('GET', '/posts/123')
        expect(res.length).toBe(2)
        expect(res[0].handler).toEqual('bar')
        expect(res[1].handler).toEqual('foo')
      })

      it('handler -> fallback', async () => {
        router.add('GET', '/:type/:action', 'foo')
        router.add('GET', '*', 'fallback')
        const res = match('GET', '/posts/123')
        expect(res.length).toBe(2)
        expect(res[0].handler).toEqual('foo')
        expect(res[1].handler).toEqual('fallback')
      })
    })

    describe('Multi match', () => {
      describe('Blog', () => {
        beforeEach(() => {
          router.add('ALL', '*', 'middleware a')
          router.add('GET', '*', 'middleware b')
          router.add('GET', '/entry', 'get entries')
          router.add('POST', '/entry/*', 'middleware c')
          router.add('POST', '/entry', 'post entry')
          router.add('GET', '/entry/:id', 'get entry')
          router.add('GET', '/entry/:id/comment/:comment_id', 'get comment')
        })

        it('GET /', async () => {
          const res = match('GET', '/')
          expect(res.length).toBe(2)
          expect(res[0].handler).toEqual('middleware a')
          expect(res[1].handler).toEqual('middleware b')
        })
        it('GET /entry/123', async () => {
          const res = match('GET', '/entry/123')
          expect(res.length).toBe(3)
          expect(res[0].handler).toEqual('middleware a')
          expect(res[0].params['id']).toBe(undefined)
          expect(res[1].handler).toEqual('middleware b')
          expect(res[1].params['id']).toBe(undefined)
          expect(res[2].handler).toEqual('get entry')
          expect(res[2].params['id']).toBe('123')
        })
        it('GET /entry/123/comment/456', async () => {
          const res = match('GET', '/entry/123/comment/456')
          expect(res.length).toBe(3)
          expect(res[0].handler).toEqual('middleware a')
          expect(res[0].params['id']).toBe(undefined)
          expect(res[0].params['comment_id']).toBe(undefined)
          expect(res[1].handler).toEqual('middleware b')
          expect(res[1].params['id']).toBe(undefined)
          expect(res[1].params['comment_id']).toBe(undefined)
          expect(res[2].handler).toEqual('get comment')
          expect(res[2].params['id']).toBe('123')
          expect(res[2].params['comment_id']).toBe('456')
        })
        it('POST /entry', async () => {
          const res = match('POST', '/entry')
          expect(res.length).toBe(3)
          expect(res[0].handler).toEqual('middleware a')
          expect(res[1].handler).toEqual('middleware c')
          expect(res[2].handler).toEqual('post entry')
        })
        it('DELETE /entry', async () => {
          const res = match('DELETE', '/entry')
          expect(res.length).toBe(1)
          expect(res[0].handler).toEqual('middleware a')
        })
      })

      describe('`params` per a handler', () => {
        beforeEach(() => {
          router.add('ALL', '*', 'middleware a')
          router.add('GET', '/entry/:id/*', 'middleware b')
          router.add('GET', '/entry/:id/:action', 'action')
        })

        it('GET /entry/123/show', async () => {
          const res = match('GET', '/entry/123/show')
          expect(res.length).toBe(3)
          expect(res[0].handler).toEqual('middleware a')
          expect(res[0].params['id']).toBe(undefined)
          expect(res[0].params['action']).toBe(undefined)
          expect(res[1].handler).toEqual('middleware b')
          expect(res[1].params['id']).toBe('123')
          expect(res[1].params['comment_id']).toBe(undefined)
          expect(res[2].handler).toEqual('action')
          expect(res[2].params['id']).toBe('123')
          expect(res[2].params['action']).toBe('show')
        })
      })

      it('hierarchy', () => {
        router.add('GET', '/posts/:id/comments/:comment_id', 'foo')
        router.add('GET', '/posts/:id', 'bar')
        expect(() => {
          router.match('GET', '/')
        }).not.toThrow()
      })
    })

    describe('Duplicate param name', () => {
      it('self', () => {
        router.add('GET', '/:id/:id', 'foo')
        const res = match('GET', '/123/456')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('foo')
        expect(res[0].params['id']).toBe('123')
      })

      it('parent', () => {
        router.add('GET', '/:id/:action', 'foo')
        router.add('GET', '/posts/:id', 'bar')
        const res = match('GET', '/posts/get')
        expect(res.length).toBe(2)
        expect(res[0].handler).toEqual('foo')
        expect(res[0].params['id']).toBe('posts')
        expect(res[0].params['action']).toBe('get')
        expect(res[1].handler).toEqual('bar')
        expect(res[1].params['id']).toBe('get')
      })

      it('child', () => {
        router.add('GET', '/posts/:id', 'foo')
        router.add('GET', '/:id/:action', 'bar')
        const res = match('GET', '/posts/get')
        expect(res.length).toBe(2)
        expect(res[0].handler).toEqual('foo')
        expect(res[0].params['id']).toBe('get')
        expect(res[1].handler).toEqual('bar')
        expect(res[1].params['id']).toBe('posts')
        expect(res[1].params['action']).toBe('get')
      })
    })

    describe('page', () => {
      it('GET /page', async () => {
        router.add('GET', '/page', 'page')
        router.add('ALL', '*', 'fallback') // or '*'

        const res = match('GET', '/page')
        expect(res.length).toBe(2)
        expect(res[0].handler).toEqual('page')
        expect(res[1].handler).toEqual('fallback')
      })
    })

    describe('star', () => {
      beforeEach(() => {
        router.add('GET', '/', '/')
        router.add('GET', '/*', '/*')
        router.add('GET', '*', '*')

        router.add('GET', '/x', '/x')
        router.add('GET', '/x/*', '/x/*')
      })

      it('top', async () => {
        const res = match('GET', '/')
        expect(res.length).toBe(3)
        expect(res[0].handler).toEqual('/')
        expect(res[1].handler).toEqual('/*')
        expect(res[2].handler).toEqual('*')
      })

      it('Under a certain path', async () => {
        const res = match('GET', '/x')
        expect(res.length).toBe(4)
        expect(res[0].handler).toEqual('/*')
        expect(res[1].handler).toEqual('*')
        expect(res[2].handler).toEqual('/x')
        expect(res[3].handler).toEqual('/x/*')
      })
    })

    describe('Optional route', () => {
      beforeEach(() => {
        router.add('GET', '/api/animals/:type?', 'animals')
        router.add('GET', '/v1/:version?/:platform?', 'result')
      })

      it('GET /api/animals/dog', async () => {
        const res = match('GET', '/api/animals/dog')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('animals')
        expect(res[0].params['type']).toBe('dog')
      })
      it('GET /api/animals', async () => {
        const res = match('GET', '/api/animals')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('animals')
        expect(res[0].params['type']).toBeUndefined()
      })
      it('GET /v1/123/abc', () => {
        const res = match('GET', '/v1/123/abc')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('result')
        expect(res[0].params['version']).toBe('123')
        expect(res[0].params['platform']).toBe('abc')
      })
      it('GET /v1/123', () => {
        const res = match('GET', '/v1/123')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('result')
        expect(res[0].params['version']).toBe('123')
        expect(res[0].params['platform']).toBeUndefined()
      })
      it('GET /v1', () => {
        const res = match('GET', '/v1')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('result')
        expect(res[0].params['version']).toBeUndefined()
        expect(res[0].params['platform']).toBeUndefined()
      })
    })

    describe('All', () => {
      beforeEach(() => {
        router.add('GET', '/hello', 'get hello')
        router.add('ALL', '/all', 'get all')
      })

      it('GET, all hello', async () => {
        const res = match('GET', '/all')
        expect(res.length).toBe(1)
      })
    })

    describe('long prefix, then star', () => {
      describe('GET only', () => {
        beforeEach(() => {
          router.add('GET', '/long/prefix/*', 'long-prefix')
          router.add('GET', '/long/*', 'long')
          router.add('GET', '*', 'star1')
          router.add('GET', '*', 'star2')
        })

        it('GET /', () => {
          const res = match('GET', '/')
          expect(res.length).toBe(2)
          expect(res[0].handler).toEqual('star1')
          expect(res[1].handler).toEqual('star2')
        })

        it('GET /long/prefix', () => {
          const res = match('GET', '/long/prefix')
          expect(res.length).toBe(4)
          expect(res[0].handler).toEqual('long-prefix')
          expect(res[1].handler).toEqual('long')
          expect(res[2].handler).toEqual('star1')
          expect(res[3].handler).toEqual('star2')
        })

        it('GET /long/prefix/test', () => {
          const res = match('GET', '/long/prefix/test')
          expect(res.length).toBe(4)
          expect(res[0].handler).toEqual('long-prefix')
          expect(res[1].handler).toEqual('long')
          expect(res[2].handler).toEqual('star1')
          expect(res[3].handler).toEqual('star2')
        })
      })

      describe('ALL and GET', () => {
        beforeEach(() => {
          router.add('ALL', '/long/prefix/*', 'long-prefix')
          router.add('ALL', '/long/*', 'long')
          router.add('GET', '*', 'star1')
          router.add('GET', '*', 'star2')
        })

        it('GET /', () => {
          const res = match('GET', '/')
          expect(res.length).toBe(2)
          expect(res[0].handler).toEqual('star1')
          expect(res[1].handler).toEqual('star2')
        })

        it('GET /long/prefix', () => {
          const res = match('GET', '/long/prefix')
          expect(res.length).toBe(4)
          expect(res[0].handler).toEqual('long-prefix')
          expect(res[1].handler).toEqual('long')
          expect(res[2].handler).toEqual('star1')
          expect(res[3].handler).toEqual('star2')
        })

        it('GET /long/prefix/test', () => {
          const res = match('GET', '/long/prefix/test')
          expect(res.length).toBe(4)
          expect(res[0].handler).toEqual('long-prefix')
          expect(res[1].handler).toEqual('long')
          expect(res[2].handler).toEqual('star1')
          expect(res[3].handler).toEqual('star2')
        })
      })
    })

    describe('Including slashes', () => {
      beforeEach(() => {
        router.add('GET', '/js/:filename{[a-z0-9/]+.js}', 'any file')
      })

      it('GET /js/main.js', () => {
        router.add('GET', '/js/main.js', 'main.js')

        const res = match('GET', '/js/main.js')
        expect(res.length).toBe(2)
        expect(res[0].handler).toEqual('any file')
        expect(res[0].params['filename']).toEqual('main.js')
        expect(res[1].handler).toEqual('main.js')
        expect(res[1].params['filename']).toEqual(undefined)
      })

      it('GET /js/chunk/123.js', () => {
        const res = match('GET', '/js/chunk/123.js')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('any file')
        expect(res[0].params['filename']).toEqual('chunk/123.js')
      })

      it('GET /js/chunk/nest/123.js', () => {
        const res = match('GET', '/js/chunk/nest/123.js')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('any file')
        expect(res[0].params['filename']).toEqual('chunk/nest/123.js')
      })
    })

    describe('Capture simple multiple directories', () => {
      beforeEach(() => {
        router.add('GET', '/:dirs{.+}/file.html', 'file.html')
      })

      it('GET /foo/bar/file.html', () => {
        const res = match('GET', '/foo/bar/file.html')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('file.html')
        expect(res[0].params['dirs']).toEqual('foo/bar')
      })
    })

    describe('Capture regex pattern has trailing wildcard', () => {
      beforeEach(() => {
        router.add('GET', '/:dir{[a-z]+}/*/file.html', 'file.html')
      })

      it('GET /foo/bar/file.html', () => {
        const res = match('GET', '/foo/bar/file.html')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('file.html')
        expect(res[0].params['dir']).toEqual('foo')
      })
    })

    describe('Capture complex multiple directories', () => {
      beforeEach(() => {
        router.add('GET', '/:first{.+}/middle-a/:reference?', '1')
        router.add('GET', '/:first{.+}/middle-b/end-c/:uuid', '2')
        router.add('GET', '/:first{.+}/middle-b/:digest', '3')
      })

      it('GET /part1/middle-b/latest', () => {
        const res = match('GET', '/part1/middle-b/latest')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('3')
        expect(res[0].params['first']).toEqual('part1')
        expect(res[0].params['digest']).toEqual('latest')
      })

      it('GET /part1/middle-b/end-c/latest', () => {
        const res = match('GET', '/part1/middle-b/end-c/latest')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('2')
        expect(res[0].params['first']).toEqual('part1')
        expect(res[0].params['uuid']).toEqual('latest')
      })
    })

    describe('Capture multiple directories and optional', () => {
      beforeEach(() => {
        router.add('GET', '/:prefix{.+}/contents/:id?', 'contents')
      })

      it('GET /foo/bar/contents', () => {
        const res = match('GET', '/foo/bar/contents')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('contents')
        expect(res[0].params['prefix']).toEqual('foo/bar')
        expect(res[0].params['id']).toEqual(undefined)
      })

      it('GET /foo/bar/contents/123', () => {
        const res = match('GET', '/foo/bar/contents/123')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('contents')
        expect(res[0].params['prefix']).toEqual('foo/bar')
        expect(res[0].params['id']).toEqual('123')
      })
    })

    describe('non ascii characters', () => {
      beforeEach(() => {
        router.add('ALL', '/$/*', 'middleware $')
        router.add('GET', '/$/:name', 'get $ name')
        router.add('ALL', '/()/*', 'middleware ()')
        router.add('GET', '/()/:name', 'get () name')
      })

      it('GET /$/hono', () => {
        const res = match('GET', '/$/hono')
        expect(res.length).toBe(2)
        expect(res[0].handler).toEqual('middleware $')
        expect(res[0].params).toEqual({})
        expect(res[1].handler).toEqual('get $ name')
        expect(res[1].params['name']).toEqual('hono')
      })

      it('GET /()/hono', () => {
        const res = match('GET', '/()/hono')
        expect(res.length).toBe(2)
        expect(res[0].handler).toEqual('middleware ()')
        expect(res[0].params).toEqual({})
        expect(res[1].handler).toEqual('get () name')
        expect(res[1].params['name']).toEqual('hono')
      })
    })

    describe('REST API', () => {
      beforeEach(() => {
        router.add('GET', '/users/:username{[a-z]+}', 'profile')
        router.add('GET', '/users/:username{[a-z]+}/posts', 'posts')
      })

      it('GET /users/hono', () => {
        const res = match('GET', '/users/hono')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('profile')
      })

      it('GET /users/hono/posts', () => {
        const res = match('GET', '/users/hono/posts')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('posts')
      })
    })

    describe('Trailing slash', () => {
      beforeEach(() => {
        router.add('GET', '/book', 'GET /book')
        router.add('GET', '/book/:id', 'GET /book/:id')
      })

      it('GET /book', () => {
        const res = match('GET', '/book')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('GET /book')
      })
      it('GET /book/', () => {
        const res = match('GET', '/book/')
        expect(res.length).toBe(0)
      })
    })

    describe('Same path', () => {
      beforeEach(() => {
        router.add('GET', '/hey', 'Middleware A')
        router.add('GET', '/hey', 'Middleware B')
      })

      it('GET /hey', () => {
        const res = match('GET', '/hey')
        expect(res.length).toBe(2)
        expect(res[0].handler).toEqual('Middleware A')
        expect(res[1].handler).toEqual('Middleware B')
      })
    })

    describe('Routing with a hostname', () => {
      beforeEach(() => {
        router.add('GET', 'www1.example.com/hello', 'www1')
        router.add('GET', 'www2.example.com/hello', 'www2')
      })
      it('GET www1.example.com/hello', () => {
        const res = match('GET', 'www1.example.com/hello')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('www1')
      })
      it('GET www2.example.com/hello', () => {
        const res = match('GET', 'www2.example.com/hello')
        expect(res.length).toBe(1)
        expect(res[0].handler).toEqual('www2')
      })
      it('GET /hello', () => {
        const res = match('GET', '/hello')
        expect(res.length).toBe(0)
      })
    })

    describe('static routes of ALL and GET', () => {
      beforeEach(() => {
        router.add('ALL', '/foo', 'foo')
        router.add('GET', '/bar', 'bar')
      })

      it('get /foo', () => {
        const res = match('GET', '/foo')
        expect(res[0].handler).toEqual('foo')
      })
    })

    describe('ALL and Star', () => {
      beforeEach(() => {
        router.add('ALL', '/x', '/x')
        router.add('GET', '*', 'star')
      })

      it('Should return /x and star', async () => {
        const res = match('GET', '/x')
        expect(res.length).toBe(2)
        expect(res[0].handler).toEqual('/x')
        expect(res[1].handler).toEqual('star')
      })
    })

    describe('GET star, ALL static, GET star...', () => {
      beforeEach(() => {
        router.add('GET', '*', 'star1')
        router.add('ALL', '/x', '/x')
        router.add('GET', '*', 'star2')
        router.add('GET', '*', 'star3')
      })

      it('Should return /x and star', async () => {
        const res = match('GET', '/x')
        expect(res.length).toBe(4)
        expect(res[0].handler).toEqual('star1')
        expect(res[1].handler).toEqual('/x')
        expect(res[2].handler).toEqual('star2')
        expect(res[3].handler).toEqual('star3')
      })
    })

    // https://github.com/honojs/hono/issues/699
    describe('GET star, GET static, ALL star...', () => {
      beforeEach(() => {
        router.add('GET', '/y/*', 'star1')
        router.add('GET', '/y/a', 'a')
        router.add('ALL', '/y/b/*', 'star2')
        router.add('GET', '/y/b/bar', 'bar')
      })

      it('Should return star1, star2, and bar', async () => {
        const res = match('GET', '/y/b/bar')
        expect(res.length).toBe(3)
        expect(res[0].handler).toEqual('star1')
        expect(res[1].handler).toEqual('star2')
        expect(res[2].handler).toEqual('bar')
      })
    })

    describe('ALL star, ALL star, GET static, ALL star...', () => {
      beforeEach(() => {
        router.add('ALL', '*', 'wildcard')
        router.add('ALL', '/a/*', 'star1')
        router.add('GET', '/a/foo', 'foo')
        router.add('ALL', '/b/*', 'star2')
        router.add('GET', '/b/bar', 'bar')
      })

      it('Should return wildcard, star2 and bar', async () => {
        const res = match('GET', '/b/bar')
        expect(res.length).toBe(3)
        expect(res[0].handler).toEqual('wildcard')
        expect(res[1].handler).toEqual('star2')
        expect(res[2].handler).toEqual('bar')
      })
    })

    describe('Capture Group', () => {
      describe('Simple capturing group', () => {
        beforeEach(() => {
          router.add('get', '/foo/:capture{(?:bar|baz)}', 'ok')
        })

        it('GET /foo/bar', () => {
          const res = match('get', '/foo/bar')
          expect(res.length).toBe(1)
          expect(res[0].handler).toBe('ok')
          expect(res[0].params['capture']).toBe('bar')
        })

        it('GET /foo/baz', () => {
          const res = match('get', '/foo/baz')
          expect(res.length).toBe(1)
          expect(res[0].handler).toBe('ok')
          expect(res[0].params['capture']).toBe('baz')
        })

        it('GET /foo/qux', () => {
          const res = match('get', '/foo/qux')
          expect(res.length).toBe(0)
        })
      })

      describe('Non-capturing group', () => {
        beforeEach(() => {
          router.add('get', '/foo/:capture{(?:bar|baz)}', 'ok')
        })

        it('GET /foo/bar', () => {
          const res = match('get', '/foo/bar')
          expect(res.length).toBe(1)
          expect(res[0].handler).toBe('ok')
          expect(res[0].params['capture']).toBe('bar')
        })

        it('GET /foo/baz', () => {
          const res = match('get', '/foo/baz')
          expect(res.length).toBe(1)
          expect(res[0].handler).toBe('ok')
          expect(res[0].params['capture']).toBe('baz')
        })

        it('GET /foo/qux', () => {
          const res = match('get', '/foo/qux')
          expect(res.length).toBe(0)
        })
      })

      describe('Non-capturing group with prefix', () => {
        beforeEach(() => {
          router.add('get', '/foo/:capture{ba(?:r|z)}', 'ok')
        })

        it('GET /foo/bar', () => {
          const res = match('get', '/foo/bar')
          expect(res.length).toBe(1)
          expect(res[0].handler).toBe('ok')
          expect(res[0].params['capture']).toBe('bar')
        })

        it('GET /foo/baz', () => {
          const res = match('get', '/foo/baz')
          expect(res.length).toBe(1)
          expect(res[0].handler).toBe('ok')
          expect(res[0].params['capture']).toBe('baz')
        })

        it('GET /foo/qux', () => {
          const res = match('get', '/foo/qux')
          expect(res.length).toBe(0)
        })
      })

      describe('Complex capturing group', () => {
        it('GET request', () => {
          router.add('get', '/foo/:capture{ba(r|z)}', 'ok')

          const res = match('get', '/foo/bar')
          expect(res.length).toBe(1)
          expect(res[0].handler).toBe('ok')
        })
      })
    })

    describe('Unknown method', () => {
      beforeEach(() => {
        router.add('GET', '/', 'index')
        router.add('ALL', '/all', 'all')
      })

      it('UNKNOWN_METHOD /', () => {
        const res = match('UNKNOWN_METHOD', '/')
        expect(res.length).toBe(0)
      })

      it('UNKNOWN_METHOD /all', () => {
        const res = match('UNKNOWN_METHOD', '/all')
        expect(res.length).toBe(1)
        expect(res[0].handler).toBe('all')
      })
    })
  })
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/router/reg-exp-router/index.ts
```typescript
/**
 * @module
 * RegExpRouter for Hono.
 */

export { RegExpRouter } from './router'

```
/Users/josh/Documents/GitHub/honojs/hono/src/router/reg-exp-router/node.ts
```typescript
const LABEL_REG_EXP_STR = '[^/]+'
const ONLY_WILDCARD_REG_EXP_STR = '.*'
const TAIL_WILDCARD_REG_EXP_STR = '(?:|/.*)'
export const PATH_ERROR = Symbol()

export type ParamAssocArray = [string, number][]
export interface Context {
  varIndex: number
}

const regExpMetaChars = new Set('.\\+*[^]$()')

/**
 * Sort order:
 * 1. literal
 * 2. special pattern (e.g. :label{[0-9]+})
 * 3. common label pattern (e.g. :label)
 * 4. wildcard
 */
function compareKey(a: string, b: string): number {
  if (a.length === 1) {
    return b.length === 1 ? (a < b ? -1 : 1) : -1
  }
  if (b.length === 1) {
    return 1
  }

  // wildcard
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1
  }

  // label
  if (a === LABEL_REG_EXP_STR) {
    return 1
  } else if (b === LABEL_REG_EXP_STR) {
    return -1
  }

  return a.length === b.length ? (a < b ? -1 : 1) : b.length - a.length
}

export class Node {
  #index?: number
  #varIndex?: number
  #children: Record<string, Node> = Object.create(null)

  insert(
    tokens: readonly string[],
    index: number,
    paramMap: ParamAssocArray,
    context: Context,
    pathErrorCheckOnly: boolean
  ): void {
    if (tokens.length === 0) {
      if (this.#index !== undefined) {
        throw PATH_ERROR
      }
      if (pathErrorCheckOnly) {
        return
      }

      this.#index = index
      return
    }

    const [token, ...restTokens] = tokens
    const pattern =
      token === '*'
        ? restTokens.length === 0
          ? ['', '', ONLY_WILDCARD_REG_EXP_STR] // '*' matches to all the trailing paths
          : ['', '', LABEL_REG_EXP_STR]
        : token === '/*'
        ? ['', '', TAIL_WILDCARD_REG_EXP_STR] // '/path/to/*' is /\/path\/to(?:|/.*)$
        : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/)

    let node
    if (pattern) {
      const name = pattern[1]
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR
      if (name && pattern[2]) {
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, '(?:') // (a|b) => (?:a|b)
        if (/\((?!\?:)/.test(regexpStr)) {
          // prefix(?:a|b) is allowed, but prefix(a|b) is not
          throw PATH_ERROR
        }
      }

      node = this.#children[regexpStr]
      if (!node) {
        if (
          Object.keys(this.#children).some(
            (k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
          )
        ) {
          throw PATH_ERROR
        }
        if (pathErrorCheckOnly) {
          return
        }
        node = this.#children[regexpStr] = new Node()
        if (name !== '') {
          node.#varIndex = context.varIndex++
        }
      }
      if (!pathErrorCheckOnly && name !== '') {
        paramMap.push([name, node.#varIndex as number])
      }
    } else {
      node = this.#children[token]
      if (!node) {
        if (
          Object.keys(this.#children).some(
            (k) =>
              k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
          )
        ) {
          throw PATH_ERROR
        }
        if (pathErrorCheckOnly) {
          return
        }
        node = this.#children[token] = new Node()
      }
    }

    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly)
  }

  buildRegExpStr(): string {
    const childKeys = Object.keys(this.#children).sort(compareKey)

    const strList = childKeys.map((k) => {
      const c = this.#children[k]
      return (
        (typeof c.#varIndex === 'number'
          ? `(${k})@${c.#varIndex}`
          : regExpMetaChars.has(k)
          ? `\\${k}`
          : k) + c.buildRegExpStr()
      )
    })

    if (typeof this.#index === 'number') {
      strList.unshift(`#${this.#index}`)
    }

    if (strList.length === 0) {
      return ''
    }
    if (strList.length === 1) {
      return strList[0]
    }

    return '(?:' + strList.join('|') + ')'
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/router/reg-exp-router/router.test.ts
```typescript
import type { ParamStash } from '../../router'
import { UnsupportedPathError } from '../../router'
import { runTest } from '../common.case.test'
import { RegExpRouter } from './router'

describe('RegExpRouter', () => {
  runTest({
    skip: [
      {
        reason: 'UnsupportedPath',
        tests: [
          'Duplicate param name > parent',
          'Duplicate param name > child',
          'Capture Group > Complex capturing group > GET request',
          'Capture complex multiple directories > GET /part1/middle-b/latest',
          'Capture complex multiple directories > GET /part1/middle-b/end-c/latest',
        ],
      },
      {
        reason: 'This route can not be added with `:label` to RegExpRouter. This is ambiguous',
        tests: ['Including slashes > GET /js/main.js'],
      },
    ],
    newRouter: () => new RegExpRouter(),
  })

  describe('Return value type', () => {
    it('Should return [[T, ParamIndexMap][], ParamStash]', () => {
      const router = new RegExpRouter<string>()
      router.add('GET', '/posts/:id', 'get post')

      const [res, stash] = router.match('GET', '/posts/1')
      expect(res.length).toBe(1)
      expect(res).toEqual([['get post', { id: 1 }]])
      expect((stash as ParamStash)[1]).toBe('1')
    })
  })

  describe('UnsupportedPathError', () => {
    describe('Ambiguous', () => {
      const router = new RegExpRouter<string>()

      router.add('GET', '/:user/entries', 'get user entries')
      router.add('GET', '/entry/:name', 'get entry')
      router.add('POST', '/entry', 'create entry')

      it('GET /entry/entries', () => {
        expect(() => {
          router.match('GET', '/entry/entries')
        }).toThrowError(UnsupportedPathError)
      })
    })

    describe('Multiple handlers with different label', () => {
      const router = new RegExpRouter<string>()

      router.add('GET', '/:type/:id', ':type')
      router.add('GET', '/:class/:id', ':class')
      router.add('GET', '/:model/:id', ':model')

      it('GET /entry/123', () => {
        expect(() => {
          router.match('GET', '/entry/123')
        }).toThrowError(UnsupportedPathError)
      })
    })

    it('parent', () => {
      const router = new RegExpRouter<string>()
      router.add('GET', '/:id/:action', 'foo')
      router.add('GET', '/posts/:id', 'bar')
      expect(() => {
        router.match('GET', '/')
      }).toThrowError(UnsupportedPathError)
    })

    it('child', () => {
      const router = new RegExpRouter<string>()
      router.add('GET', '/posts/:id', 'foo')
      router.add('GET', '/:id/:action', 'bar')

      expect(() => {
        router.match('GET', '/')
      }).toThrowError(UnsupportedPathError)
    })

    describe('static and dynamic', () => {
      it('static first', () => {
        const router = new RegExpRouter<string>()
        router.add('GET', '/reg-exp/router', 'foo')
        router.add('GET', '/reg-exp/:id', 'bar')

        expect(() => {
          router.match('GET', '/')
        }).toThrowError(UnsupportedPathError)
      })

      it('long label', () => {
        const router = new RegExpRouter<string>()
        router.add('GET', '/reg-exp/router', 'foo')
        router.add('GET', '/reg-exp/:service', 'bar')

        expect(() => {
          router.match('GET', '/')
        }).toThrowError(UnsupportedPathError)
      })

      it('dynamic first', () => {
        const router = new RegExpRouter<string>()
        router.add('GET', '/reg-exp/:id', 'bar')
        router.add('GET', '/reg-exp/router', 'foo')

        expect(() => {
          router.match('GET', '/')
        }).toThrowError(UnsupportedPathError)
      })
    })

    it('different regular expression', () => {
      const router = new RegExpRouter<string>()
      router.add('GET', '/:id/:action{create|update}', 'foo')
      router.add('GET', '/:id/:action{delete}', 'bar')
      expect(() => {
        router.match('GET', '/')
      }).toThrowError(UnsupportedPathError)
    })

    describe('Capture Group', () => {
      describe('Complex capturing group', () => {
        it('GET request', () => {
          const router = new RegExpRouter<string>()
          router.add('GET', '/foo/:capture{ba(r|z)}', 'ok')
          expect(() => {
            router.match('GET', '/foo/bar')
          }).toThrowError(UnsupportedPathError)
        })
      })
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/router/reg-exp-router/router.ts
```typescript
import type { ParamIndexMap, Result, Router } from '../../router'
import {
  MESSAGE_MATCHER_IS_ALREADY_BUILT,
  METHOD_NAME_ALL,
  UnsupportedPathError,
} from '../../router'
import { checkOptionalParameter } from '../../utils/url'
import { PATH_ERROR } from './node'
import type { ParamAssocArray } from './node'
import { Trie } from './trie'

type HandlerData<T> = [T, ParamIndexMap][]
type StaticMap<T> = Record<string, Result<T>>
type Matcher<T> = [RegExp, HandlerData<T>[], StaticMap<T>]
type HandlerWithMetadata<T> = [T, number] // [handler, paramCount]

const emptyParam: string[] = []
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const nullMatcher: Matcher<any> = [/^$/, [], Object.create(null)]

let wildcardRegExpCache: Record<string, RegExp> = Object.create(null)
function buildWildcardRegExp(path: string): RegExp {
  return (wildcardRegExpCache[path] ??= new RegExp(
    path === '*'
      ? ''
      : `^${path.replace(/\/\*$|([.\\+*[^\]$()])/g, (_, metaChar) =>
          metaChar ? `\\${metaChar}` : '(?:|/.*)'
        )}$`
  ))
}

function clearWildcardRegExpCache() {
  wildcardRegExpCache = Object.create(null)
}

function buildMatcherFromPreprocessedRoutes<T>(
  routes: [string, HandlerWithMetadata<T>[]][]
): Matcher<T> {
  const trie = new Trie()
  const handlerData: HandlerData<T>[] = []
  if (routes.length === 0) {
    return nullMatcher
  }

  const routesWithStaticPathFlag = routes
    .map(
      (route) => [!/\*|\/:/.test(route[0]), ...route] as [boolean, string, HandlerWithMetadata<T>[]]
    )
    .sort(([isStaticA, pathA], [isStaticB, pathB]) =>
      isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length
    )

  const staticMap: StaticMap<T> = Object.create(null)
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length; i < len; i++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i]
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h]) => [h, Object.create(null)]), emptyParam]
    } else {
      j++
    }

    let paramAssoc: ParamAssocArray
    try {
      paramAssoc = trie.insert(path, j, pathErrorCheckOnly)
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e
    }

    if (pathErrorCheckOnly) {
      continue
    }

    handlerData[j] = handlers.map(([h, paramCount]) => {
      const paramIndexMap: ParamIndexMap = Object.create(null)
      paramCount -= 1
      for (; paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount]
        paramIndexMap[key] = value
      }
      return [h, paramIndexMap]
    })
  }

  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp()
  for (let i = 0, len = handlerData.length; i < len; i++) {
    for (let j = 0, len = handlerData[i].length; j < len; j++) {
      const map = handlerData[i][j]?.[1]
      if (!map) {
        continue
      }
      const keys = Object.keys(map)
      for (let k = 0, len = keys.length; k < len; k++) {
        map[keys[k]] = paramReplacementMap[map[keys[k]]]
      }
    }
  }

  const handlerMap: HandlerData<T>[] = []
  // using `in` because indexReplacementMap is a sparse array
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]]
  }

  return [regexp, handlerMap, staticMap] as Matcher<T>
}

function findMiddleware<T>(
  middleware: Record<string, T[]> | undefined,
  path: string
): T[] | undefined {
  if (!middleware) {
    return undefined
  }

  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {
    if (buildWildcardRegExp(k).test(path)) {
      return [...middleware[k]]
    }
  }

  return undefined
}

export class RegExpRouter<T> implements Router<T> {
  name: string = 'RegExpRouter'
  #middleware?: Record<string, Record<string, HandlerWithMetadata<T>[]>>
  #routes?: Record<string, Record<string, HandlerWithMetadata<T>[]>>

  constructor() {
    this.#middleware = { [METHOD_NAME_ALL]: Object.create(null) }
    this.#routes = { [METHOD_NAME_ALL]: Object.create(null) }
  }

  add(method: string, path: string, handler: T) {
    const middleware = this.#middleware
    const routes = this.#routes

    if (!middleware || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT)
    }

    if (!middleware[method]) {
      ;[middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = Object.create(null)
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {
          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]]
        })
      })
    }

    if (path === '/*') {
      path = '*'
    }

    const paramCount = (path.match(/\/:/g) || []).length

    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path)
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m) => {
          middleware[m][path] ||=
            findMiddleware(middleware[m], path) ||
            findMiddleware(middleware[METHOD_NAME_ALL], path) ||
            []
        })
      } else {
        middleware[method][path] ||=
          findMiddleware(middleware[method], path) ||
          findMiddleware(middleware[METHOD_NAME_ALL], path) ||
          []
      }
      Object.keys(middleware).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(middleware[m]).forEach((p) => {
            re.test(p) && middleware[m][p].push([handler, paramCount])
          })
        }
      })

      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(routes[m]).forEach(
            (p) => re.test(p) && routes[m][p].push([handler, paramCount])
          )
        }
      })

      return
    }

    const paths = checkOptionalParameter(path) || [path]
    for (let i = 0, len = paths.length; i < len; i++) {
      const path = paths[i]

      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          routes[m][path] ||= [
            ...(findMiddleware(middleware[m], path) ||
              findMiddleware(middleware[METHOD_NAME_ALL], path) ||
              []),
          ]
          routes[m][path].push([handler, paramCount - len + i + 1])
        }
      })
    }
  }

  match(method: string, path: string): Result<T> {
    clearWildcardRegExpCache() // no longer used.

    const matchers = this.#buildAllMatchers()

    this.match = (method, path) => {
      const matcher = (matchers[method] || matchers[METHOD_NAME_ALL]) as Matcher<T>

      const staticMatch = matcher[2][path]
      if (staticMatch) {
        return staticMatch
      }

      const match = path.match(matcher[0])
      if (!match) {
        return [[], emptyParam]
      }

      const index = match.indexOf('', 1)
      return [matcher[1][index], match]
    }

    return this.match(method, path)
  }

  #buildAllMatchers(): Record<string, Matcher<T> | null> {
    const matchers: Record<string, Matcher<T> | null> = Object.create(null)

    Object.keys(this.#routes!)
      .concat(Object.keys(this.#middleware!))
      .forEach((method) => {
        matchers[method] ||= this.#buildMatcher(method)
      })

    // Release cache
    this.#middleware = this.#routes = undefined

    return matchers
  }

  #buildMatcher(method: string): Matcher<T> | null {
    const routes: [string, HandlerWithMetadata<T>[]][] = []

    let hasOwnRoute = method === METHOD_NAME_ALL

    ;[this.#middleware!, this.#routes!].forEach((r) => {
      const ownRoute = r[method]
        ? Object.keys(r[method]).map((path) => [path, r[method][path]])
        : []
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true
        routes.push(...(ownRoute as [string, HandlerWithMetadata<T>[]][]))
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(
          ...(Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]]) as [
            string,
            HandlerWithMetadata<T>[]
          ][])
        )
      }
    })

    if (!hasOwnRoute) {
      return null
    } else {
      return buildMatcherFromPreprocessedRoutes(routes)
    }
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/router/reg-exp-router/trie.ts
```typescript
import type { Context, ParamAssocArray } from './node'
import { Node } from './node'

export type ReplacementMap = number[]

export class Trie {
  #context: Context = { varIndex: 0 }
  #root: Node = new Node()

  insert(path: string, index: number, pathErrorCheckOnly: boolean): ParamAssocArray {
    const paramAssoc: ParamAssocArray = []

    const groups: [string, string][] = [] // [mark, original string]
    for (let i = 0; ; ) {
      let replaced = false
      path = path.replace(/\{[^}]+\}/g, (m) => {
        const mark = `@\\${i}`
        groups[i] = [mark, m]
        i++
        replaced = true
        return mark
      })
      if (!replaced) {
        break
      }
    }

    /**
     *  - pattern (:label, :label{0-9]+}, ...)
     *  - /* wildcard
     *  - character
     */
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || []
    for (let i = groups.length - 1; i >= 0; i--) {
      const [mark] = groups[i]
      for (let j = tokens.length - 1; j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i][1])
          break
        }
      }
    }

    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly)

    return paramAssoc
  }

  buildRegExp(): [RegExp, ReplacementMap, ReplacementMap] {
    let regexp = this.#root.buildRegExpStr()
    if (regexp === '') {
      return [/^$/, [], []] // never match
    }

    let captureIndex = 0
    const indexReplacementMap: ReplacementMap = []
    const paramReplacementMap: ReplacementMap = []

    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (handlerIndex !== undefined) {
        indexReplacementMap[++captureIndex] = Number(handlerIndex)
        return '$()'
      }
      if (paramIndex !== undefined) {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex
        return ''
      }

      return ''
    })

    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap]
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/router/smart-router/index.ts
```typescript
/**
 * @module
 * SmartRouter for Hono.
 */

export { SmartRouter } from './router'

```
/Users/josh/Documents/GitHub/honojs/hono/src/router/smart-router/router.test.ts
```typescript
import { runTest } from '../common.case.test'
import { RegExpRouter } from '../reg-exp-router'
import { TrieRouter } from '../trie-router'
import { SmartRouter } from './router'

describe('SmartRouter', () => {
  runTest({
    newRouter: () =>
      new SmartRouter({
        routers: [new RegExpRouter(), new TrieRouter()],
      }),
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/router/smart-router/router.ts
```typescript
import type { Result, Router } from '../../router'
import { MESSAGE_MATCHER_IS_ALREADY_BUILT, UnsupportedPathError } from '../../router'

export class SmartRouter<T> implements Router<T> {
  name: string = 'SmartRouter'
  #routers: Router<T>[] = []
  #routes?: [string, string, T][] = []

  constructor(init: { routers: Router<T>[] }) {
    this.#routers = init.routers
  }

  add(method: string, path: string, handler: T) {
    if (!this.#routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT)
    }

    this.#routes.push([method, path, handler])
  }

  match(method: string, path: string): Result<T> {
    if (!this.#routes) {
      throw new Error('Fatal error')
    }

    const routers = this.#routers
    const routes = this.#routes

    const len = routers.length
    let i = 0
    let res
    for (; i < len; i++) {
      const router = routers[i]
      try {
        for (let i = 0, len = routes.length; i < len; i++) {
          router.add(...routes[i])
        }
        res = router.match(method, path)
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue
        }
        throw e
      }

      this.match = router.match.bind(router)
      this.#routers = [router]
      this.#routes = undefined
      break
    }

    if (i === len) {
      // not found
      throw new Error('Fatal error')
    }

    // e.g. "SmartRouter + RegExpRouter"
    this.name = `SmartRouter + ${this.activeRouter.name}`

    return res as Result<T>
  }

  get activeRouter(): Router<T> {
    if (this.#routes || this.#routers.length !== 1) {
      throw new Error('No active router has been determined yet.')
    }

    return this.#routers[0]
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/router/pattern-router/index.ts
```typescript
/**
 * @module
 * PatternRouter for Hono.
 */

export { PatternRouter } from './router'

```
/Users/josh/Documents/GitHub/honojs/hono/src/router/pattern-router/router.test.ts
```typescript
import { UnsupportedPathError } from '../../router'
import { runTest } from '../common.case.test'
import { PatternRouter } from './router'

describe('Pattern', () => {
  runTest({
    skip: [
      {
        reason: 'UnsupportedPath',
        tests: ['Duplicate param name > self'],
      },
      {
        reason: 'PatternRouter allows trailing slashes',
        tests: ['Trailing slash > GET /book/'],
      },
    ],
    newRouter: () => new PatternRouter(),
  })

  describe('Duplicate param name', () => {
    it('self', () => {
      const router = new PatternRouter<string>()
      expect(() => {
        router.add('GET', '/:id/:id', 'foo')
      }).toThrowError(UnsupportedPathError)
    })
  })
  describe('Trailing slash', () => {
    const router = new PatternRouter<string>()

    beforeEach(() => {
      router.add('GET', '/book', 'GET /book')
      router.add('GET', '/book/:id', 'GET /book/:id')
    })

    it('GET /book/', () => {
      const [res] = router.match('GET', '/book/')
      expect(res.length).toBe(1)
      expect(res[0][0]).toBe('GET /book')
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/router/pattern-router/router.ts
```typescript
import type { Params, Result, Router } from '../../router'
import { METHOD_NAME_ALL, UnsupportedPathError } from '../../router'

type Route<T> = [RegExp, string, T] // [pattern, method, handler]

const emptyParams = Object.create(null)

export class PatternRouter<T> implements Router<T> {
  name: string = 'PatternRouter'
  #routes: Route<T>[] = []

  add(method: string, path: string, handler: T) {
    const endsWithWildcard = path.at(-1) === '*'
    if (endsWithWildcard) {
      path = path.slice(0, -2)
    }
    if (path.at(-1) === '?') {
      path = path.slice(0, -1)
      this.add(method, path.replace(/\/[^/]+$/, ''), handler)
    }

    const parts = (path.match(/\/?(:\w+(?:{(?:(?:{[\d,]+})|[^}])+})?)|\/?[^\/\?]+/g) || []).map(
      (part) => {
        const match = part.match(/^\/:([^{]+)(?:{(.*)})?/)
        return match
          ? `/(?<${match[1]}>${match[2] || '[^/]+'})`
          : part === '/*'
          ? '/[^/]+'
          : part.replace(/[.\\+*[^\]$()]/g, '\\$&')
      }
    )

    try {
      this.#routes.push([
        new RegExp(`^${parts.join('')}${endsWithWildcard ? '' : '/?$'}`),
        method,
        handler,
      ])
    } catch {
      throw new UnsupportedPathError()
    }
  }

  match(method: string, path: string): Result<T> {
    const handlers: [T, Params][] = []

    for (let i = 0, len = this.#routes.length; i < len; i++) {
      const [pattern, routeMethod, handler] = this.#routes[i]

      if (routeMethod === method || routeMethod === METHOD_NAME_ALL) {
        const match = pattern.exec(path)
        if (match) {
          handlers.push([handler, match.groups || emptyParams])
        }
      }
    }

    return [handlers]
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/router/linear-router/index.ts
```typescript
/**
 * @module
 * LinearRouter for Hono.
 */

export { LinearRouter } from './router'

```
/Users/josh/Documents/GitHub/honojs/hono/src/router/linear-router/router.test.ts
```typescript
import { UnsupportedPathError } from '../../router'
import { runTest } from '../common.case.test'
import { LinearRouter } from './router'

describe('LinearRouter', () => {
  runTest({
    skip: [
      {
        reason: 'UnsupportedPath',
        tests: [
          'Multi match > `params` per a handler > GET /entry/123/show',
          'Capture regex pattern has trailing wildcard > GET /foo/bar/file.html',
        ],
      },
      {
        reason: 'LinearRouter allows trailing slashes',
        tests: ['Trailing slash > GET /book/'],
      },
    ],
    newRouter: () => new LinearRouter(),
  })

  describe('Multi match', () => {
    describe('`params` per a handler', () => {
      const router = new LinearRouter<string>()

      beforeEach(() => {
        router.add('ALL', '*', 'middleware a')
        router.add('GET', '/entry/:id/*', 'middleware b')
        router.add('GET', '/entry/:id/:action', 'action')
      })

      it('GET /entry/123/show', () => {
        expect(() => {
          router.match('GET', '/entry/123/show')
        }).toThrowError(UnsupportedPathError)
      })
    })
  })

  describe('Trailing slash', () => {
    const router = new LinearRouter<string>()

    beforeEach(() => {
      router.add('GET', '/book', 'GET /book')
      router.add('GET', '/book/:id', 'GET /book/:id')
    })

    it('GET /book/', () => {
      const [res] = router.match('GET', '/book/')
      expect(res.length).toBe(1)
      expect(res[0][0]).toBe('GET /book')
    })
  })

  describe('Skip part', () => {
    const router = new LinearRouter<string>()

    beforeEach(() => {
      router.add('GET', '/products/:id{d+}', 'GET /products/:id{d+}')
    })

    it('GET /products/list', () => {
      const [res] = router.match('GET', '/products/list')
      expect(res.length).toBe(0)
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/router/linear-router/router.ts
```typescript
import type { Params, Result, Router } from '../../router'
import { METHOD_NAME_ALL, UnsupportedPathError } from '../../router'
import { checkOptionalParameter } from '../../utils/url'

type RegExpMatchArrayWithIndices = RegExpMatchArray & { indices: [number, number][] }

const emptyParams = Object.create(null)

const splitPathRe = /\/(:\w+(?:{(?:(?:{[\d,]+})|[^}])+})?)|\/[^\/\?]+|(\?)/g
const splitByStarRe = /\*/
export class LinearRouter<T> implements Router<T> {
  name: string = 'LinearRouter'
  #routes: [string, string, T][] = []

  add(method: string, path: string, handler: T) {
    for (
      let i = 0, paths = checkOptionalParameter(path) || [path], len = paths.length;
      i < len;
      i++
    ) {
      this.#routes.push([method, paths[i], handler])
    }
  }

  match(method: string, path: string): Result<T> {
    const handlers: [T, Params][] = []
    ROUTES_LOOP: for (let i = 0, len = this.#routes.length; i < len; i++) {
      const [routeMethod, routePath, handler] = this.#routes[i]
      if (routeMethod === method || routeMethod === METHOD_NAME_ALL) {
        if (routePath === '*' || routePath === '/*') {
          handlers.push([handler, emptyParams])
          continue
        }

        const hasStar = routePath.indexOf('*') !== -1
        const hasLabel = routePath.indexOf(':') !== -1
        if (!hasStar && !hasLabel) {
          if (routePath === path || routePath + '/' === path) {
            handlers.push([handler, emptyParams])
          }
        } else if (hasStar && !hasLabel) {
          const endsWithStar = routePath.charCodeAt(routePath.length - 1) === 42
          const parts = (endsWithStar ? routePath.slice(0, -2) : routePath).split(splitByStarRe)

          const lastIndex = parts.length - 1
          for (let j = 0, pos = 0, len = parts.length; j < len; j++) {
            const part = parts[j]
            const index = path.indexOf(part, pos)
            if (index !== pos) {
              continue ROUTES_LOOP
            }
            pos += part.length
            if (j === lastIndex) {
              if (
                !endsWithStar &&
                pos !== path.length &&
                !(pos === path.length - 1 && path.charCodeAt(pos) === 47)
              ) {
                continue ROUTES_LOOP
              }
            } else {
              const index = path.indexOf('/', pos)
              if (index === -1) {
                continue ROUTES_LOOP
              }
              pos = index
            }
          }
          handlers.push([handler, emptyParams])
        } else if (hasLabel && !hasStar) {
          const params: Record<string, string> = Object.create(null)
          const parts = routePath.match(splitPathRe) as string[]

          const lastIndex = parts.length - 1
          for (let j = 0, pos = 0, len = parts.length; j < len; j++) {
            if (pos === -1 || pos >= path.length) {
              continue ROUTES_LOOP
            }

            const part = parts[j]
            if (part.charCodeAt(1) === 58) {
              // /:label
              let name = part.slice(2)
              let value

              if (name.charCodeAt(name.length - 1) === 125) {
                // :label{pattern}
                const openBracePos = name.indexOf('{')
                const next = parts[j + 1]
                const lookahead = next && next[1] !== ':' && next[1] !== '*' ? `(?=${next})` : ''
                const pattern = name.slice(openBracePos + 1, -1) + lookahead
                const restPath = path.slice(pos + 1)
                const match = new RegExp(pattern, 'd').exec(restPath) as RegExpMatchArrayWithIndices
                if (!match || match.indices[0][0] !== 0 || match.indices[0][1] === 0) {
                  continue ROUTES_LOOP
                }
                name = name.slice(0, openBracePos)
                value = restPath.slice(...match.indices[0])
                pos += match.indices[0][1] + 1
              } else {
                let endValuePos = path.indexOf('/', pos + 1)
                if (endValuePos === -1) {
                  if (pos + 1 === path.length) {
                    continue ROUTES_LOOP
                  }
                  endValuePos = path.length
                }
                value = path.slice(pos + 1, endValuePos)
                pos = endValuePos
              }

              params[name] ||= value as string
            } else {
              const index = path.indexOf(part, pos)
              if (index !== pos) {
                continue ROUTES_LOOP
              }
              pos += part.length
            }

            if (j === lastIndex) {
              if (
                pos !== path.length &&
                !(pos === path.length - 1 && path.charCodeAt(pos) === 47)
              ) {
                continue ROUTES_LOOP
              }
            }
          }

          handlers.push([handler, params])
        } else if (hasLabel && hasStar) {
          throw new UnsupportedPathError()
        }
      }
    }

    return [handlers]
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/router/trie-router/index.ts
```typescript
/**
 * @module
 * TrieRouter for Hono.
 */

export { TrieRouter } from './router'

```
/Users/josh/Documents/GitHub/honojs/hono/src/router/trie-router/node.test.ts
```typescript
import { Node } from './node'

describe('Root Node', () => {
  const node = new Node()
  node.insert('get', '/', 'get root')
  it('get /', () => {
    const [res] = node.search('get', '/')
    expect(res).not.toBeNull()
    expect(res[0][0]).toEqual('get root')
    expect(node.search('get', '/hello')[0].length).toBe(0)
  })
})

describe('Root Node is not defined', () => {
  const node = new Node()
  node.insert('get', '/hello', 'get hello')
  it('get /', () => {
    expect(node.search('get', '/')[0]).toEqual([])
  })
})

describe('Get with *', () => {
  const node = new Node()
  node.insert('get', '*', 'get all')
  it('get /', () => {
    expect(node.search('get', '/')[0].length).toBe(1)
    expect(node.search('get', '/hello')[0].length).toBe(1)
  })
})

describe('Get with * including JS reserved words', () => {
  const node = new Node()
  node.insert('get', '*', 'get all')
  it('get /', () => {
    expect(node.search('get', '/hello/constructor')[0].length).toBe(1)
    expect(node.search('get', '/hello/__proto__')[0].length).toBe(1)
  })
})

describe('Basic Usage', () => {
  const node = new Node()
  node.insert('get', '/hello', 'get hello')
  node.insert('post', '/hello', 'post hello')
  node.insert('get', '/hello/foo', 'get hello foo')

  it('get, post /hello', () => {
    expect(node.search('get', '/')[0].length).toBe(0)
    expect(node.search('post', '/')[0].length).toBe(0)

    expect(node.search('get', '/hello')[0][0][0]).toEqual('get hello')
    expect(node.search('post', '/hello')[0][0][0]).toEqual('post hello')
    expect(node.search('put', '/hello')[0].length).toBe(0)
  })
  it('get /nothing', () => {
    expect(node.search('get', '/nothing')[0].length).toBe(0)
  })
  it('/hello/foo, /hello/bar', () => {
    expect(node.search('get', '/hello/foo')[0][0][0]).toEqual('get hello foo')
    expect(node.search('post', '/hello/foo')[0].length).toBe(0)
    expect(node.search('get', '/hello/bar')[0].length).toBe(0)
  })
  it('/hello/foo/bar', () => {
    expect(node.search('get', '/hello/foo/bar')[0].length).toBe(0)
  })
})

describe('Name path', () => {
  const node = new Node()
  node.insert('get', '/entry/:id', 'get entry')
  node.insert('get', '/entry/:id/comment/:comment_id', 'get comment')
  node.insert('get', '/map/:location/events', 'get events')
  node.insert('get', '/about/:name/address/map', 'get address')

  it('get /entry/123', () => {
    const [res] = node.search('get', '/entry/123')
    expect(res.length).toBe(1)
    expect(res[0][0]).toEqual('get entry')
    expect(res[0][1]).not.toBeNull()
    expect(res[0][1]['id']).toBe('123')
    expect(res[0][1]['id']).not.toBe('1234')
  })

  it('get /entry/456/comment', () => {
    const [res] = node.search('get', '/entry/456/comment')
    expect(res.length).toBe(0)
  })

  it('get /entry/789/comment/123', () => {
    const [res] = node.search('get', '/entry/789/comment/123')
    expect(res.length).toBe(1)
    expect(res[0][0]).toEqual('get comment')
    expect(res[0][1]['id']).toBe('789')
    expect(res[0][1]['comment_id']).toBe('123')
  })

  it('get /map/:location/events', () => {
    const [res] = node.search('get', '/map/yokohama/events')
    expect(res.length).toBe(1)
    expect(res[0][0]).toEqual('get events')
    expect(res[0][1]['location']).toBe('yokohama')
  })

  it('get /about/:name/address/map', () => {
    const [res] = node.search('get', '/about/foo/address/map')
    expect(res.length).toBe(1)
    expect(res[0][0]).toEqual('get address')
    expect(res[0][1]['name']).toBe('foo')
  })

  it('Should not return a previous param value', () => {
    const node = new Node()
    node.insert('delete', '/resource/:id', 'resource')
    const [resA] = node.search('delete', '/resource/a')
    const [resB] = node.search('delete', '/resource/b')
    expect(resA).not.toBeNull()
    expect(resA.length).toBe(1)
    expect(resA[0][0]).toEqual('resource')
    expect(resA[0][1]).toEqual({ id: 'a' })
    expect(resB).not.toBeNull()
    expect(resB.length).toBe(1)
    expect(resB[0][0]).toEqual('resource')
    expect(resB[0][1]).toEqual({ id: 'b' })
  })

  it('Should return a sorted values', () => {
    const node = new Node()
    node.insert('get', '/resource/a', 'A')
    node.insert('get', '/resource/*', 'Star')
    const [res] = node.search('get', '/resource/a')
    expect(res).not.toBeNull()
    expect(res.length).toBe(2)
    expect(res[0][0]).toEqual('A')
    expect(res[1][0]).toEqual('Star')
  })
})

describe('Name path - Multiple route', () => {
  const node = new Node()

  node.insert('get', '/:type/:id', 'common')
  node.insert('get', '/posts/:id', 'specialized')

  it('get /posts/123', () => {
    const [res] = node.search('get', '/posts/123')
    expect(res.length).toBe(2)
    expect(res[0][0]).toEqual('common')
    expect(res[0][1]['id']).toBe('123')
    expect(res[1][0]).toEqual('specialized')
    expect(res[1][1]['id']).toBe('123')
  })
})

describe('Param prefix', () => {
  const node = new Node()

  node.insert('get', '/:foo', 'onepart')
  node.insert('get', '/:bar/:baz', 'twopart')

  it('get /hello', () => {
    const [res] = node.search('get', '/hello')
    expect(res.length).toBe(1)
    expect(res[0][0]).toEqual('onepart')
    expect(res[0][1]['foo']).toBe('hello')
  })

  it('get /hello/world', () => {
    const [res] = node.search('get', '/hello/world')
    expect(res.length).toBe(1)
    expect(res[0][0]).toEqual('twopart')
    expect(res[0][1]['bar']).toBe('hello')
    expect(res[0][1]['baz']).toBe('world')
  })
})

describe('Named params and a wildcard', () => {
  const node = new Node()

  node.insert('get', '/:id/*', 'onepart')

  it('get /', () => {
    const [res] = node.search('get', '/')
    expect(res.length).toBe(0)
  })

  it('get /foo', () => {
    const [res] = node.search('get', '/foo')
    expect(res.length).toBe(1)
    expect(res[0][0]).toEqual('onepart')
    expect(res[0][1]['id']).toEqual('foo')
  })

  it('get /foo/bar', () => {
    const [res] = node.search('get', '/foo/bar')
    expect(res.length).toBe(1)
    expect(res[0][0]).toEqual('onepart')
    expect(res[0][1]['id']).toEqual('foo')
  })
})

describe('Wildcard', () => {
  const node = new Node()
  node.insert('get', '/wildcard-abc/*/wildcard-efg', 'wildcard')
  it('/wildcard-abc/xxxxxx/wildcard-efg', () => {
    const [res] = node.search('get', '/wildcard-abc/xxxxxx/wildcard-efg')
    expect(res.length).toBe(1)
    expect(res[0][0]).toEqual('wildcard')
  })
  node.insert('get', '/wildcard-abc/*/wildcard-efg/hijk', 'wildcard')
  it('/wildcard-abc/xxxxxx/wildcard-efg/hijk', () => {
    const [res] = node.search('get', '/wildcard-abc/xxxxxx/wildcard-efg/hijk')
    expect(res.length).toBe(1)
    expect(res[0][0]).toEqual('wildcard')
  })
})

describe('Regexp', () => {
  const node = new Node()
  node.insert('get', '/regex-abc/:id{[0-9]+}/comment/:comment_id{[a-z]+}', 'regexp')
  it('/regexp-abc/123/comment/abc', () => {
    const [res] = node.search('get', '/regex-abc/123/comment/abc')
    expect(res.length).toBe(1)
    expect(res[0][0]).toEqual('regexp')
    expect(res[0][1]['id']).toBe('123')
    expect(res[0][1]['comment_id']).toBe('abc')
  })
  it('/regexp-abc/abc', () => {
    const [res] = node.search('get', '/regex-abc/abc')
    expect(res.length).toBe(0)
  })
  it('/regexp-abc/123/comment/123', () => {
    const [res] = node.search('get', '/regex-abc/123/comment/123')
    expect(res.length).toBe(0)
  })
})

describe('All', () => {
  const node = new Node()
  node.insert('ALL', '/all-methods', 'all methods') // ALL
  it('/all-methods', () => {
    let [res] = node.search('get', '/all-methods')
    expect(res.length).toBe(1)
    expect(res[0][0]).toEqual('all methods')
    ;[res] = node.search('put', '/all-methods')
    expect(res.length).toBe(1)
    expect(res[0][0]).toEqual('all methods')
  })
})

describe('Special Wildcard', () => {
  const node = new Node()
  node.insert('ALL', '*', 'match all')

  it('/foo', () => {
    const [res] = node.search('get', '/foo')
    expect(res.length).toBe(1)
    expect(res[0][0]).toEqual('match all')
  })
  it('/hello', () => {
    const [res] = node.search('get', '/hello')
    expect(res.length).toBe(1)
    expect(res[0][0]).toEqual('match all')
  })
  it('/hello/foo', () => {
    const [res] = node.search('get', '/hello/foo')
    expect(res.length).toBe(1)
    expect(res[0][0]).toEqual('match all')
  })
})

describe('Special Wildcard deeply', () => {
  const node = new Node()
  node.insert('ALL', '/hello/*', 'match hello')
  it('/hello', () => {
    const [res] = node.search('get', '/hello')
    expect(res.length).toBe(1)
    expect(res[0][0]).toEqual('match hello')
  })
  it('/hello/foo', () => {
    const [res] = node.search('get', '/hello/foo')
    expect(res.length).toBe(1)
    expect(res[0][0]).toEqual('match hello')
  })
})

describe('Default with wildcard', () => {
  const node = new Node()
  node.insert('ALL', '/api/*', 'fallback')
  node.insert('ALL', '/api/abc', 'match api')
  it('/api/abc', () => {
    const [res] = node.search('get', '/api/abc')
    expect(res.length).toBe(2)
    expect(res[0][0]).toEqual('fallback')
    expect(res[1][0]).toEqual('match api')
  })
  it('/api/def', () => {
    const [res] = node.search('get', '/api/def')
    expect(res.length).toBe(1)
    expect(res[0][0]).toEqual('fallback')
  })
})

describe('Multi match', () => {
  describe('Basic', () => {
    const node = new Node()
    node.insert('get', '*', 'GET *')
    node.insert('get', '/abc/*', 'GET /abc/*')
    node.insert('get', '/abc/*/edf', 'GET /abc/*/edf')
    node.insert('get', '/abc/edf', 'GET /abc/edf')
    node.insert('get', '/abc/*/ghi/jkl', 'GET /abc/*/ghi/jkl')
    it('get /abc/edf', () => {
      const [res] = node.search('get', '/abc/edf')
      expect(res.length).toBe(3)
      expect(res[0][0]).toEqual('GET *')
      expect(res[1][0]).toEqual('GET /abc/*')
      expect(res[2][0]).toEqual('GET /abc/edf')
    })
    it('get /abc/xxx/edf', () => {
      const [res] = node.search('get', '/abc/xxx/edf')
      expect(res.length).toBe(3)
      expect(res[0][0]).toEqual('GET *')
      expect(res[1][0]).toEqual('GET /abc/*')
      expect(res[2][0]).toEqual('GET /abc/*/edf')
    })
    it('get /', () => {
      const [res] = node.search('get', '/')
      expect(res.length).toBe(1)
      expect(res[0][0]).toEqual('GET *')
    })
    it('post /', () => {
      const [res] = node.search('post', '/')
      expect(res.length).toBe(0)
    })
    it('get /abc/edf/ghi', () => {
      const [res] = node.search('get', '/abc/edf/ghi')
      expect(res.length).toBe(2)
      expect(res[0][0]).toEqual('GET *')
      expect(res[1][0]).toEqual('GET /abc/*')
    })
  })
  describe('Blog', () => {
    const node = new Node()
    node.insert('get', '*', 'middleware a') // 0.1
    node.insert('ALL', '*', 'middleware b') // 0.2 <===
    node.insert('get', '/entry', 'get entries') // 1.3
    node.insert('post', '/entry/*', 'middleware c') // 1.4 <===
    node.insert('post', '/entry', 'post entry') // 1.5 <===
    node.insert('get', '/entry/:id', 'get entry') // 2.6
    node.insert('get', '/entry/:id/comment/:comment_id', 'get comment') // 4.7
    it('get /entry/123', async () => {
      const [res] = node.search('get', '/entry/123')
      expect(res.length).toBe(3)
      expect(res[0][0]).toEqual('middleware a')
      expect(res[0][1]['id']).toBe(undefined)
      expect(res[1][0]).toEqual('middleware b')
      expect(res[1][1]['id']).toBe(undefined)
      expect(res[2][0]).toEqual('get entry')
      expect(res[2][1]['id']).toBe('123')
    })
    it('get /entry/123/comment/456', async () => {
      const [res] = node.search('get', '/entry/123/comment/456')
      expect(res.length).toBe(3)
      expect(res[0][0]).toEqual('middleware a')
      expect(res[0][1]['id']).toBe(undefined)
      expect(res[0][1]['comment_id']).toBe(undefined)
      expect(res[1][0]).toEqual('middleware b')
      expect(res[1][1]['id']).toBe(undefined)
      expect(res[1][1]['comment_id']).toBe(undefined)
      expect(res[2][0]).toEqual('get comment')
      expect(res[2][1]['id']).toBe('123')
      expect(res[2][1]['comment_id']).toBe('456')
    })
    it('post /entry', async () => {
      const [res] = node.search('post', '/entry')
      expect(res.length).toBe(3)
      expect(res[0][0]).toEqual('middleware b')
      expect(res[1][0]).toEqual('middleware c')
      expect(res[2][0]).toEqual('post entry')
    })
    it('delete /entry', async () => {
      const [res] = node.search('delete', '/entry')
      expect(res.length).toBe(1)
      expect(res[0][0]).toEqual('middleware b')
    })
  })
  describe('ALL', () => {
    const node = new Node()
    node.insert('ALL', '*', 'ALL *')
    node.insert('ALL', '/abc/*', 'ALL /abc/*')
    node.insert('ALL', '/abc/*/def', 'ALL /abc/*/def')
    it('get /', () => {
      const [res] = node.search('get', '/')
      expect(res.length).toBe(1)
      expect(res[0][0]).toEqual('ALL *')
    })
    it('post /abc', () => {
      const [res] = node.search('post', '/abc')
      expect(res.length).toBe(2)
      expect(res[0][0]).toEqual('ALL *')
      expect(res[1][0]).toEqual('ALL /abc/*')
    })
    it('delete /abc/xxx/def', () => {
      const [res] = node.search('post', '/abc/xxx/def')
      expect(res.length).toBe(3)
      expect(res[0][0]).toEqual('ALL *')
      expect(res[1][0]).toEqual('ALL /abc/*')
      expect(res[2][0]).toEqual('ALL /abc/*/def')
    })
  })
  describe('Regexp', () => {
    const node = new Node()
    node.insert('get', '/regex-abc/:id{[0-9]+}/*', 'middleware a')
    node.insert('get', '/regex-abc/:id{[0-9]+}/def', 'regexp')
    it('/regexp-abc/123/def', () => {
      const [res] = node.search('get', '/regex-abc/123/def')
      expect(res.length).toBe(2)
      expect(res[0][0]).toEqual('middleware a')
      expect(res[0][1]['id']).toBe('123')
      expect(res[1][0]).toEqual('regexp')
      expect(res[1][1]['id']).toBe('123')
    })
    it('/regexp-abc/123', () => {
      const [res] = node.search('get', '/regex-abc/123/ghi')
      expect(res.length).toBe(1)
      expect(res[0][0]).toEqual('middleware a')
    })
  })
  describe('Trailing slash', () => {
    const node = new Node()
    node.insert('get', '/book', 'GET /book')
    node.insert('get', '/book/:id', 'GET /book/:id')
    it('get /book', () => {
      const [res] = node.search('get', '/book')
      expect(res.length).toBe(1)
    })
    it('get /book/', () => {
      const [res] = node.search('get', '/book/')
      expect(res.length).toBe(0)
    })
  })
  describe('Same path', () => {
    const node = new Node()
    node.insert('get', '/hey', 'Middleware A')
    node.insert('get', '/hey', 'Middleware B')
    it('get /hey', () => {
      const [res] = node.search('get', '/hey')
      expect(res.length).toBe(2)
      expect(res[0][0]).toEqual('Middleware A')
      expect(res[1][0]).toEqual('Middleware B')
    })
  })
  describe('Including slashes', () => {
    const node = new Node()
    node.insert('get', '/js/:filename{[a-z0-9/]+.js}', 'any file')
    node.insert('get', '/js/main.js', 'main.js')
    it('get /js/main.js', () => {
      const [res] = node.search('get', '/js/main.js')
      expect(res.length).toBe(2)
      expect(res[0][0]).toEqual('any file')
      expect(res[0][1]).toEqual({ filename: 'main.js' })
      expect(res[1][0]).toEqual('main.js')
      expect(res[1][1]).toEqual({})
    })
    it('get /js/chunk/123.js', () => {
      const [res] = node.search('get', '/js/chunk/123.js')
      expect(res.length).toBe(1)
      expect(res[0][0]).toEqual('any file')
      expect(res[0][1]).toEqual({ filename: 'chunk/123.js' })
    })
    it('get /js/chunk/nest/123.js', () => {
      const [res] = node.search('get', '/js/chunk/nest/123.js')
      expect(res.length).toBe(1)
      expect(res[0][0]).toEqual('any file')
      expect(res[0][1]).toEqual({ filename: 'chunk/nest/123.js' })
    })
  })
  describe('REST API', () => {
    const node = new Node()
    node.insert('get', '/users/:username{[a-z]+}', 'profile')
    node.insert('get', '/users/:username{[a-z]+}/posts', 'posts')
    it('get /users/hono', () => {
      const [res] = node.search('get', '/users/hono')
      expect(res.length).toBe(1)
      expect(res[0][0]).toEqual('profile')
    })
    it('get /users/hono/posts', () => {
      const [res] = node.search('get', '/users/hono/posts')
      expect(res.length).toBe(1)
      expect(res[0][0]).toEqual('posts')
    })
  })
})

describe('Duplicate param name', () => {
  it('self', () => {
    const node = new Node()
    node.insert('get', '/:id/:id', 'foo')
    const [res] = node.search('get', '/123/456')
    expect(res.length).toBe(1)
    expect(res[0][0]).toBe('foo')
    expect(res[0][1]['id']).toBe('123')
  })

  describe('parent', () => {
    const node = new Node()
    node.insert('get', '/:id/:action', 'foo')
    node.insert('get', '/posts/:id', 'bar')
    node.insert('get', '/posts/:id/comments/:comment_id', 'comment')

    it('get /123/action', () => {
      const [res] = node.search('get', '/123/action')
      expect(res.length).toBe(1)
      expect(res[0][0]).toBe('foo')
      expect(res[0][1]).toEqual({ id: '123', action: 'action' })
    })
  })

  it('get /posts/456 for comments', () => {
    const node = new Node()
    node.insert('get', '/posts/:id/comments/:comment_id', 'comment')
    const [res] = node.search('get', '/posts/abc/comments/edf')
    expect(res.length).toBe(1)
    expect(res[0][0]).toBe('comment')
    expect(res[0][1]).toEqual({ id: 'abc', comment_id: 'edf' })
  })

  describe('child', () => {
    const node = new Node()
    node.insert('get', '/posts/:id', 'foo')
    node.insert('get', '/:id/:action', 'bar')
    it('get /posts/action', () => {
      const [res] = node.search('get', '/posts/action')
      expect(res.length).toBe(2)
      expect(res[0][0]).toBe('foo')
      expect(res[0][1]).toEqual({ id: 'action' })
      expect(res[1][0]).toBe('bar')
      expect(res[1][1]).toEqual({ id: 'posts', action: 'action' })
    })
  })

  describe('regular expression', () => {
    const node = new Node()
    node.insert('get', '/:id/:action{create|update}', 'foo')
    node.insert('get', '/:id/:action{delete}', 'bar')
    it('get /123/create', () => {
      const [res] = node.search('get', '/123/create')
      expect(res.length).toBe(1)
      expect(res[0][0]).toBe('foo')
      expect(res[0][1]).toEqual({ id: '123', action: 'create' })
    })
    it('get /123/delete', () => {
      const [res] = node.search('get', '/123/delete')
      expect(res.length).toBe(1)
      expect(res[0][0]).toBe('bar')
      expect(res[0][1]).toEqual({ id: '123', action: 'delete' })
    })
  })
})

describe('Sort Order', () => {
  describe('Basic', () => {
    const node = new Node()
    node.insert('get', '*', 'a')
    node.insert('get', '/page', '/page')
    node.insert('get', '/:slug', '/:slug')

    it('get /page', () => {
      const [res] = node.search('get', '/page')
      expect(res.length).toBe(3)
      expect(res[0][0]).toEqual('a')
      expect(res[1][0]).toEqual('/page')
      expect(res[2][0]).toEqual('/:slug')
    })
  })

  describe('With Named path', () => {
    const node = new Node()
    node.insert('get', '*', 'a')
    node.insert('get', '/posts/:id', '/posts/:id')
    node.insert('get', '/:type/:id', '/:type/:id')

    it('get /posts/123', () => {
      const [res] = node.search('get', '/posts/123')
      expect(res.length).toBe(3)
      expect(res[0][0]).toEqual('a')
      expect(res[1][0]).toEqual('/posts/:id')
      expect(res[2][0]).toEqual('/:type/:id')
    })
  })

  describe('With Wildcards', () => {
    const node = new Node()
    node.insert('get', '/api/*', '1st')
    node.insert('get', '/api/*', '2nd')
    node.insert('get', '/api/posts/:id', '3rd')
    node.insert('get', '/api/*', '4th')

    it('get /api/posts/123', () => {
      const [res] = node.search('get', '/api/posts/123')
      expect(res.length).toBe(4)
      expect(res[0][0]).toEqual('1st')
      expect(res[1][0]).toEqual('2nd')
      expect(res[2][0]).toEqual('3rd')
      expect(res[3][0]).toEqual('4th')
    })
  })

  describe('With special Wildcard', () => {
    const node = new Node()
    node.insert('get', '/posts', '/posts') // 1.1
    node.insert('get', '/posts/*', '/posts/*') // 1.2
    node.insert('get', '/posts/:id', '/posts/:id') // 2.3

    it('get /posts', () => {
      const [res] = node.search('get', '/posts')
      expect(res.length).toBe(2)
      expect(res[0][0]).toEqual('/posts')
      expect(res[1][0]).toEqual('/posts/*')
    })
  })

  describe('Complex', () => {
    const node = new Node()
    node.insert('get', '/api', 'a') // not match
    node.insert('get', '/api/*', 'b') // match
    node.insert('get', '/api/:type', 'c') // not match
    node.insert('get', '/api/:type/:id', 'd') // match
    node.insert('get', '/api/posts/:id', 'e') // match
    node.insert('get', '/api/posts/123', 'f') // match
    node.insert('get', '/*/*/:id', 'g') // match
    node.insert('get', '/api/posts/*/comment', 'h') // not match
    node.insert('get', '*', 'i') // match
    node.insert('get', '*', 'j') // match

    it('get /api/posts/123', () => {
      const [res] = node.search('get', '/api/posts/123')
      expect(res.length).toBe(7)
      expect(res[0][0]).toEqual('b')
      expect(res[1][0]).toEqual('d')
      expect(res[2][0]).toEqual('e')
      expect(res[3][0]).toEqual('f')
      expect(res[4][0]).toEqual('g')
      expect(res[5][0]).toEqual('i')
      expect(res[6][0]).toEqual('j')
    })
  })

  describe('Multi match', () => {
    const node = new Node()
    node.insert('get', '*', 'GET *') // 0.1
    node.insert('get', '/abc/*', 'GET /abc/*') // 1.2
    node.insert('get', '/abc/edf', 'GET /abc/edf') // 2.3
    node.insert('get', '/abc/*/ghi/jkl', 'GET /abc/*/ghi/jkl') // 4.4
    it('get /abc/edf', () => {
      const [res] = node.search('get', '/abc/edf')
      expect(res.length).toBe(3)
      expect(res[0][0]).toEqual('GET *')
      expect(res[1][0]).toEqual('GET /abc/*')
      expect(res[2][0]).toEqual('GET /abc/edf')
    })
  })

  describe('Multi match', () => {
    const node = new Node()

    node.insert('get', '/api/*', 'a') // 2.1 for /api/entry
    node.insert('get', '/api/entry', 'entry') // 2.2
    node.insert('ALL', '/api/*', 'b') // 2.3 for /api/entry

    it('get /api/entry', async () => {
      const [res] = node.search('get', '/api/entry')
      expect(res.length).toBe(3)
      expect(res[0][0]).toEqual('a')
      expect(res[1][0]).toEqual('entry')
      expect(res[2][0]).toEqual('b')
    })
  })

  describe('fallback', () => {
    describe('Blog - failed', () => {
      const node = new Node()
      node.insert('post', '/entry', 'post entry') // 1.1
      node.insert('post', '/entry/*', 'fallback') // 1.2
      node.insert('get', '/entry/:id', 'get entry') // 2.3
      it('post /entry', async () => {
        const [res] = node.search('post', '/entry')
        expect(res.length).toBe(2)
        expect(res[0][0]).toEqual('post entry')
        expect(res[1][0]).toEqual('fallback')
      })
    })
  })
  describe('page', () => {
    const node = new Node()
    node.insert('get', '/page', 'page') // 1.1
    node.insert('ALL', '/*', 'fallback') // 1.2
    it('get /page', async () => {
      const [res] = node.search('get', '/page')
      expect(res.length).toBe(2)
      expect(res[0][0]).toEqual('page')
      expect(res[1][0]).toEqual('fallback')
    })
  })
})

describe('star', () => {
  const node = new Node()
  node.insert('get', '/', '/')
  node.insert('get', '/*', '/*')
  node.insert('get', '*', '*')

  node.insert('get', '/x', '/x')
  node.insert('get', '/x/*', '/x/*')

  it('top', async () => {
    const [res] = node.search('get', '/')
    expect(res.length).toBe(3)
    expect(res[0][0]).toEqual('/')
    expect(res[1][0]).toEqual('/*')
    expect(res[2][0]).toEqual('*')
  })

  it('Under a certain path', async () => {
    const [res] = node.search('get', '/x')
    expect(res.length).toBe(4)
    expect(res[0][0]).toEqual('/*')
    expect(res[1][0]).toEqual('*')
    expect(res[2][0]).toEqual('/x')
    expect(res[3][0]).toEqual('/x/*')
  })
})

describe('Routing order With named parameters', () => {
  const node = new Node()
  node.insert('get', '/book/a', 'no-slug')
  node.insert('get', '/book/:slug', 'slug')
  node.insert('get', '/book/b', 'no-slug-b')
  it('/book/a', () => {
    const [res] = node.search('get', '/book/a')
    expect(res).not.toBeNull()
    expect(res.length).toBe(2)
    expect(res[0][0]).toEqual('no-slug')
    expect(res[0][1]).toEqual({})
    expect(res[1][0]).toEqual('slug')
    expect(res[1][1]).toEqual({ slug: 'a' })
  })
  it('/book/foo', () => {
    const [res] = node.search('get', '/book/foo')
    expect(res).not.toBeNull()
    expect(res.length).toBe(1)
    expect(res[0][0]).toEqual('slug')
    expect(res[0][1]).toEqual({ slug: 'foo' })
    expect(res[0][1]['slug']).toBe('foo')
  })
  it('/book/b', () => {
    const [res] = node.search('get', '/book/b')
    expect(res).not.toBeNull()
    expect(res.length).toBe(2)
    expect(res[0][0]).toEqual('slug')
    expect(res[0][1]).toEqual({ slug: 'b' })
    expect(res[1][0]).toEqual('no-slug-b')
    expect(res[1][1]).toEqual({})
  })
})

describe('The same name is used for path params', () => {
  describe('Basic', () => {
    const node = new Node()
    node.insert('get', '/:a/:b/:c', 'abc')
    node.insert('get', '/:a/:b/:c/:d', 'abcd')
    it('/1/2/3', () => {
      const [res] = node.search('get', '/1/2/3')
      expect(res).not.toBeNull()
      expect(res.length).toBe(1)
      expect(res[0][0]).toEqual('abc')
      expect(res[0][1]).toEqual({ a: '1', b: '2', c: '3' })
    })
  })

  describe('Complex', () => {
    const node = new Node()
    node.insert('get', '/:a', 'a')
    node.insert('get', '/:b/:a', 'ba')
    it('/about/me', () => {
      const [res] = node.search('get', '/about/me')
      expect(res).not.toBeNull()
      expect(res.length).toBe(1)
      expect(res[0][0]).toEqual('ba')
      expect(res[0][1]).toEqual({ b: 'about', a: 'me' })
    })
  })

  describe('Complex with tails', () => {
    const node = new Node()
    node.insert('get', '/:id/:id2/comments', 'a')
    node.insert('get', '/posts/:id/comments', 'b')
    it('/posts/123/comments', () => {
      const [res] = node.search('get', '/posts/123/comments')
      expect(res).not.toBeNull()
      expect(res.length).toBe(2)
      expect(res[0][0]).toEqual('a')
      expect(res[0][1]).toEqual({ id: 'posts', id2: '123' })
      expect(res[1][0]).toEqual('b')
      expect(res[1][1]).toEqual({ id: '123' })
    })
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/router/trie-router/node.ts
```typescript
import type { Params } from '../../router'
import { METHOD_NAME_ALL } from '../../router'
import type { Pattern } from '../../utils/url'
import { getPattern, splitPath, splitRoutingPath } from '../../utils/url'

type HandlerSet<T> = {
  handler: T
  possibleKeys: string[]
  score: number
}

type HandlerParamsSet<T> = HandlerSet<T> & {
  params: Record<string, string>
}

const emptyParams = Object.create(null)

export class Node<T> {
  #methods: Record<string, HandlerSet<T>>[]

  #children: Record<string, Node<T>>
  #patterns: Pattern[]
  #order: number = 0
  #params: Record<string, string> = emptyParams

  constructor(method?: string, handler?: T, children?: Record<string, Node<T>>) {
    this.#children = children || Object.create(null)
    this.#methods = []
    if (method && handler) {
      const m: Record<string, HandlerSet<T>> = Object.create(null)
      m[method] = { handler, possibleKeys: [], score: 0 }
      this.#methods = [m]
    }
    this.#patterns = []
  }

  insert(method: string, path: string, handler: T): Node<T> {
    this.#order = ++this.#order

    // eslint-disable-next-line @typescript-eslint/no-this-alias
    let curNode: Node<T> = this
    const parts = splitRoutingPath(path)

    const possibleKeys: string[] = []

    for (let i = 0, len = parts.length; i < len; i++) {
      const p: string = parts[i]
      const nextP = parts[i + 1]
      const pattern = getPattern(p, nextP)
      const key = Array.isArray(pattern) ? pattern[0] : p

      if (Object.keys(curNode.#children).includes(key)) {
        curNode = curNode.#children[key]
        const pattern = getPattern(p, nextP)
        if (pattern) {
          possibleKeys.push(pattern[1])
        }
        continue
      }

      curNode.#children[key] = new Node()

      if (pattern) {
        curNode.#patterns.push(pattern)
        possibleKeys.push(pattern[1])
      }
      curNode = curNode.#children[key]
    }

    const m: Record<string, HandlerSet<T>> = Object.create(null)

    const handlerSet: HandlerSet<T> = {
      handler,
      possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),
      score: this.#order,
    }

    m[method] = handlerSet
    curNode.#methods.push(m)

    return curNode
  }

  #getHandlerSets(
    node: Node<T>,
    method: string,
    nodeParams: Record<string, string>,
    params?: Record<string, string>
  ): HandlerParamsSet<T>[] {
    const handlerSets: HandlerParamsSet<T>[] = []
    for (let i = 0, len = node.#methods.length; i < len; i++) {
      const m = node.#methods[i]
      const handlerSet = (m[method] || m[METHOD_NAME_ALL]) as HandlerParamsSet<T>
      const processedSet: Record<number, boolean> = {}
      if (handlerSet !== undefined) {
        handlerSet.params = Object.create(null)
        handlerSets.push(handlerSet)
        if (nodeParams !== emptyParams || (params && params !== emptyParams)) {
          for (let i = 0, len = handlerSet.possibleKeys.length; i < len; i++) {
            const key = handlerSet.possibleKeys[i]
            const processed = processedSet[handlerSet.score]
            handlerSet.params[key] =
              params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key]
            processedSet[handlerSet.score] = true
          }
        }
      }
    }
    return handlerSets
  }

  search(method: string, path: string): [[T, Params][]] {
    const handlerSets: HandlerParamsSet<T>[] = []
    this.#params = emptyParams

    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const curNode: Node<T> = this
    let curNodes = [curNode]
    const parts = splitPath(path)
    const curNodesQueue: Node<T>[][] = []

    for (let i = 0, len = parts.length; i < len; i++) {
      const part: string = parts[i]
      const isLast = i === len - 1
      const tempNodes: Node<T>[] = []

      for (let j = 0, len2 = curNodes.length; j < len2; j++) {
        const node = curNodes[j]
        const nextNode = node.#children[part]

        if (nextNode) {
          nextNode.#params = node.#params
          if (isLast) {
            // '/hello/*' => match '/hello'
            if (nextNode.#children['*']) {
              handlerSets.push(
                ...this.#getHandlerSets(nextNode.#children['*'], method, node.#params)
              )
            }
            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params))
          } else {
            tempNodes.push(nextNode)
          }
        }

        for (let k = 0, len3 = node.#patterns.length; k < len3; k++) {
          const pattern = node.#patterns[k]
          const params = node.#params === emptyParams ? {} : { ...node.#params }

          // Wildcard
          // '/hello/*/foo' => match /hello/bar/foo
          if (pattern === '*') {
            const astNode = node.#children['*']
            if (astNode) {
              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params))
              astNode.#params = params
              tempNodes.push(astNode)
            }
            continue
          }

          if (part === '') {
            continue
          }

          const [key, name, matcher] = pattern

          const child = node.#children[key]

          // `/js/:filename{[a-z]+.js}` => match /js/chunk/123.js
          const restPathString = parts.slice(i).join('/')
          if (matcher instanceof RegExp) {
            const m = matcher.exec(restPathString)
            if (m) {
              params[name] = m[0]
              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params))

              if (Object.keys(child.#children).length) {
                child.#params = params
                const componentCount = m[0].match(/\//)?.length ?? 0
                const targetCurNodes = (curNodesQueue[componentCount] ||= [])
                targetCurNodes.push(child)
              }

              continue
            }
          }

          if (matcher === true || matcher.test(part)) {
            params[name] = part
            if (isLast) {
              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params))
              if (child.#children['*']) {
                handlerSets.push(
                  ...this.#getHandlerSets(child.#children['*'], method, params, node.#params)
                )
              }
            } else {
              child.#params = params
              tempNodes.push(child)
            }
          }
        }
      }

      curNodes = tempNodes.concat(curNodesQueue.shift() ?? [])
    }

    if (handlerSets.length > 1) {
      handlerSets.sort((a, b) => {
        return a.score - b.score
      })
    }

    return [handlerSets.map(({ handler, params }) => [handler, params] as [T, Params])]
  }
}

```
/Users/josh/Documents/GitHub/honojs/hono/src/router/trie-router/router.test.ts
```typescript
import { runTest } from '../common.case.test'
import { TrieRouter } from './router'

describe('TrieRouter', () => {
  runTest({
    newRouter: () => new TrieRouter(),
  })
})

```
/Users/josh/Documents/GitHub/honojs/hono/src/router/trie-router/router.ts
```typescript
import type { Result, Router } from '../../router'
import { checkOptionalParameter } from '../../utils/url'
import { Node } from './node'

export class TrieRouter<T> implements Router<T> {
  name: string = 'TrieRouter'
  #node: Node<T>

  constructor() {
    this.#node = new Node()
  }

  add(method: string, path: string, handler: T) {
    const results = checkOptionalParameter(path)
    if (results) {
      for (let i = 0, len = results.length; i < len; i++) {
        this.#node.insert(method, results[i], handler)
      }
      return
    }

    this.#node.insert(method, path, handler)
  }

  match(method: string, path: string): Result<T> {
    return this.#node.search(method, path)
  }
}

```
