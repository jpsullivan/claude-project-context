<documents>
<document index="1">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/packages/better-auth/src/plugins/passkey/client.ts</source>
<document_content>
import type { BetterFetch, BetterFetchOption } from "@better-fetch/fetch";
import {
	WebAuthnError,
	startAuthentication,
	startRegistration,
} from "@simplewebauthn/browser";
import type {
	PublicKeyCredentialCreationOptionsJSON,
	PublicKeyCredentialRequestOptionsJSON,
} from "@simplewebauthn/browser";
import type { Session } from "inspector";
import type { User } from "../../types";
import type { passkey as passkeyPl, Passkey } from ".";
import type { BetterAuthClientPlugin } from "../../client/types";
import { useAuthQuery } from "../../client";
import { atom } from "nanostores";

export const getPasskeyActions = (
	$fetch: BetterFetch,
	{
		$listPasskeys,
	}: {
		$listPasskeys: ReturnType<typeof atom<any>>;
	},
) => {
	const signInPasskey = async (
		opts?: {
			autoFill?: boolean;
			email?: string;
			fetchOptions?: BetterFetchOption;
		},
		options?: BetterFetchOption,
	) => {
		const response = await $fetch<PublicKeyCredentialRequestOptionsJSON>(
			"/passkey/generate-authenticate-options",
			{
				method: "POST",
				body: {
					email: opts?.email,
				},
			},
		);
		if (!response.data) {
			return response;
		}
		try {
			const res = await startAuthentication({
				optionsJSON: response.data,
				useBrowserAutofill: opts?.autoFill,
			});
			const verified = await $fetch<{
				session: Session;
				user: User;
			}>("/passkey/verify-authentication", {
				body: {
					response: res,
				},
				...opts?.fetchOptions,
				...options,
				method: "POST",
			});
			if (!verified.data) {
				return verified;
			}
		} catch (e) {
			return {
				data: null,
				error: {
					message: "auth cancelled",
					status: 400,
					statusText: "BAD_REQUEST",
				},
			};
		}
	};

	const registerPasskey = async (
		opts?: {
			fetchOptions?: BetterFetchOption;
			/**
			 * The name of the passkey. This is used to
			 * identify the passkey in the UI.
			 */
			name?: string;

			/**
			 * The type of attachment for the passkey. Defaults to both
			 * platform and cross-platform allowed, with platform preferred.
			 */
			authenticatorAttachment?: "platform" | "cross-platform";

			/**
			 * Try to silently create a passkey with the password manager that the user just signed
			 * in with.
			 * @default false
			 */
			useAutoRegister?: boolean;
		},
		fetchOpts?: BetterFetchOption,
	) => {
		const options = await $fetch<PublicKeyCredentialCreationOptionsJSON>(
			"/passkey/generate-register-options",
			{
				method: "GET",
				query: {
					...(opts?.authenticatorAttachment && {
						authenticatorAttachment: opts.authenticatorAttachment,
					}),
				},
			},
		);
		if (!options.data) {
			return options;
		}
		try {
			const res = await startRegistration({
				optionsJSON: options.data,
				useAutoRegister: opts?.useAutoRegister,
			});
			const verified = await $fetch<{
				passkey: Passkey;
			}>("/passkey/verify-registration", {
				...opts?.fetchOptions,
				...fetchOpts,
				body: {
					response: res,
					name: opts?.name,
				},
				method: "POST",
			});
			if (!verified.data) {
				return verified;
			}
			$listPasskeys.set(Math.random());
		} catch (e) {
			if (e instanceof WebAuthnError) {
				if (e.code === "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED") {
					return {
						data: null,
						error: {
							message: "previously registered",
							status: 400,
							statusText: "BAD_REQUEST",
						},
					};
				}
				if (e.code === "ERROR_CEREMONY_ABORTED") {
					return {
						data: null,
						error: {
							message: "registration cancelled",
							status: 400,
							statusText: "BAD_REQUEST",
						},
					};
				}
				return {
					data: null,
					error: {
						message: e.message,
						status: 400,
						statusText: "BAD_REQUEST",
					},
				};
			}
			return {
				data: null,
				error: {
					message: e instanceof Error ? e.message : "unknown error",
					status: 500,
					statusText: "INTERNAL_SERVER_ERROR",
				},
			};
		}
	};

	return {
		signIn: {
			/**
			 * Sign in with a registered passkey
			 */
			passkey: signInPasskey,
		},
		passkey: {
			/**
			 * Add a passkey to the user account
			 */
			addPasskey: registerPasskey,
		},
		/**
		 * Inferred Internal Types
		 */
		$Infer: {} as {
			Passkey: Passkey;
		},
	};
};

export const passkeyClient = () => {
	const $listPasskeys = atom<any>();
	return {
		id: "passkey",
		$InferServerPlugin: {} as ReturnType<typeof passkeyPl>,
		getActions: ($fetch) =>
			getPasskeyActions($fetch, {
				$listPasskeys,
			}),
		getAtoms($fetch) {
			const listPasskeys = useAuthQuery<Passkey[]>(
				$listPasskeys,
				"/passkey/list-user-passkeys",
				$fetch,
				{
					method: "GET",
				},
			);
			return {
				listPasskeys,
				$listPasskeys,
			};
		},
		pathMethods: {
			"/passkey/register": "POST",
			"/passkey/authenticate": "POST",
		},
		atomListeners: [
			{
				matcher(path) {
					return (
						path === "/passkey/verify-registration" ||
						path === "/passkey/delete-passkey" ||
						path === "/passkey/update-passkey"
					);
				},
				signal: "_listPasskeys",
			},
		],
	} satisfies BetterAuthClientPlugin;
};

</document_content>
</document>
<document index="2">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/packages/better-auth/src/plugins/passkey/index.ts</source>
<document_content>
import {
	generateAuthenticationOptions,
	generateRegistrationOptions,
	verifyAuthenticationResponse,
	verifyRegistrationResponse,
} from "@simplewebauthn/server";
import type {
	AuthenticationResponseJSON,
	AuthenticatorTransportFuture,
	CredentialDeviceType,
	PublicKeyCredentialCreationOptionsJSON,
} from "@simplewebauthn/server";
import { APIError } from "better-call";
import { generateRandomString } from "../../crypto/random";
import { z } from "zod";
import { createAuthEndpoint } from "../../api/call";
import { sessionMiddleware } from "../../api";
import { freshSessionMiddleware, getSessionFromCtx } from "../../api/routes";
import type {
	BetterAuthPlugin,
	InferOptionSchema,
	AuthPluginSchema,
} from "../../types/plugins";
import { setSessionCookie } from "../../cookies";
import { generateId } from "../../utils";
import { mergeSchema } from "../../db/schema";
import { base64 } from "@better-auth/utils/base64";

interface WebAuthnChallengeValue {
	expectedChallenge: string;
	userData: {
		id: string;
	};
}

function getRpID(options: PasskeyOptions, baseURL?: string) {
	return (
		options.rpID || (baseURL ? new URL(baseURL).hostname : "localhost") // default rpID
	);
}

export interface PasskeyOptions {
	/**
	 * A unique identifier for your website. 'localhost' is okay for
	 * local dev
	 *
	 * @default "localhost"
	 */
	rpID?: string;
	/**
	 * Human-readable title for your website
	 *
	 * @default "Better Auth"
	 */
	rpName?: string;
	/**
	 * The URL at which registrations and authentications should occur.
	 * 'http://localhost' and 'http://localhost:PORT' are also valid.
	 * Do NOT include any trailing /
	 *
	 * if this isn't provided. The client itself will
	 * pass this value.
	 */
	origin?: string | null;

	/**
	 * Allow customization of the authenticatorSelection options
	 * during passkey registration.
	 */
	authenticatorSelection?: AuthenticatorSelectionCriteria;

	/**
	 * Advanced options
	 */
	advanced?: {
		webAuthnChallengeCookie?: string;
	};
	/**
	 * Schema for the passkey model
	 */
	schema?: InferOptionSchema<typeof schema>;
}

export type Passkey = {
	id: string;
	name?: string;
	publicKey: string;
	userId: string;
	credentialID: string;
	counter: number;
	deviceType: CredentialDeviceType;
	backedUp: boolean;
	transports?: string;
	createdAt: Date;
};

export const passkey = (options?: PasskeyOptions) => {
	const opts = {
		origin: null,
		...options,
		advanced: {
			webAuthnChallengeCookie: "better-auth-passkey",
			...options?.advanced,
		},
	};
	const expirationTime = new Date(Date.now() + 1000 * 60 * 5);
	const currentTime = new Date();
	const maxAgeInSeconds = Math.floor(
		(expirationTime.getTime() - currentTime.getTime()) / 1000,
	);

	const ERROR_CODES = {
		CHALLENGE_NOT_FOUND: "Challenge not found",
		YOU_ARE_NOT_ALLOWED_TO_REGISTER_THIS_PASSKEY:
			"You are not allowed to register this passkey",
		FAILED_TO_VERIFY_REGISTRATION: "Failed to verify registration",
		PASSKEY_NOT_FOUND: "Passkey not found",
		AUTHENTICATION_FAILED: "Authentication failed",
		UNABLE_TO_CREATE_SESSION: "Unable to create session",
		FAILED_TO_UPDATE_PASSKEY: "Failed to update passkey",
	} as const;
	return {
		id: "passkey",
		endpoints: {
			generatePasskeyRegistrationOptions: createAuthEndpoint(
				"/passkey/generate-register-options",
				{
					method: "GET",
					use: [freshSessionMiddleware],
					query: z
						.object({
							authenticatorAttachment: z
								.enum(["platform", "cross-platform"])
								.optional(),
						})
						.optional(),
					metadata: {
						client: false,
						openapi: {
							description: "Generate registration options for a new passkey",
							responses: {
								200: {
									description: "Success",
									parameters: {
										query: {
											authenticatorAttachment: {
												description: `Type of authenticator to use for registration. 
                          "platform" for device-specific authenticators, 
                          "cross-platform" for authenticators that can be used across devices.`,
												required: false,
											},
										},
									},
									content: {
										"application/json": {
											schema: {
												type: "object",
												properties: {
													challenge: {
														type: "string",
													},
													rp: {
														type: "object",
														properties: {
															name: {
																type: "string",
															},
															id: {
																type: "string",
															},
														},
													},
													user: {
														type: "object",
														properties: {
															id: {
																type: "string",
															},
															name: {
																type: "string",
															},
															displayName: {
																type: "string",
															},
														},
													},
													pubKeyCredParams: {
														type: "array",
														items: {
															type: "object",
															properties: {
																type: {
																	type: "string",
																},
																alg: {
																	type: "number",
																},
															},
														},
													},
													timeout: {
														type: "number",
													},
													excludeCredentials: {
														type: "array",
														items: {
															type: "object",
															properties: {
																id: {
																	type: "string",
																},
																type: {
																	type: "string",
																},
																transports: {
																	type: "array",
																	items: {
																		type: "string",
																	},
																},
															},
														},
													},
													authenticatorSelection: {
														type: "object",
														properties: {
															authenticatorAttachment: {
																type: "string",
															},
															requireResidentKey: {
																type: "boolean",
															},
															userVerification: {
																type: "string",
															},
														},
													},
													attestation: {
														type: "string",
													},

													extensions: {
														type: "object",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
				async (ctx) => {
					const { session } = ctx.context;
					const userPasskeys = await ctx.context.adapter.findMany<Passkey>({
						model: "passkey",
						where: [
							{
								field: "userId",
								value: session.user.id,
							},
						],
					});
					const userID = new TextEncoder().encode(
						generateRandomString(32, "a-z", "0-9"),
					);
					let options: PublicKeyCredentialCreationOptionsJSON;
					options = await generateRegistrationOptions({
						rpName: opts.rpName || ctx.context.appName,
						rpID: getRpID(opts, ctx.context.options.baseURL),
						userID,
						userName: session.user.email || session.user.id,
						attestationType: "none",
						excludeCredentials: userPasskeys.map((passkey) => ({
							id: passkey.credentialID,
							transports: passkey.transports?.split(
								",",
							) as AuthenticatorTransportFuture[],
						})),
						authenticatorSelection: {
							residentKey: "preferred",
							userVerification: "preferred",
							...(opts.authenticatorSelection || {}),
							...(ctx.query?.authenticatorAttachment
								? {
										authenticatorAttachment: ctx.query.authenticatorAttachment,
									}
								: {}),
						},
					});
					const id = generateId(32);
					const webAuthnCookie = ctx.context.createAuthCookie(
						opts.advanced.webAuthnChallengeCookie,
					);
					await ctx.setSignedCookie(
						webAuthnCookie.name,
						id,
						ctx.context.secret,
						{
							...webAuthnCookie.attributes,
							maxAge: maxAgeInSeconds,
						},
					);
					await ctx.context.internalAdapter.createVerificationValue({
						identifier: id,
						value: JSON.stringify({
							expectedChallenge: options.challenge,
							userData: {
								id: session.user.id,
							},
						}),
						expiresAt: expirationTime,
					});
					return ctx.json(options, {
						status: 200,
					});
				},
			),
			generatePasskeyAuthenticationOptions: createAuthEndpoint(
				"/passkey/generate-authenticate-options",
				{
					method: "POST",
					body: z
						.object({
							email: z
								.string({
									description: "The email address of the user",
								})
								.optional(),
						})
						.optional(),
					metadata: {
						openapi: {
							description: "Generate authentication options for a passkey",
							responses: {
								200: {
									description: "Success",
									content: {
										"application/json": {
											schema: {
												type: "object",
												properties: {
													challenge: {
														type: "string",
													},
													rp: {
														type: "object",
														properties: {
															name: {
																type: "string",
															},
															id: {
																type: "string",
															},
														},
													},
													user: {
														type: "object",
														properties: {
															id: {
																type: "string",
															},
															name: {
																type: "string",
															},
															displayName: {
																type: "string",
															},
														},
													},
													timeout: {
														type: "number",
													},
													allowCredentials: {
														type: "array",
														items: {
															type: "object",
															properties: {
																id: {
																	type: "string",
																},
																type: {
																	type: "string",
																},
																transports: {
																	type: "array",
																	items: {
																		type: "string",
																	},
																},
															},
														},
													},
													userVerification: {
														type: "string",
													},
													authenticatorSelection: {
														type: "object",
														properties: {
															authenticatorAttachment: {
																type: "string",
															},
															requireResidentKey: {
																type: "boolean",
															},
															userVerification: {
																type: "string",
															},
														},
													},
													extensions: {
														type: "object",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
				async (ctx) => {
					const session = await getSessionFromCtx(ctx);
					let userPasskeys: Passkey[] = [];
					if (session) {
						userPasskeys = await ctx.context.adapter.findMany<Passkey>({
							model: "passkey",
							where: [
								{
									field: "userId",
									value: session.user.id,
								},
							],
						});
					}
					const options = await generateAuthenticationOptions({
						rpID: getRpID(opts, ctx.context.options.baseURL),
						userVerification: "preferred",
						...(userPasskeys.length
							? {
									allowCredentials: userPasskeys.map((passkey) => ({
										id: passkey.credentialID,
										transports: passkey.transports?.split(
											",",
										) as AuthenticatorTransportFuture[],
									})),
								}
							: {}),
					});
					const data = {
						expectedChallenge: options.challenge,
						userData: {
							id: session?.user.id || "",
						},
					};
					const id = generateId(32);
					const webAuthnCookie = ctx.context.createAuthCookie(
						opts.advanced.webAuthnChallengeCookie,
					);
					await ctx.setSignedCookie(
						webAuthnCookie.name,
						id,
						ctx.context.secret,
						{
							...webAuthnCookie.attributes,
							maxAge: maxAgeInSeconds,
						},
					);
					await ctx.context.internalAdapter.createVerificationValue({
						identifier: id,
						value: JSON.stringify(data),
						expiresAt: expirationTime,
					});
					return ctx.json(options, {
						status: 200,
					});
				},
			),
			verifyPasskeyRegistration: createAuthEndpoint(
				"/passkey/verify-registration",
				{
					method: "POST",
					body: z.object({
						response: z.any({
							description: "The response from the authenticator",
						}),
						name: z
							.string({
								description: "Name of the passkey",
							})
							.optional(),
					}),
					use: [freshSessionMiddleware],
					metadata: {
						openapi: {
							description: "Verify registration of a new passkey",
							responses: {
								200: {
									description: "Success",
									content: {
										"application/json": {
											schema: {
												$ref: "#/components/schemas/Passkey",
											},
										},
									},
								},
								400: {
									description: "Bad request",
								},
							},
						},
					},
				},
				async (ctx) => {
					const origin = options?.origin || ctx.headers?.get("origin") || "";
					if (!origin) {
						return ctx.json(null, {
							status: 400,
						});
					}
					const resp = ctx.body.response;
					const webAuthnCookie = ctx.context.createAuthCookie(
						opts.advanced.webAuthnChallengeCookie,
					);
					const challengeId = await ctx.getSignedCookie(
						webAuthnCookie.name,
						ctx.context.secret,
					);
					if (!challengeId) {
						throw new APIError("BAD_REQUEST", {
							message: ERROR_CODES.CHALLENGE_NOT_FOUND,
						});
					}

					const data =
						await ctx.context.internalAdapter.findVerificationValue(
							challengeId,
						);
					if (!data) {
						return ctx.json(null, {
							status: 400,
						});
					}
					const { expectedChallenge, userData } = JSON.parse(
						data.value,
					) as WebAuthnChallengeValue;

					if (userData.id !== ctx.context.session.user.id) {
						throw new APIError("UNAUTHORIZED", {
							message: ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REGISTER_THIS_PASSKEY,
						});
					}

					try {
						const verification = await verifyRegistrationResponse({
							response: resp,
							expectedChallenge,
							expectedOrigin: origin,
							expectedRPID: getRpID(opts, ctx.context.options.baseURL),
							requireUserVerification: false,
						});
						const { verified, registrationInfo } = verification;
						if (!verified || !registrationInfo) {
							return ctx.json(null, {
								status: 400,
							});
						}
						const {
							// credentialID,
							// credentialPublicKey,
							// counter,
							credentialDeviceType,
							credentialBackedUp,
							credential,
							credentialType,
						} = registrationInfo;
						const pubKey = base64.encode(credential.publicKey);
						const newPasskey: Passkey = {
							name: ctx.body.name,
							userId: userData.id,
							id: ctx.context.generateId({ model: "passkey" }),
							credentialID: credential.id,
							publicKey: pubKey,
							counter: credential.counter,
							deviceType: credentialDeviceType,
							transports: resp.response.transports.join(","),
							backedUp: credentialBackedUp,
							createdAt: new Date(),
						};
						const newPasskeyRes = await ctx.context.adapter.create<Passkey>({
							model: "passkey",
							data: newPasskey,
						});
						return ctx.json(newPasskeyRes, {
							status: 200,
						});
					} catch (e) {
						console.log(e);
						throw new APIError("INTERNAL_SERVER_ERROR", {
							message: ERROR_CODES.FAILED_TO_VERIFY_REGISTRATION,
						});
					}
				},
			),
			verifyPasskeyAuthentication: createAuthEndpoint(
				"/passkey/verify-authentication",
				{
					method: "POST",
					body: z.object({
						response: z.record(z.any()),
					}),
					metadata: {
						openapi: {
							description: "Verify authentication of a passkey",
							responses: {
								200: {
									description: "Success",
									content: {
										"application/json": {
											schema: {
												type: "object",
												properties: {
													session: {
														$ref: "#/components/schemas/Session",
													},
													user: {
														$ref: "#/components/schemas/User",
													},
												},
											},
										},
									},
								},
							},
						},
						$Infer: {
							body: {} as {
								response: AuthenticationResponseJSON;
							},
						},
					},
				},
				async (ctx) => {
					const origin = options?.origin || ctx.headers?.get("origin") || "";
					if (!origin) {
						throw new APIError("BAD_REQUEST", {
							message: "origin missing",
						});
					}
					const resp = ctx.body.response;
					const webAuthnCookie = ctx.context.createAuthCookie(
						opts.advanced.webAuthnChallengeCookie,
					);
					const challengeId = await ctx.getSignedCookie(
						webAuthnCookie.name,
						ctx.context.secret,
					);
					if (!challengeId) {
						throw new APIError("BAD_REQUEST", {
							message: ERROR_CODES.CHALLENGE_NOT_FOUND,
						});
					}

					const data =
						await ctx.context.internalAdapter.findVerificationValue(
							challengeId,
						);
					if (!data) {
						throw new APIError("BAD_REQUEST", {
							message: ERROR_CODES.CHALLENGE_NOT_FOUND,
						});
					}
					const { expectedChallenge } = JSON.parse(
						data.value,
					) as WebAuthnChallengeValue;
					const passkey = await ctx.context.adapter.findOne<Passkey>({
						model: "passkey",
						where: [
							{
								field: "credentialID",
								value: resp.id,
							},
						],
					});
					if (!passkey) {
						throw new APIError("UNAUTHORIZED", {
							message: ERROR_CODES.PASSKEY_NOT_FOUND,
						});
					}
					try {
						const verification = await verifyAuthenticationResponse({
							response: resp as AuthenticationResponseJSON,
							expectedChallenge,
							expectedOrigin: origin,
							expectedRPID: getRpID(opts, ctx.context.options.baseURL),
							credential: {
								id: passkey.credentialID,
								publicKey: base64.decode(passkey.publicKey),
								counter: passkey.counter,
								transports: passkey.transports?.split(
									",",
								) as AuthenticatorTransportFuture[],
							},
							requireUserVerification: false,
						});
						const { verified } = verification;
						if (!verified)
							throw new APIError("UNAUTHORIZED", {
								message: ERROR_CODES.AUTHENTICATION_FAILED,
							});

						await ctx.context.adapter.update<Passkey>({
							model: "passkey",
							where: [
								{
									field: "id",
									value: passkey.id,
								},
							],
							update: {
								counter: verification.authenticationInfo.newCounter,
							},
						});
						const s = await ctx.context.internalAdapter.createSession(
							passkey.userId,
							ctx.request,
						);
						if (!s) {
							throw new APIError("INTERNAL_SERVER_ERROR", {
								message: ERROR_CODES.UNABLE_TO_CREATE_SESSION,
							});
						}
						const user = await ctx.context.internalAdapter.findUserById(
							passkey.userId,
						);
						if (!user) {
							throw new APIError("INTERNAL_SERVER_ERROR", {
								message: "User not found",
							});
						}
						await setSessionCookie(ctx, {
							session: s,
							user,
						});
						return ctx.json(
							{
								session: s,
							},
							{
								status: 200,
							},
						);
					} catch (e) {
						ctx.context.logger.error("Failed to verify authentication", e);
						throw new APIError("BAD_REQUEST", {
							message: ERROR_CODES.AUTHENTICATION_FAILED,
						});
					}
				},
			),
			listPasskeys: createAuthEndpoint(
				"/passkey/list-user-passkeys",
				{
					method: "GET",
					use: [sessionMiddleware],
				},
				async (ctx) => {
					const passkeys = await ctx.context.adapter.findMany<Passkey>({
						model: "passkey",
						where: [{ field: "userId", value: ctx.context.session.user.id }],
					});
					return ctx.json(passkeys, {
						status: 200,
					});
				},
			),
			deletePasskey: createAuthEndpoint(
				"/passkey/delete-passkey",
				{
					method: "POST",
					body: z.object({
						id: z.string(),
					}),
					use: [sessionMiddleware],
				},
				async (ctx) => {
					await ctx.context.adapter.delete<Passkey>({
						model: "passkey",
						where: [
							{
								field: "id",
								value: ctx.body.id,
							},
						],
					});
					return ctx.json(null, {
						status: 200,
					});
				},
			),
			updatePasskey: createAuthEndpoint(
				"/passkey/update-passkey",
				{
					method: "POST",
					body: z.object({
						id: z.string(),
						name: z.string(),
					}),
					use: [sessionMiddleware],
				},
				async (ctx) => {
					const passkey = await ctx.context.adapter.findOne<Passkey>({
						model: "passkey",
						where: [
							{
								field: "id",
								value: ctx.body.id,
							},
						],
					});

					if (!passkey) {
						throw new APIError("NOT_FOUND", {
							message: ERROR_CODES.PASSKEY_NOT_FOUND,
						});
					}

					if (passkey.userId !== ctx.context.session.user.id) {
						throw new APIError("UNAUTHORIZED", {
							message: ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REGISTER_THIS_PASSKEY,
						});
					}

					const updatedPasskey = await ctx.context.adapter.update<Passkey>({
						model: "passkey",
						where: [
							{
								field: "id",
								value: ctx.body.id,
							},
						],
						update: {
							name: ctx.body.name,
						},
					});

					if (!updatedPasskey) {
						throw new APIError("INTERNAL_SERVER_ERROR", {
							message: ERROR_CODES.FAILED_TO_UPDATE_PASSKEY,
						});
					}
					return ctx.json(
						{
							passkey: updatedPasskey,
						},
						{
							status: 200,
						},
					);
				},
			),
		},
		schema: mergeSchema(schema, options?.schema),
		$ERROR_CODES: ERROR_CODES,
	} satisfies BetterAuthPlugin;
};

const schema = {
	passkey: {
		fields: {
			name: {
				type: "string",
				required: false,
			},
			publicKey: {
				type: "string",
				required: true,
			},
			userId: {
				type: "string",
				references: {
					model: "user",
					field: "id",
				},
				required: true,
			},
			credentialID: {
				type: "string",
				required: true,
			},
			counter: {
				type: "number",
				required: true,
			},
			deviceType: {
				type: "string",
				required: true,
			},
			backedUp: {
				type: "boolean",
				required: true,
			},
			transports: {
				type: "string",
				required: false,
			},
			createdAt: {
				type: "date",
				required: false,
			},
		},
	},
} satisfies AuthPluginSchema;

</document_content>
</document>
<document index="3">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/packages/better-auth/src/plugins/passkey/passkey.test.ts</source>
<document_content>
import { describe, expect, it } from "vitest";
import { getTestInstance } from "../../test-utils/test-instance";
import { type Passkey, passkey } from ".";
import { createAuthClient } from "../../client";
import { passkeyClient } from "./client";

describe("passkey", async () => {
	const { auth, signInWithTestUser, customFetchImpl } = await getTestInstance({
		plugins: [passkey()],
	});

	it("should generate register options", async () => {
		const { headers } = await signInWithTestUser();
		const options = await auth.api.generatePasskeyRegistrationOptions({
			headers: headers,
		});

		expect(options).toBeDefined();
		expect(options).toHaveProperty("challenge");
		expect(options).toHaveProperty("rp");
		expect(options).toHaveProperty("user");
		expect(options).toHaveProperty("pubKeyCredParams");

		const client = createAuthClient({
			plugins: [passkeyClient()],
			baseURL: "http://localhost:3000/api/auth",
			fetchOptions: {
				headers: headers,
				customFetchImpl,
			},
		});

		await client.$fetch("/passkey/generate-register-options", {
			headers: headers,
			method: "GET",
			onResponse(context) {
				const setCookie = context.response.headers.get("Set-Cookie");
				expect(setCookie).toBeDefined();
				expect(setCookie).toContain("better-auth-passkey");
			},
		});
	});

	it("should generate authenticate options", async () => {
		const { headers } = await signInWithTestUser();
		const options = await auth.api.generatePasskeyAuthenticationOptions({
			headers: headers,
		});
		expect(options).toBeDefined();
		expect(options).toHaveProperty("challenge");
		expect(options).toHaveProperty("rpId");
		expect(options).toHaveProperty("allowCredentials");
		expect(options).toHaveProperty("userVerification");
	});

	it("should list user passkeys", async () => {
		const { headers, user } = await signInWithTestUser();
		const context = await auth.$context;
		await context.adapter.create({
			model: "passkey",
			data: {
				id: "mockPasskeyId",
				userId: user.id,
				publicKey: "mockPublicKey",
				name: "mockName",
				counter: 0,
				deviceType: "singleDevice",
				credentialID: "mockCredentialID",
				createdAt: new Date(),
				backedUp: false,
				transports: "mockTransports",
			} satisfies Passkey,
		});

		const passkeys = await auth.api.listPasskeys({
			headers: headers,
		});

		expect(Array.isArray(passkeys)).toBe(true);
		expect(passkeys[0]).toHaveProperty("id");
		expect(passkeys[0]).toHaveProperty("userId");
		expect(passkeys[0]).toHaveProperty("publicKey");
		expect(passkeys[0]).toHaveProperty("credentialID");
	});

	it("should update a passkey", async () => {
		const { headers } = await signInWithTestUser();
		const passkeys = await auth.api.listPasskeys({
			headers: headers,
		});
		const passkey = passkeys[0];
		const updateResult = await auth.api.updatePasskey({
			headers: headers,
			body: {
				id: passkey.id,
				name: "newName",
			},
		});

		expect(updateResult.passkey.name).toBe("newName");
	});

	it("should delete a passkey", async () => {
		const { headers } = await signInWithTestUser();
		const deleteResult = await auth.api.deletePasskey({
			headers: headers,
			body: {
				id: "mockPasskeyId",
			},
		});
		expect(deleteResult).toBe(null);
	});
});

</document_content>
</document>
</documents>
