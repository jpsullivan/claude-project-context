<documents>
<document index="1">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/2fa.mdx</source>
<document_content>
---
title: Two-Factor Authentication (2FA)
description: Enhance your app's security with two-factor authentication.
---

`OTP` `TOTP` `Backup Codes` `Trusted Devices`

Two-Factor Authentication (2FA) adds an extra security step when users log in. Instead of just using a password, they'll need to provide a second form of verification. This makes it much harder for unauthorized people to access accounts, even if they've somehow gotten the password.

This plugin offers two main methods to do a second factor verification:

1. **OTP (One-Time Password)**: A temporary code sent to the user's email or phone.
2. **TOTP (Time-based One-Time Password)**: A code generated by an app on the user's device.

**Additional features include:**
- Generating backup codes for account recovery
- Enabling/disabling 2FA
- Managing trusted devices

## Installation

<Steps>
    <Step>
        ### Add the plugin to your auth config

        Add the two-factor plugin to your auth configuration and specify your app name as the issuer.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { twoFactor } from "better-auth/plugins" // [!code highlight]

        export const auth = betterAuth({
            // ... other config options
            appName: "My App", // provide your app name. It'll be used as an issuer. // [!code highlight]
            plugins: [
                twoFactor() // [!code highlight]
            ]
        })
        ```
    </Step>
      <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```bash
            npx @better-auth/cli migrate
            ```
            </Tab>
            <Tab value="generate">
            ```bash
            npx @better-auth/cli generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>

        <Step>
        ### Add the client plugin

        Add the client plugin and Specify where the user should be redirected if they need to verify 2nd factor

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        import { twoFactorClient } from "better-auth/client/plugins"

        const authClient = createAuthClient({
            plugins: [
                twoFactorClient()
            ]
        })
        ```
        </Step>
</Steps>

## Usage

### Enabling 2FA

To enable two-factor authentication, call `twoFactor.enable` with the user's password:

```ts title="two-factor.ts"
const { data } = await authClient.twoFactor.enable({
    password: "password" // user password required
})
```

When 2FA is enabled:
- An encrypted `secret` and `backupCodes` are generated.
- `enable` returns `totpURI` and `backupCodes`.

Note: `twoFactorEnabled` won’t be set to `true` until the user verifies their TOTP code.

To verify, display the QR code for the user to scan with their authenticator app. After they enter the code, call `verifyTotp`:

```ts
await authClient.twoFactor.verifyTotp({
    code: "" // user input
})
```

<Callout>
You can skip verification by setting `skipVerificationOnEnable` to true in your plugin config.
</Callout>

### Sign In with 2FA

When a user with 2FA enabled tries to sign in via email, the response will contain `twoFactorRedirect` set to `true`. This indicates that the user needs to verify their 2FA code.

```ts title="sign-in.ts"
await authClient.signIn.email({
    email: "user@example.com",
    password: "password123",
})
```

You can handle this in the `onSuccess` callback or by providing a `onTwoFactorRedirect` callback in the plugin config.

```ts title="sign-in.ts"
import { createAuthClient } from "better-auth/client";
import { twoFactorClient } from "better-auth/client/plugins";

const authClient = createAuthClient({
    plugins: [twoFactorClient({
        onTwoFactorRedirect(){
            // Handle the 2FA verification globally
        }
    })]
})
```

Or you can handle it in place:

```ts
await authClient.signIn.email({
        email: "user@example.com",
        password: "password123",
    }, {
        async onSuccess(context) {
            if (context.data.twoFactorRedirect) {
                // Handle the 2FA verification in place
            }
        }
    }
})
```

#### Using `auth.api`

When you call `auth.api.signInEmail` on the server, and the user has 2FA enabled, it will, by default, respond with an object where `twoFactorRedirect` is set to `true`. This behavior isn’t inferred in TypeScript, which can be misleading. We recommend passing `asResponse: true` to receive the Response object instead.

```ts
const response = await auth.api.signInEmail({
    email: "my-email@email.com",
    password: "secure-password",
    asResponse: true
})
```

### Disabling 2FA

To disable two-factor authentication, call `twoFactor.disable` with the user's password:

```ts title="two-factor.ts"
const { data } = await authClient.twoFactor.disable({
    password: "password" // user password required
})
```

### TOTP

TOTP (Time-Based One-Time Password) is an algorithm that generates a unique password for each login attempt using time as a counter. Every fixed interval (Better Auth defaults to 30 seconds), a new password is generated. This addresses several issues with traditional passwords: they can be forgotten, stolen, or guessed. OTPs solve some of these problems, but their delivery via SMS or email can be unreliable (or even risky, considering it opens new attack vectors).

TOTP, however, generates codes offline, making it both secure and convenient. You just need an authenticator app on your phone, and you’re set—no internet required.

#### Getting TOTP URI

After enabling 2FA, you can get the TOTP URI to display to the user. This URI is generated by the server using the `secret` and `issuer` and can be used to generate a QR code for the user to scan with their authenticator app.

```ts
const { data, error } = await authClient.twoFactor.getTotpUri({
    password: "password" // user password required
})
```

**Example: Using React**

```tsx title="user-card.tsx"
import QRCode from "react-qr-code";

export default function UserCard(){
    const { data: session } = client.useSession();
	const { data: qr } = useQuery({
		queryKey: ["two-factor-qr"],
		queryFn: async () => {
			const res = await authClient.twoFactor.getTotpUri();
			return res.data;
		},
		enabled: !!session?.user.twoFactorEnabled,
	});
    return (
        <QRCode value={qr?.totpURI || ""} />
   )
}
```

<Callout>
By default the issuer for TOTP is set to the app name provided in the auth config or if not provided it will be set to `Better Auth`. You can override this by passing `issuer` to the plugin config.
</Callout>

#### Verifying TOTP

After the user has entered their 2FA code, you can verify it using `twoFactor.verifyTotp` method.

```ts
const verifyTotp = async (code: string) => {
    const { data, error } = await authClient.twoFactor.verifyTotp({ code })
}
```

### OTP

OTP (One-Time Password) is similar to TOTP but a random code is generated and sent to the user's email or phone.

Before using OTP to verify the second factor, you need to configure `sendOTP` in your Better Auth instance. This function is responsible for sending the OTP to the user's email, phone, or any other method supported by your application.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { twoFactor } from "better-auth/plugins"

export const auth = betterAuth({
    plugins: [
        twoFactor({
          	otpOptions: {
				async sendOTP({ user, otp }, request) {
                    // send otp to user
				},
			},
        })
    ]
})
```

#### Sending OTP

Sending an OTP is done by calling the `twoFactor.sendOtp` function. This function will trigger your sendOTP implementation that you provided in the Better Auth configuration.

```ts
const { data, error } = await authClient.twoFactor.sendOtp()
if (data) {
    // redirect or show the user to enter the code
}
```

#### Verifying OTP

After the user has entered their OTP code, you can verify it

```ts
const verifyOtp = async (code: string) => {
    await authClient.twoFactor.verifyOtp({ code }, {
        onSuccess(){
            //redirect the user on success
        },
        onError(ctx){
            alert(ctx.error.message)
        }
    })
}
```

### Backup Codes

Backup codes are generated and stored in the database. This can be used to recover access to the account if the user loses access to their phone or email.

#### Generating Backup Codes
Generate backup codes for account recovery:

```ts
const { data, error } = await authClient.twoFactor.generateBackupCodes({
    password: "password" // user password required
})
if (data) {
    // Show the backup codes to the user
}
```

#### Using Backup Codes

You can now allow users to provider backup code as account recover method.

```ts
await authClient.twoFactor.verifyBackupCode({code: ""}, {
    onSuccess(){
        //redirect the user on success
    },
    onError(ctx){
        alert(ctx.error.message)
    }
})
```

once a backup code is used, it will be removed from the database and can't be used again.

#### Viewing Backup Codes

You can view the backup codes at any time by calling `viewBackupCodes`. This action can only be performed on the server using `auth.api`.

```ts
await auth.api.viewBackupCodes({
    body: {
        userId: "user-id"
    }
})
```

### Trusted Devices

You can mark a device as trusted by passing `trustDevice` to `verifyTotp` or `verifyOtp`.

```ts
const verify2FA = async (code: string) => {
    const { data, error } = await authClient.twoFactor.verifyTotp({
        code,
        callbackURL: "/dashboard",
        trustDevice: true // Mark this device as trusted
    })
    if (data) {
        // 2FA verified and device trusted
    }
}
```

When `trustDevice` is set to `true`, the current device will be remembered for 60 days. During this period, the user won't be prompted for 2FA on subsequent sign-ins from this device. The trust period is refreshed each time the user signs in successfully.

### Issuer

By adding an `issuer` you can set your application name for the 2fa application.

For example, if your user uses Google Auth, the default appName will show up as `Better Auth`. However, by using the following code, it will show up as `my-app-name`.

```ts
twoFactor({
    issuer: "my-app-name" // [!code highlight]
})
```
---

## Schema

The plugin requires 1 additional fields in the `user` table and 1 additional table to store the two factor authentication data.

<DatabaseTable
    fields={[
        { name: "twoFactorEnabled", type: "boolean", description: "Whether two factor authentication is enabled for the user.", isOptional: true },
    ]}
/>

Table: `twoFactor`

<DatabaseTable
    fields={[
        { name: "id", type: "string", description: "The id of the two factor authentication.", isPrimaryKey: true },
        { name: "userId", type: "string", description: "The id of the user", isForeignKey: true },
        { name: "secret", type: "string", description: "The secret used to generate the TOTP code.", isOptional: true },
        { name: "backupCodes", type: "string", description: "The backup codes used to recover access to the account if the user loses access to their phone or email.", isOptional: true },
    ]}
/>

## Options

### Server

**twoFactorTable**: The name of the table that stores the two factor authentication data. Default: `twoFactor`.

**skipVerificationOnEnable**: Skip the verification process before enabling two factor for a user.

**Issuer**: The issuer is the name of your application. It's used to generate TOTP codes. It'll be displayed in the authenticator apps.

**TOTP options**

these are options for TOTP.

<TypeTable
  type={{
    digits:{
        description: "The number of digits the otp to be",
        type: "number",
        default: 6,
    },
    period: {
        description: "The period for otp in seconds.",
        type: "number",
        default: 30,
    },
  }}
/>

**OTP options**

these are options for OTP.

<TypeTable
  type={{
    sendOTP: {
        description: "a function that sends the otp to the user's email or phone number. It takes two parameters: user and otp",
        type: "function",
    },
    period: {
        description: "The period for otp in seconds.", 
        type: "number",
        default: 30,
    },
  }}
  />

**Backup Code Options**

backup codes are generated and stored in the database when the user enabled two factor authentication. This can be used to recover access to the account if the user loses access to their phone or email.

<TypeTable
    type={{
        amount: {
            description: "The amount of backup codes to generate",
            type: "number",
            default: 10,
        },
        length: {
            description: "The length of the backup codes",
            type: "number",
            default: 10,
        },
        customBackupCodesGenerate: {
            description: "A function that generates custom backup codes. It takes no parameters and returns an array of strings.",
            type: "function",
        },
    }}
/>

### Client

To use the two factor plugin in the client, you need to add it on your plugins list.

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client"
import { twoFactorClient } from "better-auth/client/plugins"

const authClient =  createAuthClient({
    plugins: [
        twoFactorClient({ // [!code highlight]
            onTwoFactorRedirect(){
                window.location.href = "/2fa" // Handle the 2FA verification redirect
            }
        }) // [!code highlight]
    ]
})
```


**Options**

`onTwoFactorRedirect`: A callback that will be called when the user needs to verify their 2FA code. This can be used to redirect the user to the 2FA page.

</document_content>
</document>
<document index="2">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/admin.mdx</source>
<document_content>
---
title: Admin
description: Admin plugin for Better Auth
---

The Admin plugin provides a set of administrative functions for user management in your application. It allows administrators to perform various operations such as creating users, managing user roles, banning/unbanning users, impersonating users, and more.

## Installation

<Steps>
  <Step>
    ### Add the plugin to your auth config

    To use the Admin plugin, add it to your auth config.

    ```ts title="auth.ts"
    import { betterAuth } from "better-auth"
    import { admin } from "better-auth/plugins" // [!code highlight]

    export const auth = betterAuth({
        // ... other config options
        plugins: [
            admin() // [!code highlight]
        ]
    })
    ```

  </Step>

    <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```bash
            npx @better-auth/cli migrate
            ```
            </Tab>
            <Tab value="generate">
            ```bash
            npx @better-auth/cli generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>

  <Step>
    ### Add the client plugin

    Next, include the admin client plugin in your authentication client instance.

    ```ts title="auth-client.ts"
    import { createAuthClient } from "better-auth/client"
    import { adminClient } from "better-auth/client/plugins"

    const authClient = createAuthClient({
        plugins: [
            adminClient()
        ]
    })
    ```

  </Step>
</Steps>

## Usage

Before performing any admin operations, the user must be authenticated with an admin account. An admin is any user assigned the `admin` role or any user whose ID is included in the `adminUserIds` option.

### Create User

Allows an admin to create a new user.

```ts title="admin.ts"
const newUser = await authClient.admin.createUser({
  name: "Test User",
  email: "test@example.com",
  password: "password123",
  role: "user", // this can also be an array for multiple roles (e.g. ["user", "sale"])
  data: {
    // any additional on the user table including plugin fields and custom fields
    customField: "customValue",
  },
});
```

### List Users

Allows an admin to list all users in the database.

```ts title="admin.ts"
const users = await authClient.admin.listUsers({
  query: {
    limit: 10,
  },
});
```

By default, 100 users are returned. You can adjust the limit and offset using the following query parameters:

- `search`: The search query to apply to the users. It can be an object with the following properties:
  - `field`: The field to search on, which can be `email` or `name`.
  - `operator`: The operator to use for the search. It can be `contains`, `starts_with`, or `ends_with`.
  - `value`: The value to search for.
- `limit`: The number of users to return.
- `offset`: The number of users to skip.
- `sortBy`: The field to sort the users by.
- `sortDirection`: The direction to sort the users by. Defaults to `asc`.
- `filter`: The filter to apply to the users. It can be an array of objects.

```ts title="admin.ts"
const users = await authClient.admin.listUsers({
    query: {
        searchField: "email",
        searchOperator: "contains",
        searchValue: "@example.com",
        limit: 10,
        offset: 0,
        sortBy: "createdAt",
        sortDirection: "desc"
        filterField: "role",
        filterOperator: "eq",
        filterValue: "admin"
    }
});
```

#### Pagination

The `listUsers` function supports pagination by returning metadata alongside the user list. The response includes the following fields:  

```ts
{
  users: User[],   // Array of returned users
  total: number,   // Total number of users after filters and search queries
  limit: number | undefined,   // The limit provided in the query
  offset: number | undefined   // The offset provided in the query
}
```

##### How to Implement Pagination  

To paginate results, use the `total`, `limit`, and `offset` values to calculate:  

- **Total pages:** `Math.ceil(total / limit)`  
- **Current page:** `(offset / limit) + 1`  
- **Next page offset:** `Math.min(offset + limit, (total - 1))` – The value to use as `offset` for the next page, ensuring it does not exceed the total number of pages.
- **Previous page offset:** `Math.max(0, offset - limit)` – The value to use as `offset` for the previous page (ensuring it doesn’t go below zero).

##### Example Usage  

Fetching the second page with 10 users per page:  

```ts title="admin.ts"
const pageSize = 10;
const currentPage = 2;

const users = await authClient.admin.listUsers({
    query: {
        limit: pageSize,
        offset: (currentPage - 1) * pageSize
    }
});

const totalUsers = users.total;
const totalPages = Math.ceil(totalUsers / limit)
```

### Set User Role

Changes the role of a user.

```ts title="admin.ts"
const updatedUser = await authClient.admin.setRole({
  userId: "user_id_here",
  role: "admin", // this can also be an array for multiple roles (e.g. ["admin", "sale"])
});
```

### Ban User

Bans a user, preventing them from signing in and revokes all of their existing sessions.

```ts title="admin.ts"
const bannedUser = await authClient.admin.banUser({
  userId: "user_id_here",
  banReason: "Spamming", // Optional (if not provided, the default ban reason will be used - No reason)
  banExpiresIn: 60 * 60 * 24 * 7, // Optional (if not provided, the ban will never expire)
});
```

### Unban User

Removes the ban from a user, allowing them to sign in again.

```ts title="admin.ts"
const unbannedUser = await authClient.admin.unbanUser({
  userId: "user_id_here",
});
```

### List User Sessions

Lists all sessions for a user.

```ts title="admin.ts"
const sessions = await authClient.admin.listUserSessions({
  userId: "user_id_here",
});
```

### Revoke User Session

Revokes a specific session for a user.

```ts title="admin.ts"
const revokedSession = await authClient.admin.revokeUserSession({
  sessionToken: "session_token_here",
});
```

### Revoke All Sessions for a User

Revokes all sessions for a user.

```ts title="admin.ts"
const revokedSessions = await authClient.admin.revokeUserSessions({
  userId: "user_id_here",
});
```

### Impersonate User

This feature allows an admin to create a session that mimics the specified user. The session will remain active until either the browser session ends or it reaches 1 hour. You can change this duration by setting the `impersonationSessionDuration` option.

```ts title="admin.ts"
const impersonatedSession = await authClient.admin.impersonateUser({
  userId: "user_id_here",
});
```

### Stop Impersonating User

To stop impersonating a user and continue with the admin account, you can use `stopImpersonating`

```ts title="admin.ts"
await authClient.admin.stopImpersonating();
```

### Remove User

Hard deletes a user from the database.

```ts title="admin.ts"
const deletedUser = await authClient.admin.removeUser({
  userId: "user_id_here",
});
```

## Access Control

The admin plugin offers a highly flexible access control system, allowing you to manage user permissions based on their role. You can define custom permission sets to fit your needs.

### Roles

By default, there are two roles:

`admin`: Users with the admin role have full control over other users.

`user`: Users with the user role have no control over other users.

<Callout>
  A user can have multiple roles. Multiple roles are stored as string separated by comma (",").
</Callout>

### Permissions

By default, there are two resources with up to six permissions.

**user**:
  `create` `list` `set-role` `ban` `impersonate` `delete` `set-password`

**session**:
  `list` `revoke` `delete`

Users with the admin role have full control over all the resources and actions. Users with the user role have no control over any of those actions.

### Custom Permissions

The plugin provides an easy way to define your own set of permissions for each role.

<Steps>
    <Step>
    #### Create Access Control

    You first need to create an access controller by calling the `createAccessControl` function and passing the statement object. The statement object should have the resource name as the key and the array of actions as the value.
    ```ts title="permissions.ts"
    import { createAccessControl } from "better-auth/plugins/access";

    /**
     * make sure to use `as const` so typescript can infer the type correctly
     */
    const statement = { // [!code highlight]
        project: ["create", "share", "update", "delete"], // [!code highlight]
    } as const; // [!code highlight]

    const ac = createAccessControl(statement); // [!code highlight]
    ```
    </Step>

    <Step>
    #### Create Roles

    Once you have created the access controller you can create roles with the permissions you have defined.

    ```ts title="permissions.ts"
    import { createAccessControl } from "better-auth/plugins/access";

    const statement = {
        project: ["create", "share", "update", "delete"],
    } as const;

    const ac = createAccessControl(statement);

    const user = ac.newRole({ // [!code highlight]
        project: ["create"], // [!code highlight]
    }); // [!code highlight]

    const admin = ac.newRole({ // [!code highlight]
        project: ["create", "update"], // [!code highlight]
    }); // [!code highlight]

    const myCustomRole = ac.newRole({ // [!code highlight]
        project: ["create", "update", "delete"], // [!code highlight]
        user: ["ban"], // [!code highlight]
    }); // [!code highlight]
    ```

      When you create custom roles for existing roles, the predefined permissions for those roles will be overridden. To add the existing permissions to the custom role, you need to import `defaultStatements` and merge it with your new statement, plus merge the roles' permissions set with the default roles.

    ```ts title="permissions.ts"
    import { createAccessControl } from "better-auth/plugins/access";
    import { defaultStatements, adminAc } from "better-auth/plugins/admin/access";

    const statement = {
        ...defaultStatements, // [!code highlight]
        project: ["create", "share", "update", "delete"],
    } as const;

    const ac = createAccessControl(statement);

    const admin = ac.newRole({
        project: ["create", "update"],
        ...adminAc.statements, // [!code highlight]
    });
    ```

    </Step>

    <Step>
        #### Pass Roles to the Plugin

        Once you have created the roles you can pass them to the organization plugin both on the client and the server.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { admin as adminPlugin } from "better-auth/plugins"
        import { ac, admin, user } from "@/auth/permissions"

        export const auth = betterAuth({
            plugins: [
                adminPlugin({
                    ac,
                    roles: {
                        admin,
                        user,
                        myCustomRole
                    }
                }),
            ],
        });
        ```

        You also need to pass the access controller and the roles to the client plugin.

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        import { adminClient } from "better-auth/client/plugins"
        import { ac, admin, user, myCustomRole } from "@/auth/permissions"

        export const client = createAuthClient({
            plugins: [
                adminClient({
                    ac,
                    roles: {
                        admin,
                        user,
                        myCustomRole
                    }
                })
            ]
        })
        ```
    </Step>

</Steps>

### Access Control Usage

**Has Permission**:

To check a user's permissions, you can use the `hasPermission` function provided by the client.

```ts title="auth-client.ts"
const canCreateProject = await authClient.admin.hasPermission({
  permission: {
    project: ["create"],
  },
});
```

If you want to check a user's permissions server-side, you can use the `userHasPermission` action provided by the `api` to check the user's permissions.

```ts title="api.ts"
import { auth } from "@/auth";
auth.api.userHasPermission({
  body: {
    userId: 'id', //the user id
    permission: {
      project: ["create"], // This must match the structure in your access control
    },
  },
});

//you can also just pass the role directly
auth.api.userHasPermission({
  body: {
   role: "admin",
    permission: {
      project: ["create"], // This must match the structure in your access control
    },
  },
});
```


**Check Role Permission**:

Once you have defined the roles and permissions to avoid checking the permission from the server you can use the `checkRolePermission` function provided by the client.

```ts title="auth-client.ts"
const canCreateProject = client.admin.checkRolePermission({
  permission: {
    user: ["delete"],
  },
  role: "admin",
});
```

## Schema

This plugin adds the following fields to the `user` table:

<DatabaseTable
  fields={[
    {
      name: "role",
      type: "string",
      description:
        "The user's role. Defaults to `user`. Admins will have the `admin` role.",
      isOptional: true,
    },
    {
      name: "banned",
      type: "boolean",
      description: "Indicates whether the user is banned.",
      isOptional: true,
    },
    {
      name: "banReason",
      type: "string",
      description: "The reason for the user's ban.",
      isOptional: true,
    },
    {
      name: "banExpires",
      type: "number",
      description: "The Unix timestamp when the user's ban will expire.",
      isOptional: true,
    },
  ]}
/>

And adds one field in the `session` table:

<DatabaseTable
  fields={[
    {
      name: "impersonatedBy",
      type: "string",
      description: "The ID of the admin that is impersonating this session.",
      isOptional: true,
    },
  ]}
/>

## Options

### Default Role

The default role for a user. Defaults to `user`.

```ts title="auth.ts"
admin({
  defaultRole: "regular",
});
```
### Admin Roles

The roles that are considered admin roles. Defaults to `["admin"]`.

```ts title="auth.ts"
admin({
  adminRoles: ["admin", "superadmin"],
});
```

<Callout type="warning">
  Any role that isn't in the `adminRoles` list, even if they have the permission,
  will not be considered an admin.
</Callout>

### Admin userIds

You can pass an array of userIds that should be considered as admin. Default to `[]`

```ts title="auth.ts"
admin({
    adminUserIds: ["user_id_1", "user_id_2"]
})
```

If a user is in the `adminUserIds` list, they will be able to perform any admin operation.

### impersonationSessionDuration

The duration of the impersonation session in seconds. Defaults to 1 hour.

```ts title="auth.ts"
admin({
  impersonationSessionDuration: 60 * 60 * 24, // 1 day
});
```

### Default Ban Reason

The default ban reason for a user created by the admin. Defaults to `No reason`.

```ts title="auth.ts"
admin({
  defaultBanReason: "Spamming",
});
```

### Default Ban Expires In

The default ban expires in for a user created by the admin in seconds. Defaults to `undefined` (meaning the ban never expires).

```ts title="auth.ts"
admin({
  defaultBanExpiresIn: 60 * 60 * 24, // 1 day
});
```

### bannedUserMessage

The message to show when a banned user tries to sign in. Defaults to "You have been banned from this application. Please contact support if you believe this is an error."

```ts title="auth.ts"
admin({
  bannedUserMessage: "Custom banned user message",
});
```


</document_content>
</document>
<document index="3">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/anonymous.mdx</source>
<document_content>
---
title: Anonymous  
description: Anonymous plugin for Better Auth.
---

The Anonymous plugin allows users to have an authenticated experience without requiring them to provide an email address, password, OAuth provider, or any other Personally Identifiable Information (PII). Users can later link an authentication method to their account when ready.

## Installation

<Steps>
  <Step>
    ### Add the plugin to your auth config

    To enable anonymous authentication, add the anonymous plugin to your authentication configuration.

    ```ts title="auth.ts"
    import { betterAuth } from "better-auth"
    import { anonymous } from "better-auth/plugins" // [!code highlight]
    
    export const auth = betterAuth({
        // ... other config options
        plugins: [
            anonymous() // [!code highlight]
        ]
    })
    ```
  </Step>

    <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```bash
            npx @better-auth/cli migrate
            ```
            </Tab>
            <Tab value="generate">
            ```bash
            npx @better-auth/cli generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>

  <Step>
    ### Add the client plugin

    Next, include the anonymous client plugin in your authentication client instance.

    ```ts title="auth-client.ts"
    import { createAuthClient } from "better-auth/client"
    import { anonymousClient } from "better-auth/client/plugins"
    
    const authClient =  createAuthClient({
        plugins: [
            anonymousClient()
        ]
    })
    ```
  </Step>
</Steps>

## Usage

### Sign In

To sign in a user anonymously, use the `signIn.anonymous()` method.

```ts title="example.ts"
const user = await authClient.signIn.anonymous()
```

### Link Account

If a user is already signed in anonymously and tries to `signIn` or `signUp` with another method, their anonymous activities can be linked to the new account.

To do that you first need to provide `onLinkAccount` callback to the plugin.

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    plugins: [
        anonymous({
            onLinkAccount: async ({ anonymousUser, newUser }) => {
               // perform actions like moving the cart items from anonymous user to the new user
            }
        })
    ]
```

Then when you call `signIn` or `signUp` with another method, the `onLinkAccount` callback will be called. And the `anonymousUser` will be deleted by default.

```ts title="example.ts"
const user = await authClient.signIn.email({
    email,
})
```

## Options

- `emailDomainName`: The domain name to use when generating an email address for anonymous users. Defaults to the domain name of the current site.

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    plugins: [
        anonymous({
            emailDomainName: "example.com"
        })
    ]
})
```

- `onLinkAccount`: A callback function that is called when an anonymous user links their account to a new authentication method. The callback receives an object with the `anonymousUser` and the `newUser`.

- `disableDeleteAnonymousUser`: By default, the anonymous user is deleted when the account is linked to a new authentication method. Set this option to `true` to disable this behavior.


## Schema

The anonymous plugin requires an additional field in the user table:

<DatabaseTable
    fields={[
        { name: "isAnonymous", type: "boolean", description: "Indicates whether the user is anonymous.", isOptional: true },
    ]}
/>

</document_content>
</document>
<document index="4">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/api-key.mdx</source>
<document_content>
---
title: API Key
description: API Key plugin for Better Auth.
---

The API Key plugin allows you to create and manage API keys for your application. It provides a way to authenticate and authorize API requests by verifying API keys.

## Features

- Create, manage, and verify API keys
- [Built-in rate limiting](/docs/plugins/api-key#rate-limiting)
- [Custom expiration times, remaining count, and refill systems](/docs/plugins/api-key#remaining-refill-and-expiration)
- [metadata for API keys](/docs/plugins/api-key#metadata)
- Custom prefix
- [Sessions from API keys](/docs/plugins/api-key#sessions-from-api-keys)

## Installation

<Steps>
    <Step>
        ### Add Plugin to the server

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { apiKey } from "better-auth/plugins"

        const auth = betterAuth({
            plugins: [ // [!code highlight]
                apiKey() // [!code highlight]
            ] // [!code highlight]
        })
        ```
    </Step>
    <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```bash
            npx @better-auth/cli migrate
            ```
            </Tab>
            <Tab value="generate">
            ```bash
            npx @better-auth/cli generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>
    <Step>
        ### Add the client plugin

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        import { apiKeyClient } from "better-auth/client/plugins"

        const authClient = createAuthClient({
            plugins: [ // [!code highlight]
                apiKeyClient() // [!code highlight]
            ] // [!code highlight]
        })
        ```
    </Step>

</Steps>

## Usage

You can view the list of API Key plugin options [here](/docs/plugins/api-key#api-key-plugin-options).

### Create an API key

<Endpoint path="/api-key/create" method="POST" />

<Tabs items={['Client', 'Server']}>
    <Tab value="Client">
      ```ts
      const { data: apiKey, error } = await authClient.apiKey.create({
          name: "My API Key",
          expiresIn: 60 * 60 * 24 * 7, // 7 days
          prefix: "my_app",
          metadata: {
              tier: "premium",
          },
      });
      ```
    </Tab>
    <Tab value="Server">
    on the server, you can create an API key for a user by passing the `userId` property in the body. And allows you to add any properties you want to the API key.

    ```ts
      const apiKey = await auth.api.createApiKey({
          body: {
            name: "My API Key",
            expiresIn: 60 * 60 * 24 * 365, // 1 year
            prefix: "my_app",
            remaining: 100,
            refillAmount: 100,
            refillInterval: 60 * 60 * 24 * 7, // 7 days
            metadata: {
                tier: "premium",
            },
            rateLimitTimeWindow: 1000 * 60 * 60 * 24, // everyday
            rateLimitMax: 100, // every day, they can use up to 100 requests
            rateLimitEnabled: true,
            userId: user.id, // the user id to create the API key for
          },
      });
      ```
    </Tab>
</Tabs>

All API keys are assigned to a user. If you're creating an API key on the server, without access to headers, you must pass the `userId` property. This is the ID of the user that the API key is associated with.

#### Properties

All properties are optional. However if you pass a `refillAmount`, you must also pass a `refillInterval`, and vice versa.

- `name`?: The name of the API key.
- `expiresIn`?: The expiration time of the API key in seconds. If not provided, the API key will never expire.
- `prefix`?: The prefix of the API key. This is used to identify the API key in the database.
- `metadata`?: The metadata of the API key. This is used to store additional information about the API key.

<DividerText>Server Only Properties</DividerText>

- `remaining`?: The remaining number of requests for the API key. If `null`, then there is no cap to key usage.
- `refillAmount`?: The amount to refill the `remaining` count of the API key.
- `refillInterval`?: The interval to refill the API key in milliseconds.
- `rateLimitTimeWindow`?: The duration in milliseconds where each request is counted. Once the `rateLimitMax` is reached, the request will be rejected until the `timeWindow` has passed, at which point the time window will be reset.
- `rateLimitMax`?: The maximum number of requests allowed within the `rateLimitTimeWindow`.
- `rateLimitEnabled`?: Whether rate limiting is enabled for the API key.
- `permissions`?: Permissions for the API key, structured as a record mapping resource types to arrays of allowed actions.

```ts
const example = {
  projects: ["read", "read-write"]
}
```
- `userId`?: The ID of the user associated with the API key. When creating an API Key, you must pass the headers of the user who will own the key. However if you do not have the headers, you can pass this field, which will allow you to bypass the need for headers.

#### Result

It'll return the `ApiKey` object which includes the `key` value for you to use.
Otherwise if it throws, it will throw an `APIError`.

---

### Verify an API key

<Endpoint path="/api-key/verify" method="POST" isServerOnly />

```ts
const { valid, error, key } = await auth.api.verifyApiKey({
  body: {
    key: "your_api_key_here",
  },
});

//with permissions check
const { valid, error, key } = await auth.api.verifyApiKey({
  body: {
    key: "your_api_key_here",
    permissions: {
      projects: ["read", "read-write"]
    }
  },
});
```

#### Properties

- `key`: The API Key to validate
- `permissions`?: The permissions to check against the API key.

#### Result

```ts
type Result = {
  valid: boolean;
  error: { message: string; code: string } | null;
  key: Omit<ApiKey, "key"> | null;
};
```

---

### Get an API key

<Endpoint method="GET" path="/api-key/get" isServerOnly />

```ts
const key = await auth.api.getApiKey({
  body: {
    keyId: "your_api_key_id_here",
  },
});
```

#### Properties

- `keyId`: The API Key id to get information on.

#### Result

You'll receive everything about the API key details, except for the `key` value itself.
If it fails, it will throw an `APIError`.

```ts
type Result = Omit<ApiKey, "key">;
```

---

### Update an API key

<Endpoint method="POST" path="/api-key/update" isServerOnly />

<Tabs items={['Client', 'Server']}>
    <Tab value="Client">
      ```ts
      const { data: apiKey, error } = await authClient.apiKey.update({
        keyId: "your_api_key_id_here",
        name: "New API Key Name",
        enabled: false,
      });
      ```
    </Tab>
    <Tab value="Server">
    You can update an API key on the server by passing the `keyId` and any other properties you want to update.
      ```ts
      const apiKey = await auth.api.updateApiKey({
        body: {
          keyId: "your_api_key_id_here",
          name: "New API Key Name",
          userId: "userId",
          enabled: false,
          remaining: 100,
          refillAmount: null,
          refillInterval: null,
          metadata: null,
          expiresIn: 60 * 60 * 24 * 7,
          rateLimitEnabled: false,
          rateLimitTimeWindow: 1000 * 60 * 60 * 24,
          rateLimitMax: 100,
        },
      });
      ```
    </Tab>
</Tabs>

#### Properties
  <DividerText>Client</DividerText>
- `keyId`: The API key Id to update on.
- `name`?: Update the key name.

  <DividerText>Server Only</DividerText>
- `userId`?: Update the user id who owns this key.
- `name`?: Update the key name.
- `enabled`?: Update whether the API key is enabled or not.
- `remaining`?: Update the remaining count.
- `refillAmount`?: Update the amount to refill the `remaining` count every interval.
- `refillInterval`?: Update the interval to refill the `remaining` count.
- `metadata`?: Update the metadata of the API key.
- `expiresIn`?: Update the expiration time of the API key. In seconds.
- `rateLimitEnabled`?: Update whether the rate-limiter is enabled or not.
- `rateLimitTimeWindow`?: Update the time window for the rate-limiter.
- `rateLimitMax`?: Update the maximum number of requests they can make during the rate-limit-time-window.

#### Result

If fails, throws `APIError`.
Otherwise, you'll receive the API Key details, except for the `key` value itself.

---

### Delete an API Key

<Endpoint method="POST" path="/api-key/delete" />
<Tabs items={['Client', 'Server']}>
    <Tab value="Client">
      ```ts
      const { data: result, error } = await authClient.apiKey.delete({
        keyId: "your_api_key_id_here",
      });
      ```
    </Tab>
    <Tab value="Server">
      ```ts
      const apiKey = await auth.api.deleteApiKey({
        body: {
          keyId: "your_api_key_id_here",
          userId: "userId", 
        },
      });
      ```
    </Tab>
</Tabs>

#### Properties

- `keyId`: The API Key id to delete.

#### Result

If fails, throws `APIError`.
Otherwise, you'll receive:

```ts
type Result = {
  success: boolean;
};
```

---

### List API keys

<Endpoint method="GET" path="/api-key/list" />

<Tabs items={['Client', 'Server']}>
    <Tab value="Client">
      ```ts
      const { data: apiKeys, error } = await authClient.apiKey.list();
      ```
    </Tab>
    <Tab value="Server">
      ```ts
      const apiKeys = await auth.api.listApiKeys({
        headers: user_headers,
      });
      ```
    </Tab>
</Tabs>

#### Result

If fails, throws `APIError`.
Otherwise, you'll receive:

```ts
type Result = ApiKey[]
```
---

### Delete all expired API keys

This function will delete all API keys that have an expired expiration date.

<Endpoint method="DELETE" path="/api-key/delete-all-expired-api-keys" isServerOnly />
```ts
await auth.api.deleteAllExpiredApiKeys();
```

<Callout>
  We automatically delete expired API keys every time any apiKey plugin
  endpoints were called, however they are rate-limited to a 10 second cool down
  each call to prevent multiple calls to the database.
</Callout>

---

## Sessions from API keys

Any time an endpoint in Better Auth is called that has a valid API key in the headers, we will automatically create a mock session to represent the user.

The default header key is `x-api-key`, but this can be changed by setting the `apiKeyHeaders` option in the plugin options.

```ts
export const auth = betterAuth({
  plugins: [
    apiKey({
      apiKeyHeaders: ['x-api-key', 'xyz-api-key'], // or you can pass just a string, eg: "x-api-key"
    })
  ]
})
```

Or optionally, you can pass an `apiKeyGetter` function to the plugin options, which will be called with the `GenericEndpointContext`, and from there, you should return the API key, or `null` if the request is invalid.

```ts
export const auth = betterAuth({
  plugins: [
    apiKey({
      apiKeyGetter: (ctx) => {
        const has = ctx.request.headers.has('x-api-key')
        if(!has) return null
        return ctx.request.headers.get('x-api-key')
      }
    })
  ]
})
```

## Rate Limiting

Every API key can have its own rate limit settings, however, the built-in rate-limiting only applies to the verification process for a given API key.
For every other endpoint/method, you should utilize Better Auth's [built-in rate-limiting](/docs/concepts/rate-limit).

You can refer to the rate-limit default configurations below in the API Key plugin options.

An example default value:

```ts
export const auth = betterAuth({
  plugins: [
    apiKey({
      rateLimit: {
        enabled: true,
        timeWindow: 1000 * 60 * 60 * 24, // 1 day
        maxRequests: 10, // 10 requests per day
      },
    })
  ]
})
```

For each API key, you can customize the rate-limit options on create.

<Callout>
  You can only customize the rate-limit options on the server auth instance.
</Callout>

```ts
const apiKey = await auth.api.createApiKey({
  body: {
    rateLimitEnabled: true,
    rateLimitTimeWindow: 1000 * 60 * 60 * 24, // 1 day
    rateLimitMax: 10, // 10 requests per day
  },
  headers: user_headers,
});
```

### How does it work?

For each request, a counter (internally called `requestCount`) is incremented.  
If the `rateLimitMax` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset.

## Remaining, refill, and expiration

The remaining count is the number of requests left before the API key is disabled.  
The refill interval is the interval in milliseconds where the `remaining` count is refilled by day.  
The expiration time is the expiration date of the API key.

### How does it work?

#### Remaining:
Whenever an API key is used, the `remaining` count is updated.  
If the `remaining` count is `null`, then there is no cap to key usage.  
Otherwise, the `remaining` count is decremented by 1.  
If the `remaining` count is 0, then the API key is disabled & removed.

#### refillInterval & refillAmount:
Whenever an API key is created, the `refillInterval` and `refillAmount` are set to `null`.  
This means that the API key will not be refilled automatically.  
However, if `refillInterval` & `refillAmount` are set, then the API key will be refilled accordingly.

#### Expiration:
Whenever an API key is created, the `expiresAt` is set to `null`.  
This means that the API key will never expire.  
However, if the `expiresIn` is set, then the API key will expire after the `expiresIn` time.


## Custom Key generation & verification

You can customize the key generation and verification process straight from the plugin options.

Here's an example:

```ts
export const auth = betterAuth({
  plugins: [
    apiKey({
      customKeyGenerator: (options: { length: number, prefix: string | undefined }) => {
        const apiKey = mySuperSecretApiKeyGenerator(options.length, options.prefix);
        return apiKey;
      },
      customAPIKeyValidator: ({ctx, key}) => {
          if(key.endsWith("_super_secret_api_key")) {
            return true;
          } else {
            return false;
          }
      },
    })
  ]
});
```

If an API key is validated from your `customAPIKeyValidator`, we still must match that against the database's key.
However, by providing this custom function, you can improve the performance of the API key verification process,
as all failed keys can be invalidated without having to query your database.

## Metadata

We allow you to store metadata alongside your API keys. This is useful for storing information about the key, such as a subscription plan for example.

To store metadata, make sure you haven't disabled the metadata feature in the plugin options.
```ts
export const auth = betterAuth({
  plugins: [
    apiKey({
      enableMetadata: true,
    })
  ]
})
```

Then, you can store metadata in the `metadata` field of the API key object.
```ts
const apiKey = await auth.api.createApiKey({
  body: {
    metadata: {
      plan: "premium",
    },
  },
});
```

You can then retrieve the metadata from the API key object.
```ts
const apiKey = await auth.api.getApiKey({
  body: {
    keyId: "your_api_key_id_here",
  },
});

console.log(apiKey.metadata.plan); // "premium"
```

## API Key plugin options

`apiKeyHeaders` <span className="opacity-70">`string | string[];`</span>

The header name to check for api key. Default is `x-api-key`.


`customAPIKeyGetter` <span className="opacity-70">`(ctx: GenericEndpointContext) => string | null`</span>

A custom function to get the API key from the context.


`customAPIKeyValidator` <span className="opacity-70">`(options: { ctx: GenericEndpointContext; key: string; }) => boolean`</span>

A custom function to validate the API key.

`customKeyGenerator` <span className="opacity-70">`(options: { length: number; prefix: string | undefined; }) => string | Promise<string>`</span>

A custom function to generate the API key.

`startingCharactersConfig` <span className="opacity-70">`{ shouldStore?: boolean; charactersLength?: number; }`</span>

Customize the starting characters configuration.

<Accordions>
  <Accordion title="startingCharactersConfig Options">
    `shouldStore` <span className="opacity-70">`boolean`</span>

    Wether to store the starting characters in the database.  
    If false, we will set `start` to `null`.  
    Default is `true`.
    
    `charactersLength` <span className="opacity-70">`number`</span>

    The length of the starting characters to store in the database.  
    This includes the prefix length.  
    Default is `6`.
  </Accordion>
</Accordions>

`defaultKeyLength` <span className="opacity-70">`number`</span>

The length of the API key. Longer is better. Default is 64. (Doesn't include the prefix length)

`defaultPrefix` <span className="opacity-70">`string`</span>

The prefix of the API key.

Note: We recommend you append an underscore to the prefix to make the prefix more identifiable. (eg `hello_`)

`maximumPrefixLength` <span className="opacity-70">`number`</span>

The maximum length of the prefix.

`minimumPrefixLength` <span className="opacity-70">`number`</span>

The minimum length of the prefix.

`maximumNameLength` <span className="opacity-70">`number`</span>

The maximum length of the name.

`minimumNameLength` <span className="opacity-70">`number`</span>

The minimum length of the name.

`enableMetadata` <span className="opacity-70">`boolean`</span>

Whether to enable metadata for an API key.

`keyExpiration` <span className="opacity-70">`{ defaultExpiresIn?: number | null; disableCustomExpiresTime?: boolean; minExpiresIn?: number; maxExpiresIn?: number; }`</span>

Customize the key expiration.

<Accordions>
  <Accordion title="keyExpiration options">
    `defaultExpiresIn` <span className="opacity-70">`number | null`</span>

    The default expires time in milliseconds.
    If `null`, then there will be no expiration time.
    Default is `null`.

    `disableCustomExpiresTime` <span className="opacity-70">`boolean`</span>

    Wether to disable the expires time passed from the client.  
    If `true`, the expires time will be based on the default values.
    Default is `false`.

    `minExpiresIn` <span className="opacity-70">`number`</span>

    The minimum expiresIn value allowed to be set from the client. in days.
    Default is `1`.

    `maxExpiresIn` <span className="opacity-70">`number`</span>

    The maximum expiresIn value allowed to be set from the client. in days.
    Default is `365`.
  </Accordion>
</Accordions>

`rateLimit` <span className="opacity-70">`{ enabled?: boolean; timeWindow?: number; maxRequests?: number; }`</span>

Customize the rate-limiting.

<Accordions>
  <Accordion title="rateLimit options">
    `enabled` <span className="opacity-70">`boolean`</span>

    Whether to enable rate limiting. (Default true)

    `timeWindow` <span className="opacity-70">`number`</span>

    The duration in milliseconds where each request is counted.  
    Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset.  

    `maxRequests` <span className="opacity-70">`number`</span>

    Maximum amount of requests allowed within a window.  
    Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset.
  </Accordion>
</Accordions>


`schema` <span className="opacity-70">`InferOptionSchema<ReturnType<typeof apiKeySchema>>`</span>

Custom schema for the api key plugin.

`disableSessionForAPIKeys` <span className="opacity-70">`boolean`</span>

An API Key can represent a valid session, so we automatically mock a session for the user if we find a valid API key in the request headers.  

`permissions` <span className="opacity-70">`{ defaultPermissions?: Statements | ((userId: string, ctx: GenericEndpointContext) => Statements | Promise<Statements>) }`</span>

Permissions for the API key.

Read more about permissions [here](/docs/plugins/api-key#permissions).

<Accordions>
  <Accordion title="permissions Options">
    `defaultPermissions` <span className="opacity-70">`Statements | ((userId: string, ctx: GenericEndpointContext) => Statements | Promise<Statements>)`</span>

    The default permissions for the API key.
  </Accordion>
</Accordions>

---

## Schema

Table: `apiKey`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "The ID of the api key.",
      isUnique: true,
      isPrimaryKey: true,
    },
    {
      name: "name",
      type: "string",
      description: "The name of the API key.",
      isOptional: true,
    },
    {
      name: "start",
      type: "string",
      description:
        "The starting characters of the API key. Useful for showing the first few characters of the API key in the UI for the users to easily identify.",
      isOptional: true,
    },
    {
      name: "prefix",
      type: "string",
      description: "The API Key prefix. Stored as plain text.",
      isOptional: true,
    },
    {
      name: "key",
      type: "string",
      description: "The hashed API key itself.",
    },
    {
      name: "userId",
      type: "string",
      description: "The id of the user who created the API key.",
      isForeignKey: true,
    },
    {
      name: "refillInterval",
      type: "number",
      description: "The interval to refill the key in milliseconds.",
      isOptional: true,
    },
    {
      name: "refillAmount",
      type: "number",
      description: "The amount to refill the remaining count of the key.",
      isOptional: true,
    },
    {
      name: "lastRefillAt",
      type: "Date",
      description: "The date and time when the key was last refilled.",
      isOptional: true,
    },
    {
      name: "enabled",
      type: "boolean",
      description: "Whether the API key is enabled.",
    },
    {
      name: "rateLimitEnabled",
      type: "boolean",
      description: "Whether the API key has rate limiting enabled.",
    },
    {
      name: "rateLimitTimeWindow",
      type: "number",
      description: "The time window in milliseconds for the rate limit.",
      isOptional: true,
    },
    {
      name: "rateLimitMax",
      type: "number",
      description:
        "The maximum number of requests allowed within the `rateLimitTimeWindow`.",
      isOptional: true,
    },
    {
      name: "requestCount",
      type: "number",
      description:
        "The number of requests made within the rate limit time window.",
    },
    {
      name: "remaining",
      type: "number",
      description: "The number of requests remaining.",
      isOptional: true,
    },
    {
      name: "lastRequest",
      type: "Date",
      description: "The date and time of the last request made to the key.",
      isOptional: true,
    },
    {
      name: "expiresAt",
      type: "Date",
      description: "The date and time when the key will expire.",
      isOptional: true,
    },
    {
      name: "createdAt",
      type: "Date",
      description: "The date and time the API key was created.",
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "The date and time the API key was updated.",
    },
    {
      name: "permissions",
      type: "string",
      description: "The permissions of the key.",
      isOptional: true,
    },
    {
      name: "metadata",
      type: "Object",
      isOptional: true,
      description: "Any additional metadata you want to store with the key.",
    },
  ]}
/>

## Permissions

API keys can have permissions associated with them, allowing you to control access at a granular level. Permissions are structured as a record of resource types to arrays of allowed actions.

### Setting Default Permissions

You can configure default permissions that will be applied to all newly created API keys:

```ts
export const auth = betterAuth({
  plugins: [
    apiKey({
      permissions: {
        defaultPermissions: {
          files: ["read"],
          users: ["read"]
        }
      }
    })
  ]
})
```

You can also provide a function that returns permissions dynamically:

```ts
export const auth = betterAuth({
  plugins: [
    apiKey({
      permissions: {
        defaultPermissions: async (userId, ctx) => {
          // Fetch user role or other data to determine permissions
          return {
            files: ["read"],
            users: ["read"]
          };
        }
      }
    })
  ]
})
```

### Creating API Keys with Permissions

When creating an API key, you can specify custom permissions:

```ts
const apiKey = await auth.api.createApiKey({
  body: {
    name: "My API Key",
    permissions: {
      files: ["read", "write"],
      users: ["read"]
    },
    userId: "userId"
  },
});
```

### Verifying API Keys with Required Permissions

When verifying an API key, you can check if it has the required permissions:

```ts
const result = await auth.api.verifyApiKey({
  body: {
    key: "your_api_key_here",
    permissions: {
      files: ["read"]
    }
  }
});

if (result.valid) {
  // API key is valid and has the required permissions
} else {
  // API key is invalid or doesn't have the required permissions
}
```

### Updating API Key Permissions

You can update the permissions of an existing API key:

```ts
const apiKey = await auth.api.updateApiKey({
  body: {
    keyId: existingApiKeyId,
    permissions: {
      files: ["read", "write", "delete"],
      users: ["read", "write"]
    }
  },
  headers: user_headers,
});
```

### Permissions Structure

Permissions follow a resource-based structure:

```ts
type Permissions = {
  [resourceType: string]: string[];
};

// Example:
const permissions = {
  files: ["read", "write", "delete"],
  users: ["read"],
  projects: ["read", "write"]
};
```

When verifying an API key, all required permissions must be present in the API key's permissions for validation to succeed.

</document_content>
</document>
<document index="5">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/bearer.mdx</source>
<document_content>
---
title: Bearer Token Authentication
description: Authenticate API requests using Bearer tokens instead of browser cookies
---

The Bearer plugin enables authentication using Bearer tokens as an alternative to browser cookies. It intercepts requests, adding the Bearer token to the Authorization header before forwarding them to your API.

<Callout type="warn">
  Use this cautiously; it is intended only for APIs that don't support cookies or require Bearer tokens for authentication. Improper implementation could easily lead to security vulnerabilities.
</Callout>

## Installing the Bearer Plugin

Add the Bearer plugin to your authentication setup:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { bearer } from "better-auth/plugins";

export const auth = betterAuth({
    plugins: [bearer()]
});
```

## How to Use Bearer Tokens

### 1. Obtain the Bearer Token

After a successful sign-in, you'll receive a session token in the response headers. Store this token securely (e.g., in `localStorage`):

```ts title="auth-client.ts"
const { data } = await authClient.signIn.email({
    email: "user@example.com",
    password: "securepassword"
}, {
  onSuccess: (ctx)=>{
    const authToken = ctx.response.headers.get("set-auth-token") // get the token from the response headers
    // Store the token securely (e.g., in localStorage)
    localStorage.setItem("bearer_token", authToken);
  }
});
```

You can also set this up globally in your auth client:

```ts title="auth-client.ts"
export const authClient = createAuthClient({
    fetchOptions: {
        onSuccess: (ctx) => {
            const authToken = ctx.response.headers.get("set-auth-token") // get the token from the response headers
            // Store the token securely (e.g., in localStorage)
            if(authToken){
              localStorage.setItem("bearer_token", authToken);
            }
        }
    }
});
```


You may want to clear the token based on the response status code or other conditions:

### 2. Configure the Auth Client

Set up your auth client to include the Bearer token in all requests:

```ts title="auth-client.ts"
export const authClient = createAuthClient({
    fetchOptions: {
        auth: {
           type:"Bearer",
           token: () => localStorage.getItem("bearer_token") || "" // get the token from localStorage
        }
    }
});
```

### 3. Make Authenticated Requests

Now you can make authenticated API calls:

```ts title="auth-client.ts"
// This request is automatically authenticated
const { data } = await authClient.listSessions();
```

### 4. Per-Request Token (Optional)

You can also provide the token for individual requests:

```ts title="auth-client.ts"
const { data } = await authClient.listSessions({
    fetchOptions: {
        headers: {
            Authorization: `Bearer ${token}`
        }
    }
});
```

### 5. Using Bearer Tokens Outside the Auth Client

The Bearer token can be used to authenticate any request to your API, even when not using the auth client:

```ts title="api-call.ts"
const token = localStorage.getItem("bearer_token");

const response = await fetch("https://api.example.com/data", {
  headers: {
    Authorization: `Bearer ${token}`
  }
});

const data = await response.json();
```

And in the server, you can use the `auth.api.getSession` function to authenticate requests:

```ts title="server.ts"
import { auth } from "@/auth";

export async function handler(req, res) {
  const session = await auth.api.getSession({
    headers: req.headers
  });
  
  if (!session) {
    return res.status(401).json({ error: "Unauthorized" });
  }
  
  // Process authenticated request
  // ...
}
```


## Options

**requireSignature** (boolean): Require the token to be signed. Default: `false`.

</document_content>
</document>
<document index="6">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/captcha.mdx</source>
<document_content>
---
title: Captcha
description: Captcha plugin
---

The **Captcha Plugin** integrates bot protection into your Better Auth system by adding captcha verification for key endpoints. This plugin ensures that only human users can perform actions like signing up, signing in, or resetting passwords. Two providers are currently supported: [Google reCAPTCHA](https://developers.google.com/recaptcha) and [Cloudflare Turnstile](https://www.cloudflare.com/application-services/products/turnstile/).

## Installation

<Steps>
  <Step>
    ### Add the plugin to your **auth** config

    ```ts title="auth.ts"
    import { betterAuth } from "better-auth";
    import { captcha } from "better-auth/plugins";

    export const auth = betterAuth({
        plugins: [ // [!code highlight]
            captcha({ // [!code highlight]
                provider: "cloudflare-turnstile", // or "google-recaptcha" // [!code highlight]
                secretKey: process.env.TURNSTILE_SECRET_KEY!, // [!code highlight]
            }), // [!code highlight]
        ], // [!code highlight]
    });
    ```

  </Step>
  <Step>
    ### Add the captcha token to your request headers

    Add the captcha token to your request headers for all protected endpoints. This example shows how to include it in a `signIn` request:

    ```ts
    await authClient.signIn.email({
        email: "user@example.com",
        password: "secure-password",
        fetchOptions: { // [!code highlight]
            headers: { // [!code highlight]
                "x-captcha-response": turnstileToken, // [!code highlight]
            }, // [!code highlight]
        },
    });
    ```

    - To implement Cloudflare Turnstile on the client side, see the official [Cloudflare Turnstile documentation](https://developers.cloudflare.com/turnstile/) or use a library like [react-turnstile](https://www.npmjs.com/package/@marsidev/react-turnstile).
    - To implement Google reCAPTCHA on the client side, see the official [Google reCAPTCHA documentation](https://developers.google.com/recaptcha/intro) or use a library like [react-google-recaptcha](https://www.npmjs.com/package/react-google-recaptcha).

  </Step>
</Steps>

## How it works

<Steps>
  <Step>
    The plugin acts as a middleware: it intercepts all `POST` requests to configured endpoints (see `endpoints`
    in the [Plugin Options](#plugin-options) section).
  </Step>
  <Step>
    it validates the captcha token on the server, by calling the captcha provider's `/siteverify`.
  </Step>
  <Step>
    - if the token is missing, gets rejected by the captcha provider, or if the `/siteverify` endpoint is
    unavailable, the plugin returns an error and interrupts the request.
    - if the token is accepted by the captcha provider, the middleware returns `undefined`, meaning the request is allowed to proceed.

  </Step>
</Steps>

## Plugin Options

- **`provider` (required)**
  Your captcha provider. Supported values are `cloudflare-turnstile` and `google-recaptcha`.
- **`secretKey` (required)**
  Your captcha provider secret key used for the server-side validation of captcha tokens.
- **`endpoints` (optional)**
  An array of paths where captcha validation is enforced. Defaults to: `["/sign-up", "/sign-in", "/forget-password"]`.
- **`siteVerifyURLOverride` (optional)**
  Overrides the endpoint URL for the captcha verification request.

</document_content>
</document>
<document index="7">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/community-plugins.mdx</source>
<document_content>
---
title: Community Plugins
description: A list of recommended community plugins.
---

This page showcases a list of recommended community made plugins.

We encourage you to create custom plugins and maybe get added to the list!

To create your own custom plugin, get started by reading our [plugins documentation](https://www.better-auth.com/docs/concepts/plugins). And if you want to share your plugin with the community, please open a pull request to add it to this list.

| <div className="w-[200px]">Plugin</div>                                         | Description                                                                                          | <div className="w-[150px]">Author</div>                                                                                                                              |
| ------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [better-auth-harmony](https://github.com/gekorm/better-auth-harmony/)           | Email & phone normalization and additional validation, blocking over 55,000 temporary email domains. | <img src="https://github.com/GeKorm.png" className="rounded-full w-6 h-6 border opacity-70 m-0 inline mr-1" /> [GeKorm](https://github.com/GeKorm) |
| [validation-better-auth](https://github.com/Daanish2003/validation-better-auth) | Validate API request using any validation library (e.g., Zod, Yup)                                   | <img src="https://github.com/Daanish2003.png" className="rounded-full w-6 h-6 border opacity-70 m-0 inline mr-1" /> [Daanish2003](https://github.com/Daanish2003) |

</document_content>
</document>
<document index="8">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/email-otp.mdx</source>
<document_content>
---
title: Email OTP
description: Email OTP plugin for Better Auth.
---

The Email OTP plugin allows user to sign-in, verify their email, or reset their password using a one-time password (OTP) sent to their email address.


## Installation

<Steps>
  <Step>
    ### Add the plugin to your auth config

    To enable email otp in your app, you need to add the `emailOTP` plugin to your auth config.

    ```ts title="auth.ts"
    import { betterAuth } from "better-auth"
    import { emailOTP } from "better-auth/plugins" // [!code highlight]
    
    export const auth = betterAuth({
        // ... other config options
        plugins: [
            emailOTP({ // [!code highlight]
                    async sendVerificationOTP({ email, otp, type}) { // [!code highlight]
						// Implement the sendVerificationOTP method to send the OTP to the user's email address // [!code highlight]
					}, // [!code highlight]
            }) // [!code highlight]
        ]
    })
    ```
    </Step>
    <Step>
    ### Add the client plugin

    ```ts title="auth-client.ts"
    import { createAuthClient } from "better-auth/client"
    import { emailOTPClient } from "better-auth/client/plugins"
    
    const authClient =  createAuthClient({
        plugins: [
            emailOTPClient()
        ]
    })
    ```
  </Step>
</Steps>

## Usage

### Send OTP

First, send an OTP to the user's email address.

```ts title="example.ts"
const { data, error } = await authClient.emailOtp.sendVerificationOtp({
    email: "user-email@email.com",
    type: "sign-in" // or "email-verification", "forget-password"
})
```

### SignIn with OTP

Once the user provides the OTP, you can sign in the user using the `signIn.emailOTP()` method.

```ts title="example.ts"
const { data, error } = await authClient.signIn.emailOtp({
    email: "user-email@email.com",
    otp: "123456"
})
```

If the user is not registered, they'll be automatically registered. If you want to prevent this, you can pass `disableSignUp` as `true` in the options.

### Verify Email

To verify the user's email address, use the `verifyEmail()` method.

```ts title="example.ts"
const { data, error } = await authClient.emailOtp.verifyEmail({
    email: "user-email@email.com",
    otp: "123456"
})
```

### Reset Password

To reset the user's password, use the `resetPassword()` method.

```ts title="example.ts"
const { data, error } = await authClient.emailOtp.resetPassword({
    email: "user-email@email.com",
    otp: "123456",
    password: "password"
})
```

## Options

- `sendVerificationOTP`: A function that sends the OTP to the user's email address. The function receives an object with the following properties:
  - `email`: The user's email address.
  - `otp`: The OTP to send.
  - `type`: The type of OTP to send. Can be "sign-in", "email-verification", or "forget-password".

### Example

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    plugins: [
        emailOTP({
            async sendVerificationOTP({
                email,
                otp,
                type
            }) {
                if (type === "sign-in") {
                    // Send the OTP for sign-in
                } else if (type === "email-verification") {
                    // Send the OTP for email verification
                } else {
                    // Send the OTP for password reset
                }
            },
        })
    ]
})
```

- `otpLength`: The length of the OTP. Defaults to `6`.
- `expiresIn`: The expiry time of the OTP in seconds. Defaults to `300` seconds.

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    plugins: [
        emailOTP({
            otpLength: 8,
            expiresIn: 600
        })
    ]
})
```

- `sendVerificationOnSignUp`: A boolean value that determines whether to send the OTP when a user signs up. Defaults to `false`.

- `disableSignUp`: A boolean value that determines whether to prevent automatic sign-up when the user is not registered. Defaults to `false`.

- `generateOTP`: A function that generates the OTP. Defaults to a random 6-digit number.
</document_content>
</document>
<document index="9">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/generic-oauth.mdx</source>
<document_content>
---
title: Generic OAuth
description: Authenticate users with any OAuth provider
---

The Generic OAuth plugin provides a flexible way to integrate authentication with any OAuth provider. It supports both OAuth 2.0 and OpenID Connect (OIDC) flows, allowing you to easily add social login or custom OAuth authentication to your application.

## Installation

<Steps>
  <Step>
    ### Add the plugin to your auth config

    To use the Generic OAuth plugin, add it to your auth config.

    ```ts title="auth.ts"
    import { betterAuth } from "better-auth"
    import { genericOAuth } from "better-auth/plugins" // [!code highlight]
    
    export const auth = betterAuth({
        // ... other config options
        plugins: [ 
            genericOAuth({ // [!code highlight]
                config: [ // [!code highlight]
                    { // [!code highlight] 
                        providerId: "provider-id", // [!code highlight]
                        clientId: "test-client-id", // [!code highlight]
                        clientSecret: "test-client-secret", // [!code highlight]
                        discoveryUrl: "https://auth.example.com/.well-known/openid-configuration", // [!code highlight]
                        // ... other config options // [!code highlight]
                    }, // [!code highlight]
                    // Add more providers as needed // [!code highlight]
                ] // [!code highlight]
            }) // [!code highlight]
        ]
    })
    ```
  </Step>

  <Step>
    ### Add the client plugin

    Include the Generic OAuth client plugin in your authentication client instance.

    ```ts title="auth-client.ts"
    import { createAuthClient } from "better-auth/client"
    import { genericOAuthClient } from "better-auth/client/plugins"
    
    const authClient = createAuthClient({
        plugins: [
            genericOAuthClient()
        ]
    })
    ```
  </Step>
</Steps>

## Usage

The Generic OAuth plugin provides endpoints for initiating the OAuth flow and handling the callback. Here's how to use them:

### Initiate OAuth Sign-In

To start the OAuth sign-in process:

```ts title="sign-in.ts"
const response = await authClient.signIn.oauth2({
  providerId: "provider-id",
  callbackURL: "/dashboard" // the path to redirect to after the user is authenticated
});
```

### Linking OAuth Accounts

To link an OAuth account to an existing user:

```ts title="link-account.ts"
const response = await authClient.oauth2.link({
  providerId: "provider-id",
  callbackURL: "/dashboard" // the path to redirect to after the account is linked
});
```

### Handle OAuth Callback

The plugin mounts a route to handle the OAuth callback `/oauth2/callback/:providerId`. This means by default `${baseURL}/api/auth/oauth2/callback/:providerId` will be used as the callback URL. Make sure your OAuth provider is configured to use this URL.

## Configuration

When adding the plugin to your auth config, you can configure multiple OAuth providers. Each provider configuration object supports the following options:

```ts
interface GenericOAuthConfig {
  providerId: string;
  discoveryUrl?: string;
  authorizationUrl?: string;
  tokenUrl?: string;
  userInfoUrl?: string;
  clientId: string;
  clientSecret: string;
  scopes?: string[];
  redirectURI?: string;
  responseType?: string;
  prompt?: string;
  pkce?: boolean;
  accessType?: string;
  getUserInfo?: (tokens: OAuth2Tokens) => Promise<User | null>;
}
```

- `providerId`: A unique identifier for the OAuth provider.
- `discoveryUrl`: URL to fetch OAuth 2.0 configuration (optional, but recommended for OIDC providers).
- `type`: Type of OAuth flow ("oauth2" or "oidc", defaults to "oauth2").
- `authorizationUrl`: URL for the authorization endpoint (optional if using discoveryUrl).
- `tokenUrl`: URL for the token endpoint (optional if using discoveryUrl).
- `userInfoUrl`: URL for the user info endpoint (optional if using discoveryUrl).
- `clientId`: OAuth client ID.
- `clientSecret`: OAuth client secret.
- `scopes`: Array of OAuth scopes to request.
- `redirectURI`: Custom redirect URI (optional).
- `responseType`: OAuth response type (defaults to "code").
- `prompt`: Controls the authentication experience for the user.
- `pkce`: Whether to use PKCE (Proof Key for Code Exchange, defaults to false).
- `accessType`: Access type for the authorization request.
- `getUserInfo`: Custom function to fetch user info (optional).

## Advanced Usage

### Custom User Info Fetching

You can provide a custom `getUserInfo` function to handle specific provider requirements:

```ts
genericOAuth({
  config: [
    {
      providerId: "custom-provider",
      // ... other config options
      getUserInfo: async (tokens) => {
        // Custom logic to fetch and return user info
        const userInfo = await fetchUserInfoFromCustomProvider(tokens);
        return {
          id: userInfo.sub,
          email: userInfo.email,
          name: userInfo.name,
          // ... map other fields as needed
        };
      }
    }
  ]
})
```

### Map User Info Fields

If the user info returned by the provider does not match the expected format, or you need to map additional fields, you can use the `mapProfileToUser`:

```ts
genericOAuth({
  config: [
    {
      providerId: "custom-provider",
      // ... other config options
      mapProfileToUser: async (profile) => {
        return {
          firstName: profile.given_name,
          // ... map other fields as needed
        };
      }
    }
  ]
})
```

### Error Handling

The plugin includes built-in error handling for common OAuth issues. Errors are typically redirected to your application's error page with an appropriate error message in the URL parameters. If the callback URL is not provided, the user will be redirected to Better Auth's default error page.
</document_content>
</document>
<document index="10">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/jwt.mdx</source>
<document_content>
---
title: JWT
description: Authenticate users with JWT tokens in services that can't use the session
---

The JWT plugin provides endpoints to retrieve a JWT token and a JWKS endpoint to verify the token.

<Callout type="info">
  This plugin is not meant as a replacement for the session. 
  It's meant to be used for services that can't use the session.
</Callout>

## Installation

<Steps>
<Step>
### Add the plugin to your **auth** config
```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { jwt } from "better-auth/plugins"

export const auth = betterAuth({
    plugins: [ // [!code highlight]
        jwt(), // [!code highlight]
    ] // [!code highlight]
})
```
</Step>

<Step>
    ### Migrate the database

    Run the migration or generate the schema to add the necessary fields and tables to the database.

    <Tabs items={["migrate", "generate"]}>
        <Tab value="migrate">
        ```bash
        npx @better-auth/cli migrate
        ```
        </Tab>
        <Tab value="generate">
        ```bash
        npx @better-auth/cli generate
        ```
        </Tab>
    </Tabs>
    See the [Schema](#schema) section to add the fields manually.
</Step>
</Steps>    


## Usage

Once you've installed the plugin, you can start using the JWT & JWKS plugin to get the token and the JWKS through their respective endpoints.

## JWT

### Retrieve the token

1. Using your session token

To get the token, call the `/token`, this will return the following:
  
```json
  { 
    "token": "ey..."
  }
```

Make sure to include the token in the Authorization header of your requests. And `bearer` plugin is added in your auth configuration.

```ts
await fetch("/api/auth/token", {
  headers: {
    "Authorization": `Bearer ${token}`
  },
})
```

2. From `set-auth-jwt` header

When you call `getSession` method a jwt is returned in `set-auth-jwt` header. Which you can use to send to your services directly.

```ts
await authClient.getSession({
  fetchOptions: {
    onSuccess: (ctx)=>{
      const jwt = ctx.response.headers.get("set-auth-jwt")
    }
  }
})
```

### Verifying the token
The token can be verified in your own service, without the need for an additional verify call or database check.
For this JWKS is used, the public key can be fetched from the `/api/auth/jwks` endpoint.

Since this key is not subject to a frequent change, it can be cached indefinitely.
The Key ID (kid) that was used to sign a JWT is included in the header of the token.
In the case a JWT with a different kid is received it is recommended to fetch the JWKS again.

```json
  {
    "keys": [
        {
            "crv": "Ed25519",
            "x": "bDHiLTt7u-VIU7rfmcltcFhaHKLVvWFy-_csKZARUEU",
            "kty": "OKP",
            "kid": "c5c7995d-0037-4553-8aee-b5b620b89b23"
        }
    ]
  }
```

#### Example using jose with remote JWKS

```ts
import { jwtVerify, createRemoteJWKSet } from 'jose'

async function validateToken(token: string) {
  try {
    const JWKS = createRemoteJWKSet(
      new URL('http://localhost:3000/api/auth/jwks')
    )
    const { payload } = await jwtVerify(token, JWKS, {
      issuer: 'http://localhost:3000', // Should match your JWT issuer which is the BASE_URL
      audience: 'http://localhost:3000', // Should match your JWT audience which is the BASE_URL by default
    })
    return payload
  } catch (error) {
    console.error('Token validation failed:', error)
    throw error
  }
}

// Usage example
const token = 'your.jwt.token' // this is the token you get from the /api/auth/token endpoint
const payload = await validateToken(token)
```

#### Example with local JWKS

```ts
import { jwtVerify, createLocalJWKSet } from 'jose'


async function validateToken(token: string) {
  try {
    /**
     * This is the JWKS that you get from the /api/auth/
     * jwks endpoint
     */
    const storedJWKS = {
      keys: [{
        //...
      }]
    };
    const JWKS = createLocalJWKSet({
      keys: storedJWKS.data?.keys!,
    })
    const { payload } = await jwtVerify(token, JWKS, {
      issuer: 'http://localhost:3000', // Should match your JWT issuer which is the BASE_URL
      audience: 'http://localhost:3000', // Should match your JWT audience which is the BASE_URL by default
    })
    return payload
  } catch (error) {
    console.error('Token validation failed:', error)
    throw error
  }
}

// Usage example
const token = 'your.jwt.token' // this is the token you get from the /api/auth/token endpoint
const payload = await validateToken(token)
```

## Schema

The JWT plugin adds the following tables to the database:

### JWKS

Table Name: `jwks`

<DatabaseTable
  fields={[
    { 
      name: "id", 
      type: "string", 
      description: "Unique identifier for each web key",
      isPrimaryKey: true
    },
    { 
      name: "publicKey", 
      type: "string", 
      description: "The public part of the web key" 
    },
    { 
      name: "privateKey", 
      type: "string", 
      description: "The private part of the web key" 
    },
    { 
      name: "createdAt", 
      type: "Date", 
      description: "Timestamp of when the web key was created" 
    },
  ]}
  />

## Options

### Algorithm of the Key Pair

The algorithm used for the generation of the keypair. The default is **EdDSA** with the **Ed25519** curve. Below are the available options:

```ts title="auth.ts"
jwt({
  jwks: {
    keyPairConfig: {
      alg: "EdDSA",
      crv: "Ed25519"
    }
  }
})
```

#### EdDSA
- **Default Curve**: `Ed25519`
- **Optional Property**: `crv`
  - Available options: `Ed25519`, `Ed448`
  - Default: `Ed25519`

#### ES256
- No additional properties

#### RSA256
- **Optional Property**: `modulusLength`
  - Expects a number
  - Default: `2048`

#### PS256
- **Optional Property**: `modulusLength`
  - Expects a number
  - Default: `2048`

#### ECDH-ES
- **Optional Property**: `crv`
  - Available options: `P-256`, `P-384`, `P-521`
  - Default: `P-256`

#### ES512
- No additional properties


### Disable private key encryption

By default, the private key is encrypted using AES256 GCM. You can disable this by setting the `disablePrivateKeyEncryption` option to `true`.

For security reasons, it's recommended to keep the private key encrypted.

```ts title="auth.ts"
jwt({
  jwks: {
    disablePrivateKeyEncryption: true
  }
})
```

### Modify JWT payload

By default the entire user object is added to the JWT payload. You can modify the payload by providing a function to the `definePayload` option.

```ts title="auth.ts"
jwt({
  jwt: {
    definePayload: (user) => {
      return {
        id: user.id,
        email: user.email,
        role: user.role
      }
    }
  }
})
```

### Modify Issuer, Audience or Expiration time
If none is given, the BASE_URL is used as the issuer and the audience is set to the BASE_URL. The expiration time is set to 15 minutes.

```ts title="auth.ts"
jwt({
  jwt: {
    issuer: "https://example.com",
    audience: "https://example.com",
    expirationTime: "1h"
  }
})
```

</document_content>
</document>
<document index="11">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/magic-link.mdx</source>
<document_content>
---
title: Magic link
description: Magic link plugin
---

Magic link or email link is a way to authenticate users without a password. When a user enters their email, a link is sent to their email. When the user clicks on the link, they are authenticated.

## Installation

<Steps>
    <Step>
    ### Add the server Plugin

    Add the magic link plugin to your server:

    ```ts title="server.ts"
    import { betterAuth } from "better-auth";
    import { magicLink } from "better-auth/plugins";

    export const auth = betterAuth({
        plugins: [
            magicLink({
                sendMagicLink: async ({ email, token, url }, request) => {
                    // send email to user
                }
            })
        ]
    })
    ```
    </Step>

    <Step>
    ### Add the client Plugin

    Add the magic link plugin to your client:

    ```ts title="auth-client.ts"
    import { createAuthClient } from "better-auth/client";
    import { magicLinkClient } from "better-auth/client/plugins";
    const authClient =  createAuthClient({
        plugins: [
            magicLinkClient()
        ]
    });
    ```
    </Step>

</Steps>

## Usage

### Sign In with Magic Link

To sign in with a magic link, you need to call `signIn.magicLink` with the user's email address. The `sendMagicLink` function is called to send the magic link to the user's email.

```ts title="magic-link.ts"
const { data, error } = await authClient.signIn.magicLink({
  email: "user@email.com",
  callbackURL: "/dashboard", //redirect after successful login (optional)
});
```

If the user has not signed up, unless `disableSignUp` is set to `true`, the user will be signed up automatically.

### Verify Magic Link

When you send the URL generated by the `sendMagicLink` function to a user, clicking the link will authenticate them and redirect them to the `callbackURL` specified in the `signIn.magicLink` function. If an error occurs, the user will be redirected to the `callbackURL` with an error query parameter.

<Callout type="warn">
  If no `callbackURL` is provided, the user will be redirected to the root URL.
</Callout>

If you want to handle the verification manually, (e.g, if you send the user a different url), you can use the `verify` function.

```ts title="magic-link.ts"
const { data, error } = await authClient.magicLink.verify({
  query: {
    token,
  },
});
```

## Configuration Options

**sendMagicLink**: The `sendMagicLink` function is called when a user requests a magic link. It takes an object with the following properties:

- `email`: The email address of the user.
- `url`: The url to be sent to the user. This url contains the token.
- `token`: The token if you want to send the token with custom url.

and a `request` object as the second parameter.

**expiresIn**: specifies the time in seconds after which the magic link will expire. The default value is `300` seconds (5 minutes).

**disableSignUp**: If set to `true`, the user will not be able to sign up using the magic link. The default value is `false`.

**generateToken**: The `generateToken` function is called to generate a token which is used to uniquely identify the user. The default value is a random string. There is one parameter:

- `email`: The email address of the user.

<Callout type="warn">
  When using `generateToken`, ensure that the returned string is hard to guess
  because it is used to verify who someone actually is in a confidential way. By
  default, we return a long and cryptographically secure string.
</Callout>

</document_content>
</document>
<document index="12">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/multi-session.mdx</source>
<document_content>
---
title: Multi Session
description: Learn how to use multi-session plugin in Better Auth.
---

The multi-session plugin allows users to maintain multiple active sessions across different accounts in the same browser. This plugin is useful for applications that require users to switch between multiple accounts without logging out.

## Installation

<Steps>
<Step>
### Add the plugin to your **auth** config
```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { multiSession } from "better-auth/plugins"

export const auth = betterAuth({
    plugins: [ // [!code highlight]
        multiSession(), // [!code highlight]
    ] // [!code highlight]
})
```
</Step>
<Step>
        ### Add the client Plugin

        Add the client plugin and Specify where the user should be redirected if they need to verify 2nd factor

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        import { multiSessionClient } from "better-auth/client/plugins"

        const authClient =  createAuthClient({
            plugins: [
                multiSessionClient()
            ]
        })
        ```
        </Step>
</Steps>    


## Usage

Whenever a user logs in, the plugin will add additional cookie to the browser. This cookie will be used to maintain multiple sessions across different accounts. 


### List all device sessions

To list all active sessions for the current user, you can call the `listDeviceSessions` method.

```ts
await authClient.multiSession.listDeviceSessions()
```

on the server you can call `listDeviceSessions` method.

```ts
await auth.api.listDeviceSessions()
```

### Set active session

To set the active session, you can call the `setActive` method.

```ts
await authClient.multiSession.setActive({
    sessionToken: "session-token"
})
```

### Revoke a session

To revoke a session, you can call the `revoke` method.

```ts
await authClient.multiSession.revoke({
    sessionToken: "session-token"
})
```

### Signout and Revoke all sessions

When a user logs out, the plugin will revoke all active sessions for the user. You can do this by calling the existing `signOut` method, which handles revoking all sessions automatically.

### Max Sessions

You can specify the maximum number of sessions a user can have by passing the `maximumSessions` option to the plugin. By default, the plugin allows 5 sessions per device.

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    plugins: [
        multiSession({
            maximumSessions: 3
        })
    ]
})
```
</document_content>
</document>
<document index="13">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/oauth-proxy.mdx</source>
<document_content>
---
title: OAuth Proxy
description: OAuth Proxy plugin for Better Auth
---

A proxy plugin, that allows you to proxy OAuth requests. Useful for development and preview deployments where the redirect URL can't be known in advance to add to the OAuth provider. 

## Installation

<Steps>
    <Step>
    ### Add the plugin to your **auth** config
    ```ts title="auth.ts"
    import { betterAuth } from "better-auth"
    import { oAuthProxy } from "better-auth/plugins"

    export const auth = betterAuth({
        plugins: [ // [!code highlight]
            oAuthProxy(), // [!code highlight]
        ] // [!code highlight]
    })
    ```
    </Step>
    <Step>
    ### Add redirect URL to your OAuth provider

   For the proxy server to work properly, you’ll need to pass the redirect URL of your main production app registered with the OAuth provider in your social provider config. This needs to be done for each social provider you want to proxy requests for.

    ```ts
    export const auth = betterAuth({
       plugins: [
           oAuthProxy(),
       ], 
       socialProviders: {
            github: {
                clientId: "your-client-id",
                clientSecret: "your-client-secret",
                redirectURI: "https://my-main-app.com/api/auth/callback/github". // [!code highlight]
            }
       }
    })
    ```
    </Step>
</Steps>    


## How it works

The plugin adds an endpoint to your server that proxies OAuth requests. When you initiate a social sign-in, it sets the redirect URL to this proxy endpoint. After the OAuth provider redirects back to your server, the plugin then forwards the user to the original callback URL.

```ts
await authClient.signIn.social({
    provider: "github",
    callbackURL: "/dashboard" // the plugin will override this to something like "http://localhost:3000/api/auth/oauth-proxy?callbackURL=/dashboard"
})
```

When the OAuth provider returns the user to your server, the plugin automatically redirects them to the intended callback URL.

<Callout>
To share cookies between the proxy server and your main server it uses url query parameters to pass the cookies encrypted in the URL. This is secure as the cookies are encrypted and can only be decrypted by the server.
</Callout>

## Options

**currentURL**: The application's current URL is automatically determined by the plugin. It first it check for the request URL if invoked by a client, then it checks the base URL from popular hosting providers, and finally falls back to the `baseURL` in your auth config. If the URL isn’t inferred correctly, you can specify it manually here.

**productionURL**: If this value matches the `baseURL` in your auth config, requests will not be proxied. Defaults to the `BETTER_AUTH_URL` environment variable.

</document_content>
</document>
<document index="14">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/oidc-provider.mdx</source>
<document_content>
---
title: OIDC Provider
description: Open ID Connect plugin for Better Auth that allows you to have your own OIDC provider.
---

The **OIDC Provider Plugin** enables you to build and manage your own OpenID Connect (OIDC) provider, granting full control over user authentication without relying on third-party services like Okta or Azure AD. It also allows other services to authenticate users through your OIDC provider.

**Key Features**:

- **Client Registration**: Register clients to authenticate with your OIDC provider.
- **Dynamic Client Registration**: Allow clients to register dynamically.
- **Authorization Code Flow**: Support the Authorization Code Flow.
- **JWKS Endpoint**: Publish a JWKS endpoint to allow clients to verify tokens. (Not fully implemented)
- **Refresh Tokens**: Issue refresh tokens and handle access token renewal using the `refresh_token` grant.
- **OAuth Consent**: Implement OAuth consent screens for user authorization, with an option to bypass consent for trusted applications.
- **UserInfo Endpoint**: Provide a UserInfo endpoint for clients to retrieve user details.

<Callout type="warn">
This plugin is in active development and may not be suitable for production use. Please report any issues or bugs on [GitHub](https://github.com/better-auth/better-auth).
</Callout>

## Installation

<Steps>
    <Step>
        ### Mount the Plugin

        Add the OIDC plugin to your auth config. See [OIDC Configuration](#oidc-configuration) on how to configure the plugin.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth";
        import { oidcProvider } from "better-auth/plugins";

        const auth = betterAuth({
            plugins: [oidcProvider({
                loginPage: "/sign-in", // path to the login page
                // ...other options
            })]
        })
        ```
    </Step>

    <Step>
        ### Migrate the Database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```bash
            npx @better-auth/cli migrate
            ```
            </Tab>
            <Tab value="generate">
            ```bash
            npx @better-auth/cli generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>

    <Step>
        ### Add the Client Plugin

        Add the OIDC client plugin to your auth client config.

        ```ts
        import { createAuthClient } from "better-auth/client";
        import { oidcClient } from "better-auth/client/plugins"
        const authClient = createAuthClient({
            plugins: [oidcClient({
                // Your OIDC configuration
            })]
        })
        ```
    </Step>
</Steps>

## Usage

Once installed, you can utilize the OIDC Provider to manage authentication flows within your application.

### Register a New Client

To register a new OIDC client, use the `oauth2.register` method.

<Endpoint path="/oauth2/register" method="POST" />

```ts title="client.ts"
const application = await client.oauth2.register({
    name: "My Client",
    redirect_uris: ["https://client.example.com/callback"],
});
```

Once the application is created, you will receive a `client_id` and `client_secret` that you can display to the user.

This Endpoint support [RFC7591](https://datatracker.ietf.org/doc/html/rfc7591) compliant client registration.

### UserInfo Endpoint

The OIDC Provider includes a UserInfo endpoint that allows clients to retrieve information about the authenticated user. This endpoint is available at `/oauth2/userinfo` and requires a valid access token.

<Endpoint path="/oauth2/userinfo" method="GET" />

```ts title="client-app.ts"
// Example of how a client would use the UserInfo endpoint
const response = await fetch('https://your-domain.com/api/auth/oauth2/userinfo', {
  headers: {
    'Authorization': 'Bearer ACCESS_TOKEN'
  }
});

const userInfo = await response.json();
// userInfo contains user details based on the scopes granted
```

The UserInfo endpoint returns different claims based on the scopes that were granted during authorization:

- With `openid` scope: Returns the user's ID (`sub` claim)
- With `profile` scope: Returns name, picture, given_name, family_name
- With `email` scope: Returns email and email_verified

The `getAdditionalUserInfoClaim` function receives the user object and the requested scopes array, allowing you to conditionally include claims based on the scopes granted during authorization. These additional claims will be included in both the UserInfo endpoint response and the ID token.

### Consent Screen

When a user is redirected to the OIDC provider for authentication, they may be prompted to authorize the application to access their data. This is known as the consent screen. By default, Better Auth will display a sample consent screen. You can customize the consent screen by providing a `consentPage` option during initialization.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    plugins: [oidcProvider({
        consentPage: "/path/to/consent/page"
    })]
})
```

The plugin will redirect the user to the specified path with a `client_id` and `scope` query parameter. You can use this information to display a custom consent screen. Once the user consents, you can call `oauth2.consent` to complete the authorization.

<Endpoint path="/oauth2/consent" method="POST" />

```ts title="server.ts"
const res = await client.oauth2.consent({
	accept: true, // or false to deny
});
```

The `client_id` and other necessary information are stored in the browser cookie, so you don't need to pass them in the request. If they don't exist in the cookie, the consent method will return an error.

### Handling Login

When a user is redirected to the OIDC provider for authentication, if they are not already logged in, they will be redirected to the login page. You can customize the login page by providing a `loginPage` option during initialization.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    plugins: [oidcProvider({
        loginPage: "/sign-in"
    })]
})
```

You don't need to handle anything from your side; when a new session is created, the plugin will handle continuing the authorization flow.

## Configuration

### OIDC Metadata

Customize the OIDC metadata by providing a configuration object during initialization.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { oidcProvider } from "better-auth/plugins";

export const auth = betterAuth({
    plugins: [oidcProvider({
        metadata: {
            issuer: "https://your-domain.com",
            authorization_endpoint: "/custom/oauth2/authorize",
            token_endpoint: "/custom/oauth2/token",
            // ...other custom metadata
        }
    })]
})
```

### JWKS Endpoint (Not Fully Implemented)

For JWKS support, you need to use the `jwt` plugin. It exposes the `/jwks` endpoint to provide the public keys.

<Callout type="warn">
Currently, the token is signed with the application's secret key. The JWKS endpoint is not fully implemented yet.
</Callout>

### Dynamic Client Registration

If you want to allow clients to register dynamically, you can enable this feature by setting the `allowDynamicClientRegistration` option to `true`.

```ts title="auth.ts"
const auth = betterAuth({
    plugins: [oidcProvider({
        allowDynamicClientRegistration: true,
    })]
})
```

This will allow clients to register using the `/register` endpoint to be publicly available.

## Schema

The OIDC Provider plugin adds the following tables to the database:

### OAuth Application

Table Name: `oauthApplication`

<DatabaseTable
  fields={[
   {
      name: "id",
      type: "string",
      description: "Database ID of the OAuth client",
      isPrimaryKey: true
   },
    { 
      name: "clientId", 
      type: "string", 
      description: "Unique identifier for each OAuth client",
      isPrimaryKey: true
    },
    { 
      name: "clientSecret", 
      type: "string", 
      description: "Secret key for the OAuth client",
      isRequired: true
    },
    { 
      name: "name", 
      type: "string", 
      description: "Name of the OAuth client",
      isRequired: true
    },
    { 
      name: "redirectURLs", 
      type: "string", 
      description: "Comma-separated list of redirect URLs",
      isRequired: true
    },
    { 
      name: "metadata", 
      type: "string",
      description: "Additional metadata for the OAuth client",
      isOptional: true
    },
    { 
      name: "type", 
      type: "string",
      description: "Type of OAuth client (e.g., web, mobile)",
      isRequired: true
    },
    { 
      name: "disabled", 
      type: "boolean", 
      description: "Indicates if the client is disabled",
      isRequired: true
    },
    { 
      name: "userId", 
      type: "string", 
      description: "ID of the user who owns the client. (optional)",
      isOptional: true
    },
    { 
      name: "createdAt", 
      type: "Date", 
      description: "Timestamp of when the OAuth client was created" 
    },
   {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of when the OAuth client was last updated"
   }
  ]}
/>

### OAuth Access Token

Table Name: `oauthAccessToken`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Database ID of the access token",
      isPrimaryKey: true
   },
    { 
      name: "accessToken", 
      type: "string", 
      description: "Access token issued to the client",
    },
    { 
      name: "refreshToken", 
      type: "string", 
      description: "Refresh token issued to the client",
      isRequired: true
    },
    { 
      name: "accessTokenExpiresAt", 
      type: "Date", 
      description: "Expiration date of the access token",
      isRequired: true
    },
    { 
      name: "refreshTokenExpiresAt", 
      type: "Date", 
      description: "Expiration date of the refresh token",
      isRequired: true
    },
    { 
      name: "clientId", 
      type: "string", 
      description: "ID of the OAuth client",
      isForeignKey: true,
      references: { model: "oauthClient", field: "clientId" }
    },
    { 
      name: "userId", 
      type: "string", 
      description: "ID of the user associated with the token",
      isForeignKey: true,
      references: { model: "user", field: "id" }
    },
    { 
      name: "scopes", 
      type: "string", 
      description: "Comma-separated list of scopes granted",
      isRequired: true
    },
    { 
      name: "createdAt", 
      type: "Date", 
      description: "Timestamp of when the access token was created" 
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of when the access token was last updated"
    }
  ]}
/>

### OAuth Consent

Table Name: `oauthConsent`

<DatabaseTable
  fields={[
    { 
      name: "id", 
      type: "string", 
      description: "Database ID of the consent",
      isPrimaryKey: true
    },
    { 
      name: "userId", 
      type: "string", 
      description: "ID of the user who gave consent",
      isForeignKey: true,
      references: { model: "user", field: "id" }
    },
    { 
      name: "clientId", 
      type: "string", 
      description: "ID of the OAuth client",
      isForeignKey: true,
      references: { model: "oauthClient", field: "clientId" }
    },
    { 
      name: "scopes", 
      type: "string", 
      description: "Comma-separated list of scopes consented to",
      isRequired: true
    },
    { 
      name: "consentGiven", 
      type: "boolean", 
      description: "Indicates if consent was given",
      isRequired: true
    },
    { 
      name: "createdAt", 
      type: "Date", 
      description: "Timestamp of when the consent was given" 
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of when the consent was last updated"
    }
  ]}
/>

## Options

**allowDynamicClientRegistration**: `boolean` - Enable or disable dynamic client registration.

**metadata**: `OIDCMetadata` - Customize the OIDC provider metadata.

**loginPage**: `string` - Path to the custom login page.

**consentPage**: `string` - Path to the custom consent page.

**getAdditionalUserInfoClaim**: `(user: User, scopes: string[]) => Record<string, any>` - Function to get additional user info claims.
</document_content>
</document>
<document index="15">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/one-tap.mdx</source>
<document_content>
---
title: One Tap
description: One Tap plugin for Better Auth
---

The One Tap plugin allows users to log in with a single tap using Google's One Tap API. The plugin
provides a simple way to integrate One Tap into your application, handling the client-side and server-side logic for you.

## Installation

### Add the Server Plugin

Add the One Tap plugin to your auth configuration:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { oneTap } from "better-auth/plugins";

export const auth = betterAuth({
  plugins: [
    oneTap(), // Add the One Tap server plugin
  ]
});
```

### Add the Client Plugin

Add the client plugin and specify where the user should be redirected after sign-in or if additional verification (like 2FA) is needed.


```ts
import { createAuthClient } from "better-auth/client";
import { oneTapClient } from "better-auth/client/plugins";

const authClient = createAuthClient({
  plugins: [
    oneTapClient({
      clientId: "YOUR_CLIENT_ID",
      // Optional client configuration:
      autoSelect: false,
      cancelOnTapOutside: true,
      context: "signin",
      additionalOptions: {
        // Any extra options for the Google initialize method
      },
      // Configure prompt behavior and exponential backoff:
      promptOptions: {
        baseDelay: 1000,   // Base delay in ms (default: 1000)
        maxAttempts: 5     // Maximum number of attempts before triggering onPromptNotification (default: 5)
      }
    })
  ]
});
```

### Usage

To display the One Tap popup, simply call the oneTap method on your auth client:

```ts
await authClient.oneTap();
```

### Customizing Redirect Behavior

By default, after a successful login the plugin will hard redirect the user to `/`. You can customize this behavior as follows:

#### Avoiding a Hard Redirect

Pass fetchOptions with an onSuccess callback to handle the login response without a page reload:

```ts
authClient.oneTap({
  fetchOptions: {
    onSuccess: () => {
      // For example, use a router to navigate without a full reload:
      router.push("/dashboard");
    }
  }
});
```

#### Specifying a Custom Callback URL

To perform a hard redirect to a different page after login, use the callbackURL option:

```ts
authClient.oneTap({
  callbackURL: "/dashboard"
});
```

#### Handling Prompt Dismissals with Exponential Backoff

If the user dismisses or skips the prompt, the plugin will retry showing the One Tap prompt using exponential backoff based on your configured promptOptions.

If the maximum number of attempts is reached without a successful sign-in, you can use the onPromptNotification callback to be notified—allowing you to render an alternative UI (e.g., a traditional Google Sign-In button) so users can restart the process manually:

```ts
authClient.oneTap({
  onPromptNotification: (notification) => {
    console.warn("Prompt was dismissed or skipped. Consider displaying an alternative sign-in option.", notification);
    // Render your alternative UI here
  }
});
```

### Client Options

- **clientId**: The client ID for your Google One Tap API.
- **autoSelect**: Automatically select the account if the user is already signed in. Default is false.
- **context**: The context in which the One Tap API should be used (e.g., "signin"). Default is "signin".
- **cancelOnTapOutside**: Cancel the One Tap popup when the user taps outside it. Default is true.
- additionalOptions: Extra options to pass to Google's initialize method as per the [Google Identity Services docs](https://developers.google.com/identity/gsi/web/reference/js-reference#google.accounts.id.prompt).
- **promptOptions**: Configuration for the prompt behavior and exponential backoff:
- **baseDelay**: Base delay in milliseconds for retries. Default is 1000.
- **maxAttempts**: Maximum number of prompt attempts before invoking the onPromptNotification callback. Default is 5.

### Server Options

- **disableSignUp**:  Disable the sign-up option, allowing only existing users to sign in. Default is `false`.
- **ClientId**: Optionally, pass a client ID here if it is not provided in your social provider configuration.


</document_content>
</document>
<document index="16">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/open-api.mdx</source>
<document_content>
---
title: Open API
description: Open API reference for Better Auth.
---

This is a plugin that provides an Open API reference for Better Auth. It shows all endpoints added by plugins and the core. It also provides a way to test the endpoints. It uses [Scalar](https://scalar.com/) to display the Open API reference.


<Callout>
This plugin is still in the early stages of development. We are working on adding more features to it and filling in the gaps.
</Callout>


## Installation

<Steps>
    <Step>
    ### Add the plugin to your **auth** config
    ```ts title="auth.ts"
    import { betterAuth } from "better-auth"
    import { openAPI } from "better-auth/plugins"

    export const auth = betterAuth({
        plugins: [ // [!code highlight]
            openAPI(), // [!code highlight]
        ] // [!code highlight]
    })
    ```
    </Step>
    <Step>
    ### Navigate to `/api/auth/reference` to view the Open API reference
    
    Each plugin endpoints are grouped by the plugin name. The core endpoints are grouped under the `Default` group. And Model schemas are grouped under the `Models` group.

    ![Open API reference](/open-api-reference.png)
    </Step>
</Steps>    



## Usage 

The Open API reference is generated using the [OpenAPI 3.0](https://swagger.io/specification/) specification. You can use the reference to generate client libraries, documentation, and more.

The reference is generated using the [Scalar](https://scalar.com/) library. Scalar provides a way to view and test the endpoints. You can test the endpoints by clicking on the `Try it out` button and providing the required parameters.

![Open API reference](/open-api-reference.png)

### Generated Schema

To get the generated Open API schema directly as JSON, you can do `auth.api.generateOpenAPISchema()`. This will return the Open API schema as a JSON object.

```ts
import { auth } from "~/lib/auth"

const openAPISchema = await auth.api.generateOpenAPISchema()
console.log(openAPISchema)
```

## Configuration

`path` - The path where the Open API reference is served. Default is `/api/auth/reference`. You can change it to any path you like, but keep in mind that it will be appended to the base path of your auth server.

`disableDefaultReference` - If set to `true`, the default Open API reference UI by Scalar will be disabled. Default is `false`.
</document_content>
</document>
<document index="17">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/organization.mdx</source>
<document_content>
---
title: Organization
description: The organization plugin allows you to manage your organization's members and teams.
---

Organizations simplifies user access and permissions management. Assign roles and permissions to streamline project management, team coordination, and partnerships.

## Installation

<Steps>
<Step>
### Add the plugin to your **auth** config
```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { organization } from "better-auth/plugins"

export const auth = betterAuth({
    plugins: [ // [!code highlight]
        organization() // [!code highlight]
    ] // [!code highlight]
})
```
</Step>

<Step>
    ### Migrate the database

    Run the migration or generate the schema to add the necessary fields and tables to the database.

    <Tabs items={["migrate", "generate"]}>
        <Tab value="migrate">
        ```bash
        npx @better-auth/cli migrate
        ```
        </Tab>
        <Tab value="generate">
        ```bash
        npx @better-auth/cli generate
        ```
        </Tab>
    </Tabs>
    See the [Schema](#schema) section to add the fields manually.
</Step>

<Step>
    ### Add the client plugin
    
    ```ts title="auth-client.ts" 
    import { createAuthClient } from "better-auth/client"
    import { organizationClient } from "better-auth/client/plugins"

    const client = createAuthClient({
        plugins: [ // [!code highlight]
            organizationClient() // [!code highlight]
        ] // [!code highlight]
    })
    ```
</Step>
</Steps>    


## Usage

Once you've installed the plugin, you can start using the organization plugin to manage your organization's members and teams. The client plugin will provide you methods under the `organization` namespace. And the server `api` will provide you with the necessary endpoints to manage your organization and gives you easier way to call the functions on your own backend.

## Organization

### Create an organization

To create an organization, you need to provide:

- `name`: The name of the organization.
- `slug`: The slug of the organization.
- `logo`: The logo of the organization. (Optional)

```ts title="auth-client.ts"
await authClient.organization.create({
    name: "My Organization",
    slug: "my-org",
    logo: "https://example.com/logo.png"
})
```


#### Restrict who can create an organization

By default, any user can create an organization. To restrict this, set the `allowUserToCreateOrganization` option to a function that returns a boolean, or directly to `true` or `false`.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { organization } from "better-auth/plugins"

const auth = betterAuth({
    //...
    plugins: [
        organization({
            allowUserToCreateOrganization: async (user) => { // [!code highlight]
                const subscription = await getSubscription(user.id) // [!code highlight]
                return subscription.plan === "pro" // [!code highlight]
            } // [!code highlight]
        })
    ]
})
```

#### Check if organization slug is taken

To check if an organization slug is taken or not you can use the `checkSlug` function provided by the client. The function takes an object with the following properties:

- `slug`: The slug of the organization.

```ts title="auth-client.ts"
await authClient.organization.checkSlug({
    slug: "my-org",
});
```


#### Organization Creation Hooks

You can customize the organization creation process using hooks that run before and after an organization is created.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { organization } from "better-auth/plugins"

export const auth = betterAuth({
    plugins: [
        organization({
            organizationCreation: {
                disabled: false, // Set to true to disable organization creation
                beforeCreate: async ({ organization, user }, request) => {
                    // Run custom logic before organization is created
                    // Optionally modify the organization data
                    return {
                        data: {
                            ...organization,
                            metadata: {
                                customField: "value"
                            }
                        }
                    }
                },
                afterCreate: async ({ organization, member, user }, request) => {
                    // Run custom logic after organization is created
                    // e.g., create default resources, send notifications
                    await setupDefaultResources(organization.id)
                }
            }
        })
    ]
})
```

The `beforeCreate` hook runs before an organization is created. It receives:

- `organization`: The organization data (without ID)
- `user`: The user creating the organization
- `request`: The HTTP request object (optional)

Return an object with `data` property to modify the organization data that will be created.

The `afterCreate` hook runs after an organization is successfully created. It receives:

- `organization`: The created organization (with ID)
- `member`: The member record for the creator
- `user`: The user who created the organization
- `request`: The HTTP request object (optional)


### List User's Organizations

To list the organizations that a user is a member of, you can use `useListOrganizations` hook. It implements a reactive way to get the organizations that the user is a member of.

<Tabs items={["React", "Vue", "Svelte"]} defaultValue="React">
<Tab value="React">
```tsx title="client.tsx"
import { client } from "@/auth/client"

function App(){
    const { data: organizations } = client.useListOrganizations()
    return (
        <div>
            {organizations.map(org => <p>{org.name}</p>)}
        </div>
    )
} 
```
</Tab>

<Tab value="Svelte">
```svelte title="page.svelte"
<script lang="ts">
  import { client } from "$lib/client";
  const organizations = client.useListOrganizations();
</script>

<h1>Organizations</h1>s

{#if $organizations.isPending}
  <p>Loading...</p>
{:else if $organizations.data === null}
  <p>No organizations found.</p>
{:else}
  <ul>
    {#each $organizations.data as organization}
      <li>{organization.name}</li>
    {/each}
  </ul>
{/if}
```
</Tab>

<Tab value="Vue">
```vue title="organization.vue"
<script lang="ts">;
export default {
    setup() {
        const organizations = client.useListOrganizations()
        return { organizations };
    }
};
</script>

<template>
    <div>
        <h1>Organizations</h1>
        <div v-if="organizations.isPending">Loading...</div>
        <div v-else-if="organizations.data === null">No organizations found.</div>
        <ul v-else>
            <li v-for="organization in organizations.data" :key="organization.id">
                {{ organization.name }}
            </li>
        </ul>
    </div>
</template>
```
</Tab>
</Tabs>


### Active Organization

Active organization is the workspace the user is currently working on. By default when the user is signed in the active organization is set to `null`. You can set the active organization to the user session.

<Callout type="info">
 It's not always you want to persist the active organization in the session. You can manage the active organization in the client side only. For example, multiple tabs can have different active organizations.
</Callout>

#### Set Active Organization

You can set the active organization by calling the `organization.setActive` function. It'll set the active organization for the user session.
<Tabs items={["client", "server"]} defaultValue="client">
  <Tab value="client">
  ```ts title="auth-client.ts"
  import { client } from "@/lib/auth-client";

  await authClient.organization.setActive({
    organizationId: "organization-id"
  })

  // you can also use organizationSlug instead of organizationId
  authClient.organization.setActive({
    organizationSlug: "organization-slug"
  })
  ```
  </Tab>

  <Tab value="server">
    ```ts title="api.ts"
    import { auth } from "@/lib/auth";

    auth.api.setActiveOrganization({
      headers: // pass the headers,
      body: {
        organizationSlug: "organization-slug"
      }
    })

    // you can also use organizationId instead of organizationSlug
    auth.api.setActiveOrganization({
      headers: // pass the headers,
      body: {
        organizationId: "organization-id"
      }
    })
    ```
  </Tab>
</Tabs>

To set active organization when a session is created you can use [database hooks](/docs/concepts/database#database-hooks).

```ts title="auth.ts"
export const auth = betterAuth({
  databaseHooks: {
      session: {
          create: {
              before: async(session)=>{
                  const organization = await getActiveOrganization(session.userId)
                  return {
                    data: {
                      ...session,
                      activeOrganizationId: organization.id
                    }
                  }
              }
          }
      }
  }
})
```

#### Use Active Organization

To retrieve the active organization for the user, you can call the `useActiveOrganization` hook. It returns the active organization for the user. Whenever the active organization changes, the hook will re-evaluate and return the new active organization.

<Tabs items={['React', 'Vue', 'Svelte']}>
    <Tab value="React">   
    ```tsx title="client.tsx" 
    import { client } from "@/auth/client"

    function App(){
        const { data: activeOrganization } = client.useActiveOrganization()
        return (
            <div>
                {activeOrganization ? <p>{activeOrganization.name}</p> : null}
            </div>
        )
    } 
    ``` 
    </Tab>
    <Tab value="Svelte">   
    ```tsx title="client.tsx" 
    <script lang="ts">
    import { client } from "$lib/client";
    const activeOrganization = client.useActiveOrganization();
    </script>

    <h2>Active Organization</h2>

    {#if $activeOrganization.isPending}
    <p>Loading...</p>
    {:else if $activeOrganization.data === null}
    <p>No active organization found.</p>
    {:else}
    <p>{$activeOrganization.data.name}</p>
    {/if}
    ``` 
    </Tab>
    <Tab value="Vue">   
    ```vue title="organization.vue" 
    <script lang="ts">;
    export default {
        setup() {
            const activeOrganization = client.useActiveOrganization();
            return { activeOrganization };
        }
    };
    </script>

    <template>
        <div>
            <h2>Active organization</h2>
            <div v-if="activeOrganization.isPending">Loading...</div>
            <div v-else-if="activeOrganization.data === null">No active organization.</div>
            <div v-else>
                {{ activeOrganization.data.name }}
            </div>
        </div>
    </template>
    ``` 
    </Tab>
</Tabs>

### Get Full Organization

To get the full details of an organization, you can use the `getFullOrganization` function provided by the client. The function takes an object with the following properties:

- `organizationId`: The id of the organization. (Optional) – By default, it will use the active organization.
- `organizationSlug`: The slug of the organization. (Optional) – To get the organization by slug.

<Tabs items={["client", "server"]}>

  <Tab value="client">
  ```ts title="auth-client.ts"
  const organization = await authClient.organization.getFullOrganization({
      organizationId: "organization-id" // optional, by default it will use the active organization
  })
  //you can also use organizationSlug instead of organizationId
  const organization = await authClient.organization.getFullOrganization({
      organizationSlug: "organization-slug"
  })
  ```
  </Tab>

  <Tab value="server">
    ```ts title="api.ts"
    import { auth } from "@/auth";

    auth.api.getFullOrganization({
        headers: // pass the headers
    })

    //  you can also use organizationSlug instead of organizationId
    auth.api.getFullOrganization({
        headers: // pass the headers,
        query: {
            organizationSlug: "organization-slug"
        }
    })
    ```
  </Tab>
</Tabs>


### Update Organization

To update organization info, you can use `organization.update`


```ts 
await client.organization.update({
  data: {
    name: "updated-name",
    logo: "new-logo.url",
    metadata: {
      customerId: "test"
    },
    slug: "updated-slug"
  },
  organizationId: 'org-id' //defaults to the current active organization
})
```

### Delete Organization

To remove user owned organization, you can use `organization.delete`

```ts title="org.ts"
await authClient.organization.delete({
  organizationId: "test"
});
```

If the user has the necessary permissions (by default: role is owner) in the specified organization, all members, invitations and organization information will be removed.

You can configure how organization deletion is handled through `organizationDeletion` option:

```ts
const auth = betterAuth({
  plugins: [
    organization({
      organizationDeletion: {
        disabled: true, //to disable it altogether
        beforeDelete: async (data, request) => {
          // a callback to run before deleting org
        },
        afterDelete: async (data, request) => {
          // a callback to run after deleting org
        },
      },
    }),
  ],
});
```

## Invitations

To add a member to an organization, we first need to send an invitation to the user. The user will receive an email/sms with the invitation link. Once the user accepts the invitation, they will be added to the organization.

### Setup Invitation Email

For member invitation to work we first need to provider `sendInvitationEmail` to the `better-auth` instance. This function is responsible for sending the invitation email to the user.

You'll need to construct and send the invitation link to the user. The link should include the invitation ID, which will be used with the acceptInvitation function when the user clicks on it.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { organization } from "better-auth/plugins"
import { sendOrganizationInvitation } from "./email"
export const auth = betterAuth({
	plugins: [
		organization({
			async sendInvitationEmail(data) {
                const inviteLink = `https://example.com/accept-invitation/${data.id}`
				sendOrganizationInvitation({
					    email: data.email,
						invitedByUsername: data.inviter.user.name,
						invitedByEmail: data.inviter.user.email,
						teamName: data.organization.name,
						inviteLink
					})
			},
		}),
	],
});
```

### Send Invitation

To invite users to an organization, you can use the `invite` function provided by the client. The `invite` function takes an object with the following properties:

- `email`: The email address of the user.
- `role`: The role of the user in the organization. It can be `admin`, `member`, or `guest`.
- `organizationId`: The id of the organization. this is optional by default it will use the active organization. (Optional)

```ts title="invitation.ts"
await authClient.organization.inviteMember({
    email: "test@email.com",
    role: "admin", //this can also be an array for multiple roles (e.g. ["admin", "sale"])
})
```


### Accept Invitation

When a user receives an invitation email, they can click on the invitation link to accept the invitation. The invitation link should include the invitation ID, which will be used to accept the invitation.

Make sure to call the `acceptInvitation` function after the user is logged in. 

```ts title="auth-client.ts"
await authClient.organization.acceptInvitation({
    invitationId: "invitation-id"
})
```

### Update Invitation Status
        
To update the status of invitation you can use the `acceptInvitation`, `cancelInvitation`, `rejectInvitation` functions provided by the client. The functions take the invitation id as an argument.

```ts title="auth-client.ts"
//cancel invitation
await authClient.organization.cancelInvitation({
    invitationId: "invitation-id"
})

//reject invitation (needs to be called when the user who received the invitation is logged in)
await authClient.organization.rejectInvitation({
    invitationId: "invitation-id"
})
```


### Get Invitation

To get an invitation you can use the `getInvitation` function provided by the client. You need to provide the invitation id as a query parameter.

```ts title="auth-client.ts"
client.organization.getInvitation({
    query: {
        id: params.id
    }
})
```

## Members

### Remove Member 

To remove you can use `organization.removeMember`

```ts title="auth-client.ts"
//remove member
await authClient.organization.removeMember({
    memberIdOrEmail: "member-id", // this can also be the email of the member
    organizationId: "organization-id" // optional, by default it will use the active organization
})
```

### Update Member Role

To update the role of a member in an organization, you can use the `organization.updateMemberRole`. If the user has the permission to update the role of the member, the role will be updated.

```ts title="auth-client.ts"
await authClient.organization.updateMemberRole({
    memberId: "member-id",
    role: "admin" // this can also be an array for multiple roles (e.g. ["admin", "sale"])
})
```

### Get Active Member

To get the current member of the organization you can use the `organization.getActiveMember` function. This function will return the current active member.

```ts title="auth-client.ts"
const member = await authClient.organization.getActiveMember()
```

### Add Member

If you want to add a member directly to an organization without sending an invitation, you can use the `addMember` function which can only be invoked on the server.

```ts title="api.ts"
import { auth } from "@/auth";

auth.api.addMember({
  body: {
      userId: "user-id",
      organizationId: "organization-id",
      role: "admin", // this can also be an array for multiple roles (e.g. ["admin", "sale"])
      teamId: "team-id" // Optionally specify a teamId to add the member to a team. (requires teams to be enabled)
  }
})
```

### Leave Organization

To leave organization you can use `organization.leave` function. This function will remove the current user from the organization.

```ts title="auth-client.ts"
await authClient.organization.leave({
    organizationId: "organization-id"
})
```    

## Access Control

The organization plugin providers a very flexible access control system. You can control the access of the user based on the role they have in the organization. You can define your own set of permissions based on the role of the user.

### Roles

By default, there are three roles in the organization:

`owner`: The user who created the organization by default. The owner has full control over the organization and can perform any action.

`admin`: Users with the admin role have full control over the organization except for deleting the organization or changing the owner.

`member`: Users with the member role have limited control over the organization. They can create projects, invite users, and manage projects they have created.

<Callout>
  A user can have multiple roles. Multiple roles are stored as string separated by comma (",").
</Callout>

### Permissions

By default, there are three resources, and these have two to three actions.

**organization**: 

    `update` `delete`

**member**: 

    `create` `update` `delete`

**invitation**: 
    
    `create` `cancel`

The owner have full control over all the resources and actions. The admin have full control over all the resources except for deleting the organization or changing the owner. The member have no control over any of those action other than reading the data.

### Custom Permissions

The plugin provides an easy way to define your own set of permissions for each role.

<Steps>
    <Step>
    #### Create Access Control

    You first need to create access controller by calling `createAccessControl` function and passing the statement object. The statement object should have the resource name as the key and the array of actions as the value.
    ```ts title="permissions.ts"
    import { createAccessControl } from "better-auth/plugins/access";

    /**
     * make sure to use `as const` so typescript can infer the type correctly
     */
    const statement = { // [!code highlight]
        project: ["create", "share", "update", "delete"], // [!code highlight]
    } as const; // [!code highlight]

    const ac = createAccessControl(statement); // [!code highlight]
    ```
    </Step>

    <Step>
    #### Create Roles

    Once you have created the access controller you can create roles with the permissions you have defined.

    ```ts title="permissions.ts"
    import { createAccessControl } from "better-auth/plugins/access";

    const statement = { 
        project: ["create", "share", "update", "delete"],
    } as const; 

    const ac = createAccessControl(statement); 

    const member = ac.newRole({ // [!code highlight]
        project: ["create"], // [!code highlight]
    }); // [!code highlight]

    const admin = ac.newRole({ // [!code highlight] 
        project: ["create", "update"], // [!code highlight]
    }); // [!code highlight]

    const owner = ac.newRole({ // [!code highlight]
        project: ["create", "update", "delete"], // [!code highlight]
    }); // [!code highlight]

    const myCustomRole = ac.newRole({ // [!code highlight]
        project: ["create", "update", "delete"], // [!code highlight]
        organization: ["update"], // [!code highlight]
    }); // [!code highlight]
    ```

      When you create custom roles for existing roles, the predefined permissions for those roles will be overridden. To add the existing permissions to the custom role, you need to import `defaultStatements` and merge it with your new statement, plus merge the roles' permissions set with the default roles.

    ```ts title="permissions.ts"
    import { createAccessControl } from "better-auth/plugins/access";
    import { defaultStatements, adminAc } from 'better-auth/plugins/organization/access'

    const statement = { 
        ...defaultStatements, // [!code highlight]
        project: ["create", "share", "update", "delete"],
    } as const;
    
    const ac = createAccessControl(statement);

    const admin = ac.newRole({
        project: ["create", "update"],
        ...adminAc.statements, // [!code highlight]
    });
    ```

    </Step>

    <Step>
        #### Pass Roles to the Plugin

        Once you have created the roles you can pass them to the organization plugin both on the client and the server.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { organization } from "better-auth/plugins"
        import { ac, owner, admin, member } from "@/auth/permissions"

        export const auth = betterAuth({
            plugins: [
                organization({
                    ac,
                    roles: {
                        owner,
                        admin,
                        member,
                        myCustomRole
                    }
                }),
            ],
        });
        ```

        You also need to pass the access controller and the roles to the client plugin.

        ```ts title="auth-client"
        import { createAuthClient } from "better-auth/client"
        import { organizationClient } from "better-auth/client/plugins"
        import { ac, owner, admin, member, myCustomRole } from "@/auth/permissions"

        export const client = createAuthClient({
            plugins: [
                organizationClient({
                    ac,
                    roles: {
                        owner,
                        admin,
                        member,
                        myCustomRole
                    }
                })
          ]
        })
        ```
    </Step>
</Steps>


### Access Control Usage

**Has Permission**:

You can use the `hasPermission` action provided by the `api` to check the permission of the user.

```ts title="api.ts"
import { auth } from "@/auth";
    auth.api.hasPermission({
        headers: await headers(),
        body: {
            permission: {
                project: ["create"] // This must match the structure in your access control
            }
        }
    });
```

If you want to check the permission of the user on the client from the server you can use the `hasPermission` function provided by the client. 

```ts title="auth-client.ts"
const canCreateProject = await authClient.organization.hasPermission({
    permission: {
        project: ["create"]
    }
})
```

**Check Role Permission**:

Once you have defined the roles and permissions to avoid checking the permission from the server you can use the `checkRolePermission` function provided by the client.

```ts title="auth-client.ts"
const canCreateProject = client.organization.checkRolePermission({
	permission: {
		organization: ["delete"],
	},
	role: "admin",
});
```

## Teams

Teams allow you to group members within an organization. The teams feature provides additional organization structure and can be used to manage permissions at a more granular level.

### Enabling Teams

To enable teams, pass the `teams` configuration option to both server and client plugins:

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { organization } from "better-auth/plugins"

export const auth = betterAuth({
    plugins: [
        organization({
            teams: {
                enabled: true,
                maximumTeams: 10, // Optional: limit teams per organization
                allowRemovingAllTeams: false // Optional: prevent removing the last team
            }
        })
    ]
})
```

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client"
import { organizationClient } from "better-auth/client/plugins"

export const client = createAuthClient({
    plugins: [
        organizationClient({
            teams: {
                enabled: true
            }
        })
    ]
})
```

### Managing Teams

#### Create Team
Create a new team within an organization:

```ts
const team = await client.organization.createTeam({
    name: "Development Team",
    organizationId: "org-id" // Optional: defaults to active organization
})
```

#### List Teams
Get all teams in an organization:

```ts
const teams = await authClient.organization.listTeams({
  query: {
    organizationId: org.id, // Optional: defaults to active organization
  },
});
```

#### Update Team
Update a team's details:

```ts
const updatedTeam = await client.organization.updateTeam({
    teamId: "team-id",
    data: {
        name: "Updated Team Name"
    }
})
```

#### Remove Team
Delete a team from an organization:

```ts
await client.organization.removeTeam({
    teamId: "team-id",
    organizationId: "org-id" // Optional: defaults to active organization
})
```

### Team Permissions

Teams follow the organization's permission system. To manage teams, users need the following permissions:

- `team:create` - Create new teams
- `team:update` - Update team details
- `team:delete` - Remove teams

By default:
- Organization owners and admins can manage teams
- Regular members cannot create, update, or delete teams

### Team Configuration Options

The teams feature supports several configuration options:

- `maximumTeams`: Limit the number of teams per organization
  ```ts
  teams: {
    enabled: true,
    maximumTeams: 10 // Fixed number
    // OR
    maximumTeams: async ({ organizationId, session }, request) => {
      // Dynamic limit based on organization plan
      const plan = await getPlan(organizationId)
      return plan === 'pro' ? 20 : 5
    }
  }
  ```

- `allowRemovingAllTeams`: Control whether the last team can be removed
  ```ts
  teams: {
    enabled: true,
    allowRemovingAllTeams: false // Prevent removing the last team
  }
  ```

### Team Members

When inviting members to an organization, you can specify a team:

```ts
await client.organization.inviteMember({
    email: "user@example.com",
    role: "member",
    teamId: "team-id"
})
```

The invited member will be added to the specified team upon accepting the invitation.

### Database Schema

When teams are enabled, a new `team` table is added with the following structure:

<DatabaseTable
  fields={[
    { 
      name: "id", 
      type: "string", 
      description: "Unique identifier for each team",
      isPrimaryKey: true
    },
    { 
      name: "name", 
      type: "string", 
      description: "The name of the team" 
    },
    { 
      name: "organizationId", 
      type: "string", 
      description: "The id of the organization",
      isForeignKey: true
    },
    { 
      name: "createdAt", 
      type: "Date", 
      description: "Timestamp of when the team was created" 
    },
    { 
      name: "updatedAt", 
      type: "Date", 
      description: "Timestamp of when the team was last updated" 
    }
  ]}
/>

## Schema

The organization plugin adds the following tables to the database:

### Organization

Table Name: `organization`

<DatabaseTable
  fields={[
    { 
      name: "id", 
      type: "string", 
      description: "Unique identifier for each organization",
      isPrimaryKey: true
    },
    { 
      name: "name", 
      type: "string", 
      description: "The name of the organization" 
    },
    { 
      name: "slug", 
      type: "string", 
      description: "The slug of the organization" 
    },
    { 
      name: "logo", 
      type: "string", 
      description: "The logo of the organization",
      isOptional: true
    },   
    { 
      name: "metadata", 
      type: "string",
      description: "Additional metadata for the organization",
      isOptional: true
    },
    { 
      name: "createdAt", 
      type: "Date", 
      description: "Timestamp of when the organization was created" 
    },
  ]}
  />

### Member

Table Name: `member`

<DatabaseTable
  fields={[
    { 
      name: "id", 
      type: "string", 
      description: "Unique identifier for each member",
      isPrimaryKey: true
    },
    { 
      name: "userId", 
      type: "string", 
      description: "The id of the user",
      isForeignKey: true
    },
    { 
      name: "organizationId", 
      type: "string", 
      description: "The id of the organization",
      isForeignKey: true
    },
    { 
      name: "role", 
      type: "string", 
      description: "The role of the user in the organization" 
    },
    { 
      name: "createdAt", 
      type: "Date", 
      description: "Timestamp of when the member was added to the organization" 
    },
  ]}
  />

### Invitation

Table Name: `invitation`

<DatabaseTable
  fields={[
    { 
      name: "id", 
      type: "string", 
      description: "Unique identifier for each invitation",
      isPrimaryKey: true
    },
    { 
      name: "email", 
      type: "string", 
      description: "The email address of the user" 
    },
    { 
      name: "inviterId", 
      type: "string", 
      description: "The id of the inviter",
      isForeignKey: true
    },
    { 
      name: "organizationId", 
      type: "string", 
      description: "The id of the organization",
      isForeignKey: true
    },
    { 
      name: "role", 
      type: "string", 
      description: "The role of the user in the organization" 
    },
    { 
      name: "status", 
      type: "string", 
      description: "The status of the invitation" 
    },
    { 
      name: "expiresAt", 
      type: "Date", 
      description: "Timestamp of when the invitation expires" 
    },
    { 
      name: "createdAt", 
      type: "Date", 
      description: "Timestamp of when the invitation was created" 
    },
  ]}
  />

### Session

Table Name: `session` 

You need to add one more field to the session table to store the active organization id.

<DatabaseTable
  fields={[
    { 
      name: "activeOrganizationId", 
      type: "string", 
      description: "The id of the active organization",
      isOptional: true
    },
  ]}
  />

### Teams (optional)

Table Name: `team`

<DatabaseTable
  fields={[
    { 
      name: "id", 
      type: "string", 
      description: "Unique identifier for each team",
      isPrimaryKey: true
    },
    { 
      name: "name", 
      type: "string", 
      description: "The name of the team" 
    },
    { 
      name: "organizationId", 
      type: "string", 
      description: "The id of the organization",
      isForeignKey: true
    },
    { 
      name: "createdAt", 
      type: "Date", 
      description: "Timestamp of when the team was created" 
    },
    { 
      name: "updatedAt", 
      type: "Date", 
      isOptional: true,
      description: "Timestamp of when the team was created" 
    },
  ]}
/>


### Customizing the Schema

To change the schema table name or fields, you can pass `schema` option to the organization plugin. 

```ts title="auth.ts"
const auth = betterAuth({
  plugins: [organization({
    schema: {
      organization: {
        modelName: "organizations",  //map the organization table to organizations
        fields: { 
          name: "title" //map the name field to title
        }
      }
    }
  })]
})
```

## Options

**allowUserToCreateOrganization**: `boolean` | `((user: User) => Promise<boolean> | boolean)` - A function that determines whether a user can create an organization. By default, it's `true`. You can set it to `false` to restrict users from creating organizations.

**organizationLimit**: `number` | `((user: User) => Promise<boolean> | boolean)` - The maximum number of organizations allowed for a user. By default, it's `5`. You can set it to any number you want or a function that returns a boolean.

**creatorRole**: `admin | owner` - The role of the user who creates the organization. By default, it's `owner`. You can set it to `admin`.

**membershipLimit**: `number` - The maximum number of members allowed in an organization. By default, it's `100`. You can set it to any number you want.

**sendInvitationEmail**: `async (data) => Promise<void>` - A function that sends an invitation email to the user.

**invitationExpiresIn** : `number` - How long the invitation link is valid for in seconds. By default, it's 48 hours (2 days).

</document_content>
</document>
<document index="18">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/passkey.mdx</source>
<document_content>
---
title: Passkey
description: Passkey
---

Passkeys are a secure, passwordless authentication method using cryptographic key pairs, supported by WebAuthn and FIDO2 standards in web browsers. They replace passwords with unique key pairs: a private key stored on the user’s device and a public key shared with the website. Users can log in using biometrics, PINs, or security keys, providing strong, phishing-resistant authentication without traditional passwords.

The passkey plugin implementation is powered by [simple-web-authn](https://simplewebauthn.dev/) behind the scenes.

## Installation

<Steps>
    <Step>
        ### Add the plugin to your auth config
        To add the passkey plugin to your auth config, you need to import the plugin and pass it to the `plugins` option of the auth instance.

        **Options**

        `rpID`: A unique identifier for your website. 'localhost' is okay for local dev

        `rpName`: Human-readable title for your website

        `origin`: The URL at which registrations and authentications should occur. 'http://localhost' and 'http://localhost:PORT' are also valid. Do **NOT** include any trailing /

        `authenticatorSelection`: Allows customization of WebAuthn authenticator selection criteria. Leave unspecified for default settings.
            - `authenticatorAttachment`: Specifies the type of authenticator
                - `platform`: Authenticator is attached to the platform (e.g., fingerprint reader)
                - `cross-platform`: Authenticator is not attached to the platform (e.g., security key)
                - Default: `not set` (both platform and cross-platform allowed, with platform preferred)
            - `residentKey`: Determines credential storage behavior.
                - `required`: User MUST store credentials on the authenticator (highest security)
                - `preferred`: Encourages credential storage but not mandatory
                - `discouraged`: No credential storage required (fastest experience)
                - Default: `preferred`
            - `userVerification`: Controls biometric/PIN verification during authentication:
                - `required`: User MUST verify identity (highest security)
                - `preferred`: Verification encouraged but not mandatory
                - `discouraged`: No verification required (fastest experience)
                - Default: `preferred`
            
           
        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { passkey } from "better-auth/plugins/passkey" // [!code highlight]

        export const auth = betterAuth({
            plugins: [ // [!code highlight]
                passkey(), // [!code highlight]
            ], // [!code highlight]
        })
        ```
    </Step>
      <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```bash
            npx @better-auth/cli migrate
            ```
            </Tab>
            <Tab value="generate">
            ```bash
            npx @better-auth/cli generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>
    <Step>
        ### Add the client plugin

         ```ts title="auth-client.ts"
            import { createAuthClient } from "better-auth/client"
            import { passkeyClient } from "better-auth/client/plugins"

            const authClient =  createAuthClient({
                plugins: [ // [!code highlight]
                    passkeyClient() // [!code highlight]
                ] // [!code highlight]
            })
            ```
    </Step>

</Steps>

## Usage

### Add/Register a passkey

To add or register a passkey make sure a user is authenticated and then call the `passkey.addPasskey` function provided by the client.

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client";
import { passkeyClient } from "better-auth/client/plugins";

const authClient = createAuthClient({
  plugins: [
    // [!code highlight]
    passkeyClient(), // [!code highlight]
  ], // [!code highlight]
});

// Default behavior allows both platform and cross-platform passkeys
const { data, error } = await authClient.passkey.addPasskey();
```

This will prompt the user to register a passkey. And it'll add the passkey to the user's account.

You can also specify the type of authenticator you want to register. The authenticatorAttachment can be either `platform` or `cross-platform`.

```ts title="auth-client.ts"
// Register a cross-platform passkey showing only a QR code
// for the user to scan as well as the option to plug in a security key
const { data, error } = await authClient.passkey.addPasskey({
  authenticatorAttachment: 'cross-platform'
});
```

### Signin with a passkey

To signin with a passkey you can use the passkeySignIn method. This will prompt the user to sign in with their passkey.

Signin method accepts:

`autoFill`: Browser autofill, a.k.a. Conditional UI. [read more](https://simplewebauthn.dev/docs/packages/browser#browser-autofill-aka-conditional-ui)

`callbackURL`: The URL to redirect to after the user has signed in. (optional)

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client";
import { passkeyClient } from "better-auth/client/plugins";

const authClient = createAuthClient({
  plugins: [
    // [!code highlight]
    passkeyClient(), // [!code highlight]
  ], // [!code highlight]
});
const data = await authClient.signIn.passkey();
```

### Conditional UI

The plugin supports conditional UI, which allows the browser to autofill the passkey if the user has already registered a passkey.

There are two requirements for conditional UI to work:

<Steps>
    <Step>
        #### Update input fields

        Add the `autocomplete` attribute with the value `webauthn` to your input fields. You can add this attribute to multiple input fields, but at least one is required for conditional UI to work.

        The `webauthn` value should also be the last entry of the `autocomplete` attribute.

        ```html
        <label for="name">Username:</label>
        <input type="text" name="name" autocomplete="username webauthn">
        <label for="password">Password:</label>
        <input type="password" name="password" autocomplete="current-password webauthn">
        ```
    </Step>
    <Step>
        #### Preload the passkeys

        When your component mounts, you can preload the user's passkeys by calling the `authClient.signIn.passkey` method with the `autoFill` option set to `true`.

        To prevent unnecessary calls, we will also add a check to see if the browser supports conditional UI.

        <Tabs items={["React"]}>
            <Tab value="React">
            ```ts
            useEffect(() => {
               if (!PublicKeyCredential.isConditionalMediationAvailable ||
                   !PublicKeyCredential.isConditionalMediationAvailable()) {
                 return;
               }

              void authClient.signIn.passkey({ autoFill: true })
            }, [])
            ```
            </Tab>
        </Tabs>

    </Step>

   </Steps>

Depending on the browser, a prompt will appear to autofill the passkey. If the user has multiple passkeys, they can select the one they want to use.

Some browsers also require the user to first interact with the input field before the autofill prompt appears.

### Debugging

To test your passkey implementation you can use [emulated authenticators](https://developer.chrome.com/docs/devtools/webauthn). This way you can test the registration and sign-in process without even owning a physical device.

## Schema

The plugin require a new table in the database to store passkey data.

Table Name: `passkey`

<DatabaseTable
    fields={[
        { 
            name: "id", 
            type: "string", 
            description: "Unique identifier for each passkey",
            isPrimaryKey: true
        },
        {
            name: "name",
            type: "string",
            description: "The name of the passkey",
            isOptional: true
        },
        { 
            name: "publicKey", 
            type: "string", 
            description: "The public key of the passkey",
        },
        { 
            name: "userId", 
            type: "string", 
            description: "The id of the user",
            isForeignKey: true
        },
        {
            name: "credentialID",
            type: "string",
            description: "The unique identifier of the registered credential",
        },
        { 
            name: "counter", 
            type: "number", 
            description: "The counter of the passkey",
        },
        {
            name: "deviceType",
            type: "string",
            description: "The type of device used to register the passkey",
        },
        {
            name: "backedUp",
            type: "boolean",
            description: "Whether the passkey is backed up",
        },
        {
            name: "transports",
            type: "string",
            description: "The transports used to register the passkey",
        },
        { 
            name: "createdAt", 
            type: "Date", 
            description: "The time when the passkey was created",
        },
    ]}
    />

## Options

**rpID**: A unique identifier for your website. 'localhost' is okay for local dev.

**rpName**: Human-readable title for your website.

**origin**: The URL at which registrations and authentications should occur. 'http://localhost' and 'http://localhost:PORT' are also valid. Do NOT include any trailing /.

**authenticatorSelection**: Allows customization of WebAuthn authenticator selection criteria. When unspecified, both platform and cross-platform authenticators are allowed with `preferred` settings for `residentKey` and `userVerification`.
</document_content>
</document>
<document index="19">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/phone-number.mdx</source>
<document_content>
---
title: Phone Number
description: Phone number plugin
---

The phone number plugin extends the authentication system by allowing users to sign in and sign up using their phone number. It includes OTP (One-Time Password) functionality to verify phone numbers.

## Installation

<Steps>
    <Step>
        ### Add Plugin to the server

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { phoneNumber } from "better-auth/plugins"

        const auth = betterAuth({
            plugins: [ 
                phoneNumber({  // [!code highlight]
                    sendOTP: ({ phoneNumber, code }, request) => { // [!code highlight]
                        // Implement sending OTP code via SMS // [!code highlight]
                    } // [!code highlight]
                }) // [!code highlight]
            ] 
        })
        ```
    </Step>
    <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```bash
            npx @better-auth/cli migrate
            ```
            </Tab>
            <Tab value="generate">
            ```bash
            npx @better-auth/cli generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>
    <Step>
        ### Add the client plugin

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        import { phoneNumberClient } from "better-auth/client/plugins"

        const authClient =  createAuthClient({
            plugins: [ // [!code highlight]
                phoneNumberClient() // [!code highlight]
            ] // [!code highlight]
        })
        ```
    </Step>
</Steps>

## Usage

### Send OTP for Verification

To send an OTP to a user's phone number for verification, you can use the `sendVerificationCode` endpoint.

```ts title="auth-client.ts"
await authClient.phoneNumber.sendOtp({
    phoneNumber: "+1234567890"
})
```

### Verify Phone Number

After the OTP is sent, users can verify their phone number by providing the code.

```ts title="auth-client.ts"
const isVerified = await authClient.phoneNumber.verify({
    phoneNumber: "+1234567890",
    code: "123456"
})
```

When the phone number is verified, the `phoneNumberVerified` field in the user table is set to `true`. If `disableSession` is not set to `true`, a session is created for the user. Additionally, if `callbackOnVerification` is provided, it will be called.

### Allow Sign-Up with Phone Number

To allow users to sign up using their phone number, you can pass `signUpOnVerification` option to your plugin configuration. It requires you to pass `getTempEmail` function to generate a temporary email for the user.

```ts title="auth.ts"
export const auth = betterAuth({
    plugins: [
        phoneNumber({
            sendOTP: ({ phoneNumber, code }, request) => {
                // Implement sending OTP code via SMS
            },
            signUpOnVerification: {
                getTempEmail: (phoneNumber) => {
                    return `${phoneNumber}@my-site.com`
                },
                //optionally, you can also pass `getTempName` function to generate a temporary name for the user
                getTempName: (phoneNumber) => {
                    return phoneNumber //by default, it will use the phone number as the name
                }
            }
        })
    ]
})
```

### SignIn with Phone number

In addition to signing in a user using send-verify flow, you can also use phone number as an identifier and sign in a user using phone number and password.

```ts
await authClient.signIn.phoneNumber({
    phoneNumber: "+123456789",
    password: "password",
    rememberMe: true //optional defaults to true
})
```

### Update Phone Number

Updating phone number uses the same process as verifying a phone number. The user will receive an OTP code to verify the new phone number.


```ts title="auth-client.ts"
await authClient.phoneNumber.sendOtp({
    phoneNumber: "+1234567890" // New phone number
})
```

Then verify the new phone number with the OTP code. 

```ts title="auth-client.ts"
const isVerified = await authClient.phoneNumber.verify({
    phoneNumber: "+1234567890",
    code: "123456",
    updatePhoneNumber: true // Set to true to update the phone number
})
```

If a user session exist the phone number will be updated automatically.


### Disable Session Creation

By default, the plugin creates a session for the user after verifying the phone number. You can disable this behavior by passing `disableSession: true` to the `verify` method.

```ts title="auth-client.ts"
const isVerified = await authClient.phoneNumber.verify({
    phoneNumber: "+1234567890",
    code: "123456",
    disableSession: true
})
```

### Forget Password

To initiate a forget password flow using `phoneNumber`, you can start by calling `forgetPassword` on the client to send an OTP code to the user's phone number.

```ts title="auth-client.ts"
await authClient.phoneNumber.forgetPassword({
    phoneNumber: "+1234567890"
})
```

Then, you can reset the password by calling `resetPassword` on the client with the OTP code and the new password.

```ts title="auth-client.ts"
const isVerified = await authClient.phoneNumber.resetPassword({
    otp: "123456", // OTP code sent to the user's phone number
    phoneNumber: "+1234567890",
    newPassword: "newPassword"
})  
```

## Options

- `otpLength`: The length of the OTP code to be generated. Default is `6`.
- `sendOTP`: A function that sends the OTP code to the user's phone number. It takes the phone number and the OTP code as arguments.
- `verifyOTP`: A custom function to verify the OTP code. It takes the phone number and the OTP code as arguments and returns a boolean indicating whether the code is valid.
- `expiresIn`: The time in seconds after which the OTP code expires. Default is `300` seconds.
- `callbackOnVerification`: A function that is called after the phone number is verified. It takes the phone number and the user object as the first argument and a request object as the second argument.
```ts
export const auth = betterAuth({
    plugins: [
        phoneNumber({
            sendOTP: ({ phoneNumber, code }, request) => {
                // Implement sending OTP code via SMS
            },
            callbackOnVerification: async ({ phoneNumber, user }, request) => {
                // Implement callback after phone number verification
            }
        })
    ]
})
```
- `phoneNumberValidator`: A custom function to validate the phone number. It takes the phone number as an argument and returns a boolean indicating whether the phone number is valid.
- `signUpOnVerification`: An object with the following properties:
    - `getTempEmail`: A function that generates a temporary email for the user. It takes the phone number as an argument and returns the temporary email.
    - `getTempName`: A function that generates a temporary name for the user. It takes the phone number as an argument and returns the temporary name.
    

## Schema

The plugin requires 2 fields to be added to the user table 

### User Table
<DatabaseTable
    fields={[
        { 
            name: "phoneNumber", 
            type: "string", 
            description: "The phone number of the user",
            isUnique: true,
            isOptional: true
        },
        { 
            name: "phoneNumberVerified", 
            type: "boolean", 
            description: "Whether the phone number is verified or not",
            defaultValue: false,
            isOptional: true
        },
    ]}
    />

</document_content>
</document>
<document index="20">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/polar.mdx</source>
<document_content>
---
title: Polar
description: Better Auth Plugin for Payment and Checkouts using Polar
---

[Polar](https://polar.sh) is a developer first payment infrastructure. Out of the box it provides a lot of developer first integrations for payments, checkouts and more. This plugin helps you integrate Polar with Better Auth to make your auth + payments flow seamless.

<Callout>
This plugin is maintained by Polar team. For bugs, issues or feature requests, please visit the [Polar GitHub repo](https://github.com/polarsource/polar-adapters).
</Callout>

## Installation

<Steps>
    <Step>
        ### Install the plugin
        First, install the plugin:

        ```package-install
        @polar-sh/better-auth
        ```
    </Step>
    <Step>
        ### Install the Polar SDK

        Next, install the Polar SDK on your server:

        ```package-install
        @polar-sh/sdk
        ```
    </Step>
    <Step>
        ### Add the plugin to your auth config

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth";
        import { polar } from "@polar-sh/better-auth";
        import { Polar } from "@polar-sh/sdk";

        const client = new Polar({
            accessToken: process.env.POLAR_ACCESS_TOKEN,
            // Use 'sandbox' if you're using the Polar Sandbox environment
            // Remember that access tokens, products, etc. are completely separated between environments.
            // Access tokens obtained in Production are for instance not usable in the Sandbox environment.
            server: 'production'
        });

        const auth = betterAuth({
            // ... Better Auth config
            plugins: [
                polar({
                    client,
                    // Enable automatic Polar Customer creation on signup
                    createCustomerOnSignUp: true,
                    // Enable customer portal
                    enableCustomerPortal: true, // Deployed under /portal for authenticated users
                    // Configure checkout
                    checkout: {
                        enabled: true,
                        products: [
                            {
                                productId: "123-456-789", // ID of Product from Polar Dashboard
                                slug: "pro" // Custom slug for easy reference in Checkout URL, e.g. /checkout/pro
                            }
                        ],
                        successUrl: "/success?checkout_id={CHECKOUT_ID}"
                    },
                    // Incoming Webhooks handler will be installed at /polar/webhooks
                    webhooks: {
                        secret: process.env.POLAR_WEBHOOK_SECRET,
                        onPayload: ...,
                    }
                })
            ]
        });
        ```
    </Step>
</Steps>

<Callout>
There is no client configuration required. You don't need to pass any configuration options to the `createAuthClient` function.
</Callout>


For configuration options and more information, check out [Polar's Better Auth docs](https://docs.polar.sh/integrate/sdk/adapters/better-auth#configuration-options).

</document_content>
</document>
<document index="21">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/sso.mdx</source>
<document_content>
---
title: Single Sign-On (SSO)
description: Integrate Single Sign-On (SSO) with your application.
---

`OIDC` `OAuth2` `SSO`

Single Sign-On (SSO) allows users to authenticate with multiple applications using a single set of credentials. This plugin supports OpenID Connect (OIDC) and OAuth2 providers.

<Callout>
    SAML support is coming soon. Upvote the feature request on our [GitHub](https://github.com/better-auth/better-auth/issues/96)
</Callout>

## Installation

<Steps>
    <Step>
        ### Add Plugin to the server

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { sso } from "better-auth/plugins/sso";

        const auth = betterAuth({
            plugins: [ // [!code highlight]
                sso() // [!code highlight]
            ] // [!code highlight]
        })
        ```
    </Step>
    <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```bash
            npx @better-auth/cli migrate
            ```
            </Tab>
            <Tab value="generate">
            ```bash
            npx @better-auth/cli generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>
    <Step>
        ### Add the client plugin

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        import { ssoClient } from "better-auth/client/plugins"

        const authClient = createAuthClient({
            plugins: [ // [!code highlight]
                ssoClient() // [!code highlight]
            ] // [!code highlight]
        })
        ```
    </Step>
</Steps>

## Usage

### Register an OIDC Provider

To register an OIDC provider, use the `createOIDCProvider` endpoint and provide the necessary configuration details for the provider.

A redirect URL will be automatically generated using the provider ID. For instance, if the provider ID is `hydra`, the redirect URL would be `{baseURL}/api/auth/sso/hydra`. Note that `/api/auth` may vary depending on your base path configuration.

<Tabs items={["client", "server"]}>
    <Tab value="client">
```ts title="register-provider.ts"
import { authClient } from "@/lib/auth-client";

// only with issuer if the provider supports discovery
await authClient.sso.register({
    issuer: "https://idp.example.com",
    providerId: "example-provider",
});

// with all fields
await authClient.sso.register({
    issuer: "https://idp.example.com",
    domain: "example.com",
    clientId: "client-id",
    clientSecret: "client-secret",
    authorizationEndpoint: "https://idp.example.com/authorize",
    tokenEndpoint: "https://idp.example.com/token",
    jwksEndpoint: "https://idp.example.com/jwks",
    mapping: {
        id: "sub",
        email: "email",
        emailVerified: "email_verified",
        name: "name",
        image: "picture",
    },
    providerId: "example-provider",
});
```
    </Tab>

    <Tab value="server">
```ts title="register-provider.ts"
const { headers } = await signInWithTestUser();
await auth.api.createOIDCProvider({
    body: {
        issuer: "https://idp.example.com",
        domain: "example.com",
        clientId: "your-client-id",
        clientSecret: "your-client-secret",
        authorizationEndpoint: "https://idp.example.com/authorize",
        tokenEndpoint: "https://idp.example.comtoken",
        jwksEndpoint: "https://idp.example.com/jwks",
        mapping: {
            id: "sub",
            email: "email",
            emailVerified: "email_verified",
            name: "name",
            image: "picture",
        },
        providerId: "example-provider",
    },
    headers,
});
```
    </Tab>
</Tabs>

### Sign In with SSO

To sign in with an SSO provider, you can call `signIn.sso`

You can sign in using the email with domain matching:

```ts title="sign-in.ts"
const res = await authClient.signIn.sso({
    email: "user@example.com",
    callbackURL: "/dashboard",
});
```

or you can specify the domain:

```ts title="sign-in-domain.ts"
const res = await authClient.signIn.sso({
    domain: "example.com",
    callbackURL: "/dashboard",
});
```

You can also sign in using the organization slug if a provider is associated with an organization:

```ts title="sign-in-org.ts"
const res = await authClient.signIn.sso({
    organizationSlug: "example-org",
    callbackURL: "/dashboard",
});
```

Alternatively, you can sign in using the provider's ID:

```ts title="sign-in-provider-id.ts"
const res = await authClient.signIn.sso({
    providerId: "example-provider-id",
    callbackURL: "/dashboard",
});
```

To use the server api you can use `signInSSO`

```ts title="sign-in-org.ts"
const res = await auth.api.signInSSO({
    body: {
        organizationSlug: "example-org",
        callbackURL: "/dashboard",
    }
});
```

When a user is authenticated, if the user does not exist, the user will be provisioned using the `provisionUser` function. If the organization provisioning is enabled and a provider is associated with an organization, the user will be added to the organization.


```ts title="auth.ts"
const auth = betterAuth({
    plugins: [
        sso({
            provisionUser: async (user) => {
                // provision user
            },
            organizationProvisioning: {
                disabled: false,
                defaultRole: "member",
                getRole: async (user) => {
                    // get role if needed
                },
            },
        }),
    ],
});
```

## Schema

The plugin requires additional fields in the `ssoProvider` table to store the provider's configuration.

<DatabaseTable
    fields={[
        {
            name: "id", type: "string", description: "A database identifier", isRequired: true, isPrimaryKey: true,
        },
        { name: "issuer", type: "string", description: "The issuer identifier", isRequired: true },
        { name: "domain", type: "string", description: "The domain of the provider", isRequired: true },
        { name: "oidcConfig", type: "string", description: "The OIDC configuration", isRequired: false },
        { name: "userId", type: "string", description: "The user id", isRequired: true, references: { model: "user", field: "id" } },
        { name: "providerId", type: "string", description: "The provider id. Used to identify a provider and to generate a redirect url.", isRequired: true, isUnique: true },
        { name: "organizationId", type: "string", description: "The organization Id. If provider is linked to an organization.", isRequired: false },
    ]}
/>

## Options

### Server

**provisionUser**: A custom function to provision a user when they sign in with an SSO provider.

**organizationProvisioning**: Options for provisioning users to an organization.

<TypeTable
  type={{
    provisionUser: {
        description: "A custom function to provision a user when they sign in with an SSO provider.",
        type: "function",
    },
    organizationProvisioning: {
        description: "Options for provisioning users to an organization.",
        type: "object",
        properties: {
            disabled: {
                description: "Disable organization provisioning.",
                type: "boolean",
                default: false,
            },
            defaultRole: {
                description: "The default role for new users.",
                type: "string",
                enum: ["member", "admin"],
                default: "member",
            },
            getRole: {
                description: "A custom function to determine the role for new users.",
                type: "function",
            },
        },
    },
  }}
/>

</document_content>
</document>
<document index="22">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/stripe.mdx</source>
<document_content>
---
title: Stripe
description: Stripe plugin for Better Auth to manage subscriptions and payments.
---

The Stripe plugin integrates Stripe's payment and subscription functionality with Better Auth. Since payment and authentication are often tightly coupled, this plugin simplifies the integration of stripe into your application, handling customer creation, subscription management, and webhook processing.

<Callout type="warn">
This plugin is currently in beta. We're actively collecting feedback and exploring additional features. If you have feature requests or suggestions, please join our [Discord community](https://discord.com/invite/Mh3DaacaFs) to discuss them.
</Callout>

## Features

- Create Stripe Customers automatically when users sign up
- Manage subscription plans and pricing
- Process subscription lifecycle events (creation, updates, cancellations)
- Handle Stripe webhooks securely with signature verification
- Expose subscription data to your application
- Support for trial periods and subscription upgrades
- Flexible reference system to associate subscriptions with users or organizations
- Team subscription support with seats management

## Installation

<Steps>
    <Step>
        ### Install the plugin

        First, install the plugin:

        ```package-install
        @better-auth/stripe
        ```
        <Callout>
        If you're using a separate client and server setup, make sure to install the plugin in both parts of your project.
        </Callout>
    </Step>
    <Step>
        ### Install the Stripe SDK

        Next, install the Stripe SDK on your server:

        ```package-install
        stripe
        ```
    </Step>
    <Step>
        ### Add the plugin to your auth config

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { stripe } from "@better-auth/stripe"
        import Stripe from "stripe"

        const stripeClient = new Stripe(process.env.STRIPE_SECRET_KEY!)

        export const auth = betterAuth({
            // ... your existing config
            plugins: [
                stripe({
                    stripeClient,
                    stripeWebhookSecret: process.env.STRIPE_WEBHOOK_SECRET!,
                    createCustomerOnSignUp: true,
                })
            ]
        })
        ```
    </Step>
    <Step>
        ### Add the client plugin

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        import { stripeClient } from "@better-auth/stripe/client"

        export const client = createAuthClient({
            // ... your existing config
            plugins: [
                stripeClient({
                    subscription: true //if you want to enable subscription management
                })
            ]
        })
        ```
    </Step>
    <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```bash
            npx @better-auth/cli migrate
            ```
            </Tab>
            <Tab value="generate">
            ```bash
            npx @better-auth/cli generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the tables manually.
    </Step>
    <Step>
        ### Set up Stripe webhooks

        Create a webhook endpoint in your Stripe dashboard pointing to:

        ```
        https://your-domain.com/api/auth/stripe/webhook
        ```
        `/api/auth` is the default path for the auth server.
        
        Make sure to select at least these events:
        - `checkout.session.completed`
        - `customer.subscription.updated`
        - `customer.subscription.deleted`

        Save the webhook signing secret provided by Stripe and add it to your environment variables as `STRIPE_WEBHOOK_SECRET`.
    </Step>
</Steps>

## Usage

### Customer Management

You can use this plugin solely for customer management without enabling subscriptions. This is useful if you just want to link Stripe customers to your users.

By default, when a user signs up, a Stripe customer is automatically created if you set `createCustomerOnSignUp: true`. This customer is linked to the user in your database.
You can customize the customer creation process:

```ts title="auth.ts"
stripe({
    // ... other options
    createCustomerOnSignUp: true,
    onCustomerCreate: async ({ customer, stripeCustomer, user }, request) => {
        // Do something with the newly created customer
        console.log(`Customer ${customer.id} created for user ${user.id}`);
    },
    getCustomerCreateParams: async ({ user, session }, request) => {
        // Customize the Stripe customer creation parameters
        return {
            metadata: {
                referralSource: user.metadata?.referralSource
            }
        };
    }
})
```

### Subscription Management

#### Defining Plans

You can define your subscription plans either statically or dynamically:

```ts title="auth.ts"
// Static plans
subscription: {
    enabled: true,
    plans: [
        {
            name: "basic", // the name of the plan, it'll be automatically lower cased when stored in the database
            priceId: "price_1234567890", // the price id from stripe
            annualDiscountPriceId: "price_1234567890", // (optional) the price id for annual billing with a discount
            limits: {
                projects: 5,
                storage: 10
            }
        },
        {
            name: "pro",
            priceId: "price_0987654321",
            limits: {
                projects: 20,
                storage: 50
            },
            freeTrial: {
                days: 14,
            }
        }
    ]
}

// Dynamic plans (fetched from database or API)
subscription: {
    enabled: true,
    plans: async () => {
        const plans = await db.query("SELECT * FROM plans");
        return plans.map(plan => ({
            name: plan.name,
            priceId: plan.stripe_price_id,
            limits: JSON.parse(plan.limits)
        }));
    }
}
```

see [plan configuration](#plan-configuration) for more.

#### Creating a Subscription

To create a subscription, use the `subscription.upgrade` method:

```ts title="client.ts"
await client.subscription.upgrade({
    plan: "pro",
    successUrl: "/dashboard",
    cancelUrl: "/pricing",
    annual: true, // Optional: upgrade to an annual plan
    referenceId: "org_123" // Optional: defaults to the current logged in user id
    seats: 5 // Optional: for team plans
});
```

This will create a Checkout Session and redirect the user to the Stripe Checkout page.

> **Important:** The `successUrl` parameter will be internally modified to handle race conditions between checkout completion and webhook processing. The plugin creates an intermediate redirect that ensures subscription status is properly updated before redirecting to your success page.

```ts
const { error } = await client.subscription.upgrade({
    plan: "pro",
    successUrl: "/dashboard",
    cancelUrl: "/pricing",
});
if(error) {
    alert(error.message);
}
```

<Callout type="warn">
For each reference ID (user or organization), only one active or trialing subscription is supported at a time. The plugin doesn't currently support multiple concurrent active subscriptions for the same reference ID.
</Callout>


#### Listing Active Subscriptions

To get the user's active subscriptions:

```ts title="client.ts"
const { data: subscriptions } = await client.subscription.list();

// get the active subscription
const activeSubscription = subscriptions.find(
    sub => sub.status === "active" || sub.status === "trialing"
);

// Check subscription limits
const projectLimit = subscriptions?.limits?.projects || 0;
```

#### Canceling a Subscription

To cancel a subscription:

```ts title="client.ts"
const { data } = await client.subscription.cancel({
    returnUrl: "/account",
    referenceId: "org_123" // optional defaults to userId
});
```

This will redirect the user to the Stripe Billing Portal where they can cancel their subscription.

### Reference System

By default, subscriptions are associated with the user ID. However, you can use a custom reference ID to associate subscriptions with other entities, such as organizations:

```ts title="client.ts"
// Create a subscription for an organization
await client.subscription.upgrade({
    plan: "pro",
    referenceId: "org_123456",
    successUrl: "/dashboard",
    cancelUrl: "/pricing",
    seats: 5 // Number of seats for team plans
});

// List subscriptions for an organization
const { data: subscriptions } = await client.subscription.list({
    query: {
        referenceId: "org_123456"
    }
});
```

#### Team Subscriptions with Seats

For team or organization plans, you can specify the number of seats:

```ts
await client.subscription.upgrade({
    plan: "team",
    referenceId: "org_123456",
    seats: 10, // 10 team members
    successUrl: "/org/billing/success",
    cancelUrl: "/org/billing"
});
```

The `seats` parameter is passed to Stripe as the quantity for the subscription item. You can use this value in your application logic to limit the number of members in a team or organization.

To authorize reference IDs, implement the `authorizeReference` function:

```ts title="auth.ts"
subscription: {
    // ... other options
    authorizeReference: async ({ user, session, referenceId, action }) => {
        // Check if the user has permission to manage subscriptions for this reference
        if (action === "upgrade-subscription" || action === "cancel-subscription") {
            const org = await db.member.findFirst({
                where: {
                    organizationId: referenceId,
                    userId: user.id
                }   
            });
            return org?.role === "owner"
        }
        return true;
    }
}
```

### Webhook Handling

The plugin automatically handles common webhook events:

- `checkout.session.completed`: Updates subscription status after checkout
- `customer.subscription.updated`: Updates subscription details when changed
- `customer.subscription.deleted`: Marks subscription as canceled

You can also handle custom events:

```ts title="auth.ts"
stripe({
    // ... other options
    onEvent: async (event) => {
        // Handle any Stripe event
        switch (event.type) {
            case "invoice.paid":
                // Handle paid invoice
                break;
            case "payment_intent.succeeded":
                // Handle successful payment
                break;
        }
    }
})
```

### Subscription Lifecycle Hooks

You can hook into various subscription lifecycle events:

```ts title="auth.ts"
subscription: {
    // ... other options
    onSubscriptionComplete: async ({ event, subscription, stripeSubscription, plan }) => {
        // Called when a subscription is successfully created
        await sendWelcomeEmail(subscription.referenceId, plan.name);
    },
    onSubscriptionUpdate: async ({ event, subscription }) => {
        // Called when a subscription is updated
        console.log(`Subscription ${subscription.id} updated`);
    },
    onSubscriptionCancel: async ({ event, subscription, stripeSubscription, cancellationDetails }) => {
        // Called when a subscription is canceled
        await sendCancellationEmail(subscription.referenceId);
    },
    onSubscriptionDeleted: async ({ event, subscription, stripeSubscription }) => {
        // Called when a subscription is deleted
        console.log(`Subscription ${subscription.id} deleted`);
    }
}
```

### Trial Periods

You can configure trial periods for your plans:

```ts title="auth.ts"
{
    name: "pro",
    priceId: "price_0987654321",
    freeTrial: {
        days: 14,
        onTrialStart: async (subscription) => {
            // Called when a trial starts
            await sendTrialStartEmail(subscription.referenceId);
        },
        onTrialEnd: async ({ subscription, user }, request) => {
            // Called when a trial ends
            await sendTrialEndEmail(user.email);
        },
        onTrialExpired: async (subscription) => {
            // Called when a trial expires without conversion
            await sendTrialExpiredEmail(subscription.referenceId);
        }
    }
}
```

## Schema

The Stripe plugin adds the following tables to your database:


### User

Table Name: `user`

<DatabaseTable
  fields={[
    { 
      name: "stripeCustomerId", 
      type: "string", 
      description: "The Stripe customer ID" 
    },
  ]}
/>

### Subscription

Table Name: `subscription`

<DatabaseTable
  fields={[
    { 
      name: "id", 
      type: "string", 
      description: "Unique identifier for each subscription",
      isPrimaryKey: true
    },
    { 
      name: "plan", 
      type: "string", 
      description: "The name of the subscription plan" 
    },
    { 
      name: "referenceId", 
      type: "string", 
      description: "The ID this subscription is associated with (user ID by default)",
      isUnique: true
    },
    { 
      name: "stripeCustomerId", 
      type: "string", 
      description: "The Stripe customer ID",
      isOptional: true
    },
    { 
      name: "stripeSubscriptionId", 
      type: "string", 
      description: "The Stripe subscription ID",
      isOptional: true
    },
    { 
      name: "status", 
      type: "string", 
      description: "The status of the subscription (active, canceled, etc.)",
      defaultValue: "incomplete"
    },
    { 
      name: "periodStart", 
      type: "Date", 
      description: "Start date of the current billing period",
      isOptional: true
    },
    { 
      name: "periodEnd", 
      type: "Date", 
      description: "End date of the current billing period",
      isOptional: true
    },
    { 
      name: "cancelAtPeriodEnd", 
      type: "boolean", 
      description: "Whether the subscription will be canceled at the end of the period",
      defaultValue: false,
      isOptional: true
    },
    { 
      name: "seats", 
      type: "number", 
      description: "Number of seats for team plans",
      isOptional: true
    },
    { 
      name: "trialStart", 
      type: "Date", 
      description: "Start date of the trial period",
      isOptional: true
    },
    { 
      name: "trialEnd", 
      type: "Date", 
      description: "End date of the trial period",
      isOptional: true
    }
  ]}
/>

### Customizing the Schema

To change the schema table names or fields, you can pass a `schema` option to the Stripe plugin:

```ts title="auth.ts"
stripe({
    // ... other options
    schema: {
        subscription: {
            modelName: "stripeSubscriptions", // map the subscription table to stripeSubscriptions
            fields: {
                plan: "planName" // map the plan field to planName
            }
        }
    }
})
```

## Options

### Main Options

**stripeClient**: `Stripe` - The Stripe client instance. Required.

**stripeWebhookSecret**: `string` - The webhook signing secret from Stripe. Required.

**createCustomerOnSignUp**: `boolean` - Whether to automatically create a Stripe customer when a user signs up. Default: `false`.

**onCustomerCreate**: `(data: { customer: Customer, stripeCustomer: Stripe.Customer, user: User }, request?: Request) => Promise<void>` - A function called after a customer is created.

**getCustomerCreateParams**: `(data: { user: User, session: Session }, request?: Request) => Promise<{}>` - A function to customize the Stripe customer creation parameters.

**onEvent**: `(event: Stripe.Event) => Promise<void>` - A function called for any Stripe webhook event.

### Subscription Options

**enabled**: `boolean` - Whether to enable subscription functionality. Required.

**plans**: `Plan[] | (() => Promise<Plan[]>)` - An array of subscription plans or a function that returns plans. Required if subscriptions are enabled.

**requireEmailVerification**: `boolean` - Whether to require email verification before allowing subscription upgrades. Default: `false`.

**authorizeReference**: `(data: { user: User, session: Session, referenceId: string, action: "upgrade-subscription" | "list-subscription" | "cancel-subscription" }, request?: Request) => Promise<boolean>` - A function to authorize reference IDs.

### Plan Configuration

Each plan can have the following properties:

**name**: `string` - The name of the plan. Required.

**priceId**: `string` - The Stripe price ID. Required unless using `lookupKey`.

**lookupKey**: `string` - The Stripe price lookup key. Alternative to `priceId`.

**annualDiscountPriceId**: `string` - A price ID for annual billing with a discount.

**limits**: `Record<string, number>` - Limits associated with the plan (e.g., `{ projects: 10, storage: 5 }`).

**group**: `string` - A group name for the plan, useful for categorizing plans.

**freeTrial**: Object containing trial configuration:
  - **days**: `number` - Number of trial days.
  - **onTrialStart**: `(subscription: Subscription) => Promise<void>` - Called when a trial starts.
  - **onTrialEnd**: `(data: { subscription: Subscription, user: User }, request?: Request) => Promise<void>` - Called when a trial ends.
  - **onTrialExpired**: `(subscription: Subscription) => Promise<void>` - Called when a trial expires without conversion.

## Advanced Usage

### Using with Organizations

The Stripe plugin works well with the organization plugin. You can associate subscriptions with organizations instead of individual users:

```ts title="client.ts"
// Get the active organization
const { data: activeOrg } = client.useActiveOrganization();

// Create a subscription for the organization
await client.subscription.upgrade({
    plan: "team",
    referenceId: activeOrg.id,
    seats: 10,
    annual: true, // upgrade to an annual plan (optional)
    successUrl: "/org/billing/success",
    cancelUrl: "/org/billing"
});
```

Make sure to implement the `authorizeReference` function to verify that the user has permission to manage subscriptions for the organization:

```ts title="auth.ts"
authorizeReference: async ({ user, referenceId, action }) => {
    const member = await db.members.findFirst({
        where: {
            userId: user.id,
            organizationId: referenceId
        }
    });
    
    return member?.role === "owner" || member?.role === "admin";
}
```

### Custom Checkout Session Parameters

You can customize the Stripe Checkout session with additional parameters:

```ts title="auth.ts"
getCheckoutSessionParams: async ({ user, session, plan, subscription }, request) => {
    return {
        params: {
            allow_promotion_codes: true,
            tax_id_collection: {
                enabled: true
            },
            billing_address_collection: "required",
            custom_text: {
                submit: {
                    message: "We'll start your subscription right away"
                }
            },
            metadata: {
                planType: "business",
                referralCode: user.metadata?.referralCode
            }
        },
        options: {
            idempotencyKey: `sub_${user.id}_${plan.name}_${Date.now()}`
        }
    };
}
```

### Tax Collection

To enable tax collection:

```ts title="auth.ts"
subscription: {
    // ... other options
    getCheckoutSessionParams: async ({ user, session, plan, subscription }, request) => {
        return {
            params: {
                tax_id_collection: {
                    enabled: true
                }
            }
        };
    }
}
```

## Troubleshooting

### Webhook Issues

If webhooks aren't being processed correctly:

1. Check that your webhook URL is correctly configured in the Stripe dashboard
2. Verify that the webhook signing secret is correct
3. Ensure you've selected all the necessary events in the Stripe dashboard
4. Check your server logs for any errors during webhook processing

### Subscription Status Issues

If subscription statuses aren't updating correctly:

1. Make sure the webhook events are being received and processed
2. Check that the `stripeCustomerId` and `stripeSubscriptionId` fields are correctly populated
3. Verify that the reference IDs match between your application and Stripe

### Testing Webhooks Locally

For local development, you can use the Stripe CLI to forward webhooks to your local environment:

```bash
stripe listen --forward-to localhost:3000/api/auth/stripe/webhook
```

This will provide you with a webhook signing secret that you can use in your local environment.

</document_content>
</document>
<document index="23">
<source>/Users/josh/Documents/GitHub/better-auth/better-auth/docs/content/docs/plugins/username.mdx</source>
<document_content>
---
title: Username
description: Username plugin
---

The username plugin wraps the email and password authenticator and adds username support. This allows users to sign in and sign up with their username instead of their email.

## Installation

<Steps>
    <Step>
        ### Add Plugin to the server

        ```ts title="auth.ts" 
        import { betterAuth } from "better-auth"
        import { username } from "better-auth/plugins"

        const auth = betterAuth({
            plugins: [ // [!code highlight]
                username() // [!code highlight]
            ] // [!code highlight]
        })
        ```
    </Step>
    <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```bash
            npx @better-auth/cli migrate
            ```
            </Tab>
            <Tab value="generate">
            ```bash
            npx @better-auth/cli generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>
    <Step>
        ### Add the client plugin
        
        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        import { usernameClient } from "better-auth/client/plugins"
        
        const authClient = createAuthClient({
            plugins: [ // [!code highlight]
                usernameClient() // [!code highlight]
            ] // [!code highlight]
        })
        ```
    </Step>
</Steps>

## Usage

### Signup with username

To sign up a user with username, you can use the existing `signUp.email` function provided by the client. The `signUp` function should take a new `username` property in the object.

```ts title="auth-client.ts"
const data = await authClient.signUp.email({
    email: "email@domain.com",
    name: "Test User",
    password: "password1234",
    username: "test"
})
```

### Signin with username

To signin a user with username, you can use the `signIn.username` function provided by the client. The `signIn` function takes an object with the following properties:

- `username`: The username of the user.
- `password`: The password of the user.

```ts title="auth-client.ts" 
const data = await authClient.signIn.username({
    username: "test",
    password: "password1234",
})
```

### Update username

To update the username of a user, you can use the `updateUser` function provided by the client.

```ts title="auth-client.ts"
const data = await authClient.updateUser({
    username: "new-username"
})
```

## Schema

The plugin requires 1 field to be added to the user table:

<DatabaseTable
    fields={[
        { 
            name: "username", 
            type: "string", 
            description: "The username of the user",
            isUnique: true
        },
        { 
            name: "displayUsername", 
            type: "string", 
            description: "Non normalized username of the user",
            isUnique: true
        },
    ]}
/>

## Options

### Min Username Length

The minimum length of the username. Default is `3`.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { username } from "better-auth/plugins"

const auth = betterAuth({
    plugins: [
        username({
            minUsernameLength: 5
        })
    ]
})
```

### Max Username Length

The maximum length of the username. Default is `30`.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { username } from "better-auth/plugins"

const auth = betterAuth({
    plugins: [
        username({
            maxUsernameLength: 100
        })
    ]
})
```

### Username Validator 

A function that validates the username. The function should return false if the username is invalid. By default, the username should only contain alphanumeric characters, underscores, and dots.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { username } from "better-auth/plugins"

const auth = betterAuth({
    plugins: [
        username({
            usernameValidator: (username) => {
                if (username === "admin") {
                    return false
                }
            }
        })
    ]
})
```

</document_content>
</document>
</documents>
