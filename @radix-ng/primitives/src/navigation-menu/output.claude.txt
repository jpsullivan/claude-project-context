<documents>
<document index="1">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/README.md</source>
<document_content>
# @radix-ng/primitives/navigation-menu

A responsive navigation component that automatically collapses navigation items into a menu when space is limited. Follows the WAI-ARIA Menu Button Pattern for accessibility.

</document_content>
</document>
<document index="2">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/index.ts</source>
<document_content>
import { NgModule } from '@angular/core';
import {
    RdxNavigationMenuAriaOwnsComponent,
    RdxNavigationMenuFocusProxyComponent
} from './src/navigation-menu-a11y.component';
import { RdxNavigationMenuContentDirective } from './src/navigation-menu-content.directive';
import { RdxNavigationMenuIndicatorDirective } from './src/navigation-menu-indicator.directive';
import { RdxNavigationMenuItemDirective } from './src/navigation-menu-item.directive';
import { RdxNavigationMenuLinkDirective } from './src/navigation-menu-link.directive';
import { RdxNavigationMenuListDirective } from './src/navigation-menu-list.directive';
import { RdxNavigationMenuSubDirective } from './src/navigation-menu-sub.directive';
import { RdxNavigationMenuTriggerDirective } from './src/navigation-menu-trigger.directive';
import { RdxNavigationMenuViewportDirective } from './src/navigation-menu-viewport.directive';
import { RdxNavigationMenuDirective } from './src/navigation-menu.directive';

export * from './src/navigation-menu-a11y.component';
export * from './src/navigation-menu-content.directive';
export * from './src/navigation-menu-indicator.directive';
export * from './src/navigation-menu-item.directive';
export * from './src/navigation-menu-link.directive';
export * from './src/navigation-menu-list.directive';
export * from './src/navigation-menu-sub.directive';
export * from './src/navigation-menu-trigger.directive';
export * from './src/navigation-menu-viewport.directive';
export * from './src/navigation-menu.directive';
export * from './src/navigation-menu.token';
export * from './src/navigation-menu.types';

const _imports = [
    RdxNavigationMenuDirective,
    RdxNavigationMenuSubDirective,
    RdxNavigationMenuListDirective,
    RdxNavigationMenuItemDirective,
    RdxNavigationMenuTriggerDirective,
    RdxNavigationMenuLinkDirective,
    RdxNavigationMenuIndicatorDirective,
    RdxNavigationMenuContentDirective,
    RdxNavigationMenuViewportDirective,
    RdxNavigationMenuFocusProxyComponent,
    RdxNavigationMenuAriaOwnsComponent
];

@NgModule({
    imports: [..._imports],
    exports: [..._imports]
})
export class RdxNavigationMenuModule {}

</document_content>
</document>
<document index="3">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/ng-package.json</source>
<document_content>
{
    "lib": {
        "entryFile": "index.ts"
    }
}

</document_content>
</document>
<document index="4">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/stories/navigation-menu.docs.mdx</source>
<document_content>
import {ArgTypes, Canvas, Markdown, Meta, Source} from '@storybook/blocks';
import * as NavigationMenuStories from "./navigation-menu.stories";

<Meta title="Primitives/Navigation Menu" />

# Navigation Menu

A navigation component that provides structured menu navigation with support for submenus and content display.

## Overview

The Navigation Menu component provides:

- ✅ Support for different item types including links, buttons, and custom components
- ✅ Submenu navigation capabilities
- ✅ Keyboard navigation support
- ✅ LTR and RTL layout compatibility
- ✅ Focus management for accessibility compliance

## Examples
### Default

<Canvas sourceState="hidden" of={NavigationMenuStories.Default} />

## Component Structure

```html
<nav rdxNavigationMenu>
  <ul rdxNavigationMenuList>
    <li rdxNavigationMenuItem value="item1">
      <button rdxNavigationMenuTrigger>Item 1</button>

      <!-- Content as structural directive -->
      <div *rdxNavigationMenuContent class="NavigationMenuContent">
        <!-- Content for Item 1 -->
      </div>
    </li>

    <li rdxNavigationMenuItem value="item2">
      <a rdxNavigationMenuLink href="#">Item 2</a>
    </li>

    <!-- Indicator for highlighting active item -->
    <div rdxNavigationMenuIndicator></div>
  </ul>

  <!-- Viewport for content display -->
  <div rdxNavigationMenuViewport></div>
</nav>
```

## API Reference

### Root
`rdxNavigationMenu`

The root directive that contains all parts of a navigation menu.

| Property | Type | Default | Description |
| -------- | ---- | ------- | ----------- |
| orientation | 'horizontal' \| 'vertical' | 'horizontal' | Determines the orientation of the navigation menu |
| dir | 'ltr' \| 'rtl' | 'ltr' | Sets the reading direction of the navigation menu |
| delayDuration | number | 200 | Duration (ms) from mouse enter until content opens |
| skipDelayDuration | number | 300 | Duration (ms) after leaving a submenu before it closes |
| loop | boolean | false | When true, keyboard navigation loops from last item to first and vice versa |

### List
`rdxNavigationMenuList`

Container for navigation menu items. Must be rendered inside `rdxNavigationMenu` or `rdxNavigationMenuSub`. Has the `menubar` ARIA role.

### Item
`rdxNavigationMenuItem`

A navigation item container that can hold a trigger and content.

### Trigger
`rdxNavigationMenuTrigger`

Button that opens submenu content. Must be rendered inside `rdxNavigationMenuItem`.

| Data attribute | Value |
|----------------|-------|
| [data-state] | 'open' \| 'closed' |
| [data-disabled] | Present when disabled |

### Link
`rdxNavigationMenuLink`

A navigation link. Must be rendered inside `rdxNavigationMenuItem`.

| Property | Type | Default | Description |
| -------- | ---- | ------- | ----------- |
| active | boolean | false | Indicates if the link is active |

| Data attribute | Value |
|----------------|-------|
| [data-active] | Present when active |

### Content
`*rdxNavigationMenuContent`

Content displayed when a trigger is activated. Must be rendered inside `rdxNavigationMenuItem`. Used as a structural directive with asterisk syntax. Content renders within the `rdxNavigationMenuViewport`.

| Property | Type | Default | Description |
| -------- | ---- | ------- | ----------- |
| forceMount | boolean | false | Keeps content in the DOM even when closed |

Data attributes can be manually controlled:

```html
<div *rdxNavigationMenuContent
     class="NavigationMenuContent"
     [attr.data-state]="'open'"
     [attr.data-motion]="'from-start'">
  <!-- Content -->
</div>
```

### Indicator
`rdxNavigationMenuIndicator`

Visual indicator for active menu items. Must be rendered inside `rdxNavigationMenuList`.

| Property | Type | Default | Description |
| -------- | ---- | ------- | ----------- |
| forceMount | boolean | false | Keeps indicator in the DOM even when hidden |

| Data attribute | Value |
|----------------|-------|
| [data-state] | 'visible' \| 'hidden' |

### Viewport
`rdxNavigationMenuViewport`

Component that displays active content. Must be rendered inside `rdxNavigationMenu`.

| Property | Type | Default | Description |
| -------- | ---- | ------- | ----------- |
| forceMount | boolean | false | Keeps viewport in the DOM even when closed |

| Data attribute | Value |
|----------------|-------|
| [data-state] | 'open' \| 'closed' |

### Sub
`rdxNavigationMenuSub`

Container for nested submenus. Contains its own `rdxNavigationMenuList` and items. Must be rendered inside `rdxNavigationMenuItem`.

| Property | Type | Default | Description |
| -------- | ---- | ------- | ----------- |
| orientation | 'horizontal' \| 'vertical' | 'horizontal' | Orientation of submenu list |
| defaultValue | string | '' | Value of item that should be open by default |

## Accessibility

This component implements the [WAI-ARIA Menu Button Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/menubutton/):

- Arrow key navigation between items
- Enter/Space to open menus
- Escape to close open menus
- Tab navigation to move focus between focusable elements
- Automatic ARIA attribute management

## Styling Reference

The component provides data attributes for styling:

```css
/* Basic styling example */
.NavigationMenuRoot {
  position: relative;
}

.NavigationMenuList {
  display: flex;
  list-style: none;
}

.NavigationMenuTrigger,
.NavigationMenuLink {
  padding: 8px 12px;
  color: var(--primary);
  text-decoration: none;
}

.NavigationMenuTrigger[data-state="open"] {
  background-color: var(--primary-light);
}

.NavigationMenuContent {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  animation-duration: 250ms;
  animation-timing-function: ease;
}

.NavigationMenuIndicator {
  transition: transform 250ms ease;
}

.NavigationMenuViewport {
  position: relative;
  transform-origin: top center;
}
```

## Animation

Content transitions can be animated using data attributes:

```css
@keyframes enterFromRight {
  from {
    opacity: 0;
    transform: translateX(200px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes exitToRight {
  from {
    opacity: 1;
    transform: translateX(0);
  }
  to {
    opacity: 0;
    transform: translateX(200px);
  }
}

/* Apply animations based on motion direction */
.NavigationMenuContent[data-motion="from-end"] {
  animation-name: enterFromRight;
}

.NavigationMenuContent[data-motion="to-end"] {
  animation-name: exitToRight;
}
```

</document_content>
</document>
<document index="5">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/stories/navigation-menu.stories.ts</source>
<document_content>
import { CommonModule } from '@angular/common';
import { provideAnimations } from '@angular/platform-browser/animations';
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { RdxNavigationMenuModule } from '../index';

const html = String.raw;

export default {
    title: 'Primitives/Navigation Menu',
    decorators: [
        moduleMetadata({
            imports: [
                CommonModule,
                RdxNavigationMenuModule
            ],
            providers: [provideAnimations()]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div class="story-wrapper">${story}</div>

                <style>
                    .story-wrapper {
                        font-family:
                            -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,
                            'Open Sans', 'Helvetica Neue', sans-serif;
                        padding: 50px 0;
                        min-height: 400px;
                        display: flex;
                        position: relative;
                        justify-content: center;
                        align-items: flex-start;
                        box-sizing: border-box;
                    }

                    /* reset */
                    *,
                    :after,
                    :before {
                        box-sizing: border-box;
                    }
                    button,
                    p {
                        all: unset;
                    }

                    .NavigationMenuRoot {
                        position: relative;
                        display: flex;
                        justify-content: center;
                        width: 100vw;
                        z-index: 1;
                    }

                    .NavigationMenuList {
                        display: flex;
                        justify-content: center;
                        background-color: white;
                        padding: 4px;
                        border-radius: 6px;
                        list-style: none;
                        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
                        margin: 0;
                    }

                    .NavigationMenuTrigger,
                    .NavigationMenuLink {
                        padding: 8px 12px;
                        outline: none;
                        user-select: none;
                        font-weight: 500;
                        line-height: 1;
                        border-radius: 4px;
                        font-size: 15px;
                        color: #6952a7;
                    }
                    .NavigationMenuTrigger:focus,
                    .NavigationMenuLink:focus {
                        box-shadow: 0 0 0 2px #a28fd0;
                    }
                    .NavigationMenuTrigger:hover,
                    .NavigationMenuLink:hover {
                        background-color: #f1eefc;
                    }

                    .NavigationMenuTrigger {
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        gap: 2px;
                    }

                    .NavigationMenuLink {
                        display: block;
                        text-decoration: none;
                        font-size: 15px;
                        line-height: 1;
                    }

                    .NavigationMenuContentWrapper {
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        animation-duration: 250ms;
                        animation-timing-function: ease;
                        transition:
                            opacity 250ms ease,
                            transform 250ms ease;
                    }
                    .NavigationMenuContentWrapper[data-state='closed'] {
                        opacity: 0;
                    }
                    .NavigationMenuContentWrapper[data-state='open'] {
                        opacity: 1;
                    }
                    .NavigationMenuContentWrapper[data-motion='from-start'] {
                        animation-name: enterFromLeft;
                    }
                    .NavigationMenuContentWrapper[data-motion='from-end'] {
                        animation-name: enterFromRight;
                    }
                    .NavigationMenuContentWrapper[data-motion='to-start'] {
                        animation-name: exitToLeft;
                    }
                    .NavigationMenuContentWrapper[data-motion='to-end'] {
                        animation-name: exitToRight;
                    }

                    .NavigationMenuContent {
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        animation-duration: 250ms;
                        animation-timing-function: ease;
                    }

                    @media only screen and (min-width: 600px) {
                        .NavigationMenuContent {
                            width: auto;
                        }
                    }

                    .NavigationMenuIndicator {
                        display: flex;
                        align-items: flex-end;
                        justify-content: center;
                        height: 10px;
                        top: 100%;
                        overflow: hidden;
                        z-index: 1;
                        transition:
                            width,
                            transform 250ms ease;
                    }
                    .NavigationMenuIndicator[data-state='visible'] {
                        animation: fadeIn 200ms ease;
                    }
                    .NavigationMenuIndicator[data-state='hidden'] {
                        animation: fadeOut 200ms ease;
                    }

                    .NavigationMenuViewport {
                        position: relative;
                        transform-origin: top center;
                        margin-top: 10px;
                        width: 100%;
                        background-color: white;
                        border-radius: 6px;
                        overflow: hidden;
                        box-shadow:
                            0px 10px 38px -10px rgba(22, 23, 24, 0.35),
                            0px 10px 20px -15px rgba(22, 23, 24, 0.2);
                        height: var(--radix-navigation-menu-viewport-height);
                        transition:
                            width 300ms ease,
                            height 300ms ease,
                            opacity 200ms ease-out;
                        opacity: 1;
                    }
                    .NavigationMenuViewport[data-state='open'] {
                        opacity: 1;
                        animation: scaleIn 200ms ease;
                    }
                    .NavigationMenuViewport[data-state='closed'] {
                        opacity: 0;
                        animation: scaleOut 200ms ease;
                    }
                    @media only screen and (min-width: 600px) {
                        .NavigationMenuViewport {
                            width: var(--radix-navigation-menu-viewport-width);
                        }
                    }

                    .List {
                        display: grid;
                        padding: 22px;
                        margin: 0;
                        column-gap: 10px;
                        list-style: none;
                    }
                    @media only screen and (min-width: 600px) {
                        .List.one {
                            width: 500px;
                            grid-template-columns: 0.75fr 1fr;
                        }
                        .List.two {
                            width: 600px;
                            grid-auto-flow: column;
                            grid-template-rows: repeat(3, 1fr);
                        }
                    }

                    .ListItemLink {
                        display: block;
                        outline: none;
                        text-decoration: none;
                        user-select: none;
                        padding: 12px;
                        border-radius: 6px;
                        font-size: 15px;
                        line-height: 1;
                    }
                    .ListItemLink:focus {
                        box-shadow: 0 0 0 2px #9574db;
                    }
                    .ListItemLink:hover {
                        background-color: #f5f3ff;
                    }

                    .ListItemHeading {
                        font-weight: 500;
                        line-height: 1.2;
                        margin-bottom: 5px;
                        color: #1e085a;
                    }

                    .ListItemText {
                        color: #696096;
                        line-height: 1.4;
                        font-weight: initial;
                    }

                    .Callout {
                        display: flex;
                        justify-content: flex-end;
                        flex-direction: column;
                        width: 100%;
                        height: 100%;
                        background: linear-gradient(135deg, #8257e6 0%, #4120a9 100%);
                        border-radius: 6px;
                        padding: 25px;
                        text-decoration: none;
                        outline: none;
                        user-select: none;
                    }
                    .Callout:focus {
                        box-shadow: 0 0 0 2px #9574db;
                    }

                    .CalloutHeading {
                        color: white;
                        font-size: 18px;
                        font-weight: 500;
                        line-height: 1.2;
                        margin-top: 16px;
                        margin-bottom: 7px;
                    }

                    .CalloutText {
                        color: #e4e2e4;
                        font-size: 14px;
                        line-height: 1.3;
                    }

                    .ViewportPosition {
                        position: absolute;
                        display: flex;
                        justify-content: center;
                        width: 100%;
                        top: 100%;
                        left: 0;
                        perspective: 2000px;
                    }

                    .CaretDown {
                        position: relative;
                        color: #7952c7;
                        top: 1px;
                        transition: transform 250ms ease;
                    }

                    [data-state='open'] > .CaretDown {
                        transform: rotate(-180deg);
                    }

                    .Arrow {
                        position: relative;
                        top: 70%;
                        background-color: white;
                        width: 10px;
                        height: 10px;
                        transform: rotate(45deg);
                        border-top-left-radius: 2px;
                    }

                    @keyframes enterFromRight {
                        from {
                            opacity: 0;
                            transform: translateX(200px);
                        }
                        to {
                            opacity: 1;
                            transform: translateX(0);
                        }
                    }

                    @keyframes enterFromLeft {
                        from {
                            opacity: 0;
                            transform: translateX(-200px);
                        }
                        to {
                            opacity: 1;
                            transform: translateX(0);
                        }
                    }

                    @keyframes exitToRight {
                        from {
                            opacity: 1;
                            transform: translateX(0);
                        }
                        to {
                            opacity: 0;
                            transform: translateX(200px);
                        }
                    }

                    @keyframes exitToLeft {
                        from {
                            opacity: 1;
                            transform: translateX(0);
                        }
                        to {
                            opacity: 0;
                            transform: translateX(-200px);
                        }
                    }

                    @keyframes scaleIn {
                        from {
                            opacity: 0;
                            transform: rotateX(-30deg) scale(0.9);
                        }
                        to {
                            opacity: 1;
                            transform: rotateX(0deg) scale(1);
                        }
                    }

                    @keyframes scaleOut {
                        from {
                            opacity: 1;
                            transform: rotateX(0deg) scale(1);
                        }
                        to {
                            opacity: 0;
                            transform: rotateX(-10deg) scale(0.95);
                        }
                    }

                    @keyframes fadeIn {
                        from {
                            opacity: 0;
                        }
                        to {
                            opacity: 1;
                        }
                    }

                    @keyframes fadeOut {
                        from {
                            opacity: 1;
                        }
                        to {
                            opacity: 0;
                        }
                    }
                </style>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: html`
            <nav class="NavigationMenuRoot" rdxNavigationMenu>
                <ul class="NavigationMenuList" rdxNavigationMenuList>
                    <li class="NavigationMenuItem" rdxNavigationMenuItem value="learn">
                        <button class="NavigationMenuTrigger" rdxNavigationMenuTrigger>
                            Learn
                            <svg
                                class="CaretDown"
                                width="15"
                                height="15"
                                viewBox="0 0 15 15"
                                fill="none"
                                xmlns="http://www.w3.org/2000/svg"
                                aria-hidden="true"
                            >
                                <path
                                    d="M4.18179 6.18181C4.35753 6.00608 4.64245 6.00608 4.81819 6.18181L7.49999 8.86362L10.1818 6.18181C10.3575 6.00608 10.6424 6.00608 10.8182 6.18181C10.9939 6.35755 10.9939 6.64247 10.8182 6.81821L7.81819 9.81821C7.73379 9.9026 7.61934 9.95001 7.49999 9.95001C7.38064 9.95001 7.26618 9.9026 7.18179 9.81821L4.18179 6.81821C4.00605 6.64247 4.00605 6.35755 4.18179 6.18181Z"
                                    fill="currentColor"
                                    fill-rule="evenodd"
                                    clip-rule="evenodd"
                                ></path>
                            </svg>
                        </button>

                        <div class="NavigationMenuContent" *rdxNavigationMenuContent>
                            <ul class="List one">
                                <li style="grid-row: span 3;">
                                    <a class="Callout" href="https://www.radix-ng.com/">
                                        <svg width="38" height="38" viewBox="0 0 24 24" fill="white">
                                            <path
                                                fill-rule="evenodd"
                                                clip-rule="evenodd"
                                                d="M11.576 2.00343L3 6.28335L3.02794 16.4367L3.02533 16.4391L3.02794 16.4379L3.02795 16.4408L3.03419 16.4352C5.58784 15.3254 7.85549 13.3817 9.4478 10.6971L9.45551 10.6902L9.45806 10.6798C11.047 7.99289 11.7245 4.96369 11.5773 2.01016L11.5794 2.00173L11.577 2.00294L11.5768 2L11.576 2.00343ZM12.424 2.00343L21 6.28335L20.9721 16.4367L20.9747 16.4391L20.9721 16.4379L20.972 16.4408L20.9658 16.4352C18.4122 15.3254 16.1445 13.3817 14.5522 10.6971L14.5445 10.6902L14.5419 10.6798C12.953 7.99289 12.2755 4.96369 12.4227 2.01016L12.4206 2.00173L12.423 2.00294L12.4232 2L12.424 2.00343ZM12.0978 22.25L3.79429 17.3315L3.79085 17.3325L3.79328 17.3309L3.79085 17.3295L3.79922 17.327C6.13674 15.7832 8.99744 14.8743 12.0874 14.8723L12.0978 14.8692L12.1082 14.8723C15.1981 14.8743 18.0588 15.7832 20.3963 17.327L20.4048 17.3295L20.4023 17.3309L20.4047 17.3325L20.4013 17.3315L12.0978 22.25Z"
                                            ></path>
                                        </svg>
                                        <div class="CalloutHeading">Radix Primitives</div>
                                        <p class="CalloutText">Unstyled, accessible components for Angular.</p>
                                    </a>
                                </li>

                                <li>
                                    <a
                                        class="ListItemLink"
                                        href="https://www.radix-ng.com/themes/overview/getting-started"
                                    >
                                        <div class="ListItemHeading">Themes</div>
                                        <p class="ListItemText">
                                            Pre-styled component library designed to work out of the box.
                                        </p>
                                    </a>
                                </li>
                                <li>
                                    <a class="ListItemLink" href="/colors">
                                        <div class="ListItemHeading">Colors</div>
                                        <p class="ListItemText">Beautiful, thought-out palettes with auto dark mode.</p>
                                    </a>
                                </li>
                                <li>
                                    <a class="ListItemLink" href="https://icons.radix-ui.com/">
                                        <div class="ListItemHeading">Icons</div>
                                        <p class="ListItemText">A crisp set of 15x15 icons, balanced and consistent.</p>
                                    </a>
                                </li>
                            </ul>
                        </div>
                    </li>

                    <li class="NavigationMenuItem" rdxNavigationMenuItem value="overview">
                        <button class="NavigationMenuTrigger" rdxNavigationMenuTrigger>
                            Overview
                            <svg
                                class="CaretDown"
                                width="15"
                                height="15"
                                viewBox="0 0 15 15"
                                fill="none"
                                xmlns="http://www.w3.org/2000/svg"
                                aria-hidden="true"
                            >
                                <path
                                    d="M4.18179 6.18181C4.35753 6.00608 4.64245 6.00608 4.81819 6.18181L7.49999 8.86362L10.1818 6.18181C10.3575 6.00608 10.6424 6.00608 10.8182 6.18181C10.9939 6.35755 10.9939 6.64247 10.8182 6.81821L7.81819 9.81821C7.73379 9.9026 7.61934 9.95001 7.49999 9.95001C7.38064 9.95001 7.26618 9.9026 7.18179 9.81821L4.18179 6.81821C4.00605 6.64247 4.00605 6.35755 4.18179 6.18181Z"
                                    fill="currentColor"
                                    fill-rule="evenodd"
                                    clip-rule="evenodd"
                                ></path>
                            </svg>
                        </button>

                        <div class="NavigationMenuContent" *rdxNavigationMenuContent>
                            <ul class="List two">
                                <li>
                                    <a
                                        class="ListItemLink"
                                        href="https://www.radix-ng.com/primitives/overview/introduction"
                                    >
                                        <div class="ListItemHeading">Introduction</div>
                                        <p class="ListItemText">
                                            Build high-quality, accessible design systems and web apps.
                                        </p>
                                    </a>
                                </li>
                                <li>
                                    <a
                                        class="ListItemLink"
                                        href="https://www.radix-ng.com/primitives/overview/getting-started"
                                    >
                                        <div class="ListItemHeading">Getting started</div>
                                        <p class="ListItemText">
                                            A quick tutorial to get you up and running with Radix Primitives.
                                        </p>
                                    </a>
                                </li>
                                <li>
                                    <a class="ListItemLink" href="https://www.radix-ng.com/primitives/overview/styling">
                                        <div class="ListItemHeading">Styling</div>
                                        <p class="ListItemText">Unstyled and compatible with any styling solution.</p>
                                    </a>
                                </li>
                                <li>
                                    <a
                                        class="ListItemLink"
                                        href="https://www.radix-ng.com/primitives/overview/accessibility"
                                    >
                                        <div class="ListItemHeading">Accessibility</div>
                                        <p class="ListItemText">
                                            Tested in a range of browsers and assistive technologies.
                                        </p>
                                    </a>
                                </li>
                                <li>
                                    <a
                                        class="ListItemLink"
                                        href="https://www.radix-ng.com/primitives/overview/contribute"
                                    >
                                        <div class="ListItemHeading">Contribute</div>
                                        <p class="ListItemText">Contribute to the open source project on GitHub.</p>
                                    </a>
                                </li>
                                <li>
                                    <a class="ListItemLink" href="https://github.com/radix-ng/primitives/releases">
                                        <div class="ListItemHeading">Releases</div>
                                        <p class="ListItemText">Radix Primitives releases and their changelogs.</p>
                                    </a>
                                </li>
                            </ul>
                        </div>
                    </li>

                    <li class="NavigationMenuItem" rdxNavigationMenuItem>
                        <a class="NavigationMenuLink" rdxNavigationMenuLink href="https://github.com/radix-ui">
                            Github
                        </a>
                    </li>

                    <div class="NavigationMenuIndicator" rdxNavigationMenuIndicator>
                        <div class="Arrow"></div>
                    </div>
                </ul>

                <div class="ViewportPosition">
                    <div class="NavigationMenuViewport" rdxNavigationMenuViewport></div>
                </div>
            </nav>
        `
    })
};

</document_content>
</document>
<document index="6">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu-a11y.component.ts</source>
<document_content>
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { RdxVisuallyHiddenDirective } from '@radix-ng/primitives/visually-hidden';

@Component({
    selector: 'rdx-navigation-menu-focus-proxy',
    template: `
        <span
            [attr.tabindex]="0"
            [attr.aria-hidden]="true"
            (focus)="onFocus($event)"
            rdxVisuallyHidden
            feature="focusable"
        ></span>
    `,
    imports: [RdxVisuallyHiddenDirective]
})
export class RdxNavigationMenuFocusProxyComponent {
    @Input() triggerElement: HTMLElement | null = null;
    @Input() contentElement: HTMLElement | null = null;
    @Output() proxyFocus = new EventEmitter<'start' | 'end'>();

    onFocus(event: FocusEvent): void {
        const prevFocusedElement = event.relatedTarget as HTMLElement | null;
        const wasTriggerFocused = prevFocusedElement === this.triggerElement;
        const wasFocusFromContent = this.contentElement ? this.contentElement.contains(prevFocusedElement) : false;

        if (wasTriggerFocused || !wasFocusFromContent) {
            this.proxyFocus.emit(wasTriggerFocused ? 'start' : 'end');
        }
    }
}

@Component({
    selector: 'rdx-navigation-menu-aria-owns',
    template: `
        <span [attr.aria-owns]="contentId" rdxVisuallyHidden feature="fully-hidden"></span>
    `,
    imports: [RdxVisuallyHiddenDirective]
})
export class RdxNavigationMenuAriaOwnsComponent {
    @Input() contentId: string = '';
}

</document_content>
</document>
<document index="7">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu-content.directive.ts</source>
<document_content>
import {
    booleanAttribute,
    Directive,
    ElementRef,
    inject,
    Input,
    input,
    NgZone,
    OnDestroy,
    OnInit,
    TemplateRef
} from '@angular/core';
import { ESCAPE, injectDocument } from '@radix-ng/primitives/core';
import { RdxNavigationMenuItemDirective } from './navigation-menu-item.directive';
import { injectNavigationMenu, isRootNavigationMenu } from './navigation-menu.token';
import { getMotionAttribute, makeContentId, makeTriggerId } from './utils';

@Directive({
    selector: '[rdxNavigationMenuContent]'
})
export class RdxNavigationMenuContentDirective implements OnInit, OnDestroy {
    private readonly elementRef = inject(ElementRef);
    private readonly ngZone = inject(NgZone);
    private readonly template = inject(TemplateRef);
    private readonly document = injectDocument();
    private readonly item = inject(RdxNavigationMenuItemDirective);
    private readonly context = injectNavigationMenu();

    @Input({ transform: booleanAttribute })
    set rdxNavigationMenuContent(value: boolean) {
        // structural directive requires this input even if unused
    }

    /**
     * Used to keep the content rendered and available in the DOM, even when closed.
     * Useful for animations or SEO.
     * @default false
     */
    readonly forceMount = input(false, { transform: booleanAttribute });

    /** @ignore */
    readonly contentId = makeContentId(this.context.baseId, this.item.value());
    /** @ignore */
    readonly triggerId = makeTriggerId(this.context.baseId, this.item.value());

    private escapeHandler: ((e: KeyboardEvent) => void) | null = null;

    /** @ignore */
    ngOnInit() {
        this.item.contentRef.set(this.elementRef.nativeElement);

        // register template with viewport in root menu via context
        if (isRootNavigationMenu(this.context) && this.context.onViewportContentChange) {
            this.context.onViewportContentChange(this.item.value(), {
                ref: this.elementRef,
                templateRef: this.template,
                forceMount: this.forceMount(),
                value: this.item.value(),
                getMotionAttribute: this.getMotionAttribute.bind(this),
                additionalAttrs: {
                    id: this.contentId,
                    'aria-labelledby': this.triggerId,
                    role: 'menu'
                }
            });
        }

        // add Escape key handler
        this.escapeHandler = (event: KeyboardEvent) => {
            if (event.key === ESCAPE && this.context.value() === this.item.value()) {
                // mark that this close was triggered by Escape
                this.item.wasEscapeCloseRef.set(true);

                // close the content
                if (this.context.onItemDismiss) {
                    this.context.onItemDismiss();
                }

                // refocus the trigger
                setTimeout(() => {
                    const trigger = this.item.triggerRef();
                    if (trigger) trigger.focus();
                }, 0);

                event.preventDefault();
                event.stopPropagation();
            }
        };

        this.ngZone.runOutsideAngular(() => {
            if (this.escapeHandler) {
                this.document.addEventListener('keydown', this.escapeHandler);
            }
        });
    }

    /** @ignore */
    ngOnDestroy() {
        // unregister from viewport
        if (isRootNavigationMenu(this.context) && this.context.onViewportContentRemove) {
            this.context.onViewportContentRemove(this.item.value());
        }

        // remove escape key handler
        if (this.escapeHandler) {
            this.document.removeEventListener('keydown', this.escapeHandler);
            this.escapeHandler = null;
        }
    }

    /** @ignore - Compute motion attribute for animations */
    getMotionAttribute(): string | null {
        if (!isRootNavigationMenu(this.context)) return null;

        const itemValues = Array.from(this.context.viewportContent?.() ?? new Map()).map(([value]) => value);

        return getMotionAttribute(
            this.context.value(),
            this.context.previousValue(),
            this.item.value(),
            itemValues,
            this.context.dir
        );
    }
}

</document_content>
</document>
<document index="8">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu-indicator.directive.ts</source>
<document_content>
import {
    booleanAttribute,
    computed,
    Directive,
    effect,
    ElementRef,
    inject,
    input,
    OnDestroy,
    Renderer2,
    runInInjectionContext,
    signal,
    untracked
} from '@angular/core';
import { injectNavigationMenu, isRootNavigationMenu } from './navigation-menu.token';

@Directive({
    selector: '[rdxNavigationMenuIndicator]',
    host: {
        '[attr.data-state]': 'isVisible() ? "visible" : "hidden"',
        '[attr.data-orientation]': 'context.orientation',
        '[style.display]': 'isVisible() ? null : "none"',
        'aria-hidden': 'true'
    }
})
export class RdxNavigationMenuIndicatorDirective implements OnDestroy {
    private readonly context = injectNavigationMenu();
    private readonly elementRef = inject(ElementRef);
    private readonly renderer = inject(Renderer2);

    /**
     * Used to keep the indicator rendered and available in the DOM, even when hidden.
     * Useful for animations.
     * @default false
     */
    readonly forceMount = input(false, { transform: booleanAttribute });

    /** @ignore */
    private readonly _position = signal<{ size: number; offset: number } | null>(null);
    /** @ignore */
    private readonly _activeTrigger = signal<HTMLElement | null>(null);
    /** @ignore */
    private readonly _resizeObserver = new ResizeObserver(() => this.updatePosition());

    readonly isVisible = computed(() => Boolean(this.context.value() || this.forceMount()));

    constructor() {
        // set up effect for tracking active trigger and position
        effect(() => {
            // this effect runs when the current value changes
            const value = this.context.value();

            untracked(() => {
                if (value && isRootNavigationMenu(this.context)) {
                    this.findAndSetActiveTrigger();
                }
            });
        });

        // initialize observers for position tracking
        runInInjectionContext(this.context as any, () => {
            if (isRootNavigationMenu(this.context) && this.context.indicatorTrack) {
                const track = this.context.indicatorTrack();
                if (track) {
                    // observe size changes on the track
                    this._resizeObserver.observe(track);
                }

                // initial position update if menu is open
                if (this.context.value()) {
                    setTimeout(() => this.findAndSetActiveTrigger(), 0);
                }
            }
        });
    }

    /** @ignore */
    ngOnDestroy() {
        this._resizeObserver.disconnect();
    }

    /** @ignore */
    private findAndSetActiveTrigger(): void {
        if (!isRootNavigationMenu(this.context) || !this.context.indicatorTrack) return;

        const track = this.context.indicatorTrack();
        if (!track) return;

        // find all triggers within the track
        const triggers = Array.from(track.querySelectorAll('[rdxNavigationMenuTrigger]')) as HTMLElement[];

        // find the active trigger based on the current menu value
        const activeTrigger = triggers.find((trigger) => {
            const item = trigger.closest('[rdxNavigationMenuItem]');
            if (!item) return false;

            const value = item.getAttribute('value');
            return value === this.context.value();
        });

        if (activeTrigger && activeTrigger !== this._activeTrigger()) {
            this._activeTrigger.set(activeTrigger);
            this.updatePosition();
        }
    }

    /** @ignore */
    private updatePosition(): void {
        const trigger = this._activeTrigger();
        if (!trigger) return;

        const isHorizontal = this.context.orientation === 'horizontal';

        // calculate new position
        const newPosition = {
            size: isHorizontal ? trigger.offsetWidth : trigger.offsetHeight,
            offset: isHorizontal ? trigger.offsetLeft : trigger.offsetTop
        };

        // only update if position has changed
        if (JSON.stringify(newPosition) !== JSON.stringify(this._position())) {
            this._position.set(newPosition);

            // apply position styles
            const styles = isHorizontal
                ? {
                      position: 'absolute',
                      left: '0',
                      width: `${newPosition.size}px`,
                      transform: `translateX(${newPosition.offset}px)`
                  }
                : {
                      position: 'absolute',
                      top: '0',
                      height: `${newPosition.size}px`,
                      transform: `translateY(${newPosition.offset}px)`
                  };

            Object.entries(styles).forEach(([key, value]) => {
                this.renderer.setStyle(this.elementRef.nativeElement, key, value);
            });
        }
    }
}

</document_content>
</document>
<document index="9">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu-item.directive.ts</source>
<document_content>
import { FocusableOption } from '@angular/cdk/a11y';
import { contentChild, Directive, ElementRef, inject, input, Signal, signal } from '@angular/core';
import { injectNavigationMenu, isRootNavigationMenu } from './navigation-menu.token';
import { RdxNavigationMenuFocusableOption } from './navigation-menu.types';
import { focusFirst, getTabbableCandidates, removeFromTabOrder } from './utils';

@Directive({
    selector: '[rdxNavigationMenuItem]',
    host: {
        '[attr.value]': 'value()'
    },
    exportAs: 'rdxNavigationMenuItem'
})
export class RdxNavigationMenuItemDirective implements FocusableOption {
    readonly elementRef = inject(ElementRef);
    private readonly context = injectNavigationMenu();

    readonly value = input('');

    /**
     * @ignore
     */
    readonly triggerOrLink = contentChild(RdxNavigationMenuFocusableOption);

    readonly triggerRef = signal<HTMLElement | null>(null);
    readonly contentRef = signal<HTMLElement | null>(null);
    readonly focusProxyRef = signal<HTMLElement | null>(null);
    readonly wasEscapeCloseRef = signal(false);

    private readonly _restoreContentTabOrderRef = signal<(() => void) | null>(null);

    get restoreContentTabOrderRef(): Signal<(() => void) | null> {
        return this._restoreContentTabOrderRef;
    }

    /**
     * Handle keyboard entry into content from trigger
     */
    onEntryKeyDown() {
        // Check if we're using a viewport in a root menu
        if (isRootNavigationMenu(this.context) && this.context.viewport && this.context.viewport()) {
            const viewport = this.context.viewport();
            if (viewport) {
                // find tabbable elements in the viewport
                const candidates = getTabbableCandidates(viewport);
                if (candidates.length) {
                    this.ensureTabOrder();

                    // focus the first element
                    focusFirst(candidates);
                    return;
                }
            }
        }

        // fallback to content if no viewport or no tabbable elements in viewport
        if (this.contentRef()) {
            // restore tab order if needed
            const restoreFn = this._restoreContentTabOrderRef();
            if (restoreFn) restoreFn();

            // find and focus first tabbable element
            const candidates = getTabbableCandidates(this.contentRef()!);
            if (candidates.length) {
                focusFirst(candidates);
            }
        }
    }

    focus(): void {
        this.triggerOrLink()?.focus();
    }

    /**
     * Ensure elements are in the tab order by restoring any previously removed tabindex values
     */
    private ensureTabOrder(): void {
        const restoreFn = this._restoreContentTabOrderRef();
        if (restoreFn) {
            restoreFn();
            this._restoreContentTabOrderRef.set(null);
        }
    }

    /**
     * Handle focus coming from the focus proxy element
     * @param side Which side the focus is coming from (start = from trigger, end = from after content)
     */
    onFocusProxyEnter(side: 'start' | 'end' = 'start') {
        // check for viewport first
        if (isRootNavigationMenu(this.context) && this.context.viewport && this.context.viewport()) {
            const viewport = this.context.viewport();
            if (viewport) {
                const candidates = getTabbableCandidates(viewport);
                if (candidates.length) {
                    this.ensureTabOrder();

                    // focus first or last element depending on direction
                    focusFirst(side === 'start' ? candidates : [...candidates].reverse());
                    return;
                }
            }
        }

        // fallback to content
        if (this.contentRef()) {
            // restore tab order if needed
            const restoreFn = this._restoreContentTabOrderRef();
            if (restoreFn) restoreFn();

            // find and focus appropriate element based on direction
            const candidates = getTabbableCandidates(this.contentRef()!);
            if (candidates.length) {
                // Focus first or last element depending on which direction we're coming from
                focusFirst(side === 'start' ? candidates : [...candidates].reverse());
            }
        }
    }

    /**
     * Handle focus moving outside of the content
     * Remove elements from tab order when not focused
     */
    onContentFocusOutside() {
        // get all tabbable elements from both viewport and content
        let allCandidates: HTMLElement[] = [];

        // check viewport first
        if (isRootNavigationMenu(this.context) && this.context.viewport && this.context.viewport()) {
            const viewport = this.context.viewport();
            if (viewport) {
                allCandidates = getTabbableCandidates(viewport);
            }
        }

        // ... also check direct content
        if (this.contentRef()) {
            const contentCandidates = getTabbableCandidates(this.contentRef()!);
            allCandidates = [...allCandidates, ...contentCandidates];
        }

        // remove from tab order and store restore function
        if (allCandidates.length) {
            this._restoreContentTabOrderRef.set(removeFromTabOrder(allCandidates));
        }
    }

    /**
     * Handle content being closed from root menu
     */
    onRootContentClose() {
        this.onContentFocusOutside();
    }
}

</document_content>
</document>
<document index="10">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu-link.directive.ts</source>
<document_content>
import { booleanAttribute, Directive, ElementRef, inject, input, OnInit } from '@angular/core';
import { ENTER, SPACE } from '@radix-ng/primitives/core';
import { RdxRovingFocusItemDirective } from '@radix-ng/primitives/roving-focus';
import { RdxNavigationMenuFocusableOption } from './navigation-menu.types';
import { generateId } from './utils';

const LINK_SELECT = 'navigationMenu.linkSelect';
const ROOT_CONTENT_DISMISS = 'navigationMenu.rootContentDismiss';

@Directive({
    selector: '[rdxNavigationMenuLink]',
    hostDirectives: [{ directive: RdxRovingFocusItemDirective, inputs: ['focusable'] }],
    host: {
        '[attr.data-active]': 'active() ? "" : undefined',
        '[attr.aria-current]': 'active() ? "page" : undefined',
        '(click)': 'onClick($event)',
        '(keydown)': 'onKeydown($event)'
    },
    providers: [{ provide: RdxNavigationMenuFocusableOption, useExisting: RdxNavigationMenuLinkDirective }]
})
export class RdxNavigationMenuLinkDirective extends RdxNavigationMenuFocusableOption implements OnInit {
    private readonly rovingFocusItem = inject(RdxRovingFocusItemDirective, { self: true });
    private readonly uniqueId = generateId();
    readonly active = input(false, { transform: booleanAttribute });
    readonly onSelect = input<(event: Event) => void>();
    readonly elementRef = inject(ElementRef);

    ngOnInit(): void {
        this.rovingFocusItem.tabStopId = this.elementRef.nativeElement.id || `link-${this.uniqueId}`;
    }

    override focus(): void {
        this.elementRef.nativeElement.focus();
    }

    onClick(event: MouseEvent) {
        const target = event.target as HTMLElement;

        // dispatch link select event
        const linkSelectEvent = new CustomEvent(LINK_SELECT, {
            bubbles: true,
            cancelable: true
        });

        // add one-time listener for onSelect handler
        const onSelect = this.onSelect();
        if (onSelect) {
            target.addEventListener(LINK_SELECT, onSelect, { once: true });
        }

        // dispatch event
        target.dispatchEvent(linkSelectEvent);

        // if not prevented and not meta key, dismiss content
        if (!linkSelectEvent.defaultPrevented && !event.metaKey) {
            const dismissEvent = new CustomEvent(ROOT_CONTENT_DISMISS, {
                bubbles: true,
                cancelable: true
            });
            target.dispatchEvent(dismissEvent);
        }
    }

    onKeydown(event: KeyboardEvent): void {
        // activate link on Enter or Space
        if (event.key === ENTER || event.key === SPACE) {
            // prevent default behavior like scrolling (Space) or form submission (Enter) BEFORE simulating the click.
            event.preventDefault();

            // simulate a click event on the link element itself
            const clickEvent = new MouseEvent('click', { bubbles: true, cancelable: true });
            this.elementRef.nativeElement.dispatchEvent(clickEvent);

            return;
        }
    }
}

</document_content>
</document>
<document index="11">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu-list.directive.ts</source>
<document_content>
import { FocusKeyManager } from '@angular/cdk/a11y';
import {
    AfterContentInit,
    AfterViewInit,
    contentChildren,
    Directive,
    ElementRef,
    forwardRef,
    inject,
    Renderer2
} from '@angular/core';
import { TAB } from '@radix-ng/primitives/core';
import { RdxRovingFocusGroupDirective } from '@radix-ng/primitives/roving-focus'; // Import Roving Focus Group
import { RdxNavigationMenuItemDirective } from './navigation-menu-item.directive';
import { injectNavigationMenu, isRootNavigationMenu } from './navigation-menu.token';

@Directive({
    selector: '[rdxNavigationMenuList]',
    hostDirectives: [RdxRovingFocusGroupDirective],
    host: {
        role: 'menubar',
        '(keydown)': 'onKeydown($event)'
    }
})
export class RdxNavigationMenuListDirective implements AfterContentInit, AfterViewInit {
    private readonly context = injectNavigationMenu();
    private readonly elementRef = inject(ElementRef<HTMLElement>);
    private readonly renderer = inject(Renderer2);
    private readonly rovingFocusGroup = inject(RdxRovingFocusGroupDirective, { self: true });

    /**
     * @private
     * @ignore
     */
    readonly items = contentChildren(
        forwardRef(() => RdxNavigationMenuItemDirective),
        { descendants: true }
    );

    /**
     * @ignore
     */
    protected keyManager: FocusKeyManager<RdxNavigationMenuItemDirective>;

    /**
     * @ignore
     */
    ngAfterContentInit(): void {
        const items = this.items();
        this.keyManager = new FocusKeyManager(items);

        if (this.context.orientation === 'horizontal') {
            this.keyManager.withHorizontalOrientation(this.context.dir || 'ltr');
        } else {
            this.keyManager.withVerticalOrientation();
        }
    }

    /**
     * @ignore
     */
    ngAfterViewInit() {
        this.rovingFocusGroup.orientation = this.context.orientation;
        this.rovingFocusGroup.dir = this.context.dir;

        // looping typically only applies to the root menu bar
        if (isRootNavigationMenu(this.context)) {
            this.rovingFocusGroup.loop = this.context.loop ?? false;
        } else {
            this.rovingFocusGroup.loop = false;
        }

        if (isRootNavigationMenu(this.context) && this.context.onIndicatorTrackChange) {
            const listElement = this.elementRef.nativeElement;
            const parent = listElement.parentNode;

            // ensure parent exists and list hasn't already been wrapped
            if (parent && !listElement.parentElement?.hasAttribute('data-radix-navigation-menu-list-wrapper')) {
                // create a wrapper div with relative positioning
                const wrapper = this.renderer.createElement('div');
                this.renderer.setAttribute(wrapper, 'data-radix-navigation-menu-list-wrapper', ''); // Add marker
                this.renderer.setStyle(wrapper, 'position', 'relative');

                // insert the wrapper before the list element in the parent
                this.renderer.insertBefore(parent, wrapper, listElement);

                // move the list element inside the new wrapper
                this.renderer.appendChild(wrapper, listElement);

                // register the wrapper element as the track for the indicator positioning
                this.context.onIndicatorTrackChange(wrapper);
            } else if (listElement.parentElement?.hasAttribute('data-radix-navigation-menu-list-wrapper')) {
                // if wrapper somehow already exists, ensure context has the correct reference
                this.context.onIndicatorTrackChange(listElement.parentElement);
            }
        }
    }

    /**
     * @ignore
     */
    onKeydown(event: KeyboardEvent) {
        if (!this.keyManager.activeItem) {
            this.keyManager.setFirstItemActive();
        }

        if (event.key === TAB && event.shiftKey) {
            if (this.keyManager.activeItemIndex === 0) return;
            this.keyManager.setPreviousItemActive();
            event.preventDefault();
        } else if (event.key === TAB) {
            const items = this.items();
            if (this.keyManager.activeItemIndex === items.length - 1) {
                return;
            }
            this.keyManager.setNextItemActive();
            event.preventDefault();
        } else {
            this.keyManager.onKeydown(event);
        }
    }

    /**
     * @ignore
     */
    setActiveItem(item: RdxNavigationMenuItemDirective) {
        this.keyManager.setActiveItem(item);
    }
}

</document_content>
</document>
<document index="12">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu-sub.directive.ts</source>
<document_content>
import { Directive, inject, Input, input, output, signal } from '@angular/core';
import { RdxNavigationMenuDirective } from './navigation-menu.directive';
import { provideNavigationMenuContext } from './navigation-menu.token';
import { generateId } from './utils';

@Directive({
    selector: '[rdxNavigationMenuSub]',
    providers: [provideNavigationMenuContext(RdxNavigationMenuSubDirective)],
    host: {
        '[attr.data-orientation]': 'orientation()'
    }
})
export class RdxNavigationMenuSubDirective {
    readonly orientation = input<'horizontal' | 'vertical'>('horizontal');
    @Input() set defaultValue(val: string) {
        if (val) this.value.set(val);
    }

    readonly valueChange = output<string>();

    readonly value = signal<string>('');
    readonly previousValue = signal<string>('');
    readonly baseId = `rdx-nav-menu-sub-${generateId()}`;
    readonly isRootMenu = false;

    private readonly parent = inject(RdxNavigationMenuDirective, { optional: true });

    get dir(): 'ltr' | 'rtl' {
        if (!this.parent) {
            return 'ltr';
        }

        return this.parent.dir || 'ltr';
    }

    get rootNavigationMenu(): HTMLElement | null {
        return this.parent?.rootNavigationMenu() || null;
    }

    onTriggerEnter(itemValue: string) {
        this.setValue(itemValue);
    }

    onItemSelect(itemValue: string) {
        this.setValue(itemValue);
    }

    onItemDismiss() {
        this.setValue('');
    }

    private setValue(value: string) {
        this.previousValue.set(this.value());
        this.value.set(value);
        this.valueChange.emit(value);
    }
}

</document_content>
</document>
<document index="13">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu-trigger.directive.ts</source>
<document_content>
import {
    booleanAttribute,
    ComponentRef,
    computed,
    Directive,
    effect,
    ElementRef,
    inject,
    input,
    OnDestroy,
    OnInit,
    untracked,
    ViewContainerRef
} from '@angular/core';
import { ARROW_DOWN, ARROW_LEFT, ARROW_RIGHT, ARROW_UP, ENTER, SPACE, TAB } from '@radix-ng/primitives/core';
import { RdxRovingFocusItemDirective } from '@radix-ng/primitives/roving-focus';
import {
    RdxNavigationMenuAriaOwnsComponent,
    RdxNavigationMenuFocusProxyComponent
} from './navigation-menu-a11y.component';
import { RdxNavigationMenuItemDirective } from './navigation-menu-item.directive';
import { RdxNavigationMenuListDirective } from './navigation-menu-list.directive';
import { injectNavigationMenu, isRootNavigationMenu } from './navigation-menu.token';
import { RdxNavigationMenuFocusableOption } from './navigation-menu.types';
import { getTabbableCandidates, makeContentId, makeTriggerId } from './utils';

@Directive({
    selector: '[rdxNavigationMenuTrigger]',
    hostDirectives: [RdxRovingFocusItemDirective],
    host: {
        '[id]': 'triggerId',
        '[attr.data-state]': 'open() ? "open" : "closed"',
        '[attr.data-orientation]': 'context.orientation',
        '[attr.data-disabled]': 'disabled() ? "" : undefined',
        '[disabled]': 'disabled() ? true : null',
        '[attr.aria-expanded]': 'open()',
        '[attr.aria-controls]': 'contentId',
        '[attr.aria-haspopup]': '"menu"',
        '(pointerenter)': 'onPointerEnter()',
        '(pointermove)': 'onPointerMove($event)',
        '(pointerleave)': 'onPointerLeave($event)',
        '(click)': 'onClick()',
        '(keydown)': 'onKeydown($event)',
        type: 'button'
    },
    providers: [{ provide: RdxNavigationMenuFocusableOption, useExisting: RdxNavigationMenuTriggerDirective }]
})
export class RdxNavigationMenuTriggerDirective extends RdxNavigationMenuFocusableOption implements OnInit, OnDestroy {
    private readonly context = injectNavigationMenu();
    private readonly item = inject(RdxNavigationMenuItemDirective);
    private readonly list = inject(RdxNavigationMenuListDirective);
    private readonly rovingFocusItem = inject(RdxRovingFocusItemDirective, { self: true });
    private readonly elementRef = inject(ElementRef);
    private readonly viewContainerRef = inject(ViewContainerRef);

    readonly disabled = input(false, { transform: booleanAttribute });

    readonly triggerId = makeTriggerId(this.context.baseId, this.item.value());
    readonly contentId = makeContentId(this.context.baseId, this.item.value());
    readonly open = computed(() => {
        return this.item.value() === this.context.value();
    });

    private focusProxyRef: ComponentRef<RdxNavigationMenuFocusProxyComponent> | null = null;
    private ariaOwnsRef: ComponentRef<RdxNavigationMenuAriaOwnsComponent> | null = null;

    private hasPointerMoveOpened = false;
    private wasClickClose = false;

    constructor() {
        super();

        effect(() => {
            this.rovingFocusItem.focusable = !this.disabled();
        });

        effect(() => {
            const isOpen = this.open();

            untracked(() => {
                // handle focus proxy and aria-owns when open state changes
                if (isOpen) {
                    this.createAccessibilityComponents();
                } else {
                    this.removeAccessibilityComponents();

                    if (!this.item.wasEscapeCloseRef()) {
                        this.item.onRootContentClose();
                    }

                    this.hasPointerMoveOpened = false;
                }
            });
        });
    }

    ngOnInit() {
        this.item.triggerRef.set(this.elementRef.nativeElement);

        // configure the static part of the roving focus item directive instance
        this.rovingFocusItem.tabStopId = this.item.value();
    }

    ngOnDestroy() {
        this.removeAccessibilityComponents();
    }

    override focus() {
        this.elementRef.nativeElement.focus();
    }

    private createAccessibilityComponents(): void {
        if (this.focusProxyRef || this.ariaOwnsRef) {
            return;
        }

        // create focus proxy component
        this.focusProxyRef = this.viewContainerRef.createComponent(RdxNavigationMenuFocusProxyComponent);
        this.focusProxyRef.instance.triggerElement = this.elementRef.nativeElement;
        this.focusProxyRef.instance.contentElement = this.item.contentRef();
        this.focusProxyRef.instance.proxyFocus.subscribe((direction: 'start' | 'end') => {
            this.item.onFocusProxyEnter(direction);
        });

        // store reference in item directive
        this.item.focusProxyRef.set(this.focusProxyRef.location.nativeElement);

        // only add aria-owns component if using viewport
        if (isRootNavigationMenu(this.context) && this.context.viewport && this.context.viewport()) {
            this.ariaOwnsRef = this.viewContainerRef.createComponent(RdxNavigationMenuAriaOwnsComponent);
            this.ariaOwnsRef.instance.contentId = this.contentId;
        }
    }

    private removeAccessibilityComponents(): void {
        if (this.focusProxyRef) {
            this.focusProxyRef.destroy();
            this.focusProxyRef = null;
            this.item.focusProxyRef.set(null);
        }

        if (this.ariaOwnsRef) {
            this.ariaOwnsRef.destroy();
            this.ariaOwnsRef = null;
        }
    }

    onPointerEnter(): void {
        // ignore if disabled or not the root menu (hover logic primarily for root)
        if (this.disabled() || !isRootNavigationMenu(this.context)) return;

        this.wasClickClose = false; // Reset click close flag on enter
        this.item.wasEscapeCloseRef.set(false); // Reset escape flag
        this.context.setTriggerPointerState?.(true); // Update context state

        // if the menu isn't already open for this item, trigger the enter logic (handles delays)
        if (!this.open()) {
            this.context.onTriggerEnter?.(this.item.value());
        }
    }

    onPointerMove(event: PointerEvent): void {
        // ignore if not a mouse event, disabled, closed by click/escape, or already opened by this move
        if (
            event.pointerType !== 'mouse' ||
            this.disabled() ||
            this.wasClickClose ||
            this.item.wasEscapeCloseRef() ||
            this.hasPointerMoveOpened ||
            !isRootNavigationMenu(this.context)
        ) {
            return;
        }
        // trigger enter logic (handles delays) and mark that this move initiated an open attempt
        this.context.onTriggerEnter?.(this.item.value());
        this.hasPointerMoveOpened = true;
    }

    onPointerLeave(event: PointerEvent): void {
        // ignore if not a mouse event or disabled
        if (event.pointerType !== 'mouse' || this.disabled() || !isRootNavigationMenu(this.context)) {
            return;
        }

        this.context.setTriggerPointerState?.(false); // Update context state
        this.context.onTriggerLeave?.(); // Trigger leave logic (handles delays)
        this.hasPointerMoveOpened = false; // Reset flag

        // reset user dismissal flag if pointer leaves the whole system (trigger + content)
        if (this.context.resetUserDismissed) {
            // relay slightly to allow pointer movement to content area without resetting dismissal state
            setTimeout(() => {
                if (!this.context.isPointerInSystem?.()) {
                    this.context.resetUserDismissed?.();
                }
            }, 50); // small delay for tolerance
        }
    }

    onClick(): void {
        if (this.disabled()) return;

        // manually set the `KeyManager` active item to this trigger
        this.list.setActiveItem(this.item);

        if (this.context.onItemSelect) {
            this.context.onItemSelect(this.item.value());
            // track if this click action resulted in closing the menu
            this.wasClickClose = !this.open();
            // reset escape flag if menu was opened by click
            if (this.open()) {
                this.item.wasEscapeCloseRef.set(false);
            }
        }
    }

    onKeydown(event: KeyboardEvent): void {
        if (this.disabled()) return;

        if (event.key === ENTER || event.key === SPACE) {
            event.preventDefault(); // prevent default button behavior
            this.onClick();

            // if menu was opened by this keypress, move focus into the content
            if (this.open()) {
                // defer focus slightly to ensure content is ready
                setTimeout(() => this.item.onEntryKeyDown(), 0);
            }
            return;
        }

        const isHorizontal = this.context.orientation === 'horizontal';
        const isRTL = this.context.dir === 'rtl';

        // handle `ArrowDown` specifically for viewport navigation
        if (event.key === ARROW_DOWN || event.key === TAB) {
            if (event.key === ARROW_DOWN) {
                event.preventDefault();
            }

            // if the menu is open, focus into the content
            if (this.open()) {
                if (event.key === TAB) {
                    // needed to ensure that the `keyManager` on the list directive does not activate
                    // any focus updates, shifting focus to the subsequent focusable list item
                    event.stopImmediatePropagation();
                }

                // direct focus handling for viewport case
                if (isRootNavigationMenu(this.context) && this.context.viewport && this.context.viewport()) {
                    // get the viewport element
                    const viewport = this.context.viewport();
                    if (viewport) {
                        // find all tabbable elements in the viewport
                        const tabbables = getTabbableCandidates(viewport);
                        if (tabbables.length > 0) {
                            // focus the first tabbable element directly
                            setTimeout(() => {
                                tabbables[0].focus();
                            }, 0);
                            return;
                        }
                    }
                }

                // fallback to the standard entry key down approach
                setTimeout(() => this.item.onEntryKeyDown(), 0);
                return;
            }

            // if not open but in horizontal orientation, emulate right key navigation
            if (isHorizontal) {
                const nextEvent = new KeyboardEvent('keydown', {
                    key: isRTL ? ARROW_LEFT : ARROW_RIGHT,
                    bubbles: true
                });
                this.elementRef.nativeElement.dispatchEvent(nextEvent);
                return;
            }
        }

        // handle ArrowUp in horizontal orientation
        if (isHorizontal && event.key === ARROW_UP) {
            event.preventDefault();

            // emulate a left key press to move to the previous item
            const nextEvent = new KeyboardEvent('keydown', {
                key: isRTL ? ARROW_RIGHT : ARROW_LEFT,
                bubbles: true
            });
            this.elementRef.nativeElement.dispatchEvent(nextEvent);
            return;
        }

        // handle vertical navigation and entry into content
        const verticalEntryKey = isRTL ? ARROW_LEFT : ARROW_RIGHT;
        const entryKey = isHorizontal ? ARROW_DOWN : verticalEntryKey;

        if (this.item.contentRef() && event.key === entryKey && event.key !== ARROW_DOWN) {
            // Skip if it's ArrowDown as we already handled it above
            event.preventDefault();

            if (!this.open()) {
                // if closed, open the menu first
                this.context.onItemSelect?.(this.item.value());
                // defer focus movement into content until after state update and render
                setTimeout(() => this.item.onEntryKeyDown(), 0);
            } else {
                // if already open, just move focus into the content
                this.item.onEntryKeyDown();
            }
            return;
        }
    }
}

</document_content>
</document>
<document index="14">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu-viewport.directive.ts</source>
<document_content>
import {
    booleanAttribute,
    computed,
    DestroyRef,
    Directive,
    effect,
    ElementRef,
    EmbeddedViewRef,
    inject,
    input,
    NgZone,
    OnDestroy,
    OnInit,
    Renderer2,
    signal,
    untracked,
    ViewContainerRef
} from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { ARROW_DOWN, ARROW_UP, injectDocument, injectWindow } from '@radix-ng/primitives/core';
import { TransitionOptions, TransitionStartFn, usePresence } from '@radix-ng/primitives/presence';
import { Subscription } from 'rxjs';
import { injectNavigationMenu, isRootNavigationMenu } from './navigation-menu.token';
import { getOpenStateLabel, getTabbableCandidates } from './utils';

interface ContentNode {
    embeddedView: EmbeddedViewRef<unknown>;
    element: HTMLElement;
    contentValue: string;
    state: 'open' | 'closed';
    transitionSubscription?: Subscription | null;
}

@Directive({
    selector: '[rdxNavigationMenuViewport]',
    host: {
        '[attr.data-state]': 'dataState()',
        '[attr.data-orientation]': 'context.orientation',
        '[style.--radix-navigation-menu-viewport-width.px]': 'viewportSize()?.width',
        '[style.--radix-navigation-menu-viewport-height.px]': 'viewportSize()?.height',
        '(keydown)': 'onKeydown($event)',
        '(pointerenter)': 'onPointerEnter()',
        '(pointerleave)': 'onPointerLeave()'
    }
})
export class RdxNavigationMenuViewportDirective implements OnInit, OnDestroy {
    private readonly context = injectNavigationMenu();
    private readonly document = injectDocument();
    private readonly window = injectWindow();
    private readonly elementRef = inject(ElementRef);
    private readonly viewContainerRef = inject(ViewContainerRef);
    private readonly renderer = inject(Renderer2);
    private readonly zone = inject(NgZone);
    private readonly destroyRef = inject(DestroyRef);

    /**
     * Used to keep the viewport rendered and available in the DOM, even when closed.
     * Useful for animations.
     * @default false
     */
    readonly forceMount = input(false, { transform: booleanAttribute });

    private readonly _contentNodes = signal(new Map<string, ContentNode>());
    private readonly _activeContentNode = signal<ContentNode | null>(null);
    private readonly _leavingContentNode = signal<ContentNode | null>(null);
    private readonly _viewportSize = signal<{ width: number; height: number } | null>(null);

    readonly activeContentValue = computed(() => {
        if (!isRootNavigationMenu(this.context)) return null;
        return this.context.value() || this.context.previousValue();
    });
    readonly isOpen = computed(() => {
        if (!isRootNavigationMenu(this.context)) return false;
        return Boolean(this.context.value() || this.forceMount());
    });
    readonly dataState = computed(() => getOpenStateLabel(this.isOpen()));
    readonly viewportSize = computed(() => this._viewportSize());

    private readonly _resizeObserver = new ResizeObserver(() => this.updateSize());

    constructor() {
        this.setupViewportEffect();
    }

    ngOnInit() {
        if (isRootNavigationMenu(this.context) && this.context.onViewportChange) {
            this.context.onViewportChange(this.elementRef.nativeElement);
        }
    }

    ngOnDestroy() {
        this._resizeObserver.disconnect();
        // clean up any remaining nodes/views/subscriptions
        this._contentNodes().forEach((node) => this.cleanupAfterLeave(node));
        if (isRootNavigationMenu(this.context) && this.context.onViewportChange) {
            this.context.onViewportChange(null);
        }
    }

    onKeydown(event: KeyboardEvent): void {
        if (!this.isOpen()) return;
        const tabbableElements = getTabbableCandidates(this.elementRef.nativeElement);
        if (!tabbableElements.length) return;
        const activeElement = this.document.activeElement as HTMLElement | null;
        const currentIndex = tabbableElements.findIndex((el) => el === activeElement);

        if (event.key === ARROW_DOWN) {
            event.preventDefault();
            const nextIndex = currentIndex >= 0 && currentIndex < tabbableElements.length - 1 ? currentIndex + 1 : 0;
            tabbableElements[nextIndex]?.focus();
        } else if (event.key === ARROW_UP) {
            event.preventDefault();
            const prevIndex = currentIndex > 0 ? currentIndex - 1 : tabbableElements.length - 1;
            tabbableElements[prevIndex]?.focus();
        }
    }

    onPointerEnter(): void {
        if (isRootNavigationMenu(this.context) && this.context.onContentEnter) {
            this.context.onContentEnter();
        }
        if (isRootNavigationMenu(this.context) && this.context.setContentPointerState) {
            this.context.setContentPointerState(true);
        }
    }

    onPointerLeave(): void {
        if (isRootNavigationMenu(this.context) && this.context.onContentLeave) {
            this.context.onContentLeave();
        }
        if (isRootNavigationMenu(this.context) && this.context.setContentPointerState) {
            this.context.setContentPointerState(false);
        }
    }

    private setupViewportEffect(): void {
        effect(() => {
            const currentActiveValue = this.context.value();
            const previousActiveValue = this.context.previousValue();
            const forceMount = this.forceMount();

            untracked(() => {
                // ensure context is root before proceeding
                if (!isRootNavigationMenu(this.context) || !this.context.viewportContent) {
                    return;
                }

                const allContentData = this.context.viewportContent();
                const currentNodesMap = this._contentNodes();
                let enteringNode: ContentNode | null = null;
                let leavingNode = this._leavingContentNode(); // get potentially already leaving node

                // 1. Identify Entering Node
                if (currentActiveValue && allContentData.has(currentActiveValue)) {
                    enteringNode = this.getOrCreateContentNode(currentActiveValue);
                }

                // 2. Identify Leaving Node
                const nodeThatWasActive = previousActiveValue ? currentNodesMap.get(previousActiveValue) : null;
                // if there was a previously active node, it's different from the entering one,
                // and it's not already leaving, mark it for removal.
                if (nodeThatWasActive && nodeThatWasActive !== enteringNode && nodeThatWasActive !== leavingNode) {
                    // if another node was already leaving, force complete its transition
                    if (leavingNode) {
                        this.forceCompleteLeaveTransition(leavingNode);
                    }
                    leavingNode = nodeThatWasActive;
                    this._leavingContentNode.set(leavingNode);
                }

                // 3. Handle Entering Node
                if (enteringNode) {
                    // cancel any pending leave transition for this node if it was leaving
                    if (enteringNode === leavingNode) {
                        this.cancelLeaveTransition(enteringNode);
                        leavingNode = null;
                        this._leavingContentNode.set(null);
                    }
                    // ensure it's in the DOM and set state to open
                    this.addNodeToDOM(enteringNode);
                    this.setNodeState(enteringNode, 'open'); // Triggers enter animation via data-state
                    this._activeContentNode.set(enteringNode);
                    this.updateSize(); // Update size based on the entering node
                } else {
                    // no node entering, clear active node state
                    this._activeContentNode.set(null);
                }

                // 4. Handle Leaving Node
                if (leavingNode) {
                    if (forceMount) {
                        // if forceMount, just mark as closed, don't trigger removal animation
                        this.setNodeState(leavingNode, 'closed');
                        this._leavingContentNode.set(null); // No longer considered "leaving"
                    } else {
                        // start the leave transition (usePresence handles DOM removal)
                        this.startLeaveTransition(leavingNode);
                    }
                }
            });
        });
    }

    // gets or creates the ContentNode (wrapper + view)
    private getOrCreateContentNode(contentValue: string): ContentNode | null {
        const existingNode = this._contentNodes().get(contentValue);
        if (existingNode && !existingNode.embeddedView.destroyed) {
            return existingNode;
        }

        // create if doesn't exist or view was destroyed
        if (!isRootNavigationMenu(this.context) || !this.context.viewportContent) return null;
        const allContentData = this.context.viewportContent();
        const contentData = allContentData.get(contentValue);
        const templateRef = contentData?.templateRef;

        if (!templateRef) {
            console.error(`No templateRef found for content value: ${contentValue}`);
            return null;
        }

        try {
            const embeddedView = this.viewContainerRef.createEmbeddedView(templateRef);
            const container = this.renderer.createElement('div');
            this.renderer.setAttribute(container, 'class', 'NavigationMenuContentWrapper');
            this.renderer.setAttribute(container, 'data-content-value', contentValue);
            embeddedView.rootNodes.forEach((node: Node) => this.renderer.appendChild(container, node));

            const newNode: ContentNode = {
                embeddedView,
                element: container,
                contentValue,
                state: 'closed'
            };

            const newMap = new Map(this._contentNodes());
            newMap.set(contentValue, newNode);
            this._contentNodes.set(newMap);
            return newNode;
        } catch (error) {
            console.error(`Error creating content node for ${contentValue}:`, error);
            return null;
        }
    }

    // adds node element to viewport DOM if not already present
    private addNodeToDOM(node: ContentNode): void {
        if (!this.elementRef.nativeElement.contains(node.element)) {
            this.renderer.appendChild(this.elementRef.nativeElement, node.element);
            // observe size only when added to DOM
            this._resizeObserver.observe(node.element);
        }
    }

    // removes node element from viewport DOM
    private removeNodeFromDOM(node: ContentNode): void {
        if (this.elementRef.nativeElement.contains(node.element)) {
            this._resizeObserver.unobserve(node.element); // stop observing before removal
            this.renderer.removeChild(this.elementRef.nativeElement, node.element);
        }
    }

    // updates the data-state and motion attributes
    private setNodeState(node: ContentNode, state: 'open' | 'closed'): void {
        if (node.state === state) return; // avoid redundant updates

        node.state = state;
        this.renderer.setAttribute(node.element, 'data-state', state);

        // apply motion attribute based on context
        if (isRootNavigationMenu(this.context) && this.context.viewportContent) {
            const contentData = this.context.viewportContent().get(node.contentValue);
            if (contentData?.getMotionAttribute) {
                // get motion based on current state transition
                const motionAttr = contentData.getMotionAttribute();
                if (motionAttr) {
                    this.renderer.setAttribute(node.element, 'data-motion', motionAttr);
                } else {
                    this.renderer.removeAttribute(node.element, 'data-motion');
                }
            } else {
                this.renderer.removeAttribute(node.element, 'data-motion');
            }
        }

        // apply A11y attributes (might only be needed on open?)
        if (state === 'open') {
            this.applyA11yAttributes(node);
        }
    }

    // apply A11y attributes to the first child element
    private applyA11yAttributes(node: ContentNode): void {
        if (!isRootNavigationMenu(this.context) || !this.context.viewportContent) return;
        const contentData = this.context.viewportContent().get(node.contentValue);
        if (contentData?.additionalAttrs && node.embeddedView.rootNodes.length > 0) {
            const firstRootNode = node.embeddedView.rootNodes[0] as Element;
            if (firstRootNode) {
                Object.entries(contentData.additionalAttrs).forEach(([attr, value]) => {
                    this.renderer.setAttribute(firstRootNode, attr, value as string);
                });
            }
        }
    }

    private startLeaveTransition(node: ContentNode): void {
        // ensure node exists and isn't already leaving with an active subscription
        if (!node || node.transitionSubscription) {
            node.transitionSubscription?.unsubscribe();
            return;
        }

        const startFn: TransitionStartFn<null> = () => {
            this.setNodeState(node, 'closed');
            return () => this.cleanupAfterLeave(node);
        };

        const options: TransitionOptions<null> = {
            animation: true, // assuming CSS animations/transitions handle the exit
            state: 'continue' // start the leave process
        };

        node.transitionSubscription = usePresence(this.zone, node.element, startFn, options)
            .pipe(takeUntilDestroyed(this.destroyRef))
            .subscribe({
                complete: () => {
                    this.cleanupAfterLeave(node);
                }
            });
    }

    /**
     * Cleanup function called after leave animation finishes
     * @param node The node that is leaving
     */
    private cleanupAfterLeave(node: ContentNode): void {
        // check if this node is still marked as the one leaving
        if (this._leavingContentNode() === node) {
            this.removeNodeFromDOM(node);
            if (!this.forceMount() && node.embeddedView && !node.embeddedView.destroyed) {
                node.embeddedView.destroy();
                // Remove from cache if destroyed
                const newMap = new Map(this._contentNodes());
                newMap.delete(node.contentValue);
                this._contentNodes.set(newMap);
            }

            node.transitionSubscription = null;
            this._leavingContentNode.set(null);
        } else {
            // if this node is NOT the one currently marked as leaving, it means
            // a new transition started before this one finished. Just clean up DOM/Sub.
            this.removeNodeFromDOM(node);
            node.transitionSubscription?.unsubscribe();
            node.transitionSubscription = null;
        }
    }

    /**
     * Cancels an ongoing leave transition (e.g., if user hovers back)
     * @param node The node that is leaving
     */
    private cancelLeaveTransition(node: ContentNode): void {
        node.transitionSubscription?.unsubscribe();
        node.transitionSubscription = null;
    }

    /**
     * Force completes a leave transition (e.g., if another leave starts)
     * @param node The node that is leaving
     */
    private forceCompleteLeaveTransition(node: ContentNode): void {
        if (node && node.transitionSubscription) {
            node.transitionSubscription.unsubscribe();

            // perform cleanup immediately
            this.cleanupAfterLeave(node);
        }
    }

    private updateSize() {
        const activeNode = this._activeContentNode()?.element; // measure the currently active node
        if (!activeNode || !activeNode.isConnected) return;

        const firstChild = activeNode.firstChild as HTMLElement;
        if (!firstChild) return;

        this.window.requestAnimationFrame(() => {
            // keep rAF here for measurement stability
            activeNode.getBoundingClientRect(); // force layout
            const width = Math.ceil(firstChild.offsetWidth);
            const height = Math.ceil(firstChild.offsetHeight);

            if (width !== 0 || height !== 0) {
                const currentSize = this._viewportSize();
                if (!currentSize || currentSize.width !== width || currentSize.height !== height) {
                    this._viewportSize.set({ width, height });
                }
            } else if (this._viewportSize() !== null) {
                this._viewportSize.set(null);
            }
        });
    }
}

</document_content>
</document>
<document index="15">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu.directive.ts</source>
<document_content>
import {
    booleanAttribute,
    Directive,
    effect,
    ElementRef,
    inject,
    Input,
    numberAttribute,
    OnDestroy,
    signal,
    WritableSignal
} from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { injectDocument, injectWindow } from '@radix-ng/primitives/core';
import { debounce, map, Subject, tap, timer } from 'rxjs';
import { provideNavigationMenuContext } from './navigation-menu.token';
import { RdxNavigationMenuAnimationStatus } from './navigation-menu.types';
import { generateId } from './utils';

// define action types for clearer intent
export enum RdxNavigationMenuAction {
    OPEN = 'open',
    CLOSE = 'close'
}

@Directive({
    selector: '[rdxNavigationMenu]',
    providers: [provideNavigationMenuContext(RdxNavigationMenuDirective)],
    host: {
        '[attr.data-orientation]': 'orientation',
        '[attr.dir]': 'dir',
        'aria-label': 'Main',
        role: 'navigation'
    },
    exportAs: 'rdxNavigationMenu'
})
export class RdxNavigationMenuDirective implements OnDestroy {
    private readonly elementRef = inject(ElementRef);
    private readonly document = injectDocument();
    private readonly window = injectWindow();

    // State
    readonly #value = signal<string>('');
    readonly #previousValue = signal<string>('');
    readonly baseId = `rdx-nav-menu-${generateId()}`;
    readonly #indicatorTrack = signal<HTMLElement | null>(null);
    readonly #viewport = signal<HTMLElement | null>(null);
    readonly #viewportContent = signal<Map<string, any>>(new Map());
    readonly #rootNavigationMenu = signal<HTMLElement | null>(this.elementRef.nativeElement);

    readonly #userDismissedByClick = signal(false);
    userDismissedByClick = () => this.#userDismissedByClick();
    resetUserDismissed = () => this.#userDismissedByClick.set(false);

    // delay timers
    private openTimerRef = 0;
    private closeTimerRef = 0;
    private skipDelayTimerRef = 0;
    readonly #isOpenDelayed = signal(true);

    // pointer tracking
    readonly #isPointerOverContent = signal(false);
    readonly #isPointerOverTrigger = signal(false);
    private documentMouseLeaveHandler: ((e: Event) => void) | null = null;

    readonly actionSubject$ = new Subject<{ action: RdxNavigationMenuAction; itemValue?: string }>();

    @Input() orientation: 'horizontal' | 'vertical' = 'horizontal';
    @Input() dir: 'ltr' | 'rtl' = 'ltr';
    @Input({ transform: numberAttribute }) delayDuration = 200;
    @Input({ transform: numberAttribute }) skipDelayDuration = 300;
    @Input({ transform: booleanAttribute }) loop = false;
    @Input({ transform: booleanAttribute }) cssAnimation = false;
    @Input({ transform: booleanAttribute }) cssOpeningAnimation = false;
    @Input({ transform: booleanAttribute }) cssClosingAnimation = false;

    readonly isRootMenu = true;
    readonly cssAnimationStatus: WritableSignal<RdxNavigationMenuAnimationStatus | null> = signal(null);

    // exposed state as functions for the token
    value = () => this.#value();
    previousValue = () => this.#previousValue();
    rootNavigationMenu = () => this.#rootNavigationMenu();
    indicatorTrack = () => this.#indicatorTrack();
    viewport = () => this.#viewport();
    viewportContent = () => this.#viewportContent();

    // exposed pointer state
    setTriggerPointerState = (isOver: boolean) => this.#isPointerOverTrigger.set(isOver);
    setContentPointerState = (isOver: boolean) => this.#isPointerOverContent.set(isOver);
    isPointerInSystem = () => this.#isPointerOverContent() || this.#isPointerOverTrigger();

    // exposed  animation state
    getCssAnimation = () => this.cssAnimation;
    getCssOpeningAnimation = () => this.cssOpeningAnimation;
    getCssClosingAnimation = () => this.cssClosingAnimation;

    constructor() {
        effect(() => {
            const value = this.#value();
            if (value) {
                this.window.clearTimeout(this.skipDelayTimerRef);
                if (this.skipDelayDuration > 0) {
                    this.#isOpenDelayed.set(false);
                }
            } else {
                // menu is closed, start skip delay timer
                this.window.clearTimeout(this.skipDelayTimerRef);
                this.skipDelayTimerRef = this.window.setTimeout(() => {
                    this.#isOpenDelayed.set(true);
                }, this.skipDelayDuration);
            }
        });

        this.actionSubject$
            .pipe(
                map((config) => {
                    // different delays for open vs close (better ux)
                    const duration = config.action === RdxNavigationMenuAction.OPEN ? this.delayDuration : 150;
                    return { ...config, duration };
                }),
                debounce((config) => timer(config.duration)),
                tap((config) => {
                    switch (config.action) {
                        case RdxNavigationMenuAction.OPEN:
                            if (config.itemValue) {
                                this.setValue(config.itemValue);
                            }
                            break;
                        case RdxNavigationMenuAction.CLOSE:
                            // only close if not hovering over any part of the system
                            if (!this.isPointerInSystem()) {
                                this.setValue('');
                            }
                            break;
                    }
                }),
                takeUntilDestroyed()
            )
            .subscribe();

        // set up document mouseleave handler to close menu when mouse leaves window
        this.documentMouseLeaveHandler = () => this.handleClose();
        this.document.addEventListener('mouseleave', this.documentMouseLeaveHandler);
    }

    ngOnDestroy() {
        this.window.clearTimeout(this.openTimerRef);
        this.window.clearTimeout(this.closeTimerRef);
        this.window.clearTimeout(this.skipDelayTimerRef);

        // clean up document event listener
        if (this.documentMouseLeaveHandler) {
            document.removeEventListener('mouseleave', this.documentMouseLeaveHandler);
        }
    }

    onIndicatorTrackChange(track: HTMLElement | null) {
        this.#indicatorTrack.set(track);
    }

    onViewportChange(viewport: HTMLElement | null) {
        this.#viewport.set(viewport);
    }

    onTriggerEnter(itemValue: string) {
        // skip opening if user explicitly dismissed this menu
        if (this.#userDismissedByClick() && itemValue === this.#previousValue()) {
            return;
        }

        this.window.clearTimeout(this.openTimerRef);
        this.window.clearTimeout(this.closeTimerRef);

        if (this.#isOpenDelayed()) {
            this.handleDelayedOpen(itemValue);
        } else {
            this.handleOpen(itemValue);
        }
    }

    onTriggerLeave() {
        this.window.clearTimeout(this.openTimerRef);
        this.startCloseTimer();
    }

    onContentEnter() {
        this.window.clearTimeout(this.closeTimerRef);
    }

    onContentLeave() {
        this.startCloseTimer();
    }

    handleClose() {
        this.actionSubject$.next({ action: RdxNavigationMenuAction.CLOSE });
    }

    onItemSelect(itemValue: string) {
        const wasOpen = this.#value() === itemValue;
        const newValue = wasOpen ? '' : itemValue;

        // if user is closing an open menu, mark as user-dismissed
        if (wasOpen) {
            this.#userDismissedByClick.set(true);
        } else {
            this.#userDismissedByClick.set(false);
        }

        this.setValue(newValue);
    }

    onItemDismiss() {
        this.setValue('');
    }

    onViewportContentChange(contentValue: string, contentData: any) {
        const newMap = new Map(this.#viewportContent());
        newMap.set(contentValue, contentData);
        this.#viewportContent.set(newMap);
    }

    onViewportContentRemove(contentValue: string) {
        const newMap = new Map(this.#viewportContent());
        if (newMap.has(contentValue)) {
            newMap.delete(contentValue);
            this.#viewportContent.set(newMap);
        }
    }

    private setValue(value: string) {
        // Store previous value before changing
        this.#previousValue.set(this.#value());
        this.#value.set(value);
    }

    private startCloseTimer() {
        this.window.clearTimeout(this.closeTimerRef);
        this.closeTimerRef = this.window.setTimeout(() => {
            // only close if not hovering over any part of the system
            if (!this.isPointerInSystem()) {
                this.setValue('');
            }
        }, 150);
    }

    private handleOpen(itemValue: string) {
        this.window.clearTimeout(this.closeTimerRef);
        this.setValue(itemValue);
    }

    private handleDelayedOpen(itemValue: string) {
        const isOpenItem = this.#value() === itemValue;
        if (isOpenItem) {
            // if the item is already open, clear close timer
            this.window.clearTimeout(this.closeTimerRef);
        } else {
            // otherwise, start the open timer
            this.openTimerRef = this.window.setTimeout(() => {
                this.window.clearTimeout(this.closeTimerRef);
                this.setValue(itemValue);
            }, this.delayDuration);
        }
    }
}

</document_content>
</document>
<document index="16">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu.token.ts</source>
<document_content>
import { inject, InjectionToken, Provider, Type } from '@angular/core';
import { RdxNavigationMenuSubDirective } from './navigation-menu-sub.directive';
import { RdxNavigationMenuDirective } from './navigation-menu.directive';

export interface NavigationMenuContext {
    isRootMenu: boolean;
    value: () => string;
    previousValue: () => string;
    baseId: string;
    dir: 'ltr' | 'rtl';
    orientation: 'horizontal' | 'vertical';
    loop: boolean;
    rootNavigationMenu: () => HTMLElement | null;

    indicatorTrack?: () => HTMLElement | null;
    onIndicatorTrackChange?: (track: HTMLElement | null) => void;
    userDismissedByClick?: () => boolean;
    resetUserDismissed?: () => void;
    viewport?: () => HTMLElement | null;
    onViewportChange?: (viewport: HTMLElement | null) => void;
    viewportContent?: () => Map<string, any>;
    onViewportContentChange?: (contentValue: string, contentData: any) => void;
    onViewportContentRemove?: (contentValue: string) => void;
    onTriggerEnter?: (itemValue: string) => void;
    onTriggerLeave?: () => void;
    onContentEnter?: () => void;
    onContentLeave?: () => void;
    onItemSelect?: (itemValue: string) => void;
    onItemDismiss?: () => void;
    handleClose?: (force?: boolean) => void;
    setTriggerPointerState?: (isOver: boolean) => void;
    setContentPointerState?: (isOver: boolean) => void;
    isPointerInSystem?: () => boolean;
}

export const RDX_NAVIGATION_MENU_TOKEN = new InjectionToken<NavigationMenuContext>('RdxNavigationMenuToken');

export function injectNavigationMenu(): NavigationMenuContext {
    return inject(RDX_NAVIGATION_MENU_TOKEN);
}

export function isRootNavigationMenu(context: NavigationMenuContext): boolean {
    return context.isRootMenu;
}

export function provideNavigationMenuContext(
    provider: Type<RdxNavigationMenuDirective | RdxNavigationMenuSubDirective>
): Provider {
    return {
        provide: RDX_NAVIGATION_MENU_TOKEN,
        useExisting: provider
    };
}

</document_content>
</document>
<document index="17">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu.types.ts</source>
<document_content>
import { FocusableOption } from '@angular/cdk/a11y';

export enum RdxNavigationMenuAnimationStatus {
    OPEN_STARTED = 'open_started',
    OPEN_ENDED = 'open_ended',
    CLOSED_STARTED = 'closed_started',
    CLOSED_ENDED = 'closed_ended'
}

/**
 * A stub class solely used to query a single type of focusable element in the navigation menu.
 */
export abstract class RdxNavigationMenuFocusableOption implements FocusableOption {
    focus(): void {
        throw new Error('Method not implemented.');
    }
}

</document_content>
</document>
<document index="18">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/utils.ts</source>
<document_content>
export type NavigationMenuOrientation = 'horizontal' | 'vertical';
export type NavigationMenuDirection = 'ltr' | 'rtl';
export type MotionAttribute = 'to-start' | 'to-end' | 'from-start' | 'from-end';

export const ROOT_CONTENT_DISMISS = 'navigationMenu.rootContentDismiss';

/**
 * Generate a unique ID
 */
export function generateId(): string {
    return Math.random().toString(36).substring(2, 11);
}

/**
 * Get the open state for data-state attribute
 */
export function getOpenStateLabel(open: boolean): 'open' | 'closed' {
    return open ? 'open' : 'closed';
}

/**
 * Create a trigger ID from base ID and value
 */
export function makeTriggerId(baseId: string, value: string): string {
    return `${baseId}-trigger-${value}`;
}

/**
 * Create a content ID from base ID and value
 */
export function makeContentId(baseId: string, value: string): string {
    return `${baseId}-content-${value}`;
}

/**
 * Get the motion attribute for animations
 */
export function getMotionAttribute(
    currentValue: string | null,
    previousValue: string | null,
    itemValue: string,
    itemValues: string[],
    dir: NavigationMenuDirection
): MotionAttribute | null {
    // reverse values in RTL
    const values = dir === 'rtl' ? [...itemValues].reverse() : itemValues;

    const currentIndex = currentValue !== null ? values.indexOf(currentValue) : -1;
    const prevIndex = previousValue !== null ? values.indexOf(previousValue) : -1;

    const isSelected = itemValue === currentValue;
    const wasSelected = itemValue === previousValue && previousValue !== null;

    // Preserve motion attribute for items not directly involved in the transition
    // (This matches React's behaviour, using a ref/signal might be needed
    // in the component using this function to fully replicate React's prevMotionAttributeRef)
    // For now, returning null if not involved, as per the original code's intent here.
    if (!isSelected && !wasSelected) {
        return null;
    }

    // handle transitions between items
    if (currentIndex !== -1 && prevIndex !== -1) {
        // if moving to this item (isSelected)
        if (isSelected) {
            return currentIndex > prevIndex ? 'from-end' : 'from-start';
        }
        // if moving away from this item (wasSelected)
        if (wasSelected) {
            return currentIndex > prevIndex ? 'to-start' : 'to-end';
        }
    }

    // handle initial open (prevIndex is -1, currentIndex is valid)
    if (isSelected && prevIndex === -1) {
        return null;
    }

    // handle closing entirely (currentIndex is -1, prevIndex is valid)
    if (wasSelected && currentIndex === -1) {
        return null;
    }

    // fallback if none of the above conditions met (should ideally not happen with clear states)
    return null;
}

/**
 * Focus the first element in a list of candidates
 * @param candidates Array of elements that can receive focus
 * @param preventScroll Whether to prevent scrolling when focusing
 * @param activateKeyboardNav Whether to dispatch a dummy keydown event to activate keyboard navigation handlers
 * @returns Whether focus was successfully moved
 */
export function focusFirst(candidates: HTMLElement[], preventScroll = false, activateKeyboardNav = true): boolean {
    const prevFocusedElement = document.activeElement;

    // sort candidates by tabindex to ensure proper order
    const sortedCandidates = [...candidates].sort((a, b) => {
        const aIndex = a.tabIndex || 0;
        const bIndex = b.tabIndex || 0;
        return aIndex - bIndex;
    });

    const success = sortedCandidates.some((candidate) => {
        // if focus is already where we want it, do nothing
        if (candidate === prevFocusedElement) return true;

        try {
            candidate.focus({ preventScroll });
            return document.activeElement !== prevFocusedElement;
        } catch (e) {
            console.error('Error focusing element:', e);
            return false;
        }
    });

    // if focus was moved successfully and we want to activate keyboard navigation,
    // dispatch a dummy keypress to ensure keyboard handlers are activated
    if (success && activateKeyboardNav && document.activeElement !== prevFocusedElement) {
        try {
            // dispatch a no-op keydown event to activate any keyboard handlers
            document.activeElement?.dispatchEvent(
                new KeyboardEvent('keydown', {
                    bubbles: true,
                    cancelable: true,
                    key: 'Tab',
                    code: 'Tab'
                })
            );
        } catch (e) {
            console.error('Error dispatching keyboard event:', e);
        }
    }

    return success;
}

/**
 * Get all tabbable candidates in a container
 */
export function getTabbableCandidates(container: HTMLElement): HTMLElement[] {
    if (!container || !container.querySelectorAll) return [];

    const TABBABLE_SELECTOR =
        'a[href], button:not([disabled]), input:not([disabled]):not([type="hidden"]), ' +
        'select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"]), ' +
        '[contenteditable="true"]:not([tabindex="-1"])';

    // use querySelector for better browser support
    const elements = Array.from(container.querySelectorAll(TABBABLE_SELECTOR)) as HTMLElement[];

    // filter out elements that are hidden, have display:none, etc.
    return elements.filter((element) => {
        if (element.tabIndex < 0) return false;
        if (element.hasAttribute('disabled')) return false;
        if (element.hasAttribute('aria-hidden') && element.getAttribute('aria-hidden') === 'true') return false;

        // Check if element or any parent is hidden
        let current: HTMLElement | null = element;
        while (current) {
            const style = window.getComputedStyle(current);
            if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') {
                return false;
            }
            current = current.parentElement;
        }

        return true;
    });
}

/**
 * Remove elements from tab order and return a function to restore them
 */
export function removeFromTabOrder(candidates: HTMLElement[]): () => void {
    const originalValues = new Map<HTMLElement, string | null>();

    candidates.forEach((candidate) => {
        // Store original tabindex
        originalValues.set(candidate, candidate.getAttribute('tabindex'));

        // Set to -1 to remove from tab order
        candidate.setAttribute('tabindex', '-1');
    });

    // Return restore function
    return () => {
        candidates.forEach((candidate) => {
            const originalValue = originalValues.get(candidate);
            if (originalValue == null) {
                candidate.removeAttribute('tabindex');
            } else {
                candidate.setAttribute('tabindex', originalValue);
            }
        });
    };
}

/**
 * Wrap array around itself at given start index
 */
export function wrapArray<T>(array: T[], startIndex: number): T[] {
    return array.map((_, index) => array[(startIndex + index) % array.length]);
}

</document_content>
</document>
</documents>
