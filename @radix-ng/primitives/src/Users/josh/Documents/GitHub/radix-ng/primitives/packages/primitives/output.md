/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/CHANGELOG.md
```
## 0.34.0 (2025-04-27)

### ðŸš€ Features

- **calendar:** new Calendar primitive ([#295](https://github.com/radix-ng/primitives/pull/295))

### â¤ï¸ Thank You

- Oleg Pimenov @pimenovoleg

## 0.33.1 (2025-04-23)

### ðŸ©¹ Fixes

- **navigation-menu:** motion state ([#307](https://github.com/radix-ng/primitives/pull/307))
- **hover-card:** remove console log from action handling ([#306](https://github.com/radix-ng/primitives/pull/306))
- **navigation-menu:** simplify viewport content existence validation ([#302](https://github.com/radix-ng/primitives/pull/302))

### â¤ï¸ Thank You

- Josh Sullivan @jpsullivan

## 0.33.0 (2025-04-12)

### ðŸš€ Features

- **popover:** add the ability to define the element that receives focus first ([#296](https://github.com/radix-ng/primitives/pull/296))
- **navigation-menu:** add navigation menu primitive ([#292](https://github.com/radix-ng/primitives/pull/292))
- **popover:** focus management inside popover ([#285](https://github.com/radix-ng/primitives/pull/285))
- **visually-hidden:** added updated feature effect ([0b2a6b4](https://github.com/radix-ng/primitives/commit/0b2a6b4))

### â¤ï¸ Thank You

- Josh Sullivan
- Oleg Pimenov
- Victor Zubrinkin

## 0.32.4 (2025-03-04)

### ðŸ©¹ Fixes

- **radio:** unset data-disabled attr for indicator ([99036a5](https://github.com/radix-ng/primitives/commit/99036a5))

### â¤ï¸ Thank You

- Oleg Pimenov

## 0.32.3 (2025-03-04)

### ðŸ©¹ Fixes

- **radio:** unset data-disabled attr for indicator ([af7099e](https://github.com/radix-ng/primitives/commit/af7099e))
- **stepper:** added valuechange event ([dca2dc2](https://github.com/radix-ng/primitives/commit/dca2dc2))

### â¤ï¸ Thank You

- Oleg Pimenov

## 0.32.2 (2025-02-16)

### ðŸ©¹ Fixes

- schematic build ([4bc55de](https://github.com/radix-ng/primitives/commit/4bc55de))

### â¤ï¸ Thank You

- Oleg Pimenov

## 0.32.1 (2025-02-16)

### ðŸ©¹ Fixes

- **stepper:** package ([d67b685](https://github.com/radix-ng/primitives/commit/d67b685))

### â¤ï¸ Thank You

- Oleg Pimenov

## 0.32.0 (2025-02-16)

### ðŸš€ Features

- **stepper:** added new primitive - Stepper ([#276](https://github.com/radix-ng/primitives/pull/276))

### â¤ï¸ Thank You

- Oleg Pimenov

## 0.31.0 (2025-02-09)

### ðŸš€ Features

- **pagination:** added pagination primitive ([#273](https://github.com/radix-ng/primitives/pull/273))
- **config:** added provider for global config ([9b1d5b3](https://github.com/radix-ng/primitives/commit/9b1d5b3))

### â¤ï¸ Thank You

- Oleg Pimenov

## 0.30.0 (2025-02-02)

### ðŸš€ Features

- **radix-docs:** added Checkbox ([6f32531](https://github.com/radix-ng/primitives/commit/6f32531))
- upd angular to 19.1 ([#266](https://github.com/radix-ng/primitives/pull/266))
- menu ([#258](https://github.com/radix-ng/primitives/pull/258))
- **progress:** updated to signals ([#265](https://github.com/radix-ng/primitives/pull/265))
- **alert:** added alert role to dialog config ([eb8d725](https://github.com/radix-ng/primitives/commit/eb8d725))

### â¤ï¸ Thank You

- Oleg Pimenov

## 0.29.0 (2025-01-12)

### ðŸš€ Features

- **schematics:** added ng-add ([57e1ad9](https://github.com/radix-ng/primitives/commit/57e1ad9))
- **toolbar:** added Toolbar primitive ([0a1398b](https://github.com/radix-ng/primitives/commit/0a1398b))
- **slider:** added styleClass, updated docs and move emits to signals ([439b594](https://github.com/radix-ng/primitives/commit/439b594))
- **radix-docs:** added Toggle Group ([58e5ef3](https://github.com/radix-ng/primitives/commit/58e5ef3))

### â¤ï¸ Thank You

- Oleg Pimenov

## 0.28.0 (2025-01-08)

### ðŸš€ Features

- **toggle-group:** rewrite to signals and host as Toggle ([3fd4edb](https://github.com/radix-ng/primitives/commit/3fd4edb))
- **toggle-group:** updated multiple selection ([f396126](https://github.com/radix-ng/primitives/commit/f396126))

### ðŸ©¹ Fixes

- **dialog:** set dialogClose for any elements ([c341a9b](https://github.com/radix-ng/primitives/commit/c341a9b))

### â¤ï¸ Thank You

- Oleg Pimenov

## 0.27.0 (2024-12-31)

### ðŸš€ Features

- **hover-card:** create hover-card primitive ([#242](https://github.com/radix-ng/primitives/pull/242))

### â¤ï¸ Thank You

- pawel-twardziak

## 0.26.0 (2024-12-30)

### ðŸš€ Features

- **popover:** use input transformers & embrace default standalone ([#230](https://github.com/radix-ng/primitives/pull/230))

### ðŸ©¹ Fixes

- **tooltip:** show tooltip on hover ([#234](https://github.com/radix-ng/primitives/pull/234))
- **popover:** position arrow correctly ([#232](https://github.com/radix-ng/primitives/pull/232))
- **tooltip:** added input transforms and remove standalone param ([#228](https://github.com/radix-ng/primitives/pull/228))

### â¤ï¸ Thank You

- Oleg Pimenov
- pawel-twardziak

## 0.25.0 (2024-12-26)

### ðŸš€ Features

- updated to Angular 19 ([#226](https://github.com/radix-ng/primitives/pull/226))

### ðŸ©¹ Fixes

- **tooltip:** use core positioning utils ([#227](https://github.com/radix-ng/primitives/pull/227))

### â¤ï¸ Thank You

- Oleg Pimenov
- pawel-twardziak

## 0.24.0 (2024-12-25)

### ðŸš€ Features

- **popover:** add cdk events service ([#217](https://github.com/radix-ng/primitives/pull/217))

### ðŸ©¹ Fixes

- **popover:** close popover on anchor click ([#225](https://github.com/radix-ng/primitives/pull/225))

### â¤ï¸ Thank You

- pawel-twardziak

## 0.23.0 (2024-12-23)

### ðŸš€ Features

- added typedoc generator ([#218](https://github.com/radix-ng/primitives/pull/218))

### ðŸ©¹ Fixes

- **popover:** repair offsets calculation ([#219](https://github.com/radix-ng/primitives/pull/219))

### â¤ï¸ Thank You

- Oleg Pimenov
- pawel-twardziak

## 0.22.0 (2024-12-21)

### ðŸš€ Features

- **tabs:** added activation-mode ([2415dab](https://github.com/radix-ng/primitives/commit/2415dab))

### ðŸ©¹ Fixes

- **tabs:** roving-focus item active state ([983b984](https://github.com/radix-ng/primitives/commit/983b984))

### â¤ï¸ Thank You

- Oleg Pimenov

## 0.21.0 (2024-12-20)

### ðŸš€ Features

- **popover:** add anchor directive ([#209](https://github.com/radix-ng/primitives/pull/209))
- **switch:** added inputId and aria labels for screenreader ([#211](https://github.com/radix-ng/primitives/pull/211))
- **switch:** added defaultChecked boolean attr ([ba493d1](https://github.com/radix-ng/primitives/commit/ba493d1))
- **switch:** added Switch components for Radix Theme ([9e8cef4](https://github.com/radix-ng/primitives/commit/9e8cef4))
- **switch:** added cva, updated storybook ([#210](https://github.com/radix-ng/primitives/pull/210))
- **toggle:** rename visually hidden directive for input, upd storybook ([#208](https://github.com/radix-ng/primitives/pull/208))
- **popover:** add animation on open and close ([#200](https://github.com/radix-ng/primitives/pull/200))

### ðŸ©¹ Fixes

- **avatar:** fallback display ([7685774](https://github.com/radix-ng/primitives/commit/7685774))

### â¤ï¸ Thank You

- Oleg Pimenov
- pawel-twardziak

## 0.20.2 (2024-12-13)

### ðŸ©¹ Fixes

- **popover:** set align-offset default value to 0 ([#195](https://github.com/radix-ng/primitives/pull/195))
- **popover:** set default Radix values ([#189](https://github.com/radix-ng/primitives/pull/189))
- **popover:** close on outside click by default ([#192](https://github.com/radix-ng/primitives/pull/192))

### â¤ï¸ Thank You

- Oleg Pimenov
- pawel-twardziak

## 0.20.1 (2024-12-12)

### ðŸ©¹ Fixes

- **radio:** indicator data-state ([50ccf4d](https://github.com/radix-ng/primitives/commit/50ccf4d))

### â¤ï¸ Thank You

- Oleg Pimenov

## 0.20.0 (2024-12-12)

### ðŸš€ Features

- **popover:** create popover directives ([#179](https://github.com/radix-ng/primitives/pull/179))

### ðŸ©¹ Fixes

- **popover:** remove unnecesary effect-refs asignments + more ([#187](https://github.com/radix-ng/primitives/pull/187))
- **radio:** updated disabled state ([#186](https://github.com/radix-ng/primitives/pull/186))

### â¤ï¸ Thank You

- Oleg Pimenov
- pawel-twardziak

## 0.19.0 (2024-12-10)

### ðŸš€ Features

- **avatar:** move to zoneless, upd visibility logic ([c1c15c3](https://github.com/radix-ng/primitives/commit/c1c15c3))
- **radio:** added roving focus ([afdde5d](https://github.com/radix-ng/primitives/commit/afdde5d))
- **roving-focus:** added Roving Focus Direcrivces ([6f22c69](https://github.com/radix-ng/primitives/commit/6f22c69))
- **checkbox:** added prefix rdx to checkbox directives ([1347e8c](https://github.com/radix-ng/primitives/commit/1347e8c))

### ðŸ©¹ Fixes

- **radio:** updated input element, added item-input directive ([fe4d69e](https://github.com/radix-ng/primitives/commit/fe4d69e))
- **toggle:** added value for input element ([0be7115](https://github.com/radix-ng/primitives/commit/0be7115))

### â¤ï¸ Thank You

- Oleg Pimenov

## 0.18.2 (2024-12-04)

### ðŸ©¹ Fixes

- **slider:** remove root from context service ([d4dac98](https://github.com/radix-ng/primitives/commit/d4dac98))

### â¤ï¸ Thank You

- Oleg Pimenov

## 0.18.1 (2024-12-03)

### ðŸ©¹ Fixes

- **slider:** fixed SSR and added ssr test ([6486d80](https://github.com/radix-ng/primitives/commit/6486d80))

### â¤ï¸ Thank You

- Oleg Pimenov

## 0.18.0 (2024-12-03)

### ðŸš€ Features

- **primitives:** added Slider ([#174](https://github.com/radix-ng/primitives/pull/174))
- **primitives:** added Tooltip ([#91](https://github.com/radix-ng/primitives/pull/91))

### ðŸ©¹ Fixes

- **select:** referenceError and track expression ([4e155bf](https://github.com/radix-ng/primitives/commit/4e155bf))

### â¤ï¸ Thank You

- lskramarov
- Oleg Pimenov
- Vitaliy Agoshkov

## 0.17.0 (2024-11-30)

### ðŸš€ Features

- **primitives:** added Select ([#146](https://github.com/radix-ng/primitives/pull/146))
- **checkbox:** replace cdk visual hidden to hostDirective ([77e4c34](https://github.com/radix-ng/primitives/commit/77e4c34))

### â¤ï¸ Thank You

- lskramarov
- Oleg Pimenov

## 0.16.0 (2024-11-08)


### ðŸš€ Features

- **radix-docs:** added aspect ration docs ([d98ec13](https://github.com/radix-ng/primitives/commit/d98ec13))

- **radix-docs:** added separator docs ([2a32a3a](https://github.com/radix-ng/primitives/commit/2a32a3a))

- **toggle:** added toggle-input ([6e8a238](https://github.com/radix-ng/primitives/commit/6e8a238))

- **avatar:** added role img ([f8a1228](https://github.com/radix-ng/primitives/commit/f8a1228))


### ðŸ©¹ Fixes

- **dialog:** added string[] type for backdropClass ([#153](https://github.com/radix-ng/primitives/pull/153))


### â¤ï¸  Thank You

- Oleg Pimenov

## 0.15.0 (2024-10-22)


### ðŸš€ Features

- **primitives:** added visual hidden for input ([a28557f](https://github.com/radix-ng/primitives/commit/a28557f))

- **alert-dialog:** added module exports ([a8e2dd9](https://github.com/radix-ng/primitives/commit/a8e2dd9))

- **aspect-ratio:** added AspectRatio primitive ([33d964a](https://github.com/radix-ng/primitives/commit/33d964a))

- **separator:** updated to signals ([3fc6309](https://github.com/radix-ng/primitives/commit/3fc6309))


### â¤ï¸  Thank You

- Oleg Pimenov

## 0.14.0 (2024-10-10)


### ðŸš€ Features

- **toggle:** migrate o signals, added disable example in storybbok ([3309e6d](https://github.com/radix-ng/primitives/commit/3309e6d))

- **toggle-group:** rename to multiple ([1b955c1](https://github.com/radix-ng/primitives/commit/1b955c1))

- **toggle-group:** added Multiple example ([c8a41e5](https://github.com/radix-ng/primitives/commit/c8a41e5))

- **toggle-group:** added focus-manager ([b30ed2e](https://github.com/radix-ng/primitives/commit/b30ed2e))

- **switch:** use model for checked ([a0e0f58](https://github.com/radix-ng/primitives/commit/a0e0f58))


### ðŸ©¹ Fixes

- **toggle:** rename button to rdxToggleGroupItem ([761580c](https://github.com/radix-ng/primitives/commit/761580c))

- **dropdown-menu:** onPointerMove if not highlighted ([97dd5cd](https://github.com/radix-ng/primitives/commit/97dd5cd))

- **accordion:** fixed navigation with TAB key ([#127](https://github.com/radix-ng/primitives/pull/127))


### â¤ï¸  Thank You

- lskramarov
- Oleg Pimenov

## 0.13.0 (2024-09-25)


### ðŸš€ Features

- added module exports ([9eee903](https://github.com/radix-ng/primitives/commit/9eee903))

- **progress:** added NgModule export ([d2c5875](https://github.com/radix-ng/primitives/commit/d2c5875))

- **radix-docs:** added example of Sheet component ([1feae56](https://github.com/radix-ng/primitives/commit/1feae56))


### â¤ï¸  Thank You

- Oleg Pimenov

## 0.12.2 (2024-09-19)


### ðŸ©¹ Fixes

- publish script ([38e43ab](https://github.com/radix-ng/primitives/commit/38e43ab))

## 0.12.1 (2024-09-19)


### ðŸ©¹ Fixes

- publish script ([1ecaf0c](https://github.com/radix-ng/primitives/commit/1ecaf0c))

## 0.12.0 (2024-09-19)


### ðŸš€ Features

- **dialog:** added Dialog primitive ([#101](https://github.com/radix-ng/primitives/pull/101))

- **radio:** added prefix rdx ([e5ebbc6](https://github.com/radix-ng/primitives/commit/e5ebbc6))

- **ci:** added eslint support ([#103](https://github.com/radix-ng/primitives/pull/103))

- **context-menu:** added context menu ([#2865](https://github.com/radix-ng/primitives/pull/2865), [#104](https://github.com/radix-ng/primitives/pull/104))


### ðŸ©¹ Fixes

- **avatar:** supported SSR ([c50ce18](https://github.com/radix-ng/primitives/commit/c50ce18))

- **dropdown-menu:** navigation ([#106](https://github.com/radix-ng/primitives/pull/106))

## 0.11.1 (2024-09-10)


### ðŸ©¹ Fixes

- shadcn/ui accordion example ([ee300bb](https://github.com/radix-ng/primitives/commit/ee300bb))

- animation in accordion-content.directive ([#94](https://github.com/radix-ng/primitives/pull/94))

## 0.11.0 (2024-09-06)


### ðŸš€ Features

- radix documentation - Astro and MDX ([#69](https://github.com/radix-ng/primitives/pull/69))

- accordion (#DS-2773) ([#92](https://github.com/radix-ng/primitives/pull/92))

- **collapsible:** rename onOpenChange and added content attributes ([24baf80](https://github.com/radix-ng/primitives/commit/24baf80))


### ðŸ©¹ Fixes

- **radio-group:** added focusKeyManager ([#95](https://github.com/radix-ng/primitives/pull/95))

## 0.10.0 (2024-08-21)


### ðŸš€ Features

- **primitives:** added rdx suffix for separator directive ([be5f9a5](https://github.com/radix-ng/primitives/commit/be5f9a5))


### ðŸ©¹ Fixes

- extend in trigger and menu + onEscapeKeyDown ([#86](https://github.com/radix-ng/primitives/pull/86))

## 0.9.1 (2024-08-15)


### ðŸ©¹ Fixes

- use extend for CdkMenuItem ([#85](https://github.com/radix-ng/primitives/pull/85))

## 0.9.0 (2024-08-13)


### ðŸš€ Features

- added stylelint support ([#64](https://github.com/radix-ng/primitives/pull/64))

- added prettier support for ts files ([#80](https://github.com/radix-ng/primitives/pull/80))

- added prettier support for mdx files ([#81](https://github.com/radix-ng/primitives/pull/81))

- **primitives:** dropdown menu, added parameters â€“ side, align and offsets ([#65](https://github.com/radix-ng/primitives/pull/65))

- **primitives:** avatar - added prefix ([908bce1](https://github.com/radix-ng/primitives/commit/908bce1))

- **primitives:** updated prefix and documentation ([a2e5d34](https://github.com/radix-ng/primitives/commit/a2e5d34))

- **primitives:** dropdown menu ([#79](https://github.com/radix-ng/primitives/pull/79))

## 0.8.2 (2024-07-20)


### ðŸš€ Features

- **primitives:** upd Checkbox added input primitive and upd docs for imdeterminate ([e7d1279](https://github.com/radix-ng/primitives/commit/e7d1279))

- **shadcn:** updated checkbox indeterminate state ([497659d](https://github.com/radix-ng/primitives/commit/497659d))

## 0.8.1 (2024-07-10)

This was a version bump only for primitives to align it with other projects, there were no code changes.

## 0.7.2 (2024-07-06)


### ðŸš€ Features

- added Menubar base primitive ([0db991f](https://github.com/radix-ng/primitives/commit/0db991f))

- added Menu base primitive ([c7e395e](https://github.com/radix-ng/primitives/commit/c7e395e))

- **menubar:** added MenuBar ([#44](https://github.com/radix-ng/primitives/pull/44))

## 0.7.1 (2024-06-30)

This was a version bump only for primitives to align it with other projects, there were no code changes.

## 0.7.0 (2024-06-29)


### ðŸš€ Features

- **tabs:** added Tabs ([#38](https://github.com/radix-ng/primitives/pull/38))

## 0.6.0 (2024-06-20)


### ðŸš€ Features

- based for Textarea ([fcd14e1](https://github.com/radix-ng/primitives/commit/fcd14e1))

- added beta presence ([55b4a75](https://github.com/radix-ng/primitives/commit/55b4a75))

- **alert-dialog:** poc code ([f314588](https://github.com/radix-ng/primitives/commit/f314588))

## 0.5.0 (2024-04-26)


### ðŸš€ Features

- added Accordion primitive ([2e95121](https://github.com/radix-ng/primitives/commit/2e95121))

- **toggle-group:** added Toggle Group primitive ([88a38d3](https://github.com/radix-ng/primitives/commit/88a38d3))


### ðŸ©¹ Fixes

- **label:** added setter for UniqueId ([774c82f](https://github.com/radix-ng/primitives/commit/774c82f))

## 0.4.0 (2024-04-22)


### ðŸš€ Features

- **toggle:** added Toggle primitive ([f9a98dc](https://github.com/radix-ng/primitives/commit/f9a98dc))

## 0.3.0 (2024-04-20)


### ðŸš€ Features

- added overlay and tooltip ([e993fb3](https://github.com/radix-ng/primitives/commit/e993fb3))

- **avatar:** added primitive ([f76e8e9](https://github.com/radix-ng/primitives/commit/f76e8e9))

## 0.2.0 (2024-04-16)

### ðŸš€ Features

-   **radio:** added Radio Group ([f0b0eed](https://github.com/radix-ng/primitives/commit/f0b0eed))

### ðŸ©¹ Fixes

-   **checkbox:** updated story and styles ([7999532](https://github.com/radix-ng/primitives/commit/7999532))

-   **styles:** radix variables ([532a6d1](https://github.com/radix-ng/primitives/commit/532a6d1))

## 0.1.1 (2024-04-14)

### ðŸ©¹ Fixes

-   nx release publish target ([a27032f](https://github.com/radix-ng/primitives/commit/a27032f))

## 0.1.0 (2024-04-14)

### ðŸš€ Features

-   **progress:** added progress meter ([17f3ffb](https://github.com/radix-ng/primitives/commit/17f3ffb))

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/README.md
```
# Primitives

> Radix-NG is an unofficial Angular port of [Radix UI](https://www.radix-ui.com/),
> thus we share the same principal and vision when building primitives.

Radix Primitives is a low-level UI component library with a focus on accessibility,
customization and developer experience.

You can use these components either as the base layer of your design system, or adopt them incrementally.

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/index.ts
```typescript
export {};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/jest.config.ts
```typescript
export default {
    displayName: 'primitives',
    preset: '../../jest.preset.cjs',
    setupFilesAfterEnv: ['<rootDir>/test-setup.ts'],
    coverageDirectory: '../../coverage/packages/primitives',
    transform: {
        '^.+\\.(ts|mjs|js|html)$': [
            'jest-preset-angular',
            {
                tsconfig: '<rootDir>/tsconfig.spec.json',
                stringifyContentPathRegex: '\\.(html|svg)$'
            }
        ]
    },
    transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
    snapshotSerializers: [
        'jest-preset-angular/build/serializers/no-ng-attributes',
        'jest-preset-angular/build/serializers/ng-snapshot',
        'jest-preset-angular/build/serializers/html-comment'
    ]
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/ng-package.json
```json
{
    "$schema": "../../node_modules/ng-packagr/ng-package.schema.json",
    "dest": "../../dist/primitives",
    "lib": {
        "entryFile": "index.ts"
    },
    "allowedNonPeerDependencies": []
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/package.json
```json
{
    "name": "@radix-ng/primitives",
    "version": "0.34.0",
    "license": "MIT",
    "publishConfig": {
        "access": "public"
    },
    "repository": {
        "type": "git",
        "url": "https://github.com/radix-ng/primitives.git",
        "directory": "packages/primitives"
    },
    "keywords": [
        "components",
        "ui",
        "angular",
        "radix-ng",
        "headless"
    ],
    "peerDependencies": {
        "@angular/core": "^19.2.4",
        "@angular/cdk": "^19.2.7"
    },
    "devDependencies": {
        "@angular-devkit/schematics": "^19.2.5",
        "@internationalized/date": "^3.7.0"
    },
    "schematics": "./schematics/collection.json",
    "sideEffects": false,
    "ng-add": {
        "save": "true"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/project.json
```json
{
    "name": "primitives",
    "$schema": "../../node_modules/nx/schemas/project-schema.json",
    "sourceRoot": "packages/primitives",
    "prefix": "rdx",
    "projectType": "library",
    "tags": [],
    "targets": {
        "build": {
            "executor": "@nx/angular:package",
            "outputs": ["{workspaceRoot}/dist/{projectRoot}"],
            "options": {
                "project": "packages/primitives/ng-package.json"
            },
            "configurations": {
                "production": {
                    "tsConfig": "packages/primitives/tsconfig.lib.prod.json"
                },
                "development": {
                    "tsConfig": "packages/primitives/tsconfig.lib.json"
                }
            },
            "defaultConfiguration": "production"
        },
        "schematics": {
            "executor": "@nx/js:tsc",
            "outputs": ["{workspaceRoot}/dist/primitives-schematics"],
            "options": {
                "outputPath": "dist/primitives-schematics",
                "main": "packages/primitives/index.ts",
                "tsConfig": "packages/primitives/tsconfig.schematics.json",
                "assets": [
                    {
                        "input": "./packages/primitives/schematics",
                        "output": "./schematics",
                        "glob": "collection.json"
                    }
                ]
            }
        },
        "build:schematics": {
            "executor": "nx:run-commands",
            "options": {
                "parallel": false,
                "commands": [
                    {
                        "command": "nx schematics primitives"
                    },
                    {
                        "command": "cpy 'dist/primitives-schematics/**/*' '!dist/primitives-schematics/package.json' dist/primitives"
                    }
                ]
            }
        },
        "test": {
            "executor": "@nx/jest:jest",
            "outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
            "options": {
                "jestConfig": "packages/primitives/jest.config.ts"
            }
        },
        "nx-release-publish": {
            "dependsOn": ["build"],
            "options": {
                "packageRoot": "{workspaceRoot}/dist/{projectName}"
            }
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/test-setup.ts
```typescript
import '@testing-library/jest-dom';
import { toHaveNoViolations } from 'jest-axe';
import { setupZoneTestEnv } from 'jest-preset-angular/setup-env/zone';

setupZoneTestEnv();
expect.extend(toHaveNoViolations);

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tsconfig.doc.json
```json
{
    "include": ["**/*.ts"],
    "exclude": [
        "**/*.spec.ts",
        "test-setup.ts",
        "jest.config.ts",
        "**/*.test.ts",
        "**/*.stories.ts",
        "**/*.stories.js"
    ]
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tsconfig.json
```json
{
    "compilerOptions": {
        "target": "es2022",
        "useDefineForClassFields": false,
        "forceConsistentCasingInFileNames": true,
        "strict": true,
        "noImplicitOverride": true,
        "noPropertyAccessFromIndexSignature": true,
        "noImplicitReturns": true,
        "noFallthroughCasesInSwitch": true
    },
    "files": [],
    "include": [],
    "references": [
        {
            "path": "./tsconfig.lib.json"
        },
        {
            "path": "./tsconfig.spec.json"
        },
        {
            "path": "./tsconfig.schematics.json"
        },
        {
            "path": "./tsconfig.typedoc.json"
        }
    ],
    "extends": "../../tsconfig.base.json",
    "angularCompilerOptions": {
        "enableI18nLegacyMessageIdFormat": false,
        "strictInjectionParameters": true,
        "strictInputAccessModifiers": true,
        "strictTemplates": true
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tsconfig.lib.json
```json
{
    "extends": "./tsconfig.json",
    "compilerOptions": {
        "outDir": "../../dist/out-tsc",
        "declaration": true,
        "declarationMap": true,
        "inlineSources": true,
        "types": []
    },
    "exclude": [
        "**/*.spec.ts",
        "test-setup.ts",
        "jest.config.ts",
        "**/*.test.ts",
        "**/*.stories.ts",
        "**/*.stories.js"
    ],
    "include": [
        "**/*.ts"
    ]
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tsconfig.lib.prod.json
```json
{
    "extends": "./tsconfig.lib.json",
    "compilerOptions": {
        "declarationMap": false,
        "paths": {
            "@radix-ng/primitives/*": ["./dist/primitives/*"]
        }
    },
    "angularCompilerOptions": {
        "compilationMode": "partial"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tsconfig.schematics.json
```json
{
    "extends": "./tsconfig.json",
    "compilerOptions": {
        "outDir": "../../dist/out-tsc",
        "declaration": true,
        "resolveJsonModule": true,
        "module": "CommonJS",
        "types": ["node"]
    },
    "exclude": ["**/*.spec.ts", "**/*.test.ts"],
    "include": ["./schematics/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tsconfig.spec.json
```json
{
    "extends": "./tsconfig.json",
    "compilerOptions": {
        "outDir": "../../dist/out-tsc",
        "module": "commonjs",
        "target": "es2016",
        "types": ["jest", "node"]
    },
    "files": ["test-setup.ts"],
    "include": ["jest.config.ts", "**/*.test.ts", "**/*.spec.ts", "**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tsconfig.typedoc.json
```json
{
    "extends": "./tsconfig.json",
    "compilerOptions": {
        "outDir": "../../dist/out-tsc",
        "declaration": true,
        "resolveJsonModule": true,
        "module": "CommonJS",
        "types": [
            "node"
        ]
    },
    "include": [
        "**/src/**.ts",
        "**/*.ts"
    ],
    "exclude": [
        "**/*.spec.ts",
        "**/*.test.ts",
        "**/stories/**.*",
        "*.stories.ts",
        "./schematics/**/*.ts"
    ]
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tabs/index.ts
```typescript
import { NgModule } from '@angular/core';
import { RdxTabsContentDirective } from './src/tabs-content.directive';
import { RdxTabsListDirective } from './src/tabs-list.directive';
import { RdxTabsRootDirective } from './src/tabs-root.directive';
import { RdxTabsTriggerDirective } from './src/tabs-trigger.directive';

export * from './src/tabs-content.directive';
export * from './src/tabs-list.directive';
export * from './src/tabs-root.directive';
export * from './src/tabs-trigger.directive';

const tabsImports = [
    RdxTabsRootDirective,
    RdxTabsContentDirective,
    RdxTabsListDirective,
    RdxTabsTriggerDirective
];

@NgModule({
    imports: [...tabsImports],
    exports: [...tabsImports]
})
export class RdxTabsModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tabs/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tabs/stories/tabs.docs.mdx
````
import { ArgTypes, Canvas, Markdown, Meta } from '@storybook/blocks';
import * as TabsStories from './tabs.stories';
import { RdxTabsRootDirective } from '../src/tabs-root.directive';
import { RdxTabsTriggerDirective } from '../src/tabs-trigger.directive';
import { RdxTabsContentDirective } from '../src/tabs-content.directive';

<Meta title="Primitives/Tabs" />

# Tabs

#### A set of layered sections of contentâ€”known as tab panelsâ€”that are displayed one at a time.

<Canvas sourceState="hidden" of={TabsStories.Default} />

## Features

- âœ… Can be controlled or uncontrolled.
- âœ… Supports horizontal/vertical orientation.
- âœ… Full keyboard navigation.

## Import

Get started with importing the directives:

```typescript
import {
    RdxTabsRootDirective,
    RdxTabsListDirective,
    RdxTabsTriggerDirective,
    RdxTabsContentDirective } from '@radix-ng/primitives/tabs';
```

## Anatomy

```html
<div rdxTabsRoot>
    <div rdxTabsList>
        <button rdxTabsTrigger></button>
        <button rdxTabsTrigger></button>
        <button rdxTabsTrigger></button>
    </div>
    <div rdxTabsContent></div>
    <div rdxTabsContent></div>
    <div rdxTabsContent></div>
</div>
```

## API Reference

### TabsRoot

`RdxTabsRootDirective`

<ArgTypes of={RdxTabsRootDirective} />

### TabsList

`RdxTabsListDirective`

<Markdown>
    {`
| Data attribute | Value          |
|----------------|----------------|
| [data-orientation]   | <code>"vertical" | "horizontal"</code>
`}
</Markdown>

### TabsTrigger

`RdxTabsTriggerDirective`

<ArgTypes of={RdxTabsTriggerDirective} />

### TabsContent

`RdxTabsContentDirective`

<ArgTypes of={RdxTabsContentDirective} />

## Accessibility

Adheres to the [Tabs WAI-ARIA design pattern](https://www.w3.org/WAI/ARIA/apg/patterns/tabs).

### Keyboard Interactions

**Screen Reader**

Tabs container is defined with the **tablist** role, as any attribute is passed to the container element **aria-labelledby** can be
optionally used to specify an element to describe the Tabs. Each tab header has a **tab** role along with **aria-selected**
state attribute and **aria-controls** to refer to the corresponding tab content element.

The content element of each tab has **tabpanel** role, an id to match the **aria-controls** of the header and **aria-labelledby**
reference to the header as the accessible name.

<Markdown>
    {`
  | Key | Description |
  | ----------- | --------- |
  | Tab       | When focus moves onto the tabs, focuses the active trigger. When a trigger is focused, moves focus to the active content.        |
  | ArrowDown       | Moves focus to the next trigger depending on **orientation** and activates its associated content.    |
  | ArrowRight | Moves focus to the next trigger depending on **orientation** and activates its associated content. |
  | ArrowUp | Moves focus to the previous trigger depending on **orientation** and activates its associated content. |
  | ArrowLeft | Moves focus to the previous trigger depending on **orientation** and activates its associated content. |
  | Home | Moves focus to the first trigger and activates its associated content. |
  | End | Moves focus to the last trigger and activates its associated content. |
  `}
</Markdown>

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tabs/stories/tabs.stories.ts
```typescript
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { RdxTabsContentDirective } from '../src/tabs-content.directive';
import { RdxTabsListDirective } from '../src/tabs-list.directive';
import { RdxTabsRootDirective } from '../src/tabs-root.directive';
import { RdxTabsTriggerDirective } from '../src/tabs-trigger.directive';

const html = String.raw;

export default {
    title: 'Primitives/Tabs',
    decorators: [
        moduleMetadata({
            imports: [
                RdxTabsRootDirective,
                RdxTabsListDirective,
                RdxTabsTriggerDirective,
                RdxTabsContentDirective
            ]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div class="radix-themes light light-theme" data-radius="medium" data-scaling="100%">
                    ${story}
                    <style>
                        /* reset */
                        button,
                        fieldset,
                        input {
                            all: unset;
                        }

                        .TabsRoot {
                            display: flex;
                            flex-direction: column;
                            width: 300px;
                            box-shadow: 0 2px 10px var(--black-a4);
                        }

                        .TabsList {
                            flex-shrink: 0;
                            display: flex;
                            border-bottom: 1px solid var(--mauve-6);
                        }

                        .TabsTrigger {
                            font-family: inherit;
                            background-color: white;
                            padding: 0 20px;
                            height: 45px;
                            flex: 1;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 15px;
                            line-height: 1;
                            color: var(--mauve-11);
                            user-select: none;
                        }
                        .TabsTrigger:first-child {
                            border-top-left-radius: 6px;
                        }
                        .TabsTrigger:last-child {
                            border-top-right-radius: 6px;
                        }
                        .TabsTrigger:hover {
                            color: var(--violet-11);
                        }
                        .TabsTrigger[data-state='active'] {
                            color: var(--violet-11);
                            box-shadow:
                                inset 0 -1px 0 0 currentColor,
                                0 1px 0 0 currentColor;
                        }
                        .TabsTrigger:focus {
                            position: relative;
                            box-shadow: 0 0 0 2px black;
                        }

                        .TabsContent {
                            flex-grow: 1;
                            padding: 20px;
                            background-color: white;
                            border-bottom-left-radius: 6px;
                            border-bottom-right-radius: 6px;
                            outline: none;
                        }
                        .TabsContent:focus {
                            box-shadow: 0 0 0 2px black;
                        }

                        .Text {
                            margin-top: 0;
                            margin-bottom: 20px;
                            color: var(--mauve-11);
                            font-size: 15px;
                            line-height: 1.5;
                        }

                        .Fieldset {
                            margin-bottom: 15px;
                            width: 100%;
                            display: flex;
                            flex-direction: column;
                            justify-content: flex-start;
                        }

                        .Label {
                            font-size: 13px;
                            line-height: 1;
                            margin-bottom: 10px;
                            color: var(--violet-12);
                            display: block;
                        }

                        .Input {
                            flex: 1 0 auto;
                            border-radius: 4px;
                            padding: 0 10px;
                            font-size: 15px;
                            line-height: 1;
                            color: var(--violet-11);
                            box-shadow: 0 0 0 1px var(--violet-7);
                            height: 35px;
                        }
                        .Input:focus {
                            box-shadow: 0 0 0 2px var(--violet-8);
                        }

                        .Button {
                            display: inline-flex;
                            align-items: center;
                            justify-content: center;
                            border-radius: 4px;
                            padding: 0 15px;
                            font-size: 15px;
                            line-height: 1;
                            font-weight: 500;
                            height: 35px;
                        }
                        .Button.green {
                            background-color: var(--green-4);
                            color: var(--green-11);
                        }
                        .Button.green:hover {
                            background-color: var(--green-5);
                        }
                        .Button.green:focus {
                            box-shadow: 0 0 0 2px var(--green-7);
                        }

                        h2,
                        p {
                            color: #ffffff;
                        }

                        section {
                            width: 500px;
                        }
                    </style>
                </div>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: (args) => ({
        props: args,
        template: html`
            <div class="TabsRoot" rdxTabsRoot defaultValue="tab1">
                <div class="TabsList" rdxTabsList>
                    <button class="TabsTrigger" rdxTabsTrigger value="tab1">Account</button>
                    <button class="TabsTrigger" rdxTabsTrigger value="tab2">Password</button>
                </div>
                <div class="TabsContent" rdxTabsContent value="tab1">
                    <p class="Text">Make changes to your account here. Click save when you're done.</p>
                    <fieldset class="Fieldset">
                        <label class="Label" for="name">Name</label>
                        <input class="Input" id="name" value="Pedro Duarte" />
                    </fieldset>
                    <fieldset class="Fieldset">
                        <label class="Label" for="username">Username</label>
                        <input class="Input" id="username" value="@peduarte" />
                    </fieldset>
                    <div style="display: flex; margin-top: 20px; justify-content: flex-end; ">
                        <button class="Button green">Save changes</button>
                    </div>
                </div>
                <div class="TabsContent" rdxTabsContent value="tab2">
                    <p class="Text">Change your password here. After saving, you'll be logged out.</p>
                    <fieldset class="Fieldset">
                        <label class="Label" for="currentPassword">Current password</label>
                        <input class="Input" id="currentPassword" type="password" />
                    </fieldset>
                    <fieldset class="Fieldset">
                        <label class="Label" for="newPassword">New password</label>
                        <input class="Input" id="newPassword" type="password" />
                    </fieldset>
                    <fieldset class="Fieldset">
                        <label class="Label" for="confirmPassword">Confirm password</label>
                        <input class="Input" id="confirmPassword" type="password" />
                    </fieldset>
                    <div style="display: flex; margin-top: 20px; justify-content: flex-end;">
                        <button class="Button green">Change password</button>
                    </div>
                </div>
            </div>
        `
    })
};

export const ActivationMode: Story = {
    render: (args) => ({
        props: args,
        template: html`
            <div class="TabsRoot" rdxTabsRoot activationMode="manual" defaultValue="tab1">
                <div class="TabsList" rdxTabsList>
                    <button class="TabsTrigger" rdxTabsTrigger value="tab1">Account</button>
                    <button class="TabsTrigger" rdxTabsTrigger value="tab2">Password</button>
                </div>
                <div class="TabsContent" rdxTabsContent value="tab1">
                    <p class="Text">Make changes to your account here. Click save when you're done.</p>
                    <fieldset class="Fieldset">
                        <label class="Label" for="name">Name</label>
                        <input class="Input" id="name" value="Pedro Duarte" />
                    </fieldset>
                    <fieldset class="Fieldset">
                        <label class="Label" for="username">Username</label>
                        <input class="Input" id="username" value="@peduarte" />
                    </fieldset>
                    <div style="display: flex; margin-top: 20px; justify-content: flex-end; ">
                        <button class="Button green">Save changes</button>
                    </div>
                </div>
                <div class="TabsContent" rdxTabsContent value="tab2">
                    <p class="Text">Change your password here. After saving, you'll be logged out.</p>
                    <fieldset class="Fieldset">
                        <label class="Label" for="currentPassword">Current password</label>
                        <input class="Input" id="currentPassword" type="password" />
                    </fieldset>
                    <fieldset class="Fieldset">
                        <label class="Label" for="newPassword">New password</label>
                        <input class="Input" id="newPassword" type="password" />
                    </fieldset>
                    <fieldset class="Fieldset">
                        <label class="Label" for="confirmPassword">Confirm password</label>
                        <input class="Input" id="confirmPassword" type="password" />
                    </fieldset>
                    <div style="display: flex; margin-top: 20px; justify-content: flex-end;">
                        <button class="Button green">Change password</button>
                    </div>
                </div>
            </div>
        `
    })
};

export const Disabled: Story = {
    render: (args) => ({
        props: args,
        template: html`
            <section>
                <h2>Disabled</h2>
                <p>Enabling disabled property of a Tab prevents user interaction.</p>
                <div class="TabsRoot" rdxTabsRoot activationMode="manual" defaultValue="tab1">
                    <div class="TabsList" rdxTabsList>
                        <button class="TabsTrigger" rdxTabsTrigger value="tab1">Account</button>
                        <button class="TabsTrigger" rdxTabsTrigger disabled value="tab2">Password</button>
                    </div>
                    <div class="TabsContent" rdxTabsContent value="tab1">
                        <p class="Text">Make changes to your account here. Click save when you're done.</p>
                        <fieldset class="Fieldset">
                            <label class="Label" for="name">Name</label>
                            <input class="Input" id="name" value="Pedro Duarte" />
                        </fieldset>
                        <fieldset class="Fieldset">
                            <label class="Label" for="username">Username</label>
                            <input class="Input" id="username" value="@peduarte" />
                        </fieldset>
                        <div style="display: flex; margin-top: 20px; justify-content: flex-end; ">
                            <button class="Button green">Save changes</button>
                        </div>
                    </div>
                    <div class="TabsContent" rdxTabsContent value="tab2">
                        <p class="Text">Change your password here. After saving, you'll be logged out.</p>
                        <fieldset class="Fieldset">
                            <label class="Label" for="currentPassword">Current password</label>
                            <input class="Input" id="currentPassword" type="password" />
                        </fieldset>
                        <fieldset class="Fieldset">
                            <label class="Label" for="newPassword">New password</label>
                            <input class="Input" id="newPassword" type="password" />
                        </fieldset>
                        <fieldset class="Fieldset">
                            <label class="Label" for="confirmPassword">Confirm password</label>
                            <input class="Input" id="confirmPassword" type="password" />
                        </fieldset>
                        <div style="display: flex; margin-top: 20px; justify-content: flex-end;">
                            <button class="Button green">Change password</button>
                        </div>
                    </div>
                </div>
            </section>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tabs/src/tabs-content.directive.ts
```typescript
import { computed, Directive, inject, input } from '@angular/core';
import { RDX_TABS_ROOT_TOKEN } from './tabs-root.directive';
import { makeContentId, makeTriggerId } from './utils';

@Directive({
    selector: '[rdxTabsContent]',
    host: {
        role: 'tabpanel',
        tabindex: '0',
        '[id]': 'contentId()',
        '[attr.aria-labelledby]': 'triggerId()',
        '[attr.data-state]': 'selected() ? "active" : "inactive"',
        '[attr.data-orientation]': 'tabsContext.orientation()',
        '[hidden]': '!selected()'
    }
})
export class RdxTabsContentDirective {
    protected readonly tabsContext = inject(RDX_TABS_ROOT_TOKEN);

    /**
     * A unique value that associates the content with a trigger.
     */
    readonly value = input.required<string>();

    protected readonly contentId = computed(() => makeContentId(this.tabsContext.getBaseId(), this.value()));
    protected readonly triggerId = computed(() => makeTriggerId(this.tabsContext.getBaseId(), this.value()));

    protected readonly selected = computed(() => this.tabsContext.value() === this.value());
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tabs/src/tabs-list.directive.ts
```typescript
import { Directive, inject } from '@angular/core';
import { RdxRovingFocusGroupDirective } from '@radix-ng/primitives/roving-focus';
import { RDX_TABS_ROOT_TOKEN } from './tabs-root.directive';

export interface TabsListProps {
    // When true, keyboard navigation will loop from last tab to first, and vice versa.
    loop?: boolean;
}

@Directive({
    selector: '[rdxTabsList]',
    hostDirectives: [{ directive: RdxRovingFocusGroupDirective, inputs: ['dir', 'orientation', 'loop'] }],
    host: {
        role: 'tablist',
        '[attr.aria-orientation]': 'tabsContext.orientation()',
        '[attr.data-orientation]': 'tabsContext.orientation()'
    }
})
export class RdxTabsListDirective {
    protected readonly tabsContext = inject(RDX_TABS_ROOT_TOKEN);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tabs/src/tabs-root.directive.ts
```typescript
import { Directive, InjectionToken, input, model, OnInit, output } from '@angular/core';
import { provideToken } from '@radix-ng/primitives/core';

export interface TabsProps {
    /** The value for the selected tab, if controlled */
    value?: string;
    /** The value of the tab to select by default, if uncontrolled */
    defaultValue?: string;
    /** A function called when a new tab is selected */
    onValueChange?: (value: string) => void;
    /**
     * The orientation the tabs are layed out.
     * Mainly so arrow navigation is done accordingly (left & right vs. up & down)
     * @defaultValue horizontal
     */
    orientation?: string;
    /**
     * The direction of navigation between toolbar items.
     */
    dir?: string;
    /**
     * Whether a tab is activated automatically or manually.
     * @defaultValue automatic
     * */
    activationMode?: 'automatic' | 'manual';
}

export type DataOrientation = 'vertical' | 'horizontal';

export const RDX_TABS_ROOT_TOKEN = new InjectionToken<RdxTabsRootDirective>('RdxTabsRootDirective');

@Directive({
    selector: '[rdxTabsRoot]',
    providers: [
        provideToken(RDX_TABS_ROOT_TOKEN, RdxTabsRootDirective)],
    host: {
        '[attr.data-orientation]': 'orientation()',
        '[attr.dir]': 'dir()'
    }
})
export class RdxTabsRootDirective implements OnInit {
    /**
     * The controlled value of the tab to activate. Should be used in conjunction with `onValueChange`.
     */
    readonly value = model<string>();

    readonly defaultValue = input<string>();

    /**
     * When automatic, tabs are activated when receiving focus. When manual, tabs are activated when clicked.
     */
    readonly activationMode = input<'automatic' | 'manual'>('automatic');

    /**
     * The orientation of the component.
     */
    readonly orientation = input<DataOrientation>('horizontal');

    readonly dir = input<string>('ltr');

    /**
     * Event handler called when the value changes.
     */
    readonly onValueChange = output<string>();

    ngOnInit() {
        if (this.defaultValue()) {
            this.value.set(this.defaultValue());
        }
    }

    select(value: string) {
        this.value.set(value);
        this.onValueChange.emit(value);
    }

    /** @ignore */
    getBaseId() {
        return `tabs-${Math.random().toString(36).substr(2, 9)}`;
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tabs/src/tabs-trigger.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { booleanAttribute, computed, Directive, effect, inject, input, InputSignalWithTransform } from '@angular/core';
import { RdxRovingFocusItemDirective } from '@radix-ng/primitives/roving-focus';
import { RDX_TABS_ROOT_TOKEN } from './tabs-root.directive';
import { makeContentId, makeTriggerId } from './utils';

interface TabsTriggerProps {
    // When true, prevents the user from interacting with the tab.
    disabled: InputSignalWithTransform<boolean, BooleanInput>;
}

@Directive({
    selector: '[rdxTabsTrigger]',
    hostDirectives: [
        {
            directive: RdxRovingFocusItemDirective,
            inputs: ['focusable', 'active', 'allowShiftKey']
        }
    ],

    host: {
        type: 'button',
        role: 'tab',
        '[id]': 'triggerId()',
        '[attr.aria-selected]': 'isSelected()',
        '[attr.aria-controls]': 'contentId()',
        '[attr.data-disabled]': "disabled() ? '' : undefined",
        '[disabled]': 'disabled()',
        '[attr.data-state]': "isSelected() ? 'active' : 'inactive'",
        '[attr.data-orientation]': 'tabsContext.orientation()',
        '(mousedown)': 'onMouseDown($event)',
        '(keydown)': 'onKeyDown($event)',
        '(focus)': 'onFocus()'
    }
})
export class RdxTabsTriggerDirective implements TabsTriggerProps {
    private readonly rdxRovingFocusItemDirective = inject(RdxRovingFocusItemDirective);

    protected readonly tabsContext = inject(RDX_TABS_ROOT_TOKEN);

    /**
     * A unique value that associates the trigger with a content.
     */
    readonly value = input.required<string>();

    /**
     * When true, prevents the user from interacting with the tab.
     */
    readonly disabled = input<boolean, BooleanInput>(false, {
        transform: booleanAttribute
    });

    protected readonly contentId = computed(() => makeContentId(this.tabsContext.getBaseId(), this.value()));
    protected readonly triggerId = computed(() => makeTriggerId(this.tabsContext.getBaseId(), this.value()));

    protected readonly isSelected = computed(() => this.tabsContext.value() === this.value());

    constructor() {
        effect(() => (this.rdxRovingFocusItemDirective.active = this.isSelected()));
    }

    protected onMouseDown(event: MouseEvent) {
        // only call handler if it's the left button (mousedown gets triggered by all mouse buttons)
        // but not when the control key is pressed (avoiding MacOS right click)
        if (!this.disabled() && event.button === 0 && !event.ctrlKey) {
            this.tabsContext?.select(this.value());
        } else {
            // prevent focus to avoid accidental activation
            event.preventDefault();
        }
    }

    protected onKeyDown(event: KeyboardEvent) {
        if ([' ', 'Enter'].includes(event.key)) {
            this.tabsContext?.select(this.value());
        }
    }

    protected onFocus() {
        const isAutomaticActivation = this.tabsContext.activationMode() !== 'manual';
        if (!this.isSelected() && !this.disabled() && isAutomaticActivation) {
            this.tabsContext?.select(this.value());
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tabs/src/utils.ts
```typescript
export function makeTriggerId(baseId: string, value: string | number) {
    return `${baseId}-trigger-${value}`;
}

export function makeContentId(baseId: string, value: string | number) {
    return `${baseId}-content-${value}`;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/pagination/README.md
```
# @radix-ng/primitives/pagination

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/pagination/index.ts
```typescript
import { NgModule } from '@angular/core';
import { RdxPaginationEllipsisDirective } from './src/pagination-ellipsis.directive';
import { RdxPaginationFirstDirective } from './src/pagination-first.directive';
import { RdxPaginationLastDirective } from './src/pagination-last.directive';
import { RdxPaginationListItemDirective } from './src/pagination-list-item.directive';
import { RdxPaginationListDirective } from './src/pagination-list.directive';
import { RdxPaginationNextDirective } from './src/pagination-next.directive';
import { RdxPaginationPrevDirective } from './src/pagination-prev.directive';
import { RdxPaginationRootDirective } from './src/pagination-root.directive';

export * from './src/pagination-context.token';
export * from './src/pagination-ellipsis.directive';
export * from './src/pagination-first.directive';
export * from './src/pagination-last.directive';
export * from './src/pagination-list-item.directive';
export * from './src/pagination-list.directive';
export * from './src/pagination-next.directive';
export * from './src/pagination-prev.directive';
export * from './src/pagination-root.directive';

const paginationImports = [
    RdxPaginationRootDirective,
    RdxPaginationListDirective,
    RdxPaginationFirstDirective,
    RdxPaginationPrevDirective,
    RdxPaginationLastDirective,
    RdxPaginationNextDirective,
    RdxPaginationListItemDirective,
    RdxPaginationEllipsisDirective
];

@NgModule({
    imports: [...paginationImports],
    exports: [...paginationImports]
})
export class RdxPaginationModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/pagination/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/pagination/stories/pagination.docs.mdx
````
import { ArgTypes, Canvas, Markdown, Meta } from '@storybook/blocks';
import * as Stories from './pagination.stories';
import {RdxPaginationRootDirective} from "../src/pagination-root.directive";

<Meta title="Primitives/Pagination" />

# Pagination

####  Displays data in paged format and provides navigation between pages.

<Canvas sourceState="hidden" of={Stories.WithEllipsis} />

## Features

- âœ… Enable quick access to first, or last page.
- âœ… Enable to show edges constantly, or not.

## Import

Get started with importing the directives:

```typescript
import { RdxPaginationModule } from '@radix-ng/primitives/pagination';
```

## Anatomy

```html
<div rdxPaginationRoot>
    <div rdxPaginationList #list="rdxPaginationList">
        <button rdxPaginationFirst></button>
        <button rdxPaginationPrev></button>

        @for (item of list.transformedRange(); track item) {
            <button rdxPaginationListItem [value]="item.value">{{ item.value }}</button>
        }

        <button rdxPaginationNext></button>
        <button rdxPaginationLast></button>
    </div>
</div>
```

## API Reference

### Root

`RdxPaginationRootDirective`

<ArgTypes of={RdxPaginationRootDirective} />

### List

`RdxPaginationListDirective`

Used to show the list of pages. It also makes pagination accessible to assistive technologies.

### Item

`RdxPaginationListItemDirective`

Used to render the button that changes the current page.

<Markdown>
    {`
  | Data Attribute     | Value |
  | ------------------ | -------------------------- |
  | [data-selected]    | "true" or ""   |
  | [data-type]        | "page"        |
  `}
</Markdown>

### Ellipsis

`RdxPaginationEllipsisDirective`

Placeholder element when the list is long, and only a small amount of `siblingCount` was set and `showEdges` was set to `true`.

<Markdown>
    {`
  | Data Attribute     | Value |
  | ------------------ | -------------------------- |
  | [data-type]        | "ellipsis"        |
  `}
</Markdown>

## Accessibility

### Keyboard Interactions

<Markdown>
  {`
  | Key | Description |
  | ----------- | --------- |
  | Tab         | Moves focus to the next focusable element.  |
  | Space       | When focus is on a any trigger, trigger selected page or arrow navigation.    |
  | Enter       | When focus is on a any trigger, trigger selected page or arrow navigation.  |
  `}
</Markdown>

## Examples

### With ellipsis

You can add `rdxPaginationEllipsis` as a visual cue for more previous and after items.

```html
<div rdxPaginationRoot>
    <div rdxPaginationList #list="rdxPaginationList">

        @for (item of list.transformedRange(); track item) {
            @if (item.type == 'page') {
                <button rdxPaginationListItem [value]="item.value">{{ item.value }}</button>
            } @else {
                <div rdxPaginationEllipsis>&#8230;</div>
            }
        }

    </div>
</div>
```

### With first/last button

You can add `rdxPaginationFirst` to allow user to navigate to first page, or `rdxPaginationLast` to navigate to last page.

```html
<div rdxPaginationRoot>
    <div rdxPaginationList #list="rdxPaginationList">
        <button rdxPaginationFirst></button>
        ...
        <button rdxPaginationLast></button>
    </div>
</div>
```

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/pagination/stories/pagination.stories.ts
```typescript
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { ChevronLeft, ChevronRight, ChevronsLeft, ChevronsRight, LucideAngularModule } from 'lucide-angular';
import { RdxPaginationEllipsisDirective } from '../src/pagination-ellipsis.directive';
import { RdxPaginationFirstDirective } from '../src/pagination-first.directive';
import { RdxPaginationLastDirective } from '../src/pagination-last.directive';
import { RdxPaginationListItemDirective } from '../src/pagination-list-item.directive';
import { RdxPaginationListDirective } from '../src/pagination-list.directive';
import { RdxPaginationNextDirective } from '../src/pagination-next.directive';
import { RdxPaginationPrevDirective } from '../src/pagination-prev.directive';
import { RdxPaginationRootDirective } from '../src/pagination-root.directive';

const html = String.raw;

export default {
    title: 'Primitives/Pagination',
    decorators: [
        moduleMetadata({
            imports: [
                RdxPaginationRootDirective,
                RdxPaginationListDirective,
                RdxPaginationFirstDirective,
                RdxPaginationPrevDirective,
                RdxPaginationLastDirective,
                RdxPaginationNextDirective,
                RdxPaginationListItemDirective,
                RdxPaginationEllipsisDirective,
                LucideAngularModule,
                LucideAngularModule.pick({ ChevronLeft, ChevronRight, ChevronsRight, ChevronsLeft })
            ]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div class="radix-themes light light-theme" data-radius="medium" data-scaling="100%">
                    ${story}

                    <style>
                        button {
                            all: unset;
                        }

                        .Button {
                            text-align: center;
                            font-size: 15px;
                            line-height: 1;
                            align-items: center;
                            justify-content: center;
                            height: 2.25rem;
                            width: 2.25rem;
                            border-radius: 0.25rem;
                            transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);
                            cursor: pointer;
                        }

                        .Button:disabled {
                            opacity: 0.5;
                        }

                        .Button:hover {
                            background-color: rgb(255 255 255 / 0.1);
                        }

                        .Button[data-selected] {
                            background-color: rgb(255 255 255);
                            color: var(--black-a11);
                        }

                        .PaginationList {
                            display: flex;
                            align-items: center;
                            gap: 0.25rem;
                            color: rgb(255 255 255);
                        }

                        .PaginationEllipsis {
                            display: flex;
                            height: 2.25rem;
                            width: 2.25rem;
                            align-items: center;
                            justify-content: center;
                        }
                    </style>
                </div>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: `
            <div rdxPaginationRoot total="34" siblingCount="1" itemsPerPage="10">
                <div class="PaginationList" rdxPaginationList #list="rdxPaginationList">
                    <button class="Button" rdxPaginationFirst>
                        <lucide-icon name="chevrons-left" size="16" strokeWidth="2" />
                    </button>
                    <button class="Button" rdxPaginationPrev style="margin-right: 16px;">
                        <lucide-icon name="chevron-left" size="16" strokeWidth="2" />
                    </button>

                    @for (item of list.transformedRange(); track item) {
                        <button class="Button" rdxPaginationListItem [value]="item.value">{{ item.value }}</button>
                    }

                    <button class="Button" rdxPaginationNext style="margin-left: 16px;">
                        <lucide-icon name="chevron-right" size="16" strokeWidth="2" />
                    </button>
                    <button class="Button" rdxPaginationLast>
                        <lucide-icon name="chevrons-right" size="16" strokeWidth="2" />
                    </button>
                </div>
            </div>
        `
    })
};

export const WithEllipsis: Story = {
    render: () => ({
        template: `
            <div rdxPaginationRoot total="100" siblingCount="1" defaultPage="2" showEdges itemsPerPage="10">
                <div class="PaginationList" rdxPaginationList #list="rdxPaginationList">
                    <button class="Button" rdxPaginationFirst>
                        <lucide-icon name="chevrons-left" size="16" strokeWidth="2" />
                    </button>
                    <button class="Button" rdxPaginationPrev style="margin-right: 16px;">
                        <lucide-icon name="chevron-left" size="16" strokeWidth="2" />
                    </button>

                    @for (item of list.transformedRange(); track item) {
                        @if (item.type == 'page') {
                            <button class="Button" rdxPaginationListItem [value]="item.value">{{ item.value }}</button>
                        } @else {
                            <div class="PaginationEllipsis" rdxPaginationEllipsis>&#8230;</div>
                        }
                    }

                    <button class="Button" rdxPaginationNext style="margin-left: 16px;">
                        <lucide-icon name="chevron-right" size="16" strokeWidth="2" />
                    </button>
                    <button class="Button" rdxPaginationLast>
                        <lucide-icon name="chevrons-right" size="16" strokeWidth="2" />
                    </button>
                </div>
            </div>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/pagination/src/pagination-context.token.ts
```typescript
import { computed, inject, InjectionToken, model } from '@angular/core';

export interface PaginationRootContext {
    page: ReturnType<typeof model<number>>;
    onPageChange: (value: number) => void;
    pageCount: ReturnType<typeof computed<number>>;
    siblingCount: ReturnType<typeof computed<number>>;
    disabled: ReturnType<typeof computed<boolean>>;
    showEdges: ReturnType<typeof computed<boolean>>;
}

export const PAGINATION_ROOT_CONTEXT = new InjectionToken<PaginationRootContext>('PaginationRootContext');

export function injectPaginationRootContext(): PaginationRootContext {
    return inject(PAGINATION_ROOT_CONTEXT);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/pagination/src/pagination-ellipsis.directive.ts
```typescript
import { Directive } from '@angular/core';

@Directive({
    selector: '[rdxPaginationEllipsis]',
    host: {
        '[attr.data-type]': '"ellipsis"'
    }
})
export class RdxPaginationEllipsisDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/pagination/src/pagination-first.directive.ts
```typescript
import { computed, Directive } from '@angular/core';
import { injectPaginationRootContext } from './pagination-context.token';

// as Button
@Directive({
    selector: '[rdxPaginationFirst]',
    host: {
        '[attr.aria-label]': '"First Page"',

        '[disabled]': 'disabled()',
        '(click)': 'onClick()'
    }
})
export class RdxPaginationFirstDirective {
    private readonly rootContext = injectPaginationRootContext();

    readonly disabled = computed(() => this.rootContext.page() === 1 || this.rootContext.disabled());

    onClick() {
        if (!this.disabled()) {
            this.rootContext.onPageChange(1);
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/pagination/src/pagination-last.directive.ts
```typescript
import { computed, Directive } from '@angular/core';
import { injectPaginationRootContext } from './pagination-context.token';

// as Button
@Directive({
    selector: '[rdxPaginationLast]',
    host: {
        '[attr.aria-label]': '"Last Page"',

        '[disabled]': 'disabled()',
        '(click)': 'onClick()'
    }
})
export class RdxPaginationLastDirective {
    private readonly rootContext = injectPaginationRootContext();

    readonly disabled = computed(
        () => this.rootContext.page() === this.rootContext.pageCount() || this.rootContext.disabled()
    );

    onClick() {
        if (!this.disabled()) {
            this.rootContext.onPageChange(this.rootContext.pageCount());
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/pagination/src/pagination-list-item.directive.ts
```typescript
import { computed, Directive, input } from '@angular/core';
import { injectPaginationRootContext } from './pagination-context.token';

// as Button
@Directive({
    selector: '[rdxPaginationListItem]',
    host: {
        '[data-type]': '"page"',

        '[attr.aria-label]': '"Page " + value()',
        '[attr.aria-current]': 'isSelected() ? "page" : undefined',
        '[attr.data-selected]': 'isSelected() ? true : undefined',

        '[disabled]': 'disabled()',
        '(click)': 'onClick()'
    }
})
export class RdxPaginationListItemDirective {
    private readonly rootContext = injectPaginationRootContext();

    readonly value = input<number>();

    readonly disabled = computed(() => this.rootContext.disabled());

    readonly isSelected = computed(() => this.rootContext.page() === this.value());

    onClick() {
        const pageValue = this.value();
        if (!this.disabled() && typeof pageValue === 'number') {
            this.rootContext.onPageChange(pageValue);
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/pagination/src/pagination-list.directive.ts
```typescript
import { computed, Directive } from '@angular/core';
import { injectPaginationRootContext } from './pagination-context.token';
import { getRange, transform } from './utils';

@Directive({
    selector: '[rdxPaginationList]',
    exportAs: 'rdxPaginationList'
})
export class RdxPaginationListDirective {
    private readonly rootContext = injectPaginationRootContext();

    readonly transformedRange = computed(() => {
        return transform(
            getRange(
                this.rootContext.page(),
                this.rootContext.pageCount(),
                this.rootContext.siblingCount(),
                this.rootContext.showEdges()
            )
        );
    });
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/pagination/src/pagination-next.directive.ts
```typescript
import { computed, Directive } from '@angular/core';
import { injectPaginationRootContext } from './pagination-context.token';

// as Button
@Directive({
    selector: '[rdxPaginationNext]',
    host: {
        '[attr.aria-label]': '"Next Page"',

        '[disabled]': 'disabled()',
        '(click)': 'onClick()'
    }
})
export class RdxPaginationNextDirective {
    private readonly rootContext = injectPaginationRootContext();

    readonly disabled = computed(
        () => this.rootContext.page() === this.rootContext.pageCount() || this.rootContext.disabled()
    );

    onClick() {
        if (!this.disabled()) {
            this.rootContext.onPageChange(this.rootContext.page() + 1);
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/pagination/src/pagination-prev.directive.ts
```typescript
import { computed, Directive } from '@angular/core';
import { injectPaginationRootContext } from './pagination-context.token';

// as Button
@Directive({
    selector: '[rdxPaginationPrev]',
    host: {
        '[attr.aria-label]': '"Previous Page"',

        '[disabled]': 'disabled()',
        '(click)': 'onClick()'
    }
})
export class RdxPaginationPrevDirective {
    private readonly rootContext = injectPaginationRootContext();

    readonly disabled = computed(() => this.rootContext.page() === 1 || this.rootContext.disabled());

    onClick() {
        if (!this.disabled()) {
            this.rootContext.onPageChange(this.rootContext.page() - 1);
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/pagination/src/pagination-root.directive.ts
```typescript
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import {
    booleanAttribute,
    computed,
    Directive,
    forwardRef,
    input,
    model,
    numberAttribute,
    output
} from '@angular/core';
import { PAGINATION_ROOT_CONTEXT } from './pagination-context.token';

@Directive({
    selector: '[rdxPaginationRoot]',
    exportAs: 'rdxPaginationRoot',
    providers: [
        { provide: PAGINATION_ROOT_CONTEXT, useExisting: forwardRef(() => RdxPaginationRootDirective) }]
})
export class RdxPaginationRootDirective {
    readonly defaultPage = input<number, NumberInput>(1, { transform: numberAttribute });

    readonly page = model<number>(this.defaultPage());

    readonly itemsPerPage = input<number, NumberInput>(undefined, { transform: numberAttribute });

    readonly total = input<number, NumberInput>(0, { transform: numberAttribute });

    readonly siblingCount = input<number, NumberInput>(2, { transform: numberAttribute });

    readonly disabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    readonly showEdges = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    readonly updatePage = output<number>();

    /** @ignore */
    readonly pageCount = computed(() => Math.max(1, Math.ceil(this.total() / (this.itemsPerPage() || 1))));

    /** @ignore */
    onPageChange(value: number) {
        if (!this.disabled()) {
            this.page.set(value);
            this.updatePage.emit(value);
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/pagination/src/utils.ts
```typescript
// reference https://github.com/chakra-ui/zag/blob/main/packages/machines/pagination/src/pagination.utils.ts

type Pages = Array<{ type: 'ellipsis' } | { type: 'page'; value: number }>;

function range(start: number, end: number) {
    const length = end - start + 1;
    return Array.from({ length }, (_, idx) => idx + start);
}

export function transform(items: (string | number)[]): Pages {
    return items.map((value) => {
        if (typeof value === 'number') return { type: 'page', value };
        return { type: 'ellipsis' };
    });
}

const ELLIPSIS = 'ellipsis';

export function getRange(currentPage: number, pageCount: number, siblingCount: number, showEdges: boolean) {
    const firstPageIndex = 1;
    const lastPageIndex = pageCount;

    const leftSiblingIndex = Math.max(currentPage - siblingCount, firstPageIndex);
    const rightSiblingIndex = Math.min(currentPage + siblingCount, lastPageIndex);

    if (showEdges) {
        /**
         * `2 * siblingCount + 5` explanation:
         * 2 * siblingCount for left/right siblings
         * 5 for 2x left/right ellipsis, 2x first/last page + 1x current page
         *
         * For some page counts (e.g. totalPages: 8, siblingCount: 2),
         * calculated max page is higher than total pages,
         * so we need to take the minimum of both.
         */
        const totalPageNumbers = Math.min(2 * siblingCount + 5, pageCount);

        const itemCount = totalPageNumbers - 2; // 2 stands for one ellipsis and either first or last page

        const showLeftEllipsis =
            // default condition
            leftSiblingIndex > firstPageIndex + 2 &&
            // if the current page is towards the end of the list
            Math.abs(lastPageIndex - itemCount - firstPageIndex + 1) > 2 &&
            // if the current page is towards the middle of the list
            Math.abs(leftSiblingIndex - firstPageIndex) > 2;

        const showRightEllipsis =
            // default condition
            rightSiblingIndex < lastPageIndex - 2 &&
            // if the current page is towards the start of the list
            Math.abs(lastPageIndex - itemCount) > 2 &&
            // if the current page is towards the middle of the list
            Math.abs(lastPageIndex - rightSiblingIndex) > 2;

        if (!showLeftEllipsis && showRightEllipsis) {
            const leftRange = range(1, itemCount);

            return [...leftRange, ELLIPSIS, lastPageIndex];
        }

        if (showLeftEllipsis && !showRightEllipsis) {
            const rightRange = range(lastPageIndex - itemCount + 1, lastPageIndex);

            return [firstPageIndex, ELLIPSIS, ...rightRange];
        }

        if (showLeftEllipsis && showRightEllipsis) {
            const middleRange = range(leftSiblingIndex, rightSiblingIndex);

            return [firstPageIndex, ELLIPSIS, ...middleRange, ELLIPSIS, lastPageIndex];
        }

        const fullRange = range(firstPageIndex, lastPageIndex);
        return fullRange;
    } else {
        const itemCount = siblingCount * 2 + 1;

        if (pageCount < itemCount) return range(1, lastPageIndex);
        else if (currentPage <= siblingCount + 1) return range(firstPageIndex, itemCount);
        else if (pageCount - currentPage <= siblingCount) return range(pageCount - itemCount + 1, lastPageIndex);
        else return range(leftSiblingIndex, rightSiblingIndex);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/README.md
```
# @radix-ng/primitives/tooltip

Secondary entry point of `@radix-ng/primitives`. It can be used by importing from `@radix-ng/primitives/tooltip`.

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/index.ts
```typescript
import { NgModule } from '@angular/core';
import { RdxTooltipAnchorDirective } from './src/tooltip-anchor.directive';
import { RdxTooltipArrowDirective } from './src/tooltip-arrow.directive';
import { RdxTooltipCloseDirective } from './src/tooltip-close.directive';
import { RdxTooltipContentAttributesComponent } from './src/tooltip-content-attributes.component';
import { RdxTooltipContentDirective } from './src/tooltip-content.directive';
import { RdxTooltipRootDirective } from './src/tooltip-root.directive';
import { RdxTooltipTriggerDirective } from './src/tooltip-trigger.directive';

export * from './src/tooltip-anchor.directive';
export * from './src/tooltip-arrow.directive';
export * from './src/tooltip-close.directive';
export * from './src/tooltip-content-attributes.component';
export * from './src/tooltip-content.directive';
export * from './src/tooltip-root.directive';
export * from './src/tooltip-trigger.directive';

const _imports = [
    RdxTooltipArrowDirective,
    RdxTooltipCloseDirective,
    RdxTooltipContentDirective,
    RdxTooltipTriggerDirective,
    RdxTooltipRootDirective,
    RdxTooltipAnchorDirective,
    RdxTooltipContentAttributesComponent
];

@NgModule({
    imports: [..._imports],
    exports: [..._imports]
})
export class RdxTooltipModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/stories/tooltip-anchor.component.ts
```typescript
import { Component, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { LucideAngularModule, MapPin, MapPinPlus, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxTooltipModule } from '../index';
import { RdxTooltipAnchorDirective } from '../src/tooltip-anchor.directive';
import { RdxTooltipContentAttributesComponent } from '../src/tooltip-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-tooltip-anchor',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxTooltipModule,
        LucideAngularModule,
        RdxTooltipContentAttributesComponent,
        WithOptionPanelComponent,
        RdxTooltipAnchorDirective
    ],
    styles: styles(),
    template: `
        <p class="ExampleSubtitle">Internal Anchor (within TooltipRoot)</p>
        <tooltip-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container
                    #root1="rdxTooltipRoot"
                    [openDelay]="openDelay()"
                    [closeDelay]="closeDelay()"
                    rdxTooltipRoot
                >
                    <button class="reset IconButton InternalAnchor" rdxTooltipAnchor>
                        <lucide-angular [img]="LucideMapPinPlusInside" size="16" style="display: flex" />
                    </button>

                    <button class="reset IconButton" rdxTooltipTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxTooltipContent
                    >
                        <div class="TooltipContent" rdxTooltipContentAttributes>
                            <button class="reset TooltipClose" rdxTooltipClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="12" style="display: flex" />
                            </button>
                            Add to library
                            <div
                                class="TooltipArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxTooltipArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="TooltipId">ID: {{ rootDirective1()?.uniqueId() }}</div>
        </tooltip-with-option-panel>

        <p class="ExampleSubtitle">External Anchor (outside TooltipRoot)</p>
        <tooltip-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <button class="reset IconButton ExternalAnchor" #externalAnchor="rdxTooltipAnchor" rdxTooltipAnchor>
                    <lucide-angular [img]="LucideMapPinPlus" size="16" style="display: flex" />
                </button>

                <ng-container
                    #root2="rdxTooltipRoot"
                    [anchor]="externalAnchor"
                    [openDelay]="openDelay()"
                    [closeDelay]="closeDelay()"
                    rdxTooltipRoot
                >
                    <button class="reset IconButton" rdxTooltipTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxTooltipContent
                    >
                        <div class="TooltipContent" rdxTooltipContentAttributes>
                            <button class="reset TooltipClose" rdxTooltipClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="12" style="display: flex" />
                            </button>
                            Add to library
                            <div
                                class="TooltipArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxTooltipArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="TooltipId">ID: {{ rootDirective2()?.uniqueId() }}</div>
        </tooltip-with-option-panel>
    `
})
export class RdxTooltipAnchorComponent extends OptionPanelBase {
    readonly rootDirective1 = viewChild('root1');
    readonly rootDirective2 = viewChild('root2');

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;
    readonly LucideMapPinPlusInside = MapPinPlus;
    readonly LucideMapPinPlus = MapPin;
    readonly TriangleAlert = TriangleAlert;
    readonly containerAlert = containerAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/stories/tooltip-animations.component.ts
```typescript
import { Component, signal, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { RdxPositionAlign, RdxPositionSide } from '@radix-ng/primitives/core';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxTooltipModule, RdxTooltipRootDirective } from '../index';
import { RdxTooltipContentAttributesComponent } from '../src/tooltip-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-tooltip-animations',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxTooltipModule,
        LucideAngularModule,
        RdxTooltipContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: styles(true),
    template: `
        <tooltip-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ParamsContainer">
                <input [ngModel]="cssAnimation()" (ngModelChange)="cssAnimation.set($event)" type="checkbox" />
                CSS Animation
                <input
                    [ngModel]="cssOpeningAnimation()"
                    (ngModelChange)="cssOpeningAnimation.set($event)"
                    type="checkbox"
                />
                On Opening Animation
                <input
                    [ngModel]="cssClosingAnimation()"
                    (ngModelChange)="cssClosingAnimation.set($event)"
                    type="checkbox"
                />
                On Closing Animation
            </div>

            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container
                    [cssAnimation]="cssAnimation()"
                    [cssOpeningAnimation]="cssOpeningAnimation()"
                    [cssClosingAnimation]="cssClosingAnimation()"
                    [openDelay]="openDelay()"
                    [closeDelay]="closeDelay()"
                    rdxTooltipRoot
                >
                    <button class="IconButton reset" rdxTooltipTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxTooltipContent
                    >
                        <div class="TooltipContent" rdxTooltipContentAttributes>
                            <button class="TooltipClose reset" rdxTooltipClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            Add to library
                            <div
                                class="TooltipArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxTooltipArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="TooltipId">ID: {{ rootDirective()?.uniqueId() }}</div>
        </tooltip-with-option-panel>
    `
})
export class RdxTooltipAnimationsComponent extends OptionPanelBase {
    readonly rootDirective = viewChild(RdxTooltipRootDirective);

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;

    readonly sides = RdxPositionSide;
    readonly aligns = RdxPositionAlign;

    cssAnimation = signal<boolean>(true);
    cssOpeningAnimation = signal(true);
    cssClosingAnimation = signal(true);
    protected readonly TriangleAlert = TriangleAlert;
    protected readonly containerAlert = containerAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/stories/tooltip-default.component.ts
```typescript
import { Component, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxTooltipModule, RdxTooltipRootDirective } from '../index';
import { RdxTooltipContentAttributesComponent } from '../src/tooltip-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-tooltip-default',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxTooltipModule,
        LucideAngularModule,
        RdxTooltipContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: styles(),
    template: `
        <tooltip-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container [openDelay]="openDelay()" [closeDelay]="closeDelay()" rdxTooltipRoot>
                    <button class="reset IconButton" rdxTooltipTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxTooltipContent
                    >
                        <div class="TooltipContent" rdxTooltipContentAttributes>
                            <button class="reset TooltipClose" rdxTooltipClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="12" style="display: flex" />
                            </button>
                            Add to library
                            <div
                                class="TooltipArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxTooltipArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="TooltipId">ID: {{ rootDirective()?.uniqueId() }}</div>
        </tooltip-with-option-panel>
    `
})
export class RdxTooltipDefaultComponent extends OptionPanelBase {
    readonly rootDirective = viewChild(RdxTooltipRootDirective);

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;
    protected readonly TriangleAlert = TriangleAlert;
    protected readonly containerAlert = containerAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/stories/tooltip-events.components.ts
```typescript
import { Component, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { RdxPositionAlign, RdxPositionSide } from '@radix-ng/primitives/core';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxTooltipModule, RdxTooltipRootDirective } from '../index';
import { RdxTooltipContentAttributesComponent } from '../src/tooltip-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-tooltip-events',
    providers: [provideRdxCdkEventService()],
    imports: [
        RdxTooltipModule,
        LucideAngularModule,
        FormsModule,
        RdxTooltipContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: `
        ${styles()}
    `,
    template: `
        <tooltip-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container [openDelay]="openDelay()" [closeDelay]="closeDelay()" rdxTooltipRoot>
                    <button class="reset IconButton" rdxTooltipTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        [sideOffset]="8"
                        rdxTooltipContent
                    >
                        <div class="TooltipContent" rdxTooltipContentAttributes>
                            <button class="reset TooltipClose" rdxTooltipClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="12" style="display: flex" />
                            </button>
                            Add to library
                            <div
                                class="TooltipArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxTooltipArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="TooltipId">ID: {{ rootDirective()?.uniqueId() }}</div>
        </tooltip-with-option-panel>
    `
})
export class RdxTooltipEventsComponent extends OptionPanelBase {
    readonly rootDirective = viewChild(RdxTooltipRootDirective);

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;

    protected readonly sides = RdxPositionSide;
    protected readonly aligns = RdxPositionAlign;
    protected readonly containerAlert = containerAlert;
    protected readonly TriangleAlert = TriangleAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/stories/tooltip-initially-open.component.ts
```typescript
import { Component, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxTooltipModule, RdxTooltipRootDirective } from '../index';
import { RdxTooltipContentAttributesComponent } from '../src/tooltip-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-tooltip-initially-open',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxTooltipModule,
        LucideAngularModule,
        RdxTooltipContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: styles(),
    template: `
        <tooltip-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container [defaultOpen]="true" [openDelay]="openDelay()" [closeDelay]="closeDelay()" rdxTooltipRoot>
                    <button class="reset IconButton" rdxTooltipTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        [sideOffset]="8"
                        rdxTooltipContent
                    >
                        <div class="TooltipContent" rdxTooltipContentAttributes>
                            <button class="reset TooltipClose" rdxTooltipClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="12" style="display: flex" />
                            </button>
                            Add to library
                            <div
                                class="TooltipArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxTooltipArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="TooltipId">ID: {{ rootDirective()?.uniqueId() }}</div>
        </tooltip-with-option-panel>
    `
})
export class RdxTooltipInitiallyOpenComponent extends OptionPanelBase {
    readonly rootDirective = viewChild(RdxTooltipRootDirective);

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;
    protected readonly containerAlert = containerAlert;
    protected readonly TriangleAlert = TriangleAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/stories/tooltip-multiple.component.ts
```typescript
import { Component, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { RdxPositionAlign, RdxPositionSide } from '@radix-ng/primitives/core';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxTooltipModule } from '../index';
import { RdxTooltipContentAttributesComponent } from '../src/tooltip-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-tooltip-multiple',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxTooltipModule,
        LucideAngularModule,
        RdxTooltipContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: styles(),
    template: `
        <p class="ExampleSubtitle">Tooltip #1</p>
        <tooltip-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container
                    #root1="rdxTooltipRoot"
                    [openDelay]="openDelay()"
                    [closeDelay]="closeDelay()"
                    rdxTooltipRoot
                >
                    <button class="reset IconButton" rdxTooltipTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxTooltipContent
                    >
                        <div class="TooltipContent" rdxTooltipContentAttributes>
                            <button class="reset TooltipClose" rdxTooltipClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="12" style="display: flex" />
                            </button>
                            Add to library
                            <div
                                class="TooltipArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxTooltipArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="TooltipId">ID: {{ rootDirective1()?.uniqueId() }}</div>
        </tooltip-with-option-panel>

        <p class="ExampleSubtitle">Tooltip #2</p>
        <tooltip-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                <code>[side]="'left'"</code>
                <code>[align]="'start'"</code>
                <code>[sideOffset]="16"</code>
                <code>[alignOffset]="16"</code>
            </div>
            <div class="container">
                <ng-container
                    #root2="rdxTooltipRoot"
                    [openDelay]="openDelay()"
                    [closeDelay]="closeDelay()"
                    rdxTooltipRoot
                >
                    <button class="reset IconButton" rdxTooltipTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [side]="RdxPositionSide.Left"
                        [align]="RdxPositionAlign.Start"
                        [sideOffset]="16"
                        [alignOffset]="16"
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxTooltipContent
                    >
                        <div class="TooltipContent" rdxTooltipContentAttributes>
                            <button class="reset TooltipClose" rdxTooltipClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="12" style="display: flex" />
                            </button>
                            Add to library
                            <div
                                class="TooltipArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxTooltipArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="TooltipId">ID: {{ rootDirective2()?.uniqueId() }}</div>
        </tooltip-with-option-panel>

        <p class="ExampleSubtitle">Tooltip #3</p>
        <tooltip-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                <code>[side]="'right'"</code>
                <code>[align]="'end'"</code>
                <code>[sideOffset]="60"</code>
                <code>[alignOffset]="60"</code>
            </div>
            <div class="container">
                <ng-container
                    #root3="rdxTooltipRoot"
                    [openDelay]="openDelay()"
                    [closeDelay]="closeDelay()"
                    rdxTooltipRoot
                >
                    <button class="reset IconButton" rdxTooltipTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [side]="RdxPositionSide.Right"
                        [align]="RdxPositionAlign.End"
                        [sideOffset]="60"
                        [alignOffset]="60"
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxTooltipContent
                    >
                        <div class="TooltipContent" rdxTooltipContentAttributes>
                            <button class="reset TooltipClose" rdxTooltipClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="12" style="display: flex" />
                            </button>
                            Add to library
                            <div
                                class="TooltipArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxTooltipArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="TooltipId">ID: {{ rootDirective3()?.uniqueId() }}</div>
        </tooltip-with-option-panel>
    `
})
export class RdxTooltipMultipleComponent extends OptionPanelBase {
    readonly rootDirective1 = viewChild('root1');
    readonly rootDirective2 = viewChild('root2');
    readonly rootDirective3 = viewChild('root3');

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;
    readonly RdxPositionSide = RdxPositionSide;
    readonly RdxPositionAlign = RdxPositionAlign;
    protected readonly containerAlert = containerAlert;
    protected readonly TriangleAlert = TriangleAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/stories/tooltip-positioning.component.ts
```typescript
import { Component, signal, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { RdxPositionAlign, RdxPositionSide } from '@radix-ng/primitives/core';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxTooltipModule, RdxTooltipRootDirective } from '../index';
import { RdxTooltipContentAttributesComponent } from '../src/tooltip-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-tooltip-positioning',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxTooltipModule,
        LucideAngularModule,
        RdxTooltipContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: styles(),
    template: `
        <tooltip-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ParamsContainer">
                Side:
                <select [ngModel]="selectedSide()" (ngModelChange)="selectedSide.set($event)">
                    <option [value]="sides.Top">{{ sides.Top }}</option>
                    <option [value]="sides.Bottom">{{ sides.Bottom }}</option>
                    <option [value]="sides.Left">{{ sides.Left }}</option>
                    <option [value]="sides.Right">{{ sides.Right }}</option>
                </select>
                Align:
                <select [ngModel]="selectedAlign()" (ngModelChange)="selectedAlign.set($event)">
                    <option [value]="aligns.Center">{{ aligns.Center }}</option>
                    <option [value]="aligns.Start">{{ aligns.Start }}</option>
                    <option [value]="aligns.End">{{ aligns.End }}</option>
                </select>
                SideOffset:
                <input [ngModel]="sideOffset()" (ngModelChange)="sideOffset.set($event)" type="number" />
                AlignOffset:
                <input [ngModel]="alignOffset()" (ngModelChange)="alignOffset.set($event)" type="number" />
            </div>

            <div class="ParamsContainer">
                <input
                    [ngModel]="disableAlternatePositions()"
                    (ngModelChange)="disableAlternatePositions.set($event)"
                    type="checkbox"
                />
                Disable alternate positions (to see the result, scroll the page to make the tooltip cross the viewport
                boundary)
            </div>

            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container [openDelay]="openDelay()" [closeDelay]="closeDelay()" rdxTooltipRoot>
                    <button class="reset IconButton" rdxTooltipTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [sideOffset]="sideOffset()"
                        [alignOffset]="alignOffset()"
                        [side]="selectedSide()"
                        [align]="selectedAlign()"
                        [alternatePositionsDisabled]="disableAlternatePositions()"
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxTooltipContent
                    >
                        <div class="TooltipContent" rdxTooltipContentAttributes>
                            <button class="reset TooltipClose" rdxTooltipClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="12" style="display: flex" />
                            </button>
                            Add to library
                            <div
                                class="TooltipArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxTooltipArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="TooltipId">ID: {{ rootDirective()?.uniqueId() }}</div>
        </tooltip-with-option-panel>
    `
})
export class RdxTooltipPositioningComponent extends OptionPanelBase {
    readonly rootDirective = viewChild(RdxTooltipRootDirective);

    readonly selectedSide = signal(RdxPositionSide.Top);
    readonly selectedAlign = signal(RdxPositionAlign.Center);
    readonly sideOffset = signal<number | undefined>(void 0);
    readonly alignOffset = signal<number | undefined>(void 0);
    readonly disableAlternatePositions = signal(false);

    readonly sides = RdxPositionSide;
    readonly aligns = RdxPositionAlign;

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;
    protected readonly containerAlert = containerAlert;
    protected readonly TriangleAlert = TriangleAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/stories/tooltip-triggering.component.ts
```typescript
import { Component, signal, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxTooltipModule } from '../index';
import { RdxTooltipContentAttributesComponent } from '../src/tooltip-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-tooltip-triggering',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxTooltipModule,
        LucideAngularModule,
        RdxTooltipContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: styles(),
    template: `
        <p class="ExampleSubtitle">Initially closed</p>
        <tooltip-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ParamsContainer">
                <button (mouseup)="triggerOpenFalse()" type="button">Open: {{ isOpenFalse() }}</button>
                onOpenChange count: {{ counterOpenFalse() }}
            </div>

            <div class="ParamsContainer">
                <input
                    [ngModel]="externalControlFalse()"
                    (ngModelChange)="externalControlFalse.set($event)"
                    type="checkbox"
                />
                External control
            </div>

            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container
                    #root1="rdxTooltipRoot"
                    [open]="isOpenFalse()"
                    [openDelay]="openDelay()"
                    [closeDelay]="closeDelay()"
                    [externalControl]="externalControlFalse()"
                    rdxTooltipRoot
                >
                    <button class="reset IconButton" rdxTooltipTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [sideOffset]="8"
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        (onOpen)="countOpenFalse(true)"
                        (onClosed)="countOpenFalse(false)"
                        rdxTooltipContent
                    >
                        <div class="TooltipContent" rdxTooltipContentAttributes>
                            <button class="reset TooltipClose" rdxTooltipClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="12" style="display: flex" />
                            </button>
                            Add to library
                            <div
                                class="TooltipArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxTooltipArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="TooltipId">ID: {{ rootDirective1()?.uniqueId() }}</div>
        </tooltip-with-option-panel>

        <p class="ExampleSubtitle">Initially open</p>
        <tooltip-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ParamsContainer">
                <button (mouseup)="triggerOpenTrue()" type="button">Open: {{ isOpenTrue() }}</button>
                <span>onOpenChange count: {{ counterOpenTrue() }}</span>
            </div>

            <div class="ParamsContainer">
                <input
                    [ngModel]="externalControlTrue()"
                    (ngModelChange)="externalControlTrue.set($event)"
                    type="checkbox"
                />
                External control
            </div>

            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container
                    #root2="rdxTooltipRoot"
                    [open]="isOpenTrue()"
                    [openDelay]="openDelay()"
                    [closeDelay]="closeDelay()"
                    [externalControl]="externalControlTrue()"
                    rdxTooltipRoot
                >
                    <button class="reset IconButton" rdxTooltipTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [sideOffset]="8"
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        (onOpen)="countOpenTrue(true)"
                        (onClosed)="countOpenTrue(false)"
                        rdxTooltipContent
                    >
                        <div class="TooltipContent" rdxTooltipContentAttributes>
                            <button class="reset TooltipClose" rdxTooltipClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="12" style="display: flex" />
                            </button>
                            Add to library
                            <div
                                class="TooltipArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxTooltipArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="TooltipId">ID: {{ rootDirective2()?.uniqueId() }}</div>
        </tooltip-with-option-panel>
    `
})
export class RdxTooltipTriggeringComponent extends OptionPanelBase {
    readonly rootDirective1 = viewChild('root1');
    readonly rootDirective2 = viewChild('root2');

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;

    isOpenFalse = signal(false);
    counterOpenFalse = signal(0);
    externalControlFalse = signal(true);

    isOpenTrue = signal(true);
    counterOpenTrue = signal(0);
    externalControlTrue = signal(true);

    triggerOpenFalse(): void {
        this.isOpenFalse.update((value) => !value);
    }

    countOpenFalse(open: boolean): void {
        this.isOpenFalse.set(open);
        this.counterOpenFalse.update((value) => value + 1);
    }

    triggerOpenTrue(): void {
        this.isOpenTrue.update((value) => !value);
    }

    countOpenTrue(open: boolean): void {
        this.isOpenTrue.set(open);
        this.counterOpenTrue.update((value) => value + 1);
    }

    protected readonly containerAlert = containerAlert;
    protected readonly TriangleAlert = TriangleAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/stories/tooltip.docs.mdx
````
import {ArgTypes, Canvas, Markdown, Meta, Source} from '@storybook/blocks';
import * as TooltipStories from "./tooltip.stories";
import {RdxTooltipRootDirective} from "../src/tooltip-root.directive";
import {RdxTooltipContentDirective} from "../src/tooltip-content.directive";
import {RdxTooltipArrowDirective} from "../src/tooltip-arrow.directive";
import {RdxTooltipAnchorDirective} from "../src/tooltip-anchor.directive";
import {RdxTooltipTriggerDirective} from "../src/tooltip-trigger.directive";
import {RdxTooltipCloseDirective} from "../src/tooltip-close.directive";
import {animationStylesOnly} from "./utils/styles.constants";
import {RdxTooltipContentAttributesComponent} from "../src/tooltip-content-attributes.component";

<Meta title="Primitives/Tooltip" />

# Tooltip

#### A popup that displays information related to an element when the element receives keyboard focus or the mouse hovers over it.

<br />
<br />

## Examples
### Default

<Canvas sourceState="hidden" of={TooltipStories.Default} />

### Multiple

<Canvas sourceState="hidden" of={TooltipStories.Multiple} />

### Events

<Canvas sourceState="hidden" of={TooltipStories.Events} />

### Positioning

<Canvas sourceState="hidden" of={TooltipStories.Positioning} />

### External Triggering

<Canvas sourceState="hidden" of={TooltipStories.ExternalTriggering} />

### Anchor

<Canvas sourceState="hidden" of={TooltipStories.Anchor} />

### Initially Open

<Canvas sourceState="hidden" of={TooltipStories.InitiallyOpen} />

### Animations

<Canvas sourceState="hidden" of={TooltipStories.Animations} />

### Animation Styles

<Source type="code" language="css" code={`${animationStylesOnly}`} />


## Features

- âœ… Opens when the trigger is clicked.
- âœ… Closes when the trigger is clicked again or when pressing escape.
- âœ… Controllable from outside.

## Anatomy

```html
<ng-container rdxTooltipRoot>
    <button class="IconButton" rdxTooltipTrigger>+</button>

    <ng-template rdxTooltipContent>
        <div class="TooltipContent" rdxTooltipContentAttributes>
            <button class="TooltipClose" rdxTooltipClose aria-label="Close">X</button>
            Tooltip Content
            <div class="TooltipArrow" rdxTooltipArrow></div>
        </div>
    </ng-template>
</ng-container>
```

## Import

Get started with importing the directives:

<Source type="code" language="typescript" code={`import {
  RdxTooltipRootDirective,
  RdxTooltipRootTrigger,
  RdxTooltipContentDirective,
  RdxTooltipArrowDirective,
  RdxTooltipAnchorDirective,
  RdxTooltipCloseDirective
} from '@radix-ng/primitives/tooltip';`} />

or

<Source type="code" language="typescript" code={`import { RdxTooltipModule } from '@radix-ng/primitives/tooltip';`} />

## API Reference

### Root
`RdxTooltipRootDirective`

Contains all the parts of a tooltip.

<ArgTypes of={RdxTooltipRootDirective} />

### Trigger
`RdxTooltipTriggerDirective`

The button that toggles the tooltip. By default, the TooltipContent will position itself against the trigger.

<Markdown>
{`
| Data attribute | Value          |
|----------------|----------------|
| [data-state]   | <code>"closed" | "open" (type RdxTooltipState)</code>
`}
</Markdown>

### Anchor
`RdxTooltipAnchorDirective`

An optional element to position the TooltipContent against. If this part is not used, the content will position alongside the TooltipTrigger.

### Content
`RdxTooltipContentDirective`

The component that pops out when the tooltip is open.

<ArgTypes of={RdxTooltipContentDirective} />

### Content Attributes
`RdxTooltipContentAttributesComponent`

A component with the content attributes that are necessary to run animations.

<ArgTypes of={RdxTooltipContentAttributesComponent} />

<Markdown>
{`
| Data attribute | Value          |
|----------------|----------------|
| [data-state]   | <code>"closed" | "open" (enum RdxTooltipState)</code>
| [data-side]    | <code>"left"   | "right" | "bottom" | "top" (enum RdxPositionSide)</code>
| [data-align]   | <code>"start"  | "end" | "center" (enum RdxPositionAlign)</code>
`}
</Markdown>

### Arrow
`RdxTooltipArrowDirective`

An optional arrow element to render alongside the tooltip. This can be used to help visually link the trigger with the TooltipContent. Must be rendered inside TooltipContent.

<ArgTypes of={RdxTooltipArrowDirective} />

### Close
`RdxTooltipCloseDirective`

An optional close button element to render alongside the tooltip. This can be used to close the TooltipContent. Must be rendered inside TooltipContent.

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/stories/tooltip.stories.ts
```typescript
import { provideAnimations } from '@angular/platform-browser/animations';
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { LucideAngularModule, MountainSnow, X } from 'lucide-angular';
import { RdxTooltipModule } from '../index';
import { RdxTooltipAnchorComponent } from './tooltip-anchor.component';
import { RdxTooltipAnimationsComponent } from './tooltip-animations.component';
import { RdxTooltipDefaultComponent } from './tooltip-default.component';
import { RdxTooltipEventsComponent } from './tooltip-events.components';
import { RdxTooltipInitiallyOpenComponent } from './tooltip-initially-open.component';
import { RdxTooltipMultipleComponent } from './tooltip-multiple.component';
import { RdxTooltipPositioningComponent } from './tooltip-positioning.component';
import { RdxTooltipTriggeringComponent } from './tooltip-triggering.component';

const html = String.raw;

export default {
    title: 'Primitives/Tooltip',
    decorators: [
        moduleMetadata({
            imports: [
                RdxTooltipModule,
                RdxTooltipDefaultComponent,
                RdxTooltipEventsComponent,
                RdxTooltipPositioningComponent,
                RdxTooltipTriggeringComponent,
                RdxTooltipMultipleComponent,
                RdxTooltipAnimationsComponent,
                RdxTooltipInitiallyOpenComponent,
                RdxTooltipAnchorComponent,
                LucideAngularModule,
                LucideAngularModule.pick({ MountainSnow, X })
            ],
            providers: [provideAnimations()]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div
                    class="radix-themes light light-theme radix-themes-default-fonts"
                    data-accent-color="indigo"
                    data-radius="medium"
                    data-scaling="100%"
                >
                    ${story}
                </div>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: html`
            <rdx-tooltip-default></rdx-tooltip-default>
        `
    })
};

export const Multiple: Story = {
    render: () => ({
        template: html`
            <rdx-tooltip-multiple></rdx-tooltip-multiple>
        `
    })
};

export const Events: Story = {
    render: () => ({
        template: html`
            <rdx-tooltip-events></rdx-tooltip-events>
        `
    })
};

export const Positioning: Story = {
    render: () => ({
        template: html`
            <rdx-tooltip-positioning></rdx-tooltip-positioning>
        `
    })
};

export const ExternalTriggering: Story = {
    render: () => ({
        template: html`
            <rdx-tooltip-triggering></rdx-tooltip-triggering>
        `
    })
};

export const Anchor: Story = {
    render: () => ({
        template: html`
            <rdx-tooltip-anchor></rdx-tooltip-anchor>
        `
    })
};

export const InitiallyOpen: Story = {
    render: () => ({
        template: html`
            <rdx-tooltip-initially-open></rdx-tooltip-initially-open>
        `
    })
};

export const Animations: Story = {
    render: () => ({
        template: html`
            <rdx-tooltip-animations></rdx-tooltip-animations>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/stories/utils/constants.ts
```typescript
export const containerAlert =
    'For the sake of option panels to play with the stories, the "onOverlayEscapeKeyDown" & "onOverlayOutsideClick" events are limited to the area inside the rectangle marked with a dashed line - the events work when the area is active (focused)';

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/stories/utils/containers.registry.ts
```typescript
import { isDevMode } from '@angular/core';
import { RdxTooltipRootDirective } from '../../src/tooltip-root.directive';
import { injectRdxCdkEventService } from '../../src/utils/cdk-event.service';

const containerRegistry: Map<HTMLElement, RdxTooltipRootDirective> = new Map();
let rdxCdkEventService: ReturnType<typeof injectRdxCdkEventService> | undefined = void 0;

const domRootClickEventCallback: (event: MouseEvent) => void = (event: MouseEvent) => {
    const target = event.target as HTMLElement;
    const containers = Array.from(containerRegistry.keys());
    const containerContainingTarget = containers
        .map((container) => {
            container.classList.remove('focused');
            return container;
        })
        .find((container) => {
            return container.contains(target);
        });
    containerContainingTarget?.classList.add('focused');
    Array.from(containerRegistry.entries()).forEach((item) => {
        if (item[0] === containerContainingTarget) {
            rdxCdkEventService?.allowPrimitiveForCdkMultiEvents(item[1], [
                'cdkOverlayOutsideClick',
                'cdkOverlayEscapeKeyDown'
            ]);
        } else {
            rdxCdkEventService?.preventPrimitiveFromCdkMultiEvents(item[1], [
                'cdkOverlayOutsideClick',
                'cdkOverlayEscapeKeyDown'
            ]);
        }
    });
};

export function registerContainer(container: HTMLElement, root: RdxTooltipRootDirective) {
    if (containerRegistry.has(container)) {
        return;
    }
    containerRegistry.set(container, root);
    if (containerRegistry.size === 1) {
        rdxCdkEventService?.addClickDomRootEventCallback(domRootClickEventCallback);
    }
}

export function deregisterContainer(container: HTMLElement) {
    if (!containerRegistry.has(container)) {
        return;
    }
    containerRegistry.delete(container);
    if (containerRegistry.size === 0) {
        rdxCdkEventService?.removeClickDomRootEventCallback(domRootClickEventCallback);
        unsetRdxCdkEventService();
    }
}

export function setRdxCdkEventService(service: typeof rdxCdkEventService) {
    isDevMode() && console.log('setRdxCdkEventService', service, rdxCdkEventService === service);
    rdxCdkEventService ??= service;
}

export function unsetRdxCdkEventService() {
    rdxCdkEventService = void 0;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/stories/utils/option-panel-base.class.ts
```typescript
import { afterNextRender, DestroyRef, Directive, ElementRef, inject, signal, viewChildren } from '@angular/core';
import { injectDocument, RDX_POSITIONING_DEFAULTS } from '@radix-ng/primitives/core';
import { RdxTooltipRootDirective } from '../../src/tooltip-root.directive';
import { injectRdxCdkEventService } from '../../src/utils/cdk-event.service';
import { deregisterContainer, registerContainer, setRdxCdkEventService } from './containers.registry';
import { IArrowDimensions, IIgnoreClickOutsideContainer, IOpenCloseDelay } from './types';

@Directive()
export abstract class OptionPanelBase implements IIgnoreClickOutsideContainer, IArrowDimensions, IOpenCloseDelay {
    onOverlayEscapeKeyDownDisabled = signal(false);
    onOverlayOutsideClickDisabled = signal(false);

    arrowWidth = signal(RDX_POSITIONING_DEFAULTS.arrow.width);
    arrowHeight = signal(RDX_POSITIONING_DEFAULTS.arrow.height);

    openDelay = signal(500);
    closeDelay = signal(200);

    readonly elementRef = inject<ElementRef<HTMLElement>>(ElementRef);
    readonly destroyRef = inject(DestroyRef);
    readonly rootDirectives = viewChildren(RdxTooltipRootDirective);
    readonly document = injectDocument();
    readonly rdxCdkEventService = injectRdxCdkEventService();

    protected constructor() {
        afterNextRender(() => {
            this.elementRef.nativeElement.querySelectorAll<HTMLElement>('.container').forEach((container) => {
                const rootInsideContainer = this.rootDirectives().find((rootDirective) =>
                    container.contains(rootDirective.triggerDirective().elementRef.nativeElement)
                );
                if (rootInsideContainer) {
                    setRdxCdkEventService(this.rdxCdkEventService);
                    registerContainer(container, rootInsideContainer);
                    this.destroyRef.onDestroy(() => deregisterContainer(container));
                }
            });
        });
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/stories/utils/styles.constants.ts
```typescript
const appliedAnimations = `
.TooltipContent[data-state='open'][data-side='top'] {
    animation-name: rdxSlideDownAndFade;
}

.TooltipContent[data-state='open'][data-side='right'] {
    animation-name: rdxSlideLeftAndFade;
}

.TooltipContent[data-state='open'][data-side='bottom'] {
    animation-name: rdxSlideUpAndFade;
}

.TooltipContent[data-state='open'][data-side='left'] {
    animation-name: rdxSlideRightAndFade;
}

.TooltipContent[data-state='closed'][data-side='top'] {
    animation-name: rdxSlideDownAndFadeReverse;
}

.TooltipContent[data-state='closed'][data-side='right'] {
    animation-name: rdxSlideLeftAndFadeReverse;
}

.TooltipContent[data-state='closed'][data-side='bottom'] {
    animation-name: rdxSlideUpAndFadeReverse;
}

.TooltipContent[data-state='closed'][data-side='left'] {
    animation-name: rdxSlideRightAndFadeReverse;
}
`;

const animationParams = `
.TooltipContent {
    animation-duration: 400ms;
    animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
    will-change: transform, opacity;
}
`;

const animationDefs = `
/* Opening animations */

@keyframes rdxSlideUpAndFade {
    from {
        opacity: 0;
        transform: translateY(2px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes rdxSlideRightAndFade {
    from {
        opacity: 0;
        transform: translateX(-2px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

@keyframes rdxSlideDownAndFade {
    from {
        opacity: 0;
        transform: translateY(-2px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes rdxSlideLeftAndFade {
    from {
        opacity: 0;
        transform: translateX(2px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

/* Closing animations */

@keyframes rdxSlideUpAndFadeReverse {
    from {
        opacity: 1;
        transform: translateY(0);
    }
    to {
        opacity: 0;
        transform: translateY(2px);
    }
}

@keyframes rdxSlideRightAndFadeReverse {
    from {
        opacity: 1;
        transform: translateX(0);
    }
    to {
        opacity: 0;
        transform: translateX(-2px);
    }
}

@keyframes rdxSlideDownAndFadeReverse {
    from {
        opacity: 1;
        transform: translateY(0);
    }
    to {
        opacity: 0;
        transform: translateY(-2px);
    }
}

@keyframes rdxSlideLeftAndFadeReverse {
    from {
        opacity: 1;
        transform: translateX(0);
    }
    to {
        opacity: 0;
        transform: translateX(2px);
    }
}
`;

const events = `
/* =============== Event messages =============== */

.MessagesContainer {
    padding: 20px;
}

.Message {
    color: var(--white-a12);
    font-size: 15px;
    line-height: 19px;
    font-weight: bolder;
}

.MessageId {
    font-size: 75%;
    font-weight: light;
}
`;

const params = `
/* =============== Params layout =============== */

.ParamsContainer {
    display: flex;
    column-gap: 8px;
    color: var(--white-a12);
    padding-bottom: 32px;
}
`;

function styles(withAnimations = false, withEvents = false, withParams = true) {
    return `
.container {
    height: 150px;
    display: flex;
    justify-content: center;
    gap: 80px;
    align-items: center;
    border: 3px dashed var(--white-a8);
    border-radius: 12px;
    &.focused {
        border-color: var(--white-a12);
        -webkit-box-shadow: 0px 0px 24px 0px var(--white-a12);
        -moz-box-shadow: 0px 0px 24px 0px var(--white-a12);
        box-shadow: 0px 0px 24px 0px var(--white-a12);
    }
}

.ContainerAlerts {
    display: flex;
    gap: 6px;
    color: var(--white-a8);
    font-size: 16px;
    line-height: 16px;
    margin: 0 0 24px 0;
}

/* reset */
.reset {
    all: unset;
}

.ExampleSubtitle {
    color: var(--white-a12);
    font-size: 22px;
    line-height: 26px;
    font-weight: bolder;
    margin: 46px 0 34px 16px;
    padding-top: 22px;
    &:not(:first-child) {
        border-top: 2px solid var(--gray-a8);
    }
    &:first-child {
        margin-top: 0;
    }
}

.TooltipId {
    color: var(--white-a12);
    font-size: 12px;
    line-height: 14px;
    font-weight: 800;
    margin: 1px 0 24px 22px;
}

.TooltipContent {
    border-radius: 4px;
    padding: 10px 15px;
    font-size: 15px;
    line-height: 1;
    background-color: white;
    box-shadow:
        hsl(206 22% 7% / 35%) 0px 10px 38px -10px,
        hsl(206 22% 7% / 20%) 0px 10px 20px -15px;
}

${withAnimations ? animationParams : ''}

${withAnimations ? appliedAnimations : ''}

.TooltipContent:focus {
    box-shadow:
        hsl(206 22% 7% / 35%) 0px 10px 38px -10px,
        hsl(206 22% 7% / 20%) 0px 10px 20px -15px,
        0 0 0 2px var(--violet-7);
}

.TooltipArrow {
    fill: white;
}

.TooltipClose {
    font-family: inherit;
    border-radius: 100%;
    background-color: var(--white-a12);
    height: 14px;
    width: 14px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: var(--violet-11);
    position: absolute;
    top: -12px;
    right: -12px;
}

.TooltipClose:hover {
    background-color: var(--violet-4);
}

.TooltipClose:focus {
    box-shadow: 0 0 0 2px var(--violet-7);
}

.IconButton {
    font-family: inherit;
    border-radius: 100%;
    height: 35px;
    width: 35px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: var(--violet-11);
    background-color: white;
    box-shadow: 0 2px 10px var(--black-a7);
}

.IconButton:hover {
    background-color: var(--violet-3);
}

.IconButton:focus {
    box-shadow: 0 0 0 2px black;
}

.Fieldset {
    display: flex;
    gap: 20px;
    align-items: center;
}

.Label {
    font-size: 13px;
    color: var(--violet-11);
    width: 75px;
}

.Input {
    width: 100%;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    border-radius: 4px;
    padding: 0 10px;
    font-size: 13px;
    line-height: 1;
    color: var(--violet-11);
    box-shadow: 0 0 0 1px var(--violet-7);
    height: 25px;
}

.Input:focus {
    box-shadow: 0 0 0 2px var(--violet-8);
}

.Text {
    margin: 0;
    color: var(--mauve-12);
    font-size: 15px;
    line-height: 19px;
    font-weight: 500;
}

${withAnimations ? animationDefs : ''}

${withParams ? params : ''}

${withEvents ? events : ''}
`;
}

export const animationStylesOnly = `
${animationParams}

${appliedAnimations}

${animationDefs}
`;

export const paramsAndEventsOnly = `
${params}

${events}
`;

export default styles;

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/stories/utils/types.ts
```typescript
import { DestroyRef, ElementRef, Signal } from '@angular/core';
import { RdxTooltipRootDirective } from '../../src/tooltip-root.directive';
import { injectRdxCdkEventService } from '../../src/utils/cdk-event.service';

export interface IIgnoreClickOutsideContainer {
    onOverlayEscapeKeyDownDisabled: Signal<boolean>;
    onOverlayOutsideClickDisabled: Signal<boolean>;
    elementRef: ElementRef<Element>;
    destroyRef: DestroyRef;
    rootDirectives: Signal<ReadonlyArray<RdxTooltipRootDirective>>;
    document: Document;
    rdxCdkEventService: ReturnType<typeof injectRdxCdkEventService>;
}

export interface IArrowDimensions {
    arrowWidth: Signal<number | undefined>;
    arrowHeight: Signal<number | undefined>;
}

export interface IOpenCloseDelay {
    openDelay: Signal<number | undefined>;
    closeDelay: Signal<number | undefined>;
}

export type Message = { value: string; timeFromPrev: number };

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/stories/utils/with-option-panel.component.ts
```typescript
import { NgTemplateOutlet } from '@angular/common';
import {
    afterNextRender,
    Component,
    computed,
    contentChild,
    ElementRef,
    inject,
    isDevMode,
    model,
    signal
} from '@angular/core';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { RdxTooltipRootDirective } from '../../src/tooltip-root.directive';
import { paramsAndEventsOnly } from './styles.constants';
import { Message } from './types';

@Component({
    selector: 'tooltip-with-option-panel',
    styles: paramsAndEventsOnly,
    template: `
        <ng-content select=".ParamsContainer" />

        @if (paramsContainerCounter() > 3) {
            <hr />
        }

        <div class="ParamsContainer">
            <input
                [ngModel]="onOverlayEscapeKeyDownDisabled()"
                (ngModelChange)="onOverlayEscapeKeyDownDisabled.set($event)"
                type="checkbox"
            />
            Disable (onOverlayEscapeKeyDown) event
            <input
                [ngModel]="onOverlayOutsideClickDisabled()"
                (ngModelChange)="onOverlayOutsideClickDisabled.set($event)"
                type="checkbox"
            />
            Disable (onOverlayOutsideClick) event
        </div>

        <div class="ParamsContainer">
            Arrow width
            <input [ngModel]="arrowWidth()" (ngModelChange)="arrowWidth.set($event)" type="number" />
            Arrow height
            <input [ngModel]="arrowHeight()" (ngModelChange)="arrowHeight.set($event)" type="number" />
        </div>

        <div class="ParamsContainer">
            Open delay
            <input [ngModel]="openDelay()" (ngModelChange)="openDelay.set($event)" type="number" />
            Close delay
            <input [ngModel]="closeDelay()" (ngModelChange)="closeDelay.set($event)" type="number" />
        </div>

        <ng-content />

        @if (messages().length) {
            <button class="SkipOutsideClickPrevention" (click)="messages.set([])" type="button">Clear messages</button>
            <div class="MessagesContainer">
                @for (message of messages(); track i; let i = $index) {
                    <ng-container
                        [ngTemplateOutlet]="messageTpl"
                        [ngTemplateOutletContext]="{ message: message, index: messages().length - i }"
                    />
                }
            </div>
        }

        <ng-template #messageTpl let-message="message" let-index="index">
            <p class="Message">
                {{ index }}.
                <span class="MessageId">[({{ message.timeFromPrev }}ms) TOOLTIP ID {{ rootUniqueId() }}]</span>
                {{ message.value }}
            </p>
        </ng-template>
    `,
    imports: [
        ReactiveFormsModule,
        FormsModule,
        NgTemplateOutlet
    ]
})
export class WithOptionPanelComponent {
    onOverlayEscapeKeyDownDisabled = model(false);
    onOverlayOutsideClickDisabled = model(false);

    arrowWidth = model<number>(0);
    arrowHeight = model<number>(0);

    openDelay = model<number>(0);
    closeDelay = model<number>(0);

    readonly elementRef = inject<ElementRef<HTMLElement>>(ElementRef);

    readonly rootDirective = contentChild.required(RdxTooltipRootDirective);

    readonly paramsContainerCounter = signal(0);

    readonly messages = signal<Message[]>([]);
    readonly rootUniqueId = computed(() => this.rootDirective().uniqueId());

    /**
     * There should be only one container. If there is more, en error is thrown.
     */
    containers: Element[] | undefined = void 0;
    paramsContainers: Element[] | undefined = void 0;

    previousMessageTimestamp: number | undefined = void 0;

    timeFromPrev = () => {
        const now = Date.now();
        const timeFromPrev =
            typeof this.previousMessageTimestamp === 'undefined' ? 0 : Date.now() - this.previousMessageTimestamp;
        this.previousMessageTimestamp = now;
        return timeFromPrev;
    };

    constructor() {
        afterNextRender({
            read: () => {
                this.rootDirective().contentDirective().onOpen.subscribe(this.onOpen);
                this.rootDirective().contentDirective().onClosed.subscribe(this.onClose);
                this.rootDirective().contentDirective().onOverlayOutsideClick.subscribe(this.onOverlayOutsideClick);
                this.rootDirective().contentDirective().onOverlayEscapeKeyDown.subscribe(this.onOverlayEscapeKeyDown);

                /**
                 * There should be only one container. If there is more, en error is thrown.
                 */
                this.containers = Array.from(this.elementRef.nativeElement?.querySelectorAll('.container') ?? []);
                if (this.containers.length > 1) {
                    if (isDevMode()) {
                        console.error('<story>.elementRef.nativeElement', this.elementRef.nativeElement);
                        console.error('<story>.containers', this.containers);
                        throw Error('each story should have only one container!');
                    }
                }
                this.paramsContainers = Array.from(
                    this.elementRef.nativeElement?.querySelectorAll('.ParamsContainer') ?? []
                );

                this.paramsContainerCounter.set(this.paramsContainers.length ?? 0);
            }
        });
    }

    private inContainers(element: Element) {
        return !!this.containers?.find((container) => container.contains(element));
    }

    private inParamsContainers(element: Element) {
        return !!this.paramsContainers?.find((container) => container.contains(element));
    }

    private onOverlayEscapeKeyDown = () => {
        this.addMessage({
            value: `[TooltipRoot] Escape clicked! (disabled: ${this.onOverlayEscapeKeyDownDisabled()})`,
            timeFromPrev: this.timeFromPrev()
        });
    };

    private onOverlayOutsideClick = () => {
        this.addMessage({
            value: `[TooltipRoot] Mouse clicked outside the tooltip! (disabled: ${this.onOverlayOutsideClickDisabled()})`,
            timeFromPrev: this.timeFromPrev()
        });
    };

    private onOpen = () => {
        this.addMessage({ value: '[TooltipContent] Open', timeFromPrev: this.timeFromPrev() });
    };

    private onClose = () => {
        this.addMessage({ value: '[TooltipContent] Closed', timeFromPrev: this.timeFromPrev() });
    };

    protected addMessage = (message: Message) => {
        this.messages.update((messages) => {
            return [
                message,
                ...messages
            ];
        });
    };
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/src/tooltip-anchor.directive.ts
```typescript
import { CdkOverlayOrigin } from '@angular/cdk/overlay';
import { computed, Directive, ElementRef, forwardRef, inject } from '@angular/core';
import { injectDocument } from '@radix-ng/primitives/core';
import { RdxTooltipAnchorToken } from './tooltip-anchor.token';
import { RdxTooltipRootDirective } from './tooltip-root.directive';
import { injectTooltipRoot } from './tooltip-root.inject';

@Directive({
    selector: '[rdxTooltipAnchor]',
    exportAs: 'rdxTooltipAnchor',
    hostDirectives: [CdkOverlayOrigin],
    host: {
        type: 'button',
        '[attr.id]': 'name()',
        '[attr.aria-haspopup]': '"dialog"',
        '(click)': 'click()'
    },
    providers: [
        {
            provide: RdxTooltipAnchorToken,
            useExisting: forwardRef(() => RdxTooltipAnchorDirective)
        }
    ]
})
export class RdxTooltipAnchorDirective {
    /**
     * @ignore
     * If outside the rootDirective then null, otherwise the rootDirective directive - with optional `true` passed in as the first param.
     * If outside the rootDirective and non-null value that means the html structure is wrong - tooltip inside tooltip.
     * */
    protected rootDirective = injectTooltipRoot(true);
    /** @ignore */
    readonly elementRef = inject(ElementRef);
    /** @ignore */
    readonly overlayOrigin = inject(CdkOverlayOrigin);
    /** @ignore */
    readonly document = injectDocument();

    /** @ignore */
    readonly name = computed(() => `rdx-tooltip-external-anchor-${this.rootDirective?.uniqueId()}`);

    /** @ignore */
    click(): void {
        this.emitOutsideClick();
    }

    /** @ignore */
    setRoot(root: RdxTooltipRootDirective) {
        this.rootDirective = root;
    }

    private emitOutsideClick() {
        if (!this.rootDirective?.isOpen() || this.rootDirective?.contentDirective().onOverlayOutsideClickDisabled()) {
            return;
        }
        const clickEvent = new MouseEvent('click', {
            view: this.document.defaultView,
            bubbles: true,
            cancelable: true,
            relatedTarget: this.elementRef.nativeElement
        });
        this.rootDirective?.triggerDirective().elementRef.nativeElement.dispatchEvent(clickEvent);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/src/tooltip-anchor.token.ts
```typescript
import { InjectionToken } from '@angular/core';
import { RdxTooltipAnchorDirective } from './tooltip-anchor.directive';

export const RdxTooltipAnchorToken = new InjectionToken<RdxTooltipAnchorDirective>('RdxTooltipAnchorToken');

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/src/tooltip-arrow.directive.ts
```typescript
import { NumberInput } from '@angular/cdk/coercion';
import { ConnectedOverlayPositionChange } from '@angular/cdk/overlay';
import {
    afterNextRender,
    computed,
    Directive,
    effect,
    ElementRef,
    forwardRef,
    inject,
    input,
    numberAttribute,
    Renderer2,
    signal,
    untracked
} from '@angular/core';
import { toSignal } from '@angular/core/rxjs-interop';
import {
    getArrowPositionParams,
    getSideAndAlignFromAllPossibleConnectedPositions,
    RDX_POSITIONING_DEFAULTS
} from '@radix-ng/primitives/core';
import { RdxTooltipArrowToken } from './tooltip-arrow.token';
import { injectTooltipRoot } from './tooltip-root.inject';

@Directive({
    selector: '[rdxTooltipArrow]',
    providers: [
        {
            provide: RdxTooltipArrowToken,
            useExisting: forwardRef(() => RdxTooltipArrowDirective)
        }
    ]
})
export class RdxTooltipArrowDirective {
    /** @ignore */
    private readonly renderer = inject(Renderer2);
    /** @ignore */
    private readonly rootDirective = injectTooltipRoot();
    /** @ignore */
    readonly elementRef = inject(ElementRef);

    /**
     * @description The width of the arrow in pixels.
     * @default 10
     */
    readonly width = input<number, NumberInput>(RDX_POSITIONING_DEFAULTS.arrow.width, { transform: numberAttribute });

    /**
     * @description The height of the arrow in pixels.
     * @default 5
     */
    readonly height = input<number, NumberInput>(RDX_POSITIONING_DEFAULTS.arrow.height, { transform: numberAttribute });

    /** @ignore */
    readonly arrowSvgElement = computed<HTMLElement>(() => {
        const width = this.width();
        const height = this.height();

        const svgElement = this.renderer.createElement('svg', 'svg');
        this.renderer.setAttribute(svgElement, 'viewBox', '0 0 30 10');
        this.renderer.setAttribute(svgElement, 'width', String(width));
        this.renderer.setAttribute(svgElement, 'height', String(height));
        const polygonElement = this.renderer.createElement('polygon', 'svg');
        this.renderer.setAttribute(polygonElement, 'points', '0,0 30,0 15,10');
        this.renderer.setAttribute(svgElement, 'preserveAspectRatio', 'none');
        this.renderer.appendChild(svgElement, polygonElement);

        return svgElement;
    });

    /** @ignore */
    private readonly currentArrowSvgElement = signal<HTMLOrSVGElement | undefined>(void 0);
    /** @ignore */
    private readonly position = toSignal(this.rootDirective.contentDirective().positionChange());

    /** @ignore */
    private anchorOrTriggerRect: DOMRect;

    constructor() {
        afterNextRender({
            write: () => {
                if (this.elementRef.nativeElement.parentElement) {
                    this.renderer.setStyle(this.elementRef.nativeElement.parentElement, 'position', 'relative');
                }
                this.renderer.setStyle(this.elementRef.nativeElement, 'position', 'absolute');
                this.renderer.setStyle(this.elementRef.nativeElement, 'boxSizing', '');
                this.renderer.setStyle(this.elementRef.nativeElement, 'fontSize', '0px');
            }
        });
        this.onArrowSvgElementChangeEffect();
        this.onContentPositionAndArrowDimensionsChangeEffect();
    }

    /** @ignore */
    private setAnchorOrTriggerRect() {
        this.anchorOrTriggerRect = (
            this.rootDirective.anchorDirective() ?? this.rootDirective.triggerDirective()
        ).elementRef.nativeElement.getBoundingClientRect();
    }

    /** @ignore */
    private setPosition(position: ConnectedOverlayPositionChange, arrowDimensions: { width: number; height: number }) {
        this.setAnchorOrTriggerRect();
        const posParams = getArrowPositionParams(
            getSideAndAlignFromAllPossibleConnectedPositions(position.connectionPair),
            { width: arrowDimensions.width, height: arrowDimensions.height },
            { width: this.anchorOrTriggerRect.width, height: this.anchorOrTriggerRect.height }
        );

        this.renderer.setStyle(this.elementRef.nativeElement, 'top', posParams.top);
        this.renderer.setStyle(this.elementRef.nativeElement, 'bottom', '');
        this.renderer.setStyle(this.elementRef.nativeElement, 'left', posParams.left);
        this.renderer.setStyle(this.elementRef.nativeElement, 'right', '');
        this.renderer.setStyle(this.elementRef.nativeElement, 'transform', posParams.transform);
        this.renderer.setStyle(this.elementRef.nativeElement, 'transformOrigin', posParams.transformOrigin);
    }

    /** @ignore */
    private onArrowSvgElementChangeEffect() {
        effect(() => {
            const arrowElement = this.arrowSvgElement();
            untracked(() => {
                const currentArrowSvgElement = this.currentArrowSvgElement();
                if (currentArrowSvgElement) {
                    this.renderer.removeChild(this.elementRef.nativeElement, currentArrowSvgElement);
                }
                this.currentArrowSvgElement.set(arrowElement);
                this.renderer.setStyle(this.elementRef.nativeElement, 'width', `${this.width()}px`);
                this.renderer.setStyle(this.elementRef.nativeElement, 'height', `${this.height()}px`);
                this.renderer.appendChild(this.elementRef.nativeElement, this.currentArrowSvgElement());
            });
        });
    }

    /** @ignore */
    private onContentPositionAndArrowDimensionsChangeEffect() {
        effect(() => {
            const position = this.position();
            const arrowDimensions = { width: this.width(), height: this.height() };
            untracked(() => {
                if (!position) {
                    return;
                }
                this.setPosition(position, arrowDimensions);
            });
        });
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/src/tooltip-arrow.token.ts
```typescript
import { InjectionToken } from '@angular/core';
import { RdxTooltipArrowDirective } from './tooltip-arrow.directive';

export const RdxTooltipArrowToken = new InjectionToken<RdxTooltipArrowDirective>('RdxTooltipArrowToken');

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/src/tooltip-close.directive.ts
```typescript
import { Directive, effect, ElementRef, forwardRef, inject, Renderer2, untracked } from '@angular/core';
import { RdxTooltipCloseToken } from './tooltip-close.token';
import { injectTooltipRoot } from './tooltip-root.inject';

/**
 * TODO: to be removed? But it seems to be useful when controlled from outside
 */
@Directive({
    selector: '[rdxTooltipClose]',
    host: {
        type: 'button',
        '(click)': 'rootDirective.handleClose(true)'
    },
    providers: [
        {
            provide: RdxTooltipCloseToken,
            useExisting: forwardRef(() => RdxTooltipCloseDirective)
        }
    ]
})
export class RdxTooltipCloseDirective {
    /** @ignore */
    protected readonly rootDirective = injectTooltipRoot();
    /** @ignore */
    readonly elementRef = inject(ElementRef);
    /** @ignore */
    private readonly renderer = inject(Renderer2);

    constructor() {
        this.onIsControlledExternallyEffect();
    }

    /** @ignore */
    private onIsControlledExternallyEffect() {
        effect(() => {
            const isControlledExternally = this.rootDirective.controlledExternally()();

            untracked(() => {
                this.renderer.setStyle(
                    this.elementRef.nativeElement,
                    'display',
                    isControlledExternally ? null : 'none'
                );
            });
        });
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/src/tooltip-close.token.ts
```typescript
import { InjectionToken } from '@angular/core';
import { RdxTooltipCloseDirective } from './tooltip-close.directive';

export const RdxTooltipCloseToken = new InjectionToken<RdxTooltipCloseDirective>('RdxTooltipCloseToken');

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/src/tooltip-content-attributes.component.ts
```typescript
import { ChangeDetectionStrategy, Component, computed, forwardRef } from '@angular/core';
import { RdxTooltipContentAttributesToken } from './tooltip-content-attributes.token';
import { injectTooltipRoot } from './tooltip-root.inject';
import { RdxTooltipAnimationStatus, RdxTooltipState } from './tooltip.types';

@Component({
    selector: '[rdxTooltipContentAttributes]',
    template: `
        <ng-content />
    `,
    host: {
        '[attr.role]': '"dialog"',
        '[attr.id]': 'name()',
        '[attr.data-state]': 'rootDirective.state()',
        '[attr.data-side]': 'rootDirective.contentDirective().side()',
        '[attr.data-align]': 'rootDirective.contentDirective().align()',
        '[style]': 'disableAnimation() ? {animation: "none !important"} : null',
        '(animationstart)': 'onAnimationStart($event)',
        '(animationend)': 'onAnimationEnd($event)',
        '(pointerenter)': 'pointerenter()',
        '(pointerleave)': 'pointerleave()',
        '(focus)': 'focus()',
        '(blur)': 'blur()'
    },
    providers: [
        {
            provide: RdxTooltipContentAttributesToken,
            useExisting: forwardRef(() => RdxTooltipContentAttributesComponent)
        }
    ],
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class RdxTooltipContentAttributesComponent {
    /** @ignore */
    protected readonly rootDirective = injectTooltipRoot();

    /** @ignore */
    readonly name = computed(() => `rdx-tooltip-content-attributes-${this.rootDirective.uniqueId()}`);

    /** @ignore */
    readonly disableAnimation = computed(() => !this.canAnimate());

    /** @ignore */
    protected onAnimationStart(_: AnimationEvent) {
        this.rootDirective.cssAnimationStatus.set(
            this.rootDirective.state() === RdxTooltipState.OPEN
                ? RdxTooltipAnimationStatus.OPEN_STARTED
                : RdxTooltipAnimationStatus.CLOSED_STARTED
        );
    }

    /** @ignore */
    protected onAnimationEnd(_: AnimationEvent) {
        this.rootDirective.cssAnimationStatus.set(
            this.rootDirective.state() === RdxTooltipState.OPEN
                ? RdxTooltipAnimationStatus.OPEN_ENDED
                : RdxTooltipAnimationStatus.CLOSED_ENDED
        );
    }

    /** @ignore */
    protected pointerenter(): void {
        this.rootDirective.handleOpen();
    }

    /** @ignore */
    protected pointerleave(): void {
        this.rootDirective.handleClose();
    }

    /** @ignore */
    protected focus(): void {
        this.rootDirective.handleOpen();
    }

    /** @ignore */
    protected blur(): void {
        this.rootDirective.handleClose();
    }

    /** @ignore */
    private canAnimate() {
        return (
            this.rootDirective.cssAnimation() &&
            ((this.rootDirective.cssOpeningAnimation() && this.rootDirective.state() === RdxTooltipState.OPEN) ||
                (this.rootDirective.cssClosingAnimation() && this.rootDirective.state() === RdxTooltipState.CLOSED))
        );
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/src/tooltip-content-attributes.token.ts
```typescript
import { InjectionToken } from '@angular/core';
import { RdxTooltipContentAttributesComponent } from './tooltip-content-attributes.component';

export const RdxTooltipContentAttributesToken = new InjectionToken<RdxTooltipContentAttributesComponent>(
    'RdxTooltipContentAttributesToken'
);

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/src/tooltip-content.directive.ts
```typescript
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import { CdkConnectedOverlay, Overlay } from '@angular/cdk/overlay';
import {
    booleanAttribute,
    computed,
    DestroyRef,
    Directive,
    effect,
    inject,
    input,
    numberAttribute,
    OnInit,
    output,
    SimpleChange,
    TemplateRef,
    untracked
} from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import {
    getAllPossibleConnectedPositions,
    getContentPosition,
    RDX_POSITIONING_DEFAULTS,
    RdxPositionAlign,
    RdxPositionSide,
    RdxPositionSideAndAlignOffsets
} from '@radix-ng/primitives/core';
import { filter, tap } from 'rxjs';
import { injectTooltipRoot } from './tooltip-root.inject';
import { RdxTooltipAttachDetachEvent } from './tooltip.types';

@Directive({
    selector: '[rdxTooltipContent]',
    hostDirectives: [
        CdkConnectedOverlay
    ]
})
export class RdxTooltipContentDirective implements OnInit {
    /** @ignore */
    private readonly rootDirective = injectTooltipRoot();
    /** @ignore */
    private readonly templateRef = inject(TemplateRef);
    /** @ignore */
    private readonly overlay = inject(Overlay);
    /** @ignore */
    private readonly destroyRef = inject(DestroyRef);
    /** @ignore */
    private readonly connectedOverlay = inject(CdkConnectedOverlay);

    /** @ignore */
    readonly name = computed(() => `rdx-tooltip-trigger-${this.rootDirective.uniqueId()}`);

    /**
     * @description The preferred side of the trigger to render against when open. Will be reversed when collisions occur and avoidCollisions is enabled.
     * @default top
     */
    readonly side = input<RdxPositionSide>(RdxPositionSide.Top);
    /**
     * @description The distance in pixels from the trigger.
     * @default undefined
     */
    readonly sideOffset = input<number, NumberInput>(NaN, {
        transform: numberAttribute
    });
    /**
     * @description The preferred alignment against the trigger. May change when collisions occur.
     * @default center
     */
    readonly align = input<RdxPositionAlign>(RdxPositionAlign.Center);
    /**
     * @description An offset in pixels from the "start" or "end" alignment options.
     * @default undefined
     */
    readonly alignOffset = input<number, NumberInput>(NaN, {
        transform: numberAttribute
    });

    /**
     * @description Whether to add some alternate positions of the content.
     * @default false
     */
    readonly alternatePositionsDisabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /** @description Whether to prevent `onOverlayEscapeKeyDown` handler from calling. */
    readonly onOverlayEscapeKeyDownDisabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });
    /** @description Whether to prevent `onOverlayOutsideClick` handler from calling. */
    readonly onOverlayOutsideClickDisabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * @description Event handler called when the escape key is down.
     * It can be prevented by setting `onOverlayEscapeKeyDownDisabled` input to `true`.
     */
    readonly onOverlayEscapeKeyDown = output<KeyboardEvent>();
    /**
     * @description Event handler called when a pointer event occurs outside the bounds of the component.
     * It can be prevented by setting `onOverlayOutsideClickDisabled` input to `true`.
     */
    readonly onOverlayOutsideClick = output<MouseEvent>();

    /**
     * @description Event handler called after the overlay is open
     */
    readonly onOpen = output<void>();
    /**
     * @description Event handler called after the overlay is closed
     */
    readonly onClosed = output<void>();

    /** @ingore */
    readonly positions = computed(() => this.computePositions());

    constructor() {
        this.onOriginChangeEffect();
        this.onPositionChangeEffect();
    }

    /** @ignore */
    ngOnInit() {
        this.setScrollStrategy();
        this.setHasBackdrop();
        this.setDisableClose();
        this.onAttach();
        this.onDetach();
        this.connectKeydownEscape();
        this.connectOutsideClick();
    }

    /** @ignore */
    open() {
        if (this.connectedOverlay.open) {
            return;
        }
        const prevOpen = this.connectedOverlay.open;
        this.connectedOverlay.open = true;
        this.fireOverlayNgOnChanges('open', this.connectedOverlay.open, prevOpen);
    }

    /** @ignore */
    close() {
        if (!this.connectedOverlay.open) {
            return;
        }
        const prevOpen = this.connectedOverlay.open;
        this.connectedOverlay.open = false;
        this.fireOverlayNgOnChanges('open', this.connectedOverlay.open, prevOpen);
    }

    /** @ignore */
    positionChange() {
        return this.connectedOverlay.positionChange.asObservable();
    }

    /** @ignore */
    private connectKeydownEscape() {
        this.connectedOverlay.overlayKeydown
            .asObservable()
            .pipe(
                filter(
                    () =>
                        !this.onOverlayEscapeKeyDownDisabled() &&
                        !this.rootDirective.rdxCdkEventService?.primitivePreventedFromCdkEvent(
                            this.rootDirective,
                            'cdkOverlayEscapeKeyDown'
                        )
                ),
                filter((event) => event.key === 'Escape'),
                tap((event) => {
                    this.onOverlayEscapeKeyDown.emit(event);
                }),
                filter(() => !this.rootDirective.firstDefaultOpen()),
                tap(() => {
                    this.rootDirective.handleClose();
                }),
                takeUntilDestroyed(this.destroyRef)
            )
            .subscribe();
    }

    /** @ignore */
    private connectOutsideClick() {
        this.connectedOverlay.overlayOutsideClick
            .asObservable()
            .pipe(
                filter(
                    () =>
                        !this.onOverlayOutsideClickDisabled() &&
                        !this.rootDirective.rdxCdkEventService?.primitivePreventedFromCdkEvent(
                            this.rootDirective,
                            'cdkOverlayOutsideClick'
                        )
                ),
                /**
                 * Handle the situation when an anchor is added and the anchor becomes the origin of the overlay
                 * hence  the trigger will be considered the outside element
                 */
                filter((event) => {
                    return (
                        !this.rootDirective.anchorDirective() ||
                        !this.rootDirective
                            .triggerDirective()
                            .elementRef.nativeElement.contains(event.target as Element)
                    );
                }),
                tap((event) => {
                    this.onOverlayOutsideClick.emit(event);
                }),
                filter(() => !this.rootDirective.firstDefaultOpen()),
                tap(() => {
                    this.rootDirective.handleClose();
                }),
                takeUntilDestroyed(this.destroyRef)
            )
            .subscribe();
    }

    /** @ignore */
    private onAttach() {
        this.connectedOverlay.attach
            .asObservable()
            .pipe(
                tap(() => {
                    /**
                     * `this.onOpen.emit();` is being delegated to the rootDirective directive due to the opening animation
                     */
                    this.rootDirective.attachDetachEvent.set(RdxTooltipAttachDetachEvent.ATTACH);
                }),
                takeUntilDestroyed(this.destroyRef)
            )
            .subscribe();
    }

    /** @ignore */
    private onDetach() {
        this.connectedOverlay.detach
            .asObservable()
            .pipe(
                tap(() => {
                    /**
                     * `this.onClosed.emit();` is being delegated to the rootDirective directive due to the closing animation
                     */
                    this.rootDirective.attachDetachEvent.set(RdxTooltipAttachDetachEvent.DETACH);
                }),
                takeUntilDestroyed(this.destroyRef)
            )
            .subscribe();
    }

    /** @ignore */
    private setScrollStrategy() {
        const prevScrollStrategy = this.connectedOverlay.scrollStrategy;
        this.connectedOverlay.scrollStrategy = this.overlay.scrollStrategies.reposition();
        this.fireOverlayNgOnChanges('scrollStrategy', this.connectedOverlay.scrollStrategy, prevScrollStrategy);
    }

    /** @ignore */
    private setHasBackdrop() {
        const prevHasBackdrop = this.connectedOverlay.hasBackdrop;
        this.connectedOverlay.hasBackdrop = false;
        this.fireOverlayNgOnChanges('hasBackdrop', this.connectedOverlay.hasBackdrop, prevHasBackdrop);
    }

    /** @ignore */
    private setDisableClose() {
        const prevDisableClose = this.connectedOverlay.disableClose;
        this.connectedOverlay.disableClose = true;
        this.fireOverlayNgOnChanges('disableClose', this.connectedOverlay.disableClose, prevDisableClose);
    }

    /** @ignore */
    private setOrigin(origin: CdkConnectedOverlay['origin']) {
        const prevOrigin = this.connectedOverlay.origin;
        this.connectedOverlay.origin = origin;
        this.fireOverlayNgOnChanges('origin', this.connectedOverlay.origin, prevOrigin);
    }

    /** @ignore */
    private setPositions(positions: CdkConnectedOverlay['positions']) {
        const prevPositions = this.connectedOverlay.positions;
        this.connectedOverlay.positions = positions;
        this.fireOverlayNgOnChanges('positions', this.connectedOverlay.positions, prevPositions);
        this.connectedOverlay.overlayRef?.updatePosition();
    }

    /** @ignore */
    private computePositions() {
        const arrowHeight = this.rootDirective.arrowDirective()?.height() ?? 0;
        const offsets: RdxPositionSideAndAlignOffsets = {
            sideOffset:
                arrowHeight + (isNaN(this.sideOffset()) ? RDX_POSITIONING_DEFAULTS.offsets.side : this.sideOffset()),
            alignOffset: isNaN(this.alignOffset()) ? RDX_POSITIONING_DEFAULTS.offsets.align : this.alignOffset()
        };
        const basePosition = getContentPosition({
            side: this.side(),
            align: this.align(),
            sideOffset: offsets.sideOffset,
            alignOffset: offsets.alignOffset
        });
        const positions = [basePosition];
        if (!this.alternatePositionsDisabled()) {
            /**
             * Alternate positions for better user experience along the X/Y axis (e.g. vertical/horizontal scrolling)
             */
            const allPossibleConnectedPositions = getAllPossibleConnectedPositions();
            allPossibleConnectedPositions.forEach((_, key) => {
                const sideAndAlignArray = key.split('|');
                if (
                    (sideAndAlignArray[0] as RdxPositionSide) !== this.side() ||
                    (sideAndAlignArray[1] as RdxPositionAlign) !== this.align()
                ) {
                    positions.push(
                        getContentPosition({
                            side: sideAndAlignArray[0] as RdxPositionSide,
                            align: sideAndAlignArray[1] as RdxPositionAlign,
                            sideOffset: offsets.sideOffset,
                            alignOffset: offsets.alignOffset
                        })
                    );
                }
            });
        }
        return positions;
    }

    private onOriginChangeEffect() {
        effect(() => {
            const origin = (this.rootDirective.anchorDirective() ?? this.rootDirective.triggerDirective())
                .overlayOrigin;
            untracked(() => {
                this.setOrigin(origin);
            });
        });
    }

    /** @ignore */
    private onPositionChangeEffect() {
        effect(() => {
            const positions = this.positions();
            this.alternatePositionsDisabled();
            untracked(() => {
                this.setPositions(positions);
            });
        });
    }

    /** @ignore */
    private fireOverlayNgOnChanges<K extends keyof CdkConnectedOverlay, V extends CdkConnectedOverlay[K]>(
        input: K,
        currentValue: V,
        previousValue: V,
        firstChange = false
    ) {
        this.connectedOverlay.ngOnChanges({
            [input]: new SimpleChange(previousValue, currentValue, firstChange)
        });
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/src/tooltip-root.directive.ts
```typescript
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import {
    afterNextRender,
    booleanAttribute,
    computed,
    contentChild,
    DestroyRef,
    Directive,
    effect,
    inject,
    input,
    numberAttribute,
    signal,
    untracked,
    ViewContainerRef
} from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { debounce, map, Subject, tap, timer } from 'rxjs';
import { RdxTooltipAnchorDirective } from './tooltip-anchor.directive';
import { RdxTooltipAnchorToken } from './tooltip-anchor.token';
import { RdxTooltipArrowToken } from './tooltip-arrow.token';
import { RdxTooltipCloseToken } from './tooltip-close.token';
import { RdxTooltipContentAttributesToken } from './tooltip-content-attributes.token';
import { RdxTooltipContentDirective } from './tooltip-content.directive';
import { RdxTooltipTriggerDirective } from './tooltip-trigger.directive';
import {
    RdxTooltipAction,
    RdxTooltipAnimationStatus,
    RdxTooltipAttachDetachEvent,
    RdxTooltipState
} from './tooltip.types';
import { injectRdxCdkEventService } from './utils/cdk-event.service';

let nextId = 0;

@Directive({
    selector: '[rdxTooltipRoot]',
    exportAs: 'rdxTooltipRoot'
})
export class RdxTooltipRootDirective {
    /** @ignore */
    readonly uniqueId = signal(++nextId);
    /** @ignore */
    readonly name = computed(() => `rdx-tooltip-root-${this.uniqueId()}`);

    /**
     * @description The anchor directive that comes form outside the tooltip rootDirective
     * @default undefined
     */
    readonly anchor = input<RdxTooltipAnchorDirective | undefined>(void 0);
    /**
     * @description The open state of the tooltip when it is initially rendered. Use when you do not need to control its open state.
     * @default false
     */
    readonly defaultOpen = input<boolean, BooleanInput>(false, { transform: booleanAttribute });
    /**
     * @description The controlled state of the tooltip. `open` input take precedence of `defaultOpen` input.
     * @default undefined
     */
    readonly open = input<boolean | undefined, BooleanInput>(void 0, { transform: booleanAttribute });
    /**
     * To customise the open delay for a specific tooltip.
     */
    readonly openDelay = input<number, NumberInput>(500, {
        transform: numberAttribute
    });
    /**
     * To customise the close delay for a specific tooltip.
     */
    readonly closeDelay = input<number, NumberInput>(200, {
        transform: numberAttribute
    });
    /**
     * @description Whether to control the state of the tooltip from external. Use in conjunction with `open` input.
     * @default undefined
     */
    readonly externalControl = input<boolean | undefined, BooleanInput>(void 0, { transform: booleanAttribute });
    /**
     * @description Whether to take into account CSS opening/closing animations.
     * @default false
     */
    readonly cssAnimation = input<boolean, BooleanInput>(false, { transform: booleanAttribute });
    /**
     * @description Whether to take into account CSS opening animations. `cssAnimation` input must be set to 'true'
     * @default false
     */
    readonly cssOpeningAnimation = input<boolean, BooleanInput>(false, { transform: booleanAttribute });
    /**
     * @description Whether to take into account CSS closing animations. `cssAnimation` input must be set to 'true'
     * @default false
     */
    readonly cssClosingAnimation = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /** @ignore */
    readonly cssAnimationStatus = signal<RdxTooltipAnimationStatus | null>(null);

    /** @ignore */
    readonly contentDirective = contentChild.required(RdxTooltipContentDirective);
    /** @ignore */
    readonly triggerDirective = contentChild.required(RdxTooltipTriggerDirective);
    /** @ignore */
    readonly arrowDirective = contentChild(RdxTooltipArrowToken);
    /** @ignore */
    readonly closeDirective = contentChild(RdxTooltipCloseToken);
    /** @ignore */
    readonly contentAttributesComponent = contentChild(RdxTooltipContentAttributesToken);
    /** @ignore */
    private readonly internalAnchorDirective = contentChild(RdxTooltipAnchorToken);

    /** @ignore */
    readonly viewContainerRef = inject(ViewContainerRef);
    /** @ignore */
    readonly rdxCdkEventService = injectRdxCdkEventService();
    /** @ignore */
    readonly destroyRef = inject(DestroyRef);

    /** @ignore */
    readonly state = signal(RdxTooltipState.CLOSED);

    /** @ignore */
    readonly attachDetachEvent = signal(RdxTooltipAttachDetachEvent.DETACH);

    /** @ignore */
    private readonly isFirstDefaultOpen = signal(false);

    /** @ignore */
    readonly anchorDirective = computed(() => this.internalAnchorDirective() ?? this.anchor());

    /** @ignore */
    readonly actionSubject$ = new Subject<RdxTooltipAction>();

    constructor() {
        this.rdxCdkEventService?.registerPrimitive(this);
        this.destroyRef.onDestroy(() => this.rdxCdkEventService?.deregisterPrimitive(this));
        this.actionSubscription();
        this.onStateChangeEffect();
        this.onCssAnimationStatusChangeChangeEffect();
        this.onOpenChangeEffect();
        this.onIsFirstDefaultOpenChangeEffect();
        this.onAnchorChangeEffect();
        this.emitOpenOrClosedEventEffect();
        afterNextRender({
            write: () => {
                if (this.defaultOpen() && !this.open()) {
                    this.isFirstDefaultOpen.set(true);
                }
            }
        });
    }

    /** @ignore */
    getAnimationParamsSnapshot() {
        return {
            cssAnimation: this.cssAnimation(),
            cssOpeningAnimation: this.cssOpeningAnimation(),
            cssClosingAnimation: this.cssClosingAnimation(),
            cssAnimationStatus: this.cssAnimationStatus(),
            attachDetachEvent: this.attachDetachEvent(),
            state: this.state(),
            canEmitOnOpenOrOnClosed: this.canEmitOnOpenOrOnClosed()
        };
    }

    /** @ignore */
    controlledExternally() {
        return this.externalControl;
    }

    /** @ignore */
    firstDefaultOpen() {
        return this.isFirstDefaultOpen();
    }

    /** @ignore */
    handleOpen(): void {
        if (this.externalControl()) {
            return;
        }
        this.actionSubject$.next(RdxTooltipAction.OPEN);
    }

    /** @ignore */
    handleClose(closeButton?: boolean): void {
        if (this.isFirstDefaultOpen()) {
            this.isFirstDefaultOpen.set(false);
        }
        if (!closeButton && this.externalControl()) {
            return;
        }
        this.actionSubject$.next(RdxTooltipAction.CLOSE);
    }

    /** @ignore */
    handleToggle(): void {
        if (this.externalControl()) {
            return;
        }
        this.isOpen() ? this.handleClose() : this.handleOpen();
    }

    /** @ignore */
    isOpen(state?: RdxTooltipState) {
        return (state ?? this.state()) === RdxTooltipState.OPEN;
    }

    /** @ignore */
    private setState(state = RdxTooltipState.CLOSED): void {
        if (state === this.state()) {
            return;
        }
        this.state.set(state);
    }

    /** @ignore */
    private openContent(): void {
        this.contentDirective().open();
        if (!this.cssAnimation() || !this.cssOpeningAnimation()) {
            this.cssAnimationStatus.set(null);
        }
    }

    /** @ignore */
    private closeContent(): void {
        this.contentDirective().close();
        if (!this.cssAnimation() || !this.cssClosingAnimation()) {
            this.cssAnimationStatus.set(null);
        }
    }

    /** @ignore */
    private emitOnOpen(): void {
        this.contentDirective().onOpen.emit();
    }

    /** @ignore */
    private emitOnClosed(): void {
        this.contentDirective().onClosed.emit();
    }

    /** @ignore */
    private ifOpenOrCloseWithoutAnimations(state: RdxTooltipState) {
        return (
            !this.contentAttributesComponent() ||
            !this.cssAnimation() ||
            (this.cssAnimation() && !this.cssClosingAnimation() && state === RdxTooltipState.CLOSED) ||
            (this.cssAnimation() && !this.cssOpeningAnimation() && state === RdxTooltipState.OPEN) ||
            // !this.cssAnimationStatus() ||
            (this.cssOpeningAnimation() &&
                state === RdxTooltipState.OPEN &&
                [RdxTooltipAnimationStatus.OPEN_STARTED].includes(this.cssAnimationStatus()!)) ||
            (this.cssClosingAnimation() &&
                state === RdxTooltipState.CLOSED &&
                [RdxTooltipAnimationStatus.CLOSED_STARTED].includes(this.cssAnimationStatus()!))
        );
    }

    /** @ignore */
    private ifOpenOrCloseWithAnimations(cssAnimationStatus: RdxTooltipAnimationStatus | null) {
        return (
            this.contentAttributesComponent() &&
            this.cssAnimation() &&
            cssAnimationStatus &&
            ((this.cssOpeningAnimation() &&
                this.state() === RdxTooltipState.OPEN &&
                [RdxTooltipAnimationStatus.OPEN_ENDED].includes(cssAnimationStatus)) ||
                (this.cssClosingAnimation() &&
                    this.state() === RdxTooltipState.CLOSED &&
                    [RdxTooltipAnimationStatus.CLOSED_ENDED].includes(cssAnimationStatus)))
        );
    }

    /** @ignore */
    private openOrClose(state: RdxTooltipState) {
        const isOpen = this.isOpen(state);
        isOpen ? this.openContent() : this.closeContent();
    }

    /** @ignore */
    private emitOnOpenOrOnClosed(state: RdxTooltipState) {
        this.isOpen(state)
            ? this.attachDetachEvent() === RdxTooltipAttachDetachEvent.ATTACH && this.emitOnOpen()
            : this.attachDetachEvent() === RdxTooltipAttachDetachEvent.DETACH && this.emitOnClosed();
    }

    /** @ignore */
    private canEmitOnOpenOrOnClosed() {
        return (
            !this.cssAnimation() ||
            (!this.cssOpeningAnimation() && this.state() === RdxTooltipState.OPEN) ||
            (this.cssOpeningAnimation() &&
                this.state() === RdxTooltipState.OPEN &&
                this.cssAnimationStatus() === RdxTooltipAnimationStatus.OPEN_ENDED) ||
            (!this.cssClosingAnimation() && this.state() === RdxTooltipState.CLOSED) ||
            (this.cssClosingAnimation() &&
                this.state() === RdxTooltipState.CLOSED &&
                this.cssAnimationStatus() === RdxTooltipAnimationStatus.CLOSED_ENDED)
        );
    }

    /** @ignore */
    private onStateChangeEffect() {
        let isFirst = true;
        effect(() => {
            const state = this.state();
            untracked(() => {
                if (isFirst) {
                    isFirst = false;
                    return;
                }
                if (!this.ifOpenOrCloseWithoutAnimations(state)) {
                    return;
                }
                this.openOrClose(state);
            });
        }, {});
    }

    /** @ignore */
    private onCssAnimationStatusChangeChangeEffect() {
        let isFirst = true;
        effect(() => {
            const cssAnimationStatus = this.cssAnimationStatus();
            untracked(() => {
                if (isFirst) {
                    isFirst = false;
                    return;
                }
                if (!this.ifOpenOrCloseWithAnimations(cssAnimationStatus)) {
                    return;
                }
                this.openOrClose(this.state());
            });
        });
    }

    /** @ignore */
    private emitOpenOrClosedEventEffect() {
        let isFirst = true;
        effect(() => {
            this.attachDetachEvent();
            this.cssAnimationStatus();
            untracked(() => {
                if (isFirst) {
                    isFirst = false;
                    return;
                }
                const canEmitOpenClose = untracked(() => this.canEmitOnOpenOrOnClosed());
                if (!canEmitOpenClose) {
                    return;
                }
                this.emitOnOpenOrOnClosed(this.state());
            });
        });
    }

    /** @ignore */
    private onOpenChangeEffect() {
        effect(() => {
            const open = this.open();
            untracked(() => {
                this.setState(open ? RdxTooltipState.OPEN : RdxTooltipState.CLOSED);
            });
        });
    }

    /** @ignore */
    private onIsFirstDefaultOpenChangeEffect() {
        const effectRef = effect(() => {
            const defaultOpen = this.defaultOpen();
            untracked(() => {
                if (!defaultOpen || this.open()) {
                    effectRef.destroy();
                    return;
                }
                this.handleOpen();
            });
        });
    }

    /** @ignore */
    private onAnchorChangeEffect = () => {
        effect(() => {
            const anchor = this.anchor();
            untracked(() => {
                if (anchor) {
                    anchor.setRoot(this);
                }
            });
        });
    };

    /** @ignore */
    private actionSubscription() {
        this.actionSubject$
            .asObservable()
            .pipe(
                map((action) => {
                    switch (action) {
                        case RdxTooltipAction.OPEN:
                            return { action, duration: this.openDelay() };
                        case RdxTooltipAction.CLOSE:
                            return { action, duration: this.closeDelay() };
                    }
                }),
                debounce((config) => timer(config.duration)),
                tap((config) => {
                    switch (config.action) {
                        case RdxTooltipAction.OPEN:
                            this.setState(RdxTooltipState.OPEN);
                            break;
                        case RdxTooltipAction.CLOSE:
                            this.setState(RdxTooltipState.CLOSED);
                            break;
                    }
                }),
                takeUntilDestroyed()
            )
            .subscribe();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/src/tooltip-root.inject.ts
```typescript
import { assertInInjectionContext, inject, isDevMode } from '@angular/core';
import { RdxTooltipRootDirective } from './tooltip-root.directive';

export function injectTooltipRoot(optional?: false): RdxTooltipRootDirective;
export function injectTooltipRoot(optional: true): RdxTooltipRootDirective | null;
export function injectTooltipRoot(optional = false): RdxTooltipRootDirective | null {
    isDevMode() && assertInInjectionContext(injectTooltipRoot);
    return inject(RdxTooltipRootDirective, { optional });
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/src/tooltip-trigger.directive.ts
```typescript
import { CdkOverlayOrigin } from '@angular/cdk/overlay';
import { computed, Directive, ElementRef, inject } from '@angular/core';
import { injectTooltipRoot } from './tooltip-root.inject';

@Directive({
    selector: '[rdxTooltipTrigger]',
    hostDirectives: [CdkOverlayOrigin],
    host: {
        type: 'button',
        '[attr.id]': 'name()',
        '[attr.aria-haspopup]': '"dialog"',
        '[attr.aria-expanded]': 'rootDirective.isOpen()',
        '[attr.aria-controls]': 'rootDirective.contentDirective().name()',
        '[attr.data-state]': 'rootDirective.state()',
        '(pointerenter)': 'pointerenter()',
        '(pointerleave)': 'pointerleave()',
        '(focus)': 'focus()',
        '(blur)': 'blur()',
        '(click)': 'click()'
    }
})
export class RdxTooltipTriggerDirective {
    /** @ignore */
    protected readonly rootDirective = injectTooltipRoot();
    /** @ignore */
    readonly elementRef = inject<ElementRef<HTMLElement>>(ElementRef);
    /** @ignore */
    readonly overlayOrigin = inject(CdkOverlayOrigin);

    /** @ignore */
    readonly name = computed(() => `rdx-tooltip-trigger-${this.rootDirective.uniqueId()}`);

    /** @ignore */
    pointerenter(): void {
        this.rootDirective.handleOpen();
    }

    /** @ignore */
    pointerleave(): void {
        this.rootDirective.handleClose();
    }

    /** @ignore */
    focus(): void {
        this.rootDirective.handleOpen();
    }

    /** @ignore */
    blur(): void {
        this.rootDirective.handleClose();
    }

    /** @ignore */
    click(): void {
        this.rootDirective.handleClose();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/src/tooltip.types.ts
```typescript
export enum RdxTooltipState {
    OPEN = 'open',
    CLOSED = 'closed'
}

export enum RdxTooltipAction {
    OPEN = 'open',
    CLOSE = 'close'
}

export enum RdxTooltipAttachDetachEvent {
    ATTACH = 'attach',
    DETACH = 'detach'
}

export enum RdxTooltipAnimationStatus {
    OPEN_STARTED = 'open_started',
    OPEN_ENDED = 'open_ended',
    CLOSED_STARTED = 'closed_started',
    CLOSED_ENDED = 'closed_ended'
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/src/utils/cdk-event.service.ts
```typescript
import {
    DestroyRef,
    EnvironmentProviders,
    inject,
    Injectable,
    InjectionToken,
    isDevMode,
    makeEnvironmentProviders,
    NgZone,
    Provider,
    Renderer2,
    VERSION
} from '@angular/core';
import { injectDocument, injectWindow } from '@radix-ng/primitives/core';
import { RdxCdkEventServiceWindowKey } from './constants';
import { EventType, EventTypeAsPrimitiveConfigKey, PrimitiveConfig, PrimitiveConfigs } from './types';

function eventTypeAsPrimitiveConfigKey(eventType: EventType): EventTypeAsPrimitiveConfigKey {
    return `prevent${eventType[0].toUpperCase()}${eventType.slice(1)}` as EventTypeAsPrimitiveConfigKey;
}

@Injectable()
class RdxCdkEventService {
    document = injectDocument();
    destroyRef = inject(DestroyRef);
    ngZone = inject(NgZone);
    renderer2 = inject(Renderer2);
    window = injectWindow();

    primitiveConfigs?: PrimitiveConfigs;

    onDestroyCallbacks: Set<() => void> = new Set([() => deleteRdxCdkEventServiceWindowKey(this.window)]);

    #clickDomRootEventCallbacks: Set<(event: MouseEvent) => void> = new Set();

    constructor() {
        this.#listenToClickDomRootEvent();
        this.#registerOnDestroyCallbacks();
    }

    registerPrimitive<T extends object>(primitiveInstance: T) {
        if (!this.primitiveConfigs) {
            this.primitiveConfigs = new Map();
        }
        if (!this.primitiveConfigs.has(primitiveInstance)) {
            this.primitiveConfigs.set(primitiveInstance, {});
        }
    }

    deregisterPrimitive<T extends object>(primitiveInstance: T) {
        if (this.primitiveConfigs?.has(primitiveInstance)) {
            this.primitiveConfigs.delete(primitiveInstance);
        }
    }

    preventPrimitiveFromCdkEvent<T extends object>(primitiveInstance: T, eventType: EventType) {
        this.#setPreventPrimitiveFromCdkEvent(primitiveInstance, eventType, true);
    }

    allowPrimitiveForCdkEvent<T extends object>(primitiveInstance: T, eventType: EventType) {
        this.#setPreventPrimitiveFromCdkEvent(primitiveInstance, eventType, false);
    }

    preventPrimitiveFromCdkMultiEvents<T extends object>(primitiveInstance: T, eventTypes: EventType[]) {
        eventTypes.forEach((eventType) => {
            this.#setPreventPrimitiveFromCdkEvent(primitiveInstance, eventType, true);
        });
    }

    allowPrimitiveForCdkMultiEvents<T extends object>(primitiveInstance: T, eventTypes: EventType[]) {
        eventTypes.forEach((eventType) => {
            this.#setPreventPrimitiveFromCdkEvent(primitiveInstance, eventType, false);
        });
    }

    setPreventPrimitiveFromCdkMixEvents<T extends object>(primitiveInstance: T, eventTypes: PrimitiveConfig) {
        Object.keys(eventTypes).forEach((eventType) => {
            this.#setPreventPrimitiveFromCdkEvent(
                primitiveInstance,
                eventType as EventType,
                eventTypes[eventTypeAsPrimitiveConfigKey(eventType as EventType)]
            );
        });
    }

    primitivePreventedFromCdkEvent<T extends object>(primitiveInstance: T, eventType: EventType) {
        return this.primitiveConfigs?.get(primitiveInstance)?.[eventTypeAsPrimitiveConfigKey(eventType)];
    }

    addClickDomRootEventCallback(callback: (event: MouseEvent) => void) {
        this.#clickDomRootEventCallbacks.add(callback);
    }

    removeClickDomRootEventCallback(callback: (event: MouseEvent) => void) {
        return this.#clickDomRootEventCallbacks.delete(callback);
    }

    #setPreventPrimitiveFromCdkEvent<
        T extends object,
        R extends EventType,
        K extends PrimitiveConfig[EventTypeAsPrimitiveConfigKey<R>]
    >(primitiveInstance: T, eventType: R, value: K) {
        if (!this.primitiveConfigs?.has(primitiveInstance)) {
            isDevMode() &&
                console.error(
                    '[RdxCdkEventService.preventPrimitiveFromCdkEvent] RDX Primitive instance has not been registered!',
                    primitiveInstance
                );
            return;
        }
        switch (eventType) {
            case 'cdkOverlayOutsideClick':
                this.primitiveConfigs.get(primitiveInstance)!.preventCdkOverlayOutsideClick = value;
                break;
            case 'cdkOverlayEscapeKeyDown':
                this.primitiveConfigs.get(primitiveInstance)!.preventCdkOverlayEscapeKeyDown = value;
                break;
        }
    }

    #registerOnDestroyCallbacks() {
        this.destroyRef.onDestroy(() => {
            this.onDestroyCallbacks.forEach((onDestroyCallback) => onDestroyCallback());
            this.onDestroyCallbacks.clear();
        });
    }

    #listenToClickDomRootEvent() {
        const target = this.document;
        const eventName = 'click';
        const options: boolean | AddEventListenerOptions | undefined = { capture: true };
        const callback = (event: MouseEvent) => {
            this.#clickDomRootEventCallbacks.forEach((clickDomRootEventCallback) => clickDomRootEventCallback(event));
        };

        const major = parseInt(VERSION.major);
        const minor = parseInt(VERSION.minor);

        let destroyClickDomRootEventListener!: () => void;
        /**
         * @see src/cdk/platform/features/backwards-compatibility.ts in @angular/cdk
         */
        if (major > 19 || (major === 19 && minor > 0) || (major === 0 && minor === 0)) {
            destroyClickDomRootEventListener = this.ngZone.runOutsideAngular(() => {
                const destroyClickDomRootEventListenerInternal = this.renderer2.listen(
                    target,
                    eventName,
                    callback,

                    options
                );
                return () => {
                    destroyClickDomRootEventListenerInternal();
                    this.#clickDomRootEventCallbacks.clear();
                };
            });
        } else {
            /**
             * This part can get removed when v19.1 or higher is on the board
             */
            destroyClickDomRootEventListener = this.ngZone.runOutsideAngular(() => {
                target.addEventListener(eventName, callback, options);
                return () => {
                    this.ngZone.runOutsideAngular(() => target.removeEventListener(eventName, callback, options));
                    this.#clickDomRootEventCallbacks.clear();
                };
            });
        }
        this.onDestroyCallbacks.add(destroyClickDomRootEventListener);
    }
}

const RdxCdkEventServiceToken = new InjectionToken<RdxCdkEventService>('RdxCdkEventServiceToken');

const existsErrorMessage = 'RdxCdkEventService should be provided only once!';

const deleteRdxCdkEventServiceWindowKey = (window: Window & typeof globalThis) => {
    delete (window as any)[RdxCdkEventServiceWindowKey];
};

const getProvider: (throwWhenExists?: boolean) => Provider = (throwWhenExists = true) => ({
    provide: RdxCdkEventServiceToken,
    useFactory: () => {
        isDevMode() && console.log('providing RdxCdkEventService...');
        const window = injectWindow();
        if ((window as any)[RdxCdkEventServiceWindowKey]) {
            if (throwWhenExists) {
                throw Error(existsErrorMessage);
            } else {
                isDevMode() && console.warn(existsErrorMessage);
            }
        }
        (window as any)[RdxCdkEventServiceWindowKey] ??= new RdxCdkEventService();
        return (window as any)[RdxCdkEventServiceWindowKey];
    }
});

export const provideRdxCdkEventServiceInRoot: () => EnvironmentProviders = () =>
    makeEnvironmentProviders([getProvider()]);
export const provideRdxCdkEventService: () => Provider = () => getProvider(false);

export const injectRdxCdkEventService = () => inject(RdxCdkEventServiceToken, { optional: true });

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/src/utils/constants.ts
```typescript
export const RdxCdkEventServiceWindowKey = Symbol('__RdxCdkEventService__');

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/tooltip/src/utils/types.ts
```typescript
export type EventType = 'cdkOverlayOutsideClick' | 'cdkOverlayEscapeKeyDown';
export type EventTypeCapitalized<R extends EventType = EventType> = Capitalize<R>;
export type EventTypeAsPrimitiveConfigKey<R extends EventType = EventType> = `prevent${EventTypeCapitalized<R>}`;
export type PrimitiveConfig = {
    [value in EventTypeAsPrimitiveConfigKey]?: boolean;
};
export type PrimitiveConfigs = Map<object, PrimitiveConfig>;

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/portal/stories/portal.docs.mdx
````
import { Meta } from '@storybook/blocks';

<Meta title="Utilities/Portal" />

# Portal

#### Renders an Angular component or template in a different part of the DOM.

## Features

- âœ… Render any Angular component or template outside of your App's main structure.
- âœ… Appends to a custom container element, which can be configured as needed.

## Installation

To use the [Angular CDK Portal](https://material.angular.io/cdk/portal/overview), first install the CDK package:

```bash
npm install @angular/cdk
```

## Basic Usage

### Defining a Portal

First, create the component or template that you want to render in a different location:

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'component-portal-content',
  standalone: true,
  template: `
    <p>This is portal content!</p>
  `
})
export class PortalContentComponent {}
```

### Using the Portal

In your main component, set up the portal and the outlet:

```typescript
// app.component.ts
import { Component, ViewChild, AfterViewInit, inject, ApplicationRef, Injector, ViewContainerRef } from '@angular/core';
import { CdkPortal, DomPortalOutlet } from '@angular/cdk/portal';
import { PortalContentComponent } from './portal-content.component';

@Component({
  selector: 'app-root',
  standalone: true,
  template: `
    <ng-template cdkPortal>
      <app-portal-content></app-portal-content>
    </ng-template>
    <div #portalOutlet></div>
  `
})
export class AppComponent implements AfterViewInit {
  private readonly appRef = inject(ApplicationRef);
  private readonly injector = inject(Injector);

  @ViewChild(CdkPortal) portal: CdkPortal;
  @ViewChild('portalOutlet', { read: ViewContainerRef }) portalOutlet: ViewContainerRef;

  private host: DomPortalOutlet;

  ngAfterViewInit() {
    this.host = new DomPortalOutlet(this.portalOutlet.element.nativeElement, this.injector, this.appRef);
    this.host.attach(this.portal);
  }
}
```

## Anatomy

The Angular CDK Portal utility consists of a few key elements:

1. **Portal**:
   An Angular directive (`CdkPortal`) that defines the content to be rendered elsewhere.

2. **Portal Outlet**:
   An Angular directive (`CdkPortalOutlet`) or a host (`DomPortalOutlet`) where the portal content will be rendered.

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/README.md
```
# @radix-ng/primitives/calendar

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/index.ts
```typescript
import { NgModule } from '@angular/core';

export { RdxCalendarCellTriggerDirective } from './src/calendar-cell-trigger.directive';
export { RdxCalendarCellDirective } from './src/calendar-cell.directive';
export { RdxCalendarGridBodyDirective } from './src/calendar-grid-body.directive';
export { RdxCalendarGridHeadDirective } from './src/calendar-grid-head.directive';
export { RdxCalendarGridRowDirective } from './src/calendar-grid-row.directive';
export { RdxCalendarGridDirective } from './src/calendar-grid.directive';
export { RdxCalendarHeadCellDirective } from './src/calendar-head-cell.directive';
export { RdxCalendarHeaderDirective } from './src/calendar-header.directive';
export { RdxCalendarHeadingDirective } from './src/calendar-heading.directive';
export { RdxCalendarNextDirective } from './src/calendar-next.directive';
export { RdxCalendarPrevDirective } from './src/calendar-prev.directive';
export { RdxCalendarRootDirective } from './src/calendar-root.directive';

import { RdxCalendarCellTriggerDirective } from './src/calendar-cell-trigger.directive';
import { RdxCalendarCellDirective } from './src/calendar-cell.directive';
import { RdxCalendarGridBodyDirective } from './src/calendar-grid-body.directive';
import { RdxCalendarGridHeadDirective } from './src/calendar-grid-head.directive';
import { RdxCalendarGridRowDirective } from './src/calendar-grid-row.directive';
import { RdxCalendarGridDirective } from './src/calendar-grid.directive';
import { RdxCalendarHeadCellDirective } from './src/calendar-head-cell.directive';
import { RdxCalendarHeaderDirective } from './src/calendar-header.directive';
import { RdxCalendarHeadingDirective } from './src/calendar-heading.directive';
import { RdxCalendarNextDirective } from './src/calendar-next.directive';
import { RdxCalendarPrevDirective } from './src/calendar-prev.directive';
import { RdxCalendarRootDirective } from './src/calendar-root.directive';

const _imports = [
    RdxCalendarCellTriggerDirective,
    RdxCalendarCellDirective,
    RdxCalendarGridBodyDirective,
    RdxCalendarGridHeadDirective,
    RdxCalendarGridRowDirective,
    RdxCalendarGridDirective,
    RdxCalendarHeadCellDirective,
    RdxCalendarHeaderDirective,
    RdxCalendarPrevDirective,
    RdxCalendarRootDirective,
    RdxCalendarHeadingDirective,
    RdxCalendarNextDirective
];

@NgModule({
    imports: [..._imports],
    exports: [..._imports]
})
export class RdxCalendarModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/stories/calendar-default.component.ts
```typescript
import { Component } from '@angular/core';
import { CalendarDate, DateValue } from '@internationalized/date';
import { ChevronLeft, ChevronRight, LucideAngularModule } from 'lucide-angular';
import { RdxCalendarCellTriggerDirective } from '../src/calendar-cell-trigger.directive';
import { RdxCalendarCellDirective } from '../src/calendar-cell.directive';
import { RdxCalendarGridHeadDirective } from '../src/calendar-grid-head.directive';
import { RdxCalendarGridDirective } from '../src/calendar-grid.directive';
import { RdxCalendarHeadCellDirective } from '../src/calendar-head-cell.directive';
import { RdxCalendarHeaderDirective } from '../src/calendar-header.directive';
import { RdxCalendarHeadingDirective } from '../src/calendar-heading.directive';
import { RdxCalendarNextDirective } from '../src/calendar-next.directive';
import { RdxCalendarPrevDirective } from '../src/calendar-prev.directive';
import { RdxCalendarRootDirective } from '../src/calendar-root.directive';

@Component({
    selector: 'app-calendar-default',
    imports: [
        RdxCalendarRootDirective,
        RdxCalendarHeaderDirective,
        RdxCalendarGridDirective,
        RdxCalendarGridHeadDirective,
        RdxCalendarCellTriggerDirective,
        RdxCalendarCellDirective,
        RdxCalendarHeadingDirective,
        RdxCalendarNextDirective,
        RdxCalendarPrevDirective,
        LucideAngularModule,
        RdxCalendarHeadCellDirective
    ],
    styleUrl: 'calendar-default.style.css',
    template: `
        <div class="wrapper">
            <div
                class="calendar-root"
                #root="rdxCalendarRoot"
                [value]="date"
                data-testid="calendar"
                rdxCalendarRoot
                fixedWeeks
            >
                <div class="calendar-header" rdxCalendarHeader>
                    <button class="icon-button" type="button" rdxCalendarPrev>
                        <lucide-angular [img]="ChevronLeft" size="16" style="display: flex;" />
                    </button>
                    <div class="calendar-heading" #head="rdxCalendarHeading" data-testid="heading" rdxCalendarHeading>
                        {{ head.headingValue() }}
                    </div>
                    <button class="icon-button" type="button" data-testid="next-button" rdxCalendarNext>
                        <lucide-angular [img]="ChevronRight" size="16" style="display: flex;" />
                    </button>
                </div>

                <div class="calendar-container">
                    <table class="calendar-grid" rdxCalendarGrid>
                        @for (month of root.months(); track $index) {
                            <thead rdxCalendarGridHead>
                                <tr class="calendar-grid-head-row">
                                    @for (day of root.weekDays(); track $index) {
                                        <th class="calendar-head-cell" rdxCalendarHeadCell>{{ day }}</th>
                                    }
                                </tr>
                            </thead>
                            <tbody class="calendar-grid-body" rdxCalendarGridBody>
                                @for (weekDates of month.weeks; track $index) {
                                    <tr class="calendar-week-row">
                                        @for (weekDate of weekDates; track $index) {
                                            <td class="calendar-cell-wrapper" [date]="weekDate" rdxCalendarCell>
                                                <div
                                                    class="calendar-day"
                                                    #cell="rdxCalendarCellTrigger"
                                                    [day]="weekDate"
                                                    [month]="month.value"
                                                    rdxCalendarCellTrigger
                                                >
                                                    {{ cell.dayValue() }}
                                                </div>
                                            </td>
                                        }
                                    </tr>
                                }
                            </tbody>
                        }
                    </table>
                </div>
            </div>
        </div>
    `
})
export class CalendarDefaultComponent {
    date: DateValue = new CalendarDate(2024, 10, 3);

    protected readonly ChevronLeft = ChevronLeft;
    protected readonly ChevronRight = ChevronRight;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/stories/calendar-default.style.css
```css
/* calendar-default.style.css */

/* ÐžÐ±Ñ‰Ð¸Ðµ Ð¾Ð±Ñ‘Ñ€Ñ‚ÐºÐ¸ */
.wrapper {
    max-width: 680px;
    width: 300px;
}

.calendar-root {
    margin-top: 1.5rem;
    border-radius: 0.75rem;
    background-color: #ffffff;
    padding: 1rem;
    box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    border: 1px solid #e5e7eb;
}

/* Ð—Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº ÐºÐ°Ð»ÐµÐ½Ð´Ð°Ñ€Ñ */
.calendar-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.calendar-heading {
    font-size: 0.875rem;
    color: #000000;
    font-weight: 500;
}

/* ÐšÐ½Ð¾Ð¿ÐºÐ¸ Ð½Ð°Ð²Ð¸Ð³Ð°Ñ†Ð¸Ð¸ */
button {
    all: unset;
}

.icon-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: #000000;
    background-color: transparent;
    border-radius: 0.375rem;
    width: 1.75rem;
    height: 1.75rem;
}

.icon-button:hover {
    background-color: #f5f5f4;
}

.icon-button:active {
    transform: scale(0.98);
    transition: all 0.1s ease;
}

.icon-button:focus {
    box-shadow: 0 0 0 2px black;
}

/* ÐšÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€ Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñ‹ */
.calendar-container {
    display: flex;
    flex-direction: column;
    padding-top: 1rem;
}

/* Ð¡ÐµÑ‚ÐºÐ° ÐºÐ°Ð»ÐµÐ½Ð´Ð°Ñ€Ñ */
.calendar-grid {
    width: 100%;
    border-collapse: collapse;
    user-select: none;
}

/* Ð—Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº Ð´Ð½ÐµÐ¹ Ð½ÐµÐ´ÐµÐ»Ð¸ */
.calendar-grid-head-row {
    display: grid;
    width: 100%;
    grid-template-columns: repeat(7, minmax(0, 1fr));
    margin-bottom: 0.25rem;
}

.calendar-head-cell {
    border-radius: 0.375rem;
    font-size: 0.75rem;
    color: #30a46c;
    text-align: center;
}

/* Ð¢ÐµÐ»Ð¾ ÐºÐ°Ð»ÐµÐ½Ð´Ð°Ñ€Ñ */
.calendar-grid-body {
    display: grid;
}

.calendar-week-row {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
}

.calendar-cell-wrapper {
    position: relative;
    text-align: center;
    font-size: 0.8rem;
}

/* ÐšÐ»ÐµÑ‚ÐºÐ¸ Ð´Ð½ÐµÐ¹ */
.calendar-day {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 2rem;
    height: 2rem;
    border-radius: 9999px;
    white-space: nowrap;
    font-size: 0.875rem;
    font-weight: 400;
    color: black;
    outline: none;
    cursor: pointer;
}

.calendar-day:focus {
    box-shadow: 0 0 0 2px black;
}

.calendar-day:hover {
    background-color: #c3e8d1;
}

.calendar-day[data-selected] {
    background-color: #30a46c !important;
    color: white;
}

.calendar-day[data-outside-view],
.calendar-day[data-unavailable] {
    color: rgba(0, 0, 0, 0.3);
}

.calendar-day[data-unavailable] {
    pointer-events: none;
    text-decoration: line-through;
}

.calendar-day::before {
    content: '';
    position: absolute;
    top: 5px;
    width: 0.25rem;
    height: 0.25rem;
    border-radius: 9999px;
    background-color: white;
    display: none;
}

.calendar-day[data-today]::before {
    display: block;
    background-color: #298459;
}

.calendar-day[data-highlighted] {
    background-color: #c3e8d1;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/stories/calendar-with-locale.component.ts
```typescript
import { Component, computed, signal } from '@angular/core';
import { createCalendar, getLocalTimeZone, toCalendar, today } from '@internationalized/date';
import { ChevronLeft, ChevronRight, LucideAngularModule } from 'lucide-angular';
import { RdxCalendarCellTriggerDirective } from '../src/calendar-cell-trigger.directive';
import { RdxCalendarGridHeadDirective } from '../src/calendar-grid-head.directive';
import { RdxCalendarGridDirective } from '../src/calendar-grid.directive';
import { RdxCalendarHeaderDirective } from '../src/calendar-header.directive';
import { RdxCalendarHeadingDirective } from '../src/calendar-heading.directive';
import { RdxCalendarNextDirective } from '../src/calendar-next.directive';
import { RdxCalendarPrevDirective } from '../src/calendar-prev.directive';
import { RdxCalendarRootDirective } from '../src/calendar-root.directive';

@Component({
    selector: 'app-calendar-with-locale',
    imports: [
        RdxCalendarRootDirective,
        RdxCalendarHeaderDirective,
        RdxCalendarGridDirective,
        RdxCalendarGridHeadDirective,
        RdxCalendarCellTriggerDirective,
        RdxCalendarHeadingDirective,
        RdxCalendarNextDirective,
        RdxCalendarPrevDirective,
        LucideAngularModule
    ],
    styleUrl: 'calendar-default.style.css',
    template: `
        <div class="wrapper" style="display: flex; flex-direction: column; gap: 1rem;">
            <label style="color: white;">Locale</label>
            <select [value]="locale()" (change)="updateLocale($event)">
                @for (option of preferences; track $index) {
                    <option [value]="option.locale">{{ option.label }}</option>
                }
            </select>

            <label style="color: white;">Calendar</label>
            <select [value]="calendar()">
                @for (option of preferredCalendars(); track $index) {
                    <option [value]="option!.key">{{ option!.name }}</option>
                }
            </select>

            <div
                class="calendar-root"
                #root="rdxCalendarRoot"
                [value]="value()"
                [locale]="locale()"
                rdxCalendarRoot
                fixedWeeks
            >
                <div class="calendar-header" rdxCalendarHeader>
                    <button class="icon-button" type="button" rdxCalendarPrev>
                        <lucide-angular [img]="ChevronLeft" size="16" style="display: flex;" />
                    </button>
                    <div class="calendar-heading" #head="rdxCalendarHeading" rdxCalendarHeading>
                        {{ head.headingValue() }}
                    </div>
                    <button class="icon-button" type="button" rdxCalendarNext>
                        <lucide-angular [img]="ChevronRight" size="16" style="display: flex;" />
                    </button>
                </div>

                <div class="calendar-container">
                    <table class="calendar-grid" rdxCalendarGrid>
                        @for (month of root.months(); track $index) {
                            <thead rdxCalendarGridHead>
                                <tr class="calendar-grid-head-row">
                                    @for (day of root.weekDays(); track $index) {
                                        <th class="calendar-head-cell">{{ day }}</th>
                                    }
                                </tr>
                            </thead>
                            <tbody class="calendar-grid-body" rdxCalendarGridBody>
                                @for (weekDates of month.weeks; track $index) {
                                    <tr class="calendar-week-row">
                                        @for (weekDate of weekDates; track $index) {
                                            <td class="calendar-cell-wrapper">
                                                <div
                                                    class="calendar-day"
                                                    #cell="rdxCalendarCellTrigger"
                                                    [day]="weekDate"
                                                    [month]="month.value"
                                                    rdxCalendarCellTrigger
                                                >
                                                    {{ cell.dayValue() }}
                                                </div>
                                            </td>
                                        }
                                    </tr>
                                }
                            </tbody>
                        }
                    </table>
                </div>
            </div>
        </div>
    `
})
export class CalendarWithLocaleComponent {
    readonly preferences = [
        { locale: 'en-US', label: 'Default', ordering: 'gregory' },
        {
            label: 'Arabic (Algeria)',
            locale: 'ar-DZ',
            territories: 'DJ DZ EH ER IQ JO KM LB LY MA MR OM PS SD SY TD TN YE',
            ordering: 'gregory islamic islamic-civil islamic-tbla'
        },
        {
            label: 'Arabic (United Arab Emirates)',
            locale: 'ar-AE',
            territories: 'AE BH KW QA',
            ordering: 'gregory islamic-umalqura islamic islamic-civil islamic-tbla'
        },
        {
            label: 'Arabic (Egypt)',
            locale: 'AR-EG',
            territories: 'EG',
            ordering: 'gregory coptic islamic islamic-civil islamic-tbla'
        },
        {
            label: 'Arabic (Saudi Arabia)',
            locale: 'ar-SA',
            territories: 'SA',
            ordering: 'islamic-umalqura gregory islamic islamic-rgsa'
        },
        {
            label: 'Farsi (Iran)',
            locale: 'fa-IR',
            territories: 'IR',
            ordering: 'persian gregory islamic islamic-civil islamic-tbla'
        },
        {
            label: 'Farsi (Afghanistan)',
            locale: 'fa-AF',
            territories: 'AF IR',
            ordering: 'persian gregory islamic islamic-civil islamic-tbla'
        },
        { label: 'Amharic (Ethiopia)', locale: 'am-ET', territories: 'ET', ordering: 'gregory ethiopic ethioaa' },
        {
            label: 'Hebrew (Israel)',
            locale: 'he-IL',
            territories: 'IL',
            ordering: 'gregory hebrew islamic islamic-civil islamic-tbla'
        },
        { label: 'Hindi (India)', locale: 'hi-IN', territories: 'IN', ordering: 'gregory indian' },
        { label: 'Japanese (Japan)', locale: 'ja-JP', territories: 'JP', ordering: 'gregory japanese' },
        { label: 'Thai (Thailand)', locale: 'th-TH', territories: 'TH', ordering: 'buddhist gregory' },
        { label: 'Chinese (Taiwan)', locale: 'zh-TW', territories: 'TW', ordering: 'gregory roc chinese' }
    ];

    readonly calendars = [
        { key: 'gregory', name: 'Gregorian' },
        { key: 'japanese', name: 'Japanese' },
        { key: 'buddhist', name: 'Buddhist' },
        { key: 'roc', name: 'Taiwan' },
        { key: 'persian', name: 'Persian' },
        { key: 'indian', name: 'Indian' },
        { key: 'islamic-umalqura', name: 'Islamic (Umm al-Qura)' },
        { key: 'islamic-civil', name: 'Islamic Civil' },
        { key: 'islamic-tbla', name: 'Islamic Tabular' },
        { key: 'hebrew', name: 'Hebrew' },
        { key: 'coptic', name: 'Coptic' },
        { key: 'ethiopic', name: 'Ethiopic' },
        { key: 'ethioaa', name: 'Ethiopic (Amete Alem)' }
    ];

    readonly locale = signal(this.preferences[0].locale);
    readonly calendar = signal(this.calendars[0].key);

    readonly pref = computed(() => this.preferences.find((p) => p.locale === this.locale()));

    readonly preferredCalendars = computed(() => {
        const currentPref = this.pref();
        return currentPref
            ? currentPref.ordering
                  .split(' ')
                  .map((p) => this.calendars.find((c) => c.key === p))
                  .filter(Boolean)
            : [this.calendars[0]];
    });

    readonly otherCalendars = computed(() =>
        this.calendars.filter((c) => !this.preferredCalendars().some((p) => p!.key === c.key))
    );

    readonly value = computed(() => toCalendar(today(getLocalTimeZone()), createCalendar(this.calendar())));

    updateLocale(event: Event) {
        const newLocale = (event.target as HTMLSelectElement).value;

        this.locale.set(newLocale);
        this.calendar.set(this.pref()!.ordering.split(' ')[0]);
    }

    protected readonly ChevronLeft = ChevronLeft;
    protected readonly ChevronRight = ChevronRight;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/stories/calendar.docs.mdx
````
import { ArgTypes, Canvas, Markdown, Meta } from "@storybook/blocks";
import * as Stories from './calendar.stories';
import { RdxCalendarRootDirective } from "../src/calendar-root.directive";
import {RdxCalendarPrevDirective} from "../src/calendar-prev.directive";
import {RdxCalendarNextDirective} from "../src/calendar-next.directive";
import {RdxCalendarCellDirective} from "../src/calendar-cell.directive";

<Meta title="Primitives/Calendar" />

# Calendar

####  Displays dates and days of the week, facilitating date-related interactions.

<Canvas sourceState="hidden" of={Stories.Default} />

## Features

- âœ… Full keyboard navigation.
- âœ… Can be controlled or uncontrolled
- âœ… Focus is fully managed
- âœ… Localization support
- âœ… Highly composable

## Preface

The component depends on the [@internationalized/date package](https://react-spectrum.adobe.com/internationalized/date/index.html),
which solves a lot of the problems that come with working with dates and times in JavaScript.

We highly recommend reading through the documentation for the package to get a solid feel
for how it works, and you'll need to install it in your project to use the date-related components.

## Installation

Install the date package.

```bash
npm install @internationalized/date
```

Install the component from your command line.

```bash
npm install @radix-ng/primitives
```

## Anatomy

Import all parts and piece them together.

```html
<div
    rdxCalendarRoot
    #root="rdxCalendarRoot">
    <div rdxCalendarHeader>
        <button type="button" rdxCalendarPrev></button>
        <div #head="rdxCalendarHeading" rdxCalendarHeading>
            {{ head.headingValue() }}
        </div>
        <button type="button" rdxCalendarNext></button>
    </div>

    <table rdxCalendarGrid>
        @for (month of root.months(); track $index) {
            <thead rdxCalendarGridHead>
                <tr rdxCalendarGridRow>
                    @for (day of root.weekDays(); track $index) {
                        <th rdxCalendarHeadCell>{{ day }}</th>
                    }
                </tr>
            </thead>
            <tbody rdxCalendarGridBody>
                @for (weekDates of month.weeks; track $index) {
                    <tr rdxCalendarGridRow>
                        @for (weekDate of weekDates; track $index) {
                            <td rdxCalendarCell>
                                <div
                                    #cell="rdxCalendarCellTrigger"
                                    rdxCalendarCellTrigger
                                >
                                    {{ cell.dayValue() }}
                                </div>
                            </td>
                        }
                    </tr>
                }
            </tbody>
        }
    </table>
</div>
```

## API Reference

### Root

`RdxCalendarRootDirective` Contains all the parts of a calendar

<ArgTypes of={RdxCalendarRootDirective} />

### Header

`RdxCalendarHeaderDirective` Contains the navigation buttons and the heading segments.

### Prev Button

`RdxCalendarPrevDirective` Calendar navigation button. It navigates the calendar one month/year/decade in the past based on the current calendar view.

<ArgTypes of={RdxCalendarPrevDirective} />

### Next Button

`RdxCalendarNextDirective` Calendar navigation button. It navigates the calendar one month/year/decade in the future based on the current calendar view.

<ArgTypes of={RdxCalendarNextDirective} />

### Heading

`RdxCalendarHeadingDirective` Heading for displaying the current month and year.


| exportAs       | Description |
| ------------- | --------- |
| `headingValue`  | `string` Current month and year |

### Grid

`RdxCalendarGridDirective` Container for wrapping the calendar grid.

| Data Attribute     | Value |
| ------------------ | --------- |
| `[data-readonly]`  | Present when readonly |
| `[data-disabled]`  | Present when disabled |

### Grid Head

`RdxCalendarGridHeadDirective` Container for wrapping the grid head as `thead`.

### Grid Body

`RdxCalendarGridBodyDirective` Container for wrapping the grid body as `tbody`.

### Grid Row

`RdxCalendarGridRowDirective` Container for wrapping the grid row as `tr`.

### Head Cell

`RdxCalendarHeadCellDirective` Container for wrapping the head cell. Used for displaying the week days as `th`.

### Cell

`RdxCalendarCellDirective` Container for wrapping the calendar cells as `td`.

<ArgTypes of={RdxCalendarCellDirective} />

| Data Attribute     | Value |
| ------------------ | --------- |
| `[data-disabled]`  | Present when disabled |

### Cell Trigger

`RdxCalendarCellTriggerDirective` Interactable container for displaying the cell dates. Clicking it selects the date.

| Data Attribute     | Value |
| ------------------ | --------- |
| `[data-selected]`  | Present when selected |
| `[data-value]`  | The ISO string value of the date. |
| `[data-disabled]`  | Present when disabled |
| `[data-unavailable]`  | Present when unavailable |
| `[data-today]`  | Present when today |
| `[data-outside-view]`  | Present when the date is outside the current month it is displayed in. |
| `[data-outside-visible-view]`  | Present when the date is outside the months that are visible on the calendar. |
| `[data-focused]`  | Present when focused |

## Examples

### Calendar with Locale and Calendar System Selection

This example showcases some of the available locales and how the calendar systems are displayed.

<Canvas sourceState="hidden" of={Stories.WithLocale} />


## Accessibility

### Keyboard Interactions
| Key     | Description |
| ------------------ | --------- |
| `Tab`  | When focus moves onto the calendar, focuses the first navigation button. |
| `Space`  |  When the focus is on either `CalendarNext` or `CalendarPrev`, it navigates the calendar. Otherwise, it selects the date.  |
| `Enter`  |  When the focus is on either `CalendarNext` or `CalendarPrev`, it navigates the calendar. Otherwise, it selects the date.  |
| `ArrowLeft` `ArrowRight` `ArrowUp` `ArrowDown`  |  When the focus is on `CalendarCellTrigger`, it navigates the dates, changing the month/year/decade if necessary.  |

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/stories/calendar.stories.ts
```typescript
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { CalendarDefaultComponent } from './calendar-default.component';
import { CalendarWithLocaleComponent } from './calendar-with-locale.component';

const html = String.raw;

export default {
    title: 'Primitives/Calendar',
    decorators: [
        moduleMetadata({
            imports: [
                CalendarDefaultComponent,
                CalendarWithLocaleComponent
            ]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div
                    class="radix-themes light light-theme radix-themes-default-fonts"
                    data-accent-color="indigo"
                    data-radius="medium"
                    data-scaling="100%"
                >
                    ${story}
                </div>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: html`
            <app-calendar-default />
        `
    })
};

export const WithLocale: Story = {
    render: () => ({
        template: html`
            <app-calendar-with-locale />
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/__tests__/calendar.spec.ts
```typescript
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { CalendarDate, CalendarDateTime, DateValue, toZoned } from '@internationalized/date';
import { userEvent } from '@testing-library/user-event';
import { axe } from 'jest-axe';
import { CalendarDefaultComponent } from '../stories/calendar-default.component';

type SetupConfig = {
    modelValue?: DateValue;
    prevPage?: (placeholder: DateValue) => DateValue;
};

function getSelectedDay(calendar: HTMLElement) {
    return calendar.querySelector<HTMLElement>('[data-selected]') as HTMLElement;
}

function getByTestId(id: string, hostEl: HTMLElement) {
    return hostEl.querySelector<HTMLElement>(`[data-testId=${id}]`)!;
}

const calendarDate = new CalendarDate(1980, 1, 20);
const calendarDateTime = new CalendarDateTime(1980, 1, 20, 12, 30, 0, 0);
const zonedDateTime = toZoned(calendarDateTime, 'America/New_York');

const months = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December'
];

describe('Calendar', () => {
    let fixture: ComponentFixture<CalendarDefaultComponent>;
    let component: CalendarDefaultComponent;
    let hostEl: HTMLElement;

    beforeEach(async () => {
        await TestBed.configureTestingModule({
            imports: [
                CalendarDefaultComponent
            ]
        }).compileComponents();

        fixture = TestBed.createComponent(CalendarDefaultComponent);
        component = fixture.componentInstance;
        hostEl = fixture.nativeElement;
    });

    async function setup({ modelValue }: SetupConfig = {}) {
        if (modelValue !== undefined) {
            component.date = modelValue;
        }

        fixture.detectChanges();

        const user = userEvent.setup();

        const calendar = hostEl.querySelector<HTMLElement>('[data-testId="calendar"]')!;
        expect(calendar).toBeTruthy();

        return { fixture, component, hostEl, calendar, user };
    }

    it('should pass axe accessibility tests', async () => {
        const { calendar } = await setup({ modelValue: calendarDate });

        expect(await axe(calendar)).toHaveNoViolations();
    });

    it('respects a default value if provided - `CalendarDate`', async () => {
        const { calendar } = await setup({ modelValue: calendarDate });
        expect(getSelectedDay(calendar)).toHaveTextContent(String(calendarDate.day));
        expect(getByTestId('heading', hostEl)).toHaveTextContent('January 1980');
    });

    it('respects a default value if provided - `CalendarDateTime`', async () => {
        const { calendar } = await setup({ modelValue: calendarDateTime });

        expect(getSelectedDay(calendar)).toHaveTextContent(String(calendarDateTime.day));
        expect(getByTestId('heading', hostEl)).toHaveTextContent('January 1980');
    });

    it('respects a default value if provided - `ZonedDateTime`', async () => {
        const { calendar } = await setup({ modelValue: zonedDateTime });

        expect(getSelectedDay(calendar)).toHaveTextContent(String(zonedDateTime.day));
        expect(getByTestId('heading', hostEl)).toHaveTextContent('January 1980');
    });

    it('navigates the months forward using the next button', async () => {
        const { user } = await setup({ modelValue: calendarDate });

        const heading = getByTestId('heading', hostEl);
        const nextBtn = getByTestId('next-button', hostEl);

        for (const month of months) {
            expect(heading).toHaveTextContent(`${month} 1980`);
            await user.click(nextBtn);
            fixture.detectChanges();
        }
        expect(heading).toHaveTextContent('January 1981');
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-cell-trigger.directive.ts
```typescript
import { AfterViewInit, computed, Directive, ElementRef, inject, input } from '@angular/core';
import { DateValue, getLocalTimeZone, isSameDay, isSameMonth, isToday } from '@internationalized/date';
import * as kbd from '@radix-ng/primitives/core';
import { getDaysInMonth, toDate } from '@radix-ng/primitives/core';
import { injectCalendarRootContext } from './Ñalendar-Ñontext.token';

@Directive({
    selector: '[rdxCalendarCellTrigger]',
    exportAs: 'rdxCalendarCellTrigger',
    host: {
        role: 'button',
        '[attr.aria-label]': 'labelText()',
        '[attr.aria-disabled]': 'isDisabled() || isUnavailable() ? true : undefined',
        '[attr.data-rdx-calendar-cell-trigger]': '""',
        '[attr.tabindex]': 'isFocusedDate() ? 0 : isOutsideView() || isDisabled() ? undefined : -1',
        '[attr.data-value]': 'day()?.toString()',
        '[attr.data-disabled]': 'isDisabled() ? "" : undefined',
        '[attr.data-today]': 'isDateToday() ? "" : undefined',
        '[attr.data-outside-view]': 'isOutsideView() ? "" : undefined',
        '[attr.data-selected]': 'isSelectedDate() ? "" : undefined',
        '[attr.data-unavailable]': 'isUnavailable() ? "" : undefined',
        '[attr.data-focus]': 'isFocusedDate() ? "" : undefined',

        '(click)': 'onClick()',

        '(keydown)': 'onArrowKey($event)'
    }
})
export class RdxCalendarCellTriggerDirective implements AfterViewInit {
    private readonly rootContext = injectCalendarRootContext();
    private readonly elementRef = inject(ElementRef<HTMLElement>);

    /**
     * The date value provided to the cell trigger
     */
    readonly day = input<DateValue>();

    /**
     * The month in which the cell is rendered
     */
    readonly month = input<DateValue>();

    /**
     * Current day
     */
    readonly dayValue = computed(() => this.day()?.day.toLocaleString());

    /**
     * Current today state
     */
    readonly isDateToday = computed(() => {
        return isToday(<DateValue>this.day(), getLocalTimeZone());
    });

    /**
     * Current selected state
     */
    readonly isSelectedDate = computed(() => this.rootContext.isDateSelected!(<DateValue>this.day()));

    readonly isDisabled = computed(() => this.rootContext.isDateDisabled!(<DateValue>this.day()));

    readonly isOutsideView = computed(() => {
        return !isSameMonth(<DateValue>this.day(), <DateValue>this.month());
    });

    readonly isFocusedDate = computed(() => {
        return !this.rootContext.disabled() && isSameDay(<DateValue>this.day(), this.rootContext.placeholder());
    });

    readonly isUnavailable = computed(() => this.rootContext.isDateUnavailable?.(<DateValue>this.day()) ?? false);

    readonly labelText = computed(() => {
        return this.rootContext.formatter.custom(toDate(<DateValue>this.day()), {
            weekday: 'long',
            month: 'long',
            day: 'numeric',
            year: 'numeric'
        });
    });

    /**
     * @ignore
     */
    currentElement!: HTMLElement;

    ngAfterViewInit() {
        this.currentElement = this.elementRef.nativeElement;
    }

    protected onClick() {
        this.changeDate(this.day()!);
    }

    protected onArrowKey(event: KeyboardEvent) {
        const code = event.code;
        if (![
                kbd.ARROW_RIGHT,
                kbd.ARROW_LEFT,
                kbd.ARROW_UP,
                kbd.ARROW_DOWN,
                kbd.ENTER,
                kbd.SPACE_CODE
            ].includes(code)) {
            return;
        }

        event.preventDefault();
        event.stopPropagation();

        const indexIncrementation = 7;
        const sign = this.rootContext.dir() === 'rtl' ? -1 : 1;

        switch (code) {
            case kbd.ARROW_RIGHT:
                this.shiftFocus(this.currentElement, sign);
                break;
            case kbd.ARROW_LEFT:
                this.shiftFocus(this.currentElement, -sign);
                break;
            case kbd.ARROW_UP:
                this.shiftFocus(this.currentElement, -indexIncrementation);
                break;
            case kbd.ARROW_DOWN:
                this.shiftFocus(this.currentElement, indexIncrementation);
                break;
            case kbd.ENTER:
            case kbd.SPACE_CODE:
                this.changeDate(<DateValue>this.day());
        }
    }

    private shiftFocus(node: HTMLElement, add: number) {
        const parentElement = this.rootContext.currentElement;

        const allCollectionItems: HTMLElement[] = this.getSelectableCells(parentElement);
        if (!allCollectionItems.length) return;

        const index = allCollectionItems.indexOf(node);
        const newIndex = index + add;

        if (newIndex >= 0 && newIndex < allCollectionItems.length) {
            if (allCollectionItems[newIndex].hasAttribute('data-disabled')) {
                this.shiftFocus(allCollectionItems[newIndex], add);
            }
            allCollectionItems[newIndex].focus();
            return;
        }

        if (newIndex < 0) {
            if (!this.rootContext.prevPage) return;

            this.rootContext.prevPage();

            setTimeout(() => {
                const newCollectionItems = this.getSelectableCells(parentElement);
                if (!newCollectionItems.length) return;

                if (!this.rootContext.pagedNavigation && this.rootContext.numberOfMonths() > 1) {
                    // Placeholder is set to the first month of the new page
                    const numberOfDays = getDaysInMonth(this.rootContext.placeholder());
                    const computedIndex = numberOfDays - Math.abs(newIndex);
                    if (newCollectionItems[computedIndex].hasAttribute('data-disabled')) {
                        this.shiftFocus(newCollectionItems[computedIndex], add);
                    }
                    newCollectionItems[computedIndex].focus();
                    return;
                }

                const computedIndex = newCollectionItems.length - Math.abs(newIndex);
                if (newCollectionItems[computedIndex].hasAttribute('data-disabled')) {
                    this.shiftFocus(newCollectionItems[computedIndex], add);
                }
                newCollectionItems[computedIndex].focus();
            });
        }

        if (newIndex >= allCollectionItems.length) {
            if (!this.rootContext.nextPage) return;

            this.rootContext.nextPage();

            setTimeout(() => {
                const newCollectionItems = this.getSelectableCells(parentElement);
                if (!newCollectionItems.length) return;

                if (!this.rootContext.pagedNavigation && this.rootContext.numberOfMonths() > 1) {
                    const numberOfDays = getDaysInMonth(
                        this.rootContext.placeholder().add({ months: this.rootContext.numberOfMonths() - 1 })
                    );

                    const computedIndex =
                        newIndex - allCollectionItems.length + (newCollectionItems.length - numberOfDays);

                    if (newCollectionItems[computedIndex].hasAttribute('data-disabled')) {
                        this.shiftFocus(newCollectionItems[computedIndex], add);
                    }
                    newCollectionItems[computedIndex].focus();
                    return;
                }

                const computedIndex = newIndex - allCollectionItems.length;
                if (newCollectionItems[computedIndex].hasAttribute('data-disabled')) {
                    this.shiftFocus(newCollectionItems[computedIndex], add);
                }

                newCollectionItems[computedIndex].focus();
            });
        }
    }

    /**
     * @ignore
     */
    SELECTOR = '[data-rdx-calendar-cell-trigger]:not([data-outside-view]):not([data-outside-visible-view])';

    /**
     * @ignore
     */
    getSelectableCells(calendar: HTMLElement): HTMLElement[] {
        return Array.from(calendar.querySelectorAll(this.SELECTOR)) ?? [];
    }

    /**
     * @ignore
     */
    changeDate(date: DateValue) {
        this.rootContext.onDateChange(date);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-cell.directive.ts
```typescript
import { Directive, input } from '@angular/core';
import { DateValue } from '@internationalized/date';
import { injectCalendarRootContext } from './Ñalendar-Ñontext.token';

@Directive({
    selector: 'td[rdxCalendarCell]',
    host: {
        role: 'gridcell',
        '[attr.aria-selected]': 'rootContext.isDateSelected?.(date()!) ? true : undefined',
        '[attr.aria-disabled]': 'rootContext.isDateSelected?.(date()!) ||  rootContext.isDateUnavailable?.(date()!)',
        '[attr.data-disabled]': 'rootContext.isDateSelected?.(date()!) ? "" : undefined'
    }
})
export class RdxCalendarCellDirective {
    protected readonly rootContext = injectCalendarRootContext();

    /**
     * The date of the cell
     */
    readonly date = input<DateValue>();
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-grid-body.directive.ts
```typescript
import { Directive } from '@angular/core';

@Directive({
    selector: 'tbody[rdxCalendarGridBody]'
})
export class RdxCalendarGridBodyDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-grid-head.directive.ts
```typescript
import { Directive } from '@angular/core';

@Directive({
    selector: 'thead[rdxCalendarGridHead]',
    host: {
        '[attr.aria-hidden]': 'true'
    }
})
export class RdxCalendarGridHeadDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-grid-row.directive.ts
```typescript
import { Directive } from '@angular/core';

@Directive({
    selector: 'tr[rdxCalendarGridRow]'
})
export class RdxCalendarGridRowDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-grid.directive.ts
```typescript
import { computed, Directive } from '@angular/core';
import { injectCalendarRootContext } from './Ñalendar-Ñontext.token';

@Directive({
    selector: 'table[rdxCalendarGrid]',
    host: {
        tabindex: '-1',
        role: 'grid',
        '[attr.aria-readonly]': 'readonly()',
        '[attr.aria-disabled]': 'disabled()',
        '[attr.data-readonly]': 'readonly() && ""',
        '[attr.data-disabled]': 'disabled() && ""'
    }
})
export class RdxCalendarGridDirective {
    private readonly rootContext = injectCalendarRootContext();

    readonly disabled = computed(() => (this.rootContext.disabled() ? true : undefined));
    readonly readonly = computed(() => (this.rootContext.readonly ? true : undefined));
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-head-cell.directive.ts
```typescript
import { Directive } from '@angular/core';

@Directive({
    selector: 'th[rdxCalendarHeadCell]'
})
export class RdxCalendarHeadCellDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-header.directive.ts
```typescript
import { Directive } from '@angular/core';

@Directive({
    selector: 'div[rdxCalendarHeader]'
})
export class RdxCalendarHeaderDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-heading.directive.ts
```typescript
import { computed, Directive } from '@angular/core';
import { injectCalendarRootContext } from './Ñalendar-Ñontext.token';

@Directive({
    selector: 'div[rdxCalendarHeading]',
    exportAs: 'rdxCalendarHeading',
    host: {
        '[attr.data-disabled]': 'rootContext.disabled() ? "" : undefined'
    }
})
export class RdxCalendarHeadingDirective {
    protected readonly rootContext = injectCalendarRootContext();

    readonly headingValue = computed(() => this.rootContext.headingValue());
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-next.directive.ts
```typescript
import { computed, Directive, input } from '@angular/core';
import { DateValue } from '@internationalized/date';
import { injectCalendarRootContext } from './Ñalendar-Ñontext.token';

@Directive({
    selector: 'button[rdxCalendarNext]',
    exportAs: 'rdxCalendarNext',
    host: {
        '(click)': 'onClick()',
        '[disabled]': 'disabled()',
        '[attr.data-disabled]': 'disabled() ? "" : undefined',
        '[attr.aria-disabled]': 'disabled() ? "" : undefined',
        'aria-label': 'Next page'
    }
})
export class RdxCalendarNextDirective {
    protected readonly rootContext = injectCalendarRootContext();

    /**
     * The function to be used for the `next page`. Overwrites the nextPage function set on the `CalendarRoot`.
     */
    readonly nextPage = input<(placeholder: DateValue) => DateValue>();

    /**
     * @ignore
     */
    readonly disabled = computed(
        () => this.rootContext.disabled() || this.rootContext.isNextButtonDisabled(this.nextPage())
    );

    protected onClick() {
        this.rootContext.nextPage!(this.nextPage());
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-prev.directive.ts
```typescript
import { computed, Directive, input } from '@angular/core';
import { DateValue } from '@internationalized/date';
import { injectCalendarRootContext } from './Ñalendar-Ñontext.token';

@Directive({
    selector: 'button[rdxCalendarPrev]',
    exportAs: 'rdxCalendarPrev',
    host: {
        '(click)': 'onClick()',
        '[disabled]': 'disabled()',
        '[attr.data-disabled]': 'disabled() ? "" : undefined',
        '[attr.aria-disabled]': 'disabled() ? "" : undefined',
        'aria-label': 'Previous page'
    }
})
export class RdxCalendarPrevDirective {
    protected readonly rootContext = injectCalendarRootContext();

    /**
     * The function to be used for the `prev page`. Overwrites the prevPage function set on the `CalendarRoot`.
     */
    readonly prevPage = input<(placeholder: DateValue) => DateValue>();

    /**
     * @ignore
     */
    readonly disabled = computed(
        () => this.rootContext.disabled() || this.rootContext.isNextButtonDisabled(this.prevPage())
    );

    protected onClick() {
        this.rootContext.prevPage!(this.prevPage());
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-root.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import {
    AfterViewInit,
    booleanAttribute,
    Directive,
    effect,
    ElementRef,
    forwardRef,
    inject,
    input,
    linkedSignal,
    model,
    signal
} from '@angular/core';
import { DateValue, isEqualDay, isSameDay } from '@internationalized/date';
import { DateMatcher, Formatter, getDefaultDate, Month, watch } from '@radix-ng/primitives/core';
import { calendar, calendarState } from './calendar';
import { CALENDAR_ROOT_CONTEXT } from './Ñalendar-Ñontext.token';

@Directive({
    selector: '[rdxCalendarRoot]',
    exportAs: 'rdxCalendarRoot',
    providers: [
        { provide: CALENDAR_ROOT_CONTEXT, useExisting: forwardRef(() => RdxCalendarRootDirective) }],
    host: {
        role: 'application',
        '[attr.aria-label]': 'fullCalendarLabel()',
        '[attr.data-disabled]': 'disabled() ? "" : undefined',
        '[attr.data-readonly]': 'readonly() ? "" : undefined',
        '[attr.data-invalid]': 'isInvalid ? "" : undefined',
        '[attr.dir]': 'dir()'
    }
})
export class RdxCalendarRootDirective implements AfterViewInit {
    private readonly elementRef = inject(ElementRef<HTMLElement>);

    /**
     * The controlled checked state of the calendar
     */
    readonly value = model<DateValue | DateValue[] | undefined>();

    /**
     * The default placeholder date
     */
    readonly defaultPlaceholder = model<DateValue>();

    readonly locale = input<string>('en');

    readonly defaultDate = getDefaultDate({
        defaultPlaceholder: this.defaultPlaceholder(),
        defaultValue: this.value(),
        locale: this.locale()
    });

    /**
     * The placeholder date, which is used to determine what month to display when no date is selected.
     * This updates as the user navigates the calendar and can be used to programmatically control the calendar view
     */
    readonly placeholder = model<DateValue>(this.defaultPlaceholder() ?? this.defaultDate.copy());

    readonly multiple = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * Whether to always display 6 weeks in the calendar
     */
    readonly fixedWeeks = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * Whether the calendar is disabled
     */
    readonly disabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * Whether to prevent the user from deselecting a date without selecting another date first
     */
    readonly preventDeselect = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * The day of the week to start the calendar on
     */
    readonly weekStartsOn = input<0 | 1 | 2 | 3 | 4 | 5 | 6>(1);

    /**
     * The number of months to display at once
     */
    readonly numberOfMonths = input<number>(1);

    /**
     * The reading direction of the calendar when applicable.
     */
    readonly dir = input<'ltr' | 'rtl'>('ltr');

    /**
     * The minimum date that can be selected
     */
    readonly minValue = input<DateValue>();

    /**
     * The maximum date that can be selected
     */
    readonly maxValue = input<DateValue>();

    /**
     * The format to use for the weekday strings provided via the weekdays slot prop
     */
    readonly weekdayFormat = input<Intl.DateTimeFormatOptions['weekday']>('narrow');

    /**
     * The accessible label for the calendar
     */
    readonly calendarLabel = input<string>();

    /**
     * Whether the calendar is readonly
     */
    readonly readonly = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * This property causes the previous and next buttons to navigate by the number of months displayed at once, rather than one month
     */
    readonly pagedNavigation = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    readonly propsNextPage = input<(placeholder: DateValue) => DateValue>();

    readonly propsPrevPage = input<(placeholder: DateValue) => DateValue>();

    /**
     * A function that returns whether a date is disabled
     */
    readonly isDateDisabled = input<DateMatcher>();

    /**
     * A function that returns whether a date is unavailable
     */
    readonly isDateUnavailable = input<DateMatcher>();

    readonly initialFocus = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    readonly months = model<Month<DateValue>[]>();

    /**
     * The days of the week
     */
    readonly weekDays = model<string[]>();

    protected readonly _fixedWeeks = linkedSignal(this.fixedWeeks);

    protected readonly _disabled = linkedSignal(this.disabled);

    protected readonly _pagedNavigation = linkedSignal(this.pagedNavigation);

    /**
     * @ignore
     */
    readonly headingValue = signal<string>('');

    /**
     * @ignore
     */
    readonly fullCalendarLabel = signal<string>('');

    /**
     * @ignore
     */
    nextPage: (nextPageFunc?: (date: DateValue) => DateValue) => void;

    /**
     * @ignore
     */
    prevPage: (nextPageFunc?: (date: DateValue) => DateValue) => void;

    /**
     * @ignore
     */
    isNextButtonDisabled: (nextPageFunc?: (date: DateValue) => DateValue) => boolean;

    /**
     * @ignore
     */
    isPrevButtonDisabled: (nextPageFunc?: (date: DateValue) => DateValue) => boolean;

    /**
     * @ignore
     */
    isDateSelected: DateMatcher;

    /**
     * @ignore
     */
    isInvalid: boolean;

    /**
     * @ignore
     */
    isOutsideVisibleView: (date: DateValue) => boolean;

    /**
     * @ignore
     */
    formatter: Formatter;

    /**
     * @ignore
     */
    currentElement!: HTMLElement;

    private readonly calendar = calendar({
        locale: this.locale,
        placeholder: this.placeholder,
        weekStartsOn: this.weekStartsOn,
        fixedWeeks: this._fixedWeeks,
        numberOfMonths: this.numberOfMonths,
        minValue: this.minValue,
        maxValue: this.maxValue,
        disabled: this._disabled,
        weekdayFormat: this.weekdayFormat,
        pagedNavigation: this._pagedNavigation,
        isDateDisabled: this.isDateDisabled,
        isDateUnavailable: this.isDateUnavailable,
        calendarLabel: this.calendarLabel,
        nextPage: this.propsNextPage,
        prevPage: this.propsPrevPage
    });

    constructor() {
        this.nextPage = this.calendar.nextPage;
        this.prevPage = this.calendar.prevPage;
        this.isOutsideVisibleView = this.calendar.isOutsideVisibleView;
        this.isNextButtonDisabled = this.calendar.isNextButtonDisabled;
        this.isPrevButtonDisabled = this.calendar.isPrevButtonDisabled;
        this.formatter = this.calendar.formatter;

        effect(() => {
            this.months.set(this.calendar.month());

            this.weekDays.set(this.calendar.weekdays());

            this.fullCalendarLabel.set(this.calendar.fullCalendarLabel());

            this.headingValue.set(this.calendar.headingValue());

            const { isInvalid, isDateSelected } = calendarState({
                date: this.value,
                isDateDisabled: this.isDateDisabled(),
                isDateUnavailable: this.isDateUnavailable()
            });

            this.isDateSelected = isDateSelected;
            this.isInvalid = isInvalid();
        });

        watch([this.value], (_modelValue) => {
            if (Array.isArray(_modelValue) && _modelValue.length) {
                const lastValue = _modelValue[_modelValue.length - 1];
                if (lastValue && !isEqualDay(this.placeholder(), <DateValue>lastValue)) {
                    this.onPlaceholderChange(<DateValue>lastValue);
                }
            } else if (!Array.isArray(_modelValue) && _modelValue && !isEqualDay(this.placeholder(), _modelValue)) {
                this.onPlaceholderChange(_modelValue);
            }
        });
    }

    ngAfterViewInit() {
        this.currentElement = this.elementRef.nativeElement;
    }

    /**
     * @ignore
     */
    onPlaceholderChange(value: DateValue) {
        this.placeholder.set(value.copy());
    }

    /**
     * @ignore
     */
    onDateChange(date: DateValue) {
        const currentValue = this.value();

        if (!this.multiple()) {
            // for single selection
            if (!this.value()) {
                this.value.set(date.copy());
                return;
            }

            if (!this.preventDeselect() && isEqualDay(this.value() as DateValue, date)) {
                this.placeholder.set(date.copy());
                this.value.set(undefined);
            } else {
                this.value.set(date.copy());
            }
        } else if (!this.value()) {
            // for multiple selection
            this.value.set([date.copy()]);
        } else if (Array.isArray(currentValue)) {
            const index = currentValue.findIndex((d: DateValue) => isSameDay(d, date));
            if (index === -1) {
                this.value.set([...currentValue, date.copy()]);
            } else if (!this.preventDeselect()) {
                const next = currentValue.filter((d: DateValue) => !isSameDay(d, date));
                if (next.length === 0) {
                    this.placeholder.set(date.copy());
                    this.value.set(undefined);
                    return;
                }
                this.value.set(next.map((d) => d.copy()));
            }
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar.ts
```typescript
import { computed, InputSignal, ModelSignal, signal, WritableSignal } from '@angular/core';
import { DateFields, DateValue, isEqualMonth, isSameDay } from '@internationalized/date';
import {
    createFormatter,
    createMonths,
    DateFormatterOptions,
    DateMatcher,
    getDaysInMonth,
    isAfter,
    isBefore,
    Month,
    toDate,
    watch
} from '@radix-ng/primitives/core';

export type CalendarProps = {
    locale: InputSignal<string>;
    placeholder: WritableSignal<DateValue>;
    weekStartsOn: InputSignal<0 | 1 | 2 | 3 | 4 | 5 | 6>;
    fixedWeeks: WritableSignal<boolean>;
    numberOfMonths: InputSignal<number>;
    minValue: InputSignal<DateValue | undefined>;
    maxValue: InputSignal<DateValue | undefined>;
    disabled: WritableSignal<boolean>;
    weekdayFormat: InputSignal<Intl.DateTimeFormatOptions['weekday']>;
    pagedNavigation: WritableSignal<boolean>;
    isDateDisabled?: InputSignal<DateMatcher | undefined>;
    isDateUnavailable?: InputSignal<DateMatcher | undefined>;
    calendarLabel: InputSignal<string | undefined>;
    nextPage: InputSignal<((placeholder: DateValue) => DateValue) | undefined>;
    prevPage: InputSignal<((placeholder: DateValue) => DateValue) | undefined>;
};

export type CalendarStateProps = {
    date: ModelSignal<DateValue | DateValue[] | undefined>;
    isDateDisabled?: DateMatcher;
    isDateUnavailable?: DateMatcher;
};

export function calendarState(props: CalendarStateProps) {
    function isDateSelected(dateObj: DateValue): boolean {
        const currentValue = props.date(); // signal read

        if (Array.isArray(currentValue)) {
            return currentValue.some((d) => isSameDay(d, dateObj));
        } else if (!currentValue) {
            return false;
        } else {
            return isSameDay(currentValue, dateObj);
        }
    }

    const isInvalid = computed(() => {
        const currentValue = props.date();

        if (Array.isArray(currentValue)) {
            if (!currentValue.length) {
                return false;
            }
            for (const dateObj of currentValue) {
                if (props.isDateDisabled?.(dateObj)) return true;
                if (props.isDateUnavailable?.(dateObj)) return true;
            }
        } else {
            if (!currentValue) {
                return false;
            }
            if (props.isDateDisabled?.(currentValue)) return true;
            if (props.isDateUnavailable?.(currentValue)) return true;
        }
        return false;
    });

    return {
        isDateSelected,
        isInvalid
    };
}

function handleNextDisabled(lastPeriodInView: DateValue, nextPageFunc: (date: DateValue) => DateValue): DateValue {
    const firstPeriodOfNextPage = nextPageFunc(lastPeriodInView);
    const diff = firstPeriodOfNextPage.compare(lastPeriodInView);
    const duration: DateFields = {};
    if (diff >= 7) duration.day = 1;
    if (diff >= getDaysInMonth(lastPeriodInView)) duration.month = 1;
    return firstPeriodOfNextPage.set({ ...duration });
}

function handlePrevDisabled(firstPeriodInView: DateValue, prevPageFunc: (date: DateValue) => DateValue): DateValue {
    const lastPeriodOfPrevPage = prevPageFunc(firstPeriodInView);
    const diff = firstPeriodInView.compare(lastPeriodOfPrevPage);
    const duration: DateFields = {};
    if (diff >= 7) duration.day = 35;
    if (diff >= getDaysInMonth(firstPeriodInView)) duration.month = 13;
    return lastPeriodOfPrevPage.set({ ...duration });
}

function handleNextPage(date: DateValue, nextPageFunc: (date: DateValue) => DateValue): DateValue {
    return nextPageFunc(date);
}

function handlePrevPage(date: DateValue, prevPageFunc: (date: DateValue) => DateValue): DateValue {
    return prevPageFunc(date);
}

export function calendar(props: CalendarProps) {
    const formatter = createFormatter(props.locale());

    const headingFormatOptions = computed(() => {
        const options: DateFormatterOptions = {
            calendar: props.placeholder().calendar.identifier
        };

        if (props.placeholder().calendar.identifier === 'gregory' && props.placeholder().era === 'BC') {
            options.era = 'short';
        }

        return options;
    });

    const month = signal<Month<DateValue>[]>(
        createMonths({
            dateObj: props.placeholder(),
            weekStartsOn: props.weekStartsOn(),
            locale: props.locale(),
            fixedWeeks: props.fixedWeeks(),
            numberOfMonths: props.numberOfMonths()
        })
    );

    const visibleView = computed(() => {
        return month().map((month) => month.value);
    });

    function isOutsideVisibleView(date: DateValue) {
        return !visibleView().some((month) => isEqualMonth(date, month));
    }

    const isNextButtonDisabled = (nextPageFunc?: (date: DateValue) => DateValue) => {
        if (!props.maxValue() || !month().length) return false;
        if (props.disabled()) return true;

        const lastPeriodInView = month()[month().length - 1].value;

        if (!nextPageFunc && !props.nextPage()) {
            const firstPeriodOfNextPage = lastPeriodInView.add({ months: 1 }).set({ day: 1 });
            return isAfter(firstPeriodOfNextPage, <DateValue>props.maxValue());
        }

        const firstPeriodOfNextPage = handleNextDisabled(lastPeriodInView, nextPageFunc || props.nextPage()!);
        return isAfter(firstPeriodOfNextPage, <DateValue>props.maxValue());
    };

    const isPrevButtonDisabled = (prevPageFunc?: (date: DateValue) => DateValue) => {
        if (!props.minValue() || !month().length) return false;
        if (props.disabled()) return true;
        const firstPeriodInView = month()[0].value;

        if (!prevPageFunc && !props.prevPage()) {
            const lastPeriodOfPrevPage = firstPeriodInView.subtract({ months: 1 }).set({ day: 35 });
            return isBefore(lastPeriodOfPrevPage, <DateValue>props.minValue());
        }

        const lastPeriodOfPrevPage = handlePrevDisabled(firstPeriodInView, prevPageFunc || props.prevPage()!);
        return isBefore(lastPeriodOfPrevPage, <DateValue>props.minValue());
    };

    const nextPage = (nextPageFunc?: (date: DateValue) => DateValue) => {
        const firstDate = month()[0].value;

        if (!nextPageFunc && !props.nextPage()) {
            const newDate = firstDate.add({ months: props.pagedNavigation() ? props.numberOfMonths() : 1 });

            const newMonth = createMonths({
                dateObj: newDate,
                weekStartsOn: props.weekStartsOn(),
                locale: props.locale(),
                fixedWeeks: props.fixedWeeks(),
                numberOfMonths: props.numberOfMonths()
            });

            month.set(newMonth);
            props.placeholder.set(newMonth[0].value.set({ day: 1 }));

            return;
        }

        const newDate = handleNextPage(firstDate, nextPageFunc || props.nextPage()!);
        const newMonth = createMonths({
            dateObj: newDate,
            weekStartsOn: props.weekStartsOn(),
            locale: props.locale(),
            fixedWeeks: props.fixedWeeks(),
            numberOfMonths: props.numberOfMonths()
        });

        month.set(newMonth);

        const duration: DateFields = {};

        if (!nextPageFunc) {
            const diff = newMonth[0].value.compare(firstDate);
            if (diff >= getDaysInMonth(firstDate)) {
                duration.day = 1;
            }

            if (diff >= 365) {
                duration.month = 1;
            }
        }

        props.placeholder.set(newMonth[0].value.set({ ...duration }));
    };

    const prevPage = (prevPageFunc?: (date: DateValue) => DateValue) => {
        const firstDate = month()[0].value;

        if (!prevPageFunc && !props.prevPage()) {
            const newDate = firstDate.subtract({ months: props.pagedNavigation() ? props.numberOfMonths() : 1 });

            const newMonth = createMonths({
                dateObj: newDate,
                weekStartsOn: props.weekStartsOn(),
                locale: props.locale(),
                fixedWeeks: props.fixedWeeks(),
                numberOfMonths: props.numberOfMonths()
            });

            month.set(newMonth);

            props.placeholder.set(newMonth[0].value.set({ day: 1 }));
            return;
        }

        const newDate = handlePrevPage(firstDate, prevPageFunc || props.prevPage()!);
        const newMonth = createMonths({
            dateObj: newDate,
            weekStartsOn: props.weekStartsOn(),
            locale: props.locale(),
            fixedWeeks: props.fixedWeeks(),
            numberOfMonths: props.numberOfMonths()
        });

        month.set(newMonth);

        const duration: DateFields = {};

        // Do not adjust the placeholder if the prevPageFunc is defined (overwrite)
        if (!prevPageFunc) {
            const diff = firstDate.compare(newMonth[0].value);
            if (diff >= getDaysInMonth(firstDate)) duration.day = 1;

            if (diff >= 365) duration.month = 1;
        }

        props.placeholder.set(newMonth[0].value.set({ ...duration }));
    };

    function isDateDisabled(dateObj: DateValue) {
        if (props.isDateDisabled?.()?.(dateObj) || props.disabled()) return true;
        if (props.maxValue() && isAfter(dateObj, <DateValue>props.maxValue())) return true;
        if (props.minValue() && isBefore(dateObj, <DateValue>props.minValue())) return true;
        return false;
    }

    const isDateUnavailable = (date: DateValue) => {
        return !!props.isDateUnavailable?.()?.(date);
    };

    const weekdays = computed(() => {
        if (!month().length) return [];
        return month()[0].weeks[0].map((date) => {
            return formatter.dayOfWeek(toDate(date), props.weekdayFormat());
        });
    });

    watch([props.placeholder], ([placeholder]) => {
        if (visibleView().some((month) => isEqualMonth(month, placeholder))) {
            return;
        }

        month.set(
            createMonths({
                dateObj: placeholder,
                weekStartsOn: props.weekStartsOn(),
                locale: props.locale(),
                fixedWeeks: props.fixedWeeks(),
                numberOfMonths: props.numberOfMonths()
            })
        );
    });

    watch(
        [props.locale, props.weekStartsOn, props.fixedWeeks, props.numberOfMonths],
        ([locale, weekStartsOn, fixedWeeks, numberOfMonths]) => {
            month.set(
                createMonths({
                    dateObj: props.placeholder(),
                    weekStartsOn: weekStartsOn,
                    locale: locale,
                    fixedWeeks: fixedWeeks,
                    numberOfMonths: numberOfMonths
                })
            );
        }
    );

    const headingValue = computed(() => {
        if (!month().length) {
            return '';
        }

        if (props.locale() !== formatter.getLocale()) formatter.setLocale(props.locale());

        if (month().length === 1) {
            const _month = month()[0].value;
            return `${formatter.fullMonthAndYear(toDate(_month), headingFormatOptions())}`;
        }

        const startMonth = toDate(month()[0].value);
        const endMonth = toDate(month()[month().length - 1].value);

        const startMonthName = formatter.fullMonth(startMonth, headingFormatOptions());
        const endMonthName = formatter.fullMonth(endMonth, headingFormatOptions());
        const startMonthYear = formatter.fullYear(startMonth, headingFormatOptions());
        const endMonthYear = formatter.fullYear(endMonth, headingFormatOptions());

        return startMonthYear === endMonthYear
            ? `${startMonthName} - ${endMonthName} ${endMonthYear}`
            : `${startMonthName} ${startMonthYear} - ${endMonthName} ${endMonthYear}`;
    });

    const fullCalendarLabel = computed(() => `${props.calendarLabel() ?? 'Event Date'}, ${headingValue()}`);

    return {
        isDateDisabled,
        isDateUnavailable,
        isNextButtonDisabled,
        isPrevButtonDisabled,
        month,
        weekdays,
        visibleView,
        isOutsideVisibleView,
        formatter,
        nextPage,
        prevPage,
        headingValue,
        fullCalendarLabel
    };
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/Ñalendar-Ñontext.token.ts
```typescript
import { inject, InjectionToken, InputSignal, ModelSignal, WritableSignal } from '@angular/core';
import { DateValue } from '@internationalized/date';
import { DateMatcher, Formatter } from '@radix-ng/primitives/core';

export interface CalendarRootContextToken {
    nextPage?: (nextPageFunc?: (date: DateValue) => DateValue) => void;
    prevPage?: (nextPageFunc?: (date: DateValue) => DateValue) => void;
    isNextButtonDisabled: (nextPageFunc?: (date: DateValue) => DateValue) => boolean;
    isPrevButtonDisabled: (nextPageFunc?: (date: DateValue) => DateValue) => boolean;
    headingValue: WritableSignal<string>;
    dir: InputSignal<'ltr' | 'rtl'>;
    readonly: boolean;
    numberOfMonths: InputSignal<number>;
    placeholder: ModelSignal<DateValue>;
    pagedNavigation: boolean;
    disabled: InputSignal<boolean>;
    isDateSelected?: DateMatcher;
    isDateDisabled?: DateMatcher;
    isDateUnavailable: DateMatcher;
    formatter: Formatter;
    onDateChange: (date: DateValue) => void;
    currentElement: HTMLElement;
}

export const CALENDAR_ROOT_CONTEXT = new InjectionToken<CalendarRootContextToken>('CalendarRootContext');

export function injectCalendarRootContext(): CalendarRootContextToken {
    return inject(CALENDAR_ROOT_CONTEXT);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/radio/README.md
```
# @radix-ng/primitives/radio

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/radio/index.ts
```typescript
export * from './src/radio-root.directive';

export * from './src/radio-indicator.directive';
export * from './src/radio-item-input.directive';
export * from './src/radio-item.directive';

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/radio/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/radio/stories/radio-group.component.ts
```typescript
import { Component } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { RdxLabelDirective } from '@radix-ng/primitives/label';
import { RdxRadioGroupDirective, RdxRadioIndicatorDirective, RdxRadioItemDirective } from '@radix-ng/primitives/radio';
import { RdxRadioItemInputDirective } from '../src/radio-item-input.directive';

@Component({
    selector: 'radio-groups-forms-example',
    template: `
        <div
            class="RadioGroupRoot"
            [(ngModel)]="hotelRoom"
            orientation="vertical"
            rdxRadioRoot
            aria-label="View density"
        >
            @for (room of rooms; track $index) {
                <div class="RadioGroup">
                    <button class="RadioGroupItem" [value]="room" [id]="room" rdxRadioItem>
                        <div class="RadioGroupIndicator" rdxRadioIndicator></div>
                        <input class="Input" rdxRadioItemInput feature="fully-hidden" />
                    </button>
                    <label class="Label" [htmlFor]="room" rdxLabel>
                        {{ room }}
                    </label>
                </div>
            }
        </div>
        <p>
            <span>Your room is: {{ hotelRoom }}</span>
        </p>
    `,
    styleUrl: 'radio-group.styles.scss',
    imports: [
        FormsModule,
        RdxLabelDirective,
        RdxRadioItemDirective,
        RdxRadioIndicatorDirective,
        RdxRadioGroupDirective,
        RdxRadioItemInputDirective
    ]
})
export class RadioGroupComponent {
    hotelRoom: string | undefined;
    rooms = ['Default', 'Comfortable'];
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/radio/stories/radio-group.styles.scss
```
/* reset */
button {
    all: unset;
}

.RadioGroup {
    display: flex;
    align-items: center;
}

.RadioGroupRoot {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.RadioGroupItem {
    background-color: white;
    width: 25px;
    height: 25px;
    border-radius: 100%;
    box-shadow: 0 2px 10px var(--black-a7);
}

.RadioGroupItem:hover {
    background-color: var(--violet-3);
}

.RadioGroupItem:focus {
    box-shadow: 0 0 0 2px black;
}

.RadioGroupIndicator {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
    position: relative;
}

.RadioGroupIndicator::after {
    content: '';
    display: block;
    width: 11px;
    height: 11px;
    border-radius: 50%;
    background-color: var(--violet-11);
}

.RadioGroupIndicator[data-state='unchecked'] {
    display: none;
}

.Input {
    transform: translateX(-100%);
    position: absolute;
    pointer-events: none;
    opacity: 0;
    margin: 0;
    width: 25px;
    height: 25px;
}

.Label {
    color: white;
    font-size: 15px;
    line-height: 1;
    padding-left: 15px;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/radio/stories/radio.docs.mdx
````
import { ArgTypes, Canvas, Markdown, Meta } from '@storybook/blocks';
import * as RadioDirectiveStories from './radio.stories';
import { RdxRadioGroupDirective } from '../src/radio-root.directive';
import { RdxRadioItemDirective } from '../src/radio-item.directive';

<Meta title="Primitives/Radio Group" />

# Radio Group

#### A set of checkable buttonsâ€”known as radio buttonsâ€”where no more than one of the buttons can be checked at a time.

<Canvas sourceState="hidden" of={RadioDirectiveStories.Default} />

## Features

- âœ… Full keyboard navigation.
- âœ… Supports horizontal/vertical orientation.
- âœ… Can be controlled or uncontrolled.

## Import

Get started with importing the directives:

```typescript
import { RdxRadioIndicatorDirective, RadioItemDirective } from '@radix-ng/primitives/radio';
```

## Anatomy

```html
<div rdxRadioRoot>
  <button rdxRadioItem value="default">
    <div rdxRadioIndicator></div>
  </button>
</div>
```

## API Reference

### RadioGroup

`RdxRadioGroupDirective`

<ArgTypes of={RdxRadioGroupDirective} />

### RadioGroupItem

`RdxRadioGroupItemDirective`

<ArgTypes of={RdxRadioItemDirective} />

### RadioIndicator

`RdxRadioIndicatorDirective`

## Accessibility

Adheres to the [Radio Group WAI-ARIA design pattern](https://www.w3.org/WAI/ARIA/apg/patterns/radiobutton)
and uses [roving tabindex](https://www.w3.org/TR/wai-aria-practices-1.2/examples/radio/radio.html) to manage focus movement among radio items.

### Keyboard Interactions

<Markdown>
  {`
  | Key | Description |
  | ----------- | --------- |
  | Tab         | Moves focus to either the checked radio item or the first radio item in the group. |
  | Space       | When focus is on an unchecked radio item, checks it.        |
  | ArrowDown   | Moves focus and checks the next radio item in the group.    |
  | ArrowRight  |  Moves focus and checks the next radio item in the group.   |
  | ArrowUp     |  Moves focus to the previous radio item in the group.       |
  | ArrowLeft   |  Moves focus to the previous radio item in the group.       |
  `}
</Markdown>

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/radio/stories/radio.stories.ts
```typescript
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { RdxLabelDirective } from '../../label';
import { RdxRovingFocusGroupDirective, RdxRovingFocusItemDirective } from '../../roving-focus';
import { RdxRadioIndicatorDirective } from '../src/radio-indicator.directive';
import { RdxRadioItemInputDirective } from '../src/radio-item-input.directive';
import { RdxRadioItemDirective } from '../src/radio-item.directive';
import { RdxRadioGroupDirective } from '../src/radio-root.directive';
import { RadioGroupComponent } from './radio-group.component';

const html = String.raw;

export default {
    title: 'Primitives/Radio Group',
    decorators: [
        moduleMetadata({
            imports: [
                RdxLabelDirective,
                RdxRadioItemDirective,
                RdxRadioIndicatorDirective,
                RdxRadioItemInputDirective,
                RdxRadioGroupDirective,
                RdxRovingFocusGroupDirective,
                RdxRovingFocusItemDirective,
                RadioGroupComponent
            ]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div class="radix-themes light light-theme" data-radius="medium" data-scaling="100%">${story}</div>

                <style>
                    /* reset */
                    button {
                        all: unset;
                    }

                    .RadioGroupRoot {
                        display: flex;
                        flex-direction: column;
                        gap: 10px;
                    }

                    .RadioGroupItem {
                        background-color: white;
                        width: 25px;
                        height: 25px;
                        border-radius: 100%;
                        box-shadow: 0 2px 10px var(--black-a7);
                    }
                    .RadioGroupItem:hover {
                        background-color: var(--violet-3);
                    }
                    .RadioGroupItem:focus {
                        box-shadow: 0 0 0 2px black;
                    }

                    .RadioGroupItem:disabled {
                        background-color: var(--gray-4);
                        box-shadow: none;
                        cursor: not-allowed;
                    }

                    .RadioGroupItem:disabled:hover {
                        background-color: var(--gray-4);
                    }

                    .RadioGroupIndicator {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        width: 100%;
                        height: 100%;
                        position: relative;
                    }
                    .RadioGroupIndicator::after {
                        content: '';
                        display: block;
                        width: 11px;
                        height: 11px;
                        border-radius: 50%;
                        background-color: var(--violet-11);
                    }

                    .RadioGroupIndicator[data-state='unchecked'] {
                        display: none;
                    }

                    .Input {
                        transform: translateX(-100%);
                        position: absolute;
                        pointer-events: none;
                        opacity: 0;
                        margin: 0;
                        width: 25px;
                        height: 25px;
                    }

                    .Label {
                        color: white;
                        font-size: 15px;
                        line-height: 1;
                        padding-left: 15px;
                    }
                </style>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: html`
            <form>
                <div class="RadioGroupRoot" rdxRadioRoot orientation="vertical" aria-label="View density">
                    <div style="display: flex; align-items: center;">
                        <button class="RadioGroupItem" id="r1" rdxRadioItem value="default">
                            <div class="RadioGroupIndicator" rdxRadioIndicator></div>
                            <input class="Input" rdxRadioItemInput feature="fully-hidden" />
                        </button>
                        <label class="Label" rdxLabel htmlFor="r1">Default</label>
                    </div>
                    <div style="display: flex; align-items: center;">
                        <button class="RadioGroupItem" id="r2" rdxRadioItem [required]="true" value="comfortable">
                            <div class="RadioGroupIndicator" rdxRadioIndicator></div>
                            <input class="Input" rdxRadioItemInput feature="fully-hidden" />
                        </button>
                        <label class="Label" rdxLabel htmlFor="r2">Comfortable</label>
                    </div>
                    <div style="display: flex; align-items: center;">
                        <button class="RadioGroupItem" id="r3" rdxRadioItem value="compact">
                            <div class="RadioGroupIndicator" rdxRadioIndicator></div>
                            <input class="Input" rdxRadioItemInput feature="fully-hidden" />
                        </button>
                        <label class="Label" rdxLabel htmlFor="r3">Compact</label>
                    </div>
                </div>
            </form>
        `
    })
};

export const RadioGroup: Story = {
    render: () => ({
        template: `<radio-groups-forms-example></radio-groups-forms-example>`
    })
};

export const DisabledGroup: Story = {
    render: () => ({
        template: html`
            <div
                class="RadioGroupRoot"
                rdxRadioRoot
                [value]="'comfortable'"
                disabled
                orientation="vertical"
                aria-label="View density"
            >
                <div style="display: flex; align-items: center;">
                    <button class="RadioGroupItem" id="r1" rdxRadioItem value="default">
                        <div class="RadioGroupIndicator" rdxRadioIndicator></div>
                        <input class="Input" rdxRadioItemInput feature="fully-hidden" />
                    </button>
                    <label class="Label" rdxLabel htmlFor="r1">Default</label>
                </div>
                <div style="display: flex; align-items: center;">
                    <button class="RadioGroupItem" id="r2" rdxRadioItem [required]="true" value="comfortable">
                        <div class="RadioGroupIndicator" rdxRadioIndicator></div>
                        <input class="Input" rdxRadioItemInput feature="fully-hidden" />
                    </button>
                    <label class="Label" rdxLabel htmlFor="r2">Comfortable</label>
                </div>
                <div style="display: flex; align-items: center;">
                    <button class="RadioGroupItem" id="r3" rdxRadioItem value="compact">
                        <div class="RadioGroupIndicator" rdxRadioIndicator></div>
                        <input class="Input" rdxRadioItemInput feature="fully-hidden" />
                    </button>
                    <label class="Label" rdxLabel htmlFor="r3">Compact</label>
                </div>
            </div>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/radio/src/radio-indicator.directive.ts
```typescript
import { Directive, inject } from '@angular/core';
import { RdxRadioItemDirective } from './radio-item.directive';
import { RDX_RADIO_GROUP, RadioGroupDirective } from './radio-tokens';

@Directive({
    selector: '[rdxRadioIndicator]',
    exportAs: 'rdxRadioIndicator',
    host: {
        '[attr.data-state]': 'radioItem.checkedState() ? "checked" : "unchecked"',
        '[attr.data-disabled]': 'radioItem.disabled() ? "" : undefined'
    }
})
export class RdxRadioIndicatorDirective {
    protected readonly radioGroup: RadioGroupDirective = inject(RDX_RADIO_GROUP);
    protected readonly radioItem: RdxRadioItemDirective = inject(RdxRadioItemDirective);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/radio/src/radio-item-input.directive.ts
```typescript
import { computed, Directive, input } from '@angular/core';
import { RdxVisuallyHiddenDirective } from '@radix-ng/primitives/visually-hidden';
import { injectRadioItem } from './radio-item.directive';

@Directive({
    selector: '[rdxRadioItemInput]',
    exportAs: 'rdxRadioItemInput',
    hostDirectives: [
        { directive: RdxVisuallyHiddenDirective, inputs: ['feature'] }],
    host: {
        type: 'radio',
        '[attr.name]': 'name()',
        '[attr.required]': 'required()',
        '[attr.disabled]': 'disabled() ? disabled() : undefined',
        '[attr.checked]': 'checked()',
        '[value]': 'value()'
    }
})
export class RdxRadioItemInputDirective {
    private readonly radioItem = injectRadioItem();

    readonly name = input<string>();
    readonly value = computed(() => this.radioItem.value() || undefined);
    readonly checked = computed(() => this.radioItem.checkedState() || undefined);
    readonly required = input<boolean | undefined>(this.radioItem.required());
    readonly disabled = input<boolean | undefined>(this.radioItem.disabled());
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/radio/src/radio-item.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import {
    booleanAttribute,
    computed,
    Directive,
    ElementRef,
    inject,
    InjectionToken,
    input,
    OnInit,
    signal
} from '@angular/core';
import { provideToken } from '@radix-ng/primitives/core';
import { RdxRovingFocusItemDirective } from '@radix-ng/primitives/roving-focus';
import { RDX_RADIO_GROUP } from './radio-tokens';

export const RdxRadioItemToken = new InjectionToken<RdxRadioItemDirective>('RadioItemToken');

export function injectRadioItem(): RdxRadioItemDirective {
    return inject(RdxRadioItemToken);
}

@Directive({
    selector: '[rdxRadioItem]',
    exportAs: 'rdxRadioItem',
    providers: [provideToken(RdxRadioItemToken, RdxRadioItemDirective)],
    hostDirectives: [
        { directive: RdxRovingFocusItemDirective, inputs: ['tabStopId: id', 'focusable', 'active', 'allowShiftKey'] }],

    host: {
        type: 'button',
        role: 'radio',
        '[attr.aria-checked]': 'checkedState()',
        '[attr.data-disabled]': 'disabledState() ? "" : null',
        '[attr.data-state]': 'checkedState() ? "checked" : "unchecked"',
        '[disabled]': 'disabledState()',
        '(click)': 'onClick()',
        '(keydown)': 'onKeyDown($event)',
        '(keyup)': 'onKeyUp()',
        '(focus)': 'onFocus()'
    }
})
export class RdxRadioItemDirective implements OnInit {
    private readonly radioGroup = inject(RDX_RADIO_GROUP);
    private readonly elementRef = inject(ElementRef);

    readonly value = input.required<string>();

    readonly id = input<string>();

    readonly required = input<boolean>();

    readonly disabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    protected readonly disabledState = computed(() => this.radioGroup.disableState() || this.disabled());

    readonly checkedState = computed(() => this.radioGroup.value() === this.value());

    private readonly ARROW_KEYS = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
    private readonly isArrowKeyPressedSignal = signal(false);

    /** @ignore */
    ngOnInit() {
        if (this.radioGroup.defaultValue === this.value()) {
            this.radioGroup.select(this.value());
        }
    }

    /** @ignore */
    onClick() {
        if (!this.disabledState()) {
            this.radioGroup.select(this.value());
            this.isArrowKeyPressedSignal.set(true);
        }
    }

    /** @ignore */
    onKeyDown(event: KeyboardEvent): void {
        if (this.ARROW_KEYS.includes(event.key)) {
            this.isArrowKeyPressedSignal.set(true);
        }
    }

    /** @ignore */
    onKeyUp() {
        this.isArrowKeyPressedSignal.set(false);
    }

    /** @ignore */
    onFocus() {
        this.radioGroup.select(this.value());
        setTimeout(() => {
            /**
             * When navigating with arrow keys, focus triggers on the radio item.
             * To "check" the radio, we programmatically trigger a click event.
             */
            if (this.isArrowKeyPressedSignal()) {
                this.elementRef.nativeElement.click();
            }
        }, 0);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/radio/src/radio-root.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { booleanAttribute, computed, Directive, input, Input, model, output, signal } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { provideValueAccessor } from '@radix-ng/primitives/core';
import { Orientation, RdxRovingFocusGroupDirective } from '@radix-ng/primitives/roving-focus';
import { RadioGroupDirective, RadioGroupProps, RDX_RADIO_GROUP } from './radio-tokens';

@Directive({
    selector: '[rdxRadioRoot]',
    exportAs: 'rdxRadioRoot',
    providers: [
        provideValueAccessor(RdxRadioGroupDirective),
        { provide: RDX_RADIO_GROUP, useExisting: RdxRadioGroupDirective }],
    hostDirectives: [{ directive: RdxRovingFocusGroupDirective, inputs: ['dir', 'orientation', 'loop'] }],
    host: {
        role: 'radiogroup',
        '[attr.aria-orientation]': 'orientation()',
        '[attr.aria-required]': 'required()',
        '[attr.data-disabled]': 'disableState() ? "" : null',
        '(keydown)': 'onKeydown()'
    }
})
export class RdxRadioGroupDirective implements RadioGroupProps, RadioGroupDirective, ControlValueAccessor {
    readonly value = model<string | null>(null);

    readonly disabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    @Input() defaultValue?: string;

    readonly required = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    readonly orientation = input<Orientation>();

    /**
     * Event handler called when the value changes.
     */
    readonly onValueChange = output<string>();

    private readonly disable = signal<boolean>(this.disabled());
    readonly disableState = computed(() => this.disable() || this.disabled());

    /**
     * The callback function to call when the value of the radio group changes.
     */
    private onChange: (value: string) => void = () => {
        /* Empty */
    };

    /**
     * The callback function to call when the radio group is touched.
     * @ignore
     */
    onTouched: () => void = () => {
        /* Empty */
    };

    /**
     * Select a radio item.
     * @param value The value of the radio item to select.
     * @ignore
     */
    select(value: string): void {
        this.value.set(value);
        this.onValueChange.emit(value);
        this.onChange?.(value);
        this.onTouched();
    }

    /**
     * Update the value of the radio group.
     * @param value The new value of the radio group.
     * @ignore
     */
    writeValue(value: string): void {
        this.value.set(value);
    }

    /**
     * Register a callback function to call when the value of the radio group changes.
     * @param fn The callback function to call when the value of the radio group changes.
     * @ignore
     */
    registerOnChange(fn: (value: string) => void): void {
        this.onChange = fn;
    }

    /** @ignore */
    registerOnTouched(fn: () => void): void {
        this.onTouched = fn;
    }

    /**
     * Set the disabled state of the radio group.
     * @param isDisabled Whether the radio group is disabled.
     * @ignore
     */
    setDisabledState(isDisabled: boolean): void {
        this.disable.set(isDisabled);
    }

    protected onKeydown(): void {
        if (this.disableState()) return;
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/radio/src/radio-tokens.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { InjectionToken, InputSignalWithTransform, ModelSignal, Signal } from '@angular/core';

export interface RadioGroupProps {
    name?: string;
    disabled?: InputSignalWithTransform<boolean, BooleanInput>;
    defaultValue?: string;
    value: ModelSignal<string | null>;
    disableState: Signal<boolean>;
}

export interface RadioGroupDirective extends RadioGroupProps {
    select(value: string | null): void;

    onTouched(): void;
}

export const RDX_RADIO_GROUP = new InjectionToken<RadioGroupDirective>('RdxRadioGroup');

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/index.ts
```typescript
export * from './src/accessor/provide-value-accessor';
export * from './src/auto-focus.directive';
export * from './src/document';
export * from './src/focus-initial.directive';
export * from './src/id-generator';
export * from './src/inject-ng-control';
export * from './src/is-client';
export * from './src/is-inside-form';
export * from './src/is-nullish';
export * from './src/is-number';
export * from './src/kbd-constants';
export * from './src/provide-token';
export * from './src/window';

export * from './src/date-time';
export * from './src/positioning/constants';
export * from './src/positioning/types';
export * from './src/positioning/utils';
export * from './src/watch';

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/auto-focus.directive.ts
```typescript
import { booleanAttribute, Directive, ElementRef, inject, Input, NgZone } from '@angular/core';

/*
 * <div [rdxAutoFocus]="true"></div>
 */

@Directive({
    selector: '[rdxAutoFocus]',
    standalone: true
})
export class RdxAutoFocusDirective {
    #elementRef = inject(ElementRef);
    #ngZone = inject(NgZone);

    private _autoSelect = false;

    /**
     * @default false
     */
    @Input({ alias: 'rdxAutoFocus', transform: booleanAttribute })
    set autoFocus(value: boolean) {
        if (value) {
            // Note: Running this outside Angular's zone because `element.focus()` does not trigger change detection.
            this.#ngZone.runOutsideAngular(() =>
                // Note: `element.focus()` causes re-layout which might lead to frame drops on slower devices.
                // https://gist.github.com/paulirish/5d52fb081b3570c81e3a#setting-focus
                // `setTimeout` is a macrotask executed within the current rendering frame.
                // Animation tasks are executed in the next rendering frame.
                reqAnimationFrame(() => {
                    this.#elementRef.nativeElement.focus();
                    if (this._autoSelect && this.#elementRef.nativeElement.select) {
                        this.#elementRef.nativeElement.select();
                    }
                })
            );
        }
    }

    // Setter for autoSelect attribute to enable text selection when autoFocus is true.
    @Input({ transform: booleanAttribute })
    set autoSelect(value: boolean) {
        this._autoSelect = value;
    }
}

const availablePrefixes = ['moz', 'ms', 'webkit'];

function requestAnimationFramePolyfill(): typeof requestAnimationFrame {
    let lastTime = 0;

    return function (callback: FrameRequestCallback): number {
        const currTime = new Date().getTime();
        const timeToCall = Math.max(0, 16 - (currTime - lastTime));

        const id = setTimeout(() => {
            callback(currTime + timeToCall);
        }, timeToCall) as any;

        lastTime = currTime + timeToCall;

        return id;
    };
}

// Function to get the appropriate requestAnimationFrame method with fallback to polyfill.
function getRequestAnimationFrame(): typeof requestAnimationFrame {
    if (typeof window === 'undefined') {
        return () => 0;
    }
    if (window.requestAnimationFrame) {
        // https://github.com/vuejs/vue/issues/4465
        return window.requestAnimationFrame.bind(window);
    }

    const prefix = availablePrefixes.filter((key) => `${key}RequestAnimationFrame` in window)[0];

    return prefix ? (window as any)[`${prefix}RequestAnimationFrame`] : requestAnimationFramePolyfill();
}

// Get the requestAnimationFrame function or its polyfill.
const reqAnimationFrame = getRequestAnimationFrame();

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/chunk.ts
````typescript
/**
 * Splits an array into chunks of a given size.
 * @param arr The array to split.
 * @param size The size of each chunk.
 * @returns An array of arrays, where each sub-array has `size` elements from the original array.
 * @example ```ts
 * const arr = [1, 2, 3, 4, 5, 6, 7, 8];
 * const chunks = chunk(arr, 3);
 * // chunks = [[1, 2, 3], [4, 5, 6], [7, 8]]
 * ```
 */
export function chunk<T>(arr: T[], size: number): T[][] {
    const result = [];
    for (let i = 0; i < arr.length; i += size) result.push(arr.slice(i, i + size));

    return result;
}

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/document.ts
```typescript
import { DOCUMENT } from '@angular/common';
import { inject } from '@angular/core';

export function injectDocument(): Document {
    return inject(DOCUMENT);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/focus-initial.directive.ts
```typescript
import { Directive, ElementRef, inject } from '@angular/core';

@Directive({
    selector: '[rdxFocusInitial]'
})
export class RdxFocusInitialDirective {
    /** @ignore */
    private readonly nativeElement = inject(ElementRef).nativeElement;

    /** @ignore */
    focus(): void {
        this.nativeElement.focus();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/id-generator.ts
```typescript
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */

import { APP_ID, inject, Injectable } from '@angular/core';

/**
 * Keeps track of the ID count per prefix. This helps us make the IDs a bit more deterministic
 * like they were before the service was introduced. Note that ideally we wouldn't have to do
 * this, but there are some internal tests that rely on the IDs.
 */
const counters: Record<string, number> = {};

/** Service that generates unique IDs for DOM nodes. */
@Injectable({ providedIn: 'root' })
export class _IdGenerator {
    private readonly _appId = inject(APP_ID);

    /**
     * Generates a unique ID with a specific prefix.
     * @param prefix Prefix to add to the ID.
     */
    getId(prefix: string): string {
        // Omit the app ID if it's the default `ng`. Since the vast majority of pages have one
        // Angular app on them, we can reduce the amount of breakages by not adding it.
        if (this._appId !== 'ng') {
            prefix += this._appId;
        }

        if (!Object.prototype.hasOwnProperty.call(counters, prefix)) {
            counters[prefix] = 0;
        }

        return `${prefix}${counters[prefix]++}`;
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/inject-ng-control.ts
```typescript
import { inject } from '@angular/core';
import { FormControlDirective, FormControlName, NgControl, NgModel } from '@angular/forms';

export function injectNgControl(params: {
    optional: true;
}): FormControlDirective | FormControlName | NgModel | undefined;
export function injectNgControl(params: { optional: false }): FormControlDirective | FormControlName | NgModel;
export function injectNgControl(): FormControlDirective | FormControlName | NgModel;

export function injectNgControl(params?: { optional: true } | { optional: false }) {
    const ngControl = inject(NgControl, { self: true, optional: true });

    if (!params?.optional && !ngControl) throw new Error('NgControl not found');

    if (
        ngControl instanceof FormControlDirective ||
        ngControl instanceof FormControlName ||
        ngControl instanceof NgModel
    ) {
        return ngControl;
    }

    if (params?.optional) {
        return undefined;
    }

    throw new Error('NgControl is not an instance of FormControlDirective, FormControlName or NgModel');
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/is-client.ts
```typescript
import { Platform } from '@angular/cdk/platform';
import { inject } from '@angular/core';

export function injectIsClient() {
    return inject(Platform).isBrowser;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/is-inside-form.ts
```typescript
import { ElementRef } from '@angular/core';

export function isInsideForm(el: ElementRef<HTMLElement> | null): boolean {
    if (!el || !el.nativeElement) {
        return true;
    }
    return Boolean(el.nativeElement.closest('form'));
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/is-nullish.ts
```typescript
export function isNullish(value: any): value is null | undefined {
    return value === null || value === undefined;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/is-number.ts
```typescript
export const isNumber = (v: any): v is number => typeof v === 'number';

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/kbd-constants.ts
```typescript
export const ALT = 'Alt';
export const ARROW_DOWN = 'ArrowDown';
export const ARROW_LEFT = 'ArrowLeft';
export const ARROW_RIGHT = 'ArrowRight';
export const ARROW_UP = 'ArrowUp';
export const BACKSPACE = 'Backspace';
export const CAPS_LOCK = 'CapsLock';
export const CONTROL = 'Control';
export const DELETE = 'Delete';
export const END = 'End';
export const ENTER = 'Enter';
export const ESCAPE = 'Escape';
export const F1 = 'F1';
export const F10 = 'F10';
export const F11 = 'F11';
export const F12 = 'F12';
export const F2 = 'F2';
export const F3 = 'F3';
export const F4 = 'F4';
export const F5 = 'F5';
export const F6 = 'F6';
export const F7 = 'F7';
export const F8 = 'F8';
export const F9 = 'F9';
export const HOME = 'Home';
export const META = 'Meta';
export const PAGE_DOWN = 'PageDown';
export const PAGE_UP = 'PageUp';
export const SHIFT = 'Shift';
export const SPACE = ' ';
export const TAB = 'Tab';
export const CTRL = 'Control';
export const ASTERISK = '*';
export const a = 'a';
export const P = 'P';
export const A = 'A';
export const p = 'p';
export const n = 'n';
export const j = 'j';
export const k = 'k';
export const SPACE_CODE = 'Space';

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/mount.ts
```typescript
import { AfterViewInit, Directive } from '@angular/core';

const callAll =
    <T extends (...a: never[]) => void>(...fns: (T | undefined)[]) =>
    (...a: Parameters<T>) => {
        fns.forEach(function (fn) {
            fn?.(...a);
        });
    };

@Directive({
    standalone: true
})
export class OnMountDirective implements AfterViewInit {
    #onMountFns?: () => void;

    onMount(fn: () => void) {
        this.#onMountFns = callAll(this.#onMountFns, fn);
    }

    ngAfterViewInit() {
        if (!this.#onMountFns) {
            throw new Error('The onMount function must be called before the component is mounted.');
        }
        this.#onMountFns();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/provide-token.ts
```typescript
import { forwardRef, InjectionToken, Provider, Type } from '@angular/core';

/**
 * Creates an Angular provider that binds the given token to the existing instance
 * of the specified class. This is especially useful when you want multiple
 * tokens (or interfaces) to resolve to the same directive/component instance.
 *
 * @template T - The type associated with the injection token.
 * @param token - The InjectionToken or abstract type you want to provide.
 * @param type  - The class type whose existing instance will be used for this token.
 * @returns A Provider configuration object for Angular's DI system.
 *
 * @example
 *
 * @Directive({
 *   providers: [
 *     provideToken(RdxToggleGroupToken, RdxToggleGroupDirective),
 *     provideValueAccessor(RdxToggleGroupDirective)
 *   ]
 * })
 * export class RdxToggleGroupDirective {}
 */
export function provideToken<T>(token: InjectionToken<T>, type: Type<unknown>): Provider {
    return {
        provide: token,
        useExisting: forwardRef(() => type)
    };
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/types.ts
````typescript
/**
 * Nullable from `Type` adds `null` and `undefined`
 *
 * @example ```ts
 *  // Expect: string | number | undefined | null
 *  type Value = Nulling<string | number>;
 * ```
 */
export type Nullable<Type> = null | Type | undefined;

/**
 * SafeFunction is a type for functions that accept any number of arguments of unknown types
 * and return a value of an unknown type. This is useful when you want to define a function
 * without being strict about the input or output types, maintaining flexibility.
 *
 * @example ```ts
 *  const safeFn: SafeFunction = (...args) => {
 *    return args.length > 0 ? args[0] : null;
 *  };
 *
 *  const result = safeFn(1, 'hello'); // result: 1
 * ```
 */
export type SafeFunction = (...args: unknown[]) => unknown;

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/watch.ts
````typescript
// https://ngxtension.netlify.app/utilities/signals/explicit-effect/

import { CreateEffectOptions, EffectCleanupRegisterFn, EffectRef, effect, untracked } from '@angular/core';

/**
 * We want to have the Tuple in order to use the types in the function signature
 */
type ExplicitEffectValues<T> = {
    [K in keyof T]: () => T[K];
};

/**
 * Extend the regular set of effect options
 */
declare interface CreateExplicitEffectOptions extends CreateEffectOptions {
    /**
     * Option that allows the computation not to execute immediately, but only run on first change.
     */
    defer?: boolean;
}

/**
 * This explicit effect function will take the dependencies and the function to run when the dependencies change.
 *
 * @example
 * ```typescript
 * import { watch } from 'radix-ng/primitives/core';
 *
 * const count = signal(0);
 * const state = signal('idle');
 *
 * watch([count, state], ([count, state], cleanup) => {
 *   console.log('count updated', count, state);
 *
 *   cleanup(() => {
 *     console.log('cleanup');
 *   });
 * });
 * ```
 *
 * @param deps - The dependencies that the effect will run on
 * @param fn - The function to run when the dependencies change
 * @param options - The options for the effect with the addition of defer (it allows the computation to run on first change, not immediately)
 */
export function watch<Input extends readonly unknown[], Params = Input>(
    deps: readonly [...ExplicitEffectValues<Input>],
    fn: (deps: Params, onCleanup: EffectCleanupRegisterFn) => void,
    options?: CreateExplicitEffectOptions | undefined
): EffectRef {
    let defer = options && options.defer;
    return effect((onCleanup) => {
        const depValues = deps.map((s) => s());
        untracked(() => {
            if (!defer) {
                fn(depValues as any, onCleanup);
            }
            defer = false;
        });
    }, options);
}

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/window.ts
```typescript
import { inject, InjectionToken } from '@angular/core';
import { injectDocument } from './document';

export const WINDOW = new InjectionToken<Window & typeof globalThis>('An abstraction over global window object', {
    factory: () => {
        const { defaultView } = injectDocument();
        if (!defaultView) {
            throw new Error('Window is not available');
        }
        return defaultView;
    }
});

export function injectWindow(): Window & typeof globalThis {
    return inject(WINDOW);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/date-time/calendar.ts
```typescript
import { DateValue, endOfMonth, startOfMonth } from '@internationalized/date';
import { chunk } from '../chunk';
import { getDaysInMonth, getLastFirstDayOfWeek, getNextLastDayOfWeek } from './comparators';
import { Month } from './types';

export type CreateMonthProps = {
    /**
     * The date object representing the month's date (usually the first day of the month).
     */
    dateObj: DateValue;

    /**
     * The day of the week to start the calendar on (0 for Sunday, 1 for Monday, etc.).
     */
    weekStartsOn: number;

    /**
     * Whether to always render 6 weeks in the calendar, even if the month doesn't
     * span 6 weeks.
     */
    fixedWeeks: boolean;

    /**
     * The locale to use when creating the calendar month.
     */
    locale: string;
};

/**
 * Retrieves an array of date values representing the days between
 * the provided start and end dates.
 */
export function getDaysBetween(start: DateValue, end: DateValue) {
    const days: DateValue[] = [];
    let dCurrent = start.add({ days: 1 });
    const dEnd = end;
    while (dCurrent.compare(dEnd) < 0) {
        days.push(dCurrent);
        dCurrent = dCurrent.add({ days: 1 });
    }
    return days;
}

export function createMonth(props: CreateMonthProps): Month<DateValue> {
    const { dateObj, weekStartsOn, fixedWeeks, locale } = props;
    const daysInMonth = getDaysInMonth(dateObj);

    const datesArray = Array.from({ length: daysInMonth }, (_, i) => dateObj.set({ day: i + 1 }));

    const firstDayOfMonth = startOfMonth(dateObj);
    const lastDayOfMonth = endOfMonth(dateObj);

    const lastSunday = getLastFirstDayOfWeek(firstDayOfMonth, weekStartsOn, locale);
    const nextSaturday = getNextLastDayOfWeek(lastDayOfMonth, weekStartsOn, locale);

    const lastMonthDays = getDaysBetween(lastSunday.subtract({ days: 1 }), firstDayOfMonth);
    const nextMonthDays = getDaysBetween(lastDayOfMonth, nextSaturday.add({ days: 1 }));

    const totalDays = lastMonthDays.length + datesArray.length + nextMonthDays.length;

    if (fixedWeeks && totalDays < 42) {
        const extraDays = 42 - totalDays;

        let startFrom = nextMonthDays[nextMonthDays.length - 1];

        if (!startFrom) startFrom = endOfMonth(dateObj);

        const extraDaysArray = Array.from({ length: extraDays }, (_, i) => {
            const incr = i + 1;
            return startFrom.add({ days: incr });
        });
        nextMonthDays.push(...extraDaysArray);
    }

    const allDays = lastMonthDays.concat(datesArray, nextMonthDays);

    const weeks = chunk(allDays, 7);

    return {
        value: dateObj,
        dates: allDays,
        weeks: weeks
    };
}

type SetMonthProps = CreateMonthProps & {
    numberOfMonths: number | undefined;
    currentMonths?: Month<DateValue>[];
};

export function createMonths(props: SetMonthProps) {
    const { numberOfMonths, dateObj, ...monthProps } = props;

    const months: Month<DateValue>[] = [];

    if (!numberOfMonths || numberOfMonths === 1) {
        months.push(
            createMonth({
                ...monthProps,
                dateObj
            })
        );
        return months;
    }

    months.push(
        createMonth({
            ...monthProps,
            dateObj
        })
    );

    // Create all the months, starting with the current month
    for (let i = 1; i < numberOfMonths; i++) {
        const nextMonth = dateObj.add({ months: i });
        months.push(
            createMonth({
                ...monthProps,
                dateObj: nextMonth
            })
        );
    }

    return months;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/date-time/comparators.ts
```typescript
import {
    CalendarDate,
    CalendarDateTime,
    createCalendar,
    DateFormatter,
    type DateValue,
    getDayOfWeek,
    getLocalTimeZone,
    toCalendar,
    ZonedDateTime
} from '@internationalized/date';
import type { DateMatcher } from './types';

/**
 * Given a `DateValue` object, convert it to a native `Date` object.
 * If a timezone is provided, the date will be converted to that timezone.
 * If no timezone is provided, the date will be converted to the local timezone.
 */
export function toDate(dateValue: DateValue, tz: string = getLocalTimeZone()) {
    if (isZonedDateTime(dateValue)) return dateValue.toDate();
    else return dateValue.toDate(tz);
}

export function isCalendarDateTime(dateValue: DateValue): dateValue is CalendarDateTime {
    return dateValue instanceof CalendarDateTime;
}

export function isZonedDateTime(dateValue: DateValue): dateValue is ZonedDateTime {
    return dateValue instanceof ZonedDateTime;
}

export function hasTime(dateValue: DateValue) {
    return isCalendarDateTime(dateValue) || isZonedDateTime(dateValue);
}

/**
 * Given a date, return the number of days in the month.
 */
export function getDaysInMonth(date: Date | DateValue) {
    if (date instanceof Date) {
        const year = date.getFullYear();
        const month = date.getMonth() + 1;
        /**
         * By using zero as the day, we get the
         * last day of the previous month, which
         * is the month we originally passed in.
         */
        return new Date(year, month, 0).getDate();
    } else {
        return date.set({ day: 100 }).day;
    }
}

/**
 * Determine if a date is before the reference date.
 * @param dateToCompare - is this date before the `referenceDate`
 * @param referenceDate - is the `dateToCompare` before this date
 *
 * @see {@link isBeforeOrSame} for inclusive
 */
export function isBefore(dateToCompare: DateValue, referenceDate: DateValue) {
    return dateToCompare.compare(referenceDate) < 0;
}

/**
 * Determine if a date is after the reference date.
 * @param dateToCompare - is this date after the `referenceDate`
 * @param referenceDate - is the `dateToCompare` after this date
 *
 * @see {@link isAfterOrSame} for inclusive
 */
export function isAfter(dateToCompare: DateValue, referenceDate: DateValue) {
    return dateToCompare.compare(referenceDate) > 0;
}

/**
 * Determine if a date is before or the same as the reference date.
 *
 * @param dateToCompare - the date to compare
 * @param referenceDate - the reference date to make the comparison against
 *
 * @see {@link isBefore} for non-inclusive
 */
export function isBeforeOrSame(dateToCompare: DateValue, referenceDate: DateValue) {
    return dateToCompare.compare(referenceDate) <= 0;
}

/**
 * Determine if a date is after or the same as the reference date.
 *
 * @param dateToCompare - is this date after or the same as the `referenceDate`
 * @param referenceDate - is the `dateToCompare` after or the same as this date
 *
 * @see {@link isAfter} for non-inclusive
 */
export function isAfterOrSame(dateToCompare: DateValue, referenceDate: DateValue) {
    return dateToCompare.compare(referenceDate) >= 0;
}

/**
 * Determine if a date is inclusively between a start and end reference date.
 *
 * @param date - is this date inclusively between the `start` and `end` dates
 * @param start - the start reference date to make the comparison against
 * @param end - the end reference date to make the comparison against
 *
 * @see {@link isBetween} for non-inclusive
 */
export function isBetweenInclusive(date: DateValue, start: DateValue, end: DateValue) {
    return isAfterOrSame(date, start) && isBeforeOrSame(date, end);
}

/**
 * Determine if a date is between a start and end reference date.
 *
 * @param date - is this date between the `start` and `end` dates
 * @param start - the start reference date to make the comparison against
 * @param end - the end reference date to make the comparison against
 *
 * @see {@link isBetweenInclusive} for inclusive
 */
export function isBetween(date: DateValue, start: DateValue, end: DateValue) {
    return isAfter(date, start) && isBefore(date, end);
}

export function getLastFirstDayOfWeek<T extends DateValue = DateValue>(
    date: T,
    firstDayOfWeek: number,
    locale: string
): T {
    const day = getDayOfWeek(date, locale);

    if (firstDayOfWeek > day) return date.subtract({ days: day + 7 - firstDayOfWeek }) as T;

    if (firstDayOfWeek === day) return date as T;

    return date.subtract({ days: day - firstDayOfWeek }) as T;
}

export function getNextLastDayOfWeek<T extends DateValue = DateValue>(
    date: T,
    firstDayOfWeek: number,
    locale: string
): T {
    const day = getDayOfWeek(date, locale);
    const lastDayOfWeek = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;

    if (day === lastDayOfWeek) return date as T;

    if (day > lastDayOfWeek) return date.add({ days: 7 - day + lastDayOfWeek }) as T;

    return date.add({ days: lastDayOfWeek - day }) as T;
}

export function areAllDaysBetweenValid(
    start: DateValue,
    end: DateValue,
    isUnavailable: DateMatcher | undefined,
    isDisabled: DateMatcher | undefined
) {
    if (isUnavailable === undefined && isDisabled === undefined) return true;

    let dCurrent = start.add({ days: 1 });
    if (isDisabled?.(dCurrent) || isUnavailable?.(dCurrent)) return false;

    const dEnd = end;
    while (dCurrent.compare(dEnd) < 0) {
        dCurrent = dCurrent.add({ days: 1 });
        if (isDisabled?.(dCurrent) || isUnavailable?.(dCurrent)) return false;
    }
    return true;
}

export type Granularity = 'day' | 'hour' | 'minute' | 'second';
export type TimeGranularity = 'hour' | 'minute' | 'second';

type GetDefaultDateProps = {
    defaultValue?: DateValue | DateValue[] | undefined;
    defaultPlaceholder?: DateValue | undefined;
    granularity?: Granularity;
    locale?: string;
};

/**
 * A helper function used throughout the various date builders
 * to generate a default `DateValue` using the `defaultValue`,
 * `defaultPlaceholder`, and `granularity` props.
 *
 * It's important to match the `DateValue` type being used
 * elsewhere in the builder, so they behave according to the
 * behavior the user expects based on the props they've provided.
 *
 */
export function getDefaultDate(props: GetDefaultDateProps): DateValue {
    const { defaultValue, defaultPlaceholder, granularity = 'day', locale = 'en' } = props;

    if (Array.isArray(defaultValue) && defaultValue.length) return defaultValue[defaultValue.length - 1]!.copy();

    if (defaultValue && !Array.isArray(defaultValue)) return defaultValue.copy();

    if (defaultPlaceholder) return defaultPlaceholder.copy();

    const date = new Date();
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const calendarDateTimeGranularities = ['hour', 'minute', 'second'];

    const defaultFormatter = new DateFormatter(locale);
    const calendar = createCalendar(defaultFormatter.resolvedOptions().calendar);

    if (calendarDateTimeGranularities.includes(granularity ?? 'day'))
        return toCalendar(new CalendarDateTime(year, month, day, 0, 0, 0), calendar);

    return toCalendar(new CalendarDate(year, month, day), calendar);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/date-time/formatter.ts
```typescript
import { DateFormatter, type DateValue, getLocalTimeZone, today } from '@internationalized/date';
import { hasTime, isZonedDateTime, toDate } from './comparators';
import { HourCycle } from './types';

const defaultPartOptions: Intl.DateTimeFormatOptions = {
    year: 'numeric',
    month: 'numeric',
    day: 'numeric',
    hour: 'numeric',
    minute: 'numeric',
    second: 'numeric'
};

export interface DateFormatterOptions extends Intl.DateTimeFormatOptions {
    calendar?: string;
}

export type Formatter = {
    getLocale: () => string;
    setLocale: (newLocale: string) => void;
    custom: (date: Date, options: DateFormatterOptions) => string;
    selectedDate: (date: DateValue, includeTime?: boolean) => string;
    dayOfWeek: (date: Date, length?: DateFormatterOptions['weekday']) => string;
    fullMonthAndYear: (date: Date, options?: DateFormatterOptions) => string;
    fullMonth: (date: Date, options?: DateFormatterOptions) => string;
    fullYear: (date: Date, options?: DateFormatterOptions) => string;
    dayPeriod: (date: Date) => string;
    part: (dateObj: DateValue, type: Intl.DateTimeFormatPartTypes, options?: DateFormatterOptions) => string;
    toParts: (date: DateValue, options?: DateFormatterOptions) => Intl.DateTimeFormatPart[];
    getMonths: () => { label: string; value: number }[];
};

/**
 * Creates a wrapper around the `DateFormatter`, which is
 * an improved version of the {@link Intl.DateTimeFormat} API,
 * that is used internally by the various date builders to
 * easily format dates in a consistent way.
 *
 * @see [DateFormatter](https://react-spectrum.adobe.com/internationalized/date/DateFormatter.html)
 */
export function createFormatter(initialLocale: string): Formatter {
    let locale = initialLocale;

    function setLocale(newLocale: string) {
        locale = newLocale;
    }

    function getLocale() {
        return locale;
    }

    function custom(date: Date, options: Intl.DateTimeFormatOptions) {
        return new DateFormatter(locale, options).format(date);
    }

    function selectedDate(date: DateValue, includeTime = true) {
        if (hasTime(date) && includeTime) {
            return custom(toDate(date), {
                dateStyle: 'long',
                timeStyle: 'long'
            });
        } else {
            return custom(toDate(date), {
                dateStyle: 'long'
            });
        }
    }

    function fullMonthAndYear(date: Date) {
        return new DateFormatter(locale, { month: 'long', year: 'numeric' }).format(date);
    }

    function fullMonth(date: Date) {
        return new DateFormatter(locale, { month: 'long' }).format(date);
    }

    function fullYear(date: Date) {
        return new DateFormatter(locale, { year: 'numeric' }).format(date);
    }

    function toParts(date: DateValue, options?: Intl.DateTimeFormatOptions) {
        if (isZonedDateTime(date)) {
            return new DateFormatter(locale, {
                ...options,
                timeZone: date.timeZone
            }).formatToParts(toDate(date));
        } else {
            return new DateFormatter(locale, options).formatToParts(toDate(date));
        }
    }

    function dayOfWeek(date: Date, length: Intl.DateTimeFormatOptions['weekday'] = 'narrow') {
        return new DateFormatter(locale, { weekday: length }).format(date);
    }

    function dayPeriod(date: Date, hourCycle: HourCycle | undefined = undefined) {
        const parts = new DateFormatter(locale, {
            hour: 'numeric',
            minute: 'numeric',
            hourCycle: hourCycle === 24 ? 'h23' : undefined
        }).formatToParts(date);
        const value = parts.find((p) => p.type === 'dayPeriod')?.value;
        if (value === 'PM') {
            return 'PM';
        }
        return 'AM';
    }

    function part(dateObj: DateValue, type: Intl.DateTimeFormatPartTypes, options: Intl.DateTimeFormatOptions = {}) {
        const opts = { ...defaultPartOptions, ...options };
        const parts = toParts(dateObj, opts);
        const part = parts.find((p) => p.type === type);
        return part ? part.value : '';
    }

    function getMonths() {
        const defaultDate = today(getLocalTimeZone());
        const months = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
        return months.map((item) => ({ label: fullMonth(toDate(defaultDate.set({ month: item }))), value: item }));
    }

    return {
        setLocale,
        getLocale,
        fullMonth,
        fullYear,
        fullMonthAndYear,
        toParts,
        custom,
        part,
        dayPeriod,
        selectedDate,
        dayOfWeek,
        getMonths
    };
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/date-time/index.ts
```typescript
export * from './calendar';
export * from './comparators';
export * from './formatter';
export * from './placeholders';
export * from './types';
export * from './utils';

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/date-time/placeholders.ts
```typescript
/*
 * Implementation ported from from from https://github.com/melt-ui/melt-ui/blob/develop/src/lib/internal/helpers/date/placeholders.ts
 */

// prettier-ignore
const supportedLocales = [
    'ach','af','am','an','ar','ast','az','be','bg','bn','br','bs',
    'ca','cak','ckb','cs','cy','da','de','dsb','el','en','eo','es',
    'et','eu','fa','ff','fi','fr','fy','ga','gd','gl','he','hr',
    'hsb','hu','ia','id','it','ja','ka','kk','kn','ko','lb','lo',
    'lt','lv','meh','ml','ms','nl','nn','no','oc','pl','pt','rm',
    'ro','ru','sc','scn','sk','sl','sr','sv','szl','tg','th','tr',
    'uk','zh-CN','zh-TW',
] as const;

const placeholderFields = ['year', 'month', 'day'] as const;

type SupportedLocale = (typeof supportedLocales)[number];
type PlaceholderField = (typeof placeholderFields)[number];
export type PlaceholderMap = Record<SupportedLocale, Record<PlaceholderField, string>>;

const placeholders: PlaceholderMap = {
    ach: { year: 'mwaka', month: 'dwe', day: 'nino' },
    af: { year: 'jjjj', month: 'mm', day: 'dd' },
    am: { year: 'á‹“á‹“á‹“á‹“', month: 'áˆšáˆœ', day: 'á‰€á‰€' },
    an: { year: 'aaaa', month: 'mm', day: 'dd' },
    ar: { year: 'Ø³Ù†Ø©', month: 'Ø´Ù‡Ø±', day: 'ÙŠÙˆÙ…' },
    ast: { year: 'aaaa', month: 'mm', day: 'dd' },
    az: { year: 'iiii', month: 'aa', day: 'gg' },
    be: { year: 'Ð³Ð³Ð³Ð³', month: 'Ð¼Ð¼', day: 'Ð´Ð´' },
    bg: { year: 'Ð³Ð³Ð³Ð³', month: 'Ð¼Ð¼', day: 'Ð´Ð´' },
    bn: { year: 'yyyy', month: 'à¦®à¦¿à¦®à¦¿', day: 'dd' },
    br: { year: 'bbbb', month: 'mm', day: 'dd' },
    bs: { year: 'gggg', month: 'mm', day: 'dd' },
    ca: { year: 'aaaa', month: 'mm', day: 'dd' },
    cak: { year: 'jjjj', month: 'ii', day: "q'q'" },
    ckb: { year: 'Ø³Ø§Úµ', month: 'Ù…Ø§Ù†Ú¯', day: 'Ú•Û†Ú˜' },
    cs: { year: 'rrrr', month: 'mm', day: 'dd' },
    cy: { year: 'bbbb', month: 'mm', day: 'dd' },
    da: { year: 'Ã¥Ã¥Ã¥Ã¥', month: 'mm', day: 'dd' },
    de: { year: 'jjjj', month: 'mm', day: 'tt' },
    dsb: { year: 'llll', month: 'mm', day: 'ÅºÅº' },
    el: { year: 'ÎµÎµÎµÎµ', month: 'Î¼Î¼', day: 'Î·Î·' },
    en: { year: 'yyyy', month: 'mm', day: 'dd' },
    eo: { year: 'jjjj', month: 'mm', day: 'tt' },
    es: { year: 'aaaa', month: 'mm', day: 'dd' },
    et: { year: 'aaaa', month: 'kk', day: 'pp' },
    eu: { year: 'uuuu', month: 'hh', day: 'ee' },
    fa: { year: 'Ø³Ø§Ù„', month: 'Ù…Ø§Ù‡', day: 'Ø±ÙˆØ²' },
    ff: { year: 'hhhh', month: 'll', day: 'Ã±Ã±' },
    fi: { year: 'vvvv', month: 'kk', day: 'pp' },
    fr: { year: 'aaaa', month: 'mm', day: 'jj' },
    fy: { year: 'jjjj', month: 'mm', day: 'dd' },
    ga: { year: 'bbbb', month: 'mm', day: 'll' },
    gd: { year: 'bbbb', month: 'mm', day: 'll' },
    gl: { year: 'aaaa', month: 'mm', day: 'dd' },
    he: { year: '×©× ×”', month: '×—×•×“×©', day: '×™×•×' },
    hr: { year: 'gggg', month: 'mm', day: 'dd' },
    hsb: { year: 'llll', month: 'mm', day: 'dd' },
    hu: { year: 'Ã©Ã©Ã©Ã©', month: 'hh', day: 'nn' },
    ia: { year: 'aaaa', month: 'mm', day: 'dd' },
    id: { year: 'tttt', month: 'bb', day: 'hh' },
    it: { year: 'aaaa', month: 'mm', day: 'gg' },
    ja: { year: ' å¹´ ', month: 'æœˆ', day: 'æ—¥' },
    ka: { year: 'áƒ¬áƒ¬áƒ¬áƒ¬', month: 'áƒ—áƒ—', day: 'áƒ áƒ ' },
    kk: { year: 'Ð¶Ð¶Ð¶Ð¶', month: 'Ð°Ð°', day: 'ÐºÐº' },
    kn: { year: 'à²µà²µà²µà²µ', month: 'à²®à²¿à²®à³€', day: 'à²¦à²¿à²¦à²¿' },
    ko: { year: 'ì—°ë„', month: 'ì›”', day: 'ì¼' },
    lb: { year: 'jjjj', month: 'mm', day: 'dd' },
    lo: { year: 'àº›àº›àº›àº›', month: 'àº”àº”', day: 'àº§àº§' },
    lt: { year: 'mmmm', month: 'mm', day: 'dd' },
    lv: { year: 'gggg', month: 'mm', day: 'dd' },
    meh: { year: 'aaaa', month: 'mm', day: 'dd' },
    ml: { year: 'à´µàµ¼à´·à´‚', month: 'à´®à´¾à´¸à´‚', day: 'à´¤àµ€à´¯à´¤à´¿' },
    ms: { year: 'tttt', month: 'mm', day: 'hh' },
    nl: { year: 'jjjj', month: 'mm', day: 'dd' },
    nn: { year: 'Ã¥Ã¥Ã¥Ã¥', month: 'mm', day: 'dd' },
    no: { year: 'Ã¥Ã¥Ã¥Ã¥', month: 'mm', day: 'dd' },
    oc: { year: 'aaaa', month: 'mm', day: 'jj' },
    pl: { year: 'rrrr', month: 'mm', day: 'dd' },
    pt: { year: 'aaaa', month: 'mm', day: 'dd' },
    rm: { year: 'oooo', month: 'mm', day: 'dd' },
    ro: { year: 'aaaa', month: 'll', day: 'zz' },
    ru: { year: 'Ð³Ð³Ð³Ð³', month: 'Ð¼Ð¼', day: 'Ð´Ð´' },
    sc: { year: 'aaaa', month: 'mm', day: 'dd' },
    scn: { year: 'aaaa', month: 'mm', day: 'jj' },
    sk: { year: 'rrrr', month: 'mm', day: 'dd' },
    sl: { year: 'llll', month: 'mm', day: 'dd' },
    sr: { year: 'Ð³Ð³Ð³Ð³', month: 'Ð¼Ð¼', day: 'Ð´Ð´' },
    sv: { year: 'Ã¥Ã¥Ã¥Ã¥', month: 'mm', day: 'dd' },
    szl: { year: 'rrrr', month: 'mm', day: 'dd' },
    tg: { year: 'ÑÑÑÑ', month: 'Ð¼Ð¼', day: 'Ñ€Ñ€' },
    th: { year: 'à¸›à¸›à¸›à¸›', month: 'à¸”à¸”', day: 'à¸§à¸§' },
    tr: { year: 'yyyy', month: 'aa', day: 'gg' },
    uk: { year: 'Ñ€Ñ€Ñ€Ñ€', month: 'Ð¼Ð¼', day: 'Ð´Ð´' },
    'zh-CN': { year: 'å¹´', month: 'æœˆ', day: 'æ—¥' },
    'zh-TW': { year: 'å¹´', month: 'æœˆ', day: 'æ—¥' }
};

function getPlaceholderObj(locale: SupportedLocale | (string & {})) {
    if (!isSupportedLocale(locale)) {
        const localeLanguage = getLocaleLanguage(locale);
        if (!isSupportedLocale(localeLanguage)) {
            return placeholders.en;
        } else {
            return placeholders[localeLanguage];
        }
    } else {
        return placeholders[locale];
    }
}

type Field = 'era' | 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' | 'dayPeriod';

export function getPlaceholder(field: Field, value: string, locale: SupportedLocale | (string & {})) {
    if (isPlaceholderField(field)) return getPlaceholderObj(locale)[field];
    if (isDefaultField(field)) return value;
    if (isTimeField(field)) return 'â€“â€“';
    return '';
}

function isSupportedLocale(locale: string): locale is SupportedLocale {
    return supportedLocales.includes(locale as SupportedLocale);
}

function isPlaceholderField(field: unknown): field is PlaceholderField {
    return placeholderFields.includes(field as PlaceholderField);
}

function isTimeField(field: unknown): field is 'hour' | 'minute' | 'second' {
    return field === 'hour' || field === 'minute' || field === 'second';
}

function isDefaultField(field: unknown): field is 'era' | 'dayPeriod' {
    return field === 'era' || field === 'dayPeriod';
}

function getLocaleLanguage(locale: string) {
    if (Intl.Locale) {
        return new Intl.Locale(locale).language;
    }
    return locale.split('-')[0]!;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/date-time/types.ts
```typescript
/*
 * Implementation ported from https://github.com/melt-ui/melt-ui/blob/develop/src/lib/internal/helpers/date/types.ts
 */

import type { DateValue } from '@internationalized/date';

export type DateMatcher = (date: DateValue) => boolean;

export type HourCycle = 12 | 24;

export type Month<T> = {
    /**
     * A `DateValue` used to represent the month. Since days
     * from the previous and next months may be included in the
     * calendar grid, we need a source of truth for the value
     * the grid is representing.
     */
    value: DateValue;

    /**
     * An array of (rows) arrays representing the weeks in the calendar.
     * Each sub-array represents a week, and contains the dates for each
     * day in that week. This structure is useful for rendering the calendar
     * grid using a table, where each row represents a week and each cell
     * represents a day.
     */
    weeks: T[][];

    /**
     * An array of (cells) all the dates in the current month, including dates from
     * the previous and next months that are used to fill out the calendar grid.
     * This array is useful for rendering the calendar grid in a customizable way,
     * as it provides all the dates that should be displayed in the grid in a flat
     * array.
     */
    dates: T[];
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/date-time/utils.ts
```typescript
export function handleCalendarInitialFocus(calendar: HTMLElement) {
    const selectedDay = calendar.querySelector<HTMLElement>('[data-selected]');
    if (selectedDay) return selectedDay.focus();

    const today = calendar.querySelector<HTMLElement>('[data-today]');
    if (today) return today.focus();

    const firstDay = calendar.querySelector<HTMLElement>('[data-rdx-calendar-day]');
    if (firstDay) return firstDay.focus();
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/accessor/provide-value-accessor.ts
````typescript
import { forwardRef, Provider, Type } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';

/**
 * Include in the providers section of a component which utilizes ControlValueAccessor to redundant code.
 *
 * ```ts
 * @Directive({
 *   providers: [provideValueAccessor(ExampleDirective)]
 *}
 * export class ExampleDirective{}
 * ```
 */
export function provideValueAccessor<T>(type: Type<T>): Provider {
    return {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => type),
        multi: true
    };
}

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/positioning/constants.ts
```typescript
import { RdxPositionAlign, RdxPositioningDefaults, RdxPositions, RdxPositionSide } from './types';

export const RDX_POSITIONS: RdxPositions = {
    [RdxPositionSide.Top]: {
        [RdxPositionAlign.Center]: {
            originX: 'center',
            originY: 'top',
            overlayX: 'center',
            overlayY: 'bottom'
        },
        [RdxPositionAlign.Start]: {
            originX: 'start',
            originY: 'top',
            overlayX: 'start',
            overlayY: 'bottom'
        },
        [RdxPositionAlign.End]: {
            originX: 'end',
            originY: 'top',
            overlayX: 'end',
            overlayY: 'bottom'
        }
    },
    [RdxPositionSide.Right]: {
        [RdxPositionAlign.Center]: {
            originX: 'end',
            originY: 'center',
            overlayX: 'start',
            overlayY: 'center'
        },
        [RdxPositionAlign.Start]: {
            originX: 'end',
            originY: 'top',
            overlayX: 'start',
            overlayY: 'top'
        },
        [RdxPositionAlign.End]: {
            originX: 'end',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'bottom'
        }
    },
    [RdxPositionSide.Bottom]: {
        [RdxPositionAlign.Center]: {
            originX: 'center',
            originY: 'bottom',
            overlayX: 'center',
            overlayY: 'top'
        },
        [RdxPositionAlign.Start]: {
            originX: 'start',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'top'
        },
        [RdxPositionAlign.End]: {
            originX: 'end',
            originY: 'bottom',
            overlayX: 'end',
            overlayY: 'top'
        }
    },
    [RdxPositionSide.Left]: {
        [RdxPositionAlign.Center]: {
            originX: 'start',
            originY: 'center',
            overlayX: 'end',
            overlayY: 'center'
        },
        [RdxPositionAlign.Start]: {
            originX: 'start',
            originY: 'top',
            overlayX: 'end',
            overlayY: 'top'
        },
        [RdxPositionAlign.End]: {
            originX: 'start',
            originY: 'bottom',
            overlayX: 'end',
            overlayY: 'bottom'
        }
    }
} as const;

export const RDX_POSITIONING_DEFAULTS: RdxPositioningDefaults = {
    offsets: {
        side: 4,
        align: 0
    },
    arrow: {
        width: 8,
        height: 6
    }
} as const;

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/positioning/types.ts
```typescript
import { ConnectionPositionPair } from '@angular/cdk/overlay';

export enum RdxPositionSide {
    Top = 'top',
    Right = 'right',
    Bottom = 'bottom',
    Left = 'left'
}

export enum RdxPositionAlign {
    Start = 'start',
    Center = 'center',
    End = 'end'
}

export type RdxPositionSideAndAlign = { side: RdxPositionSide; align: RdxPositionAlign };
export type RdxPositionSideAndAlignOffsets = { sideOffset: number; alignOffset: number };

export type RdxPositions = Readonly<{
    [key in RdxPositionSide]: Readonly<{
        [key in RdxPositionAlign]: Readonly<ConnectionPositionPair>;
    }>;
}>;

export type RdxPositioningDefaults = Readonly<{
    offsets: Readonly<{
        side: number;
        align: number;
    }>;
    arrow: Readonly<{
        width: number;
        height: number;
    }>;
}>;

export type RdxAllPossibleConnectedPositions = ReadonlyMap<
    `${RdxPositionSide}|${RdxPositionAlign}`,
    ConnectionPositionPair
>;
export type RdxArrowPositionParams = {
    top: string;
    left: string;
    transform: string;
    transformOrigin: string;
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/core/src/positioning/utils.ts
```typescript
import { ConnectedPosition, ConnectionPositionPair } from '@angular/cdk/overlay';
import { RDX_POSITIONS } from './constants';
import {
    RdxAllPossibleConnectedPositions,
    RdxArrowPositionParams,
    RdxPositionAlign,
    RdxPositionSide,
    RdxPositionSideAndAlign,
    RdxPositionSideAndAlignOffsets
} from './types';

export function getContentPosition(
    sideAndAlignWithOffsets: RdxPositionSideAndAlign & RdxPositionSideAndAlignOffsets
): ConnectedPosition {
    const { side, align, sideOffset, alignOffset } = sideAndAlignWithOffsets;
    const position: ConnectedPosition = {
        ...(RDX_POSITIONS[side]?.[align] ?? RDX_POSITIONS[RdxPositionSide.Top][RdxPositionAlign.Center])
    };
    if (sideOffset || alignOffset) {
        if ([RdxPositionSide.Top, RdxPositionSide.Bottom].includes(side)) {
            if (sideOffset) {
                position.offsetY = side === RdxPositionSide.Top ? -sideOffset : sideOffset;
            }
            if (alignOffset) {
                position.offsetX = alignOffset;
            }
        } else {
            if (sideOffset) {
                position.offsetX = side === RdxPositionSide.Left ? -sideOffset : sideOffset;
            }
            if (alignOffset) {
                position.offsetY = alignOffset;
            }
        }
    }
    return position;
}

let allPossibleConnectedPositions: RdxAllPossibleConnectedPositions;
export function getAllPossibleConnectedPositions() {
    if (!allPossibleConnectedPositions) {
        allPossibleConnectedPositions = new Map();
    }
    if (allPossibleConnectedPositions.size < 1) {
        for (const [side, aligns] of Object.entries(RDX_POSITIONS)) {
            for (const [align, position] of Object.entries(aligns)) {
                (allPossibleConnectedPositions as Map<any, any>).set(`${side}|${align}`, position);
            }
        }
    }
    return allPossibleConnectedPositions;
}

export function getSideAndAlignFromAllPossibleConnectedPositions(
    position: ConnectionPositionPair
): RdxPositionSideAndAlign {
    const allPossibleConnectedPositions = getAllPossibleConnectedPositions();
    let sideAndAlign: RdxPositionSideAndAlign | undefined;
    allPossibleConnectedPositions.forEach((value, key) => {
        if (
            position.originX === value.originX &&
            position.originY === value.originY &&
            position.overlayX === value.overlayX &&
            position.overlayY === value.overlayY
        ) {
            const sideAndAlignArray = key.split('|');
            sideAndAlign = {
                side: sideAndAlignArray[0] as RdxPositionSide,
                align: sideAndAlignArray[1] as RdxPositionAlign
            };
        }
    });
    if (!sideAndAlign) {
        throw Error(
            `[Rdx positioning] cannot infer both side and align from the given position (${JSON.stringify(position)})`
        );
    }
    return sideAndAlign;
}

export function getArrowPositionParams(
    sideAndAlign: RdxPositionSideAndAlign,
    arrowWidthAndHeight: { width: number; height: number },
    triggerWidthAndHeight: { width: number; height: number }
): RdxArrowPositionParams {
    const posParams: RdxArrowPositionParams = {
        top: '',
        left: '',
        transform: '',
        transformOrigin: 'center center 0px'
    };

    if ([RdxPositionSide.Top, RdxPositionSide.Bottom].includes(sideAndAlign.side)) {
        if (sideAndAlign.side === RdxPositionSide.Top) {
            posParams.top = '100%';
        } else {
            posParams.top = `-${arrowWidthAndHeight.height}px`;
            posParams.transform = `rotate(180deg)`;
        }

        if (sideAndAlign.align === RdxPositionAlign.Start) {
            posParams.left = `${(triggerWidthAndHeight.width - arrowWidthAndHeight.width) / 2}px`;
        } else if (sideAndAlign.align === RdxPositionAlign.Center) {
            posParams.left = `calc(50% - ${arrowWidthAndHeight.width / 2}px)`;
        } else if (sideAndAlign.align === RdxPositionAlign.End) {
            posParams.left = `calc(100% - ${(triggerWidthAndHeight.width + arrowWidthAndHeight.width) / 2}px)`;
        }
    } else if ([RdxPositionSide.Left, RdxPositionSide.Right].includes(sideAndAlign.side)) {
        if (sideAndAlign.side === RdxPositionSide.Left) {
            posParams.left = `calc(100% - ${arrowWidthAndHeight.width}px)`;
            posParams.transform = `rotate(-90deg)`;
            posParams.transformOrigin = 'top right 0px';
        } else {
            posParams.left = `0`;
            posParams.transform = `rotate(90deg)`;
            posParams.transformOrigin = 'top left 0px';
        }

        if (sideAndAlign.align === RdxPositionAlign.Start) {
            posParams.top = `${(triggerWidthAndHeight.height - arrowWidthAndHeight.width) / 2}px`;
        } else if (sideAndAlign.align === RdxPositionAlign.Center) {
            posParams.top = `calc(50% - ${arrowWidthAndHeight.width / 2}px)`;
        } else if (sideAndAlign.align === RdxPositionAlign.End) {
            posParams.top = `calc(100% - ${(triggerWidthAndHeight.height + arrowWidthAndHeight.width) / 2}px)`;
        }
    }

    return posParams;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/README.md
```
# @radix-ng/primitives/navigation-menu

A responsive navigation component that automatically collapses navigation items into a menu when space is limited. Follows the WAI-ARIA Menu Button Pattern for accessibility.

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/index.ts
```typescript
import { NgModule } from '@angular/core';
import {
    RdxNavigationMenuAriaOwnsComponent,
    RdxNavigationMenuFocusProxyComponent
} from './src/navigation-menu-a11y.component';
import { RdxNavigationMenuContentDirective } from './src/navigation-menu-content.directive';
import { RdxNavigationMenuIndicatorDirective } from './src/navigation-menu-indicator.directive';
import { RdxNavigationMenuItemDirective } from './src/navigation-menu-item.directive';
import { RdxNavigationMenuLinkDirective } from './src/navigation-menu-link.directive';
import { RdxNavigationMenuListDirective } from './src/navigation-menu-list.directive';
import { RdxNavigationMenuSubDirective } from './src/navigation-menu-sub.directive';
import { RdxNavigationMenuTriggerDirective } from './src/navigation-menu-trigger.directive';
import { RdxNavigationMenuViewportDirective } from './src/navigation-menu-viewport.directive';
import { RdxNavigationMenuDirective } from './src/navigation-menu.directive';

export * from './src/navigation-menu-a11y.component';
export * from './src/navigation-menu-content.directive';
export * from './src/navigation-menu-indicator.directive';
export * from './src/navigation-menu-item.directive';
export * from './src/navigation-menu-link.directive';
export * from './src/navigation-menu-list.directive';
export * from './src/navigation-menu-sub.directive';
export * from './src/navigation-menu-trigger.directive';
export * from './src/navigation-menu-viewport.directive';
export * from './src/navigation-menu.directive';
export * from './src/navigation-menu.token';
export * from './src/navigation-menu.types';

const _imports = [
    RdxNavigationMenuDirective,
    RdxNavigationMenuSubDirective,
    RdxNavigationMenuListDirective,
    RdxNavigationMenuItemDirective,
    RdxNavigationMenuTriggerDirective,
    RdxNavigationMenuLinkDirective,
    RdxNavigationMenuIndicatorDirective,
    RdxNavigationMenuContentDirective,
    RdxNavigationMenuViewportDirective,
    RdxNavigationMenuFocusProxyComponent,
    RdxNavigationMenuAriaOwnsComponent
];

@NgModule({
    imports: [..._imports],
    exports: [..._imports]
})
export class RdxNavigationMenuModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/stories/navigation-menu.docs.mdx
````
import {ArgTypes, Canvas, Markdown, Meta, Source} from '@storybook/blocks';
import * as NavigationMenuStories from "./navigation-menu.stories";

<Meta title="Primitives/Navigation Menu" />

# Navigation Menu

A navigation component that provides structured menu navigation with support for submenus and content display.

## Overview

The Navigation Menu component provides:

- âœ… Support for different item types including links, buttons, and custom components
- âœ… Submenu navigation capabilities
- âœ… Keyboard navigation support
- âœ… LTR and RTL layout compatibility
- âœ… Focus management for accessibility compliance

## Examples
### Default

<Canvas sourceState="hidden" of={NavigationMenuStories.Default} />

## Component Structure

```html
<nav rdxNavigationMenu>
  <ul rdxNavigationMenuList>
    <li rdxNavigationMenuItem value="item1">
      <button rdxNavigationMenuTrigger>Item 1</button>

      <!-- Content as structural directive -->
      <div *rdxNavigationMenuContent class="NavigationMenuContent">
        <!-- Content for Item 1 -->
      </div>
    </li>

    <li rdxNavigationMenuItem value="item2">
      <a rdxNavigationMenuLink href="#">Item 2</a>
    </li>

    <!-- Indicator for highlighting active item -->
    <div rdxNavigationMenuIndicator></div>
  </ul>

  <!-- Viewport for content display -->
  <div rdxNavigationMenuViewport></div>
</nav>
```

## API Reference

### Root
`rdxNavigationMenu`

The root directive that contains all parts of a navigation menu.

| Property | Type | Default | Description |
| -------- | ---- | ------- | ----------- |
| orientation | 'horizontal' \| 'vertical' | 'horizontal' | Determines the orientation of the navigation menu |
| dir | 'ltr' \| 'rtl' | 'ltr' | Sets the reading direction of the navigation menu |
| delayDuration | number | 200 | Duration (ms) from mouse enter until content opens |
| skipDelayDuration | number | 300 | Duration (ms) after leaving a submenu before it closes |
| loop | boolean | false | When true, keyboard navigation loops from last item to first and vice versa |

### List
`rdxNavigationMenuList`

Container for navigation menu items. Must be rendered inside `rdxNavigationMenu` or `rdxNavigationMenuSub`. Has the `menubar` ARIA role.

### Item
`rdxNavigationMenuItem`

A navigation item container that can hold a trigger and content.

### Trigger
`rdxNavigationMenuTrigger`

Button that opens submenu content. Must be rendered inside `rdxNavigationMenuItem`.

| Data attribute | Value |
|----------------|-------|
| [data-state] | 'open' \| 'closed' |
| [data-disabled] | Present when disabled |

### Link
`rdxNavigationMenuLink`

A navigation link. Must be rendered inside `rdxNavigationMenuItem`.

| Property | Type | Default | Description |
| -------- | ---- | ------- | ----------- |
| active | boolean | false | Indicates if the link is active |

| Data attribute | Value |
|----------------|-------|
| [data-active] | Present when active |

### Content
`*rdxNavigationMenuContent`

Content displayed when a trigger is activated. Must be rendered inside `rdxNavigationMenuItem`. Used as a structural directive with asterisk syntax. Content renders within the `rdxNavigationMenuViewport`.

| Property | Type | Default | Description |
| -------- | ---- | ------- | ----------- |
| forceMount | boolean | false | Keeps content in the DOM even when closed |

Data attributes can be manually controlled:

```html
<div *rdxNavigationMenuContent
     class="NavigationMenuContent"
     [attr.data-state]="'open'"
     [attr.data-motion]="'from-start'">
  <!-- Content -->
</div>
```

### Indicator
`rdxNavigationMenuIndicator`

Visual indicator for active menu items. Must be rendered inside `rdxNavigationMenuList`.

| Property | Type | Default | Description |
| -------- | ---- | ------- | ----------- |
| forceMount | boolean | false | Keeps indicator in the DOM even when hidden |

| Data attribute | Value |
|----------------|-------|
| [data-state] | 'visible' \| 'hidden' |

### Viewport
`rdxNavigationMenuViewport`

Component that displays active content. Must be rendered inside `rdxNavigationMenu`.

| Property | Type | Default | Description |
| -------- | ---- | ------- | ----------- |
| forceMount | boolean | false | Keeps viewport in the DOM even when closed |

| Data attribute | Value |
|----------------|-------|
| [data-state] | 'open' \| 'closed' |

### Sub
`rdxNavigationMenuSub`

Container for nested submenus. Contains its own `rdxNavigationMenuList` and items. Must be rendered inside `rdxNavigationMenuItem`.

| Property | Type | Default | Description |
| -------- | ---- | ------- | ----------- |
| orientation | 'horizontal' \| 'vertical' | 'horizontal' | Orientation of submenu list |
| defaultValue | string | '' | Value of item that should be open by default |

## Accessibility

This component implements the [WAI-ARIA Menu Button Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/menubutton/):

- Arrow key navigation between items
- Enter/Space to open menus
- Escape to close open menus
- Tab navigation to move focus between focusable elements
- Automatic ARIA attribute management

## Styling Reference

The component provides data attributes for styling:

```css
/* Basic styling example */
.NavigationMenuRoot {
  position: relative;
}

.NavigationMenuList {
  display: flex;
  list-style: none;
}

.NavigationMenuTrigger,
.NavigationMenuLink {
  padding: 8px 12px;
  color: var(--primary);
  text-decoration: none;
}

.NavigationMenuTrigger[data-state="open"] {
  background-color: var(--primary-light);
}

.NavigationMenuContent {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  animation-duration: 250ms;
  animation-timing-function: ease;
}

.NavigationMenuIndicator {
  transition: transform 250ms ease;
}

.NavigationMenuViewport {
  position: relative;
  transform-origin: top center;
}
```

## Animation

Content transitions can be animated using data attributes:

```css
@keyframes enterFromRight {
  from {
    opacity: 0;
    transform: translateX(200px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes exitToRight {
  from {
    opacity: 1;
    transform: translateX(0);
  }
  to {
    opacity: 0;
    transform: translateX(200px);
  }
}

/* Apply animations based on motion direction */
.NavigationMenuContent[data-motion="from-end"] {
  animation-name: enterFromRight;
}

.NavigationMenuContent[data-motion="to-end"] {
  animation-name: exitToRight;
}
```

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/stories/navigation-menu.stories.ts
```typescript
import { CommonModule } from '@angular/common';
import { provideAnimations } from '@angular/platform-browser/animations';
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { RdxNavigationMenuModule } from '../index';

const html = String.raw;

export default {
    title: 'Primitives/Navigation Menu',
    decorators: [
        moduleMetadata({
            imports: [
                CommonModule,
                RdxNavigationMenuModule
            ],
            providers: [provideAnimations()]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div class="story-wrapper">${story}</div>

                <style>
                    .story-wrapper {
                        font-family:
                            -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,
                            'Open Sans', 'Helvetica Neue', sans-serif;
                        padding: 50px 0;
                        min-height: 400px;
                        display: flex;
                        position: relative;
                        justify-content: center;
                        align-items: flex-start;
                        box-sizing: border-box;
                    }

                    /* reset */
                    *,
                    :after,
                    :before {
                        box-sizing: border-box;
                    }
                    button,
                    p {
                        all: unset;
                    }

                    .NavigationMenuRoot {
                        position: relative;
                        display: flex;
                        justify-content: center;
                        width: 100vw;
                        z-index: 1;
                    }

                    .NavigationMenuList {
                        display: flex;
                        justify-content: center;
                        background-color: white;
                        padding: 4px;
                        border-radius: 6px;
                        list-style: none;
                        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
                        margin: 0;
                    }

                    .NavigationMenuTrigger,
                    .NavigationMenuLink {
                        padding: 8px 12px;
                        outline: none;
                        user-select: none;
                        font-weight: 500;
                        line-height: 1;
                        border-radius: 4px;
                        font-size: 15px;
                        color: #6952a7;
                    }
                    .NavigationMenuTrigger:focus,
                    .NavigationMenuLink:focus {
                        box-shadow: 0 0 0 2px #a28fd0;
                    }
                    .NavigationMenuTrigger:hover,
                    .NavigationMenuLink:hover {
                        background-color: #f1eefc;
                    }

                    .NavigationMenuTrigger {
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        gap: 2px;
                    }

                    .NavigationMenuLink {
                        display: block;
                        text-decoration: none;
                        font-size: 15px;
                        line-height: 1;
                    }

                    .NavigationMenuContentWrapper {
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        animation-duration: 250ms;
                        animation-timing-function: ease;
                        transition:
                            opacity 250ms ease,
                            transform 250ms ease;
                    }
                    .NavigationMenuContentWrapper[data-state='closed'] {
                        opacity: 0;
                    }
                    .NavigationMenuContentWrapper[data-state='open'] {
                        opacity: 1;
                    }
                    .NavigationMenuContentWrapper[data-motion='from-start'] {
                        animation-name: enterFromLeft;
                    }
                    .NavigationMenuContentWrapper[data-motion='from-end'] {
                        animation-name: enterFromRight;
                    }
                    .NavigationMenuContentWrapper[data-motion='to-start'] {
                        animation-name: exitToLeft;
                    }
                    .NavigationMenuContentWrapper[data-motion='to-end'] {
                        animation-name: exitToRight;
                    }

                    .NavigationMenuContent {
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        animation-duration: 250ms;
                        animation-timing-function: ease;
                    }

                    @media only screen and (min-width: 600px) {
                        .NavigationMenuContent {
                            width: auto;
                        }
                    }

                    .NavigationMenuIndicator {
                        display: flex;
                        align-items: flex-end;
                        justify-content: center;
                        height: 10px;
                        top: 100%;
                        overflow: hidden;
                        z-index: 1;
                        transition:
                            width,
                            transform 250ms ease;
                    }
                    .NavigationMenuIndicator[data-state='visible'] {
                        animation: fadeIn 200ms ease;
                    }
                    .NavigationMenuIndicator[data-state='hidden'] {
                        animation: fadeOut 200ms ease;
                    }

                    .NavigationMenuViewport {
                        position: relative;
                        transform-origin: top center;
                        margin-top: 10px;
                        width: 100%;
                        background-color: white;
                        border-radius: 6px;
                        overflow: hidden;
                        box-shadow:
                            0px 10px 38px -10px rgba(22, 23, 24, 0.35),
                            0px 10px 20px -15px rgba(22, 23, 24, 0.2);
                        height: var(--radix-navigation-menu-viewport-height);
                        transition:
                            width 300ms ease,
                            height 300ms ease,
                            opacity 200ms ease-out;
                        opacity: 1;
                    }
                    .NavigationMenuViewport[data-state='open'] {
                        opacity: 1;
                        animation: scaleIn 200ms ease;
                    }
                    .NavigationMenuViewport[data-state='closed'] {
                        opacity: 0;
                        animation: scaleOut 200ms ease;
                    }
                    @media only screen and (min-width: 600px) {
                        .NavigationMenuViewport {
                            width: var(--radix-navigation-menu-viewport-width);
                        }
                    }

                    .List {
                        display: grid;
                        padding: 22px;
                        margin: 0;
                        column-gap: 10px;
                        list-style: none;
                    }
                    @media only screen and (min-width: 600px) {
                        .List.one {
                            width: 500px;
                            grid-template-columns: 0.75fr 1fr;
                        }
                        .List.two {
                            width: 600px;
                            grid-auto-flow: column;
                            grid-template-rows: repeat(3, 1fr);
                        }
                    }

                    .ListItemLink {
                        display: block;
                        outline: none;
                        text-decoration: none;
                        user-select: none;
                        padding: 12px;
                        border-radius: 6px;
                        font-size: 15px;
                        line-height: 1;
                    }
                    .ListItemLink:focus {
                        box-shadow: 0 0 0 2px #9574db;
                    }
                    .ListItemLink:hover {
                        background-color: #f5f3ff;
                    }

                    .ListItemHeading {
                        font-weight: 500;
                        line-height: 1.2;
                        margin-bottom: 5px;
                        color: #1e085a;
                    }

                    .ListItemText {
                        color: #696096;
                        line-height: 1.4;
                        font-weight: initial;
                    }

                    .Callout {
                        display: flex;
                        justify-content: flex-end;
                        flex-direction: column;
                        width: 100%;
                        height: 100%;
                        background: linear-gradient(135deg, #8257e6 0%, #4120a9 100%);
                        border-radius: 6px;
                        padding: 25px;
                        text-decoration: none;
                        outline: none;
                        user-select: none;
                    }
                    .Callout:focus {
                        box-shadow: 0 0 0 2px #9574db;
                    }

                    .CalloutHeading {
                        color: white;
                        font-size: 18px;
                        font-weight: 500;
                        line-height: 1.2;
                        margin-top: 16px;
                        margin-bottom: 7px;
                    }

                    .CalloutText {
                        color: #e4e2e4;
                        font-size: 14px;
                        line-height: 1.3;
                    }

                    .ViewportPosition {
                        position: absolute;
                        display: flex;
                        justify-content: center;
                        width: 100%;
                        top: 100%;
                        left: 0;
                        perspective: 2000px;
                    }

                    .CaretDown {
                        position: relative;
                        color: #7952c7;
                        top: 1px;
                        transition: transform 250ms ease;
                    }

                    [data-state='open'] > .CaretDown {
                        transform: rotate(-180deg);
                    }

                    .Arrow {
                        position: relative;
                        top: 70%;
                        background-color: white;
                        width: 10px;
                        height: 10px;
                        transform: rotate(45deg);
                        border-top-left-radius: 2px;
                    }

                    @keyframes enterFromRight {
                        from {
                            opacity: 0;
                            transform: translateX(200px);
                        }
                        to {
                            opacity: 1;
                            transform: translateX(0);
                        }
                    }

                    @keyframes enterFromLeft {
                        from {
                            opacity: 0;
                            transform: translateX(-200px);
                        }
                        to {
                            opacity: 1;
                            transform: translateX(0);
                        }
                    }

                    @keyframes exitToRight {
                        from {
                            opacity: 1;
                            transform: translateX(0);
                        }
                        to {
                            opacity: 0;
                            transform: translateX(200px);
                        }
                    }

                    @keyframes exitToLeft {
                        from {
                            opacity: 1;
                            transform: translateX(0);
                        }
                        to {
                            opacity: 0;
                            transform: translateX(-200px);
                        }
                    }

                    @keyframes scaleIn {
                        from {
                            opacity: 0;
                            transform: rotateX(-30deg) scale(0.9);
                        }
                        to {
                            opacity: 1;
                            transform: rotateX(0deg) scale(1);
                        }
                    }

                    @keyframes scaleOut {
                        from {
                            opacity: 1;
                            transform: rotateX(0deg) scale(1);
                        }
                        to {
                            opacity: 0;
                            transform: rotateX(-10deg) scale(0.95);
                        }
                    }

                    @keyframes fadeIn {
                        from {
                            opacity: 0;
                        }
                        to {
                            opacity: 1;
                        }
                    }

                    @keyframes fadeOut {
                        from {
                            opacity: 1;
                        }
                        to {
                            opacity: 0;
                        }
                    }
                </style>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: html`
            <nav class="NavigationMenuRoot" rdxNavigationMenu>
                <ul class="NavigationMenuList" rdxNavigationMenuList>
                    <li class="NavigationMenuItem" rdxNavigationMenuItem value="learn">
                        <button class="NavigationMenuTrigger" rdxNavigationMenuTrigger>
                            Learn
                            <svg
                                class="CaretDown"
                                width="15"
                                height="15"
                                viewBox="0 0 15 15"
                                fill="none"
                                xmlns="http://www.w3.org/2000/svg"
                                aria-hidden="true"
                            >
                                <path
                                    d="M4.18179 6.18181C4.35753 6.00608 4.64245 6.00608 4.81819 6.18181L7.49999 8.86362L10.1818 6.18181C10.3575 6.00608 10.6424 6.00608 10.8182 6.18181C10.9939 6.35755 10.9939 6.64247 10.8182 6.81821L7.81819 9.81821C7.73379 9.9026 7.61934 9.95001 7.49999 9.95001C7.38064 9.95001 7.26618 9.9026 7.18179 9.81821L4.18179 6.81821C4.00605 6.64247 4.00605 6.35755 4.18179 6.18181Z"
                                    fill="currentColor"
                                    fill-rule="evenodd"
                                    clip-rule="evenodd"
                                ></path>
                            </svg>
                        </button>

                        <div class="NavigationMenuContent" *rdxNavigationMenuContent>
                            <ul class="List one">
                                <li style="grid-row: span 3;">
                                    <a class="Callout" href="https://www.radix-ng.com/">
                                        <svg width="38" height="38" viewBox="0 0 24 24" fill="white">
                                            <path
                                                fill-rule="evenodd"
                                                clip-rule="evenodd"
                                                d="M11.576 2.00343L3 6.28335L3.02794 16.4367L3.02533 16.4391L3.02794 16.4379L3.02795 16.4408L3.03419 16.4352C5.58784 15.3254 7.85549 13.3817 9.4478 10.6971L9.45551 10.6902L9.45806 10.6798C11.047 7.99289 11.7245 4.96369 11.5773 2.01016L11.5794 2.00173L11.577 2.00294L11.5768 2L11.576 2.00343ZM12.424 2.00343L21 6.28335L20.9721 16.4367L20.9747 16.4391L20.9721 16.4379L20.972 16.4408L20.9658 16.4352C18.4122 15.3254 16.1445 13.3817 14.5522 10.6971L14.5445 10.6902L14.5419 10.6798C12.953 7.99289 12.2755 4.96369 12.4227 2.01016L12.4206 2.00173L12.423 2.00294L12.4232 2L12.424 2.00343ZM12.0978 22.25L3.79429 17.3315L3.79085 17.3325L3.79328 17.3309L3.79085 17.3295L3.79922 17.327C6.13674 15.7832 8.99744 14.8743 12.0874 14.8723L12.0978 14.8692L12.1082 14.8723C15.1981 14.8743 18.0588 15.7832 20.3963 17.327L20.4048 17.3295L20.4023 17.3309L20.4047 17.3325L20.4013 17.3315L12.0978 22.25Z"
                                            ></path>
                                        </svg>
                                        <div class="CalloutHeading">Radix Primitives</div>
                                        <p class="CalloutText">Unstyled, accessible components for Angular.</p>
                                    </a>
                                </li>

                                <li>
                                    <a
                                        class="ListItemLink"
                                        href="https://www.radix-ng.com/themes/overview/getting-started"
                                    >
                                        <div class="ListItemHeading">Themes</div>
                                        <p class="ListItemText">
                                            Pre-styled component library designed to work out of the box.
                                        </p>
                                    </a>
                                </li>
                                <li>
                                    <a class="ListItemLink" href="/colors">
                                        <div class="ListItemHeading">Colors</div>
                                        <p class="ListItemText">Beautiful, thought-out palettes with auto dark mode.</p>
                                    </a>
                                </li>
                                <li>
                                    <a class="ListItemLink" href="https://icons.radix-ui.com/">
                                        <div class="ListItemHeading">Icons</div>
                                        <p class="ListItemText">A crisp set of 15x15 icons, balanced and consistent.</p>
                                    </a>
                                </li>
                            </ul>
                        </div>
                    </li>

                    <li class="NavigationMenuItem" rdxNavigationMenuItem value="overview">
                        <button class="NavigationMenuTrigger" rdxNavigationMenuTrigger>
                            Overview
                            <svg
                                class="CaretDown"
                                width="15"
                                height="15"
                                viewBox="0 0 15 15"
                                fill="none"
                                xmlns="http://www.w3.org/2000/svg"
                                aria-hidden="true"
                            >
                                <path
                                    d="M4.18179 6.18181C4.35753 6.00608 4.64245 6.00608 4.81819 6.18181L7.49999 8.86362L10.1818 6.18181C10.3575 6.00608 10.6424 6.00608 10.8182 6.18181C10.9939 6.35755 10.9939 6.64247 10.8182 6.81821L7.81819 9.81821C7.73379 9.9026 7.61934 9.95001 7.49999 9.95001C7.38064 9.95001 7.26618 9.9026 7.18179 9.81821L4.18179 6.81821C4.00605 6.64247 4.00605 6.35755 4.18179 6.18181Z"
                                    fill="currentColor"
                                    fill-rule="evenodd"
                                    clip-rule="evenodd"
                                ></path>
                            </svg>
                        </button>

                        <div class="NavigationMenuContent" *rdxNavigationMenuContent>
                            <ul class="List two">
                                <li>
                                    <a
                                        class="ListItemLink"
                                        href="https://www.radix-ng.com/primitives/overview/introduction"
                                    >
                                        <div class="ListItemHeading">Introduction</div>
                                        <p class="ListItemText">
                                            Build high-quality, accessible design systems and web apps.
                                        </p>
                                    </a>
                                </li>
                                <li>
                                    <a
                                        class="ListItemLink"
                                        href="https://www.radix-ng.com/primitives/overview/getting-started"
                                    >
                                        <div class="ListItemHeading">Getting started</div>
                                        <p class="ListItemText">
                                            A quick tutorial to get you up and running with Radix Primitives.
                                        </p>
                                    </a>
                                </li>
                                <li>
                                    <a class="ListItemLink" href="https://www.radix-ng.com/primitives/overview/styling">
                                        <div class="ListItemHeading">Styling</div>
                                        <p class="ListItemText">Unstyled and compatible with any styling solution.</p>
                                    </a>
                                </li>
                                <li>
                                    <a
                                        class="ListItemLink"
                                        href="https://www.radix-ng.com/primitives/overview/accessibility"
                                    >
                                        <div class="ListItemHeading">Accessibility</div>
                                        <p class="ListItemText">
                                            Tested in a range of browsers and assistive technologies.
                                        </p>
                                    </a>
                                </li>
                                <li>
                                    <a
                                        class="ListItemLink"
                                        href="https://www.radix-ng.com/primitives/overview/contribute"
                                    >
                                        <div class="ListItemHeading">Contribute</div>
                                        <p class="ListItemText">Contribute to the open source project on GitHub.</p>
                                    </a>
                                </li>
                                <li>
                                    <a class="ListItemLink" href="https://github.com/radix-ng/primitives/releases">
                                        <div class="ListItemHeading">Releases</div>
                                        <p class="ListItemText">Radix Primitives releases and their changelogs.</p>
                                    </a>
                                </li>
                            </ul>
                        </div>
                    </li>

                    <li class="NavigationMenuItem" rdxNavigationMenuItem>
                        <a class="NavigationMenuLink" rdxNavigationMenuLink href="https://github.com/radix-ui">
                            Github
                        </a>
                    </li>

                    <div class="NavigationMenuIndicator" rdxNavigationMenuIndicator>
                        <div class="Arrow"></div>
                    </div>
                </ul>

                <div class="ViewportPosition">
                    <div class="NavigationMenuViewport" rdxNavigationMenuViewport></div>
                </div>
            </nav>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu-a11y.component.ts
```typescript
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { RdxVisuallyHiddenDirective } from '@radix-ng/primitives/visually-hidden';

@Component({
    selector: 'rdx-navigation-menu-focus-proxy',
    template: `
        <span
            [attr.tabindex]="0"
            [attr.aria-hidden]="true"
            (focus)="onFocus($event)"
            rdxVisuallyHidden
            feature="focusable"
        ></span>
    `,
    imports: [RdxVisuallyHiddenDirective]
})
export class RdxNavigationMenuFocusProxyComponent {
    @Input() triggerElement: HTMLElement | null = null;
    @Input() contentElement: HTMLElement | null = null;
    @Output() proxyFocus = new EventEmitter<'start' | 'end'>();

    onFocus(event: FocusEvent): void {
        const prevFocusedElement = event.relatedTarget as HTMLElement | null;
        const wasTriggerFocused = prevFocusedElement === this.triggerElement;
        const wasFocusFromContent = this.contentElement ? this.contentElement.contains(prevFocusedElement) : false;

        if (wasTriggerFocused || !wasFocusFromContent) {
            this.proxyFocus.emit(wasTriggerFocused ? 'start' : 'end');
        }
    }
}

@Component({
    selector: 'rdx-navigation-menu-aria-owns',
    template: `
        <span [attr.aria-owns]="contentId" rdxVisuallyHidden feature="fully-hidden"></span>
    `,
    imports: [RdxVisuallyHiddenDirective]
})
export class RdxNavigationMenuAriaOwnsComponent {
    @Input() contentId: string = '';
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu-content.directive.ts
```typescript
import {
    booleanAttribute,
    Directive,
    ElementRef,
    inject,
    Input,
    input,
    NgZone,
    OnDestroy,
    OnInit,
    TemplateRef
} from '@angular/core';
import { ESCAPE, injectDocument } from '@radix-ng/primitives/core';
import { RdxNavigationMenuItemDirective } from './navigation-menu-item.directive';
import { injectNavigationMenu, isRootNavigationMenu } from './navigation-menu.token';
import { getMotionAttribute, makeContentId, makeTriggerId } from './utils';

@Directive({
    selector: '[rdxNavigationMenuContent]'
})
export class RdxNavigationMenuContentDirective implements OnInit, OnDestroy {
    private readonly elementRef = inject(ElementRef);
    private readonly ngZone = inject(NgZone);
    private readonly template = inject(TemplateRef);
    private readonly document = injectDocument();
    private readonly item = inject(RdxNavigationMenuItemDirective);
    private readonly context = injectNavigationMenu();

    @Input({ transform: booleanAttribute })
    set rdxNavigationMenuContent(value: boolean) {
        // structural directive requires this input even if unused
    }

    /**
     * Used to keep the content rendered and available in the DOM, even when closed.
     * Useful for animations or SEO.
     * @default false
     */
    readonly forceMount = input(false, { transform: booleanAttribute });

    /** @ignore */
    readonly contentId = makeContentId(this.context.baseId, this.item.value());
    /** @ignore */
    readonly triggerId = makeTriggerId(this.context.baseId, this.item.value());

    private escapeHandler: ((e: KeyboardEvent) => void) | null = null;

    /** @ignore */
    ngOnInit() {
        this.item.contentRef.set(this.elementRef.nativeElement);

        // register template with viewport in root menu via context
        if (isRootNavigationMenu(this.context) && this.context.onViewportContentChange) {
            this.context.onViewportContentChange(this.item.value(), {
                ref: this.elementRef,
                templateRef: this.template,
                forceMount: this.forceMount(),
                value: this.item.value(),
                getMotionAttribute: this.getMotionAttribute.bind(this),
                additionalAttrs: {
                    id: this.contentId,
                    'aria-labelledby': this.triggerId,
                    role: 'menu'
                }
            });
        }

        // add Escape key handler
        this.escapeHandler = (event: KeyboardEvent) => {
            if (event.key === ESCAPE && this.context.value() === this.item.value()) {
                // mark that this close was triggered by Escape
                this.item.wasEscapeCloseRef.set(true);

                // close the content
                if (this.context.onItemDismiss) {
                    this.context.onItemDismiss();
                }

                // refocus the trigger
                setTimeout(() => {
                    const trigger = this.item.triggerRef();
                    if (trigger) trigger.focus();
                }, 0);

                event.preventDefault();
                event.stopPropagation();
            }
        };

        this.ngZone.runOutsideAngular(() => {
            if (this.escapeHandler) {
                this.document.addEventListener('keydown', this.escapeHandler);
            }
        });
    }

    /** @ignore */
    ngOnDestroy() {
        // unregister from viewport
        if (isRootNavigationMenu(this.context) && this.context.onViewportContentRemove) {
            this.context.onViewportContentRemove(this.item.value());
        }

        // remove escape key handler
        if (this.escapeHandler) {
            this.document.removeEventListener('keydown', this.escapeHandler);
            this.escapeHandler = null;
        }
    }

    /** @ignore - Compute motion attribute for animations */
    getMotionAttribute(): string | null {
        if (!isRootNavigationMenu(this.context)) return null;

        const itemValues = Array.from(this.context.viewportContent?.() ?? new Map()).map(([value]) => value);

        return getMotionAttribute(
            this.context.value(),
            this.context.previousValue(),
            this.item.value(),
            itemValues,
            this.context.dir
        );
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu-indicator.directive.ts
```typescript
import {
    booleanAttribute,
    computed,
    Directive,
    effect,
    ElementRef,
    inject,
    input,
    OnDestroy,
    Renderer2,
    runInInjectionContext,
    signal,
    untracked
} from '@angular/core';
import { injectNavigationMenu, isRootNavigationMenu } from './navigation-menu.token';

@Directive({
    selector: '[rdxNavigationMenuIndicator]',
    host: {
        '[attr.data-state]': 'isVisible() ? "visible" : "hidden"',
        '[attr.data-orientation]': 'context.orientation',
        '[style.display]': 'isVisible() ? null : "none"',
        'aria-hidden': 'true'
    }
})
export class RdxNavigationMenuIndicatorDirective implements OnDestroy {
    private readonly context = injectNavigationMenu();
    private readonly elementRef = inject(ElementRef);
    private readonly renderer = inject(Renderer2);

    /**
     * Used to keep the indicator rendered and available in the DOM, even when hidden.
     * Useful for animations.
     * @default false
     */
    readonly forceMount = input(false, { transform: booleanAttribute });

    /** @ignore */
    private readonly _position = signal<{ size: number; offset: number } | null>(null);
    /** @ignore */
    private readonly _activeTrigger = signal<HTMLElement | null>(null);
    /** @ignore */
    private readonly _resizeObserver = new ResizeObserver(() => this.updatePosition());

    readonly isVisible = computed(() => Boolean(this.context.value() || this.forceMount()));

    constructor() {
        // set up effect for tracking active trigger and position
        effect(() => {
            // this effect runs when the current value changes
            const value = this.context.value();

            untracked(() => {
                if (value && isRootNavigationMenu(this.context)) {
                    this.findAndSetActiveTrigger();
                }
            });
        });

        // initialize observers for position tracking
        runInInjectionContext(this.context as any, () => {
            if (isRootNavigationMenu(this.context) && this.context.indicatorTrack) {
                const track = this.context.indicatorTrack();
                if (track) {
                    // observe size changes on the track
                    this._resizeObserver.observe(track);
                }

                // initial position update if menu is open
                if (this.context.value()) {
                    setTimeout(() => this.findAndSetActiveTrigger(), 0);
                }
            }
        });
    }

    /** @ignore */
    ngOnDestroy() {
        this._resizeObserver.disconnect();
    }

    /** @ignore */
    private findAndSetActiveTrigger(): void {
        if (!isRootNavigationMenu(this.context) || !this.context.indicatorTrack) return;

        const track = this.context.indicatorTrack();
        if (!track) return;

        // find all triggers within the track
        const triggers = Array.from(track.querySelectorAll('[rdxNavigationMenuTrigger]')) as HTMLElement[];

        // find the active trigger based on the current menu value
        const activeTrigger = triggers.find((trigger) => {
            const item = trigger.closest('[rdxNavigationMenuItem]');
            if (!item) return false;

            const value = item.getAttribute('value');
            return value === this.context.value();
        });

        if (activeTrigger && activeTrigger !== this._activeTrigger()) {
            this._activeTrigger.set(activeTrigger);
            this.updatePosition();
        }
    }

    /** @ignore */
    private updatePosition(): void {
        const trigger = this._activeTrigger();
        if (!trigger) return;

        const isHorizontal = this.context.orientation === 'horizontal';

        // calculate new position
        const newPosition = {
            size: isHorizontal ? trigger.offsetWidth : trigger.offsetHeight,
            offset: isHorizontal ? trigger.offsetLeft : trigger.offsetTop
        };

        // only update if position has changed
        if (JSON.stringify(newPosition) !== JSON.stringify(this._position())) {
            this._position.set(newPosition);

            // apply position styles
            const styles = isHorizontal
                ? {
                      position: 'absolute',
                      left: '0',
                      width: `${newPosition.size}px`,
                      transform: `translateX(${newPosition.offset}px)`
                  }
                : {
                      position: 'absolute',
                      top: '0',
                      height: `${newPosition.size}px`,
                      transform: `translateY(${newPosition.offset}px)`
                  };

            Object.entries(styles).forEach(([key, value]) => {
                this.renderer.setStyle(this.elementRef.nativeElement, key, value);
            });
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu-item.directive.ts
```typescript
import { FocusableOption } from '@angular/cdk/a11y';
import { contentChild, Directive, ElementRef, inject, input, Signal, signal } from '@angular/core';
import { injectNavigationMenu, isRootNavigationMenu } from './navigation-menu.token';
import { RdxNavigationMenuFocusableOption } from './navigation-menu.types';
import { focusFirst, getTabbableCandidates, removeFromTabOrder } from './utils';

@Directive({
    selector: '[rdxNavigationMenuItem]',
    host: {
        '[attr.value]': 'value()'
    },
    exportAs: 'rdxNavigationMenuItem'
})
export class RdxNavigationMenuItemDirective implements FocusableOption {
    readonly elementRef = inject(ElementRef);
    private readonly context = injectNavigationMenu();

    readonly value = input('');

    /**
     * @ignore
     */
    readonly triggerOrLink = contentChild(RdxNavigationMenuFocusableOption);

    readonly triggerRef = signal<HTMLElement | null>(null);
    readonly contentRef = signal<HTMLElement | null>(null);
    readonly focusProxyRef = signal<HTMLElement | null>(null);
    readonly wasEscapeCloseRef = signal(false);

    private readonly _restoreContentTabOrderRef = signal<(() => void) | null>(null);

    get restoreContentTabOrderRef(): Signal<(() => void) | null> {
        return this._restoreContentTabOrderRef;
    }

    /**
     * Handle keyboard entry into content from trigger
     */
    onEntryKeyDown() {
        // Check if we're using a viewport in a root menu
        if (isRootNavigationMenu(this.context) && this.context.viewport && this.context.viewport()) {
            const viewport = this.context.viewport();
            if (viewport) {
                // find tabbable elements in the viewport
                const candidates = getTabbableCandidates(viewport);
                if (candidates.length) {
                    this.ensureTabOrder();

                    // focus the first element
                    focusFirst(candidates);
                    return;
                }
            }
        }

        // fallback to content if no viewport or no tabbable elements in viewport
        if (this.contentRef()) {
            // restore tab order if needed
            const restoreFn = this._restoreContentTabOrderRef();
            if (restoreFn) restoreFn();

            // find and focus first tabbable element
            const candidates = getTabbableCandidates(this.contentRef()!);
            if (candidates.length) {
                focusFirst(candidates);
            }
        }
    }

    focus(): void {
        this.triggerOrLink()?.focus();
    }

    /**
     * Ensure elements are in the tab order by restoring any previously removed tabindex values
     */
    private ensureTabOrder(): void {
        const restoreFn = this._restoreContentTabOrderRef();
        if (restoreFn) {
            restoreFn();
            this._restoreContentTabOrderRef.set(null);
        }
    }

    /**
     * Handle focus coming from the focus proxy element
     * @param side Which side the focus is coming from (start = from trigger, end = from after content)
     */
    onFocusProxyEnter(side: 'start' | 'end' = 'start') {
        // check for viewport first
        if (isRootNavigationMenu(this.context) && this.context.viewport && this.context.viewport()) {
            const viewport = this.context.viewport();
            if (viewport) {
                const candidates = getTabbableCandidates(viewport);
                if (candidates.length) {
                    this.ensureTabOrder();

                    // focus first or last element depending on direction
                    focusFirst(side === 'start' ? candidates : [...candidates].reverse());
                    return;
                }
            }
        }

        // fallback to content
        if (this.contentRef()) {
            // restore tab order if needed
            const restoreFn = this._restoreContentTabOrderRef();
            if (restoreFn) restoreFn();

            // find and focus appropriate element based on direction
            const candidates = getTabbableCandidates(this.contentRef()!);
            if (candidates.length) {
                // Focus first or last element depending on which direction we're coming from
                focusFirst(side === 'start' ? candidates : [...candidates].reverse());
            }
        }
    }

    /**
     * Handle focus moving outside of the content
     * Remove elements from tab order when not focused
     */
    onContentFocusOutside() {
        // get all tabbable elements from both viewport and content
        let allCandidates: HTMLElement[] = [];

        // check viewport first
        if (isRootNavigationMenu(this.context) && this.context.viewport && this.context.viewport()) {
            const viewport = this.context.viewport();
            if (viewport) {
                allCandidates = getTabbableCandidates(viewport);
            }
        }

        // ... also check direct content
        if (this.contentRef()) {
            const contentCandidates = getTabbableCandidates(this.contentRef()!);
            allCandidates = [...allCandidates, ...contentCandidates];
        }

        // remove from tab order and store restore function
        if (allCandidates.length) {
            this._restoreContentTabOrderRef.set(removeFromTabOrder(allCandidates));
        }
    }

    /**
     * Handle content being closed from root menu
     */
    onRootContentClose() {
        this.onContentFocusOutside();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu-link.directive.ts
```typescript
import { booleanAttribute, Directive, ElementRef, inject, input, OnInit } from '@angular/core';
import { ENTER, SPACE } from '@radix-ng/primitives/core';
import { RdxRovingFocusItemDirective } from '@radix-ng/primitives/roving-focus';
import { RdxNavigationMenuFocusableOption } from './navigation-menu.types';
import { generateId } from './utils';

const LINK_SELECT = 'navigationMenu.linkSelect';
const ROOT_CONTENT_DISMISS = 'navigationMenu.rootContentDismiss';

@Directive({
    selector: '[rdxNavigationMenuLink]',
    hostDirectives: [{ directive: RdxRovingFocusItemDirective, inputs: ['focusable'] }],
    host: {
        '[attr.data-active]': 'active() ? "" : undefined',
        '[attr.aria-current]': 'active() ? "page" : undefined',
        '(click)': 'onClick($event)',
        '(keydown)': 'onKeydown($event)'
    },
    providers: [{ provide: RdxNavigationMenuFocusableOption, useExisting: RdxNavigationMenuLinkDirective }]
})
export class RdxNavigationMenuLinkDirective extends RdxNavigationMenuFocusableOption implements OnInit {
    private readonly rovingFocusItem = inject(RdxRovingFocusItemDirective, { self: true });
    private readonly uniqueId = generateId();
    readonly active = input(false, { transform: booleanAttribute });
    readonly onSelect = input<(event: Event) => void>();
    readonly elementRef = inject(ElementRef);

    ngOnInit(): void {
        this.rovingFocusItem.tabStopId = this.elementRef.nativeElement.id || `link-${this.uniqueId}`;
    }

    override focus(): void {
        this.elementRef.nativeElement.focus();
    }

    onClick(event: MouseEvent) {
        const target = event.target as HTMLElement;

        // dispatch link select event
        const linkSelectEvent = new CustomEvent(LINK_SELECT, {
            bubbles: true,
            cancelable: true
        });

        // add one-time listener for onSelect handler
        const onSelect = this.onSelect();
        if (onSelect) {
            target.addEventListener(LINK_SELECT, onSelect, { once: true });
        }

        // dispatch event
        target.dispatchEvent(linkSelectEvent);

        // if not prevented and not meta key, dismiss content
        if (!linkSelectEvent.defaultPrevented && !event.metaKey) {
            const dismissEvent = new CustomEvent(ROOT_CONTENT_DISMISS, {
                bubbles: true,
                cancelable: true
            });
            target.dispatchEvent(dismissEvent);
        }
    }

    onKeydown(event: KeyboardEvent): void {
        // activate link on Enter or Space
        if (event.key === ENTER || event.key === SPACE) {
            // prevent default behavior like scrolling (Space) or form submission (Enter) BEFORE simulating the click.
            event.preventDefault();

            // simulate a click event on the link element itself
            const clickEvent = new MouseEvent('click', { bubbles: true, cancelable: true });
            this.elementRef.nativeElement.dispatchEvent(clickEvent);

            return;
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu-list.directive.ts
```typescript
import { FocusKeyManager } from '@angular/cdk/a11y';
import {
    AfterContentInit,
    AfterViewInit,
    contentChildren,
    Directive,
    ElementRef,
    forwardRef,
    inject,
    Renderer2
} from '@angular/core';
import { TAB } from '@radix-ng/primitives/core';
import { RdxRovingFocusGroupDirective } from '@radix-ng/primitives/roving-focus'; // Import Roving Focus Group
import { RdxNavigationMenuItemDirective } from './navigation-menu-item.directive';
import { injectNavigationMenu, isRootNavigationMenu } from './navigation-menu.token';

@Directive({
    selector: '[rdxNavigationMenuList]',
    hostDirectives: [RdxRovingFocusGroupDirective],
    host: {
        role: 'menubar',
        '(keydown)': 'onKeydown($event)'
    }
})
export class RdxNavigationMenuListDirective implements AfterContentInit, AfterViewInit {
    private readonly context = injectNavigationMenu();
    private readonly elementRef = inject(ElementRef<HTMLElement>);
    private readonly renderer = inject(Renderer2);
    private readonly rovingFocusGroup = inject(RdxRovingFocusGroupDirective, { self: true });

    /**
     * @private
     * @ignore
     */
    readonly items = contentChildren(
        forwardRef(() => RdxNavigationMenuItemDirective),
        { descendants: true }
    );

    /**
     * @ignore
     */
    protected keyManager: FocusKeyManager<RdxNavigationMenuItemDirective>;

    /**
     * @ignore
     */
    ngAfterContentInit(): void {
        const items = this.items();
        this.keyManager = new FocusKeyManager(items);

        if (this.context.orientation === 'horizontal') {
            this.keyManager.withHorizontalOrientation(this.context.dir || 'ltr');
        } else {
            this.keyManager.withVerticalOrientation();
        }
    }

    /**
     * @ignore
     */
    ngAfterViewInit() {
        this.rovingFocusGroup.orientation = this.context.orientation;
        this.rovingFocusGroup.dir = this.context.dir;

        // looping typically only applies to the root menu bar
        if (isRootNavigationMenu(this.context)) {
            this.rovingFocusGroup.loop = this.context.loop ?? false;
        } else {
            this.rovingFocusGroup.loop = false;
        }

        if (isRootNavigationMenu(this.context) && this.context.onIndicatorTrackChange) {
            const listElement = this.elementRef.nativeElement;
            const parent = listElement.parentNode;

            // ensure parent exists and list hasn't already been wrapped
            if (parent && !listElement.parentElement?.hasAttribute('data-radix-navigation-menu-list-wrapper')) {
                // create a wrapper div with relative positioning
                const wrapper = this.renderer.createElement('div');
                this.renderer.setAttribute(wrapper, 'data-radix-navigation-menu-list-wrapper', ''); // Add marker
                this.renderer.setStyle(wrapper, 'position', 'relative');

                // insert the wrapper before the list element in the parent
                this.renderer.insertBefore(parent, wrapper, listElement);

                // move the list element inside the new wrapper
                this.renderer.appendChild(wrapper, listElement);

                // register the wrapper element as the track for the indicator positioning
                this.context.onIndicatorTrackChange(wrapper);
            } else if (listElement.parentElement?.hasAttribute('data-radix-navigation-menu-list-wrapper')) {
                // if wrapper somehow already exists, ensure context has the correct reference
                this.context.onIndicatorTrackChange(listElement.parentElement);
            }
        }
    }

    /**
     * @ignore
     */
    onKeydown(event: KeyboardEvent) {
        if (!this.keyManager.activeItem) {
            this.keyManager.setFirstItemActive();
        }

        if (event.key === TAB && event.shiftKey) {
            if (this.keyManager.activeItemIndex === 0) return;
            this.keyManager.setPreviousItemActive();
            event.preventDefault();
        } else if (event.key === TAB) {
            const items = this.items();
            if (this.keyManager.activeItemIndex === items.length - 1) {
                return;
            }
            this.keyManager.setNextItemActive();
            event.preventDefault();
        } else {
            this.keyManager.onKeydown(event);
        }
    }

    /**
     * @ignore
     */
    setActiveItem(item: RdxNavigationMenuItemDirective) {
        this.keyManager.setActiveItem(item);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu-sub.directive.ts
```typescript
import { Directive, inject, Input, input, output, signal } from '@angular/core';
import { RdxNavigationMenuDirective } from './navigation-menu.directive';
import { provideNavigationMenuContext } from './navigation-menu.token';
import { generateId } from './utils';

@Directive({
    selector: '[rdxNavigationMenuSub]',
    providers: [provideNavigationMenuContext(RdxNavigationMenuSubDirective)],
    host: {
        '[attr.data-orientation]': 'orientation()'
    }
})
export class RdxNavigationMenuSubDirective {
    readonly orientation = input<'horizontal' | 'vertical'>('horizontal');
    @Input() set defaultValue(val: string) {
        if (val) this.value.set(val);
    }

    readonly valueChange = output<string>();

    readonly value = signal<string>('');
    readonly previousValue = signal<string>('');
    readonly baseId = `rdx-nav-menu-sub-${generateId()}`;
    readonly isRootMenu = false;

    private readonly parent = inject(RdxNavigationMenuDirective, { optional: true });

    get dir(): 'ltr' | 'rtl' {
        if (!this.parent) {
            return 'ltr';
        }

        return this.parent.dir || 'ltr';
    }

    get rootNavigationMenu(): HTMLElement | null {
        return this.parent?.rootNavigationMenu() || null;
    }

    onTriggerEnter(itemValue: string) {
        this.setValue(itemValue);
    }

    onItemSelect(itemValue: string) {
        this.setValue(itemValue);
    }

    onItemDismiss() {
        this.setValue('');
    }

    private setValue(value: string) {
        this.previousValue.set(this.value());
        this.value.set(value);
        this.valueChange.emit(value);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu-trigger.directive.ts
```typescript
import {
    booleanAttribute,
    ComponentRef,
    computed,
    Directive,
    effect,
    ElementRef,
    inject,
    input,
    OnDestroy,
    OnInit,
    untracked,
    ViewContainerRef
} from '@angular/core';
import { ARROW_DOWN, ARROW_LEFT, ARROW_RIGHT, ARROW_UP, ENTER, SPACE, TAB } from '@radix-ng/primitives/core';
import { RdxRovingFocusItemDirective } from '@radix-ng/primitives/roving-focus';
import {
    RdxNavigationMenuAriaOwnsComponent,
    RdxNavigationMenuFocusProxyComponent
} from './navigation-menu-a11y.component';
import { RdxNavigationMenuItemDirective } from './navigation-menu-item.directive';
import { RdxNavigationMenuListDirective } from './navigation-menu-list.directive';
import { injectNavigationMenu, isRootNavigationMenu } from './navigation-menu.token';
import { RdxNavigationMenuFocusableOption } from './navigation-menu.types';
import { getTabbableCandidates, makeContentId, makeTriggerId } from './utils';

@Directive({
    selector: '[rdxNavigationMenuTrigger]',
    hostDirectives: [RdxRovingFocusItemDirective],
    host: {
        '[id]': 'triggerId',
        '[attr.data-state]': 'open() ? "open" : "closed"',
        '[attr.data-orientation]': 'context.orientation',
        '[attr.data-disabled]': 'disabled() ? "" : undefined',
        '[disabled]': 'disabled() ? true : null',
        '[attr.aria-expanded]': 'open()',
        '[attr.aria-controls]': 'contentId',
        '[attr.aria-haspopup]': '"menu"',
        '(pointerenter)': 'onPointerEnter()',
        '(pointermove)': 'onPointerMove($event)',
        '(pointerleave)': 'onPointerLeave($event)',
        '(click)': 'onClick()',
        '(keydown)': 'onKeydown($event)',
        type: 'button'
    },
    providers: [{ provide: RdxNavigationMenuFocusableOption, useExisting: RdxNavigationMenuTriggerDirective }]
})
export class RdxNavigationMenuTriggerDirective extends RdxNavigationMenuFocusableOption implements OnInit, OnDestroy {
    private readonly context = injectNavigationMenu();
    private readonly item = inject(RdxNavigationMenuItemDirective);
    private readonly list = inject(RdxNavigationMenuListDirective);
    private readonly rovingFocusItem = inject(RdxRovingFocusItemDirective, { self: true });
    private readonly elementRef = inject(ElementRef);
    private readonly viewContainerRef = inject(ViewContainerRef);

    readonly disabled = input(false, { transform: booleanAttribute });

    readonly triggerId = makeTriggerId(this.context.baseId, this.item.value());
    readonly contentId = makeContentId(this.context.baseId, this.item.value());
    readonly open = computed(() => {
        return this.item.value() === this.context.value();
    });

    private focusProxyRef: ComponentRef<RdxNavigationMenuFocusProxyComponent> | null = null;
    private ariaOwnsRef: ComponentRef<RdxNavigationMenuAriaOwnsComponent> | null = null;

    private hasPointerMoveOpened = false;
    private wasClickClose = false;

    constructor() {
        super();

        effect(() => {
            this.rovingFocusItem.focusable = !this.disabled();
        });

        effect(() => {
            const isOpen = this.open();

            untracked(() => {
                // handle focus proxy and aria-owns when open state changes
                if (isOpen) {
                    this.createAccessibilityComponents();
                } else {
                    this.removeAccessibilityComponents();

                    if (!this.item.wasEscapeCloseRef()) {
                        this.item.onRootContentClose();
                    }

                    this.hasPointerMoveOpened = false;
                }
            });
        });
    }

    ngOnInit() {
        this.item.triggerRef.set(this.elementRef.nativeElement);

        // configure the static part of the roving focus item directive instance
        this.rovingFocusItem.tabStopId = this.item.value();
    }

    ngOnDestroy() {
        this.removeAccessibilityComponents();
    }

    override focus() {
        this.elementRef.nativeElement.focus();
    }

    private createAccessibilityComponents(): void {
        if (this.focusProxyRef || this.ariaOwnsRef) {
            return;
        }

        // create focus proxy component
        this.focusProxyRef = this.viewContainerRef.createComponent(RdxNavigationMenuFocusProxyComponent);
        this.focusProxyRef.instance.triggerElement = this.elementRef.nativeElement;
        this.focusProxyRef.instance.contentElement = this.item.contentRef();
        this.focusProxyRef.instance.proxyFocus.subscribe((direction: 'start' | 'end') => {
            this.item.onFocusProxyEnter(direction);
        });

        // store reference in item directive
        this.item.focusProxyRef.set(this.focusProxyRef.location.nativeElement);

        // only add aria-owns component if using viewport
        if (isRootNavigationMenu(this.context) && this.context.viewport && this.context.viewport()) {
            this.ariaOwnsRef = this.viewContainerRef.createComponent(RdxNavigationMenuAriaOwnsComponent);
            this.ariaOwnsRef.instance.contentId = this.contentId;
        }
    }

    private removeAccessibilityComponents(): void {
        if (this.focusProxyRef) {
            this.focusProxyRef.destroy();
            this.focusProxyRef = null;
            this.item.focusProxyRef.set(null);
        }

        if (this.ariaOwnsRef) {
            this.ariaOwnsRef.destroy();
            this.ariaOwnsRef = null;
        }
    }

    onPointerEnter(): void {
        // ignore if disabled or not the root menu (hover logic primarily for root)
        if (this.disabled() || !isRootNavigationMenu(this.context)) return;

        this.wasClickClose = false; // Reset click close flag on enter
        this.item.wasEscapeCloseRef.set(false); // Reset escape flag
        this.context.setTriggerPointerState?.(true); // Update context state

        // if the menu isn't already open for this item, trigger the enter logic (handles delays)
        if (!this.open()) {
            this.context.onTriggerEnter?.(this.item.value());
        }
    }

    onPointerMove(event: PointerEvent): void {
        // ignore if not a mouse event, disabled, closed by click/escape, or already opened by this move
        if (
            event.pointerType !== 'mouse' ||
            this.disabled() ||
            this.wasClickClose ||
            this.item.wasEscapeCloseRef() ||
            this.hasPointerMoveOpened ||
            !isRootNavigationMenu(this.context)
        ) {
            return;
        }
        // trigger enter logic (handles delays) and mark that this move initiated an open attempt
        this.context.onTriggerEnter?.(this.item.value());
        this.hasPointerMoveOpened = true;
    }

    onPointerLeave(event: PointerEvent): void {
        // ignore if not a mouse event or disabled
        if (event.pointerType !== 'mouse' || this.disabled() || !isRootNavigationMenu(this.context)) {
            return;
        }

        this.context.setTriggerPointerState?.(false); // Update context state
        this.context.onTriggerLeave?.(); // Trigger leave logic (handles delays)
        this.hasPointerMoveOpened = false; // Reset flag

        // reset user dismissal flag if pointer leaves the whole system (trigger + content)
        if (this.context.resetUserDismissed) {
            // relay slightly to allow pointer movement to content area without resetting dismissal state
            setTimeout(() => {
                if (!this.context.isPointerInSystem?.()) {
                    this.context.resetUserDismissed?.();
                }
            }, 50); // small delay for tolerance
        }
    }

    onClick(): void {
        if (this.disabled()) return;

        // manually set the `KeyManager` active item to this trigger
        this.list.setActiveItem(this.item);

        if (this.context.onItemSelect) {
            this.context.onItemSelect(this.item.value());
            // track if this click action resulted in closing the menu
            this.wasClickClose = !this.open();
            // reset escape flag if menu was opened by click
            if (this.open()) {
                this.item.wasEscapeCloseRef.set(false);
            }
        }
    }

    onKeydown(event: KeyboardEvent): void {
        if (this.disabled()) return;

        if (event.key === ENTER || event.key === SPACE) {
            event.preventDefault(); // prevent default button behavior
            this.onClick();

            // if menu was opened by this keypress, move focus into the content
            if (this.open()) {
                // defer focus slightly to ensure content is ready
                setTimeout(() => this.item.onEntryKeyDown(), 0);
            }
            return;
        }

        const isHorizontal = this.context.orientation === 'horizontal';
        const isRTL = this.context.dir === 'rtl';

        // handle `ArrowDown` specifically for viewport navigation
        if (event.key === ARROW_DOWN || event.key === TAB) {
            if (event.key === ARROW_DOWN) {
                event.preventDefault();
            }

            // if the menu is open, focus into the content
            if (this.open()) {
                if (event.key === TAB) {
                    // needed to ensure that the `keyManager` on the list directive does not activate
                    // any focus updates, shifting focus to the subsequent focusable list item
                    event.stopImmediatePropagation();
                }

                // direct focus handling for viewport case
                if (isRootNavigationMenu(this.context) && this.context.viewport && this.context.viewport()) {
                    // get the viewport element
                    const viewport = this.context.viewport();
                    if (viewport) {
                        // find all tabbable elements in the viewport
                        const tabbables = getTabbableCandidates(viewport);
                        if (tabbables.length > 0) {
                            // focus the first tabbable element directly
                            setTimeout(() => {
                                tabbables[0].focus();
                            }, 0);
                            return;
                        }
                    }
                }

                // fallback to the standard entry key down approach
                setTimeout(() => this.item.onEntryKeyDown(), 0);
                return;
            }

            // if not open but in horizontal orientation, emulate right key navigation
            if (isHorizontal) {
                const nextEvent = new KeyboardEvent('keydown', {
                    key: isRTL ? ARROW_LEFT : ARROW_RIGHT,
                    bubbles: true
                });
                this.elementRef.nativeElement.dispatchEvent(nextEvent);
                return;
            }
        }

        // handle ArrowUp in horizontal orientation
        if (isHorizontal && event.key === ARROW_UP) {
            event.preventDefault();

            // emulate a left key press to move to the previous item
            const nextEvent = new KeyboardEvent('keydown', {
                key: isRTL ? ARROW_RIGHT : ARROW_LEFT,
                bubbles: true
            });
            this.elementRef.nativeElement.dispatchEvent(nextEvent);
            return;
        }

        // handle vertical navigation and entry into content
        const verticalEntryKey = isRTL ? ARROW_LEFT : ARROW_RIGHT;
        const entryKey = isHorizontal ? ARROW_DOWN : verticalEntryKey;

        if (this.item.contentRef() && event.key === entryKey && event.key !== ARROW_DOWN) {
            // Skip if it's ArrowDown as we already handled it above
            event.preventDefault();

            if (!this.open()) {
                // if closed, open the menu first
                this.context.onItemSelect?.(this.item.value());
                // defer focus movement into content until after state update and render
                setTimeout(() => this.item.onEntryKeyDown(), 0);
            } else {
                // if already open, just move focus into the content
                this.item.onEntryKeyDown();
            }
            return;
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu-viewport.directive.ts
```typescript
import {
    booleanAttribute,
    computed,
    DestroyRef,
    Directive,
    effect,
    ElementRef,
    EmbeddedViewRef,
    inject,
    input,
    NgZone,
    OnDestroy,
    OnInit,
    Renderer2,
    signal,
    untracked,
    ViewContainerRef
} from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { ARROW_DOWN, ARROW_UP, injectDocument, injectWindow } from '@radix-ng/primitives/core';
import { TransitionOptions, TransitionStartFn, usePresence } from '@radix-ng/primitives/presence';
import { Subscription } from 'rxjs';
import { injectNavigationMenu, isRootNavigationMenu } from './navigation-menu.token';
import { getOpenStateLabel, getTabbableCandidates } from './utils';

interface ContentNode {
    embeddedView: EmbeddedViewRef<unknown>;
    element: HTMLElement;
    contentValue: string;
    state: 'open' | 'closed';
    transitionSubscription?: Subscription | null;
}

@Directive({
    selector: '[rdxNavigationMenuViewport]',
    host: {
        '[attr.data-state]': 'dataState()',
        '[attr.data-orientation]': 'context.orientation',
        '[style.--radix-navigation-menu-viewport-width.px]': 'viewportSize()?.width',
        '[style.--radix-navigation-menu-viewport-height.px]': 'viewportSize()?.height',
        '(keydown)': 'onKeydown($event)',
        '(pointerenter)': 'onPointerEnter()',
        '(pointerleave)': 'onPointerLeave()'
    }
})
export class RdxNavigationMenuViewportDirective implements OnInit, OnDestroy {
    private readonly context = injectNavigationMenu();
    private readonly document = injectDocument();
    private readonly window = injectWindow();
    private readonly elementRef = inject(ElementRef);
    private readonly viewContainerRef = inject(ViewContainerRef);
    private readonly renderer = inject(Renderer2);
    private readonly zone = inject(NgZone);
    private readonly destroyRef = inject(DestroyRef);

    /**
     * Used to keep the viewport rendered and available in the DOM, even when closed.
     * Useful for animations.
     * @default false
     */
    readonly forceMount = input(false, { transform: booleanAttribute });

    private readonly _contentNodes = signal(new Map<string, ContentNode>());
    private readonly _activeContentNode = signal<ContentNode | null>(null);
    private readonly _leavingContentNode = signal<ContentNode | null>(null);
    private readonly _viewportSize = signal<{ width: number; height: number } | null>(null);

    readonly activeContentValue = computed(() => {
        if (!isRootNavigationMenu(this.context)) return null;
        return this.context.value() || this.context.previousValue();
    });
    readonly isOpen = computed(() => {
        if (!isRootNavigationMenu(this.context)) return false;
        return Boolean(this.context.value() || this.forceMount());
    });
    readonly dataState = computed(() => getOpenStateLabel(this.isOpen()));
    readonly viewportSize = computed(() => this._viewportSize());

    private readonly _resizeObserver = new ResizeObserver(() => this.updateSize());

    constructor() {
        this.setupViewportEffect();
    }

    ngOnInit() {
        if (isRootNavigationMenu(this.context) && this.context.onViewportChange) {
            this.context.onViewportChange(this.elementRef.nativeElement);
        }
    }

    ngOnDestroy() {
        this._resizeObserver.disconnect();
        // clean up any remaining nodes/views/subscriptions
        this._contentNodes().forEach((node) => this.cleanupAfterLeave(node));
        if (isRootNavigationMenu(this.context) && this.context.onViewportChange) {
            this.context.onViewportChange(null);
        }
    }

    onKeydown(event: KeyboardEvent): void {
        if (!this.isOpen()) return;
        const tabbableElements = getTabbableCandidates(this.elementRef.nativeElement);
        if (!tabbableElements.length) return;
        const activeElement = this.document.activeElement as HTMLElement | null;
        const currentIndex = tabbableElements.findIndex((el) => el === activeElement);

        if (event.key === ARROW_DOWN) {
            event.preventDefault();
            const nextIndex = currentIndex >= 0 && currentIndex < tabbableElements.length - 1 ? currentIndex + 1 : 0;
            tabbableElements[nextIndex]?.focus();
        } else if (event.key === ARROW_UP) {
            event.preventDefault();
            const prevIndex = currentIndex > 0 ? currentIndex - 1 : tabbableElements.length - 1;
            tabbableElements[prevIndex]?.focus();
        }
    }

    onPointerEnter(): void {
        if (isRootNavigationMenu(this.context) && this.context.onContentEnter) {
            this.context.onContentEnter();
        }
        if (isRootNavigationMenu(this.context) && this.context.setContentPointerState) {
            this.context.setContentPointerState(true);
        }
    }

    onPointerLeave(): void {
        if (isRootNavigationMenu(this.context) && this.context.onContentLeave) {
            this.context.onContentLeave();
        }
        if (isRootNavigationMenu(this.context) && this.context.setContentPointerState) {
            this.context.setContentPointerState(false);
        }
    }

    private setupViewportEffect(): void {
        effect(() => {
            const currentActiveValue = this.context.value();
            const previousActiveValue = this.context.previousValue();
            const forceMount = this.forceMount();

            untracked(() => {
                // ensure context is root before proceeding
                if (!isRootNavigationMenu(this.context) || !this.context.viewportContent) {
                    return;
                }

                const allContentData = this.context.viewportContent();
                const currentNodesMap = this._contentNodes();
                let enteringNode: ContentNode | null = null;
                let leavingNode = this._leavingContentNode(); // get potentially already leaving node

                // 1. Identify Entering Node
                if (currentActiveValue && allContentData.has(currentActiveValue)) {
                    enteringNode = this.getOrCreateContentNode(currentActiveValue);
                }

                // 2. Identify Leaving Node
                const nodeThatWasActive = previousActiveValue ? currentNodesMap.get(previousActiveValue) : null;
                // if there was a previously active node, it's different from the entering one,
                // and it's not already leaving, mark it for removal.
                if (nodeThatWasActive && nodeThatWasActive !== enteringNode && nodeThatWasActive !== leavingNode) {
                    // if another node was already leaving, force complete its transition
                    if (leavingNode) {
                        this.forceCompleteLeaveTransition(leavingNode);
                    }
                    leavingNode = nodeThatWasActive;
                    this._leavingContentNode.set(leavingNode);
                }

                // 3. Handle Entering Node
                if (enteringNode) {
                    // cancel any pending leave transition for this node if it was leaving
                    if (enteringNode === leavingNode) {
                        this.cancelLeaveTransition(enteringNode);
                        leavingNode = null;
                        this._leavingContentNode.set(null);
                    }
                    // ensure it's in the DOM and set state to open
                    this.addNodeToDOM(enteringNode);
                    this.setNodeState(enteringNode, 'open'); // Triggers enter animation via data-state
                    this._activeContentNode.set(enteringNode);
                    this.updateSize(); // Update size based on the entering node
                } else {
                    // no node entering, clear active node state
                    this._activeContentNode.set(null);
                }

                // 4. Handle Leaving Node
                if (leavingNode) {
                    if (forceMount) {
                        // if forceMount, just mark as closed, don't trigger removal animation
                        this.setNodeState(leavingNode, 'closed');
                        this._leavingContentNode.set(null); // No longer considered "leaving"
                    } else {
                        // start the leave transition (usePresence handles DOM removal)
                        this.startLeaveTransition(leavingNode);
                    }
                }
            });
        });
    }

    // gets or creates the ContentNode (wrapper + view)
    private getOrCreateContentNode(contentValue: string): ContentNode | null {
        const existingNode = this._contentNodes().get(contentValue);
        if (existingNode && !existingNode.embeddedView.destroyed) {
            return existingNode;
        }

        // create if doesn't exist or view was destroyed
        if (!isRootNavigationMenu(this.context) || !this.context.viewportContent) return null;
        const allContentData = this.context.viewportContent();
        const contentData = allContentData.get(contentValue);
        const templateRef = contentData?.templateRef;

        if (!templateRef) {
            console.error(`No templateRef found for content value: ${contentValue}`);
            return null;
        }

        try {
            const embeddedView = this.viewContainerRef.createEmbeddedView(templateRef);
            const container = this.renderer.createElement('div');
            this.renderer.setAttribute(container, 'class', 'NavigationMenuContentWrapper');
            this.renderer.setAttribute(container, 'data-content-value', contentValue);
            embeddedView.rootNodes.forEach((node: Node) => this.renderer.appendChild(container, node));

            const newNode: ContentNode = {
                embeddedView,
                element: container,
                contentValue,
                state: 'closed'
            };

            const newMap = new Map(this._contentNodes());
            newMap.set(contentValue, newNode);
            this._contentNodes.set(newMap);
            return newNode;
        } catch (error) {
            console.error(`Error creating content node for ${contentValue}:`, error);
            return null;
        }
    }

    // adds node element to viewport DOM if not already present
    private addNodeToDOM(node: ContentNode): void {
        if (!this.elementRef.nativeElement.contains(node.element)) {
            this.renderer.appendChild(this.elementRef.nativeElement, node.element);
            // observe size only when added to DOM
            this._resizeObserver.observe(node.element);
        }
    }

    // removes node element from viewport DOM
    private removeNodeFromDOM(node: ContentNode): void {
        if (this.elementRef.nativeElement.contains(node.element)) {
            this._resizeObserver.unobserve(node.element); // stop observing before removal
            this.renderer.removeChild(this.elementRef.nativeElement, node.element);
        }
    }

    // updates the data-state and motion attributes
    private setNodeState(node: ContentNode, state: 'open' | 'closed'): void {
        if (node.state === state) return; // avoid redundant updates

        node.state = state;
        this.renderer.setAttribute(node.element, 'data-state', state);

        // apply motion attribute based on context
        if (isRootNavigationMenu(this.context) && this.context.viewportContent) {
            const contentData = this.context.viewportContent().get(node.contentValue);
            if (contentData?.getMotionAttribute) {
                // get motion based on current state transition
                const motionAttr = contentData.getMotionAttribute();
                if (motionAttr) {
                    this.renderer.setAttribute(node.element, 'data-motion', motionAttr);
                } else {
                    this.renderer.removeAttribute(node.element, 'data-motion');
                }
            } else {
                this.renderer.removeAttribute(node.element, 'data-motion');
            }
        }

        // apply A11y attributes (might only be needed on open?)
        if (state === 'open') {
            this.applyA11yAttributes(node);
        }
    }

    // apply A11y attributes to the first child element
    private applyA11yAttributes(node: ContentNode): void {
        if (!isRootNavigationMenu(this.context) || !this.context.viewportContent) return;
        const contentData = this.context.viewportContent().get(node.contentValue);
        if (contentData?.additionalAttrs && node.embeddedView.rootNodes.length > 0) {
            const firstRootNode = node.embeddedView.rootNodes[0] as Element;
            if (firstRootNode) {
                Object.entries(contentData.additionalAttrs).forEach(([attr, value]) => {
                    this.renderer.setAttribute(firstRootNode, attr, value as string);
                });
            }
        }
    }

    private startLeaveTransition(node: ContentNode): void {
        // ensure node exists and isn't already leaving with an active subscription
        if (!node || node.transitionSubscription) {
            node.transitionSubscription?.unsubscribe();
            return;
        }

        const startFn: TransitionStartFn<null> = () => {
            this.setNodeState(node, 'closed');
            return () => this.cleanupAfterLeave(node);
        };

        const options: TransitionOptions<null> = {
            animation: true, // assuming CSS animations/transitions handle the exit
            state: 'continue' // start the leave process
        };

        node.transitionSubscription = usePresence(this.zone, node.element, startFn, options)
            .pipe(takeUntilDestroyed(this.destroyRef))
            .subscribe({
                complete: () => {
                    this.cleanupAfterLeave(node);
                }
            });
    }

    /**
     * Cleanup function called after leave animation finishes
     * @param node The node that is leaving
     */
    private cleanupAfterLeave(node: ContentNode): void {
        // check if this node is still marked as the one leaving
        if (this._leavingContentNode() === node) {
            this.removeNodeFromDOM(node);
            if (!this.forceMount() && node.embeddedView && !node.embeddedView.destroyed) {
                node.embeddedView.destroy();
                // Remove from cache if destroyed
                const newMap = new Map(this._contentNodes());
                newMap.delete(node.contentValue);
                this._contentNodes.set(newMap);
            }

            node.transitionSubscription = null;
            this._leavingContentNode.set(null);
        } else {
            // if this node is NOT the one currently marked as leaving, it means
            // a new transition started before this one finished. Just clean up DOM/Sub.
            this.removeNodeFromDOM(node);
            node.transitionSubscription?.unsubscribe();
            node.transitionSubscription = null;
        }
    }

    /**
     * Cancels an ongoing leave transition (e.g., if user hovers back)
     * @param node The node that is leaving
     */
    private cancelLeaveTransition(node: ContentNode): void {
        node.transitionSubscription?.unsubscribe();
        node.transitionSubscription = null;
    }

    /**
     * Force completes a leave transition (e.g., if another leave starts)
     * @param node The node that is leaving
     */
    private forceCompleteLeaveTransition(node: ContentNode): void {
        if (node && node.transitionSubscription) {
            node.transitionSubscription.unsubscribe();

            // perform cleanup immediately
            this.cleanupAfterLeave(node);
        }
    }

    private updateSize() {
        const activeNode = this._activeContentNode()?.element; // measure the currently active node
        if (!activeNode || !activeNode.isConnected) return;

        const firstChild = activeNode.firstChild as HTMLElement;
        if (!firstChild) return;

        this.window.requestAnimationFrame(() => {
            // keep rAF here for measurement stability
            activeNode.getBoundingClientRect(); // force layout
            const width = Math.ceil(firstChild.offsetWidth);
            const height = Math.ceil(firstChild.offsetHeight);

            if (width !== 0 || height !== 0) {
                const currentSize = this._viewportSize();
                if (!currentSize || currentSize.width !== width || currentSize.height !== height) {
                    this._viewportSize.set({ width, height });
                }
            } else if (this._viewportSize() !== null) {
                this._viewportSize.set(null);
            }
        });
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu.directive.ts
```typescript
import {
    booleanAttribute,
    Directive,
    effect,
    ElementRef,
    inject,
    Input,
    numberAttribute,
    OnDestroy,
    signal,
    WritableSignal
} from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { injectDocument, injectWindow } from '@radix-ng/primitives/core';
import { debounce, map, Subject, tap, timer } from 'rxjs';
import { provideNavigationMenuContext } from './navigation-menu.token';
import { RdxNavigationMenuAnimationStatus } from './navigation-menu.types';
import { generateId } from './utils';

// define action types for clearer intent
export enum RdxNavigationMenuAction {
    OPEN = 'open',
    CLOSE = 'close'
}

@Directive({
    selector: '[rdxNavigationMenu]',
    providers: [provideNavigationMenuContext(RdxNavigationMenuDirective)],
    host: {
        '[attr.data-orientation]': 'orientation',
        '[attr.dir]': 'dir',
        'aria-label': 'Main',
        role: 'navigation'
    },
    exportAs: 'rdxNavigationMenu'
})
export class RdxNavigationMenuDirective implements OnDestroy {
    private readonly elementRef = inject(ElementRef);
    private readonly document = injectDocument();
    private readonly window = injectWindow();

    // State
    readonly #value = signal<string>('');
    readonly #previousValue = signal<string>('');
    readonly baseId = `rdx-nav-menu-${generateId()}`;
    readonly #indicatorTrack = signal<HTMLElement | null>(null);
    readonly #viewport = signal<HTMLElement | null>(null);
    readonly #viewportContent = signal<Map<string, any>>(new Map());
    readonly #rootNavigationMenu = signal<HTMLElement | null>(this.elementRef.nativeElement);

    readonly #userDismissedByClick = signal(false);
    userDismissedByClick = () => this.#userDismissedByClick();
    resetUserDismissed = () => this.#userDismissedByClick.set(false);

    // delay timers
    private openTimerRef = 0;
    private closeTimerRef = 0;
    private skipDelayTimerRef = 0;
    readonly #isOpenDelayed = signal(true);

    // pointer tracking
    readonly #isPointerOverContent = signal(false);
    readonly #isPointerOverTrigger = signal(false);
    private documentMouseLeaveHandler: ((e: Event) => void) | null = null;

    readonly actionSubject$ = new Subject<{ action: RdxNavigationMenuAction; itemValue?: string }>();

    @Input() orientation: 'horizontal' | 'vertical' = 'horizontal';
    @Input() dir: 'ltr' | 'rtl' = 'ltr';
    @Input({ transform: numberAttribute }) delayDuration = 200;
    @Input({ transform: numberAttribute }) skipDelayDuration = 300;
    @Input({ transform: booleanAttribute }) loop = false;
    @Input({ transform: booleanAttribute }) cssAnimation = false;
    @Input({ transform: booleanAttribute }) cssOpeningAnimation = false;
    @Input({ transform: booleanAttribute }) cssClosingAnimation = false;

    readonly isRootMenu = true;
    readonly cssAnimationStatus: WritableSignal<RdxNavigationMenuAnimationStatus | null> = signal(null);

    // exposed state as functions for the token
    value = () => this.#value();
    previousValue = () => this.#previousValue();
    rootNavigationMenu = () => this.#rootNavigationMenu();
    indicatorTrack = () => this.#indicatorTrack();
    viewport = () => this.#viewport();
    viewportContent = () => this.#viewportContent();

    // exposed pointer state
    setTriggerPointerState = (isOver: boolean) => this.#isPointerOverTrigger.set(isOver);
    setContentPointerState = (isOver: boolean) => this.#isPointerOverContent.set(isOver);
    isPointerInSystem = () => this.#isPointerOverContent() || this.#isPointerOverTrigger();

    // exposed  animation state
    getCssAnimation = () => this.cssAnimation;
    getCssOpeningAnimation = () => this.cssOpeningAnimation;
    getCssClosingAnimation = () => this.cssClosingAnimation;

    constructor() {
        effect(() => {
            const value = this.#value();
            if (value) {
                this.window.clearTimeout(this.skipDelayTimerRef);
                if (this.skipDelayDuration > 0) {
                    this.#isOpenDelayed.set(false);
                }
            } else {
                // menu is closed, start skip delay timer
                this.window.clearTimeout(this.skipDelayTimerRef);
                this.skipDelayTimerRef = this.window.setTimeout(() => {
                    this.#isOpenDelayed.set(true);
                }, this.skipDelayDuration);
            }
        });

        this.actionSubject$
            .pipe(
                map((config) => {
                    // different delays for open vs close (better ux)
                    const duration = config.action === RdxNavigationMenuAction.OPEN ? this.delayDuration : 150;
                    return { ...config, duration };
                }),
                debounce((config) => timer(config.duration)),
                tap((config) => {
                    switch (config.action) {
                        case RdxNavigationMenuAction.OPEN:
                            if (config.itemValue) {
                                this.setValue(config.itemValue);
                            }
                            break;
                        case RdxNavigationMenuAction.CLOSE:
                            // only close if not hovering over any part of the system
                            if (!this.isPointerInSystem()) {
                                this.setValue('');
                            }
                            break;
                    }
                }),
                takeUntilDestroyed()
            )
            .subscribe();

        // set up document mouseleave handler to close menu when mouse leaves window
        this.documentMouseLeaveHandler = () => this.handleClose();
        this.document.addEventListener('mouseleave', this.documentMouseLeaveHandler);
    }

    ngOnDestroy() {
        this.window.clearTimeout(this.openTimerRef);
        this.window.clearTimeout(this.closeTimerRef);
        this.window.clearTimeout(this.skipDelayTimerRef);

        // clean up document event listener
        if (this.documentMouseLeaveHandler) {
            document.removeEventListener('mouseleave', this.documentMouseLeaveHandler);
        }
    }

    onIndicatorTrackChange(track: HTMLElement | null) {
        this.#indicatorTrack.set(track);
    }

    onViewportChange(viewport: HTMLElement | null) {
        this.#viewport.set(viewport);
    }

    onTriggerEnter(itemValue: string) {
        // skip opening if user explicitly dismissed this menu
        if (this.#userDismissedByClick() && itemValue === this.#previousValue()) {
            return;
        }

        this.window.clearTimeout(this.openTimerRef);
        this.window.clearTimeout(this.closeTimerRef);

        if (this.#isOpenDelayed()) {
            this.handleDelayedOpen(itemValue);
        } else {
            this.handleOpen(itemValue);
        }
    }

    onTriggerLeave() {
        this.window.clearTimeout(this.openTimerRef);
        this.startCloseTimer();
    }

    onContentEnter() {
        this.window.clearTimeout(this.closeTimerRef);
    }

    onContentLeave() {
        this.startCloseTimer();
    }

    handleClose() {
        this.actionSubject$.next({ action: RdxNavigationMenuAction.CLOSE });
    }

    onItemSelect(itemValue: string) {
        const wasOpen = this.#value() === itemValue;
        const newValue = wasOpen ? '' : itemValue;

        // if user is closing an open menu, mark as user-dismissed
        if (wasOpen) {
            this.#userDismissedByClick.set(true);
        } else {
            this.#userDismissedByClick.set(false);
        }

        this.setValue(newValue);
    }

    onItemDismiss() {
        this.setValue('');
    }

    onViewportContentChange(contentValue: string, contentData: any) {
        const newMap = new Map(this.#viewportContent());
        newMap.set(contentValue, contentData);
        this.#viewportContent.set(newMap);
    }

    onViewportContentRemove(contentValue: string) {
        const newMap = new Map(this.#viewportContent());
        if (newMap.has(contentValue)) {
            newMap.delete(contentValue);
            this.#viewportContent.set(newMap);
        }
    }

    private setValue(value: string) {
        // Store previous value before changing
        this.#previousValue.set(this.#value());
        this.#value.set(value);
    }

    private startCloseTimer() {
        this.window.clearTimeout(this.closeTimerRef);
        this.closeTimerRef = this.window.setTimeout(() => {
            // only close if not hovering over any part of the system
            if (!this.isPointerInSystem()) {
                this.setValue('');
            }
        }, 150);
    }

    private handleOpen(itemValue: string) {
        this.window.clearTimeout(this.closeTimerRef);
        this.setValue(itemValue);
    }

    private handleDelayedOpen(itemValue: string) {
        const isOpenItem = this.#value() === itemValue;
        if (isOpenItem) {
            // if the item is already open, clear close timer
            this.window.clearTimeout(this.closeTimerRef);
        } else {
            // otherwise, start the open timer
            this.openTimerRef = this.window.setTimeout(() => {
                this.window.clearTimeout(this.closeTimerRef);
                this.setValue(itemValue);
            }, this.delayDuration);
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu.token.ts
```typescript
import { inject, InjectionToken, Provider, Type } from '@angular/core';
import { RdxNavigationMenuSubDirective } from './navigation-menu-sub.directive';
import { RdxNavigationMenuDirective } from './navigation-menu.directive';

export interface NavigationMenuContext {
    isRootMenu: boolean;
    value: () => string;
    previousValue: () => string;
    baseId: string;
    dir: 'ltr' | 'rtl';
    orientation: 'horizontal' | 'vertical';
    loop: boolean;
    rootNavigationMenu: () => HTMLElement | null;

    indicatorTrack?: () => HTMLElement | null;
    onIndicatorTrackChange?: (track: HTMLElement | null) => void;
    userDismissedByClick?: () => boolean;
    resetUserDismissed?: () => void;
    viewport?: () => HTMLElement | null;
    onViewportChange?: (viewport: HTMLElement | null) => void;
    viewportContent?: () => Map<string, any>;
    onViewportContentChange?: (contentValue: string, contentData: any) => void;
    onViewportContentRemove?: (contentValue: string) => void;
    onTriggerEnter?: (itemValue: string) => void;
    onTriggerLeave?: () => void;
    onContentEnter?: () => void;
    onContentLeave?: () => void;
    onItemSelect?: (itemValue: string) => void;
    onItemDismiss?: () => void;
    handleClose?: (force?: boolean) => void;
    setTriggerPointerState?: (isOver: boolean) => void;
    setContentPointerState?: (isOver: boolean) => void;
    isPointerInSystem?: () => boolean;
}

export const RDX_NAVIGATION_MENU_TOKEN = new InjectionToken<NavigationMenuContext>('RdxNavigationMenuToken');

export function injectNavigationMenu(): NavigationMenuContext {
    return inject(RDX_NAVIGATION_MENU_TOKEN);
}

export function isRootNavigationMenu(context: NavigationMenuContext): boolean {
    return context.isRootMenu;
}

export function provideNavigationMenuContext(
    provider: Type<RdxNavigationMenuDirective | RdxNavigationMenuSubDirective>
): Provider {
    return {
        provide: RDX_NAVIGATION_MENU_TOKEN,
        useExisting: provider
    };
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/navigation-menu.types.ts
```typescript
import { FocusableOption } from '@angular/cdk/a11y';

export enum RdxNavigationMenuAnimationStatus {
    OPEN_STARTED = 'open_started',
    OPEN_ENDED = 'open_ended',
    CLOSED_STARTED = 'closed_started',
    CLOSED_ENDED = 'closed_ended'
}

/**
 * A stub class solely used to query a single type of focusable element in the navigation menu.
 */
export abstract class RdxNavigationMenuFocusableOption implements FocusableOption {
    focus(): void {
        throw new Error('Method not implemented.');
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/navigation-menu/src/utils.ts
```typescript
export type NavigationMenuOrientation = 'horizontal' | 'vertical';
export type NavigationMenuDirection = 'ltr' | 'rtl';
export type MotionAttribute = 'to-start' | 'to-end' | 'from-start' | 'from-end';

export const ROOT_CONTENT_DISMISS = 'navigationMenu.rootContentDismiss';

/**
 * Generate a unique ID
 */
export function generateId(): string {
    return Math.random().toString(36).substring(2, 11);
}

/**
 * Get the open state for data-state attribute
 */
export function getOpenStateLabel(open: boolean): 'open' | 'closed' {
    return open ? 'open' : 'closed';
}

/**
 * Create a trigger ID from base ID and value
 */
export function makeTriggerId(baseId: string, value: string): string {
    return `${baseId}-trigger-${value}`;
}

/**
 * Create a content ID from base ID and value
 */
export function makeContentId(baseId: string, value: string): string {
    return `${baseId}-content-${value}`;
}

/**
 * Get the motion attribute for animations
 */
export function getMotionAttribute(
    currentValue: string | null,
    previousValue: string | null,
    itemValue: string,
    itemValues: string[],
    dir: NavigationMenuDirection
): MotionAttribute | null {
    // reverse values in RTL
    const values = dir === 'rtl' ? [...itemValues].reverse() : itemValues;

    const currentIndex = currentValue !== null ? values.indexOf(currentValue) : -1;
    const prevIndex = previousValue !== null ? values.indexOf(previousValue) : -1;

    const isSelected = itemValue === currentValue;
    const wasSelected = itemValue === previousValue && previousValue !== null;

    // Preserve motion attribute for items not directly involved in the transition
    // (This matches React's behaviour, using a ref/signal might be needed
    // in the component using this function to fully replicate React's prevMotionAttributeRef)
    // For now, returning null if not involved, as per the original code's intent here.
    if (!isSelected && !wasSelected) {
        return null;
    }

    // handle transitions between items
    if (currentIndex !== -1 && prevIndex !== -1) {
        // if moving to this item (isSelected)
        if (isSelected) {
            return currentIndex > prevIndex ? 'from-end' : 'from-start';
        }
        // if moving away from this item (wasSelected)
        if (wasSelected) {
            return currentIndex > prevIndex ? 'to-start' : 'to-end';
        }
    }

    // handle initial open (prevIndex is -1, currentIndex is valid)
    if (isSelected && prevIndex === -1) {
        return null;
    }

    // handle closing entirely (currentIndex is -1, prevIndex is valid)
    if (wasSelected && currentIndex === -1) {
        return null;
    }

    // fallback if none of the above conditions met (should ideally not happen with clear states)
    return null;
}

/**
 * Focus the first element in a list of candidates
 * @param candidates Array of elements that can receive focus
 * @param preventScroll Whether to prevent scrolling when focusing
 * @param activateKeyboardNav Whether to dispatch a dummy keydown event to activate keyboard navigation handlers
 * @returns Whether focus was successfully moved
 */
export function focusFirst(candidates: HTMLElement[], preventScroll = false, activateKeyboardNav = true): boolean {
    const prevFocusedElement = document.activeElement;

    // sort candidates by tabindex to ensure proper order
    const sortedCandidates = [...candidates].sort((a, b) => {
        const aIndex = a.tabIndex || 0;
        const bIndex = b.tabIndex || 0;
        return aIndex - bIndex;
    });

    const success = sortedCandidates.some((candidate) => {
        // if focus is already where we want it, do nothing
        if (candidate === prevFocusedElement) return true;

        try {
            candidate.focus({ preventScroll });
            return document.activeElement !== prevFocusedElement;
        } catch (e) {
            console.error('Error focusing element:', e);
            return false;
        }
    });

    // if focus was moved successfully and we want to activate keyboard navigation,
    // dispatch a dummy keypress to ensure keyboard handlers are activated
    if (success && activateKeyboardNav && document.activeElement !== prevFocusedElement) {
        try {
            // dispatch a no-op keydown event to activate any keyboard handlers
            document.activeElement?.dispatchEvent(
                new KeyboardEvent('keydown', {
                    bubbles: true,
                    cancelable: true,
                    key: 'Tab',
                    code: 'Tab'
                })
            );
        } catch (e) {
            console.error('Error dispatching keyboard event:', e);
        }
    }

    return success;
}

/**
 * Get all tabbable candidates in a container
 */
export function getTabbableCandidates(container: HTMLElement): HTMLElement[] {
    if (!container || !container.querySelectorAll) return [];

    const TABBABLE_SELECTOR =
        'a[href], button:not([disabled]), input:not([disabled]):not([type="hidden"]), ' +
        'select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"]), ' +
        '[contenteditable="true"]:not([tabindex="-1"])';

    // use querySelector for better browser support
    const elements = Array.from(container.querySelectorAll(TABBABLE_SELECTOR)) as HTMLElement[];

    // filter out elements that are hidden, have display:none, etc.
    return elements.filter((element) => {
        if (element.tabIndex < 0) return false;
        if (element.hasAttribute('disabled')) return false;
        if (element.hasAttribute('aria-hidden') && element.getAttribute('aria-hidden') === 'true') return false;

        // Check if element or any parent is hidden
        let current: HTMLElement | null = element;
        while (current) {
            const style = window.getComputedStyle(current);
            if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') {
                return false;
            }
            current = current.parentElement;
        }

        return true;
    });
}

/**
 * Remove elements from tab order and return a function to restore them
 */
export function removeFromTabOrder(candidates: HTMLElement[]): () => void {
    const originalValues = new Map<HTMLElement, string | null>();

    candidates.forEach((candidate) => {
        // Store original tabindex
        originalValues.set(candidate, candidate.getAttribute('tabindex'));

        // Set to -1 to remove from tab order
        candidate.setAttribute('tabindex', '-1');
    });

    // Return restore function
    return () => {
        candidates.forEach((candidate) => {
            const originalValue = originalValues.get(candidate);
            if (originalValue == null) {
                candidate.removeAttribute('tabindex');
            } else {
                candidate.setAttribute('tabindex', originalValue);
            }
        });
    };
}

/**
 * Wrap array around itself at given start index
 */
export function wrapArray<T>(array: T[], startIndex: number): T[] {
    return array.map((_, index) => array[(startIndex + index) % array.length]);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menubar/README.md
```
# @radix-ng/primitives/menubar

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menubar/index.ts
```typescript
import { NgModule } from '@angular/core';
import { RdxMenuBarContentDirective } from './src/menubar-content.directive';
import { RdxMenubarItemCheckboxDirective } from './src/menubar-item-checkbox.directive';
import { RdxMenubarItemIndicatorDirective } from './src/menubar-item-indicator.directive';
import { RdxMenubarItemRadioDirective } from './src/menubar-item-radio.directive';
import { RdxMenuBarItemDirective } from './src/menubar-item.directive';
import { RdxMenubarRadioGroupDirective } from './src/menubar-radio-group.directive';
import { RdxMenuBarRootDirective } from './src/menubar-root.directive';
import { RdxMenubarSeparatorDirective } from './src/menubar-separator.directive';
import { RdxMenuBarTriggerDirective } from './src/menubar-trigger.directive';

export * from './src/menubar-content.directive';
export * from './src/menubar-item-checkbox.directive';
export * from './src/menubar-item-indicator.directive';
export * from './src/menubar-item-radio.directive';
export * from './src/menubar-item.directive';
export * from './src/menubar-radio-group.directive';
export * from './src/menubar-root.directive';
export * from './src/menubar-separator.directive';
export * from './src/menubar-trigger.directive';

const menubarImports = [
    RdxMenuBarContentDirective,
    RdxMenuBarTriggerDirective,
    RdxMenubarSeparatorDirective,
    RdxMenubarItemCheckboxDirective,
    RdxMenuBarRootDirective,
    RdxMenuBarItemDirective,
    RdxMenubarItemIndicatorDirective,
    RdxMenubarItemRadioDirective,
    RdxMenubarRadioGroupDirective
];

@NgModule({
    imports: [...menubarImports],
    exports: [...menubarImports]
})
export class MenubarModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menubar/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menubar/stories/menubar.docs.mdx
````
import {ArgTypes, Canvas, Markdown, Meta} from "@storybook/blocks";
import * as MenubarStories from "./menubar.stories";
import {RdxMenuTriggerDirective} from "../../menu";

<Meta title="Primitives/Menubar" />

# Menu Bar

#### A visually persistent menu common in desktop applications that provides quick access to a consistent set of commands.

<Canvas sourceState="hidden" of={MenubarStories.Default} />

## Features

- âœ… Can be controlled or uncontrolled.
- âœ… Supports submenus.
- âœ… Supports items, labels, groups of items.
- âœ… Supports checkable items (single or multiple).
- âœ… Customize side, alignment, offsets.
- âœ… Focus is fully managed.
- âœ… Full keyboard navigation.

## Anatomy

```html
<div rdxMenuBarRoot>
    <div
        rdxMenuBarItem
        rdxMenuBarTrigger
        [menuTriggerFor]="file"
    >
        File
    </div>
</div>

<ng-template #file>
    <div rdxMenuBarContent>
        <div rdxMenuBarItem>New Tab</div>
        <div rdxMenubarSeparator></div>
        <div rdxMenuBarItem rdxMenuBarTrigger [menuTriggerFor]="share">
            Share
        </div>
        <div rdxMenubarSeparator></div>
        <div rdxMenuBarItem>Printâ€¦</div>
    </div>
</ng-template>

<ng-template #share>
    <div rdxMenuBarContent>
        <div rdxMenuBarItem>Undo</div>
        <div rdxMenuBarItem>Redo</div>
        <div rdxMenubarSeparator></div>
        <div rdxMenuBarItem>Cut</div>
        <div rdxMenuBarItem>Copy</div>
        <div rdxMenuBarItem>Paste</div>
    </div>
</ng-template>
```

## API Reference

### Root
Contains all the parts of a menubar and extend `CdkMenuBar`.


### Trigger
The button that toggles the content. By default, the `Content` will position itself against the trigger.

<ArgTypes of={RdxMenuTriggerDirective}/>

<Markdown>
    {`
| Data attribute | Value          |
|----------------|----------------|
| [data-state]   | <code>"closed" or "open"</code> |
| [data-highlighted]   | Present when highlighted |
| [data-disabled]   | Present when disabled |
`}
</Markdown>

### Content
The component that pops out when a menu is open.

### Item
The component that contains the menubar items.

### Group
Used to group multiple `Items`.

### Label
Used to render a label. It won't be focusable using arrow keys.

### CheckboxItem
An item that can be controlled and rendered like a checkbox.

<Markdown>
    {`
| Data attribute | Value          |
|----------------|----------------|
| [data-state]   | <code>"closed" or "open"</code> |
| [data-highlighted]   | Present when highlighted |
| [data-disabled]   | Present when disabled |
`}
</Markdown>


### RadioGroup
Used to group multiple `RadioItems`.

### ItemIndicator
Renders when the parent `CheckboxItem` or `RadioItem` is checked.
You can style this element directly, or you can use it as a wrapper to put an icon into, or both.

<Markdown>
    {`
| Data attribute | Value          |
|----------------|----------------|
| [data-state]   | <code>"checked" or "unchecked"</code> |
`}
</Markdown>

### Separator
Used to visually separate items in a menubar menu.


## Accessibility
Adheres to the [Menu Button WAI-ARIA design pattern](https://www.w3.org/WAI/ARIA/apg/patterns/menu-button/) and uses [roving tabindex](https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_roving_tabindex)
to manage focus movement among menu items.


````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menubar/stories/menubar.stories.ts
```typescript
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { Check, Dot, LucideAngularModule } from 'lucide-angular';
import { MenubarModule } from '../index';

const html = String.raw;

export default {
    title: 'Primitives/Menubar',
    decorators: [
        moduleMetadata({
            imports: [MenubarModule, LucideAngularModule, LucideAngularModule.pick({ Check, Dot })]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div
                    class="radix-themes light light-theme radix-themes-default-fonts rt-Flex rt-r-ai-start rt-r-jc-center rt-r-position-relative"
                    data-accent-color="indigo"
                    data-radius="medium"
                    data-scaling="100%"
                >
                    ${story}
                </div>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: html`
            <div class="MenubarRoot" RdxMenuBarRoot>
                <div
                    class="MenubarTrigger"
                    RdxMenuBarItem
                    RdxMenuBarTrigger
                    align="start"
                    sideOffset="5"
                    alignOffset="-3"
                    [menuTriggerFor]="file"
                >
                    File
                </div>
                <div
                    class="MenubarTrigger"
                    align="start"
                    sideOffset="5"
                    alignOffset="-3"
                    RdxMenuBarItem
                    RdxMenuBarTrigger
                    [menuTriggerFor]="edit"
                >
                    Edit
                </div>
                <div
                    class="MenubarTrigger"
                    align="start"
                    sideOffset="5"
                    alignOffset="-3"
                    RdxMenuBarItem
                    RdxMenuBarTrigger
                    [menuTriggerFor]="view"
                >
                    View
                </div>
                <div
                    class="MenubarTrigger"
                    align="start"
                    sideOffset="5"
                    alignOffset="-3"
                    RdxMenuBarItem
                    RdxMenuBarTrigger
                    [menuTriggerFor]="profiles"
                >
                    Profiles
                </div>
            </div>

            <ng-template #file>
                <div class="MenubarContent" RdxMenuBarContent>
                    <div class="MenubarItem" RdxMenuBarItem>
                        New Tab
                        <div class="RightSlot">âŒ˜ T</div>
                    </div>
                    <div class="MenubarItem" RdxMenuBarItem>
                        New Window
                        <div class="RightSlot">âŒ˜ N</div>
                    </div>
                    <div class="MenubarItem" RdxMenuBarItem disabled>New Incognito Window</div>
                    <div class="MenubarSeparator" RdxMenuBarSeparator></div>
                    <div class="MenubarItem" RdxMenuBarItem RdxMenuBarTrigger [menuTriggerFor]="share">
                        Share
                        <div class="RightSlot">></div>
                    </div>
                    <div class="MenubarSeparator" RdxMenuBarSeparator></div>
                    <div class="MenubarItem" RdxMenuBarItem>
                        Printâ€¦
                        <div class="RightSlot">âŒ˜ P</div>
                    </div>
                </div>
            </ng-template>

            <ng-template #profiles>
                <div class="MenubarContent" RdxMenuBarContent>
                    <div RdxMenuBarRadioGroup>
                        <div class="MenubarRadioItem inset" RdxMenuBarItemRadio>
                            <lucide-icon
                                class="MenubarItemIndicator"
                                size="16"
                                strokeWidth="5"
                                RdxMenuBarItemIndicator
                                name="dot"
                            />
                            Andy
                        </div>
                        <div class="MenubarRadioItem inset" RdxMenuBarItemRadio checked>
                            <lucide-icon
                                class="MenubarItemIndicator"
                                size="16"
                                strokeWidth="5"
                                RdxMenuBarItemIndicator
                                name="dot"
                            />
                            Luis
                        </div>
                    </div>
                    <div class="MenubarSeparator" RdxMenuBarSeparator></div>
                    <div class="MenubarItem inset" RdxMenuBarItem>Edit</div>
                </div>
            </ng-template>

            <ng-template #view>
                <div class="MenubarContent" RdxMenuBarContent>
                    <div class="MenubarCheckboxItem inset" RdxMenuBarCheckboxItem>
                        <lucide-icon class="MenubarItemIndicator" RdxMenuBarItemIndicator size="16" name="check" />
                        Always Show Bookmarks Bar
                    </div>
                    <div class="MenubarCheckboxItem inset" RdxMenuBarCheckboxItem [checked]="true">
                        <lucide-icon class="MenubarItemIndicator" RdxMenuBarItemIndicator size="16" name="check" />
                        Always Show Full URLs
                    </div>
                    <div class="MenubarSeparator" RdxMenuBarSeparator></div>
                    <div class="MenubarItem inset" RdxMenuBarItem>
                        Reload
                        <div class="RightSlot">âŒ˜ R</div>
                    </div>
                    <div class="MenubarItem inset" RdxMenuBarItem disabled>
                        Force Reload
                        <div class="RightSlot">â‡§ âŒ˜ R</div>
                    </div>
                    <div class="MenubarSeparator" RdxMenuBarSeparator></div>
                    <div class="MenubarItem inset" RdxMenuBarItem>Toggle Fullscreen</div>
                    <div class="MenubarSeparator" RdxMenuBarSeparator></div>
                    <div class="MenubarItem inset" RdxMenuBarItem>Hide Sidebar</div>
                </div>
            </ng-template>

            <ng-template #edit>
                <div class="MenubarContent" RdxMenuBarContent>
                    <div class="MenubarItem" RdxMenuBarItem>
                        Undo
                        <div class="RightSlot">âŒ˜ Z</div>
                    </div>
                    <div class="MenubarItem" RdxMenuBarItem>
                        Redo
                        <div class="RightSlot">â‡§ âŒ˜ Z</div>
                    </div>
                    <div class="MenubarSeparator" RdxMenuBarSeparator></div>
                    <div class="MenubarItem" RdxMenuBarItem>Cut</div>
                    <div class="MenubarItem" RdxMenuBarItem>Copy</div>
                    <div class="MenubarItem" RdxMenuBarItem>Paste</div>
                </div>
            </ng-template>

            <ng-template #share>
                <div class="MenubarSubContent" RdxMenuBarContent>
                    <div class="MenubarItem" RdxMenuBarItem>Undo</div>
                    <div class="MenubarItem" RdxMenuBarItem>Redo</div>
                    <div class="MenubarSeparator" RdxMenuBarSeparator></div>
                    <div class="MenubarItem" RdxMenuBarItem>Cut</div>
                    <div class="MenubarItem" RdxMenuBarItem>Copy</div>
                    <div class="MenubarItem" RdxMenuBarItem>Paste</div>
                </div>
            </ng-template>

            <style>
                /* reset */
                button {
                    all: unset;
                }

                .MenubarRoot {
                    display: flex;
                    background-color: white;
                    padding: 3px;
                    border-radius: 6px;
                    box-shadow: 0 2px 10px var(--black-a7);
                }

                .MenubarTrigger {
                    padding: 8px 12px;
                    outline: none;
                    user-select: none;
                    font-weight: 500;
                    line-height: 1;
                    border-radius: 4px;
                    color: var(--violet-11);
                    font-size: 13px;
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    gap: 2px;
                }

                .MenubarTrigger[data-highlighted],
                .MenubarTrigger[data-state='open'] {
                    background-color: var(--violet-4);
                }

                .MenubarContent,
                .MenubarSubContent {
                    min-width: 220px;
                    background-color: white;
                    border-radius: 6px;
                    padding: 5px;
                    box-shadow:
                        0px 10px 38px -10px rgba(22, 23, 24, 0.35),
                        0px 10px 20px -15px rgba(22, 23, 24, 0.2);
                    animation-duration: 400ms;
                    animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
                    will-change: transform, opacity;
                }

                .MenubarItem,
                .MenubarSubTrigger,
                .MenubarCheckboxItem,
                .MenubarRadioItem {
                    all: unset;
                    font-size: 13px;
                    line-height: 1;
                    color: var(--violet-11);
                    border-radius: 4px;
                    display: flex;
                    align-items: center;
                    height: 25px;
                    padding: 0 10px;
                    position: relative;
                    user-select: none;
                }

                .MenubarItem.inset,
                .MenubarSubTrigger.inset,
                .MenubarCheckboxItem.inset,
                .MenubarRadioItem.inset {
                    padding-left: 20px;
                }

                .MenubarItem[data-state='open'],
                .MenubarSubTrigger[data-state='open'] {
                    background-color: var(--violet-4);
                    color: var(--violet-11);
                }

                .MenubarItem[data-highlighted],
                .MenubarSubTrigger[data-highlighted],
                .MenubarCheckboxItem[data-highlighted],
                .MenubarRadioItem[data-highlighted] {
                    background-image: linear-gradient(135deg, var(--violet-9) 0%, var(--violet-10) 100%);
                    color: var(--violet-1);
                }

                .MenubarItem[data-disabled],
                .MenubarSubTrigger[data-disabled],
                .MenubarCheckboxItem[data-disabled],
                .MenubarRadioItem[data-disabled] {
                    color: var(--mauve-8);
                    pointer-events: none;
                }

                .MenubarItemIndicator {
                    position: absolute;
                    left: 0;
                    width: 20px;
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                }

                .MenubarSeparator {
                    height: 1px;
                    background-color: var(--violet-6);
                    margin: 5px;
                }

                .RightSlot {
                    margin-left: auto;
                    padding-left: 20px;
                    color: var(--mauve-9);
                }

                [data-highlighted] > .RightSlot {
                    color: white;
                }

                [data-disabled] > .RightSlot {
                    color: var(--mauve-8);
                }
            </style>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menubar/src/menubar-content.directive.ts
```typescript
import { Directive } from '@angular/core';
import { RdxMenuContentDirective } from '@radix-ng/primitives/menu';

@Directive({
    selector: '[RdxMenuBarContent]',
    hostDirectives: [RdxMenuContentDirective]
})
export class RdxMenuBarContentDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menubar/src/menubar-group.directive.ts
```typescript
import { Directive } from '@angular/core';
import { RdxMenuGroupDirective } from '@radix-ng/primitives/menu';

@Directive({
    selector: '[RdxMenuBarGroup]',
    hostDirectives: [RdxMenuGroupDirective]
})
export class RdxMenubarGroupDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menubar/src/menubar-item-checkbox.directive.ts
```typescript
import { Directive } from '@angular/core';
import { RdxMenuItemCheckboxDirective } from '@radix-ng/primitives/menu';

@Directive({
    selector: '[RdxMenuBarCheckboxItem]',
    hostDirectives: [
        {
            directive: RdxMenuItemCheckboxDirective,
            inputs: ['checked', 'disabled']
        }
    ]
})
export class RdxMenubarItemCheckboxDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menubar/src/menubar-item-indicator.directive.ts
```typescript
import { Directive } from '@angular/core';
import { RdxMenuItemIndicatorDirective } from '@radix-ng/primitives/menu';

@Directive({
    selector: '[RdxMenuBarItemIndicator]',
    hostDirectives: [RdxMenuItemIndicatorDirective]
})
export class RdxMenubarItemIndicatorDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menubar/src/menubar-item-radio.directive.ts
```typescript
import { Directive } from '@angular/core';
import { RdxMenuItemRadioDirective } from '@radix-ng/primitives/menu';

@Directive({
    selector: '[RdxMenuBarItemRadio]',
    hostDirectives: [
        {
            directive: RdxMenuItemRadioDirective,
            inputs: ['disabled', 'checked']
        }
    ]
})
export class RdxMenubarItemRadioDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menubar/src/menubar-item.directive.ts
```typescript
import { Directive } from '@angular/core';
import { RdxMenuItemDirective } from '@radix-ng/primitives/menu';

@Directive({
    selector: '[RdxMenuBarItem]',
    hostDirectives: [
        {
            directive: RdxMenuItemDirective,
            inputs: ['disabled'],
            outputs: ['onSelect']
        }
    ]
})
export class RdxMenuBarItemDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menubar/src/menubar-radio-group.directive.ts
```typescript
import { CdkMenuGroup } from '@angular/cdk/menu';
import { Directive } from '@angular/core';

@Directive({
    selector: '[RdxMenuBarRadioGroup]',
    hostDirectives: [CdkMenuGroup]
})
export class RdxMenubarRadioGroupDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menubar/src/menubar-root.directive.ts
```typescript
import { CdkMenuBar } from '@angular/cdk/menu';
import { Directive } from '@angular/core';

@Directive({
    selector: '[RdxMenuBarRoot]',
    hostDirectives: [CdkMenuBar],
    host: {
        tabindex: '0',
        '[attr.data-orientation]': '"horizontal"'
    }
})
export class RdxMenuBarRootDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menubar/src/menubar-separator.directive.ts
```typescript
import { Directive } from '@angular/core';
import { RdxMenuSeparatorDirective } from '@radix-ng/primitives/menu';

@Directive({
    selector: '[RdxMenuBarSeparator]',
    hostDirectives: [RdxMenuSeparatorDirective]
})
export class RdxMenubarSeparatorDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menubar/src/menubar-trigger.directive.ts
```typescript
import { Directive } from '@angular/core';
import { RdxMenuTriggerDirective } from '@radix-ng/primitives/menu';

@Directive({
    selector: '[RdxMenuBarTrigger]',
    hostDirectives: [
        {
            directive: RdxMenuTriggerDirective,
            inputs: [
                'disabled',
                'menuTriggerFor',
                'sideOffset',
                'side',
                'align',
                'alignOffset'
            ]
        }
    ]
})
export class RdxMenuBarTriggerDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/progress/README.md
```
# @radix-ng/primitives/progress

Secondary entry point of `@radix-ng/primitives`.

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/progress/index.ts
```typescript
import { NgModule } from '@angular/core';
import { RdxProgressIndicatorDirective } from './src/progress-indicator.directive';
import { RdxProgressRootDirective } from './src/progress-root.directive';

export * from './src/progress-indicator.directive';
export * from './src/progress-root.directive';

export type { ProgressProps } from './src/progress-root.directive';

const _imports = [
    RdxProgressRootDirective,
    RdxProgressIndicatorDirective
];

@NgModule({
    imports: [..._imports],
    exports: [..._imports]
})
export class RdxProgressModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/progress/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/progress/__test__/progress.spec.ts
```typescript
import { Component } from '@angular/core';
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { RdxProgressIndicatorDirective } from '../src/progress-indicator.directive';
import { RdxProgressRootDirective } from '../src/progress-root.directive';

@Component({
    template: `
        <div [id]="id" [value]="value" [max]="max" rdxProgressRoot>
            <div rdxProgressIndicator></div>
        </div>
    `,
    imports: [RdxProgressRootDirective, RdxProgressIndicatorDirective]
})
class TestHostComponent {
    value = 50;
    max = 100;
    id = 'test-progress';
}

describe('RdxProgress', () => {
    let component: TestHostComponent;
    let fixture: ComponentFixture<TestHostComponent>;

    beforeEach(async () => {
        await TestBed.configureTestingModule({
            imports: [TestHostComponent]
        }).compileComponents();

        fixture = TestBed.createComponent(TestHostComponent);
        component = fixture.componentInstance;
        fixture.detectChanges();
    });

    it('should set the correct aria attributes and data attributes', () => {
        const progressElement: HTMLElement = fixture.nativeElement.querySelector('div[role="progressbar"]');

        expect(progressElement.getAttribute('aria-valuemax')).toBe('100');
        expect(progressElement.getAttribute('aria-valuemin')).toBe('0');
        expect(progressElement.getAttribute('aria-valuenow')).toBe('50');
        expect(progressElement.getAttribute('aria-valuetext')).toBe('50%');
        expect(progressElement.getAttribute('data-state')).toBe('loading');
        expect(progressElement.getAttribute('data-value')).toBe('50');
        expect(progressElement.getAttribute('data-max')).toBe('100');
        expect(progressElement.id).toBe('test-progress');
    });

    it('should show complete state when value equals max', () => {
        component.value = 100;
        fixture.detectChanges();

        const progressElement: HTMLElement = fixture.nativeElement.querySelector('div[role="progressbar"]');

        expect(progressElement.getAttribute('data-state')).toBe('complete');
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/progress/stories/progress-circular.ts
```typescript
import { Component, computed, effect, signal } from '@angular/core';
import { RdxProgressIndicatorDirective } from '../src/progress-indicator.directive';
import { RdxProgressRootDirective } from '../src/progress-root.directive';

@Component({
    selector: 'progress-circular',
    imports: [RdxProgressRootDirective, RdxProgressIndicatorDirective],
    template: `
        <div class="progress-container">
            <div [value]="progress()" rdxProgressRoot>
                <svg class="svg-full" viewBox="0 0 100 100">
                    <!-- Background circle -->
                    <path class="circle-track" [attr.d]="trackPath()" />
                    <!-- Progress circle -->
                    <path
                        class="circle-progress"
                        [attr.d]="trackPath()"
                        [style.stroke-linecap]="'round'"
                        [style.stroke-dasharray]="dashOffset() + 'px, ' + circumference + 'px'"
                        [style.stroke-dashoffset]="'0px'"
                        rdxProgressIndicator
                    />
                </svg>
                <div class="progress-center">
                    <span class="progress-text">{{ progress() }}%</span>
                </div>
            </div>
        </div>
    `,
    styles: [
        `
            .progress-container {
                position: relative;
                width: 160px;
                height: 160px;
            }

            .svg-full {
                width: 100%;
                height: 100%;
            }

            .circle-track {
                fill: none;
                stroke: #e0e0e0;
                stroke-width: 6px;
            }

            .circle-progress {
                fill: none;
                stroke: black;
                stroke-width: 6px;
                transition:
                    stroke-dasharray 0.7s,
                    opacity 0.7s;
            }

            .progress-center {
                position: absolute;
                top: 0;
                right: 0;
                bottom: 0;
                left: 0;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .progress-text {
                font-size: 1.125rem;
                font-weight: bold;
                color: #333;
            }
        `

    ]
})
export class ProgressCircularComponent {
    private readonly RADIUS = 45;
    protected readonly circumference = 2 * Math.PI * this.RADIUS;

    progress = signal<number>(0);

    readonly dashOffset = computed(() => (this.progress() / 100) * this.circumference);

    trackPath = computed(() => {
        const r = this.RADIUS;
        return `
          M 50 50
          m 0 -${r}
          a ${r} ${r} 0 1 1 0 ${r * 2}
          a ${r} ${r} 0 1 1 0 -${r * 2}
          `;
    });

    constructor() {
        effect(() => {
            setInterval(() => {
                if (this.progress() < 100) {
                    this.progress.update((value) => value + 10);
                } else {
                    this.progress.set(0);
                }
            }, 1000);
        });
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/progress/stories/progress.docs.mdx
````
import { ArgTypes, Canvas, Markdown, Meta } from '@storybook/blocks';
import { RdxProgressRootDirective } from '../src/progress-root.directive';
import * as ProgressDirectiveStories from './progress.stories';

<Meta title="Primitives/Progress" />

# Progress

#### Displays an indicator showing the completion progress of a task, typically displayed as a progress bar.

<Canvas sourceState="hidden" of={ProgressDirectiveStories.Default} />

## Features

- âœ… Provides context for assistive technology to read the progress of a task.

## Usage

Get started with importing the directive:

```typescript
import { RdxProgressRootDirective, RdxProgressIndicatorDirective } from '@radix-ng/primitives/progress';
```

## Example

```html
<div class="ProgressRoot" rdxProgressRoot [value]="progress">
  <div class="ProgressIndicator" rdxProgressIndicator [style.transform]="'translateX(-' + (100 - progress) +'%)'"></div>
</div>
```

## API Reference

### RdxProgressRootDirective

<ArgTypes of={RdxProgressRootDirective} />

<Markdown>
  {`
  | Data Attribute | Value |
  | ----------- | --------- |
  | [data-state]    | "complete" or "indeterminate" or "loading"   |
  | [data-value]    | The current value          |
  | [data-max] |  The max value     |
  `}
</Markdown>

### RdxProgressIndicatorDirective

Used to show the progress visually. It also makes progress accessible to assistive technologies.

<Markdown>
  {`
  | Data Attribute | Value |
  | ----------- | --------- |
  | [data-state]    | "complete" or "indeterminate" or "loading"   |
  | [data-value]    | The current value          |
  | [data-max] |  The max value     |
  `}
</Markdown>

## Accessibility

Adheres to the [`progressbar` role requirements](https://www.w3.org/WAI/ARIA/apg/patterns/meter).


## Examples

### Progress Circular

<Canvas sourceState="hidden" of={ProgressDirectiveStories.ProgressCircular} />

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/progress/stories/progress.stories.ts
```typescript
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { RdxProgressIndicatorDirective } from '../src/progress-indicator.directive';
import { RdxProgressRootDirective } from '../src/progress-root.directive';
import { ProgressCircularComponent } from './progress-circular';

const html = String.raw;

export default {
    title: 'Primitives/Progress',
    decorators: [
        moduleMetadata({
            imports: [RdxProgressRootDirective, RdxProgressIndicatorDirective, ProgressCircularComponent]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div class="radix-themes light light-theme" data-radius="medium" data-scaling="100%">${story}</div>
            `
        )
    ],
    argTypes: {
        progress: {
            options: ['10', '30', '70', '95'],
            control: { type: 'select' }
        }
    }
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    args: {
        progress: 70
    },
    render: (args) => ({
        props: args,
        template: html`
            <div class="ProgressRoot" rdxProgressRoot [value]="progress">
                <div
                    class="ProgressIndicator"
                    rdxProgressIndicator
                    [style.transform]="'translateX(-' + (100 - progress) +'%)'"
                ></div>
            </div>

            <style>
                .ProgressRoot {
                    position: relative;
                    overflow: hidden;
                    background: var(--black-a9);
                    border-radius: 99999px;
                    width: 300px;
                    height: 25px;

                    /* Fix overflow clipping in Safari */
                    /* https://gist.github.com/domske/b66047671c780a238b51c51ffde8d3a0 */
                    transform: translateZ(0);
                }

                .ProgressIndicator {
                    background-color: white;
                    width: 100%;
                    height: 100%;
                    transition: transform 660ms cubic-bezier(0.65, 0, 0.35, 1);
                }
            </style>
        `
    })
};

export const ProgressCircular: Story = {
    render: () => ({
        template: html`
            <progress-circular />
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/progress/src/progress-indicator.directive.ts
```typescript
import { Directive } from '@angular/core';
import { injectProgress } from './progress-root.directive';

/**
 * Directive to manage progress indicator state and attributes.
 *
 * This directive is used to display the progress indicator inside the progress bar.
 * It inherits the state and value from the `RdxProgressRootDirective`.
 */
@Directive({
    selector: '[rdxProgressIndicator]',
    exportAs: 'rdxProgressIndicator',
    host: {
        '[attr.data-state]': 'progress.progressState()',
        '[attr.data-value]': 'progress.value()',
        '[attr.data-max]': 'progress.max()'
    }
})
export class RdxProgressIndicatorDirective {
    /**
     * This allows the directive to access the progress bar state and values.
     */
    protected readonly progress = injectProgress();
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/progress/src/progress-root.directive.ts
```typescript
import { computed, Directive, effect, inject, InjectionToken, input, model } from '@angular/core';
import { isNullish, isNumber, provideToken } from '@radix-ng/primitives/core';

export const RdxProgressToken = new InjectionToken<RdxProgressRootDirective>('RdxProgressDirective');

/**
 * Injects the current instance of RdxProgressRootDirective.
 * @returns The instance of RdxProgressRootDirective.
 */
export function injectProgress(): RdxProgressRootDirective {
    return inject(RdxProgressToken);
}

export type ProgressState = 'indeterminate' | 'complete' | 'loading';

export interface ProgressProps {
    value?: number | null;
    max?: number;
    /**
     * A function to get the accessible label text representing the current value in a human-readable format.
     *
     *  If not provided, the value label will be read as the numeric value as a percentage of the max value.
     */
    getValueLabel?: (value: number, max: number) => string;
}

const MIN_PERCENT = 0;
const DEFAULT_MAX = 100;

/**
 * Directive to manage progress bar state and attributes.
 *
 * This directive provides a way to create a progress bar with customizable value and max attributes.
 * It handles aria attributes for accessibility and provides different states like 'indeterminate', 'complete', and 'loading'.
 *
 * @group Components
 */
@Directive({
    selector: '[rdxProgressRoot]',
    exportAs: 'rdxProgressRoot',
    providers: [provideToken(RdxProgressToken, RdxProgressRootDirective)],
    host: {
        role: 'progressbar',
        '[attr.aria-valuemax]': 'max()',
        '[attr.aria-valuemin]': '0',
        '[attr.aria-valuenow]': 'value()',
        '[attr.aria-valuetext]': 'label()',
        '[attr.aria-label]': 'label()',
        '[attr.data-state]': 'progressState()',
        '[attr.data-value]': 'value() ?? undefined',
        '[attr.data-max]': 'max()',
        // set tab index to -1 so screen readers will read the aria-label
        // Note: there is a known issue with JAWS that does not read progressbar aria labels on FireFox
        tabindex: '-1'
    }
})
export class RdxProgressRootDirective {
    /**
     * The current value of the progress bar.
     * @group Props
     * @defaultValue 0
     */
    readonly value = model<number>(MIN_PERCENT);

    /**
     * The maximum value of the progress bar.
     * @defaultValue 100
     * @group Props
     */
    readonly max = model<number>(DEFAULT_MAX);

    /**
     * Function to generate the value label.
     * @group Props
     */
    readonly valueLabel = input<(value: number, max: number) => string>((value, max) =>
        this.defaultGetValueLabel(value, max)
    );

    protected readonly label = computed(() => this.valueLabel()(this.value(), this.max()));

    readonly progressState = computed<ProgressState>(() => {
        if (isNullish(this.value())) {
            return 'indeterminate';
        }
        if (this.value() === this.max()) {
            return 'complete';
        }
        return 'loading';
    });

    constructor() {
        effect(() => {
            const correctedValue = this.validateValue(this.value(), this.max());
            if (correctedValue != null && correctedValue !== this.value()) {
                this.value.set(correctedValue);
            }
        });

        effect(() => {
            const correctedMax = this.validateMax(this.max());
            if (correctedMax !== this.max()) {
                this.max.set(correctedMax);
            }
        });
    }

    private validateValue(value: any, max: number): number | null {
        const isValidValueError =
            isNullish(value) || (isNumber(value) && !Number.isNaN(value) && value <= max && value >= 0);

        if (isValidValueError) return value as null;

        console.error(`Invalid prop \`value\` of value \`${value}\` supplied to \`ProgressRoot\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${DEFAULT_MAX} if no \`max\` prop is set)
  - \`null\`  or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`);
        return null;
    }

    private validateMax(max: number): number {
        const isValidMaxError = isNumber(max) && !Number.isNaN(max) && max > 0;

        if (isValidMaxError) return max;

        console.error(
            `Invalid prop \`max\` of value \`${max}\` supplied to \`ProgressRoot\`. Only numbers greater than 0 are valid max values. Defaulting to \`${DEFAULT_MAX}\`.`
        );
        return DEFAULT_MAX;
    }

    private defaultGetValueLabel(value: number, max: number) {
        return `${Math.round((value / max) * 100)}%`;
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/alert-dialog/README.md
```
# @radix-ng/primitives/alert-dialog

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/alert-dialog/index.ts
```typescript
import { NgModule } from '@angular/core';
import { RdxAlertDialogCancelDirective } from './src/alert-dialog-cancel.directive';
import { RdxAlertDialogContentDirective } from './src/alert-dialog-content.directive';
import { RdxAlertDialogRootDirective } from './src/alert-dialog-root.directive';
import { RdxAlertDialogTitleDirective } from './src/alert-dialog-title.directive';
import { RdxAlertDialogTriggerDirective } from './src/alert-dialog-trigger.directive';

export * from './src/alert-dialog-cancel.directive';
export * from './src/alert-dialog-content.directive';
export * from './src/alert-dialog-root.directive';
export * from './src/alert-dialog-title.directive';
export * from './src/alert-dialog-trigger.directive';

export * from './src/alert-dialog.service';

const _imports = [
    RdxAlertDialogRootDirective,
    RdxAlertDialogContentDirective,
    RdxAlertDialogCancelDirective,
    RdxAlertDialogTriggerDirective,
    RdxAlertDialogTitleDirective
];

@NgModule({
    imports: [..._imports],
    exports: [..._imports]
})
export class RdxAlertDialogModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/alert-dialog/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/alert-dialog/stories/alert-dialog.stories.ts
```typescript
import { OverlayModule } from '@angular/cdk/overlay';
import { PortalModule } from '@angular/cdk/portal';
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { RdxAlertDialogCancelDirective } from '../src/alert-dialog-cancel.directive';
import { RdxAlertDialogContentDirective } from '../src/alert-dialog-content.directive';
import { RdxAlertDialogRootDirective } from '../src/alert-dialog-root.directive';
import { RdxAlertDialogTitleDirective } from '../src/alert-dialog-title.directive';
import { RdxAlertDialogTriggerDirective } from '../src/alert-dialog-trigger.directive';
import { RdxAlertDialogService } from '../src/alert-dialog.service';

export default {
    title: 'Primitives/Alert Dialog',
    decorators: [
        moduleMetadata({
            imports: [
                RdxAlertDialogContentDirective,
                RdxAlertDialogRootDirective,
                RdxAlertDialogTitleDirective,
                RdxAlertDialogTriggerDirective,
                RdxAlertDialogCancelDirective,
                OverlayModule,
                PortalModule
            ],
            providers: [RdxAlertDialogService]
        }),
        componentWrapperDecorator(
            (story) =>
                `
                    <div class="radix-themes light light-theme"
                      data-radius="medium"
                      data-scaling="100%">${story}</div>`
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: (args) => ({
        props: args,
        template: `

<div rdxAlertDialogRoot [content]="alertDialogContent">
    <button rdxAlertDialogTrigger class="Button violet">Delete account</button>
    <ng-template #alertDialogContent>
        <div rdxAlertDialogContent maxWidth="450" class="AlertDialogContent">
            <h2 rdxAlertDialogTitle class="AlertDialogTitle">Are you absolutely sure?</h2>
            <p class="AlertDialogDescription">
               This action cannot be undone. This will permanently delete your account and remove your data from our servers.
            </p>
            <div style="display: flex; gap: 3px; margin-top: 4px; justify-content: flex-end;">
                <button rdxAlertDialogCancel class="Button mauve">Cancel</button>
                <button class="Button red">Revoke access</button>
            </div>
        </div>
    </ng-template>
</div>

<style>

.AlertDialogContent {
  background-color: white;
  border-radius: 6px;
  box-shadow: hsl(206 22% 7% / 35%) 0px 10px 38px -10px, hsl(206 22% 7% / 20%) 0px 10px 20px -15px;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 90vw;
  max-width: 500px;
  max-height: 85vh;
  padding: 25px;
  animation: contentShow 150ms cubic-bezier(0.16, 1, 0.3, 1);
}

.AlertDialogTitle {
  margin: 0;
  color: var(--mauve-12);
  font-size: 17px;
  font-weight: 500;
}

.AlertDialogDescription {
  margin-bottom: 20px;
  color: var(--mauve-11);
  font-size: 15px;
  line-height: 1.5;
}

button {
  all: unset;
}
Button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  padding: 0 15px;
  font-size: 15px;
  line-height: 1;
  font-weight: 500;
  height: 35px;
}
.Button.violet {
  background-color: white;
  color: var(--violet-11);
  box-shadow: 0 2px 10px var(--black-a7);
}
.Button.violet:hover {
  background-color: var(--mauve-3);
}
.Button.violet:focus {
  box-shadow: 0 0 0 2px black;
}
.Button.red {
  background-color: var(--red-4);
  color: var(--red-11);
}
.Button.red:hover {
  background-color: var(--red-5);
}
.Button.red:focus {
  box-shadow: 0 0 0 2px var(--red-7);
}
.Button.mauve {
  background-color: var(--mauve-4);
  color: var(--mauve-11);
}
.Button.mauve:hover {
  background-color: var(--mauve-5);
}
.Button.mauve:focus {
  box-shadow: 0 0 0 2px var(--mauve-7);
}
</style>

`
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/alert-dialog/src/alert-dialog-cancel.directive.ts
```typescript
import { Directive, inject } from '@angular/core';
import { RdxAlertDialogService } from './alert-dialog.service';

@Directive({
    selector: '[rdxAlertDialogCancel]',
    standalone: true,
    host: {
        '(click)': 'onClick()'
    }
})
export class RdxAlertDialogCancelDirective {
    private readonly alertDialogService = inject(RdxAlertDialogService);

    onClick() {
        this.alertDialogService.close();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/alert-dialog/src/alert-dialog-content.directive.ts
```typescript
import { CdkTrapFocus } from '@angular/cdk/a11y';
import { Directive, ElementRef, inject, Input, Renderer2 } from '@angular/core';

@Directive({
    selector: '[rdxAlertDialogContent]',
    standalone: true,
    hostDirectives: [
        {
            directive: CdkTrapFocus
        }
    ],
    host: {
        '[attr.data-state]': '"open"',
        '[attr.cdkTrapFocusAutoCapture]': 'true'
    }
})
export class RdxAlertDialogContentDirective {
    private readonly renderer = inject(Renderer2);
    private readonly elementRef = inject(ElementRef);

    @Input() set maxWidth(value: string) {
        this.renderer.setStyle(this.elementRef.nativeElement, 'maxWidth', value);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/alert-dialog/src/alert-dialog-root.directive.ts
```typescript
import { Directive, inject, Input, TemplateRef, ViewContainerRef } from '@angular/core';
import { RdxAlertDialogService } from './alert-dialog.service';

@Directive({
    selector: '[rdxAlertDialogRoot]',
    standalone: true
})
export class RdxAlertDialogRootDirective {
    private readonly viewContainerRef = inject(ViewContainerRef);
    private readonly alertDialogService = inject(RdxAlertDialogService);

    @Input() set content(template: TemplateRef<any>) {
        this.alertDialogService.setDialogContent(this.viewContainerRef, template);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/alert-dialog/src/alert-dialog-title.directive.ts
```typescript
import { Directive } from '@angular/core';

@Directive({
    selector: '[rdxAlertDialogTitle]',
    standalone: true
})
export class RdxAlertDialogTitleDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/alert-dialog/src/alert-dialog-trigger.directive.ts
```typescript
import { Directive, inject } from '@angular/core';
import { RdxAlertDialogService } from './alert-dialog.service';

@Directive({
    selector: '[rdxAlertDialogTrigger]',
    standalone: true,
    host: {
        '(click)': 'handleClick()'
    }
})
export class RdxAlertDialogTriggerDirective {
    private readonly alertDialogService = inject(RdxAlertDialogService);

    handleClick() {
        this.alertDialogService.open();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/alert-dialog/src/alert-dialog.service.ts
```typescript
import { Overlay, OverlayRef } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { Injectable, TemplateRef, ViewContainerRef } from '@angular/core';

@Injectable({
    providedIn: 'root'
})
export class RdxAlertDialogService {
    private overlayRef: OverlayRef | null | undefined;
    private dialogContent:
        | {
              viewContainerRef: ViewContainerRef;
              template: TemplateRef<any>;
          }
        | undefined;

    constructor(private overlay: Overlay) {}

    setDialogContent(viewContainerRef: ViewContainerRef, template: TemplateRef<any>) {
        this.dialogContent = { viewContainerRef, template };
    }

    open() {
        if (!this.dialogContent) {
            throw new Error('Dialog content is not set');
        }

        this.overlayRef = this.overlay.create({
            hasBackdrop: true,
            backdropClass: 'cdk-overlay-dark-backdrop',
            positionStrategy: this.overlay.position().global().centerHorizontally().centerVertically()
        });

        const templatePortal = new TemplatePortal(this.dialogContent.template, this.dialogContent.viewContainerRef);
        this.overlayRef.attach(templatePortal);

        this.overlayRef.keydownEvents().subscribe((event) => {
            if (event.key === 'Escape' || event.code === 'Escape') {
                this.close();
            }
        });
        this.overlayRef.backdropClick().subscribe(() => this.close());
    }

    close() {
        if (this.overlayRef) {
            this.overlayRef.dispose();
            this.overlayRef = null;
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/roving-focus/README.md
```
# @radix-ng/primitives/roving-focus

Secondary entry point of `@radix-ng/primitives`.

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/roving-focus/index.ts
```typescript
export * from './src/roving-focus-group.directive';
export * from './src/roving-focus-item.directive';

export type { Direction, Orientation } from './src/utils';

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/roving-focus/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/roving-focus/__test__/roving-focus-group.spec.ts
```typescript
import { Component } from '@angular/core';
import { fakeAsync, TestBed, tick } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { RdxRovingFocusGroupDirective } from '@radix-ng/primitives/roving-focus';

@Component({
    selector: 'test-host',
    standalone: true,
    template: `
        <div rdxRovingFocusGroup>
            <button id="item1">Item 1</button>
            <button id="item2">Item 2</button>
            <button id="item3">Item 3</button>
        </div>
    `,
    imports: [RdxRovingFocusGroupDirective]
})
class TestHostComponent {}

describe('RdxRovingFocusGroupDirective', () => {
    beforeEach(() => {
        TestBed.configureTestingModule({
            imports: [TestHostComponent]
        });
    });

    it('should create the directive', () => {
        const fixture = TestBed.createComponent(TestHostComponent);
        fixture.detectChanges();

        const hostElement = fixture.nativeElement.querySelector('[rdxRovingFocusGroup]');
        expect(hostElement).toBeTruthy();
    });

    it('should correctly handle focus logic', () => {
        const fixture = TestBed.createComponent(TestHostComponent);
        fixture.detectChanges();

        const hostElement = fixture.nativeElement.querySelector('[rdxRovingFocusGroup]');
        const buttons = hostElement.querySelectorAll('button');

        // Simulate focus on the first button
        buttons[0].focus();
        expect(document.activeElement).toBe(buttons[0]);

        // Simulate navigation to the second button
        buttons[1].focus();
        expect(document.activeElement).toBe(buttons[1]);
    });

    it('should handle `onItemFocus` and update currentTabStopId', () => {
        const fixture = TestBed.createComponent(TestHostComponent);
        fixture.detectChanges();

        const directiveInstance = fixture.debugElement
            .query(By.directive(RdxRovingFocusGroupDirective))
            .injector.get(RdxRovingFocusGroupDirective);

        directiveInstance.onItemFocus('item1');
        expect(directiveInstance.currentTabStopId()).toBe('item1');

        directiveInstance.onItemFocus('item2');
        expect(directiveInstance.currentTabStopId()).toBe('item2');
    });

    it('should emit currentTabStopIdChange on item focus', () => {
        const fixture = TestBed.createComponent(TestHostComponent);
        fixture.detectChanges();

        const directiveInstance = fixture.debugElement
            .query(By.directive(RdxRovingFocusGroupDirective))
            .injector.get(RdxRovingFocusGroupDirective);

        const spy = jest.spyOn(directiveInstance.currentTabStopIdChange, 'emit');

        directiveInstance.onItemFocus('item1');
        expect(spy).toHaveBeenCalledWith('item1');
    });

    it('should register and unregister focusable items correctly', () => {
        const fixture = TestBed.createComponent(TestHostComponent);
        fixture.detectChanges();

        const directiveInstance = fixture.debugElement
            .query(By.directive(RdxRovingFocusGroupDirective))
            .injector.get(RdxRovingFocusGroupDirective);

        const item = document.createElement('div');
        directiveInstance.registerItem(item);
        expect(directiveInstance.focusableItems()).toContain(item);

        directiveInstance.unregisterItem(item);
        expect(directiveInstance.focusableItems()).not.toContain(item);
    });

    it('should handle `onFocusableItemAdd` and `onFocusableItemRemove` correctly', () => {
        const fixture = TestBed.createComponent(TestHostComponent);
        fixture.detectChanges();

        const directiveInstance = fixture.debugElement
            .query(By.directive(RdxRovingFocusGroupDirective))
            .injector.get(RdxRovingFocusGroupDirective);

        directiveInstance.onFocusableItemAdd();
        expect(directiveInstance.getFocusableItemsCount()).toBe(1);

        directiveInstance.onFocusableItemRemove();
        expect(directiveInstance.getFocusableItemsCount()).toBe(0);
    });

    it('should handle `handleMouseDown` and set `isClickFocus` indirectly', () => {
        const fixture = TestBed.createComponent(TestHostComponent);
        fixture.detectChanges();

        const directiveInstance = fixture.debugElement
            .query(By.directive(RdxRovingFocusGroupDirective))
            .injector.get(RdxRovingFocusGroupDirective);

        directiveInstance.handleMouseDown();

        // Use the public behavior to infer the private state change
        // For example, call a method that uses isClickFocus.
        expect(directiveInstance['isClickFocus']()).toBe(true);
    });

    it('should reset `isClickFocus` on mouse up', fakeAsync(() => {
        const fixture = TestBed.createComponent(TestHostComponent);
        fixture.detectChanges();

        const directiveInstance = fixture.debugElement
            .query(By.directive(RdxRovingFocusGroupDirective))
            .injector.get(RdxRovingFocusGroupDirective);

        directiveInstance.handleMouseDown();
        directiveInstance.handleMouseUp();

        tick();

        expect(directiveInstance['isClickFocus']()).toBe(false);
    }));
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/roving-focus/stories/roving-focus-events.component.ts
```typescript
import { Component } from '@angular/core';
import { RdxRovingFocusGroupDirective, RdxRovingFocusItemDirective } from '@radix-ng/primitives/roving-focus';

@Component({
    selector: 'rvg-events',
    imports: [RdxRovingFocusItemDirective, RdxRovingFocusGroupDirective],
    template: `
        <div
            [orientation]="'horizontal'"
            [loop]="true"
            (entryFocus)="onEntryFocus($event)"
            (currentTabStopIdChange)="onTabStopChange($event)"
            rdxRovingFocusGroup
        >
            <button rdxRovingFocusItem tabStopId="item1">Item 1</button>
            <button rdxRovingFocusItem tabStopId="item2">Item 2</button>
            <button rdxRovingFocusItem tabStopId="item3">Item 3</button>
        </div>
    `
})
export class RovingFocusEventsComponent {
    onEntryFocus(event: Event) {
        console.log('Entry focus triggered:', event);
    }

    onTabStopChange(tabStopId: string | null) {
        console.log('Current tab stop changed to:', tabStopId);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/roving-focus/stories/roving-focus.docs.mdx
````
import { ArgTypes, Canvas, Meta } from '@storybook/blocks';
import * as Stories from './roving-focus.stories';
import { RdxRovingFocusGroupDirective } from '../src/roving-focus-group.directive';
import { RdxRovingFocusItemDirective } from '../src/roving-focus-item.directive';


<Meta title="Utilities/Roving Focus" />

# Roving Focus


<Canvas sourceState="hidden" of={Stories.Default} />


## Anatomy

```html
<div rdxRovingFocusGroup>
    <button rdxRovingFocusItem></button>
    <button rdxRovingFocusItem></button>
    <button rdxRovingFocusItem></button>
</div>
```

## API Reference

### Focus Group
The `RdxRovingFocusGroupDirective` allows managing focus within a group of elements, such as buttons, links, or any interactive items. It provides an accessible navigation pattern for keyboard users and ensures intuitive interaction.

#### Usage

This directive can be added to a container element, and all its focusable children will be managed as a group.

<ArgTypes of={RdxRovingFocusGroupDirective} />

### Focus Item
The `RdxRovingFocusItemDirective` is a companion directive to `RdxRovingFocusGroupDirective`. It manages individual items within the group, ensuring smooth keyboard navigation and intuitive focus behavior.

#### Usage
This directive should be used on individual elements (e.g., buttons or links) within a container that has the `RdxRovingFocusGroupDirective`.

<ArgTypes of={RdxRovingFocusItemDirective} />

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/roving-focus/stories/roving-focus.stories.ts
```typescript
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { RdxRovingFocusGroupDirective } from '../src/roving-focus-group.directive';
import { RdxRovingFocusItemDirective } from '../src/roving-focus-item.directive';
import { RovingFocusEventsComponent } from './roving-focus-events.component';

const html = String.raw;

export default {
    title: 'Utilities/Roving Focus',
    decorators: [
        moduleMetadata({
            imports: [
                RdxRovingFocusGroupDirective,
                RdxRovingFocusItemDirective,
                RovingFocusEventsComponent
            ]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div class="radix-themes light light-theme" data-radius="medium" data-scaling="100%">
                    ${story}

                    <style>
                        h2,
                        p {
                            color: #ffffff;
                        }

                        section {
                            width: 500px;
                        }

                        [rdxRovingFocusGroup] {
                            display: flex;
                            gap: 8px;
                        }

                        [rdxRovingFocusGroup][data-orientation='vertical'] {
                            width: 90px;
                            flex-direction: column;
                        }

                        [rdxRovingFocusGroup][data-orientation='horizontal'] {
                            flex-direction: row;
                        }

                        [rdxRovingFocusItem] {
                            padding: 8px 16px;
                            border: 1px solid #ccc;
                            border-radius: 4px;
                            background-color: #f9f9f9;
                            cursor: pointer;
                            transition:
                                background-color 0.2s,
                                transform 0.2s;
                        }

                        [rdxRovingFocusItem]:focus {
                            outline: none;
                            background-color: #007bff;
                            color: white;
                            transform: scale(1.05);
                        }

                        [rdxRovingFocusItem][data-disabled] {
                            cursor: not-allowed;
                            opacity: 0.5;
                            background-color: #f1f1f1;
                        }
                    </style>
                </div>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: html`
            <section>
                <h2>Horizontal Navigation with Looping</h2>
                <p>
                    Use the ArrowLeft and ArrowRight keys to navigate between buttons. Ensure that when reaching the end
                    of the group, the focus cycles back to the first item (and vice versa).
                </p>
                <div rdxRovingFocusGroup [orientation]="'horizontal'" [loop]="true">
                    <button rdxRovingFocusItem>Item 1</button>
                    <button rdxRovingFocusItem>Item 2</button>
                    <button rdxRovingFocusItem>Item 3</button>
                </div>
            </section>
        `
    })
};

export const HorizontalRTL: Story = {
    render: () => ({
        template: html`
            <section>
                <h2>Horizontal Navigation in RTL Direction</h2>
                <p>
                    Use the ArrowLeft and ArrowRight keys. In RTL direction, the keys should behave inversely
                    (ArrowRight moves to the previous item, and ArrowLeft moves to the next item).
                </p>
                <div rdxRovingFocusGroup [orientation]="'horizontal'" [dir]="'rtl'" [loop]="true">
                    <button rdxRovingFocusItem>Left</button>
                    <button rdxRovingFocusItem>Center</button>
                    <button rdxRovingFocusItem>Right</button>
                </div>
            </section>
        `
    })
};

export const WithHomeAndEnd: Story = {
    render: () => ({
        template: html`
            <section>
                <h2>Navigation with "Home" and "End" Keys</h2>
                <p>
                    Press the Home key to move focus to the first item. Press the End key to move focus to the last
                    item.
                </p>
                <div rdxRovingFocusGroup [orientation]="'horizontal'" [loop]="false">
                    <button rdxRovingFocusItem>Left</button>
                    <button rdxRovingFocusItem>Center</button>
                    <button rdxRovingFocusItem>Right</button>
                </div>
            </section>
        `
    })
};

export const MixedActiveAndInactive: Story = {
    render: () => ({
        template: html`
            <section>
                <h2>Mixed Active and Inactive States</h2>
                <p>Try navigating with arrow keys. Ensure that the inactive item (Disabled) is skipped.</p>
                <div rdxRovingFocusGroup [orientation]="'horizontal'" [loop]="true">
                    <button rdxRovingFocusItem [focusable]="true">Left</button>
                    <button rdxRovingFocusItem [focusable]="false">Center</button>
                    <button rdxRovingFocusItem [focusable]="true">Right</button>
                </div>
            </section>
        `
    })
};

export const VerticalWithoutLooping: Story = {
    render: () => ({
        template: html`
            <section>
                <h2>Vertical Navigation without Looping</h2>
                <p>
                    Use the ArrowLeft and ArrowRight keys to navigate between buttons. Ensure that when reaching the end
                    of the group, the focus cycles back to the first item (and vice versa).
                </p>
                <div rdxRovingFocusGroup [orientation]="'vertical'" [loop]="false">
                    <button rdxRovingFocusItem>Item 1</button>
                    <button rdxRovingFocusItem>Item 2</button>
                    <button rdxRovingFocusItem>Item 3</button>
                </div>
            </section>
        `
    })
};

export const IgnoreShiftKey: Story = {
    render: () => ({
        template: html`
            <section>
                <h2>Ignore Shift Key (allowShiftKey)</h2>
                <p>
                    Use the ArrowLeft and ArrowRight keys to navigate between buttons. Holding the
                    <code>Shift</code>
                    key should not affect focus behavior.
                </p>
                <div rdxRovingFocusGroup [orientation]="'horizontal'" [loop]="true">
                    <button rdxRovingFocusItem allowShiftKey="true">Item 1 (Shift Allowed)</button>
                    <button rdxRovingFocusItem>Item 2 (Default)</button>
                    <button rdxRovingFocusItem allowShiftKey="true">Item 3 (Shift Allowed)</button>
                </div>
            </section>
        `
    })
};

export const EventHandling: Story = {
    render: () => ({
        template: html`
            <h2>Event Handling</h2>
            <p>
                Verify that the
                <code>entryFocus</code>
                and
                <code>currentTabStopIdChange</code>
                events are triggered during the appropriate actions.
            </p>
            <rvg-events />
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/roving-focus/src/roving-focus-group.directive.ts
```typescript
import {
    booleanAttribute,
    Directive,
    ElementRef,
    EventEmitter,
    inject,
    Input,
    NgZone,
    Output,
    signal
} from '@angular/core';
import { Direction, ENTRY_FOCUS, EVENT_OPTIONS, focusFirst, Orientation } from './utils';

@Directive({
    selector: '[rdxRovingFocusGroup]',
    standalone: true,
    host: {
        '[attr.data-orientation]': 'dataOrientation',
        '[attr.tabindex]': 'tabIndex',
        '[attr.dir]': 'dir',
        '(focus)': 'handleFocus($event)',
        '(blur)': 'handleBlur()',
        '(mouseup)': 'handleMouseUp()',
        '(mousedown)': 'handleMouseDown()',
        style: 'outline: none;'
    }
})
export class RdxRovingFocusGroupDirective {
    private readonly ngZone = inject(NgZone);
    private readonly elementRef = inject(ElementRef);

    @Input() orientation: Orientation | undefined;
    @Input() dir: Direction = 'ltr';
    @Input({ transform: booleanAttribute }) loop: boolean = true;
    @Input({ transform: booleanAttribute }) preventScrollOnEntryFocus: boolean = false;

    @Output() entryFocus = new EventEmitter<Event>();
    @Output() currentTabStopIdChange = new EventEmitter<string | null>();

    /** @ignore */
    readonly currentTabStopId = signal<string | null>(null);

    /** @ignore */
    readonly focusableItems = signal<HTMLElement[]>([]);

    private readonly isClickFocus = signal(false);
    private readonly isTabbingBackOut = signal(false);
    private readonly focusableItemsCount = signal(0);

    /** @ignore */
    get dataOrientation() {
        return this.orientation || 'horizontal';
    }

    /** @ignore */
    get tabIndex() {
        return this.isTabbingBackOut() || this.getFocusableItemsCount() === 0 ? -1 : 0;
    }

    /** @ignore */
    handleBlur() {
        this.isTabbingBackOut.set(false);
    }

    /** @ignore */
    handleMouseUp() {
        // reset `isClickFocus` after 1 tick because handleFocus might not triggered due to focused element
        this.ngZone.runOutsideAngular(() => {
            // eslint-disable-next-line promise/catch-or-return,promise/always-return
            Promise.resolve().then(() => {
                this.ngZone.run(() => {
                    this.isClickFocus.set(false);
                });
            });
        });
    }

    /** @ignore */
    handleFocus(event: FocusEvent) {
        // We normally wouldn't need this check, because we already check
        // that the focus is on the current target and not bubbling to it.
        // We do this because Safari doesn't focus buttons when clicked, and
        // instead, the wrapper will get focused and not through a bubbling event.
        const isKeyboardFocus = !this.isClickFocus();

        if (
            event.currentTarget === this.elementRef.nativeElement &&
            event.target === event.currentTarget &&
            isKeyboardFocus &&
            !this.isTabbingBackOut()
        ) {
            const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);
            this.elementRef.nativeElement.dispatchEvent(entryFocusEvent);
            this.entryFocus.emit(entryFocusEvent);

            if (!entryFocusEvent.defaultPrevented) {
                const items = this.focusableItems().filter((item) => item.dataset['disabled'] !== '');
                const activeItem = items.find((item) => item.getAttribute('data-active') === 'true');
                const currentItem = items.find((item) => item.id === this.currentTabStopId());
                const candidateItems = [activeItem, currentItem, ...items].filter(Boolean) as HTMLElement[];

                focusFirst(candidateItems, this.preventScrollOnEntryFocus);
            }
        }
        this.isClickFocus.set(false);
    }

    /** @ignore */
    handleMouseDown() {
        this.isClickFocus.set(true);
    }

    /** @ignore */
    onItemFocus(tabStopId: string) {
        this.currentTabStopId.set(tabStopId);
        this.currentTabStopIdChange.emit(tabStopId);
    }

    /** @ignore */
    onItemShiftTab() {
        this.isTabbingBackOut.set(true);
    }

    /** @ignore */
    onFocusableItemAdd() {
        this.focusableItemsCount.update((count) => count + 1);
    }

    /** @ignore */
    onFocusableItemRemove() {
        this.focusableItemsCount.update((count) => Math.max(0, count - 1));
    }

    /** @ignore */
    registerItem(item: HTMLElement) {
        const currentItems = this.focusableItems();
        this.focusableItems.set([...currentItems, item]);
    }

    /** @ignore */
    unregisterItem(item: HTMLElement) {
        const currentItems = this.focusableItems();
        this.focusableItems.set(currentItems.filter((el) => el !== item));
    }

    /** @ignore */
    getFocusableItemsCount() {
        return this.focusableItemsCount();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/roving-focus/src/roving-focus-item.directive.ts
```typescript
import {
    booleanAttribute,
    computed,
    Directive,
    ElementRef,
    inject,
    Input,
    NgZone,
    OnDestroy,
    OnInit
} from '@angular/core';
import { RdxRovingFocusGroupDirective } from './roving-focus-group.directive';
import { focusFirst, generateId, getFocusIntent, wrapArray } from './utils';

@Directive({
    selector: '[rdxRovingFocusItem]',
    standalone: true,
    host: {
        '[attr.tabindex]': 'tabIndex',
        '[attr.data-orientation]': 'parent.orientation',
        '[attr.data-active]': 'active',
        '[attr.data-disabled]': '!focusable ? "" : undefined',
        '(mousedown)': 'handleMouseDown($event)',
        '(keydown)': 'handleKeydown($event)',
        '(focus)': 'onFocus()'
    }
})
export class RdxRovingFocusItemDirective implements OnInit, OnDestroy {
    private readonly elementRef = inject(ElementRef);
    private readonly ngZone = inject(NgZone);
    protected readonly parent = inject(RdxRovingFocusGroupDirective);

    @Input({ transform: booleanAttribute }) focusable: boolean = true;
    @Input({ transform: booleanAttribute }) active: boolean = true;
    @Input() tabStopId: string;
    @Input({ transform: booleanAttribute }) allowShiftKey: boolean = false;

    private readonly id = computed(() => this.tabStopId || generateId());

    /** @ignore */
    readonly isCurrentTabStop = computed(() => this.parent.currentTabStopId() === this.id());

    /**
     * Lifecycle hook triggered on initialization.
     * Registers the element with the parent roving focus group if it is focusable.
     * @ignore
     */
    ngOnInit() {
        if (this.focusable) {
            this.parent.registerItem(this.elementRef.nativeElement);
            this.parent.onFocusableItemAdd();
        }
    }

    /**
     * Lifecycle hook triggered on destruction.
     * Unregisters the element from the parent roving focus group if it is focusable.
     * @ignore
     */
    ngOnDestroy() {
        if (this.focusable) {
            this.parent.unregisterItem(this.elementRef.nativeElement);
            this.parent.onFocusableItemRemove();
        }
    }

    /**
     * Determines the `tabIndex` of the element.
     * Returns `0` if the element is the current tab stop; otherwise, returns `-1`.
     * @ignore
     */
    get tabIndex() {
        return this.isCurrentTabStop() ? 0 : -1;
    }

    /** @ignore */
    handleMouseDown(event: MouseEvent) {
        if (!this.focusable) {
            // We prevent focusing non-focusable items on `mousedown`.
            // Even though the item has tabIndex={-1}, that only means take it out of the tab order.
            event.preventDefault();
        } else {
            // Safari doesn't focus a button when clicked so we run our logic on mousedown also
            this.parent.onItemFocus(this.id());
        }
    }

    /** @ignore */
    onFocus() {
        this.parent.onItemFocus(this.id());
    }

    /**
     * Handles the `keydown` event for keyboard navigation within the roving focus group.
     * Supports navigation based on orientation and direction, and focuses appropriate elements.
     *
     * @param event The `KeyboardEvent` object.
     * @ignore
     */
    handleKeydown(event: KeyboardEvent) {
        if (event.key === 'Tab' && event.shiftKey) {
            this.parent.onItemShiftTab();
            return;
        }

        if (event.target !== this.elementRef.nativeElement) return;

        const focusIntent = getFocusIntent(event, this.parent.orientation, this.parent.dir);

        if (focusIntent !== undefined) {
            if (event.metaKey || event.ctrlKey || event.altKey || (this.allowShiftKey ? false : event.shiftKey)) {
                return;
            }

            event.preventDefault();

            let candidateNodes = this.parent.focusableItems().filter((item) => item.dataset['disabled'] !== '');

            if (focusIntent === 'last') {
                candidateNodes.reverse();
            } else if (focusIntent === 'prev' || focusIntent === 'next') {
                if (focusIntent === 'prev') candidateNodes.reverse();
                const currentIndex = candidateNodes.indexOf(this.elementRef.nativeElement);

                candidateNodes = this.parent.loop
                    ? wrapArray(candidateNodes, currentIndex + 1)
                    : candidateNodes.slice(currentIndex + 1);
            }

            this.ngZone.runOutsideAngular(() => {
                // eslint-disable-next-line promise/always-return,promise/catch-or-return
                Promise.resolve().then(() => {
                    focusFirst(candidateNodes, false, this.elementRef.nativeElement);
                });
            });
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/roving-focus/src/utils.ts
```typescript
export type Orientation = 'horizontal' | 'vertical';
export type Direction = 'ltr' | 'rtl';

export const ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';
export const EVENT_OPTIONS = { bubbles: false, cancelable: true };

type FocusIntent = 'first' | 'last' | 'prev' | 'next';

export const MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {
    ArrowLeft: 'prev',
    ArrowUp: 'prev',
    ArrowRight: 'next',
    ArrowDown: 'next',
    PageUp: 'first',
    Home: 'first',
    PageDown: 'last',
    End: 'last'
};

export function getDirectionAwareKey(key: string, dir?: Direction) {
    if (dir !== 'rtl') return key;
    return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;
}

export function getFocusIntent(event: KeyboardEvent, orientation?: Orientation, dir?: Direction) {
    const key = getDirectionAwareKey(event.key, dir);
    if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key)) return undefined;
    if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key)) return undefined;
    return MAP_KEY_TO_FOCUS_INTENT[key];
}

export function focusFirst(candidates: HTMLElement[], preventScroll = false, rootNode?: Document | ShadowRoot) {
    const PREVIOUSLY_FOCUSED_ELEMENT = rootNode?.activeElement ?? document.activeElement;
    for (const candidate of candidates) {
        // if focus is already where we want to go, we don't want to keep going through the candidates
        if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
        candidate.focus({ preventScroll });
        if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
    }
}

/**
 * Wraps an array around itself at a given start index
 * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`
 */
export function wrapArray<T>(array: T[], startIndex: number) {
    return array.map((_, index) => array[(startIndex + index) % array.length]);
}

export function generateId(): string {
    return `rf-item-${Math.random().toString(36).slice(2, 11)}`;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/config/index.ts
```typescript
export * from './src/config';
export * from './src/config.provider';

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/config/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/config/src/config.provider.ts
```typescript
import {
    EnvironmentProviders,
    inject,
    InjectionToken,
    makeEnvironmentProviders,
    provideAppInitializer
} from '@angular/core';
import { RadixNG, type RadixNGConfig } from './config';

export const RADIX_NG_CONFIG = new InjectionToken<RadixNGConfig>('RADIX_NG_CONFIG');

/**
 * Provides RadixNG configuration as environment providers.
 *
 * @param features One or more RadixNG configuration objects.
 * @returns A set of environment providers that register the RadixNG configs.
 */
export function provideRadixNG(...features: RadixNGConfig[]): EnvironmentProviders {
    const providers = features?.map((feature) => ({
        provide: RADIX_NG_CONFIG,
        useValue: feature,
        multi: false
    }));

    /**
     * Creates an AppInitializer to load and apply each RadixNG configuration
     * to the global RadixNG service before the app starts.
     */
    const initializer = provideAppInitializer(() => {
        const config = inject(RadixNG);
        features?.forEach((feature) => config.setConfig(feature));
        return;
    });

    return makeEnvironmentProviders([...providers, initializer]);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/config/src/config.ts
```typescript
import { Direction } from '@angular/cdk/bidi';
import { Injectable, signal } from '@angular/core';

export type RadixNGConfig = {
    /**
     * The global reading direction of your application. This will be inherited by all primitives.
     * @defaultValue 'ltr'
     */
    dir?: Direction;

    /**
     * The global locale of your application. This will be inherited by all primitives.
     * @defaultValue 'en'
     */
    locale?: string;
};

@Injectable({ providedIn: 'root' })
export class RadixNG {
    readonly dir = signal<Direction>('ltr');

    readonly locale = signal<string>('en');

    setConfig(config: RadixNGConfig): void {
        const { dir, locale } = config || {};

        if (dir) this.dir.set(dir);
        if (locale) this.locale.set(locale);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/accordion/README.md
```
# @radix-ng/primitives/accordion

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/accordion/index.ts
```typescript
import { NgModule } from '@angular/core';
import { RdxAccordionContentDirective } from './src/accordion-content.directive';
import { RdxAccordionHeaderDirective } from './src/accordion-header.directive';
import { RdxAccordionItemDirective } from './src/accordion-item.directive';
import { RdxAccordionRootDirective } from './src/accordion-root.directive';
import { RdxAccordionTriggerDirective } from './src/accordion-trigger.directive';

export * from './src/accordion-content.directive';
export * from './src/accordion-header.directive';
export * from './src/accordion-item.directive';
export * from './src/accordion-root.directive';
export * from './src/accordion-trigger.directive';

const _imports = [
    RdxAccordionContentDirective,
    RdxAccordionHeaderDirective,
    RdxAccordionItemDirective,
    RdxAccordionRootDirective,
    RdxAccordionTriggerDirective
];

@NgModule({
    imports: [..._imports],
    exports: [..._imports]
})
export class RdxAccordionModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/accordion/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/accordion/stories/accordion.docs.mdx
````
import { ArgTypes, Canvas, Meta } from '@storybook/blocks';
import * as AccordionStories from './accordion.stories';
import { RdxAccordionRootDirective } from '../src/accordion-root.directive';
import { RdxAccordionItemDirective } from '../src/accordion-item.directive';
import { RdxAccordionTriggerDirective } from '../src/accordion-trigger.directive';
import { RdxAccordionContentDirective } from '../src/accordion-content.directive';

<Meta title="Primitives/Accordion" />

# Accordion

#### A vertically stacked set of interactive headings that each reveal an associated section of content.

## Single

<Canvas sourceState="hidden" of={AccordionStories.Default} />

## Multiple

<Canvas sourceState="hidden" of={AccordionStories.Multiple} />

## Horizontal

<Canvas sourceState="hidden" of={AccordionStories.Horizontal} />

## Features

- âœ… Full keyboard navigation.
- âœ… Supports horizontal/vertical orientation.
- âœ… Supports Right to Left direction.
- âœ… Can expand one or multiple items.
- âœ… Can be controlled or uncontrolled.

## Anatomy

```html
<div rdxAccordionRoot>
  <div rdxAccordionItem>
    <div rdxAccordionHeader>
      <button rdxAccordionTrigger></button>
    </div>
    <div rdxAccordionContent></div>
  </div>
</div>
```

## Import

Get started with importing the directives:

```typescript
import {
  RdxAccordionRootDirective,
  RdxAccordionItemDirective,
  RdxAccordionHeaderDirective,
  RdxAccordionTriggerDirective,
  RdxAccordionContentDirective
} from '@radix-ng/primitives/accordion';
```

## API Reference

## RdxAccordionRootDirective

<ArgTypes of={RdxAccordionRootDirective} />

## RdxAccordionItemDirective

<ArgTypes of={RdxAccordionItemDirective} />

## RdxAccordionTriggerDirective

<ArgTypes of={RdxAccordionTriggerDirective} />

## RdxAccordionContentDirective

<ArgTypes of={RdxAccordionContentDirective} />

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/accordion/stories/accordion.stories.ts
```typescript
import { BrowserAnimationsModule, provideAnimations } from '@angular/platform-browser/animations';
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { ChevronDown, LucideAngularModule } from 'lucide-angular';
import { RdxAccordionContentDirective } from '../src/accordion-content.directive';
import { RdxAccordionHeaderDirective } from '../src/accordion-header.directive';
import { RdxAccordionItemDirective } from '../src/accordion-item.directive';
import { RdxAccordionRootDirective } from '../src/accordion-root.directive';
import { RdxAccordionTriggerDirective } from '../src/accordion-trigger.directive';

const html = String.raw;

export default {
    title: 'Primitives/Accordion',
    decorators: [
        moduleMetadata({
            imports: [
                RdxAccordionRootDirective,
                RdxAccordionItemDirective,
                RdxAccordionHeaderDirective,
                RdxAccordionTriggerDirective,
                RdxAccordionContentDirective,
                BrowserAnimationsModule,
                LucideAngularModule,
                LucideAngularModule.pick({ ChevronDown })
            ],
            providers: [provideAnimations()]
        }),
        componentWrapperDecorator(
            (story) => `
                <div class="radix-themes light light-theme radix-themes-default-fonts"
                    data-accent-color="indigo"
                    data-radius="medium"
                    data-scaling="100%"
                >
                    ${story}
                </div>

                <style>
                    /* reset */
                    button,
                    h3 {
                        all: unset;
                    }

                    .AccordionRoot {
                        border-radius: 6px;
                        background-color: var(--mauve-6);
                        box-shadow: 0 2px 10px var(--black-a4);
                    }

                    .AccordionRoot[data-orientation="vertical"] {
                        width: 300px;
                    }

                    .AccordionRoot[data-orientation="horizontal"] {
                        height: 300px;

                        display: flex;
                        flex-direction: row;
                    }

                    .AccordionItem {
                        overflow: hidden;
                        margin-top: 1px;
                    }

                    .AccordionItem[data-orientation="horizontal"] {
                        display: flex;
                    }

                    .AccordionItem[data-orientation="vertical"]:first-child {
                        margin-top: 0;
                        border-top-left-radius: 4px;
                        border-top-right-radius: 4px;
                    }

                    .AccordionItem[data-orientation="vertical"]:last-child {
                        border-bottom-left-radius: 4px;
                        border-bottom-right-radius: 4px;
                    }

                    .AccordionItem[data-orientation="horizontal"]:first-child {
                        margin-top: 0;
                        border-top-left-radius: 4px;
                        border-bottom-left-radius: 4px;
                    }

                    .AccordionItem[data-orientation="horizontal"]:last-child {
                        border-top-right-radius: 4px;
                        border-bottom-right-radius: 4px;
                    }

                    .AccordionItem:focus-within {
                        position: relative;
                        z-index: 1;
                        box-shadow: 0 0 0 2px var(--mauve-12);
                    }

                    .AccordionHeader {
                        display: flex;
                    }

                    .AccordionTrigger {
                        font-family: inherit;
                        padding: 0 20px;
                        height: 45px;
                        flex: 1;
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        font-size: 15px;
                        line-height: 1;
                        color: var(--violet-11);
                        box-shadow: 0 1px 0 var(--mauve-6);
                        background-color: white;
                        cursor: default;
                    }

                    .AccordionTrigger[data-orientation="horizontal"] {
                        height: 100%;
                        padding: 20px;
                        writing-mode: vertical-rl;
                    }

                    .AccordionTrigger[data-disabled="true"] {
                        color: var(--gray-7);
                    }

                    .AccordionTrigger:hover {
                        background-color: var(--mauve-2);
                    }

                    .AccordionContent {
                        display: flex;
                        overflow: hidden;
                        font-size: 15px;
                        color: var(--mauve-11);
                        background-color: var(--mauve-2);
                    }
                    .AccordionContent[data-orientation='vertical'][data-state='open'] {
                        animation: slideDown 300ms cubic-bezier(0.87, 0, 0.13, 1);
                    }
                    .AccordionContent[data-orientation='vertical'][data-state='closed'] {
                        animation: slideUp 300ms cubic-bezier(0.87, 0, 0.13, 1);
                    }

                    .AccordionContent[data-orientation='horizontal'][data-state='open'] {
                        animation: slideRight 300ms cubic-bezier(0.87, 0, 0.13, 1);
                    }
                    .AccordionContent[data-orientation='horizontal'][data-state='closed'] {
                        animation: slideLeft 300ms cubic-bezier(0.87, 0, 0.13, 1);
                    }

                    .AccordionContentText {
                        padding: 15px 20px;
                    }

                    .AccordionChevron {
                        display: flex;
                        color: var(--violet-10);
                        transition: transform 300ms cubic-bezier(0.87, 0, 0.13, 1);
                    }
                    .AccordionTrigger[data-state='open'] > .AccordionChevron {
                        transform: rotate(180deg);
                    }

                    .horizontal-flex-container {
                        display: flex;
                    }

                    @keyframes slideDown {
                        from {
                            height: 0;
                        }
                        to {
                            height: var(--radix-accordion-content-height);
                        }
                    }

                    @keyframes slideUp {
                        from {
                            height: var(--radix-accordion-content-height);
                        }
                        to {
                            height: 0;
                        }
                    }

                    @keyframes slideRight {
                        from {
                            width: 0;
                        }
                        to {
                            width: var(--radix-accordion-content-width);
                        }
                    }

                    @keyframes slideLeft {
                        from {
                            width: var(--radix-accordion-content-width);
                        }
                        to {
                            width: 0;
                        }
                    }
                </style>`
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: html`
            <div class="AccordionRoot" rdxAccordionRoot [defaultValue]="'item-1'">
                <div class="AccordionItem" [value]="'item-1'" rdxAccordionItem>
                    <div class="AccordionHeader" rdxAccordionHeader>
                        <button class="AccordionTrigger" type="button" rdxAccordionTrigger>
                            Is it accessible?
                            <lucide-icon class="AccordionChevron" aria-hidden size="16" name="chevron-down" />
                        </button>
                    </div>
                    <div class="AccordionContent" rdxAccordionContent>
                        <div class="AccordionContentText">Yes. It adheres to the WAI-ARIA design pattern.</div>
                    </div>
                </div>

                <div class="AccordionItem" [value]="'item-2'" rdxAccordionItem [disabled]="true">
                    <div class="AccordionHeader" rdxAccordionHeader>
                        <button class="AccordionTrigger" type="button" rdxAccordionTrigger>
                            Is it unstyled?
                            <lucide-icon class="AccordionChevron" aria-hidden size="16" name="chevron-down" />
                        </button>
                    </div>
                    <div class="AccordionContent" rdxAccordionContent>
                        <div class="AccordionContentText">
                            Yes. It's unstyled by default, giving you freedom over the look and feel.
                        </div>
                    </div>
                </div>

                <div class="AccordionItem" [value]="'item-3'" rdxAccordionItem>
                    <div class="AccordionHeader" rdxAccordionHeader>
                        <button class="AccordionTrigger" type="button" rdxAccordionTrigger>
                            Can it be animated?
                            <lucide-icon class="AccordionChevron" aria-hidden size="16" name="chevron-down" />
                        </button>
                    </div>
                    <div class="AccordionContent" rdxAccordionContent>
                        <div class="AccordionContentText">
                            Yes! You can animate the Accordion with CSS or JavaScript.
                        </div>
                    </div>
                </div>
            </div>
        `
    })
};

export const Multiple: Story = {
    render: () => ({
        template: html`
            <div class="AccordionRoot" rdxAccordionRoot [value]="['item-2', 'item-3']" [type]="'multiple'">
                <div class="AccordionItem" [value]="'item-1'" rdxAccordionItem>
                    <div class="AccordionHeader" rdxAccordionHeader>
                        <button class="AccordionTrigger" type="button" rdxAccordionTrigger>Is it accessible?</button>
                    </div>
                    <div class="AccordionContent" rdxAccordionContent>
                        <div class="AccordionContentText">Yes. It adheres to the WAI-ARIA design pattern.</div>
                    </div>
                </div>

                <div class="AccordionItem" [value]="'item-2'" rdxAccordionItem>
                    <div class="AccordionHeader" rdxAccordionHeader>
                        <button class="AccordionTrigger" type="button" rdxAccordionTrigger>Is it unstyled?</button>
                    </div>
                    <div class="AccordionContent" rdxAccordionContent>
                        <div class="AccordionContentText">
                            Yes. It's unstyled by default, giving you freedom over the look and feel.
                        </div>
                    </div>
                </div>

                <div class="AccordionItem" [value]="'item-3'" rdxAccordionItem>
                    <div class="AccordionHeader" rdxAccordionHeader>
                        <button class="AccordionTrigger" type="button" rdxAccordionTrigger>Can it be animated?</button>
                    </div>
                    <div class="AccordionContent" rdxAccordionContent>
                        <div class="AccordionContentText">
                            Yes! You can animate the Accordion with CSS or JavaScript.
                        </div>
                    </div>
                </div>
            </div>
        `
    })
};

export const Horizontal: Story = {
    render: () => ({
        template: html`
            <div class="horizontal-flex-container">
                <div class="AccordionRoot" rdxAccordionRoot [defaultValue]="'item-1'" [orientation]="'horizontal'">
                    <div class="AccordionItem" [value]="'item-1'" rdxAccordionItem>
                        <div class="AccordionHeader" rdxAccordionHeader>
                            <button class="AccordionTrigger" type="button" rdxAccordionTrigger>
                                Is it accessible?
                            </button>
                        </div>
                        <div class="AccordionContent" rdxAccordionContent>
                            <div class="AccordionContentText">Yes. It adheres to the WAI-ARIA design pattern.</div>
                        </div>
                    </div>

                    <div class="AccordionItem" [value]="'item-2'" rdxAccordionItem [disabled]="true">
                        <div class="AccordionHeader" rdxAccordionHeader>
                            <button class="AccordionTrigger" type="button" rdxAccordionTrigger>Is it unstyled?</button>
                        </div>
                        <div class="AccordionContent" rdxAccordionContent>
                            <div class="AccordionContentText">
                                Yes. It's unstyled by default, giving you freedom over the look and feel.
                            </div>
                        </div>
                    </div>

                    <div class="AccordionItem" [value]="'item-3'" rdxAccordionItem>
                        <div class="AccordionHeader" rdxAccordionHeader>
                            <button class="AccordionTrigger" type="button" rdxAccordionTrigger>
                                Can it be animated?
                            </button>
                        </div>
                        <div class="AccordionContent" rdxAccordionContent>
                            <div class="AccordionContentText">
                                Yes! You can animate the Accordion with CSS or JavaScript.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/accordion/__tests__/accordion-content.directive.spec.ts
```typescript
import { RdxAccordionContentDirective } from '../src/accordion-content.directive';

xdescribe('RdxAccordionContentDirective', () => {
    it('should create an instance', () => {
        const directive = new RdxAccordionContentDirective();
        expect(directive).toBeTruthy();
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/accordion/__tests__/accordion-header.directive.spec.ts
```typescript
import { RdxAccordionHeaderDirective } from '../src/accordion-header.directive';

xdescribe('RdxAccordionHeaderDirective', () => {
    it('should create an instance', () => {
        const directive = new RdxAccordionHeaderDirective();
        expect(directive).toBeTruthy();
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/accordion/__tests__/accordion-item.directive.spec.ts
```typescript
import { RdxAccordionItemDirective } from '../src/accordion-item.directive';

xdescribe('RdxAccordionItemDirective', () => {
    it('should create an instance', () => {
        const directive = new RdxAccordionItemDirective();
        expect(directive).toBeTruthy();
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/accordion/__tests__/accordion-root.directive.spec.ts
```typescript
import { RdxAccordionRootDirective } from '../src/accordion-root.directive';

xdescribe('RdxAccordionRootDirective', () => {
    it('should create an instance', () => {
        const directive = new RdxAccordionRootDirective();
        expect(directive).toBeTruthy();
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/accordion/__tests__/accordion-trigger.directive.spec.ts
```typescript
import { RdxAccordionTriggerDirective } from '../src/accordion-trigger.directive';

xdescribe('RdxAccordionTriggerDirective', () => {
    it('should create an instance', () => {
        const directive = new RdxAccordionTriggerDirective();
        expect(directive).toBeTruthy();
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/accordion/src/accordion-content.directive.ts
```typescript
import { Directive, ElementRef, inject } from '@angular/core';
import { RdxAccordionItemDirective } from './accordion-item.directive';

@Directive({
    selector: '[rdxAccordionContent]',
    standalone: true,
    exportAs: 'rdxAccordionContent',
    host: {
        '[attr.role]': '"region"',
        '[style.display]': 'hidden ? "none" : ""',
        '[attr.data-state]': 'item.dataState',
        '[attr.data-disabled]': 'item.disabled',
        '[attr.data-orientation]': 'item.orientation',
        '(animationend)': 'onAnimationEnd()'
    }
})
export class RdxAccordionContentDirective {
    protected readonly item = inject(RdxAccordionItemDirective);
    protected readonly nativeElement = inject(ElementRef).nativeElement;

    protected hidden = false;

    protected onAnimationEnd() {
        this.hidden = !this.item.expanded;

        const { height, width } = this.nativeElement.getBoundingClientRect();

        this.nativeElement.style.setProperty('--radix-collapsible-content-height', `${height}px`);
        this.nativeElement.style.setProperty('--radix-collapsible-content-width', `${width}px`);

        this.nativeElement.style.setProperty(
            '--radix-accordion-content-height',
            'var(--radix-collapsible-content-height)'
        );
        this.nativeElement.style.setProperty(
            '--radix-accordion-content-width',
            'var(--radix-collapsible-content-width)'
        );
    }

    onToggle() {
        if (!this.item.expanded) {
            this.hidden = false;
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/accordion/src/accordion-header.directive.ts
```typescript
import { Directive, inject } from '@angular/core';
import { RdxAccordionItemDirective } from './accordion-item.directive';

@Directive({
    selector: '[rdxAccordionHeader]',
    standalone: true,
    host: {
        '[attr.data-state]': 'item.dataState',
        '[attr.data-disabled]': 'item.disabled',
        '[attr.data-orientation]': 'item.orientation'
    }
})
export class RdxAccordionHeaderDirective {
    protected readonly item = inject(RdxAccordionItemDirective);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/accordion/src/accordion-item.directive.ts
```typescript
import { FocusableOption } from '@angular/cdk/a11y';
import { UniqueSelectionDispatcher } from '@angular/cdk/collections';
import {
    booleanAttribute,
    ChangeDetectorRef,
    ContentChild,
    Directive,
    EventEmitter,
    forwardRef,
    inject,
    Input,
    OnDestroy,
    Output
} from '@angular/core';
import { Subscription } from 'rxjs';
import { RdxAccordionContentDirective } from './accordion-content.directive';
import { RdxAccordionOrientation, RdxAccordionRootToken } from './accordion-root.directive';
import { RdxAccordionTriggerDirective } from './accordion-trigger.directive';

export type RdxAccordionItemState = 'open' | 'closed';

let nextId = 0;

/**
 * @group Components
 */
@Directive({
    selector: '[rdxAccordionItem]',
    standalone: true,
    exportAs: 'rdxAccordionItem',
    host: {
        '[attr.data-state]': 'dataState',
        '[attr.data-disabled]': 'disabled',
        '[attr.data-orientation]': 'orientation'
    },
    providers: [
        { provide: RdxAccordionRootToken, useValue: undefined }]
})
export class RdxAccordionItemDirective implements FocusableOption, OnDestroy {
    protected readonly accordion = inject(RdxAccordionRootToken, { skipSelf: true });

    protected readonly changeDetectorRef = inject(ChangeDetectorRef);

    protected readonly expansionDispatcher = inject(UniqueSelectionDispatcher);

    /**
     * @ignore
     */
    @ContentChild(RdxAccordionTriggerDirective, { descendants: true }) trigger: RdxAccordionTriggerDirective;

    /**
     * @ignore
     */
    @ContentChild(forwardRef(() => RdxAccordionContentDirective), { descendants: true })
    content: RdxAccordionContentDirective;

    get dataState(): RdxAccordionItemState {
        return this.expanded ? 'open' : 'closed';
    }

    /**
     * The unique AccordionItem id.
     * @ignore
     */
    readonly id: string = `rdx-accordion-item-${nextId++}`;

    get orientation(): RdxAccordionOrientation {
        return this.accordion.orientation;
    }

    /**
     * @defaultValue false
     * @group Props
     */
    @Input({ transform: booleanAttribute })
    set expanded(expanded: boolean) {
        // Only emit events and update the internal value if the value changes.
        if (this._expanded !== expanded) {
            this._expanded = expanded;
            this.expandedChange.emit(expanded);

            if (expanded) {
                this.opened.emit();
                /**
                 * In the unique selection dispatcher, the id parameter is the id of the CdkAccordionItem,
                 * the name value is the id of the accordion.
                 */
                const accordionId = this.accordion ? this.accordion.id : this.value;
                this.expansionDispatcher.notify(this.value, accordionId);
            } else {
                this.closed.emit();
            }

            // Ensures that the animation will run when the value is set outside of an `@Input`.
            // This includes cases like the open, close and toggle methods.
            this.changeDetectorRef.markForCheck();
        }
    }

    get expanded(): boolean {
        return this._expanded;
    }

    private _expanded = false;

    /**
     * Accordion value.
     *
     * @group Props
     */
    @Input() set value(value: string) {
        this._value = value;
    }

    get value(): string {
        return this._value || this.id;
    }

    private _value?: string;

    /**
     * Whether the AccordionItem is disabled.
     *
     * @defaultValue false
     * @group Props
     */
    @Input({ transform: booleanAttribute }) set disabled(value: boolean) {
        this._disabled = value;
    }

    get disabled(): boolean {
        return this.accordion.disabled ?? this._disabled;
    }

    private _disabled = false;

    /**
     * Event emitted every time the AccordionItem is closed.
     */
    @Output() readonly closed: EventEmitter<void> = new EventEmitter<void>();

    /** Event emitted every time the AccordionItem is opened. */
    @Output() readonly opened: EventEmitter<void> = new EventEmitter<void>();

    /**
     * Event emitted when the AccordionItem is destroyed.
     * @ignore
     */
    readonly destroyed: EventEmitter<void> = new EventEmitter<void>();

    /**
     * Emits whenever the expanded state of the accordion changes.
     * Primarily used to facilitate two-way binding.
     * @group Emits
     */
    @Output() readonly expandedChange: EventEmitter<boolean> = new EventEmitter<boolean>();

    /** Unregister function for expansionDispatcher. */
    private removeUniqueSelectionListener: () => void;

    /** Subscription to openAll/closeAll events. */
    private openCloseAllSubscription = Subscription.EMPTY;

    constructor() {
        this.removeUniqueSelectionListener = this.expansionDispatcher.listen((id: string, accordionId: string) => {
            if (this.accordion.isMultiple) {
                if (this.accordion.id === accordionId && id.includes(this.value)) {
                    this.expanded = true;
                }
            } else {
                this.expanded = this.accordion.id === accordionId && id.includes(this.value);
            }
        });

        // When an accordion item is hosted in an accordion, subscribe to open/close events.
        if (this.accordion) {
            this.openCloseAllSubscription = this.subscribeToOpenCloseAllActions();
        }
    }

    /** Emits an event for the accordion item being destroyed. */
    ngOnDestroy() {
        this.opened.complete();
        this.closed.complete();
        this.destroyed.emit();
        this.destroyed.complete();
        this.removeUniqueSelectionListener();
        this.openCloseAllSubscription.unsubscribe();
    }

    focus(): void {
        this.trigger.focus();
    }

    /** Toggles the expanded state of the accordion item. */
    toggle(): void {
        if (!this.disabled) {
            this.content.onToggle();

            this.expanded = !this.expanded;
        }
    }

    /** Sets the expanded state of the accordion item to false. */
    close(): void {
        if (!this.disabled) {
            this.expanded = false;
        }
    }

    /** Sets the expanded state of the accordion item to true. */
    open(): void {
        if (!this.disabled) {
            this.expanded = true;
        }
    }

    private subscribeToOpenCloseAllActions(): Subscription {
        return this.accordion.openCloseAllActions.subscribe((expanded) => {
            // Only change expanded state if item is enabled
            if (!this.disabled) {
                this.expanded = expanded;
            }
        });
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/accordion/src/accordion-root.directive.ts
```typescript
import { FocusKeyManager } from '@angular/cdk/a11y';
import { Directionality } from '@angular/cdk/bidi';
import { UniqueSelectionDispatcher } from '@angular/cdk/collections';
import { ENTER, SPACE, TAB } from '@angular/cdk/keycodes';
import {
    AfterContentInit,
    booleanAttribute,
    ContentChildren,
    Directive,
    EventEmitter,
    forwardRef,
    inject,
    InjectionToken,
    Input,
    OnDestroy,
    Output,
    QueryList
} from '@angular/core';
import { merge, Subject, Subscription } from 'rxjs';
import { RdxAccordionItemDirective } from './accordion-item.directive';

export type RdxAccordionType = 'single' | 'multiple';
export type RdxAccordionOrientation = 'horizontal' | 'vertical';

export const RdxAccordionRootToken = new InjectionToken<RdxAccordionRootDirective>('RdxAccordionRootDirective');

let nextId = 0;

/**
 * @group Components
 */
@Directive({
    selector: '[rdxAccordionRoot]',
    standalone: true,
    providers: [
        { provide: RdxAccordionRootToken, useExisting: RdxAccordionRootDirective },
        { provide: UniqueSelectionDispatcher, useClass: UniqueSelectionDispatcher }
    ],
    host: {
        '[attr.data-orientation]': 'orientation',
        '(keydown)': 'handleKeydown($event)'
    }
})
export class RdxAccordionRootDirective implements AfterContentInit, OnDestroy {
    /**
     * @ignore
     */
    protected readonly selectionDispatcher = inject(UniqueSelectionDispatcher);
    /**
     * @ignore
     */
    protected readonly dir = inject(Directionality, { optional: true });

    /**
     * @ignore
     */
    protected keyManager: FocusKeyManager<RdxAccordionItemDirective>;

    /**
     * @ignore
     */
    readonly id: string = `rdx-accordion-${nextId++}`;

    /**
     * @ignore
     */
    readonly openCloseAllActions = new Subject<boolean>();

    get isMultiple(): boolean {
        return this.type === 'multiple';
    }

    /** Whether the Accordion is disabled.
     * @defaultValue false
     * @group Props
     */
    @Input({ transform: booleanAttribute }) disabled: boolean;

    /**
     * The orientation of the accordion.
     *
     * @defaultValue 'vertical'
     * @group Props
     */
    @Input() orientation: RdxAccordionOrientation = 'vertical';
    /**
     * @private
     * @ignore
     */
    @ContentChildren(forwardRef(() => RdxAccordionItemDirective), { descendants: true })
    items: QueryList<RdxAccordionItemDirective>;

    /**
     * The value of the item to expand when initially rendered and type is "single".
     * Use when you do not need to control the state of the items.
     * @group Props
     */
    @Input()
    set defaultValue(value: string[] | string) {
        if (value !== this._defaultValue) {
            this._defaultValue = Array.isArray(value) ? value : [value];
        }
    }

    get defaultValue(): string[] | string {
        return this.isMultiple ? this._defaultValue : this._defaultValue[0];
    }

    /**
     * Determines whether one or multiple items can be opened at the same time.
     * @group Props
     * @defaultValue 'single'
     */
    @Input() type: RdxAccordionType = 'single';

    /**
     * @ignore
     */
    @Input() collapsible = true;

    /**
     * The controlled value of the item to expand.
     *
     * @group Props
     */
    @Input()
    set value(value: string[] | string) {
        if (value !== this._value) {
            this._value = Array.isArray(value) ? value : [value];

            this.selectionDispatcher.notify(this.value as unknown as string, this.id);
        }
    }

    get value(): string[] | string {
        if (this._value === undefined) {
            return this.defaultValue;
        }

        return this.isMultiple ? this._value : this._value[0];
    }

    /**
     * Event handler called when the expanded state of an item changes and type is "multiple".
     * @group Emits
     */
    @Output() readonly onValueChange: EventEmitter<void> = new EventEmitter<void>();

    private _value?: string[];
    private _defaultValue: string[] | string = [];

    private onValueChangeSubscription: Subscription;

    /**
     * @ignore
     */
    ngAfterContentInit(): void {
        this.selectionDispatcher.notify((this._value ?? this._defaultValue) as unknown as string, this.id);

        this.keyManager = new FocusKeyManager(this.items).withHomeAndEnd();

        if (this.orientation === 'horizontal') {
            this.keyManager.withHorizontalOrientation(this.dir?.value || 'ltr');
        } else {
            this.keyManager.withVerticalOrientation();
        }

        this.onValueChangeSubscription = merge(...this.items.map((item) => item.expandedChange)).subscribe(() =>
            this.onValueChange.emit()
        );
    }

    /**
     * @ignore
     */
    ngOnDestroy() {
        this.openCloseAllActions.complete();
        this.onValueChangeSubscription.unsubscribe();
    }

    /**
     * @ignore
     */
    handleKeydown(event: KeyboardEvent) {
        if (!this.keyManager.activeItem) {
            this.keyManager.setFirstItemActive();
        }

        const activeItem = this.keyManager.activeItem;

        if (
            (event.keyCode === ENTER || event.keyCode === SPACE) &&
            !this.keyManager.isTyping() &&
            activeItem &&
            !activeItem.disabled
        ) {
            event.preventDefault();
            activeItem.toggle();
        } else if (event.keyCode === TAB && event.shiftKey) {
            if (this.keyManager.activeItemIndex === 0) return;

            this.keyManager.setPreviousItemActive();
            event.preventDefault();
        } else if (event.keyCode === TAB) {
            if (this.keyManager.activeItemIndex === this.items.length - 1) return;

            this.keyManager.setNextItemActive();
            event.preventDefault();
        } else {
            this.keyManager.onKeydown(event);
        }
    }

    /** Opens all enabled accordion items in an accordion where multi is enabled.
     * @ignore
     */
    openAll(): void {
        if (this.isMultiple) {
            this.openCloseAllActions.next(true);
        }
    }

    /** Closes all enabled accordion items.
     * @ignore
     */
    closeAll(): void {
        this.openCloseAllActions.next(false);
    }

    /**
     * @ignore
     */
    setActiveItem(item: RdxAccordionItemDirective) {
        this.keyManager.setActiveItem(item);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/accordion/src/accordion-trigger.directive.ts
```typescript
import { Directive, ElementRef, inject } from '@angular/core';
import { RdxAccordionItemDirective } from './accordion-item.directive';
import { RdxAccordionRootDirective } from './accordion-root.directive';

@Directive({
    selector: '[rdxAccordionTrigger]',
    standalone: true,
    host: {
        '[attr.role]': '"button"',
        '[attr.aria-expanded]': 'item.expanded',
        '[attr.data-state]': 'item.dataState',
        '[attr.data-disabled]': 'item.disabled',
        '[attr.disabled]': 'item.disabled ? "" : null',
        '[attr.data-orientation]': 'item.orientation',
        '(click)': 'onClick()'
    }
})
export class RdxAccordionTriggerDirective {
    protected readonly nativeElement = inject(ElementRef).nativeElement;
    protected readonly accordionRoot = inject(RdxAccordionRootDirective);
    protected readonly item = inject(RdxAccordionItemDirective);

    /**
     * Fires when trigger clicked
     */
    onClick(): void {
        if (!this.accordionRoot.collapsible && this.item.expanded) return;

        this.item.toggle();

        this.accordionRoot.setActiveItem(this.item);
    }

    focus() {
        this.nativeElement.focus();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/separator/README.md
```
# @radix-ng/primitives/separator

Secondary entry point of `@radix-ng/primitives`.

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/separator/index.ts
```typescript
export * from './src/separator.directive';

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/separator/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/separator/stories/separator.docs.mdx
````
import { ArgTypes, Canvas, Meta } from '@storybook/blocks';
import { RdxSeparatorRootDirective } from '../src/separator.directive';
import * as SeparatorDirectiveStories from './separator.stories';

<Meta title="Primitives/Separator" />

# Separator

#### Visually or semantically separates content.

<Canvas sourceState="hidden" of={SeparatorDirectiveStories.Default} />

## Features

- âœ… Supports horizontal and vertical orientations.

## Usage

Get started with importing the directive:

```typescript
import { RdxSeparatorRootDirective } from '@radix-ng/primitives/separator';
```

## Examples

```html
<div rdxSeparatorRoot decorative="decorative" orientation="vertical"></div>
```

## API Reference

<ArgTypes of={RdxSeparatorRootDirective} />

## Accessibility

Adheres to the [`separator` role requirements](https://www.w3.org/TR/wai-aria-1.2/#separator).

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/separator/stories/separator.stories.ts
```typescript
import { CommonModule } from '@angular/common';
import { componentWrapperDecorator, moduleMetadata } from '@storybook/angular';
import { RdxSeparatorRootDirective } from '../src/separator.directive';

const html = String.raw;

export default {
    component: RdxSeparatorRootDirective,
    title: 'Primitives/Separator',
    decorators: [
        moduleMetadata({
            imports: [RdxSeparatorRootDirective, CommonModule]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div class="radix-themes light light-theme" data-radius="medium" data-scaling="100%">${story}</div>
            `
        )
    ]
};

export const Default = {
    render: () => ({
        template: html`
            <style>
                .SeparatorRoot {
                    background-color: var(--violet-6);
                }

                .SeparatorRoot[data-orientation='horizontal'] {
                    height: 1px;
                    width: 100%;
                }

                .SeparatorRoot[data-orientation='vertical'] {
                    height: 100%;
                    width: 1px;
                }

                .Text {
                    color: white;
                    font-size: 15px;
                    line-height: 20px;
                }
            </style>
            <div style="width: 100%; max-width: 300px; margin: 0 15px;">
                <div class="Text">Radix Primitives</div>
                <div class="Text" style="font-weight: 500;">An open-source UI component library.</div>
                <div class="SeparatorRoot" rdxSeparatorRoot style="margin: 15px 0;"></div>
                <div style="display: flex; height: 1.25rem; align-items: center;">
                    <div class="Text">Blog</div>
                    <div
                        class="SeparatorRoot"
                        rdxSeparatorRoot
                        decorative="decorative"
                        orientation="vertical"
                        style="margin: 0 15px;"
                    ></div>
                    <div class="Text">Docs</div>
                    <div
                        class="SeparatorRoot"
                        rdxSeparatorRoot
                        decorative="decorative"
                        orientation="vertical"
                        style="margin: 0 15px;"
                    ></div>
                    <div class="Text">Source</div>
                </div>
            </div>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/separator/__tests__/separator.directive.spec.ts
```typescript
import { Component } from '@angular/core';
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { Orientation, RdxSeparatorRootDirective } from '../src/separator.directive';

@Component({
    template: '<div rdxSeparatorRoot [orientation]="orientation" [decorative]="decorative"></div>',
    imports: [RdxSeparatorRootDirective]
})
class TestHostComponent {
    orientation: Orientation = 'horizontal';
    decorative = false;
}

describe('SeparatorDirective', () => {
    let fixture: ComponentFixture<TestHostComponent>;
    let element: HTMLElement;

    beforeEach(() => {
        TestBed.configureTestingModule({
            imports: [TestHostComponent]
        });
        fixture = TestBed.createComponent(TestHostComponent);
        element = fixture.nativeElement.querySelector('div');
    });

    it('should set default role to "separator"', () => {
        fixture.detectChanges();
        expect(element.getAttribute('role')).toBe('separator');
    });

    it('should set role to "none" if decorative is true', () => {
        fixture.componentInstance.decorative = true;
        fixture.detectChanges();
        expect(element.getAttribute('role')).toBe('none');
    });

    it('should not set aria-orientation if orientation is horizontal', () => {
        fixture.componentInstance.orientation = 'horizontal';
        fixture.detectChanges();
        expect(element.getAttribute('aria-orientation')).toBeNull();
    });

    it('should set aria-orientation to "vertical" if orientation is vertical and decorative is false', () => {
        fixture.componentInstance.orientation = 'vertical';
        fixture.detectChanges();
        expect(element.getAttribute('aria-orientation')).toBe('vertical');
    });

    it('should not set aria-orientation if decorative is true', () => {
        fixture.componentInstance.orientation = 'vertical';
        fixture.componentInstance.decorative = true;
        fixture.detectChanges();
        expect(element.getAttribute('aria-orientation')).toBeNull();
    });

    it('should set data-orientation based on the orientation input', () => {
        fixture.componentInstance.orientation = 'vertical';
        fixture.detectChanges();
        expect(element.getAttribute('data-orientation')).toBe('vertical');

        fixture.componentInstance.orientation = 'horizontal';
        fixture.detectChanges();
        expect(element.getAttribute('data-orientation')).toBe('horizontal');
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/separator/src/separator.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { booleanAttribute, computed, Directive, input, linkedSignal } from '@angular/core';

const DEFAULT_ORIENTATION = 'horizontal';

// eslint-disable-next-line @typescript-eslint/no-unused-vars
const ORIENTATIONS = ['horizontal', 'vertical'] as const;

export type Orientation = (typeof ORIENTATIONS)[number];

export interface SeparatorProps {
    /**
     * Either `vertical` or `horizontal`. Defaults to `horizontal`.
     */
    orientation?: Orientation;
    /**
     * Whether the component is purely decorative. When true, accessibility-related attributes
     * are updated so that the rendered element is removed from the accessibility tree.
     */
    decorative?: boolean;
}

/**
 * Directive that adds accessible and configurable separator element to the DOM.
 * This can be either horizontal or vertical and optionally decorative (which removes
 * it from the accessibility tree).
 *
 * @group Components
 */
@Directive({
    selector: 'div[rdxSeparatorRoot]',
    host: {
        '[attr.role]': 'decorativeEffect() ? "none" : "separator"',
        '[attr.aria-orientation]': 'computedAriaOrientation()',

        '[attr.data-orientation]': 'orientationEffect()'
    }
})
export class RdxSeparatorRootDirective {
    /**
     * Orientation of the separator, can be either 'horizontal' or 'vertical'.
     *
     * @defaultValue 'horizontal'
     * @group Props
     */
    readonly orientation = input<Orientation>(DEFAULT_ORIENTATION);

    /**
     * If true, the separator will be considered decorative and removed from
     * the accessibility tree. Defaults to false.
     *
     * @defaultValue false
     * @group Props
     */
    readonly decorative = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * Computes the `role` attribute for the separator. If `decorative` is true,
     * the role is set to "none", otherwise it is "separator".
     *
     * @ignore
     */
    protected readonly decorativeEffect = linkedSignal({
        source: this.decorative,
        computation: (value) => value
    });

    protected readonly orientationEffect = linkedSignal({
        source: this.orientation,
        computation: (value) => value
    });

    /**
     * Computes the `aria-orientation` attribute. It is set to "vertical" only if
     * the separator is not decorative and the orientation is set to "vertical".
     * For horizontal orientation, the attribute is omitted.
     *
     * @ignore
     */
    protected readonly computedAriaOrientation = computed(() =>
        !this.decorativeEffect() && this.orientationEffect() === 'vertical' ? 'vertical' : undefined
    );

    updateOrientation(value: Orientation) {
        this.orientationEffect.set(value);
    }

    updateDecorative(value: boolean) {
        this.decorativeEffect.set(value);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toolbar/README.md
```
# @radix-ng/primitives/toolbar

Secondary entry point of `@radix-ng/primitives/toolbar`.

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toolbar/index.ts
```typescript
import { NgModule } from '@angular/core';
import { RdxToolbarButtonDirective } from './src/toolbar-button.directive';
import { RdxToolbarLinkDirective } from './src/toolbar-link.directive';
import { RdxToolbarRootDirective } from './src/toolbar-root.directive';
import { RdxToolbarSeparatorDirective } from './src/toolbar-separator.directive';
import { RdxToolbarToggleGroupDirective } from './src/toolbar-toggle-group.directive';
import { RdxToolbarToggleItemDirective } from './src/toolbar-toggle-item.directive';

export * from './src/toolbar-button.directive';
export * from './src/toolbar-link.directive';
export * from './src/toolbar-root.directive';
export * from './src/toolbar-root.token';
export * from './src/toolbar-separator.directive';
export * from './src/toolbar-toggle-group.directive';
export * from './src/toolbar-toggle-item.directive';

const _imports = [
    RdxToolbarRootDirective,
    RdxToolbarButtonDirective,
    RdxToolbarLinkDirective,
    RdxToolbarToggleGroupDirective,
    RdxToolbarToggleItemDirective,
    RdxToolbarSeparatorDirective
];

@NgModule({
    imports: [..._imports],
    exports: [..._imports]
})
export class RdxToolbarModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toolbar/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toolbar/stories/toolbar.docs.mdx
```
import { ArgTypes, Canvas, Markdown, Meta } from '@storybook/blocks';
import * as ToolbarStories from './toolbar.stories';

<Meta title="Primitives/Toolbar" />

# Toolbar

####  A container for grouping a set of controls, such as buttons, Toolbar groups or dropdown menus.

<Canvas sourceState="hidden" of={ToolbarStories.Default} />

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toolbar/stories/toolbar.stories.ts
```typescript
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { AlignCenter, AlignLeft, AlignRight, Bold, Italic, LucideAngularModule, Strikethrough } from 'lucide-angular';
import { RdxToolbarButtonDirective } from '../src/toolbar-button.directive';
import { RdxToolbarLinkDirective } from '../src/toolbar-link.directive';
import { RdxToolbarRootDirective } from '../src/toolbar-root.directive';
import { RdxToolbarSeparatorDirective } from '../src/toolbar-separator.directive';
import { RdxToolbarToggleGroupDirective } from '../src/toolbar-toggle-group.directive';
import { RdxToolbarToggleItemDirective } from '../src/toolbar-toggle-item.directive';

const html = String.raw;

export default {
    title: 'Primitives/Toolbar',
    decorators: [
        moduleMetadata({
            imports: [
                RdxToolbarRootDirective,
                RdxToolbarSeparatorDirective,
                RdxToolbarLinkDirective,
                RdxToolbarButtonDirective,
                RdxToolbarToggleGroupDirective,
                RdxToolbarToggleItemDirective,
                LucideAngularModule,
                LucideAngularModule.pick({ Italic, Bold, Strikethrough, AlignLeft, AlignCenter, AlignRight })
            ]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div class="radix-themes light light-theme" data-radius="medium" data-scaling="100%">
                    ${story}

                    <style>
                        a,
                        button {
                            all: unset;
                        }

                        .ToolbarRoot {
                            display: flex;
                            padding: 10px;
                            width: 100%;
                            min-width: max-content;
                            border-radius: 6px;
                            background-color: white;
                            box-shadow: 0 2px 10px var(--black-a7);
                        }

                        .ToolbarToggleItem,
                        .ToolbarLink,
                        .ToolbarButton {
                            flex: 0 0 auto;
                            color: var(--mauve-11);
                            height: 25px;
                            padding: 0 5px;
                            border-radius: 4px;
                            display: inline-flex;
                            font-size: 13px;
                            line-height: 1;
                            align-items: center;
                            justify-content: center;
                        }

                        .ToolbarToggleItem:hover,
                        .ToolbarLink:hover,
                        .ToolbarButton:hover {
                            background-color: var(--violet-3);
                            color: var(--violet-11);
                        }

                        .ToolbarToggleItem:focus,
                        .ToolbarLink:focus,
                        .ToolbarButton:focus {
                            position: relative;
                            box-shadow: 0 0 0 2px var(--violet-7);
                        }

                        .ToolbarToggleItem {
                            background-color: white;
                            margin-left: 2px;
                        }

                        .ToolbarToggleItem:first-child {
                            margin-left: 0;
                        }

                        .ToolbarToggleItem[data-state='on'] {
                            background-color: var(--violet-5);
                            color: var(--violet-11);
                        }

                        .ToolbarSeparator {
                            width: 1px;
                            background-color: var(--mauve-6);
                            margin: 0 10px;
                        }

                        .ToolbarLink {
                            background-color: transparent;
                            color: var(--mauve-11);
                            display: none;
                            justify-content: center;
                            align-items: center;
                        }

                        .ToolbarLink:hover {
                            background-color: transparent;
                            cursor: pointer;
                        }

                        @media (min-width: 520px) {
                            .ToolbarLink {
                                display: inline-flex;
                            }
                        }

                        .ToolbarButton {
                            padding-left: 10px;
                            padding-right: 10px;
                            color: white;
                            background-color: var(--violet-9);
                        }

                        .ToolbarButton:hover {
                            background-color: var(--violet-10);
                            color: white;
                        }
                    </style>
                </div>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: html`
            <div style="display: flex; flex:1;max-width:600px">
                <div class="ToolbarRoot" rdxToolbarRoot aria-label="Formatting options">
                    <div rdxToolbarToggleGroup orientation="horizontal" type="multiple" aria-label="Text formatting">
                        <button class="ToolbarToggleItem" rdxToolbarToggleItem value="bold" aria-label="Bold">
                            <lucide-angular name="bold" size="16" strokeWidth="2" style="display: flex" />
                        </button>
                        <button class="ToolbarToggleItem" rdxToolbarToggleItem value="italic" aria-label="Italic">
                            <lucide-angular name="italic" size="16" strokeWidth="2" style="display: flex" />
                        </button>
                        <button
                            class="ToolbarToggleItem"
                            rdxToolbarToggleItem
                            value="strikethrough"
                            aria-label="Strike through"
                        >
                            <lucide-angular name="Strikethrough" size="16" strokeWidth="2" style="display: flex" />
                        </button>
                    </div>
                    <div class="ToolbarSeparator" rdxToolbarSeparator></div>
                    <div rdxToolbarToggleGroup type="single" aria-label="Text alignment">
                        <button class="ToolbarToggleItem" rdxToolbarToggleItem value="left" aria-label="Left aligned">
                            <lucide-angular name="align-left" size="16" strokeWidth="1" style="display: flex" />
                        </button>
                        <button
                            class="ToolbarToggleItem"
                            rdxToolbarToggleItem
                            value="center"
                            aria-label="Center aligned"
                        >
                            <lucide-angular name="align-center" size="16" strokeWidth="1" style="display: flex" />
                        </button>
                        <button class="ToolbarToggleItem" rdxToolbarToggleItem value="right" aria-label="Right aligned">
                            <lucide-angular name="align-right" size="16" strokeWidth="1" style="display: flex" />
                        </button>
                    </div>
                    <div class="ToolbarSeparator" rdxToolbarSeparator orientation="vertical"></div>
                    <a class="ToolbarLink" href="#" rdxToolbarLink target="_blank" style="margin-right: 10px;">
                        Edited 2 hours ago
                    </a>
                    <button class="ToolbarButton" rdxToolbarButton style="margin-left: auto;">Share</button>
                </div>
            </div>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toolbar/src/toolbar-button.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { booleanAttribute, Directive, effect, inject, input, signal } from '@angular/core';
import { RdxRovingFocusItemDirective } from '@radix-ng/primitives/roving-focus';

@Directive({
    selector: '[rdxToolbarButton]',
    hostDirectives: [{ directive: RdxRovingFocusItemDirective, inputs: ['focusable'] }]
})
export class RdxToolbarButtonDirective {
    private readonly rdxRovingFocusItemDirective = inject(RdxRovingFocusItemDirective);

    readonly disabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    private readonly isDisabled = signal(this.disabled());

    #disableChanges = effect(() => {
        this.rdxRovingFocusItemDirective.focusable = !this.isDisabled();
    });
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toolbar/src/toolbar-link.directive.ts
```typescript
import { Directive } from '@angular/core';
import { RdxRovingFocusItemDirective } from '@radix-ng/primitives/roving-focus';

@Directive({
    selector: '[rdxToolbarLink]',
    hostDirectives: [{ directive: RdxRovingFocusItemDirective, inputs: ['focusable'] }],
    host: {
        '(keydown)': 'onKeyDown($event)'
    }
})
export class RdxToolbarLinkDirective {
    onKeyDown($event: KeyboardEvent) {
        if ($event.key === ' ') ($event.currentTarget as HTMLElement)?.click();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toolbar/src/toolbar-root.directive.ts
```typescript
import { Directive, input } from '@angular/core';
import { RdxRovingFocusGroupDirective } from '@radix-ng/primitives/roving-focus';
import { provideRootContext } from './toolbar-root.token';

@Directive({
    selector: '[rdxToolbarRoot]',
    hostDirectives: [{ directive: RdxRovingFocusGroupDirective, inputs: ['dir', 'orientation', 'loop'] }],
    providers: [provideRootContext()],
    host: {
        role: 'toolbar',
        '[attr.aria-orientation]': 'orientation()'
    }
})
export class RdxToolbarRootDirective {
    readonly orientation = input<'horizontal' | 'vertical'>('horizontal');
    readonly dir = input<'ltr' | 'rtl'>('ltr');
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toolbar/src/toolbar-root.token.ts
```typescript
import { inject, InjectionToken, Provider } from '@angular/core';
import { RdxToolbarRootDirective } from './toolbar-root.directive';

export const RDX_TOOLBAR_ROOT_TOKEN = new InjectionToken<RdxToolbarRootDirective>('RdxToolbarRootDirective');

export function injectRootContext(): RdxToolbarRootDirective {
    return inject(RDX_TOOLBAR_ROOT_TOKEN);
}

export function provideRootContext(): Provider {
    return {
        provide: RDX_TOOLBAR_ROOT_TOKEN,
        useExisting: RdxToolbarRootDirective
    };
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toolbar/src/toolbar-separator.directive.ts
```typescript
import { Directive } from '@angular/core';
import { RdxSeparatorRootDirective } from '@radix-ng/primitives/separator';

@Directive({
    selector: '[rdxToolbarSeparator]',
    hostDirectives: [{ directive: RdxSeparatorRootDirective, inputs: ['orientation', 'decorative'] }]
})
export class RdxToolbarSeparatorDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toolbar/src/toolbar-toggle-group.directive.ts
```typescript
import { Directive } from '@angular/core';
import { RdxToggleGroupWithoutFocusDirective } from '@radix-ng/primitives/toggle-group';

// TODO: set rovingFocus - false
@Directive({
    selector: '[rdxToolbarToggleGroup]',
    hostDirectives: [{ directive: RdxToggleGroupWithoutFocusDirective, inputs: ['value', 'type', 'disabled'] }]
})
export class RdxToolbarToggleGroupDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toolbar/src/toolbar-toggle-item.directive.ts
```typescript
import { Directive } from '@angular/core';
import { RdxToggleGroupItemDirective } from '@radix-ng/primitives/toggle-group';

@Directive({
    selector: '[rdxToolbarToggleItem]',
    hostDirectives: [{ directive: RdxToggleGroupItemDirective, inputs: ['value', 'disabled'] }]
})
export class RdxToolbarToggleItemDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/README.md
```
# @radix-ng/primitives/hover-card

Secondary entry point of `@radix-ng/primitives`. It can be used by importing from `@radix-ng/primitives/hover-card`.

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/index.ts
```typescript
import { NgModule } from '@angular/core';
import { RdxHoverCardAnchorDirective } from './src/hover-card-anchor.directive';
import { RdxHoverCardArrowDirective } from './src/hover-card-arrow.directive';
import { RdxHoverCardCloseDirective } from './src/hover-card-close.directive';
import { RdxHoverCardContentAttributesComponent } from './src/hover-card-content-attributes.component';
import { RdxHoverCardContentDirective } from './src/hover-card-content.directive';
import { RdxHoverCardRootDirective } from './src/hover-card-root.directive';
import { RdxHoverCardTriggerDirective } from './src/hover-card-trigger.directive';

export * from './src/hover-card-anchor.directive';
export * from './src/hover-card-arrow.directive';
export * from './src/hover-card-close.directive';
export * from './src/hover-card-content-attributes.component';
export * from './src/hover-card-content.directive';
export * from './src/hover-card-root.directive';
export * from './src/hover-card-trigger.directive';

const _imports = [
    RdxHoverCardArrowDirective,
    RdxHoverCardCloseDirective,
    RdxHoverCardContentDirective,
    RdxHoverCardTriggerDirective,
    RdxHoverCardRootDirective,
    RdxHoverCardAnchorDirective,
    RdxHoverCardContentAttributesComponent
];

@NgModule({
    imports: [..._imports],
    exports: [..._imports]
})
export class RdxHoverCardModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/stories/hover-card-anchor.component.ts
```typescript
import { Component, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { LucideAngularModule, MapPin, MapPinPlus, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxHoverCardModule } from '../index';
import { RdxHoverCardAnchorDirective } from '../src/hover-card-anchor.directive';
import { RdxHoverCardContentAttributesComponent } from '../src/hover-card-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-hover-card-anchor',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxHoverCardModule,
        LucideAngularModule,
        RdxHoverCardContentAttributesComponent,
        WithOptionPanelComponent,
        RdxHoverCardAnchorDirective
    ],
    styles: styles(),
    template: `
        <p class="ExampleSubtitle">Internal Anchor (within HoverCardRoot)</p>
        <with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container
                    #root1="rdxHoverCardRoot"
                    [openDelay]="openDelay()"
                    [closeDelay]="closeDelay()"
                    rdxHoverCardRoot
                >
                    <button class="reset IconButton InternalAnchor" rdxHoverCardAnchor>
                        <lucide-angular [img]="LucideMapPinPlusInside" size="16" style="display: flex" />
                    </button>

                    <a
                        class="reset ImageTrigger"
                        href="https://twitter.com/radix_ui"
                        target="_blank"
                        rel="noreferrer noopener"
                        rdxHoverCardTrigger
                    >
                        <img
                            class="Image normal"
                            src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                            alt="Radix UI"
                        />
                    </a>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxHoverCardContent
                    >
                        <div class="HoverCardContent" rdxHoverCardContentAttributes>
                            <button class="reset HoverCardClose" rdxHoverCardClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div style="display: flex; flex-direction: column; gap: 7px">
                                <img
                                    class="Image large"
                                    src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                                    alt="Radix UI"
                                />
                                <div style="display: flex; flex-direction: column; gap: 15px;">
                                    <div>
                                        <div class="Text bold">Radix</div>
                                        <div class="Text faded">{{ '@radix_ui' }}</div>
                                    </div>
                                    <div class="Text">
                                        Components, icons, colors, and templates for building high-quality, accessible
                                        UI. Free and open-source.
                                    </div>
                                    <div style="display: flex; gap: 15px">
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">0</div>
                                            &nbsp;
                                            <div class="Text faded">Following</div>
                                        </div>
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">2,900</div>
                                            &nbsp;
                                            <div class="Text faded">Followers</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div
                                class="HoverCardArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxHoverCardArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="HoverCardId">ID: {{ rootDirective1()?.uniqueId() }}</div>
        </with-option-panel>

        <p class="ExampleSubtitle">External Anchor (outside HoverCardRoot)</p>
        <with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <button class="reset IconButton ExternalAnchor" #externalAnchor="rdxHoverCardAnchor" rdxHoverCardAnchor>
                    <lucide-angular [img]="LucideMapPinPlus" size="16" style="display: flex" />
                </button>

                <ng-container
                    #root2="rdxHoverCardRoot"
                    [anchor]="externalAnchor"
                    [openDelay]="openDelay()"
                    [closeDelay]="closeDelay()"
                    rdxHoverCardRoot
                >
                    <a
                        class="reset ImageTrigger"
                        href="https://twitter.com/radix_ui"
                        target="_blank"
                        rel="noreferrer noopener"
                        rdxHoverCardTrigger
                    >
                        <img
                            class="Image normal"
                            src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                            alt="Radix UI"
                        />
                    </a>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxHoverCardContent
                    >
                        <div class="HoverCardContent" rdxHoverCardContentAttributes>
                            <button class="reset HoverCardClose" rdxHoverCardClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div style="display: flex; flex-direction: column; gap: 7px">
                                <img
                                    class="Image large"
                                    src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                                    alt="Radix UI"
                                />
                                <div style="display: flex; flex-direction: column; gap: 15px;">
                                    <div>
                                        <div class="Text bold">Radix</div>
                                        <div class="Text faded">{{ '@radix_ui' }}</div>
                                    </div>
                                    <div class="Text">
                                        Components, icons, colors, and templates for building high-quality, accessible
                                        UI. Free and open-source.
                                    </div>
                                    <div style="display: flex; gap: 15px">
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">0</div>
                                            &nbsp;
                                            <div class="Text faded">Following</div>
                                        </div>
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">2,900</div>
                                            &nbsp;
                                            <div class="Text faded">Followers</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div
                                class="HoverCardArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxHoverCardArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="HoverCardId">ID: {{ rootDirective2()?.uniqueId() }}</div>
        </with-option-panel>
    `
})
export class RdxHoverCardAnchorComponent extends OptionPanelBase {
    readonly rootDirective1 = viewChild('root1');
    readonly rootDirective2 = viewChild('root2');

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;
    readonly LucideMapPinPlusInside = MapPinPlus;
    readonly LucideMapPinPlus = MapPin;
    readonly TriangleAlert = TriangleAlert;
    readonly containerAlert = containerAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/stories/hover-card-animations.component.ts
```typescript
import { Component, signal, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { RdxPositionAlign, RdxPositionSide } from '@radix-ng/primitives/core';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxHoverCardModule, RdxHoverCardRootDirective } from '../index';
import { RdxHoverCardContentAttributesComponent } from '../src/hover-card-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-hover-card-animations',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxHoverCardModule,
        LucideAngularModule,
        RdxHoverCardContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: styles(true),
    template: `
        <with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ParamsContainer">
                <input [ngModel]="cssAnimation()" (ngModelChange)="cssAnimation.set($event)" type="checkbox" />
                CSS Animation
                <input
                    [ngModel]="cssOpeningAnimation()"
                    (ngModelChange)="cssOpeningAnimation.set($event)"
                    type="checkbox"
                />
                On Opening Animation
                <input
                    [ngModel]="cssClosingAnimation()"
                    (ngModelChange)="cssClosingAnimation.set($event)"
                    type="checkbox"
                />
                On Closing Animation
            </div>

            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container
                    [cssAnimation]="cssAnimation()"
                    [cssOpeningAnimation]="cssOpeningAnimation()"
                    [cssClosingAnimation]="cssClosingAnimation()"
                    [openDelay]="openDelay()"
                    [closeDelay]="closeDelay()"
                    rdxHoverCardRoot
                >
                    <a
                        class="reset ImageTrigger"
                        href="https://twitter.com/radix_ui"
                        target="_blank"
                        rel="noreferrer noopener"
                        rdxHoverCardTrigger
                    >
                        <img
                            class="Image normal"
                            src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                            alt="Radix UI"
                        />
                    </a>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxHoverCardContent
                    >
                        <div class="HoverCardContent" rdxHoverCardContentAttributes>
                            <button class="HoverCardClose reset" rdxHoverCardClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div style="display: flex; flex-direction: column; gap: 7px">
                                <img
                                    class="Image large"
                                    src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                                    alt="Radix UI"
                                />
                                <div style="display: flex; flex-direction: column; gap: 15px;">
                                    <div>
                                        <div class="Text bold">Radix</div>
                                        <div class="Text faded">{{ '@radix_ui' }}</div>
                                    </div>
                                    <div class="Text">
                                        Components, icons, colors, and templates for building high-quality, accessible
                                        UI. Free and open-source.
                                    </div>
                                    <div style="display: flex; gap: 15px">
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">0</div>
                                            &nbsp;
                                            <div class="Text faded">Following</div>
                                        </div>
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">2,900</div>
                                            &nbsp;
                                            <div class="Text faded">Followers</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div
                                class="HoverCardArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxHoverCardArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="HoverCardId">ID: {{ rootDirective()?.uniqueId() }}</div>
        </with-option-panel>
    `
})
export class RdxHoverCardAnimationsComponent extends OptionPanelBase {
    readonly rootDirective = viewChild(RdxHoverCardRootDirective);

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;

    readonly sides = RdxPositionSide;
    readonly aligns = RdxPositionAlign;

    cssAnimation = signal<boolean>(true);
    cssOpeningAnimation = signal(true);
    cssClosingAnimation = signal(true);
    protected readonly TriangleAlert = TriangleAlert;
    protected readonly containerAlert = containerAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/stories/hover-card-default.component.ts
```typescript
import { Component, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxHoverCardModule, RdxHoverCardRootDirective } from '../index';
import { RdxHoverCardContentAttributesComponent } from '../src/hover-card-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-hover-card-default',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxHoverCardModule,
        LucideAngularModule,
        RdxHoverCardContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: styles(),
    template: `
        <with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container [openDelay]="openDelay()" [closeDelay]="closeDelay()" rdxHoverCardRoot>
                    <a
                        class="reset ImageTrigger"
                        href="https://twitter.com/radix_ui"
                        target="_blank"
                        rel="noreferrer noopener"
                        rdxHoverCardTrigger
                    >
                        <img
                            class="Image normal"
                            src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                            alt="Radix UI"
                        />
                    </a>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxHoverCardContent
                    >
                        <div class="HoverCardContent" rdxHoverCardContentAttributes>
                            <button class="reset HoverCardClose" rdxHoverCardClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div style="display: flex; flex-direction: column; gap: 7px">
                                <img
                                    class="Image large"
                                    src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                                    alt="Radix UI"
                                />
                                <div style="display: flex; flex-direction: column; gap: 15px;">
                                    <div>
                                        <div class="Text bold">Radix</div>
                                        <div class="Text faded">{{ '@radix_ui' }}</div>
                                    </div>
                                    <div class="Text">
                                        Components, icons, colors, and templates for building high-quality, accessible
                                        UI. Free and open-source.
                                    </div>
                                    <div style="display: flex; gap: 15px">
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">0</div>
                                            &nbsp;
                                            <div class="Text faded">Following</div>
                                        </div>
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">2,900</div>
                                            &nbsp;
                                            <div class="Text faded">Followers</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div
                                class="HoverCardArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxHoverCardArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="HoverCardId">ID: {{ rootDirective()?.uniqueId() }}</div>
        </with-option-panel>
    `
})
export class RdxHoverCardDefaultComponent extends OptionPanelBase {
    readonly rootDirective = viewChild(RdxHoverCardRootDirective);

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;
    protected readonly TriangleAlert = TriangleAlert;
    protected readonly containerAlert = containerAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/stories/hover-card-events.components.ts
```typescript
import { Component, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { RdxPositionAlign, RdxPositionSide } from '@radix-ng/primitives/core';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxHoverCardModule, RdxHoverCardRootDirective } from '../index';
import { RdxHoverCardContentAttributesComponent } from '../src/hover-card-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-hover-card-events',
    providers: [provideRdxCdkEventService()],
    imports: [
        RdxHoverCardModule,
        LucideAngularModule,
        FormsModule,
        RdxHoverCardContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: `
        ${styles()}
    `,
    template: `
        <with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container [openDelay]="openDelay()" [closeDelay]="closeDelay()" rdxHoverCardRoot>
                    <a
                        class="reset ImageTrigger"
                        href="https://twitter.com/radix_ui"
                        target="_blank"
                        rel="noreferrer noopener"
                        rdxHoverCardTrigger
                    >
                        <img
                            class="Image normal"
                            src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                            alt="Radix UI"
                        />
                    </a>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        [sideOffset]="8"
                        rdxHoverCardContent
                    >
                        <div class="HoverCardContent" rdxHoverCardContentAttributes>
                            <button class="reset HoverCardClose" rdxHoverCardClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div style="display: flex; flex-direction: column; gap: 7px">
                                <img
                                    class="Image large"
                                    src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                                    alt="Radix UI"
                                />
                                <div style="display: flex; flex-direction: column; gap: 15px;">
                                    <div>
                                        <div class="Text bold">Radix</div>
                                        <div class="Text faded">{{ '@radix_ui' }}</div>
                                    </div>
                                    <div class="Text">
                                        Components, icons, colors, and templates for building high-quality, accessible
                                        UI. Free and open-source.
                                    </div>
                                    <div style="display: flex; gap: 15px">
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">0</div>
                                            &nbsp;
                                            <div class="Text faded">Following</div>
                                        </div>
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">2,900</div>
                                            &nbsp;
                                            <div class="Text faded">Followers</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div
                                class="HoverCardArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxHoverCardArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="HoverCardId">ID: {{ rootDirective()?.uniqueId() }}</div>
        </with-option-panel>
    `
})
export class RdxHoverCardEventsComponent extends OptionPanelBase {
    readonly rootDirective = viewChild(RdxHoverCardRootDirective);

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;

    protected readonly sides = RdxPositionSide;
    protected readonly aligns = RdxPositionAlign;
    protected readonly containerAlert = containerAlert;
    protected readonly TriangleAlert = TriangleAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/stories/hover-card-initially-open.component.ts
```typescript
import { Component, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxHoverCardModule, RdxHoverCardRootDirective } from '../index';
import { RdxHoverCardContentAttributesComponent } from '../src/hover-card-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-hover-card-initially-open',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxHoverCardModule,
        LucideAngularModule,
        RdxHoverCardContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: styles(),
    template: `
        <with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container
                    [defaultOpen]="true"
                    [openDelay]="openDelay()"
                    [closeDelay]="closeDelay()"
                    rdxHoverCardRoot
                >
                    <a
                        class="reset ImageTrigger"
                        href="https://twitter.com/radix_ui"
                        target="_blank"
                        rel="noreferrer noopener"
                        rdxHoverCardTrigger
                    >
                        <img
                            class="Image normal"
                            src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                            alt="Radix UI"
                        />
                    </a>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        [sideOffset]="8"
                        rdxHoverCardContent
                    >
                        <div class="HoverCardContent" rdxHoverCardContentAttributes>
                            <button class="reset HoverCardClose" rdxHoverCardClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div style="display: flex; flex-direction: column; gap: 7px">
                                <img
                                    class="Image large"
                                    src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                                    alt="Radix UI"
                                />
                                <div style="display: flex; flex-direction: column; gap: 15px;">
                                    <div>
                                        <div class="Text bold">Radix</div>
                                        <div class="Text faded">{{ '@radix_ui' }}</div>
                                    </div>
                                    <div class="Text">
                                        Components, icons, colors, and templates for building high-quality, accessible
                                        UI. Free and open-source.
                                    </div>
                                    <div style="display: flex; gap: 15px">
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">0</div>
                                            &nbsp;
                                            <div class="Text faded">Following</div>
                                        </div>
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">2,900</div>
                                            &nbsp;
                                            <div class="Text faded">Followers</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div
                                class="HoverCardArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxHoverCardArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="HoverCardId">ID: {{ rootDirective()?.uniqueId() }}</div>
        </with-option-panel>
    `
})
export class RdxHoverCardInitiallyOpenComponent extends OptionPanelBase {
    readonly rootDirective = viewChild(RdxHoverCardRootDirective);

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;
    protected readonly containerAlert = containerAlert;
    protected readonly TriangleAlert = TriangleAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/stories/hover-card-multiple.component.ts
```typescript
import { Component, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { RdxPositionAlign, RdxPositionSide } from '@radix-ng/primitives/core';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxHoverCardModule } from '../index';
import { RdxHoverCardContentAttributesComponent } from '../src/hover-card-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-hover-card-multiple',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxHoverCardModule,
        LucideAngularModule,
        RdxHoverCardContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: styles(),
    template: `
        <p class="ExampleSubtitle">HoverCard #1</p>
        <with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container
                    #root1="rdxHoverCardRoot"
                    [openDelay]="openDelay()"
                    [closeDelay]="closeDelay()"
                    rdxHoverCardRoot
                >
                    <a
                        class="reset ImageTrigger"
                        href="https://twitter.com/radix_ui"
                        target="_blank"
                        rel="noreferrer noopener"
                        rdxHoverCardTrigger
                    >
                        <img
                            class="Image normal"
                            src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                            alt="Radix UI"
                        />
                    </a>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxHoverCardContent
                    >
                        <div class="HoverCardContent" rdxHoverCardContentAttributes>
                            <button class="reset HoverCardClose" rdxHoverCardClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div style="display: flex; flex-direction: column; gap: 7px">
                                <img
                                    class="Image large"
                                    src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                                    alt="Radix UI"
                                />
                                <div style="display: flex; flex-direction: column; gap: 15px;">
                                    <div>
                                        <div class="Text bold">Radix</div>
                                        <div class="Text faded">{{ '@radix_ui' }}</div>
                                    </div>
                                    <div class="Text">
                                        Components, icons, colors, and templates for building high-quality, accessible
                                        UI. Free and open-source.
                                    </div>
                                    <div style="display: flex; gap: 15px">
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">0</div>
                                            &nbsp;
                                            <div class="Text faded">Following</div>
                                        </div>
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">2,900</div>
                                            &nbsp;
                                            <div class="Text faded">Followers</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div
                                class="HoverCardArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxHoverCardArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="HoverCardId">ID: {{ rootDirective1()?.uniqueId() }}</div>
        </with-option-panel>

        <p class="ExampleSubtitle">HoverCard #2</p>
        <with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                <code>[side]="'left'"</code>
                <code>[align]="'start'"</code>
                <code>[sideOffset]="16"</code>
                <code>[alignOffset]="16"</code>
            </div>
            <div class="container">
                <ng-container
                    #root2="rdxHoverCardRoot"
                    [openDelay]="openDelay()"
                    [closeDelay]="closeDelay()"
                    rdxHoverCardRoot
                >
                    <a
                        class="reset ImageTrigger"
                        href="https://twitter.com/radix_ui"
                        target="_blank"
                        rel="noreferrer noopener"
                        rdxHoverCardTrigger
                    >
                        <img
                            class="Image normal"
                            src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                            alt="Radix UI"
                        />
                    </a>

                    <ng-template
                        [side]="RdxPositionSide.Left"
                        [align]="RdxPositionAlign.Start"
                        [sideOffset]="16"
                        [alignOffset]="16"
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxHoverCardContent
                    >
                        <div class="HoverCardContent" rdxHoverCardContentAttributes>
                            <button class="reset HoverCardClose" rdxHoverCardClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div style="display: flex; flex-direction: column; gap: 7px">
                                <img
                                    class="Image large"
                                    src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                                    alt="Radix UI"
                                />
                                <div style="display: flex; flex-direction: column; gap: 15px;">
                                    <div>
                                        <div class="Text bold">Radix</div>
                                        <div class="Text faded">{{ '@radix_ui' }}</div>
                                    </div>
                                    <div class="Text">
                                        Components, icons, colors, and templates for building high-quality, accessible
                                        UI. Free and open-source.
                                    </div>
                                    <div style="display: flex; gap: 15px">
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">0</div>
                                            &nbsp;
                                            <div class="Text faded">Following</div>
                                        </div>
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">2,900</div>
                                            &nbsp;
                                            <div class="Text faded">Followers</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div
                                class="HoverCardArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxHoverCardArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="HoverCardId">ID: {{ rootDirective2()?.uniqueId() }}</div>
        </with-option-panel>

        <p class="ExampleSubtitle">HoverCard #3</p>
        <with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                <code>[side]="'right'"</code>
                <code>[align]="'end'"</code>
                <code>[sideOffset]="60"</code>
                <code>[alignOffset]="60"</code>
            </div>
            <div class="container">
                <ng-container
                    #root3="rdxHoverCardRoot"
                    [openDelay]="openDelay()"
                    [closeDelay]="closeDelay()"
                    rdxHoverCardRoot
                >
                    <a
                        class="reset ImageTrigger"
                        href="https://twitter.com/radix_ui"
                        target="_blank"
                        rel="noreferrer noopener"
                        rdxHoverCardTrigger
                    >
                        <img
                            class="Image normal"
                            src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                            alt="Radix UI"
                        />
                    </a>

                    <ng-template
                        [side]="RdxPositionSide.Right"
                        [align]="RdxPositionAlign.End"
                        [sideOffset]="60"
                        [alignOffset]="60"
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxHoverCardContent
                    >
                        <div class="HoverCardContent" rdxHoverCardContentAttributes>
                            <button class="reset HoverCardClose" rdxHoverCardClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div style="display: flex; flex-direction: column; gap: 7px">
                                <img
                                    class="Image large"
                                    src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                                    alt="Radix UI"
                                />
                                <div style="display: flex; flex-direction: column; gap: 15px;">
                                    <div>
                                        <div class="Text bold">Radix</div>
                                        <div class="Text faded">{{ '@radix_ui' }}</div>
                                    </div>
                                    <div class="Text">
                                        Components, icons, colors, and templates for building high-quality, accessible
                                        UI. Free and open-source.
                                    </div>
                                    <div style="display: flex; gap: 15px">
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">0</div>
                                            &nbsp;
                                            <div class="Text faded">Following</div>
                                        </div>
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">2,900</div>
                                            &nbsp;
                                            <div class="Text faded">Followers</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div
                                class="HoverCardArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxHoverCardArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="HoverCardId">ID: {{ rootDirective3()?.uniqueId() }}</div>
        </with-option-panel>
    `
})
export class RdxHoverCardMultipleComponent extends OptionPanelBase {
    readonly rootDirective1 = viewChild('root1');
    readonly rootDirective2 = viewChild('root2');
    readonly rootDirective3 = viewChild('root3');

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;
    readonly RdxPositionSide = RdxPositionSide;
    readonly RdxPositionAlign = RdxPositionAlign;
    protected readonly containerAlert = containerAlert;
    protected readonly TriangleAlert = TriangleAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/stories/hover-card-positioning.component.ts
```typescript
import { Component, signal, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { RdxPositionAlign, RdxPositionSide } from '@radix-ng/primitives/core';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxHoverCardModule, RdxHoverCardRootDirective } from '../index';
import { RdxHoverCardContentAttributesComponent } from '../src/hover-card-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-hover-card-positioning',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxHoverCardModule,
        LucideAngularModule,
        RdxHoverCardContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: styles(),
    template: `
        <with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ParamsContainer">
                Side:
                <select [ngModel]="selectedSide()" (ngModelChange)="selectedSide.set($event)">
                    <option [value]="sides.Top">{{ sides.Top }}</option>
                    <option [value]="sides.Bottom">{{ sides.Bottom }}</option>
                    <option [value]="sides.Left">{{ sides.Left }}</option>
                    <option [value]="sides.Right">{{ sides.Right }}</option>
                </select>
                Align:
                <select [ngModel]="selectedAlign()" (ngModelChange)="selectedAlign.set($event)">
                    <option [value]="aligns.Center">{{ aligns.Center }}</option>
                    <option [value]="aligns.Start">{{ aligns.Start }}</option>
                    <option [value]="aligns.End">{{ aligns.End }}</option>
                </select>
                SideOffset:
                <input [ngModel]="sideOffset()" (ngModelChange)="sideOffset.set($event)" type="number" />
                AlignOffset:
                <input [ngModel]="alignOffset()" (ngModelChange)="alignOffset.set($event)" type="number" />
            </div>

            <div class="ParamsContainer">
                <input
                    [ngModel]="disableAlternatePositions()"
                    (ngModelChange)="disableAlternatePositions.set($event)"
                    type="checkbox"
                />
                Disable alternate positions (to see the result, scroll the page to make the hover-card cross the
                viewport boundary)
            </div>

            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container [openDelay]="openDelay()" [closeDelay]="closeDelay()" rdxHoverCardRoot>
                    <a
                        class="reset ImageTrigger"
                        href="https://twitter.com/radix_ui"
                        target="_blank"
                        rel="noreferrer noopener"
                        rdxHoverCardTrigger
                    >
                        <img
                            class="Image normal"
                            src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                            alt="Radix UI"
                        />
                    </a>

                    <ng-template
                        [sideOffset]="sideOffset()"
                        [alignOffset]="alignOffset()"
                        [side]="selectedSide()"
                        [align]="selectedAlign()"
                        [alternatePositionsDisabled]="disableAlternatePositions()"
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxHoverCardContent
                    >
                        <div class="HoverCardContent" rdxHoverCardContentAttributes>
                            <button class="reset HoverCardClose" rdxHoverCardClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div style="display: flex; flex-direction: column; gap: 7px">
                                <img
                                    class="Image large"
                                    src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                                    alt="Radix UI"
                                />
                                <div style="display: flex; flex-direction: column; gap: 15px;">
                                    <div>
                                        <div class="Text bold">Radix</div>
                                        <div class="Text faded">{{ '@radix_ui' }}</div>
                                    </div>
                                    <div class="Text">
                                        Components, icons, colors, and templates for building high-quality, accessible
                                        UI. Free and open-source.
                                    </div>
                                    <div style="display: flex; gap: 15px">
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">0</div>
                                            &nbsp;
                                            <div class="Text faded">Following</div>
                                        </div>
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">2,900</div>
                                            &nbsp;
                                            <div class="Text faded">Followers</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div
                                class="HoverCardArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxHoverCardArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="HoverCardId">ID: {{ rootDirective()?.uniqueId() }}</div>
        </with-option-panel>
    `
})
export class RdxHoverCardPositioningComponent extends OptionPanelBase {
    readonly rootDirective = viewChild(RdxHoverCardRootDirective);

    readonly selectedSide = signal(RdxPositionSide.Top);
    readonly selectedAlign = signal(RdxPositionAlign.Center);
    readonly sideOffset = signal<number | undefined>(void 0);
    readonly alignOffset = signal<number | undefined>(void 0);
    readonly disableAlternatePositions = signal(false);

    readonly sides = RdxPositionSide;
    readonly aligns = RdxPositionAlign;

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;
    protected readonly containerAlert = containerAlert;
    protected readonly TriangleAlert = TriangleAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/stories/hover-card-triggering.component.ts
```typescript
import { Component, signal, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxHoverCardModule } from '../index';
import { RdxHoverCardContentAttributesComponent } from '../src/hover-card-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-hover-card-triggering',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxHoverCardModule,
        LucideAngularModule,
        RdxHoverCardContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: styles(),
    template: `
        <p class="ExampleSubtitle">Initially closed</p>
        <with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ParamsContainer">
                <button (mouseup)="triggerOpenFalse()" type="button">Open: {{ isOpenFalse() }}</button>
                onOpenChange count: {{ counterOpenFalse() }}
            </div>

            <div class="ParamsContainer">
                <input
                    [ngModel]="externalControlFalse()"
                    (ngModelChange)="externalControlFalse.set($event)"
                    type="checkbox"
                />
                External control
            </div>

            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container
                    #root1="rdxHoverCardRoot"
                    [open]="isOpenFalse()"
                    [openDelay]="openDelay()"
                    [closeDelay]="closeDelay()"
                    [externalControl]="externalControlFalse()"
                    rdxHoverCardRoot
                >
                    <a
                        class="reset ImageTrigger"
                        href="https://twitter.com/radix_ui"
                        target="_blank"
                        rel="noreferrer noopener"
                        rdxHoverCardTrigger
                    >
                        <img
                            class="Image normal"
                            src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                            alt="Radix UI"
                        />
                    </a>

                    <ng-template
                        [sideOffset]="8"
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        (onOpen)="countOpenFalse(true)"
                        (onClosed)="countOpenFalse(false)"
                        rdxHoverCardContent
                    >
                        <div class="HoverCardContent" rdxHoverCardContentAttributes>
                            <button class="reset HoverCardClose" rdxHoverCardClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div style="display: flex; flex-direction: column; gap: 7px">
                                <img
                                    class="Image large"
                                    src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                                    alt="Radix UI"
                                />
                                <div style="display: flex; flex-direction: column; gap: 15px;">
                                    <div>
                                        <div class="Text bold">Radix</div>
                                        <div class="Text faded">{{ '@radix_ui' }}</div>
                                    </div>
                                    <div class="Text">
                                        Components, icons, colors, and templates for building high-quality, accessible
                                        UI. Free and open-source.
                                    </div>
                                    <div style="display: flex; gap: 15px">
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">0</div>
                                            &nbsp;
                                            <div class="Text faded">Following</div>
                                        </div>
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">2,900</div>
                                            &nbsp;
                                            <div class="Text faded">Followers</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div
                                class="HoverCardArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxHoverCardArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="HoverCardId">ID: {{ rootDirective1()?.uniqueId() }}</div>
        </with-option-panel>

        <p class="ExampleSubtitle">Initially open</p>
        <with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            [openDelay]="openDelay()"
            [closeDelay]="closeDelay()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
            (openDelayChange)="openDelay.set($event)"
            (closeDelayChange)="closeDelay.set($event)"
        >
            <div class="ParamsContainer">
                <button (mouseup)="triggerOpenTrue()" type="button">Open: {{ isOpenTrue() }}</button>
                <span>onOpenChange count: {{ counterOpenTrue() }}</span>
            </div>

            <div class="ParamsContainer">
                <input
                    [ngModel]="externalControlTrue()"
                    (ngModelChange)="externalControlTrue.set($event)"
                    type="checkbox"
                />
                External control
            </div>

            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container
                    #root2="rdxHoverCardRoot"
                    [open]="isOpenTrue()"
                    [openDelay]="openDelay()"
                    [closeDelay]="closeDelay()"
                    [externalControl]="externalControlTrue()"
                    rdxHoverCardRoot
                >
                    <a
                        class="reset ImageTrigger"
                        href="https://twitter.com/radix_ui"
                        target="_blank"
                        rel="noreferrer noopener"
                        rdxHoverCardTrigger
                    >
                        <img
                            class="Image normal"
                            src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                            alt="Radix UI"
                        />
                    </a>

                    <ng-template
                        [sideOffset]="8"
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        (onOpen)="countOpenTrue(true)"
                        (onClosed)="countOpenTrue(false)"
                        rdxHoverCardContent
                    >
                        <div class="HoverCardContent" rdxHoverCardContentAttributes>
                            <button class="reset HoverCardClose" rdxHoverCardClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div style="display: flex; flex-direction: column; gap: 7px">
                                <img
                                    class="Image large"
                                    src="https://pbs.twimg.com/profile_images/1337055608613253126/r_eiMp2H_400x400.png"
                                    alt="Radix UI"
                                />
                                <div style="display: flex; flex-direction: column; gap: 15px;">
                                    <div>
                                        <div class="Text bold">Radix</div>
                                        <div class="Text faded">{{ '@radix_ui' }}</div>
                                    </div>
                                    <div class="Text">
                                        Components, icons, colors, and templates for building high-quality, accessible
                                        UI. Free and open-source.
                                    </div>
                                    <div style="display: flex; gap: 15px">
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">0</div>
                                            &nbsp;
                                            <div class="Text faded">Following</div>
                                        </div>
                                        <div style="display: flex; gap: 5px">
                                            <div class="Text bold">2,900</div>
                                            &nbsp;
                                            <div class="Text faded">Followers</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div
                                class="HoverCardArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxHoverCardArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="HoverCardId">ID: {{ rootDirective2()?.uniqueId() }}</div>
        </with-option-panel>
    `
})
export class RdxHoverCardTriggeringComponent extends OptionPanelBase {
    readonly rootDirective1 = viewChild('root1');
    readonly rootDirective2 = viewChild('root2');

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;

    isOpenFalse = signal(false);
    counterOpenFalse = signal(0);
    externalControlFalse = signal(true);

    isOpenTrue = signal(true);
    counterOpenTrue = signal(0);
    externalControlTrue = signal(true);

    triggerOpenFalse(): void {
        this.isOpenFalse.update((value) => !value);
    }

    countOpenFalse(open: boolean): void {
        this.isOpenFalse.set(open);
        this.counterOpenFalse.update((value) => value + 1);
    }

    triggerOpenTrue(): void {
        this.isOpenTrue.update((value) => !value);
    }

    countOpenTrue(open: boolean): void {
        this.isOpenTrue.set(open);
        this.counterOpenTrue.update((value) => value + 1);
    }

    protected readonly containerAlert = containerAlert;
    protected readonly TriangleAlert = TriangleAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/stories/hover-card.docs.mdx
````
import {ArgTypes, Canvas, Markdown, Meta, Source} from '@storybook/blocks';
import * as HoverCardStories from "./hover-card.stories";
import {RdxHoverCardRootDirective} from "../src/hover-card-root.directive";
import {RdxHoverCardContentDirective} from "../src/hover-card-content.directive";
import {RdxHoverCardArrowDirective} from "../src/hover-card-arrow.directive";
import {RdxHoverCardAnchorDirective} from "../src/hover-card-anchor.directive";
import {RdxHoverCardTriggerDirective} from "../src/hover-card-trigger.directive";
import {RdxHoverCardCloseDirective} from "../src/hover-card-close.directive";
import {animationStylesOnly} from "./utils/styles.constants";
import {RdxHoverCardContentAttributesComponent} from "../src/hover-card-content-attributes.component";

<Meta title="Primitives/Hover Card" />

# Hover Card

#### For sighted users to preview content available behind a link.

<br />
<br />

## Examples
### Default

<Canvas sourceState="hidden" of={HoverCardStories.Default} />

### Multiple

<Canvas sourceState="hidden" of={HoverCardStories.Multiple} />

### Events

<Canvas sourceState="hidden" of={HoverCardStories.Events} />

### Positioning

<Canvas sourceState="hidden" of={HoverCardStories.Positioning} />

### External Triggering

<Canvas sourceState="hidden" of={HoverCardStories.ExternalTriggering} />

### Anchor

<Canvas sourceState="hidden" of={HoverCardStories.Anchor} />

### Initially Open

<Canvas sourceState="hidden" of={HoverCardStories.InitiallyOpen} />

### Animations

<Canvas sourceState="hidden" of={HoverCardStories.Animations} />

### Animation Styles

<Source type="code" language="css" code={`${animationStylesOnly}`} />


## Features

- âœ… Opens when the trigger is clicked.
- âœ… Closes when the trigger is clicked again or when pressing escape.
- âœ… Controllable from outside.

## Anatomy

```html
<ng-container rdxHoverCardRoot>
    <button class="IconButton" rdxHoverCardTrigger>+</button>

    <ng-template rdxHoverCardContent>
        <div class="HoverCardContent" rdxHoverCardContentAttributes>
            <button class="HoverCardClose" rdxHoverCardClose aria-label="Close">X</button>
            Hover Card Content
            <div class="HoverCardArrow" rdxHoverCardArrow></div>
        </div>
    </ng-template>
</ng-container>
```

## Import

Get started with importing the directives:

<Source type="code" language="typescript" code={`import {
  RdxHoverCardRootDirective,
  RdxHoverCardRootTrigger,
  RdxHoverCardContentDirective,
  RdxHoverCardArrowDirective,
  RdxHoverCardAnchorDirective,
  RdxHoverCardCloseDirective
} from '@radix-ng/primitives/hover-card';`} />

or

<Source type="code" language="typescript" code={`import { RdxHoverCardModule } from '@radix-ng/primitives/hover-card';`} />

## API Reference

### Root
`RdxHoverCardRootDirective`

Contains all the parts of a hover-card.

<ArgTypes of={RdxHoverCardRootDirective} />

### Trigger
`RdxHoverCardTriggerDirective`

The button that toggles the hover-card. By default, the HoverCardContent will position itself against the trigger.

<Markdown>
{`
| Data attribute | Value          |
|----------------|----------------|
| [data-state]   | <code>"closed" | "open" (type RdxHoverCardState)</code>
`}
</Markdown>

### Anchor
`RdxHoverCardAnchorDirective`

An optional element to position the HoverCardContent against. If this part is not used, the content will position alongside the HoverCardTrigger.

### Content
`RdxHoverCardContentDirective`

The component that pops out when the hover-card is open.

<ArgTypes of={RdxHoverCardContentDirective} />

### Content Attributes
`RdxHoverCardContentAttributesComponent`

A component with the content attributes that are necessary to run animations.

<ArgTypes of={RdxHoverCardContentAttributesComponent} />

<Markdown>
{`
| Data attribute | Value          |
|----------------|----------------|
| [data-state]   | <code>"closed" | "open" (enum RdxHoverCardState)</code>
| [data-side]    | <code>"left"   | "right" | "bottom" | "top" (enum RdxPositionSide)</code>
| [data-align]   | <code>"start"  | "end" | "center" (enum RdxPositionAlign)</code>
`}
</Markdown>

### Arrow
`RdxHoverCardArrowDirective`

An optional arrow element to render alongside the hover-card. This can be used to help visually link the trigger with the HoverCardContent. Must be rendered inside HoverCardContent.

<ArgTypes of={RdxHoverCardArrowDirective} />

### Close
`RdxHoverCardCloseDirective`

An optional close button element to render alongside the hover-card. This can be used to close the HoverCardContent. Must be rendered inside HoverCardContent.

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/stories/hover-card.stories.ts
```typescript
import { provideAnimations } from '@angular/platform-browser/animations';
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { LucideAngularModule, MountainSnow, X } from 'lucide-angular';
import { RdxHoverCardModule } from '../index';
import { RdxHoverCardAnchorComponent } from './hover-card-anchor.component';
import { RdxHoverCardAnimationsComponent } from './hover-card-animations.component';
import { RdxHoverCardDefaultComponent } from './hover-card-default.component';
import { RdxHoverCardEventsComponent } from './hover-card-events.components';
import { RdxHoverCardInitiallyOpenComponent } from './hover-card-initially-open.component';
import { RdxHoverCardMultipleComponent } from './hover-card-multiple.component';
import { RdxHoverCardPositioningComponent } from './hover-card-positioning.component';
import { RdxHoverCardTriggeringComponent } from './hover-card-triggering.component';

const html = String.raw;

export default {
    title: 'Primitives/Hover Card',
    decorators: [
        moduleMetadata({
            imports: [
                RdxHoverCardModule,
                RdxHoverCardDefaultComponent,
                RdxHoverCardEventsComponent,
                RdxHoverCardPositioningComponent,
                RdxHoverCardTriggeringComponent,
                RdxHoverCardMultipleComponent,
                RdxHoverCardAnimationsComponent,
                RdxHoverCardInitiallyOpenComponent,
                RdxHoverCardAnchorComponent,
                LucideAngularModule,
                LucideAngularModule.pick({ MountainSnow, X })
            ],
            providers: [provideAnimations()]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div
                    class="radix-themes light light-theme radix-themes-default-fonts"
                    data-accent-color="indigo"
                    data-radius="medium"
                    data-scaling="100%"
                >
                    ${story}
                </div>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: html`
            <rdx-hover-card-default></rdx-hover-card-default>
        `
    })
};

export const Multiple: Story = {
    render: () => ({
        template: html`
            <rdx-hover-card-multiple></rdx-hover-card-multiple>
        `
    })
};

export const Events: Story = {
    render: () => ({
        template: html`
            <rdx-hover-card-events></rdx-hover-card-events>
        `
    })
};

export const Positioning: Story = {
    render: () => ({
        template: html`
            <rdx-hover-card-positioning></rdx-hover-card-positioning>
        `
    })
};

export const ExternalTriggering: Story = {
    render: () => ({
        template: html`
            <rdx-hover-card-triggering></rdx-hover-card-triggering>
        `
    })
};

export const Anchor: Story = {
    render: () => ({
        template: html`
            <rdx-hover-card-anchor></rdx-hover-card-anchor>
        `
    })
};

export const InitiallyOpen: Story = {
    render: () => ({
        template: html`
            <rdx-hover-card-initially-open></rdx-hover-card-initially-open>
        `
    })
};

export const Animations: Story = {
    render: () => ({
        template: html`
            <rdx-hover-card-animations></rdx-hover-card-animations>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/stories/utils/constants.ts
```typescript
export const containerAlert =
    'For the sake of option panels to play with the stories, the "onOverlayEscapeKeyDown" & "onOverlayOutsideClick" events are limited to the area inside the rectangle marked with a dashed line - the events work when the area is active (focused)';

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/stories/utils/containers.registry.ts
```typescript
import { isDevMode } from '@angular/core';
import { RdxHoverCardRootDirective } from '../../src/hover-card-root.directive';
import { injectRdxCdkEventService } from '../../src/utils/cdk-event.service';

const containerRegistry: Map<HTMLElement, RdxHoverCardRootDirective> = new Map();
let rdxCdkEventService: ReturnType<typeof injectRdxCdkEventService> | undefined = void 0;

const domRootClickEventCallback: (event: MouseEvent) => void = (event: MouseEvent) => {
    const target = event.target as HTMLElement;
    const containers = Array.from(containerRegistry.keys());
    const containerContainingTarget = containers
        .map((container) => {
            container.classList.remove('focused');
            return container;
        })
        .find((container) => {
            return container.contains(target);
        });
    containerContainingTarget?.classList.add('focused');
    Array.from(containerRegistry.entries()).forEach((item) => {
        if (item[0] === containerContainingTarget) {
            rdxCdkEventService?.allowPrimitiveForCdkMultiEvents(item[1], [
                'cdkOverlayOutsideClick',
                'cdkOverlayEscapeKeyDown'
            ]);
        } else {
            rdxCdkEventService?.preventPrimitiveFromCdkMultiEvents(item[1], [
                'cdkOverlayOutsideClick',
                'cdkOverlayEscapeKeyDown'
            ]);
        }
    });
};

export function registerContainer(container: HTMLElement, root: RdxHoverCardRootDirective) {
    if (containerRegistry.has(container)) {
        return;
    }
    containerRegistry.set(container, root);
    if (containerRegistry.size === 1) {
        rdxCdkEventService?.addClickDomRootEventCallback(domRootClickEventCallback);
    }
}

export function deregisterContainer(container: HTMLElement) {
    if (!containerRegistry.has(container)) {
        return;
    }
    containerRegistry.delete(container);
    if (containerRegistry.size === 0) {
        rdxCdkEventService?.removeClickDomRootEventCallback(domRootClickEventCallback);
        unsetRdxCdkEventService();
    }
}

export function setRdxCdkEventService(service: typeof rdxCdkEventService) {
    isDevMode() && console.log('setRdxCdkEventService', service, rdxCdkEventService === service);
    rdxCdkEventService ??= service;
}

export function unsetRdxCdkEventService() {
    rdxCdkEventService = void 0;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/stories/utils/option-panel-base.class.ts
```typescript
import { afterNextRender, DestroyRef, Directive, ElementRef, inject, signal, viewChildren } from '@angular/core';
import { injectDocument, RDX_POSITIONING_DEFAULTS } from '@radix-ng/primitives/core';
import { RdxHoverCardRootDirective } from '../../src/hover-card-root.directive';
import { injectRdxCdkEventService } from '../../src/utils/cdk-event.service';
import { deregisterContainer, registerContainer, setRdxCdkEventService } from './containers.registry';
import { IArrowDimensions, IIgnoreClickOutsideContainer, IOpenCloseDelay } from './types';

@Directive()
export abstract class OptionPanelBase implements IIgnoreClickOutsideContainer, IArrowDimensions, IOpenCloseDelay {
    onOverlayEscapeKeyDownDisabled = signal(false);
    onOverlayOutsideClickDisabled = signal(false);

    arrowWidth = signal(RDX_POSITIONING_DEFAULTS.arrow.width);
    arrowHeight = signal(RDX_POSITIONING_DEFAULTS.arrow.height);

    openDelay = signal(500);
    closeDelay = signal(200);

    readonly elementRef = inject<ElementRef<HTMLElement>>(ElementRef);
    readonly destroyRef = inject(DestroyRef);
    readonly rootDirectives = viewChildren(RdxHoverCardRootDirective);
    readonly document = injectDocument();
    readonly rdxCdkEventService = injectRdxCdkEventService();

    protected constructor() {
        afterNextRender(() => {
            this.elementRef.nativeElement.querySelectorAll<HTMLElement>('.container').forEach((container) => {
                const rootInsideContainer = this.rootDirectives().find((rootDirective) =>
                    container.contains(rootDirective.triggerDirective().elementRef.nativeElement)
                );
                if (rootInsideContainer) {
                    setRdxCdkEventService(this.rdxCdkEventService);
                    registerContainer(container, rootInsideContainer);
                    this.destroyRef.onDestroy(() => deregisterContainer(container));
                }
            });
        });
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/stories/utils/styles.constants.ts
```typescript
const appliedAnimations = `
.HoverCardContent[data-state='open'][data-side='top'] {
    animation-name: rdxSlideDownAndFade;
}

.HoverCardContent[data-state='open'][data-side='right'] {
    animation-name: rdxSlideLeftAndFade;
}

.HoverCardContent[data-state='open'][data-side='bottom'] {
    animation-name: rdxSlideUpAndFade;
}

.HoverCardContent[data-state='open'][data-side='left'] {
    animation-name: rdxSlideRightAndFade;
}

.HoverCardContent[data-state='closed'][data-side='top'] {
    animation-name: rdxSlideDownAndFadeReverse;
}

.HoverCardContent[data-state='closed'][data-side='right'] {
    animation-name: rdxSlideLeftAndFadeReverse;
}

.HoverCardContent[data-state='closed'][data-side='bottom'] {
    animation-name: rdxSlideUpAndFadeReverse;
}

.HoverCardContent[data-state='closed'][data-side='left'] {
    animation-name: rdxSlideRightAndFadeReverse;
}
`;

const animationParams = `
.HoverCardContent {
    animation-duration: 400ms;
    animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
    will-change: transform, opacity;
}
`;

const animationDefs = `
/* Opening animations */

@keyframes rdxSlideUpAndFade {
    from {
        opacity: 0;
        transform: translateY(2px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes rdxSlideRightAndFade {
    from {
        opacity: 0;
        transform: translateX(-2px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

@keyframes rdxSlideDownAndFade {
    from {
        opacity: 0;
        transform: translateY(-2px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes rdxSlideLeftAndFade {
    from {
        opacity: 0;
        transform: translateX(2px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

/* Closing animations */

@keyframes rdxSlideUpAndFadeReverse {
    from {
        opacity: 1;
        transform: translateY(0);
    }
    to {
        opacity: 0;
        transform: translateY(2px);
    }
}

@keyframes rdxSlideRightAndFadeReverse {
    from {
        opacity: 1;
        transform: translateX(0);
    }
    to {
        opacity: 0;
        transform: translateX(-2px);
    }
}

@keyframes rdxSlideDownAndFadeReverse {
    from {
        opacity: 1;
        transform: translateY(0);
    }
    to {
        opacity: 0;
        transform: translateY(-2px);
    }
}

@keyframes rdxSlideLeftAndFadeReverse {
    from {
        opacity: 1;
        transform: translateX(0);
    }
    to {
        opacity: 0;
        transform: translateX(2px);
    }
}
`;

const events = `
/* =============== Event messages =============== */

.MessagesContainer {
    padding: 20px;
}

.Message {
    color: var(--white-a12);
    font-size: 15px;
    line-height: 19px;
    font-weight: bolder;
}

.MessageId {
    font-size: 75%;
    font-weight: light;
}
`;

const params = `
/* =============== Params layout =============== */

.ParamsContainer {
    display: flex;
    column-gap: 8px;
    color: var(--white-a12);
    padding-bottom: 32px;
}
`;

function styles(withAnimations = false, withEvents = false, withParams = true) {
    return `
.container {
    height: 600px;
    display: flex;
    justify-content: center;
    gap: 80px;
    align-items: center;
    border: 3px dashed var(--white-a8);
    border-radius: 12px;
    &.focused {
        border-color: var(--white-a12);
        -webkit-box-shadow: 0px 0px 24px 0px var(--white-a12);
        -moz-box-shadow: 0px 0px 24px 0px var(--white-a12);
        box-shadow: 0px 0px 24px 0px var(--white-a12);
    }
}

.ContainerAlerts {
    display: flex;
    gap: 6px;
    color: var(--white-a8);
    font-size: 16px;
    line-height: 16px;
    margin: 0 0 24px 0;
}

/* reset */
.reset {
    all: unset;
}

.ExampleSubtitle {
    color: var(--white-a12);
    font-size: 22px;
    line-height: 26px;
    font-weight: bolder;
    margin: 46px 0 34px 16px;
    padding-top: 22px;
    &:not(:first-child) {
        border-top: 2px solid var(--gray-a8);
    }
    &:first-child {
        margin-top: 0;
    }
}

.HoverCardId {
    color: var(--white-a12);
    font-size: 12px;
    line-height: 14px;
    font-weight: 800;
    margin: 1px 0 24px 22px;
}

.HoverCardContent {
    border-radius: 4px;
    padding: 20px;
    width: 300px;
    background-color: white;
    box-shadow:
        hsl(206 22% 7% / 35%) 0px 10px 38px -10px,
        hsl(206 22% 7% / 20%) 0px 10px 20px -15px;
}

.ImageTrigger {
    cursor: pointer;
    border-radius: 100%;
    display: inline-block;
}
.ImageTrigger:focus {
    box-shadow: 0 0 0 2px white;
}

.Image {
    display: block;
    border-radius: 100%;
}
.Image.normal {
    width: 45px;
    height: 45px;
}
.Image.large {
    width: 60px;
    height: 60px;
}

.Text {
    margin: 0;
    color: var(--mauve-12);
    font-size: 15px;
    line-height: 1.5;

    &.bold {
        font-weight: 700;
    }

    &.faded {
        color: var(--mauve-10);
    }
}


${withAnimations ? animationParams : ''}

${withAnimations ? appliedAnimations : ''}

.HoverCardContent:focus {
    box-shadow:
        hsl(206 22% 7% / 35%) 0px 10px 38px -10px,
        hsl(206 22% 7% / 20%) 0px 10px 20px -15px,
        0 0 0 2px var(--violet-7);
}

.HoverCardArrow {
    fill: white;
}

.HoverCardClose {
    font-family: inherit;
    border-radius: 100%;
    height: 25px;
    width: 25px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: var(--violet-11);
    position: absolute;
    top: 5px;
    right: 5px;
}

.HoverCardClose:hover {
    background-color: var(--violet-4);
}

.HoverCardClose:focus {
    box-shadow: 0 0 0 2px var(--violet-7);
}

.IconButton {
    font-family: inherit;
    border-radius: 100%;
    height: 35px;
    width: 35px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: var(--violet-11);
    background-color: white;
    box-shadow: 0 2px 10px var(--black-a7);
}

.IconButton:hover {
    background-color: var(--violet-3);
}

.IconButton:focus {
    box-shadow: 0 0 0 2px black;
}

.Fieldset {
    display: flex;
    gap: 20px;
    align-items: center;
}

.Label {
    font-size: 13px;
    color: var(--violet-11);
    width: 75px;
}

.Input {
    width: 100%;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    border-radius: 4px;
    padding: 0 10px;
    font-size: 13px;
    line-height: 1;
    color: var(--violet-11);
    box-shadow: 0 0 0 1px var(--violet-7);
    height: 25px;
}

.Input:focus {
    box-shadow: 0 0 0 2px var(--violet-8);
}

.Text {
    margin: 0;
    color: var(--mauve-12);
    font-size: 15px;
    line-height: 19px;
    font-weight: 500;
}

${withAnimations ? animationDefs : ''}

${withParams ? params : ''}

${withEvents ? events : ''}
`;
}

export const animationStylesOnly = `
${animationParams}

${appliedAnimations}

${animationDefs}
`;

export const paramsAndEventsOnly = `
${params}

${events}
`;

export default styles;

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/stories/utils/types.ts
```typescript
import { DestroyRef, ElementRef, Signal } from '@angular/core';
import { RdxHoverCardRootDirective } from '../../src/hover-card-root.directive';
import { injectRdxCdkEventService } from '../../src/utils/cdk-event.service';

export interface IIgnoreClickOutsideContainer {
    onOverlayEscapeKeyDownDisabled: Signal<boolean>;
    onOverlayOutsideClickDisabled: Signal<boolean>;
    elementRef: ElementRef<Element>;
    destroyRef: DestroyRef;
    rootDirectives: Signal<ReadonlyArray<RdxHoverCardRootDirective>>;
    document: Document;
    rdxCdkEventService: ReturnType<typeof injectRdxCdkEventService>;
}

export interface IArrowDimensions {
    arrowWidth: Signal<number | undefined>;
    arrowHeight: Signal<number | undefined>;
}

export interface IOpenCloseDelay {
    openDelay: Signal<number | undefined>;
    closeDelay: Signal<number | undefined>;
}

export type Message = { value: string; timeFromPrev: number };

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/stories/utils/with-option-panel.component.ts
```typescript
import { NgTemplateOutlet } from '@angular/common';
import {
    afterNextRender,
    Component,
    computed,
    contentChild,
    ElementRef,
    inject,
    isDevMode,
    model,
    signal
} from '@angular/core';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { RdxHoverCardRootDirective } from '../../src/hover-card-root.directive';
import { paramsAndEventsOnly } from './styles.constants';
import { Message } from './types';

@Component({
    selector: 'with-option-panel',
    styles: paramsAndEventsOnly,
    template: `
        <ng-content select=".ParamsContainer" />

        @if (paramsContainerCounter() > 3) {
            <hr />
        }

        <div class="ParamsContainer">
            <input
                [ngModel]="onOverlayEscapeKeyDownDisabled()"
                (ngModelChange)="onOverlayEscapeKeyDownDisabled.set($event)"
                type="checkbox"
            />
            Disable (onOverlayEscapeKeyDown) event
            <input
                [ngModel]="onOverlayOutsideClickDisabled()"
                (ngModelChange)="onOverlayOutsideClickDisabled.set($event)"
                type="checkbox"
            />
            Disable (onOverlayOutsideClick) event
        </div>

        <div class="ParamsContainer">
            Arrow width
            <input [ngModel]="arrowWidth()" (ngModelChange)="arrowWidth.set($event)" type="number" />
            Arrow height
            <input [ngModel]="arrowHeight()" (ngModelChange)="arrowHeight.set($event)" type="number" />
        </div>

        <div class="ParamsContainer">
            Open delay
            <input [ngModel]="openDelay()" (ngModelChange)="openDelay.set($event)" type="number" />
            Close delay
            <input [ngModel]="closeDelay()" (ngModelChange)="closeDelay.set($event)" type="number" />
        </div>

        <ng-content />

        @if (messages().length) {
            <button class="SkipOutsideClickPrevention" (click)="messages.set([])" type="button">Clear messages</button>
            <div class="MessagesContainer">
                @for (message of messages(); track i; let i = $index) {
                    <ng-container
                        [ngTemplateOutlet]="messageTpl"
                        [ngTemplateOutletContext]="{ message: message, index: messages().length - i }"
                    />
                }
            </div>
        }

        <ng-template #messageTpl let-message="message" let-index="index">
            <p class="Message">
                {{ index }}.
                <span class="MessageId">[({{ message.timeFromPrev }}ms) HOVER CARD ID {{ rootUniqueId() }}]</span>
                {{ message.value }}
            </p>
        </ng-template>
    `,
    imports: [
        ReactiveFormsModule,
        FormsModule,
        NgTemplateOutlet
    ]
})
export class WithOptionPanelComponent {
    onOverlayEscapeKeyDownDisabled = model(false);
    onOverlayOutsideClickDisabled = model(false);

    arrowWidth = model<number>(0);
    arrowHeight = model<number>(0);

    openDelay = model<number>(0);
    closeDelay = model<number>(0);

    readonly elementRef = inject<ElementRef<HTMLElement>>(ElementRef);

    readonly rootDirective = contentChild.required(RdxHoverCardRootDirective);

    readonly paramsContainerCounter = signal(0);

    readonly messages = signal<Message[]>([]);
    readonly rootUniqueId = computed(() => this.rootDirective().uniqueId());

    /**
     * There should be only one container. If there is more, en error is thrown.
     */
    containers: Element[] | undefined = void 0;
    paramsContainers: Element[] | undefined = void 0;

    previousMessageTimestamp: number | undefined = void 0;

    timeFromPrev = () => {
        const now = Date.now();
        const timeFromPrev =
            typeof this.previousMessageTimestamp === 'undefined' ? 0 : Date.now() - this.previousMessageTimestamp;
        this.previousMessageTimestamp = now;
        return timeFromPrev;
    };

    constructor() {
        afterNextRender({
            read: () => {
                this.rootDirective().contentDirective().onOpen.subscribe(this.onOpen);
                this.rootDirective().contentDirective().onClosed.subscribe(this.onClose);
                this.rootDirective().contentDirective().onOverlayOutsideClick.subscribe(this.onOverlayOutsideClick);
                this.rootDirective().contentDirective().onOverlayEscapeKeyDown.subscribe(this.onOverlayEscapeKeyDown);

                /**
                 * There should be only one container. If there is more, en error is thrown.
                 */
                this.containers = Array.from(this.elementRef.nativeElement?.querySelectorAll('.container') ?? []);
                if (this.containers.length > 1) {
                    if (isDevMode()) {
                        console.error('<story>.elementRef.nativeElement', this.elementRef.nativeElement);
                        console.error('<story>.containers', this.containers);
                        throw Error('each story should have only one container!');
                    }
                }
                this.paramsContainers = Array.from(
                    this.elementRef.nativeElement?.querySelectorAll('.ParamsContainer') ?? []
                );

                this.paramsContainerCounter.set(this.paramsContainers.length ?? 0);
            }
        });
    }

    private inContainers(element: Element) {
        return !!this.containers?.find((container) => container.contains(element));
    }

    private inParamsContainers(element: Element) {
        return !!this.paramsContainers?.find((container) => container.contains(element));
    }

    private onOverlayEscapeKeyDown = () => {
        this.addMessage({
            value: `[HoverCardRoot] Escape clicked! (disabled: ${this.onOverlayEscapeKeyDownDisabled()})`,
            timeFromPrev: this.timeFromPrev()
        });
    };

    private onOverlayOutsideClick = () => {
        this.addMessage({
            value: `[HoverCardRoot] Mouse clicked outside the hover-card! (disabled: ${this.onOverlayOutsideClickDisabled()})`,
            timeFromPrev: this.timeFromPrev()
        });
    };

    private onOpen = () => {
        this.addMessage({ value: '[HoverCardContent] Open', timeFromPrev: this.timeFromPrev() });
    };

    private onClose = () => {
        this.addMessage({ value: '[HoverCardContent] Closed', timeFromPrev: this.timeFromPrev() });
    };

    protected addMessage = (message: Message) => {
        this.messages.update((messages) => {
            return [
                message,
                ...messages
            ];
        });
    };
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/src/hover-card-anchor.directive.ts
```typescript
import { CdkOverlayOrigin } from '@angular/cdk/overlay';
import { computed, Directive, ElementRef, forwardRef, inject } from '@angular/core';
import { injectDocument } from '@radix-ng/primitives/core';
import { RdxHoverCardAnchorToken } from './hover-card-anchor.token';
import { RdxHoverCardRootDirective } from './hover-card-root.directive';
import { injectHoverCardRoot } from './hover-card-root.inject';

@Directive({
    selector: '[rdxHoverCardAnchor]',
    exportAs: 'rdxHoverCardAnchor',
    hostDirectives: [CdkOverlayOrigin],
    host: {
        type: 'button',
        '[attr.id]': 'name()',
        '[attr.aria-haspopup]': '"dialog"',
        '(click)': 'click()'
    },
    providers: [
        {
            provide: RdxHoverCardAnchorToken,
            useExisting: forwardRef(() => RdxHoverCardAnchorDirective)
        }
    ]
})
export class RdxHoverCardAnchorDirective {
    /**
     * @ignore
     * If outside the rootDirective then null, otherwise the rootDirective directive - with optional `true` passed in as the first param.
     * If outside the rootDirective and non-null value that means the html structure is wrong - hover-card inside hover-card.
     * */
    protected rootDirective = injectHoverCardRoot(true);
    /** @ignore */
    readonly elementRef = inject(ElementRef);
    /** @ignore */
    readonly overlayOrigin = inject(CdkOverlayOrigin);
    /** @ignore */
    readonly document = injectDocument();

    /** @ignore */
    readonly name = computed(() => `rdx-hover-card-external-anchor-${this.rootDirective?.uniqueId()}`);

    /** @ignore */
    click(): void {
        this.emitOutsideClick();
    }

    /** @ignore */
    setRoot(root: RdxHoverCardRootDirective) {
        this.rootDirective = root;
    }

    private emitOutsideClick() {
        if (!this.rootDirective?.isOpen() || this.rootDirective?.contentDirective().onOverlayOutsideClickDisabled()) {
            return;
        }
        const clickEvent = new MouseEvent('click', {
            view: this.document.defaultView,
            bubbles: true,
            cancelable: true,
            relatedTarget: this.elementRef.nativeElement
        });
        this.rootDirective?.triggerDirective().elementRef.nativeElement.dispatchEvent(clickEvent);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/src/hover-card-anchor.token.ts
```typescript
import { InjectionToken } from '@angular/core';
import { RdxHoverCardAnchorDirective } from './hover-card-anchor.directive';

export const RdxHoverCardAnchorToken = new InjectionToken<RdxHoverCardAnchorDirective>('RdxHoverCardAnchorToken');

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/src/hover-card-arrow.directive.ts
```typescript
import { NumberInput } from '@angular/cdk/coercion';
import { ConnectedOverlayPositionChange } from '@angular/cdk/overlay';
import {
    afterNextRender,
    computed,
    Directive,
    effect,
    ElementRef,
    forwardRef,
    inject,
    input,
    numberAttribute,
    Renderer2,
    signal,
    untracked
} from '@angular/core';
import { toSignal } from '@angular/core/rxjs-interop';
import {
    getArrowPositionParams,
    getSideAndAlignFromAllPossibleConnectedPositions,
    RDX_POSITIONING_DEFAULTS
} from '@radix-ng/primitives/core';
import { RdxHoverCardArrowToken } from './hover-card-arrow.token';
import { injectHoverCardRoot } from './hover-card-root.inject';

@Directive({
    selector: '[rdxHoverCardArrow]',
    providers: [
        {
            provide: RdxHoverCardArrowToken,
            useExisting: forwardRef(() => RdxHoverCardArrowDirective)
        }
    ]
})
export class RdxHoverCardArrowDirective {
    /** @ignore */
    private readonly renderer = inject(Renderer2);
    /** @ignore */
    private readonly rootDirective = injectHoverCardRoot();
    /** @ignore */
    readonly elementRef = inject(ElementRef);

    /**
     * @description The width of the arrow in pixels.
     * @default 10
     */
    readonly width = input<number, NumberInput>(RDX_POSITIONING_DEFAULTS.arrow.width, { transform: numberAttribute });

    /**
     * @description The height of the arrow in pixels.
     * @default 5
     */
    readonly height = input<number, NumberInput>(RDX_POSITIONING_DEFAULTS.arrow.height, { transform: numberAttribute });

    /** @ignore */
    readonly arrowSvgElement = computed<HTMLElement>(() => {
        const width = this.width();
        const height = this.height();

        const svgElement = this.renderer.createElement('svg', 'svg');
        this.renderer.setAttribute(svgElement, 'viewBox', '0 0 30 10');
        this.renderer.setAttribute(svgElement, 'width', String(width));
        this.renderer.setAttribute(svgElement, 'height', String(height));
        const polygonElement = this.renderer.createElement('polygon', 'svg');
        this.renderer.setAttribute(polygonElement, 'points', '0,0 30,0 15,10');
        this.renderer.setAttribute(svgElement, 'preserveAspectRatio', 'none');
        this.renderer.appendChild(svgElement, polygonElement);

        return svgElement;
    });

    /** @ignore */
    private readonly currentArrowSvgElement = signal<HTMLOrSVGElement | undefined>(void 0);
    /** @ignore */
    private readonly position = toSignal(this.rootDirective.contentDirective().positionChange());

    /** @ignore */
    private anchorOrTriggerRect: DOMRect;

    constructor() {
        afterNextRender({
            write: () => {
                if (this.elementRef.nativeElement.parentElement) {
                    this.renderer.setStyle(this.elementRef.nativeElement.parentElement, 'position', 'relative');
                }
                this.renderer.setStyle(this.elementRef.nativeElement, 'position', 'absolute');
                this.renderer.setStyle(this.elementRef.nativeElement, 'boxSizing', '');
                this.renderer.setStyle(this.elementRef.nativeElement, 'fontSize', '0px');
            }
        });
        this.onArrowSvgElementChangeEffect();
        this.onContentPositionAndArrowDimensionsChangeEffect();
    }

    /** @ignore */
    private setAnchorOrTriggerRect() {
        this.anchorOrTriggerRect = (
            this.rootDirective.anchorDirective() ?? this.rootDirective.triggerDirective()
        ).elementRef.nativeElement.getBoundingClientRect();
    }

    /** @ignore */
    private setPosition(position: ConnectedOverlayPositionChange, arrowDimensions: { width: number; height: number }) {
        this.setAnchorOrTriggerRect();
        const posParams = getArrowPositionParams(
            getSideAndAlignFromAllPossibleConnectedPositions(position.connectionPair),
            { width: arrowDimensions.width, height: arrowDimensions.height },
            { width: this.anchorOrTriggerRect.width, height: this.anchorOrTriggerRect.height }
        );

        this.renderer.setStyle(this.elementRef.nativeElement, 'top', posParams.top);
        this.renderer.setStyle(this.elementRef.nativeElement, 'bottom', '');
        this.renderer.setStyle(this.elementRef.nativeElement, 'left', posParams.left);
        this.renderer.setStyle(this.elementRef.nativeElement, 'right', '');
        this.renderer.setStyle(this.elementRef.nativeElement, 'transform', posParams.transform);
        this.renderer.setStyle(this.elementRef.nativeElement, 'transformOrigin', posParams.transformOrigin);
    }

    /** @ignore */
    private onArrowSvgElementChangeEffect() {
        effect(() => {
            const arrowElement = this.arrowSvgElement();
            untracked(() => {
                const currentArrowSvgElement = this.currentArrowSvgElement();
                if (currentArrowSvgElement) {
                    this.renderer.removeChild(this.elementRef.nativeElement, currentArrowSvgElement);
                }
                this.currentArrowSvgElement.set(arrowElement);
                this.renderer.setStyle(this.elementRef.nativeElement, 'width', `${this.width()}px`);
                this.renderer.setStyle(this.elementRef.nativeElement, 'height', `${this.height()}px`);
                this.renderer.appendChild(this.elementRef.nativeElement, this.currentArrowSvgElement());
            });
        });
    }

    /** @ignore */
    private onContentPositionAndArrowDimensionsChangeEffect() {
        effect(() => {
            const position = this.position();
            const arrowDimensions = { width: this.width(), height: this.height() };
            untracked(() => {
                if (!position) {
                    return;
                }
                this.setPosition(position, arrowDimensions);
            });
        });
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/src/hover-card-arrow.token.ts
```typescript
import { InjectionToken } from '@angular/core';
import { RdxHoverCardArrowDirective } from './hover-card-arrow.directive';

export const RdxHoverCardArrowToken = new InjectionToken<RdxHoverCardArrowDirective>('RdxHoverCardArrowToken');

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/src/hover-card-close.directive.ts
```typescript
import { Directive, effect, ElementRef, forwardRef, inject, Renderer2, untracked } from '@angular/core';
import { RdxHoverCardCloseToken } from './hover-card-close.token';
import { injectHoverCardRoot } from './hover-card-root.inject';

/**
 * TODO: to be removed? But it seems to be useful when controlled from outside
 */
@Directive({
    selector: '[rdxHoverCardClose]',
    host: {
        type: 'button',
        '(click)': 'rootDirective.handleClose(true)'
    },
    providers: [
        {
            provide: RdxHoverCardCloseToken,
            useExisting: forwardRef(() => RdxHoverCardCloseDirective)
        }
    ]
})
export class RdxHoverCardCloseDirective {
    /** @ignore */
    protected readonly rootDirective = injectHoverCardRoot();
    /** @ignore */
    readonly elementRef = inject(ElementRef);
    /** @ignore */
    private readonly renderer = inject(Renderer2);

    constructor() {
        this.onIsControlledExternallyEffect();
    }

    /** @ignore */
    private onIsControlledExternallyEffect() {
        effect(() => {
            const isControlledExternally = this.rootDirective.controlledExternally()();

            untracked(() => {
                this.renderer.setStyle(
                    this.elementRef.nativeElement,
                    'display',
                    isControlledExternally ? null : 'none'
                );
            });
        });
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/src/hover-card-close.token.ts
```typescript
import { InjectionToken } from '@angular/core';
import { RdxHoverCardCloseDirective } from './hover-card-close.directive';

export const RdxHoverCardCloseToken = new InjectionToken<RdxHoverCardCloseDirective>('RdxHoverCardCloseToken');

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/src/hover-card-content-attributes.component.ts
```typescript
import { ChangeDetectionStrategy, Component, computed, forwardRef } from '@angular/core';
import { RdxHoverCardContentAttributesToken } from './hover-card-content-attributes.token';
import { injectHoverCardRoot } from './hover-card-root.inject';
import { RdxHoverCardAnimationStatus, RdxHoverCardState } from './hover-card.types';

@Component({
    selector: '[rdxHoverCardContentAttributes]',
    template: `
        <ng-content />
    `,
    host: {
        '[attr.role]': '"dialog"',
        '[attr.id]': 'name()',
        '[attr.data-state]': 'rootDirective.state()',
        '[attr.data-side]': 'rootDirective.contentDirective().side()',
        '[attr.data-align]': 'rootDirective.contentDirective().align()',
        '[style]': 'disableAnimation() ? {animation: "none !important"} : null',
        '(animationstart)': 'onAnimationStart($event)',
        '(animationend)': 'onAnimationEnd($event)',
        '(pointerenter)': 'pointerenter()',
        '(pointerleave)': 'pointerleave()',
        '(focus)': 'focus()',
        '(blur)': 'blur()'
    },
    providers: [
        {
            provide: RdxHoverCardContentAttributesToken,
            useExisting: forwardRef(() => RdxHoverCardContentAttributesComponent)
        }
    ],
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class RdxHoverCardContentAttributesComponent {
    /** @ignore */
    protected readonly rootDirective = injectHoverCardRoot();

    /** @ignore */
    readonly name = computed(() => `rdx-hover-card-content-attributes-${this.rootDirective.uniqueId()}`);

    /** @ignore */
    readonly disableAnimation = computed(() => !this.canAnimate());

    /** @ignore */
    protected onAnimationStart(_: AnimationEvent) {
        this.rootDirective.cssAnimationStatus.set(
            this.rootDirective.state() === RdxHoverCardState.OPEN
                ? RdxHoverCardAnimationStatus.OPEN_STARTED
                : RdxHoverCardAnimationStatus.CLOSED_STARTED
        );
    }

    /** @ignore */
    protected onAnimationEnd(_: AnimationEvent) {
        this.rootDirective.cssAnimationStatus.set(
            this.rootDirective.state() === RdxHoverCardState.OPEN
                ? RdxHoverCardAnimationStatus.OPEN_ENDED
                : RdxHoverCardAnimationStatus.CLOSED_ENDED
        );
    }

    /** @ignore */
    protected pointerenter(): void {
        this.rootDirective.handleOpen();
    }

    /** @ignore */
    protected pointerleave(): void {
        this.rootDirective.handleClose();
    }

    /** @ignore */
    protected focus(): void {
        this.rootDirective.handleOpen();
    }

    /** @ignore */
    protected blur(): void {
        this.rootDirective.handleClose();
    }

    /** @ignore */
    private canAnimate() {
        return (
            this.rootDirective.cssAnimation() &&
            ((this.rootDirective.cssOpeningAnimation() && this.rootDirective.state() === RdxHoverCardState.OPEN) ||
                (this.rootDirective.cssClosingAnimation() && this.rootDirective.state() === RdxHoverCardState.CLOSED))
        );
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/src/hover-card-content-attributes.token.ts
```typescript
import { InjectionToken } from '@angular/core';
import { RdxHoverCardContentAttributesComponent } from './hover-card-content-attributes.component';

export const RdxHoverCardContentAttributesToken = new InjectionToken<RdxHoverCardContentAttributesComponent>(
    'RdxHoverCardContentAttributesToken'
);

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/src/hover-card-content.directive.ts
```typescript
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import { CdkConnectedOverlay, Overlay } from '@angular/cdk/overlay';
import {
    booleanAttribute,
    computed,
    DestroyRef,
    Directive,
    effect,
    inject,
    input,
    numberAttribute,
    OnInit,
    output,
    SimpleChange,
    TemplateRef,
    untracked
} from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import {
    getAllPossibleConnectedPositions,
    getContentPosition,
    RDX_POSITIONING_DEFAULTS,
    RdxPositionAlign,
    RdxPositionSide,
    RdxPositionSideAndAlignOffsets
} from '@radix-ng/primitives/core';
import { filter, tap } from 'rxjs';
import { injectHoverCardRoot } from './hover-card-root.inject';
import { RdxHoverCardAttachDetachEvent } from './hover-card.types';

@Directive({
    selector: '[rdxHoverCardContent]',
    hostDirectives: [
        CdkConnectedOverlay
    ]
})
export class RdxHoverCardContentDirective implements OnInit {
    /** @ignore */
    private readonly rootDirective = injectHoverCardRoot();
    /** @ignore */
    private readonly templateRef = inject(TemplateRef);
    /** @ignore */
    private readonly overlay = inject(Overlay);
    /** @ignore */
    private readonly destroyRef = inject(DestroyRef);
    /** @ignore */
    private readonly connectedOverlay = inject(CdkConnectedOverlay);

    /** @ignore */
    readonly name = computed(() => `rdx-hover-card-trigger-${this.rootDirective.uniqueId()}`);

    /**
     * @description The preferred side of the trigger to render against when open. Will be reversed when collisions occur and avoidCollisions is enabled.
     * @default top
     */
    readonly side = input<RdxPositionSide>(RdxPositionSide.Top);
    /**
     * @description The distance in pixels from the trigger.
     * @default undefined
     */
    readonly sideOffset = input<number, NumberInput>(NaN, {
        transform: numberAttribute
    });
    /**
     * @description The preferred alignment against the trigger. May change when collisions occur.
     * @default center
     */
    readonly align = input<RdxPositionAlign>(RdxPositionAlign.Center);
    /**
     * @description An offset in pixels from the "start" or "end" alignment options.
     * @default undefined
     */
    readonly alignOffset = input<number, NumberInput>(NaN, {
        transform: numberAttribute
    });

    /**
     * @description Whether to add some alternate positions of the content.
     * @default false
     */
    readonly alternatePositionsDisabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /** @description Whether to prevent `onOverlayEscapeKeyDown` handler from calling. */
    readonly onOverlayEscapeKeyDownDisabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });
    /** @description Whether to prevent `onOverlayOutsideClick` handler from calling. */
    readonly onOverlayOutsideClickDisabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * @description Event handler called when the escape key is down.
     * It can be prevented by setting `onOverlayEscapeKeyDownDisabled` input to `true`.
     */
    readonly onOverlayEscapeKeyDown = output<KeyboardEvent>();
    /**
     * @description Event handler called when a pointer event occurs outside the bounds of the component.
     * It can be prevented by setting `onOverlayOutsideClickDisabled` input to `true`.
     */
    readonly onOverlayOutsideClick = output<MouseEvent>();

    /**
     * @description Event handler called after the overlay is open
     */
    readonly onOpen = output<void>();
    /**
     * @description Event handler called after the overlay is closed
     */
    readonly onClosed = output<void>();

    /** @ingore */
    readonly positions = computed(() => this.computePositions());

    constructor() {
        this.onOriginChangeEffect();
        this.onPositionChangeEffect();
    }

    /** @ignore */
    ngOnInit() {
        this.setScrollStrategy();
        this.setHasBackdrop();
        this.setDisableClose();
        this.onAttach();
        this.onDetach();
        this.connectKeydownEscape();
        this.connectOutsideClick();
    }

    /** @ignore */
    open() {
        if (this.connectedOverlay.open) {
            return;
        }
        const prevOpen = this.connectedOverlay.open;
        this.connectedOverlay.open = true;
        this.fireOverlayNgOnChanges('open', this.connectedOverlay.open, prevOpen);
    }

    /** @ignore */
    close() {
        if (!this.connectedOverlay.open) {
            return;
        }
        const prevOpen = this.connectedOverlay.open;
        this.connectedOverlay.open = false;
        this.fireOverlayNgOnChanges('open', this.connectedOverlay.open, prevOpen);
    }

    /** @ignore */
    positionChange() {
        return this.connectedOverlay.positionChange.asObservable();
    }

    /** @ignore */
    private connectKeydownEscape() {
        this.connectedOverlay.overlayKeydown
            .asObservable()
            .pipe(
                filter(
                    () =>
                        !this.onOverlayEscapeKeyDownDisabled() &&
                        !this.rootDirective.rdxCdkEventService?.primitivePreventedFromCdkEvent(
                            this.rootDirective,
                            'cdkOverlayEscapeKeyDown'
                        )
                ),
                filter((event) => event.key === 'Escape'),
                tap((event) => {
                    this.onOverlayEscapeKeyDown.emit(event);
                }),
                filter(() => !this.rootDirective.firstDefaultOpen()),
                tap(() => {
                    this.rootDirective.handleClose();
                }),
                takeUntilDestroyed(this.destroyRef)
            )
            .subscribe();
    }

    /** @ignore */
    private connectOutsideClick() {
        this.connectedOverlay.overlayOutsideClick
            .asObservable()
            .pipe(
                filter(
                    () =>
                        !this.onOverlayOutsideClickDisabled() &&
                        !this.rootDirective.rdxCdkEventService?.primitivePreventedFromCdkEvent(
                            this.rootDirective,
                            'cdkOverlayOutsideClick'
                        )
                ),
                /**
                 * Handle the situation when an anchor is added and the anchor becomes the origin of the overlay
                 * hence  the trigger will be considered the outside element
                 */
                filter((event) => {
                    return (
                        !this.rootDirective.anchorDirective() ||
                        !this.rootDirective
                            .triggerDirective()
                            .elementRef.nativeElement.contains(event.target as Element)
                    );
                }),
                tap((event) => {
                    this.onOverlayOutsideClick.emit(event);
                }),
                filter(() => !this.rootDirective.firstDefaultOpen()),
                tap(() => {
                    this.rootDirective.handleClose();
                }),
                takeUntilDestroyed(this.destroyRef)
            )
            .subscribe();
    }

    /** @ignore */
    private onAttach() {
        this.connectedOverlay.attach
            .asObservable()
            .pipe(
                tap(() => {
                    /**
                     * `this.onOpen.emit();` is being delegated to the rootDirective directive due to the opening animation
                     */
                    this.rootDirective.attachDetachEvent.set(RdxHoverCardAttachDetachEvent.ATTACH);
                }),
                takeUntilDestroyed(this.destroyRef)
            )
            .subscribe();
    }

    /** @ignore */
    private onDetach() {
        this.connectedOverlay.detach
            .asObservable()
            .pipe(
                tap(() => {
                    /**
                     * `this.onClosed.emit();` is being delegated to the rootDirective directive due to the closing animation
                     */
                    this.rootDirective.attachDetachEvent.set(RdxHoverCardAttachDetachEvent.DETACH);
                }),
                takeUntilDestroyed(this.destroyRef)
            )
            .subscribe();
    }

    /** @ignore */
    private setScrollStrategy() {
        const prevScrollStrategy = this.connectedOverlay.scrollStrategy;
        this.connectedOverlay.scrollStrategy = this.overlay.scrollStrategies.reposition();
        this.fireOverlayNgOnChanges('scrollStrategy', this.connectedOverlay.scrollStrategy, prevScrollStrategy);
    }

    /** @ignore */
    private setHasBackdrop() {
        const prevHasBackdrop = this.connectedOverlay.hasBackdrop;
        this.connectedOverlay.hasBackdrop = false;
        this.fireOverlayNgOnChanges('hasBackdrop', this.connectedOverlay.hasBackdrop, prevHasBackdrop);
    }

    /** @ignore */
    private setDisableClose() {
        const prevDisableClose = this.connectedOverlay.disableClose;
        this.connectedOverlay.disableClose = true;
        this.fireOverlayNgOnChanges('disableClose', this.connectedOverlay.disableClose, prevDisableClose);
    }

    /** @ignore */
    private setOrigin(origin: CdkConnectedOverlay['origin']) {
        const prevOrigin = this.connectedOverlay.origin;
        this.connectedOverlay.origin = origin;
        this.fireOverlayNgOnChanges('origin', this.connectedOverlay.origin, prevOrigin);
    }

    /** @ignore */
    private setPositions(positions: CdkConnectedOverlay['positions']) {
        const prevPositions = this.connectedOverlay.positions;
        this.connectedOverlay.positions = positions;
        this.fireOverlayNgOnChanges('positions', this.connectedOverlay.positions, prevPositions);
        this.connectedOverlay.overlayRef?.updatePosition();
    }

    /** @ignore */
    private computePositions() {
        const arrowHeight = this.rootDirective.arrowDirective()?.height() ?? 0;
        const offsets: RdxPositionSideAndAlignOffsets = {
            sideOffset:
                arrowHeight + (isNaN(this.sideOffset()) ? RDX_POSITIONING_DEFAULTS.offsets.side : this.sideOffset()),
            alignOffset: isNaN(this.alignOffset()) ? RDX_POSITIONING_DEFAULTS.offsets.align : this.alignOffset()
        };
        const basePosition = getContentPosition({
            side: this.side(),
            align: this.align(),
            sideOffset: offsets.sideOffset,
            alignOffset: offsets.alignOffset
        });
        const positions = [basePosition];
        if (!this.alternatePositionsDisabled()) {
            /**
             * Alternate positions for better user experience along the X/Y axis (e.g. vertical/horizontal scrolling)
             */
            const allPossibleConnectedPositions = getAllPossibleConnectedPositions();
            allPossibleConnectedPositions.forEach((_, key) => {
                const sideAndAlignArray = key.split('|');
                if (
                    (sideAndAlignArray[0] as RdxPositionSide) !== this.side() ||
                    (sideAndAlignArray[1] as RdxPositionAlign) !== this.align()
                ) {
                    positions.push(
                        getContentPosition({
                            side: sideAndAlignArray[0] as RdxPositionSide,
                            align: sideAndAlignArray[1] as RdxPositionAlign,
                            sideOffset: offsets.sideOffset,
                            alignOffset: offsets.alignOffset
                        })
                    );
                }
            });
        }
        return positions;
    }

    private onOriginChangeEffect() {
        effect(() => {
            const origin = (this.rootDirective.anchorDirective() ?? this.rootDirective.triggerDirective())
                .overlayOrigin;
            untracked(() => {
                this.setOrigin(origin);
            });
        });
    }

    /** @ignore */
    private onPositionChangeEffect() {
        effect(() => {
            const positions = this.positions();
            this.alternatePositionsDisabled();
            untracked(() => {
                this.setPositions(positions);
            });
        });
    }

    /** @ignore */
    private fireOverlayNgOnChanges<K extends keyof CdkConnectedOverlay, V extends CdkConnectedOverlay[K]>(
        input: K,
        currentValue: V,
        previousValue: V,
        firstChange = false
    ) {
        this.connectedOverlay.ngOnChanges({
            [input]: new SimpleChange(previousValue, currentValue, firstChange)
        });
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/src/hover-card-root.directive.ts
```typescript
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import {
    afterNextRender,
    booleanAttribute,
    computed,
    contentChild,
    DestroyRef,
    Directive,
    effect,
    inject,
    input,
    numberAttribute,
    signal,
    untracked,
    ViewContainerRef
} from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { debounce, map, Subject, tap, timer } from 'rxjs';
import { RdxHoverCardAnchorDirective } from './hover-card-anchor.directive';
import { RdxHoverCardAnchorToken } from './hover-card-anchor.token';
import { RdxHoverCardArrowToken } from './hover-card-arrow.token';
import { RdxHoverCardCloseToken } from './hover-card-close.token';
import { RdxHoverCardContentAttributesToken } from './hover-card-content-attributes.token';
import { RdxHoverCardContentDirective } from './hover-card-content.directive';
import { RdxHoverCardTriggerDirective } from './hover-card-trigger.directive';
import {
    RdxHoverCardAction,
    RdxHoverCardAnimationStatus,
    RdxHoverCardAttachDetachEvent,
    RdxHoverCardState
} from './hover-card.types';
import { injectRdxCdkEventService } from './utils/cdk-event.service';

let nextId = 0;

@Directive({
    selector: '[rdxHoverCardRoot]',
    exportAs: 'rdxHoverCardRoot'
})
export class RdxHoverCardRootDirective {
    /** @ignore */
    readonly uniqueId = signal(++nextId);
    /** @ignore */
    readonly name = computed(() => `rdx-hover-card-root-${this.uniqueId()}`);

    /**
     * @description The anchor directive that comes form outside the hover-card rootDirective
     * @default undefined
     */
    readonly anchor = input<RdxHoverCardAnchorDirective | undefined>(void 0);
    /**
     * @description The open state of the hover-card when it is initially rendered. Use when you do not need to control its open state.
     * @default false
     */
    readonly defaultOpen = input<boolean, BooleanInput>(false, { transform: booleanAttribute });
    /**
     * @description The controlled state of the hover-card. `open` input take precedence of `defaultOpen` input.
     * @default undefined
     */
    readonly open = input<boolean | undefined, BooleanInput>(void 0, { transform: booleanAttribute });
    /**
     * To customise the open delay for a specific hover-card.
     */
    readonly openDelay = input<number, NumberInput>(500, {
        transform: numberAttribute
    });
    /**
     * To customise the close delay for a specific hover-card.
     */
    readonly closeDelay = input<number, NumberInput>(200, {
        transform: numberAttribute
    });
    /**
     * @description Whether to control the state of the hover-card from external. Use in conjunction with `open` input.
     * @default undefined
     */
    readonly externalControl = input<boolean | undefined, BooleanInput>(void 0, { transform: booleanAttribute });
    /**
     * @description Whether to take into account CSS opening/closing animations.
     * @default false
     */
    readonly cssAnimation = input<boolean, BooleanInput>(false, { transform: booleanAttribute });
    /**
     * @description Whether to take into account CSS opening animations. `cssAnimation` input must be set to 'true'
     * @default false
     */
    readonly cssOpeningAnimation = input<boolean, BooleanInput>(false, { transform: booleanAttribute });
    /**
     * @description Whether to take into account CSS closing animations. `cssAnimation` input must be set to 'true'
     * @default false
     */
    readonly cssClosingAnimation = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /** @ignore */
    readonly cssAnimationStatus = signal<RdxHoverCardAnimationStatus | null>(null);

    /** @ignore */
    readonly contentDirective = contentChild.required(RdxHoverCardContentDirective);
    /** @ignore */
    readonly triggerDirective = contentChild.required(RdxHoverCardTriggerDirective);
    /** @ignore */
    readonly arrowDirective = contentChild(RdxHoverCardArrowToken);
    /** @ignore */
    readonly closeDirective = contentChild(RdxHoverCardCloseToken);
    /** @ignore */
    readonly contentAttributesComponent = contentChild(RdxHoverCardContentAttributesToken);
    /** @ignore */
    private readonly internalAnchorDirective = contentChild(RdxHoverCardAnchorToken);

    /** @ignore */
    readonly viewContainerRef = inject(ViewContainerRef);
    /** @ignore */
    readonly rdxCdkEventService = injectRdxCdkEventService();
    /** @ignore */
    readonly destroyRef = inject(DestroyRef);

    /** @ignore */
    readonly state = signal(RdxHoverCardState.CLOSED);

    /** @ignore */
    readonly attachDetachEvent = signal(RdxHoverCardAttachDetachEvent.DETACH);

    /** @ignore */
    private readonly isFirstDefaultOpen = signal(false);

    /** @ignore */
    readonly anchorDirective = computed(() => this.internalAnchorDirective() ?? this.anchor());

    /** @ignore */
    readonly actionSubject$ = new Subject<RdxHoverCardAction>();

    constructor() {
        this.rdxCdkEventService?.registerPrimitive(this);
        this.destroyRef.onDestroy(() => this.rdxCdkEventService?.deregisterPrimitive(this));
        this.actionSubscription();
        this.onStateChangeEffect();
        this.onCssAnimationStatusChangeChangeEffect();
        this.onOpenChangeEffect();
        this.onIsFirstDefaultOpenChangeEffect();
        this.onAnchorChangeEffect();
        this.emitOpenOrClosedEventEffect();
        afterNextRender({
            write: () => {
                if (this.defaultOpen() && !this.open()) {
                    this.isFirstDefaultOpen.set(true);
                }
            }
        });
    }

    /** @ignore */
    getAnimationParamsSnapshot() {
        return {
            cssAnimation: this.cssAnimation(),
            cssOpeningAnimation: this.cssOpeningAnimation(),
            cssClosingAnimation: this.cssClosingAnimation(),
            cssAnimationStatus: this.cssAnimationStatus(),
            attachDetachEvent: this.attachDetachEvent(),
            state: this.state(),
            canEmitOnOpenOrOnClosed: this.canEmitOnOpenOrOnClosed()
        };
    }

    /** @ignore */
    controlledExternally() {
        return this.externalControl;
    }

    /** @ignore */
    firstDefaultOpen() {
        return this.isFirstDefaultOpen();
    }

    /** @ignore */
    handleOpen(): void {
        if (this.externalControl()) {
            return;
        }
        this.actionSubject$.next(RdxHoverCardAction.OPEN);
    }

    /** @ignore */
    handleClose(closeButton?: boolean): void {
        if (this.isFirstDefaultOpen()) {
            this.isFirstDefaultOpen.set(false);
        }
        if (!closeButton && this.externalControl()) {
            return;
        }
        this.actionSubject$.next(RdxHoverCardAction.CLOSE);
    }

    /** @ignore */
    handleToggle(): void {
        if (this.externalControl()) {
            return;
        }
        this.isOpen() ? this.handleClose() : this.handleOpen();
    }

    /** @ignore */
    isOpen(state?: RdxHoverCardState) {
        return (state ?? this.state()) === RdxHoverCardState.OPEN;
    }

    /** @ignore */
    private setState(state = RdxHoverCardState.CLOSED): void {
        if (state === this.state()) {
            return;
        }
        this.state.set(state);
    }

    /** @ignore */
    private openContent(): void {
        this.contentDirective().open();
        if (!this.cssAnimation() || !this.cssOpeningAnimation()) {
            this.cssAnimationStatus.set(null);
        }
    }

    /** @ignore */
    private closeContent(): void {
        this.contentDirective().close();
        if (!this.cssAnimation() || !this.cssClosingAnimation()) {
            this.cssAnimationStatus.set(null);
        }
    }

    /** @ignore */
    private emitOnOpen(): void {
        this.contentDirective().onOpen.emit();
    }

    /** @ignore */
    private emitOnClosed(): void {
        this.contentDirective().onClosed.emit();
    }

    /** @ignore */
    private ifOpenOrCloseWithoutAnimations(state: RdxHoverCardState) {
        return (
            !this.contentAttributesComponent() ||
            !this.cssAnimation() ||
            (this.cssAnimation() && !this.cssClosingAnimation() && state === RdxHoverCardState.CLOSED) ||
            (this.cssAnimation() && !this.cssOpeningAnimation() && state === RdxHoverCardState.OPEN) ||
            // !this.cssAnimationStatus() ||
            (this.cssOpeningAnimation() &&
                state === RdxHoverCardState.OPEN &&
                [RdxHoverCardAnimationStatus.OPEN_STARTED].includes(this.cssAnimationStatus()!)) ||
            (this.cssClosingAnimation() &&
                state === RdxHoverCardState.CLOSED &&
                [RdxHoverCardAnimationStatus.CLOSED_STARTED].includes(this.cssAnimationStatus()!))
        );
    }

    /** @ignore */
    private ifOpenOrCloseWithAnimations(cssAnimationStatus: RdxHoverCardAnimationStatus | null) {
        return (
            this.contentAttributesComponent() &&
            this.cssAnimation() &&
            cssAnimationStatus &&
            ((this.cssOpeningAnimation() &&
                this.state() === RdxHoverCardState.OPEN &&
                [RdxHoverCardAnimationStatus.OPEN_ENDED].includes(cssAnimationStatus)) ||
                (this.cssClosingAnimation() &&
                    this.state() === RdxHoverCardState.CLOSED &&
                    [RdxHoverCardAnimationStatus.CLOSED_ENDED].includes(cssAnimationStatus)))
        );
    }

    /** @ignore */
    private openOrClose(state: RdxHoverCardState) {
        const isOpen = this.isOpen(state);
        isOpen ? this.openContent() : this.closeContent();
    }

    /** @ignore */
    private emitOnOpenOrOnClosed(state: RdxHoverCardState) {
        this.isOpen(state)
            ? this.attachDetachEvent() === RdxHoverCardAttachDetachEvent.ATTACH && this.emitOnOpen()
            : this.attachDetachEvent() === RdxHoverCardAttachDetachEvent.DETACH && this.emitOnClosed();
    }

    /** @ignore */
    private canEmitOnOpenOrOnClosed() {
        return (
            !this.cssAnimation() ||
            (!this.cssOpeningAnimation() && this.state() === RdxHoverCardState.OPEN) ||
            (this.cssOpeningAnimation() &&
                this.state() === RdxHoverCardState.OPEN &&
                this.cssAnimationStatus() === RdxHoverCardAnimationStatus.OPEN_ENDED) ||
            (!this.cssClosingAnimation() && this.state() === RdxHoverCardState.CLOSED) ||
            (this.cssClosingAnimation() &&
                this.state() === RdxHoverCardState.CLOSED &&
                this.cssAnimationStatus() === RdxHoverCardAnimationStatus.CLOSED_ENDED)
        );
    }

    /** @ignore */
    private onStateChangeEffect() {
        let isFirst = true;
        effect(() => {
            const state = this.state();
            untracked(() => {
                if (isFirst) {
                    isFirst = false;
                    return;
                }
                if (!this.ifOpenOrCloseWithoutAnimations(state)) {
                    return;
                }
                this.openOrClose(state);
            });
        }, {});
    }

    /** @ignore */
    private onCssAnimationStatusChangeChangeEffect() {
        let isFirst = true;
        effect(() => {
            const cssAnimationStatus = this.cssAnimationStatus();
            untracked(() => {
                if (isFirst) {
                    isFirst = false;
                    return;
                }
                if (!this.ifOpenOrCloseWithAnimations(cssAnimationStatus)) {
                    return;
                }
                this.openOrClose(this.state());
            });
        });
    }

    /** @ignore */
    private emitOpenOrClosedEventEffect() {
        let isFirst = true;
        effect(() => {
            this.attachDetachEvent();
            this.cssAnimationStatus();
            untracked(() => {
                if (isFirst) {
                    isFirst = false;
                    return;
                }
                const canEmitOpenClose = untracked(() => this.canEmitOnOpenOrOnClosed());
                if (!canEmitOpenClose) {
                    return;
                }
                this.emitOnOpenOrOnClosed(this.state());
            });
        });
    }

    /** @ignore */
    private onOpenChangeEffect() {
        effect(() => {
            const open = this.open();
            untracked(() => {
                this.setState(open ? RdxHoverCardState.OPEN : RdxHoverCardState.CLOSED);
            });
        });
    }

    /** @ignore */
    private onIsFirstDefaultOpenChangeEffect() {
        const effectRef = effect(() => {
            const defaultOpen = this.defaultOpen();
            untracked(() => {
                if (!defaultOpen || this.open()) {
                    effectRef.destroy();
                    return;
                }
                this.handleOpen();
            });
        });
    }

    /** @ignore */
    private onAnchorChangeEffect = () => {
        effect(() => {
            const anchor = this.anchor();
            untracked(() => {
                if (anchor) {
                    anchor.setRoot(this);
                }
            });
        });
    };

    /** @ignore */
    private actionSubscription() {
        this.actionSubject$
            .asObservable()
            .pipe(
                map((action) => {
                    switch (action) {
                        case RdxHoverCardAction.OPEN:
                            return { action, duration: this.openDelay() };
                        case RdxHoverCardAction.CLOSE:
                            return { action, duration: this.closeDelay() };
                    }
                }),
                debounce((config) => timer(config.duration)),
                tap((config) => {
                    switch (config.action) {
                        case RdxHoverCardAction.OPEN:
                            this.setState(RdxHoverCardState.OPEN);
                            break;
                        case RdxHoverCardAction.CLOSE:
                            this.setState(RdxHoverCardState.CLOSED);
                            break;
                    }
                }),
                takeUntilDestroyed()
            )
            .subscribe();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/src/hover-card-root.inject.ts
```typescript
import { assertInInjectionContext, inject, isDevMode } from '@angular/core';
import { RdxHoverCardRootDirective } from './hover-card-root.directive';

export function injectHoverCardRoot(optional?: false): RdxHoverCardRootDirective;
export function injectHoverCardRoot(optional: true): RdxHoverCardRootDirective | null;
export function injectHoverCardRoot(optional = false): RdxHoverCardRootDirective | null {
    isDevMode() && assertInInjectionContext(injectHoverCardRoot);
    return inject(RdxHoverCardRootDirective, { optional });
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/src/hover-card-trigger.directive.ts
```typescript
import { CdkOverlayOrigin } from '@angular/cdk/overlay';
import { computed, Directive, ElementRef, inject } from '@angular/core';
import { injectHoverCardRoot } from './hover-card-root.inject';

@Directive({
    selector: '[rdxHoverCardTrigger]',
    hostDirectives: [CdkOverlayOrigin],
    host: {
        '[attr.id]': 'name()',
        '[attr.aria-haspopup]': '"dialog"',
        '[attr.aria-expanded]': 'rootDirective.isOpen()',
        '[attr.aria-controls]': 'rootDirective.contentDirective().name()',
        '[attr.data-state]': 'rootDirective.state()',
        '(pointerenter)': 'pointerenter()',
        '(pointerleave)': 'pointerleave()',
        '(focus)': 'focus()',
        '(blur)': 'blur()',
        '(click)': 'click()'
    }
})
export class RdxHoverCardTriggerDirective {
    /** @ignore */
    protected readonly rootDirective = injectHoverCardRoot();
    /** @ignore */
    readonly elementRef = inject<ElementRef<HTMLElement>>(ElementRef);
    /** @ignore */
    readonly overlayOrigin = inject(CdkOverlayOrigin);

    /** @ignore */
    readonly name = computed(() => `rdx-hover-card-trigger-${this.rootDirective.uniqueId()}`);

    /** @ignore */
    protected pointerenter(): void {
        this.rootDirective.handleOpen();
    }

    /** @ignore */
    protected pointerleave(): void {
        this.rootDirective.handleClose();
    }

    /** @ignore */
    protected focus(): void {
        this.rootDirective.handleOpen();
    }

    /** @ignore */
    protected blur(): void {
        this.rootDirective.handleClose();
    }

    /** @ignore */
    protected click(): void {
        this.rootDirective.handleClose();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/src/hover-card.types.ts
```typescript
export enum RdxHoverCardState {
    OPEN = 'open',
    CLOSED = 'closed'
}

export enum RdxHoverCardAction {
    OPEN = 'open',
    CLOSE = 'close'
}

export enum RdxHoverCardAttachDetachEvent {
    ATTACH = 'attach',
    DETACH = 'detach'
}

export enum RdxHoverCardAnimationStatus {
    OPEN_STARTED = 'open_started',
    OPEN_ENDED = 'open_ended',
    CLOSED_STARTED = 'closed_started',
    CLOSED_ENDED = 'closed_ended'
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/src/utils/cdk-event.service.ts
```typescript
import {
    DestroyRef,
    EnvironmentProviders,
    inject,
    Injectable,
    InjectionToken,
    isDevMode,
    makeEnvironmentProviders,
    NgZone,
    Provider,
    Renderer2,
    VERSION
} from '@angular/core';
import { injectDocument, injectWindow } from '@radix-ng/primitives/core';
import { RdxCdkEventServiceWindowKey } from './constants';
import { EventType, EventTypeAsPrimitiveConfigKey, PrimitiveConfig, PrimitiveConfigs } from './types';

function eventTypeAsPrimitiveConfigKey(eventType: EventType): EventTypeAsPrimitiveConfigKey {
    return `prevent${eventType[0].toUpperCase()}${eventType.slice(1)}` as EventTypeAsPrimitiveConfigKey;
}

@Injectable()
class RdxCdkEventService {
    document = injectDocument();
    destroyRef = inject(DestroyRef);
    ngZone = inject(NgZone);
    renderer2 = inject(Renderer2);
    window = injectWindow();

    primitiveConfigs?: PrimitiveConfigs;

    onDestroyCallbacks: Set<() => void> = new Set([() => deleteRdxCdkEventServiceWindowKey(this.window)]);

    #clickDomRootEventCallbacks: Set<(event: MouseEvent) => void> = new Set();

    constructor() {
        this.#listenToClickDomRootEvent();
        this.#registerOnDestroyCallbacks();
    }

    registerPrimitive<T extends object>(primitiveInstance: T) {
        if (!this.primitiveConfigs) {
            this.primitiveConfigs = new Map();
        }
        if (!this.primitiveConfigs.has(primitiveInstance)) {
            this.primitiveConfigs.set(primitiveInstance, {});
        }
    }

    deregisterPrimitive<T extends object>(primitiveInstance: T) {
        if (this.primitiveConfigs?.has(primitiveInstance)) {
            this.primitiveConfigs.delete(primitiveInstance);
        }
    }

    preventPrimitiveFromCdkEvent<T extends object>(primitiveInstance: T, eventType: EventType) {
        this.#setPreventPrimitiveFromCdkEvent(primitiveInstance, eventType, true);
    }

    allowPrimitiveForCdkEvent<T extends object>(primitiveInstance: T, eventType: EventType) {
        this.#setPreventPrimitiveFromCdkEvent(primitiveInstance, eventType, false);
    }

    preventPrimitiveFromCdkMultiEvents<T extends object>(primitiveInstance: T, eventTypes: EventType[]) {
        eventTypes.forEach((eventType) => {
            this.#setPreventPrimitiveFromCdkEvent(primitiveInstance, eventType, true);
        });
    }

    allowPrimitiveForCdkMultiEvents<T extends object>(primitiveInstance: T, eventTypes: EventType[]) {
        eventTypes.forEach((eventType) => {
            this.#setPreventPrimitiveFromCdkEvent(primitiveInstance, eventType, false);
        });
    }

    setPreventPrimitiveFromCdkMixEvents<T extends object>(primitiveInstance: T, eventTypes: PrimitiveConfig) {
        Object.keys(eventTypes).forEach((eventType) => {
            this.#setPreventPrimitiveFromCdkEvent(
                primitiveInstance,
                eventType as EventType,
                eventTypes[eventTypeAsPrimitiveConfigKey(eventType as EventType)]
            );
        });
    }

    primitivePreventedFromCdkEvent<T extends object>(primitiveInstance: T, eventType: EventType) {
        return this.primitiveConfigs?.get(primitiveInstance)?.[eventTypeAsPrimitiveConfigKey(eventType)];
    }

    addClickDomRootEventCallback(callback: (event: MouseEvent) => void) {
        this.#clickDomRootEventCallbacks.add(callback);
    }

    removeClickDomRootEventCallback(callback: (event: MouseEvent) => void) {
        return this.#clickDomRootEventCallbacks.delete(callback);
    }

    #setPreventPrimitiveFromCdkEvent<
        T extends object,
        R extends EventType,
        K extends PrimitiveConfig[EventTypeAsPrimitiveConfigKey<R>]
    >(primitiveInstance: T, eventType: R, value: K) {
        if (!this.primitiveConfigs?.has(primitiveInstance)) {
            isDevMode() &&
                console.error(
                    '[RdxCdkEventService.preventPrimitiveFromCdkEvent] RDX Primitive instance has not been registered!',
                    primitiveInstance
                );
            return;
        }
        switch (eventType) {
            case 'cdkOverlayOutsideClick':
                this.primitiveConfigs.get(primitiveInstance)!.preventCdkOverlayOutsideClick = value;
                break;
            case 'cdkOverlayEscapeKeyDown':
                this.primitiveConfigs.get(primitiveInstance)!.preventCdkOverlayEscapeKeyDown = value;
                break;
        }
    }

    #registerOnDestroyCallbacks() {
        this.destroyRef.onDestroy(() => {
            this.onDestroyCallbacks.forEach((onDestroyCallback) => onDestroyCallback());
            this.onDestroyCallbacks.clear();
        });
    }

    #listenToClickDomRootEvent() {
        const target = this.document;
        const eventName = 'click';
        const options: boolean | AddEventListenerOptions | undefined = { capture: true };
        const callback = (event: MouseEvent) => {
            this.#clickDomRootEventCallbacks.forEach((clickDomRootEventCallback) => clickDomRootEventCallback(event));
        };

        const major = parseInt(VERSION.major);
        const minor = parseInt(VERSION.minor);

        let destroyClickDomRootEventListener!: () => void;
        /**
         * @see src/cdk/platform/features/backwards-compatibility.ts in @angular/cdk
         */
        if (major > 19 || (major === 19 && minor > 0) || (major === 0 && minor === 0)) {
            destroyClickDomRootEventListener = this.ngZone.runOutsideAngular(() => {
                const destroyClickDomRootEventListenerInternal = this.renderer2.listen(
                    target,
                    eventName,
                    callback,

                    options
                );
                return () => {
                    destroyClickDomRootEventListenerInternal();
                    this.#clickDomRootEventCallbacks.clear();
                };
            });
        } else {
            /**
             * This part can get removed when v19.1 or higher is on the board
             */
            destroyClickDomRootEventListener = this.ngZone.runOutsideAngular(() => {
                target.addEventListener(eventName, callback, options);
                return () => {
                    this.ngZone.runOutsideAngular(() => target.removeEventListener(eventName, callback, options));
                    this.#clickDomRootEventCallbacks.clear();
                };
            });
        }
        this.onDestroyCallbacks.add(destroyClickDomRootEventListener);
    }
}

const RdxCdkEventServiceToken = new InjectionToken<RdxCdkEventService>('RdxCdkEventServiceToken');

const existsErrorMessage = 'RdxCdkEventService should be provided only once!';

const deleteRdxCdkEventServiceWindowKey = (window: Window & typeof globalThis) => {
    delete (window as any)[RdxCdkEventServiceWindowKey];
};

const getProvider: (throwWhenExists?: boolean) => Provider = (throwWhenExists = true) => ({
    provide: RdxCdkEventServiceToken,
    useFactory: () => {
        isDevMode() && console.log('providing RdxCdkEventService...');
        const window = injectWindow();
        if ((window as any)[RdxCdkEventServiceWindowKey]) {
            if (throwWhenExists) {
                throw Error(existsErrorMessage);
            } else {
                isDevMode() && console.warn(existsErrorMessage);
            }
        }
        (window as any)[RdxCdkEventServiceWindowKey] ??= new RdxCdkEventService();
        return (window as any)[RdxCdkEventServiceWindowKey];
    }
});

export const provideRdxCdkEventServiceInRoot: () => EnvironmentProviders = () =>
    makeEnvironmentProviders([getProvider()]);
export const provideRdxCdkEventService: () => Provider = () => getProvider(false);

export const injectRdxCdkEventService = () => inject(RdxCdkEventServiceToken, { optional: true });

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/src/utils/constants.ts
```typescript
export const RdxCdkEventServiceWindowKey = Symbol('__RdxCdkEventService__');

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/hover-card/src/utils/types.ts
```typescript
export type EventType = 'cdkOverlayOutsideClick' | 'cdkOverlayEscapeKeyDown';
export type EventTypeCapitalized<R extends EventType = EventType> = Capitalize<R>;
export type EventTypeAsPrimitiveConfigKey<R extends EventType = EventType> = `prevent${EventTypeCapitalized<R>}`;
export type PrimitiveConfig = {
    [value in EventTypeAsPrimitiveConfigKey]?: boolean;
};
export type PrimitiveConfigs = Map<object, PrimitiveConfig>;

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/checkbox/README.md
```
# @radix-ng/primitives/checkbox

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/checkbox/index.ts
```typescript
import { NgModule } from '@angular/core';
import { RdxCheckboxButtonDirective } from './src/checkbox-button.directive';
import { RdxCheckboxIndicatorDirective } from './src/checkbox-indicator.directive';
import { RdxCheckboxInputDirective } from './src/checkbox-input.directive';
import { RdxCheckboxDirective } from './src/checkbox.directive';

export * from './src/checkbox-button.directive';
export * from './src/checkbox-indicator.directive';
export * from './src/checkbox-input.directive';
export * from './src/checkbox.directive';
export type { CheckboxState } from './src/checkbox.directive';
export * from './src/checkbox.token';

const _imports = [
    RdxCheckboxInputDirective,
    RdxCheckboxDirective,
    RdxCheckboxButtonDirective,
    RdxCheckboxIndicatorDirective
];

@NgModule({
    imports: [..._imports],
    exports: [..._imports]
})
export class RdxCheckboxModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/checkbox/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/checkbox/stories/checkbox-group.component.ts
```typescript
import { JsonPipe } from '@angular/common';
import { Component } from '@angular/core';
import { FormBuilder, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { RdxLabelDirective } from '@radix-ng/primitives/label';
import { LucideAngularModule } from 'lucide-angular';
import { RdxCheckboxIndicatorDirective } from '../src/checkbox-indicator.directive';
import { RdxCheckboxInputDirective } from '../src/checkbox-input.directive';
import { RdxCheckboxDirective } from '../src/checkbox.directive';

@Component({
    selector: 'checkbox-groups-forms-example',
    template: `
        <section [formGroup]="personality">
            <p>
                <label class="Label" rdxLabel htmlFor="r1">
                    <button class="CheckboxRoot" rdxCheckboxRoot formControlName="fun">
                        <lucide-angular class="CheckboxIndicator" rdxCheckboxIndicator size="16" name="check" />
                        <input class="Input" id="r1" rdxCheckboxInput />
                    </button>
                    Fun
                </label>
            </p>
            <p>
                <label class="Label" rdxLabel htmlFor="r2">
                    <button
                        class="CheckboxRoot rt-BaseCheckboxRoot rt-CheckboxRoot"
                        rdxCheckboxRoot
                        formControlName="serious"
                    >
                        <lucide-angular class="CheckboxIndicator" rdxCheckboxIndicator size="16" name="check" />
                        <input class="Input" id="r2" rdxCheckboxInput />
                    </button>
                    Serious
                </label>
            </p>
            <p>
                <label class="Label" rdxLabel htmlFor="r3">
                    <button class="CheckboxRoot" rdxCheckboxRoot formControlName="smart">
                        <lucide-angular class="CheckboxIndicator" rdxCheckboxIndicator size="16" name="check" />
                        <input class="Input" id="r3" rdxCheckboxInput />
                    </button>
                    Smart
                </label>
            </p>
        </section>
        <section class="Label" [formGroup]="personality">
            <h4>You chose:&nbsp;</h4>
            {{ personality.value | json }}
        </section>

        <button
            class="rt-reset rt-BaseButton rt-r-size-2 rt-variant-solid rt-Button"
            (click)="toggleDisable()"
            data-accent-color="cyan"
        >
            Toggle disabled state
        </button>
    `,
    styleUrl: 'checkbox-group.styles.scss',
    imports: [
        FormsModule,
        ReactiveFormsModule,
        JsonPipe,
        RdxLabelDirective,
        RdxCheckboxDirective,
        RdxCheckboxIndicatorDirective,
        LucideAngularModule,
        RdxCheckboxInputDirective
    ]
})
export class CheckboxReactiveFormsExampleComponent {
    personality = this.formBuilder.group({
        fun: false,
        serious: false,
        smart: false
    });

    constructor(protected formBuilder: FormBuilder) {}

    toggleDisable() {
        const checkbox = this.personality.get('serious');
        if (checkbox != null) {
            checkbox.disabled ? checkbox.enable() : checkbox.disable();
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/checkbox/stories/checkbox-group.styles.scss
```
.Input {
    transform: translateX(-100%);
    position: absolute;
    pointer-events: none;
    opacity: 0;
    margin: 0;
    width: 25px;
    height: 25px;
}

.CheckboxRoot {
    all: unset;
    background-color: white;
    width: 25px;
    height: 25px;
    margin-right: 15px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 10px var(--black-a7);

    &:where(:disabled) {
        cursor: var(--cursor-disabled);
        background-color: var(--gray-5);
    }
}

.CheckboxRoot:focus {
    box-shadow: 0 0 0 2px black;
}

.CheckboxIndicator {
    align-items: center;
    display: flex;
    color: var(--violet-11);
}

.CheckboxIndicator[data-state='unchecked'] {
    display: none;
}

.Label {
    color: white;
    font-size: 15px;
    line-height: 1;
    display: flex;
    align-items: center;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/checkbox/stories/checkbox-indeterminate.component.ts
```typescript
import { Component, model } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { RdxLabelDirective } from '@radix-ng/primitives/label';
import { LucideAngularModule } from 'lucide-angular';
import { RdxCheckboxIndicatorDirective } from '../src/checkbox-indicator.directive';
import { RdxCheckboxInputDirective } from '../src/checkbox-input.directive';
import { RdxCheckboxDirective } from '../src/checkbox.directive';

@Component({
    selector: 'checkbox-indeterminate-example',
    imports: [
        FormsModule,
        RdxLabelDirective,
        RdxCheckboxDirective,
        RdxCheckboxIndicatorDirective,
        LucideAngularModule,
        RdxCheckboxInputDirective
    ],
    template: `
        <label class="Label" rdxLabel htmlFor="r1">
            <button class="CheckboxRoot" [(indeterminate)]="indeterminate" [(ngModel)]="checked" rdxCheckboxRoot>
                <lucide-angular class="CheckboxIndicator" [name]="iconName()" rdxCheckboxIndicator size="16" />
                <input class="Input" id="r1" rdxCheckboxInput />
            </button>
            I'm a checkbox
        </label>

        <p>
            <button
                class="rt-reset rt-BaseButton rt-r-size-2 rt-variant-solid rt-Button"
                (click)="toggleIndeterminate()"
                data-accent-color="cyan"
            >
                Toggle Indeterminate state
            </button>
        </p>
    `,
    styleUrl: 'checkbox-group.styles.scss'
})
export class CheckboxIndeterminateComponent {
    readonly indeterminate = model(false);
    readonly checked = model(false);

    readonly iconName = model('check');

    toggleIndeterminate() {
        this.indeterminate.set(!this.indeterminate());

        this.iconName() === 'check' ? this.iconName.set('minus') : this.iconName.set('check');
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/checkbox/stories/checkbox.docs.mdx
````
import { ArgTypes, Canvas, Markdown, Meta } from '@storybook/blocks';
import { RdxCheckboxDirective } from '../src/checkbox.directive';
import * as CheckboxDirectiveStories from './checkbox.stories';

<Meta title="Primitives/Checkbox" />

# Checkbox

#### A control that allows the user to toggle between checked and not checked.

<Canvas sourceState="hidden" of={CheckboxDirectiveStories.Default} />

## Features

- âœ… Full keyboard navigation.
- âœ… Supports indeterminate \_state.
- âœ… Can be controlled or uncontrolled.

## Import

Get started with importing the directives:

```typescript
import { RdxCheckboxDirective, RdxCheckboxInputDirective, RdxCheckboxIndicatorDirective } from '@radix-ng/primitives/checkbox';
```

## Anatomy

```html
<button rdxCheckboxRoot [(checked)]="checked">
  <lucide-angular rdxCheckboxIndicator name="check" />
  <input rdxCheckboxInput type="checkbox" />
</button>
```

## API Reference

### RdxCheckboxDirective

<ArgTypes of={RdxCheckboxDirective} />

### RdxCheckboxIndicatorDirective

### RdxRadioIndicatorDirective

## Accessibility

Adheres to the [tri-\_state Checkbox WAI-ARIA design pattern](https://www.w3.org/WAI/ARIA/apg/patterns/checkbox).

### Keyboard Interactions

<Markdown>
  {`
  | Key | Description |
  | ----------- | --------- |
  | Space       | Checks/unchecks the checkbox.        |
  `}
</Markdown>

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/checkbox/stories/checkbox.stories.ts
```typescript
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { Check, LucideAngularModule, Minus } from 'lucide-angular';
import { RdxLabelDirective } from '../../label';
import { RdxCheckboxIndicatorDirective } from '../src/checkbox-indicator.directive';
import { RdxCheckboxInputDirective } from '../src/checkbox-input.directive';
import { RdxCheckboxDirective } from '../src/checkbox.directive';
import { CheckboxReactiveFormsExampleComponent } from './checkbox-group.component';
import { CheckboxIndeterminateComponent } from './checkbox-indeterminate.component';

const html = String.raw;

export default {
    title: 'Primitives/Checkbox',
    decorators: [
        moduleMetadata({
            imports: [
                RdxLabelDirective,
                RdxCheckboxDirective,
                RdxCheckboxIndicatorDirective,
                RdxCheckboxInputDirective,
                LucideAngularModule,
                LucideAngularModule.pick({ Check, Minus }),
                CheckboxReactiveFormsExampleComponent,
                CheckboxIndeterminateComponent
            ]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div
                    class="radix-themes light light-theme radix-themes-default-fonts"
                    data-accent-color="indigo"
                    data-gray-color="slate"
                    data-radius="medium"
                    data-scaling="100%"
                >
                    ${story}
                </div>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: html`
            <form>
                <div style="display: flex; align-items: center;">
                    <button class="CheckboxRoot" rdxCheckboxRoot [(checked)]="checked">
                        <lucide-angular
                            class="CheckboxIndicator"
                            rdxCheckboxIndicator
                            size="16"
                            name="check"
                        ></lucide-angular>
                        <input id="r1" rdxCheckboxInput type="checkbox" />
                    </button>
                    <label class="Label" rdxLabel htmlFor="r1">Check Item</label>
                </div>
            </form>

            <style>
                button {
                    all: unset;
                }

                .CheckboxRoot {
                    background-color: white;
                    width: 25px;
                    height: 25px;
                    border-radius: 4px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    box-shadow: 0 2px 10px var(--black-a7);
                }
                .CheckboxRoot:hover {
                    background-color: var(--violet-3);
                }
                .CheckboxRoot:focus {
                    box-shadow: 0 0 0 2px black;
                }

                .CheckboxIndicator {
                    align-items: center;
                    display: flex;
                    color: var(--violet-11);
                }

                .CheckboxIndicator[data-state='unchecked'] {
                    display: none;
                }

                .Label {
                    color: white;
                    padding-left: 15px;
                    font-size: 15px;
                    line-height: 1;
                }
            </style>
        `
    })
};

export const CheckboxGroup: Story = {
    name: 'With Reactive forms',
    render: () => ({
        template: html`
            <checkbox-groups-forms-example></checkbox-groups-forms-example>
        `
    })
};

export const indeterminate: Story = {
    render: () => ({
        template: html`
            <checkbox-indeterminate-example></checkbox-indeterminate-example>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/checkbox/src/checkbox-button.directive.ts
```typescript
import { computed, Directive, input } from '@angular/core';
import { injectCheckbox } from './checkbox.token';

@Directive({
    standalone: true,
    selector: 'button[rdxCheckboxButton]',
    host: {
        type: 'button',
        role: 'checkbox',
        tabindex: '-1',
        '[checked]': 'checkbox.checked',
        '[disabled]': 'checkbox.disabled',
        '[required]': 'checkbox.required',
        '[attr.id]': 'elementId()',
        '[attr.aria-checked]': 'checkbox.indeterminate ? "mixed" : checkbox.checked',
        '[attr.aria-required]': 'checkbox.required ? "" : null',
        '[attr.data-state]': 'checkbox.state',
        '[attr.data-disabled]': 'checkbox.disabled ? "" : null'
    }
})
export class RdxCheckboxButtonDirective {
    protected readonly checkbox = injectCheckbox();

    readonly id = input<string | null>(null);

    protected readonly elementId = computed(() => (this.id() ? this.id() : `rdx-checkbox-${this.id()}`));
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/checkbox/src/checkbox-indicator.directive.ts
```typescript
import { Directive } from '@angular/core';
import { injectCheckbox } from './checkbox.token';

@Directive({
    selector: '[rdxCheckboxIndicator]',
    standalone: true,
    host: {
        '[style.pointer-events]': '"none"',
        '[attr.aria-checked]': 'checkbox.indeterminate ? "mixed" : checkbox.checked',
        '[attr.data-state]': 'checkbox.state',
        '[attr.data-disabled]': 'checkbox.disabled ? "" : null'
    }
})
export class RdxCheckboxIndicatorDirective {
    protected readonly checkbox = injectCheckbox();
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/checkbox/src/checkbox-input.directive.ts
```typescript
import { computed, Directive, input } from '@angular/core';
import { RdxVisuallyHiddenInputDirective } from '@radix-ng/primitives/visually-hidden';
import { injectCheckbox } from './checkbox.token';

@Directive({
    standalone: true,
    selector: 'input[rdxCheckboxInput]',
    hostDirectives: [{ directive: RdxVisuallyHiddenInputDirective, inputs: ['feature: "fully-hidden"'] }],
    host: {
        type: 'checkbox',
        tabindex: '-1',
        '[checked]': 'checkbox.checked',
        '[disabled]': 'checkbox.disabled',
        '[required]': 'checkbox.required',
        '[attr.id]': 'elementId()',
        '[attr.aria-hidden]': 'true',
        '[attr.aria-checked]': 'checkbox.indeterminate ? "mixed" : checkbox.checked',
        '[attr.aria-required]': 'checkbox.required ? "" : null',
        '[attr.data-state]': 'checkbox.state',
        '[attr.data-disabled]': 'checkbox.disabled ? "" : null',
        '[attr.value]': 'value()'
    }
})
export class RdxCheckboxInputDirective {
    protected readonly checkbox = injectCheckbox();

    readonly id = input<string>();

    protected readonly elementId = computed(() => (this.id() ? this.id() : `rdx-checkbox-${this.id()}`));

    protected readonly value = computed(() => {
        const state = this.checkbox.state;
        if (state === 'indeterminate') {
            return '';
        }

        return state ? 'on' : 'off';
    });
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/checkbox/src/checkbox.directive.ts
```typescript
import { booleanAttribute, Directive, EventEmitter, Input, OnChanges, Output, SimpleChanges } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { provideValueAccessor } from '@radix-ng/primitives/core';
import { RdxCheckboxToken } from './checkbox.token';

export type CheckboxState = 'unchecked' | 'checked' | 'indeterminate';

/**
 * @group Components
 */
@Directive({
    selector: '[rdxCheckboxRoot]',
    providers: [
        { provide: RdxCheckboxToken, useExisting: RdxCheckboxDirective },
        provideValueAccessor(RdxCheckboxDirective)],
    host: {
        '[disabled]': 'disabled',
        '[attr.data-disabled]': 'disabled ? "" : null',
        '[attr.data-state]': 'state',

        '(keydown)': 'onKeyDown($event)',
        '(click)': 'onClick($event)',
        '(blur)': 'onBlur()'
    }
})
export class RdxCheckboxDirective implements ControlValueAccessor, OnChanges {
    /**
     * The controlled checked state of the checkbox. Must be used in conjunction with onCheckedChange.
     * @group Props
     */
    @Input({ transform: booleanAttribute }) checked = false;

    /**
     * Defines whether the checkbox is indeterminate.
     * @group Props
     */
    @Input({ transform: booleanAttribute }) indeterminate = false;

    /**
     * Defines whether the checkbox is disabled.
     * @group Props
     */
    @Input({ transform: booleanAttribute }) disabled = false;

    /**
     * @group Props
     */
    @Input({ transform: booleanAttribute }) required = false;

    /**
     * Event emitted when the checkbox checked state changes.
     * @group Emits
     */
    @Output() readonly checkedChange = new EventEmitter<boolean>();

    /**
     * Event emitted when the indeterminate state changes.
     * @group Emits
     */
    @Output() readonly indeterminateChange = new EventEmitter<boolean>();

    /**
     * Determine the state
     */
    get state(): CheckboxState {
        if (this.indeterminate) {
            return 'indeterminate';
        }
        return this.checked ? 'checked' : 'unchecked';
    }

    /**
     * Store the callback function that should be called when the checkbox checked state changes.
     * @internal
     */
    private onChange?: (checked: boolean) => void;

    /**
     * Store the callback function that should be called when the checkbox is blurred.
     * @internal
     */
    private onTouched?: () => void;

    protected onKeyDown(event: KeyboardEvent): void {
        // According to WAI ARIA, Checkboxes don't activate on enter keypress
        if (event.key === 'Enter') {
            event.preventDefault();
        }
    }

    protected onClick($event: MouseEvent): void {
        if (this.disabled) {
            return;
        }

        this.checked = this.indeterminate ? true : !this.checked;
        this.checkedChange.emit(this.checked);
        this.onChange?.(this.checked);

        if (this.indeterminate) {
            this.indeterminate = false;
            this.indeterminateChange.emit(this.indeterminate);
        }

        $event.preventDefault();
    }

    protected onBlur(): void {
        this.onTouched?.();
    }

    ngOnChanges(changes: SimpleChanges): void {
        if (changes['checked'] && !changes['checked'].isFirstChange()) {
            this.checkedChange.emit(this.checked);
        }
        if (changes['indeterminate'] && !changes['indeterminate'].isFirstChange()) {
            this.indeterminateChange.emit(this.indeterminate);
        }
    }

    /**
     * Sets the checked state of the checkbox.
     * @param checked The checked state of the checkbox.
     * @internal
     */
    writeValue(checked: boolean): void {
        this.checked = checked;
    }

    /**
     * Registers a callback function that should be called when the checkbox checked state changes.
     * @param fn The callback function.
     * @internal
     */
    registerOnChange(fn: (checked: boolean) => void): void {
        this.onChange = fn;
    }

    /**
     * Registers a callback function that should be called when the checkbox is blurred.
     * @param fn The callback function.
     * @internal
     */
    registerOnTouched(fn: () => void): void {
        this.onTouched = fn;
    }

    /**
     * Sets the disabled state of the checkbox.
     * @param isDisabled The disabled state of the checkbox.
     * @internal
     */
    setDisabledState(isDisabled: boolean): void {
        this.disabled = isDisabled;
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/checkbox/src/checkbox.token.ts
```typescript
import { inject, InjectionToken } from '@angular/core';
import type { RdxCheckboxDirective } from './checkbox.directive';

export const RdxCheckboxToken = new InjectionToken<RdxCheckboxDirective>('RdxCheckboxToken');

export function injectCheckbox(): RdxCheckboxDirective {
    return inject(RdxCheckboxToken);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/label/README.md
```
# @radix-ng/primitives/label

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/label/index.ts
```typescript
export * from './src/label.directive';

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/label/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/label/stories/label.docs.mdx
````
import { ArgTypes, Canvas, Meta } from '@storybook/blocks';
import { RdxLabelDirective } from '../src/label.directive';
import * as LabelDirectiveStories from './label.stories';

<Meta title="Primitives/Label" />

# Label

#### Renders an accessible label associated with controls.

<Canvas sourceState="hidden" of={LabelDirectiveStories.Default} />

## Features

- âœ… Text selection is prevented when double-clicking label.

## Import

Get started with importing the directive:

```typescript
import { RdxLabelDirective } from '@radix-ng/primitives/label';
```

## Examples

```html
<label rdxLabel htmlFor="uniqId">First name</label>
<input class="Input" id="uniqId" type="text" />
```

## API Reference

<ArgTypes of={RdxLabelDirective} />

## Accessibility

This component is based on the native `label` element, it will automatically apply the correct labelling
when wrapping controls or using the `for` attribute. For your own custom controls
to work correctly, ensure they use native elements such as `button` or `input` as a base.

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/label/stories/label.stories.ts
```typescript
import { CommonModule } from '@angular/common';
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { labelExclude } from '../../../../apps/storybook-radix/docs/utils/storybook';
import { RdxLabelDirective } from '../src/label.directive';

export default {
    component: RdxLabelDirective,
    title: 'Primitives/Label',
    parameters: {
        controls: {
            exclude: labelExclude
        }
    },
    decorators: [
        moduleMetadata({
            imports: [RdxLabelDirective, CommonModule]
        }),
        componentWrapperDecorator(
            (story) =>
                `<div class="radix-themes light light-theme"
                      data-radius="medium"
                      data-scaling="100%">${story}</div>`
        )
    ]
} as Meta<RdxLabelDirective>;

type Story = StoryObj<RdxLabelDirective>;

export const Default: Story = {
    render: (args) => ({
        props: {
            ...args
        },
        template: `
<label rdxLabel htmlFor="uniqId">First Name </label>
<input type="text" class="Input" id="uniqId" />

<style>
input {
  all: unset;
}

.Input {
  width: 200px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  padding: 0 10px;
  margin-left: 10px;
  height: 35px;
  font-size: 15px;
  line-height: 1;
  color: white;
  background-color: var(--black-a5);
  box-shadow: 0 0 0 1px var(--black-a9);
}

.Input:focus {
  box-shadow: 0 0 0 2px black;
}
.Input::selection {
  background-color: var(--black-a9);
  color: white;
}

label {
    color: white;
    font-size: 15px;
    line-height: 35px;
    font-weight: 500;
}
</style>
`
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/label/__tests__/label-root.directive.spec.ts
```typescript
import { Component, DebugElement } from '@angular/core';
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { RdxLabelDirective } from '../src/label.directive';

/* Explanation:

    Environment Setup: In addition to the label, the template now includes a div and an input button to test interaction with different types of elements.

    Double-click Prevention: Tests whether the directive correctly prevents default actions during a double-click, except on form elements like buttons.

    Single Click Handling: Verifies that the directive does not interfere with default actions on single clicks.

    Interaction with Children: Checks that double-clicks on non-form elements like divs also trigger prevention of default actions.*/
@Component({
    template: `
        <label rdxLabel>
            Test Label
            <div>Click Me</div>
            <input type="button" value="Button" />
        </label>
    `,
    imports: [RdxLabelDirective]
})
class TestComponent {}

describe('RdxLabelDirective', () => {
    let fixture: ComponentFixture<TestComponent>;
    let labelElement: DebugElement;
    let inputElement: DebugElement;
    let divElement: DebugElement;

    beforeEach(async () => {
        await TestBed.configureTestingModule({
            imports: [TestComponent]
        }).compileComponents();

        fixture = TestBed.createComponent(TestComponent);
        fixture.detectChanges();
        labelElement = fixture.debugElement.query(By.directive(RdxLabelDirective));
        inputElement = fixture.debugElement.query(By.css('input'));
        divElement = fixture.debugElement.query(By.css('div'));
    });

    it('should create an instance of the directive', () => {
        expect(labelElement).toBeTruthy();
    });

    it('should prevent default action on double-clicking the label, not on input elements', () => {
        const mockEventLabel = new MouseEvent('mousedown', {
            bubbles: true,
            cancelable: true,
            detail: 2
        });
        Object.defineProperty(mockEventLabel, 'target', { value: labelElement.nativeElement });
        jest.spyOn(mockEventLabel, 'preventDefault');

        labelElement.triggerEventHandler('mousedown', mockEventLabel);
        expect(mockEventLabel.preventDefault).toHaveBeenCalled();

        // Double-click event targeting the input element
        const mockEventInput = new MouseEvent('mousedown', {
            bubbles: true,
            cancelable: true,
            detail: 2
        });
        Object.defineProperty(mockEventInput, 'target', { value: inputElement.nativeElement });
        jest.spyOn(mockEventInput, 'preventDefault');

        labelElement.triggerEventHandler('mousedown', mockEventInput);
        expect(mockEventInput.preventDefault).not.toHaveBeenCalled();
    });

    it('should not prevent default action on single clicks', () => {
        const mockEvent = new MouseEvent('mousedown', {
            bubbles: true,
            cancelable: true,
            detail: 1
        });
        Object.defineProperty(mockEvent, 'target', { value: labelElement.nativeElement });
        jest.spyOn(mockEvent, 'preventDefault');

        labelElement.triggerEventHandler('mousedown', mockEvent);
        expect(mockEvent.preventDefault).not.toHaveBeenCalled();
    });

    it('should prevent default action when double-clicking non-button/input/select/textarea elements within the label', () => {
        const mockEvent = new MouseEvent('mousedown', {
            bubbles: true,
            cancelable: true,
            detail: 2
        });
        Object.defineProperty(mockEvent, 'target', { value: divElement.nativeElement });
        jest.spyOn(mockEvent, 'preventDefault');

        labelElement.triggerEventHandler('mousedown', mockEvent);
        expect(mockEvent.preventDefault).toHaveBeenCalled();
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/label/src/label.directive.ts
```typescript
import { computed, Directive, ElementRef, inject, input } from '@angular/core';

let idIterator = 0;

/**
 * @group Components
 */
@Directive({
    selector: 'label[rdxLabel]',
    exportAs: 'rdxLabel',
    host: {
        '[attr.id]': 'this.elementId()',
        '[attr.for]': 'htmlFor ? htmlFor() : null',
        '(mousedown)': 'onMouseDown($event)'
    }
})
export class RdxLabelDirective {
    private readonly elementRef = inject(ElementRef<HTMLElement>);

    /**
     * @default 'rdx-label-{idIterator}'
     */
    readonly id = input<string>(`rdx-label-${idIterator++}`);

    /**
     * The id of the element the label is associated with.
     * @group Props
     * @defaultValue false
     */
    readonly htmlFor = input<string>();

    protected readonly elementId = computed(() => (this.id() ? this.id() : null));

    // prevent text selection when double-clicking label
    // The main problem with double-clicks in a web app is that
    // you will have to create special code to handle this on touch enabled devices.
    /**
     * @ignore
     */
    onMouseDown(event: MouseEvent): void {
        const target = event.target as HTMLElement;

        // only prevent text selection if clicking inside the label itself
        if (['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA'].includes(target.tagName)) {
            return;
        }

        // prevent text selection when double-clicking label
        if (this.elementRef.nativeElement.contains(target) && !event.defaultPrevented && event.detail > 1) {
            event.preventDefault();
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dropdown-menu/README.md
```
# @radix-ng/primitives/dropdown-menu

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dropdown-menu/index.ts
```typescript
import { NgModule } from '@angular/core';
import { RdxDropdownMenuContentDirective } from './src/dropdown-menu-content.directive';
import { RdxDropdownMenuItemCheckboxDirective } from './src/dropdown-menu-item-checkbox.directive';
import { RdxDropdownMenuItemIndicatorDirective } from './src/dropdown-menu-item-indicator.directive';
import { RdxDropdownMenuItemRadioGroupDirective } from './src/dropdown-menu-item-radio-group.directive';
import { RdxDropdownMenuItemRadioDirective } from './src/dropdown-menu-item-radio.directive';
import { RdxDropdownMenuSelectable } from './src/dropdown-menu-item-selectable';
import { RdxDropdownMenuItemDirective } from './src/dropdown-menu-item.directive';
import { RdxDropdownMenuLabelDirective } from './src/dropdown-menu-label.directive';
import { RdxDropdownMenuSeparatorDirective } from './src/dropdown-menu-separator.directive';
import { RdxDropdownMenuTriggerDirective } from './src/dropdown-menu-trigger.directive';

export * from './src/dropdown-menu-content.directive';
export * from './src/dropdown-menu-item-checkbox.directive';
export * from './src/dropdown-menu-item-indicator.directive';
export * from './src/dropdown-menu-item-radio-group.directive';
export * from './src/dropdown-menu-item-radio.directive';
export * from './src/dropdown-menu-item-selectable';
export * from './src/dropdown-menu-item.directive';
export * from './src/dropdown-menu-label.directive';
export * from './src/dropdown-menu-separator.directive';
export * from './src/dropdown-menu-trigger.directive';

const _imports = [
    RdxDropdownMenuTriggerDirective,
    RdxDropdownMenuContentDirective,
    RdxDropdownMenuItemCheckboxDirective,
    RdxDropdownMenuItemIndicatorDirective,
    RdxDropdownMenuItemRadioGroupDirective,
    RdxDropdownMenuItemRadioDirective,
    RdxDropdownMenuSelectable,
    RdxDropdownMenuItemDirective,
    RdxDropdownMenuLabelDirective,
    RdxDropdownMenuSeparatorDirective,
    RdxDropdownMenuTriggerDirective
];

@NgModule({
    imports: [..._imports],
    exports: [..._imports]
})
export class Rdx {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dropdown-menu/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dropdown-menu/stories/dropdown-menu-item-checkbox.component.ts
```typescript
import { Component } from '@angular/core';
import { LucideAngularModule } from 'lucide-angular';
import { RdxDropdownMenuContentDirective } from '../src/dropdown-menu-content.directive';
import { RdxDropdownMenuItemCheckboxDirective } from '../src/dropdown-menu-item-checkbox.directive';
import { RdxDropdownMenuItemIndicatorDirective } from '../src/dropdown-menu-item-indicator.directive';
import { RdxDropdownMenuItemDirective } from '../src/dropdown-menu-item.directive';
import { RdxDropdownMenuLabelDirective } from '../src/dropdown-menu-label.directive';
import { RdxDropdownMenuSeparatorDirective } from '../src/dropdown-menu-separator.directive';
import { RdxDropdownMenuTriggerDirective } from '../src/dropdown-menu-trigger.directive';

@Component({
    selector: 'dropdown-menu-item-checkbox',
    styleUrl: 'dropdown-menu-item-checkbox.styles.scss',
    template: `
        <button
            class="IconButton"
            [rdxDropdownMenuTrigger]="menu"
            sideOffset="4"
            alignOffset="-5"
            aria-label="Customise options"
        >
            <lucide-angular size="16" name="menu" style="height: 1.2rem;" />
        </button>

        <ng-template #menu>
            <div class="DropdownMenuContent" [onEscapeKeyDown]="onEscapeKeyDown" rdxDropdownMenuContent>
                <button
                    class="DropdownMenuItem"
                    [(checked)]="itemState"
                    (onSelect)="onSelect()"
                    rdxDropdownMenuItemCheckbox
                >
                    <div class="DropdownMenuItemIndicator" rdxDropdownMenuItemIndicator>
                        <lucide-icon size="16" name="check" />
                    </div>
                    New Tab
                    <div class="RightSlot">âŒ˜ T</div>
                </button>
                <button class="DropdownMenuItem" rdxDropdownMenuItemCheckbox disabled>
                    New Window
                    <div class="RightSlot">âŒ˜ N</div>
                </button>
                <button
                    class="DropdownMenuItem"
                    [(checked)]="itemState2"
                    (onSelect)="onSelect()"
                    rdxDropdownMenuItemCheckbox
                >
                    <div class="DropdownMenuItemIndicator" rdxDropdownMenuItemIndicator>
                        <lucide-icon size="16" name="check" />
                    </div>
                    New Incognito Window
                </button>
                <div class="DropdownMenuSeparator" rdxDropdownMenuSeparator></div>
                <div class="DropdownMenuLabel" rdxDropdownMenuLabel>Label</div>
                <button class="DropdownMenuItem" [rdxDropdownMenuTrigger]="share" [side]="'right'" rdxDropdownMenuItem>
                    Share
                    <div class="RightSlot">></div>
                </button>
                <div class="DropdownMenuSeparator" rdxDropdownMenuSeparator></div>
                <button class="DropdownMenuItem" (onSelect)="onSelect()" rdxDropdownMenuItem>
                    Printâ€¦
                    <div class="RightSlot">âŒ˜ P</div>
                </button>
            </div>
        </ng-template>

        <ng-template #share>
            <div class="DropdownMenuSubContent" rdxDropdownMenuContent>
                <button class="DropdownMenuItem" rdxDropdownMenuItem>Undo</button>
                <button class="DropdownMenuItem" rdxDropdownMenuItem>Redo</button>
                <div class="DropdownMenuSeparator" rdxDropdownMenuSeparator></div>
                <button class="DropdownMenuItem" rdxDropdownMenuItem>Cut</button>
                <button class="DropdownMenuItem" rdxDropdownMenuItem>Copy</button>
                <button class="DropdownMenuItem" rdxDropdownMenuItem>Paste</button>
            </div>
        </ng-template>
    `,
    imports: [
        RdxDropdownMenuTriggerDirective,
        RdxDropdownMenuItemDirective,
        RdxDropdownMenuItemCheckboxDirective,
        RdxDropdownMenuItemIndicatorDirective,
        RdxDropdownMenuSeparatorDirective,
        RdxDropdownMenuContentDirective,
        RdxDropdownMenuLabelDirective,
        LucideAngularModule
    ]
})
export class DropdownMenuItemCheckboxExampleComponent {
    itemState = true;
    itemState2 = false;

    onSelect() {
        console.log('onSelect');
    }

    onEscapeKeyDown(event: Event) {
        event.stopPropagation();

        console.log('onEscapeKeyDown: ', event);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dropdown-menu/stories/dropdown-menu-item-checkbox.styles.scss
```
button {
    all: unset;
}

.DropdownMenuContent,
.DropdownMenuSubContent {
    flex-direction: column;
    display: inline-flex;
    min-width: 220px;
    background-color: white;
    border-radius: 6px;
    padding: 5px;
    box-shadow:
        0px 10px 38px -10px rgba(22, 23, 24, 0.35),
        0px 10px 20px -15px rgba(22, 23, 24, 0.2);
    will-change: transform, opacity;
}

.DropdownMenuItem,
.DropdownMenuCheckboxItem,
.DropdownMenuRadioItem,
.DropdownMenuSubTrigger {
    font-size: 13px;
    line-height: 1;
    color: var(--violet-11);
    border-radius: 3px;
    display: flex;
    align-items: center;
    height: 25px;
    position: relative;
    padding: 0 5px 0 25px;
    user-select: none;
    outline: none;
}

.DropdownMenuItem[data-disabled],
.DropdownMenuCheckboxItem[data-disabled],
.DropdownMenuRadioItem[data-disabled] {
    color: var(--mauve-8);
    pointer-events: none;
}

.DropdownMenuItem[data-highlighted],
.DropdownMenuCheckboxItem[data-highlighted],
.DropdownMenuRadioItem[data-highlighted] {
    background-color: var(--violet-9);
    color: var(--violet-1);
}

.DropdownMenuSeparator {
    height: 1px;
    background-color: var(--violet-6);
    margin: 5px;
}

.DropdownMenuLabel {
    padding-left: 25px;
    font-size: 12px;
    line-height: 25px;
    color: var(--mauve-11);
}

.IconButton {
    font-family: inherit;
    border-radius: 100%;
    height: 35px;
    width: 35px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: var(--violet-11);
    background-color: white;
    box-shadow: 0 2px 10px var(--black-a7);
}

.DropdownMenuSubTrigger[data-state='open'] {
    background-color: var(--violet-4);
    color: var(--violet-11);
}

.DropdownMenuItemIndicator {
    position: absolute;
    left: 4px;
    width: 25px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

.IconButton:hover {
    background-color: var(--violet-3);
}

.IconButton:focus {
    box-shadow: 0 0 0 2px black;
}

.RightSlot {
    margin-left: auto;
    padding-left: 20px;
    color: var(--mauve-9);
    display: flex;
    flex-direction: row;
    flex: 1;
    justify-content: flex-end;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dropdown-menu/stories/dropdown-menu-item-radio.component.ts
```typescript
import { Component } from '@angular/core';
import { LucideAngularModule } from 'lucide-angular';
import { RdxDropdownMenuContentDirective } from '../src/dropdown-menu-content.directive';
import { RdxDropdownMenuItemIndicatorDirective } from '../src/dropdown-menu-item-indicator.directive';
import { RdxDropdownMenuItemRadioGroupDirective } from '../src/dropdown-menu-item-radio-group.directive';
import { RdxDropdownMenuItemRadioDirective } from '../src/dropdown-menu-item-radio.directive';
import { RdxDropdownMenuItemDirective } from '../src/dropdown-menu-item.directive';
import { RdxDropdownMenuLabelDirective } from '../src/dropdown-menu-label.directive';
import { RdxDropdownMenuSeparatorDirective } from '../src/dropdown-menu-separator.directive';
import { RdxDropdownMenuTriggerDirective } from '../src/dropdown-menu-trigger.directive';

@Component({
    selector: 'dropdown-menu-item-radio',
    styleUrl: 'dropdown-menu-item-radio.styles.scss',
    template: `
        <button
            class="IconButton"
            [rdxDropdownMenuTrigger]="menu"
            sideOffset="4"
            alignOffset="-5"
            aria-label="Customise options"
        >
            <lucide-angular size="16" name="menu" style="height: 1.2rem;" />
        </button>
        <ng-template #menu>
            <div class="DropdownMenuContent" [closeOnEscape]="false" rdxDropdownMenuContent>
                <div [(value)]="selectedValue" (valueChange)="onValueChange($event)" rdxDropdownMenuItemRadioGroup>
                    <div class="DropdownMenuItem" [value]="'1'" rdxDropdownMenuItemRadio>
                        <div class="DropdownMenuItemIndicator" rdxDropdownMenuItemIndicator>
                            <lucide-icon size="16" name="dot" strokeWidth="8" />
                        </div>
                        New Tab
                        <div class="RightSlot">âŒ˜ T</div>
                    </div>
                    <div class="DropdownMenuItem" [value]="'2'" disabled rdxDropdownMenuItemRadio>
                        <div class="DropdownMenuItemIndicator" rdxDropdownMenuItemIndicator>
                            <lucide-icon size="16" name="dot" strokeWidth="8" />
                        </div>
                        New Window
                        <div class="RightSlot">âŒ˜ N</div>
                    </div>
                    <div class="DropdownMenuItem" [value]="'3'" rdxDropdownMenuItemRadio>
                        <div class="DropdownMenuItemIndicator" rdxDropdownMenuItemIndicator>
                            <lucide-icon size="16" name="dot" strokeWidth="8" />
                        </div>
                        New Incognito Window
                    </div>
                </div>
                <div class="DropdownMenuSeparator" rdxDropdownMenuSeparator></div>
                <div class="DropdownMenuLabel" rdxDropdownMenuLabel>Label</div>
                <button class="DropdownMenuItem" [rdxDropdownMenuTrigger]="share" [side]="'right'" rdxDropdownMenuItem>
                    Share
                    <div class="RightSlot">></div>
                </button>
                <div class="DropdownMenuSeparator" rdxDropdownMenuSeparator></div>
                <button class="DropdownMenuItem" rdxDropdownMenuItem>
                    Printâ€¦
                    <div class="RightSlot">âŒ˜ P</div>
                </button>
            </div>
        </ng-template>

        <ng-template #share>
            <div class="DropdownMenuSubContent" rdxDropdownMenuContent>
                <button class="DropdownMenuItem" rdxDropdownMenuItem>Undo</button>
                <button class="DropdownMenuItem" rdxDropdownMenuItem>Redo</button>
                <div class="DropdownMenuSeparator" rdxDropdownMenuSeparator></div>
                <button class="DropdownMenuItem" rdxDropdownMenuItem>Cut</button>
                <button class="DropdownMenuItem" rdxDropdownMenuItem>Copy</button>
                <button class="DropdownMenuItem" rdxDropdownMenuItem>Paste</button>
            </div>
        </ng-template>
    `,
    imports: [
        RdxDropdownMenuTriggerDirective,
        RdxDropdownMenuItemDirective,
        RdxDropdownMenuItemRadioDirective,
        RdxDropdownMenuItemRadioGroupDirective,
        RdxDropdownMenuItemIndicatorDirective,
        RdxDropdownMenuSeparatorDirective,
        RdxDropdownMenuContentDirective,
        RdxDropdownMenuLabelDirective,
        LucideAngularModule
    ]
})
export class DropdownMenuItemRadioExampleComponent {
    selectedValue = '2';

    onValueChange(value: string) {
        this.selectedValue = value;

        console.log('this.selectedValue', this.selectedValue);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dropdown-menu/stories/dropdown-menu-item-radio.styles.scss
```
button {
    all: unset;
}

.DropdownMenuContent,
.DropdownMenuSubContent {
    flex-direction: column;
    display: inline-flex;
    min-width: 220px;
    background-color: white;
    border-radius: 6px;
    padding: 5px;
    box-shadow:
        0px 10px 38px -10px rgba(22, 23, 24, 0.35),
        0px 10px 20px -15px rgba(22, 23, 24, 0.2);
    will-change: transform, opacity;
}

.DropdownMenuItem,
.DropdownMenuCheckboxItem,
.DropdownMenuRadioItem,
.DropdownMenuSubTrigger {
    font-size: 13px;
    line-height: 1;
    color: var(--violet-11);
    border-radius: 3px;
    display: flex;
    align-items: center;
    height: 25px;
    position: relative;
    padding: 0 5px 0 25px;
    user-select: none;
    outline: none;
}

.DropdownMenuItem[data-disabled],
.DropdownMenuCheckboxItem[data-disabled],
.DropdownMenuRadioItem[data-disabled] {
    color: var(--mauve-8);
    pointer-events: none;
}

.DropdownMenuItem[data-highlighted],
.DropdownMenuCheckboxItem[data-highlighted],
.DropdownMenuRadioItem[data-highlighted] {
    background-color: var(--violet-9);
    color: var(--violet-1);
}

.DropdownMenuSeparator {
    height: 1px;
    background-color: var(--violet-6);
    margin: 5px;
}

.DropdownMenuLabel {
    padding-left: 25px;
    font-size: 12px;
    line-height: 25px;
    color: var(--mauve-11);
}

.IconButton {
    font-family: inherit;
    border-radius: 100%;
    height: 35px;
    width: 35px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: var(--violet-11);
    background-color: white;
    box-shadow: 0 2px 10px var(--black-a7);
}

.DropdownMenuSubTrigger[data-state='open'] {
    background-color: var(--violet-4);
    color: var(--violet-11);
}

.DropdownMenuItemIndicator {
    position: absolute;
    left: 4px;
    width: 25px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

.IconButton:hover {
    background-color: var(--violet-3);
}

.IconButton:focus {
    box-shadow: 0 0 0 2px black;
}

.RightSlot {
    margin-left: auto;
    padding-left: 20px;
    color: var(--mauve-9);
    display: flex;
    flex-direction: row;
    flex: 1;
    justify-content: flex-end;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dropdown-menu/stories/dropdown.docs.mdx
```
import { Canvas, Meta } from '@storybook/blocks';
import * as DropdownStories from './dropdown.stories';

<Meta title="Primitives/Dropdown Menu" />

# Dropdown Menu

#### Displays a menu to the userâ€”such as a set of actions or functionsâ€”triggered by a button.

<Canvas sourceState="hidden" of={DropdownStories.Default} height="300px" />

## Features

- âœ… Supports submenus with configurable reading direction.
- âœ… Supports items, labels, groups of items.
- âœ… Customize side, alignment, offsets.

ToDo

- Can be controlled or uncontrolled.
- Supports checkable items (single or multiple) with optional indeterminate state.
- Supports modal and non-modal modes.
- Optionally render a pointing arrow.
- Focus is fully managed.
- Full keyboard navigation.
- Typeahead support.
- Dismissing and layering behavior is highly customizable.

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dropdown-menu/stories/dropdown.stories.ts
```typescript
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { Check, Dot, LucideAngularModule, Menu } from 'lucide-angular';

import { RdxDropdownMenuContentDirective } from '../src/dropdown-menu-content.directive';
import { RdxDropdownMenuItemCheckboxDirective } from '../src/dropdown-menu-item-checkbox.directive';
import { RdxDropdownMenuItemIndicatorDirective } from '../src/dropdown-menu-item-indicator.directive';
import { RdxDropdownMenuItemDirective } from '../src/dropdown-menu-item.directive';
import { RdxDropdownMenuSeparatorDirective } from '../src/dropdown-menu-separator.directive';
import { RdxDropdownMenuTriggerDirective } from '../src/dropdown-menu-trigger.directive';
import { DropdownMenuItemCheckboxExampleComponent } from './dropdown-menu-item-checkbox.component';
import { DropdownMenuItemRadioExampleComponent } from './dropdown-menu-item-radio.component';

export default {
    title: 'Primitives/Dropdown Menu',
    decorators: [
        moduleMetadata({
            imports: [
                RdxDropdownMenuTriggerDirective,
                RdxDropdownMenuItemDirective,
                RdxDropdownMenuItemCheckboxDirective,
                RdxDropdownMenuItemIndicatorDirective,
                RdxDropdownMenuSeparatorDirective,
                RdxDropdownMenuContentDirective,
                LucideAngularModule,
                LucideAngularModule.pick({ Menu, Check, Dot }),
                DropdownMenuItemCheckboxExampleComponent,
                DropdownMenuItemRadioExampleComponent
            ]
        }),
        componentWrapperDecorator(
            (story) => `
                <div class="radix-themes light light-theme radix-themes-default-fonts rt-Flex rt-r-ai-start rt-r-jc-center rt-r-position-relative"
                    data-accent-color="indigo"
                    data-radius="medium"
                    data-scaling="100%"
                >
                    ${story}
                </div>`
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: `
<button [rdxDropdownMenuTrigger]="menu"
        sideOffset="4"
        alignOffset="-5"
        class="IconButton" aria-label="Customise options">
    <lucide-angular size="16" name="menu" style="height: 1.2rem;"></lucide-angular>
</button>

<ng-template #menu>
  <div class="DropdownMenuContent" rdxDropdownMenuContent>
    <button class="DropdownMenuItem" rdxDropdownMenuItem>
        New Tab <div class="RightSlot">âŒ˜ T</div>
    </button>
    <button class="DropdownMenuItem" rdxDropdownMenuItem disabled>
        New Window <div class="RightSlot">âŒ˜ N</div>
    </button>
    <button class="DropdownMenuItem" rdxDropdownMenuItem>
        New Incognito Window
    </button>
    <div rdxDropdownMenuSeparator class="DropdownMenuSeparator"></div>
    <div class="DropdownMenuLabel" rdxDropdownMenuLabel>
        Label
    </div>
    <button
        class="DropdownMenuItem"
        rdxDropdownMenuItem
        [rdxDropdownMenuTrigger]="share"
        [side]="'right'"
    >
        Share <div class="RightSlot">></div>
    </button>
    <div rdxDropdownMenuSeparator class="DropdownMenuSeparator"></div>
    <button class="DropdownMenuItem" rdxDropdownMenuItem>
        Printâ€¦ <div class="RightSlot">âŒ˜ P</div>
    </button>
  </div>
</ng-template>

<ng-template #share>
  <div class="DropdownMenuContent" rdxDropdownMenuContent>
    <button class="DropdownMenuItem" rdxDropdownMenuItem>Undo</button>
    <button class="DropdownMenuItem" rdxDropdownMenuItem>Redo</button>
    <div rdxDropdownMenuSeparator class="DropdownMenuSeparator"></div>
    <button class="DropdownMenuItem" rdxDropdownMenuItem>Cut</button>
    <button class="DropdownMenuItem" rdxDropdownMenuItem>Copy</button>
    <button class="DropdownMenuItem" rdxDropdownMenuItem>Paste</button>
  </div>
</ng-template>

<style>
/* reset */
button {
  all: unset;
}

.DropdownMenuContent {
  flex-direction: column;
  display: inline-flex;
  min-width: 220px;
  background-color: white;
  border-radius: 6px;
  padding: 5px;
  box-shadow: 0px 10px 38px -10px rgba(22, 23, 24, 0.35), 0px 10px 20px -15px rgba(22, 23, 24, 0.2);
  will-change: transform, opacity;
}

.DropdownMenuItem,
.DropdownMenuCheckboxItem,
.DropdownMenuRadioItem {
  font-size: 13px;
  line-height: 1;
  color: var(--violet-11);
  border-radius: 3px;
  display: flex;
  align-items: center;
  height: 25px;
  position: relative;
  padding: 0 5px 0 25px;
  user-select: none;
  outline: none;
}

.DropdownMenuItem[data-disabled],
.DropdownMenuCheckboxItem[data-disabled],
.DropdownMenuRadioItem[data-disabled] {
  color: var(--mauve-8);
  pointer-events: none;
}
.DropdownMenuItem[data-highlighted],
.DropdownMenuCheckboxItem[data-highlighted],
.DropdownMenuRadioItem[data-highlighted] {
  background-color: var(--violet-9);
  color: var(--violet-1);
}

.DropdownMenuSeparator {
  height: 1px;
  background-color: var(--violet-6);
  margin: 5px;
}

.DropdownMenuLabel {
  padding-left: 25px;
  font-size: 12px;
  line-height: 25px;
  color: var(--mauve-11);
}

.IconButton {
  font-family: inherit;
  border-radius: 100%;
  height: 35px;
  width: 35px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  color: var(--violet-11);
  background-color: white;
  box-shadow: 0 2px 10px var(--black-a7);
}

.DropdownMenuItemIndicator {
  position: absolute;
  left: 4px;
  width: 25px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.IconButton:hover {
  background-color: var(--violet-3);
}

.IconButton:focus {
  box-shadow: 0 0 0 2px black;
}

.RightSlot {
  margin-left: auto;
  padding-left: 20px;
  color: var(--mauve-9);
  display: flex;
  flex-direction: row;
  flex: 1;
  justify-content: flex-end;
}

</style>
`
    })
};

export const DropdownMenuItemCheckbox: Story = {
    name: 'Checkbox',
    render: () => ({
        template: `<dropdown-menu-item-checkbox/>`
    })
};

export const DropdownMenuItemRadio: Story = {
    name: 'Radio',
    render: () => ({
        template: `<dropdown-menu-item-radio/>`
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dropdown-menu/src/dropdown-menu-content.directive.ts
```typescript
import { CdkMenu, CdkMenuItem } from '@angular/cdk/menu';
import { Directive, inject, Input } from '@angular/core';
import { pairwise, startWith, Subject } from 'rxjs';
import { RdxDropdownMenuItemDirective } from './dropdown-menu-item.directive';
import { RdxDropdownMenuTriggerDirective } from './dropdown-menu-trigger.directive';

@Directive({
    selector: '[rdxDropdownMenuContent]',
    standalone: true,
    host: {
        '[attr.data-state]': "menuTrigger.isOpen() ? 'open': 'closed'",
        '[attr.data-align]': 'menuTrigger!.align',
        '[attr.data-side]': 'menuTrigger!.side',
        '[attr.data-orientation]': 'orientation'
    },
    providers: [
        {
            provide: CdkMenu,
            useExisting: RdxDropdownMenuContentDirective
        }
    ]
})
export class RdxDropdownMenuContentDirective extends CdkMenu {
    readonly highlighted = new Subject<RdxDropdownMenuItemDirective>();
    readonly menuTrigger = inject(RdxDropdownMenuTriggerDirective, { optional: true });

    @Input() onEscapeKeyDown: (event?: Event) => void = () => undefined;
    @Input() closeOnEscape: boolean = true;

    constructor() {
        super();

        this.highlighted.pipe(startWith(null), pairwise()).subscribe(([prev, item]) => {
            if (prev) {
                prev.highlighted = false;
            }

            if (item) {
                item.highlighted = true;
            }
        });
    }

    updateActiveItem(item: CdkMenuItem) {
        this.keyManager.updateActiveItem(item);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dropdown-menu/src/dropdown-menu-item-checkbox.directive.ts
```typescript
import { CDK_MENU, CdkMenuItem } from '@angular/cdk/menu';
import { Directive } from '@angular/core';
import { RdxDropdownMenuContentDirective } from './dropdown-menu-content.directive';
import { RdxDropdownMenuSelectable } from './dropdown-menu-item-selectable';
import { RdxDropdownMenuItemDirective } from './dropdown-menu-item.directive';

@Directive({
    selector: '[rdxDropdownMenuItemCheckbox]',
    standalone: true,
    host: {
        role: 'menuitemcheckbox'
    },
    providers: [
        { provide: RdxDropdownMenuSelectable, useExisting: RdxDropdownMenuItemCheckboxDirective },
        { provide: RdxDropdownMenuItemDirective, useExisting: RdxDropdownMenuSelectable },
        { provide: CdkMenuItem, useExisting: RdxDropdownMenuItemDirective },
        { provide: CDK_MENU, useExisting: RdxDropdownMenuContentDirective }
    ]
})
export class RdxDropdownMenuItemCheckboxDirective extends RdxDropdownMenuSelectable {
    override trigger(options?: { keepOpen: boolean }) {
        if (!this.disabled) {
            this.checked = !this.checked;

            this.checkedChange.emit(this.checked);
        }

        super.trigger(options);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dropdown-menu/src/dropdown-menu-item-indicator.directive.ts
```typescript
import { Directive, inject } from '@angular/core';
import { RdxDropdownMenuSelectable } from './dropdown-menu-item-selectable';

@Directive({
    selector: '[rdxDropdownMenuItemIndicator]',
    standalone: true,
    host: {
        '[style.display]': "item.checked ? 'block' : 'none'",
        '[attr.data-state]': "item.checked ? 'checked' : 'unchecked'"
    }
})
export class RdxDropdownMenuItemIndicatorDirective {
    item = inject(RdxDropdownMenuSelectable);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dropdown-menu/src/dropdown-menu-item-radio-group.directive.ts
```typescript
import { UniqueSelectionDispatcher } from '@angular/cdk/collections';
import { AfterContentInit, Directive, EventEmitter, inject, Input, Output } from '@angular/core';

@Directive({
    selector: '[rdxDropdownMenuItemRadioGroup]',
    standalone: true,
    host: {
        role: 'group'
    },
    providers: [{ provide: UniqueSelectionDispatcher, useClass: UniqueSelectionDispatcher }]
})
export class RdxDropdownMenuItemRadioGroupDirective<T> implements AfterContentInit {
    private readonly selectionDispatcher = inject(UniqueSelectionDispatcher);

    @Input()
    set value(id: T | null) {
        this._value = id;
    }

    get value(): T | null {
        return this._value;
    }

    private _value: T | null = null;

    @Output() readonly valueChange = new EventEmitter();

    ngAfterContentInit(): void {
        this.selectionDispatcher.notify(this.value as string, '');
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dropdown-menu/src/dropdown-menu-item-radio.directive.ts
```typescript
import { UniqueSelectionDispatcher } from '@angular/cdk/collections';
import { CDK_MENU, CdkMenuItem } from '@angular/cdk/menu';
import { AfterContentInit, Directive, inject, Input, OnDestroy } from '@angular/core';
import { RdxDropdownMenuContentDirective } from './dropdown-menu-content.directive';
import { RdxDropdownMenuItemRadioGroupDirective } from './dropdown-menu-item-radio-group.directive';
import { RdxDropdownMenuSelectable } from './dropdown-menu-item-selectable';
import { RdxDropdownMenuItemDirective } from './dropdown-menu-item.directive';

/** Counter used to set a unique id and name for a selectable item */
let nextId = 0;

@Directive({
    selector: '[rdxDropdownMenuItemRadio]',
    standalone: true,
    host: {
        role: 'menuitemradio'
    },
    providers: [
        { provide: RdxDropdownMenuSelectable, useExisting: RdxDropdownMenuItemRadioDirective },
        { provide: RdxDropdownMenuItemDirective, useExisting: RdxDropdownMenuSelectable },
        { provide: CdkMenuItem, useExisting: RdxDropdownMenuItemDirective },
        { provide: CDK_MENU, useExisting: RdxDropdownMenuContentDirective }
    ]
})
export class RdxDropdownMenuItemRadioDirective
    extends RdxDropdownMenuSelectable
    implements AfterContentInit, OnDestroy
{
    /** The unique selection dispatcher for this radio's `RdxDropdownMenuItemRadioGroupDirective`. */
    private readonly selectionDispatcher = inject(UniqueSelectionDispatcher);

    private readonly group = inject(RdxDropdownMenuItemRadioGroupDirective);

    @Input()
    get value() {
        return this._value || this.id;
    }

    set value(value: string) {
        this._value = value;
    }

    private _value: string | undefined;

    /** An ID to identify this radio item to the `UniqueSelectionDispatcher`. */
    private id = `${nextId++}`;

    private removeDispatcherListener!: () => void;

    constructor() {
        super();

        this.triggered.subscribe(() => {
            if (!this.disabled) {
                this.selectionDispatcher.notify(this.value, '');

                this.group.valueChange.emit(this.value);
            }
        });
    }

    ngAfterContentInit() {
        this.removeDispatcherListener = this.selectionDispatcher.listen((id: string) => {
            this.checked = this.value === id;
        });
    }

    override ngOnDestroy() {
        super.ngOnDestroy();
        this.removeDispatcherListener();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dropdown-menu/src/dropdown-menu-item-selectable.ts
```typescript
import { booleanAttribute, Directive, EventEmitter, Input, Output } from '@angular/core';
import { RdxDropdownMenuItemDirective } from './dropdown-menu-item.directive';

/** Base class providing checked state for selectable DropdownMenuItems. */
@Directive({
    standalone: true,
    host: {
        '[attr.aria-checked]': '!!checked',
        '[attr.aria-disabled]': 'disabled || null',
        '[attr.data-state]': 'checked ? "checked" : "unchecked"'
    }
})
export class RdxDropdownMenuSelectable extends RdxDropdownMenuItemDirective {
    /** Whether the element is checked */
    @Input({ transform: booleanAttribute }) checked: boolean = false;

    @Output() readonly checkedChange = new EventEmitter<boolean>();
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dropdown-menu/src/dropdown-menu-item.directive.ts
```typescript
import { CDK_MENU, CdkMenuItem } from '@angular/cdk/menu';
import { booleanAttribute, Directive, ElementRef, EventEmitter, inject, Input, Output } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';

import { RdxDropdownMenuContentDirective } from './dropdown-menu-content.directive';

@Directive({
    selector: '[rdxDropdownMenuItem]',
    standalone: true,
    host: {
        type: 'button',
        // todo horizontal ?
        '[attr.data-orientation]': '"vertical"',
        '[attr.data-highlighted]': 'highlighted ? "" : null',
        '[attr.data-disabled]': 'disabled ? "" : null',
        '[attr.disabled]': 'disabled ? "" : null',
        '(pointermove)': 'onPointerMove()',
        '(focus)': 'menu.highlighted.next(this)',
        '(keydown)': 'onKeydown($event)'
    },
    providers: [
        { provide: CdkMenuItem, useExisting: RdxDropdownMenuItemDirective },
        { provide: CDK_MENU, useExisting: RdxDropdownMenuContentDirective }
    ]
})
export class RdxDropdownMenuItemDirective extends CdkMenuItem {
    protected readonly menu = inject(RdxDropdownMenuContentDirective);
    protected readonly nativeElement = inject(ElementRef).nativeElement;

    highlighted = false;

    @Input({ transform: booleanAttribute }) override disabled: boolean = false;

    @Output() readonly onSelect = new EventEmitter<void>();

    constructor() {
        super();

        this.menu.highlighted.pipe(takeUntilDestroyed()).subscribe((value) => {
            if (value !== this) {
                this.highlighted = false;
            }
        });

        this.triggered.subscribe(this.onSelect);
    }

    protected onPointerMove() {
        if (!this.highlighted) {
            this.nativeElement.focus({ preventScroll: true });
            this.menu.updateActiveItem(this);
        }
    }

    protected onKeydown(event: KeyboardEvent) {
        if (this.nativeElement.tagName !== 'BUTTON' && ['Enter', ' '].includes(event.key)) {
            event.preventDefault();
        }

        if (event.key === 'Escape') {
            if (!this.menu.closeOnEscape) {
                event.stopPropagation();
            } else {
                this.menu.onEscapeKeyDown(event);
            }
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dropdown-menu/src/dropdown-menu-label.directive.ts
```typescript
import { Directive } from '@angular/core';
import { RdxMenuLabelDirective } from '@radix-ng/primitives/menu';

@Directive({
    selector: '[rdxDropdownMenuLabel]',
    hostDirectives: [RdxMenuLabelDirective]
})
export class RdxDropdownMenuLabelDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dropdown-menu/src/dropdown-menu-separator.directive.ts
```typescript
import { Directive } from '@angular/core';
import { RdxMenuSeparatorDirective } from '@radix-ng/primitives/menu';

@Directive({
    selector: '[rdxDropdownMenuSeparator]',
    hostDirectives: [RdxMenuSeparatorDirective]
})
export class RdxDropdownMenuSeparatorDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dropdown-menu/src/dropdown-menu-trigger.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { CdkMenuTrigger, MENU_TRIGGER, PARENT_OR_NEW_MENU_STACK_PROVIDER } from '@angular/cdk/menu';
import { ConnectedPosition, OverlayRef, VerticalConnectionPos } from '@angular/cdk/overlay';
import { booleanAttribute, Directive, Input, input, numberAttribute, TemplateRef } from '@angular/core';
import { outputFromObservable } from '@angular/core/rxjs-interop';

export enum DropdownSide {
    Top = 'top',
    Right = 'right',
    Bottom = 'bottom',
    Left = 'left'
}

export enum DropdownAlign {
    Start = 'start',
    Center = 'center',
    End = 'end'
}

export const mapRdxAlignToCdkPosition = {
    start: 'top',
    center: 'center',
    end: 'bottom'
};

const dropdownPositions: Record<DropdownSide, ConnectedPosition> = {
    top: {
        originX: 'start',
        originY: 'top',
        overlayX: 'start',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: 0
    },
    right: {
        originX: 'end',
        originY: 'top',
        overlayX: 'start',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 0
    },
    bottom: {
        originX: 'start',
        originY: 'bottom',
        overlayX: 'start',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 0
    },
    left: {
        originX: 'start',
        originY: 'top',
        overlayX: 'end',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 0
    }
};

/**
 * @group Components
 */
@Directive({
    selector: '[rdxDropdownMenuTrigger]',
    standalone: true,
    host: {
        type: 'button',
        '[attr.aria-haspopup]': "'menu'",
        '[attr.aria-expanded]': 'isOpen()',
        '[attr.data-state]': "isOpen() ? 'open': 'closed'",
        '[attr.data-disabled]': "disabled() ? '' : undefined",
        '[disabled]': 'disabled()',

        '(pointerdown)': 'onPointerDown($event)'
    },
    providers: [
        { provide: CdkMenuTrigger, useExisting: RdxDropdownMenuTriggerDirective },
        { provide: MENU_TRIGGER, useExisting: CdkMenuTrigger },
        PARENT_OR_NEW_MENU_STACK_PROVIDER
    ]
})
export class RdxDropdownMenuTriggerDirective extends CdkMenuTrigger {
    readonly disabled = input<boolean, BooleanInput>(false, {
        transform: booleanAttribute
    });

    @Input()
    set rdxDropdownMenuTrigger(value: TemplateRef<unknown> | null) {
        this.menuTemplateRef = value;
    }

    /**
     * The preferred side of the trigger to render against when open.
     * Will be reversed when collisions occur and `avoidCollisions` is enabled.
     *
     * @group Props
     * @defaultValue 'bottom'
     */
    @Input()
    set side(value: DropdownSide) {
        if (!Object.values(DropdownSide).includes(value)) {
            throw new Error(`Unknown side: ${value}`);
        }

        this._side = value;

        this.menuPosition[0] = dropdownPositions[value];
    }

    get side(): DropdownSide {
        return this._side;
    }

    private _side: DropdownSide = DropdownSide.Bottom;

    /**
     * The preferred alignment against the trigger. May change when collisions occur.
     *
     * @group Props
     * @defaultValue 'center'
     */
    @Input()
    set align(value: DropdownAlign) {
        if (!Object.values(DropdownAlign).includes(value)) {
            throw new Error(`Unknown align: ${value}`);
        }

        this._align = value;

        if (this.isVertical) {
            this.defaultPosition.overlayX = this.defaultPosition.originX = value;
        } else {
            this.defaultPosition.overlayY = this.defaultPosition.originY = mapRdxAlignToCdkPosition[
                value
            ] as VerticalConnectionPos;
        }
    }

    get align() {
        return this._align;
    }

    private _align: DropdownAlign = DropdownAlign.Start;

    /**
     * The distance in pixels from the trigger.
     * @group Props
     * @defaultValue 0
     */
    @Input({ transform: numberAttribute })
    set sideOffset(value: number) {
        // todo need invert value for top and left
        if (this.isVertical) {
            this.defaultPosition.offsetY = value;
        } else {
            this.defaultPosition.offsetX = value;
        }
    }

    get sideOffset() {
        return this._sideOffset;
    }

    private _sideOffset: number = 0;

    /**
     * An offset in pixels from the "start" or "end" alignment options.
     * @group Props
     * @defaultValue 0
     */
    @Input({ transform: numberAttribute })
    set alignOffset(value: number) {
        // todo need invert value for top and left
        if (this.isVertical) {
            this.defaultPosition.offsetX = value;
        } else {
            this.defaultPosition.offsetY = value;
        }
    }

    get alignOffset(): number {
        return this._alignOffset;
    }

    private _alignOffset: number = 0;

    onOpenChange = outputFromObservable(this.opened);

    get isVertical(): boolean {
        return this._side === DropdownSide.Top || this._side === DropdownSide.Bottom;
    }

    get defaultPosition(): ConnectedPosition {
        return this.menuPosition[0];
    }

    constructor() {
        super();
        // todo priority
        this.menuPosition = [{ ...dropdownPositions[DropdownSide.Bottom] }];
    }

    onPointerDown($event: MouseEvent) {
        // only call handler if it's the left button (mousedown gets triggered by all mouse buttons)
        // but not when the control key is pressed (avoiding MacOS right click)
        if (!this.disabled() && $event.button === 0 && !$event.ctrlKey) {
            /* empty */
            if (!this.isOpen()) {
                // prevent trigger focusing when opening
                // this allows the content to be given focus without competition
                $event.preventDefault();
            }
        }
    }

    getOverlayRef(): OverlayRef | null {
        return this.overlayRef;
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/slider/README.md
```
# @radix-ng/primitives/slider

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/slider/index.ts
```typescript
import { NgModule } from '@angular/core';
import { RdxSliderRangeComponent } from './src/slider-range.component';
import { RdxSliderRootComponent } from './src/slider-root.component';
import { RdxSliderThumbComponent } from './src/slider-thumb.component';
import { RdxSliderTrackComponent } from './src/slider-track.component';

export * from './src/slider-horizontal.component';
export * from './src/slider-impl.directive';
export * from './src/slider-range.component';
export * from './src/slider-root.component';
export * from './src/slider-thumb-impl.directive';
export * from './src/slider-thumb.component';
export * from './src/slider-track.component';
export * from './src/slider-vertical.component';

const _imports = [RdxSliderRootComponent, RdxSliderTrackComponent, RdxSliderRangeComponent, RdxSliderThumbComponent];

@NgModule({
    imports: [..._imports],
    exports: [..._imports]
})
export class RdxSliderModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/slider/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/slider/stories/slider.docs.mdx
````
import { ArgTypes, Canvas, Meta } from '@storybook/blocks';
import * as SliderStories from './slider.stories';
import { RdxSliderRootComponent } from '../src/slider-root.component';

<Meta title="Primitives/Slider" />

# Slider

#### An input where the user selects a value from within a given range.

<Canvas sourceState="hidden" of={SliderStories.Default} />

## Features

- âœ… Can be controlled or uncontrolled.
- âœ… Supports multiple thumbs.
- âœ… Supports a minimum value between thumbs.
- âœ… Supports touch or click on track to update value.
- âœ… Supports Right to Left direction.
- âœ… Full keyboard navigation.

## Anatomy

Import all parts and piece them together.


```html
<rdx-slider>
    <rdx-slider-track >
        <rdx-slider-range />
    </rdx-slider-track>
    <rdx-slider-thumb />
</rdx-slider>
```

## API Reference

<ArgTypes of={RdxSliderRootComponent} />

## Accessibility
Adheres to the [Slider WAI-ARIA design pattern](https://www.w3.org/WAI/ARIA/apg/patterns/slider-multithumb).


````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/slider/stories/slider.stories.ts
```typescript
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { RdxSliderRangeComponent } from '../src/slider-range.component';
import { RdxSliderRootComponent } from '../src/slider-root.component';
import { RdxSliderThumbComponent } from '../src/slider-thumb.component';
import { RdxSliderTrackComponent } from '../src/slider-track.component';

const html = String.raw;

export default {
    title: 'Primitives/Slider',
    decorators: [
        moduleMetadata({
            imports: [
                RdxSliderRootComponent,
                RdxSliderTrackComponent,
                RdxSliderRangeComponent,
                RdxSliderThumbComponent
            ]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div class="radix-themes light light-theme" data-radius="medium" data-scaling="100%">
                    ${story}

                    <style>
                        /*Look at root main.scss*/
                    </style>
                </div>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: (args) => ({
        props: args,
        template: html`
            <rdx-slider styleClass="SliderRoot" [modelValue]="[45]" [step]="5">
                <rdx-slider-track class="SliderTrack">
                    <rdx-slider-range class="SliderRange" />
                </rdx-slider-track>
                <rdx-slider-thumb class="SliderThumb" />
            </rdx-slider>
        `
    })
};

export const Inverted: Story = {
    render: (args) => ({
        props: args,
        template: html`
            <rdx-slider styleClass="SliderRoot" inverted [modelValue]="[45]" [step]="5">
                <rdx-slider-track class="SliderTrack">
                    <rdx-slider-range class="SliderRange" />
                </rdx-slider-track>
                <rdx-slider-thumb class="SliderThumb" />
            </rdx-slider>
        `
    })
};

export const Thumbs: Story = {
    render: (args) => ({
        props: args,
        template: html`
            <rdx-slider styleClass="SliderRoot" [modelValue]="[45, 80]" [step]="5">
                <rdx-slider-track class="SliderTrack">
                    <rdx-slider-range class="SliderRange" />
                </rdx-slider-track>
                <rdx-slider-thumb class="SliderThumb" />
                <rdx-slider-thumb class="SliderThumb" />
            </rdx-slider>
        `
    })
};

export const Vertical: Story = {
    render: (args) => ({
        props: args,
        template: html`
            <rdx-slider styleClass="SliderRootV" [orientation]="'vertical'" [modelValue]="[45]" [step]="5">
                <rdx-slider-track class="SliderTrackV">
                    <rdx-slider-range class="SliderRangeV" />
                </rdx-slider-track>
                <rdx-slider-thumb class="SliderThumbV" />
            </rdx-slider>

            <rdx-slider styleClass="SliderRoot" [orientation]="'horizontal'" [modelValue]="[45]" [step]="5">
                <rdx-slider-track class="SliderTrack">
                    <rdx-slider-range class="SliderRange" />
                </rdx-slider-track>
                <rdx-slider-thumb class="SliderThumb" />
            </rdx-slider>
        `
    })
};

export const VerticalInverted: Story = {
    render: (args) => ({
        props: args,
        template: html`
            <rdx-slider
                styleClass="SliderRootV"
                style="display: flex; height: 200px;"
                inverted
                [orientation]="'vertical'"
                [modelValue]="[45]"
                [step]="5"
            >
                <rdx-slider-track class="SliderTrackV">
                    <rdx-slider-range class="SliderRangeV" />
                </rdx-slider-track>
                <rdx-slider-thumb class="SliderThumbV" />
            </rdx-slider>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/slider/src/slider-horizontal.component.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import {
    booleanAttribute,
    Component,
    ElementRef,
    inject,
    input,
    Input,
    output,
    signal,
    viewChild
} from '@angular/core';
import { RdxSliderImplDirective } from './slider-impl.directive';
import { RdxSliderRootComponent } from './slider-root.component';
import { BACK_KEYS, linearScale } from './utils';

@Component({
    selector: 'rdx-slider-horizontal',
    imports: [RdxSliderImplDirective],
    template: `
        <span
            #sliderElement
            [class]="className"
            [attr.data-orientation]="'horizontal'"
            [style]="{ '--rdx-slider-thumb-transform': 'translateX(-50%)' }"
            (slideStart)="onSlideStart($event)"
            (slideMove)="onSlideMove($event)"
            (slideEnd)="onSlideEnd()"
            (stepKeyDown)="onStepKeyDown($event)"
            (endKeyDown)="endKeyDown.emit($event)"
            (homeKeyDown)="homeKeyDown.emit($event)"
            rdxSliderImpl
        >
            <ng-content />
        </span>
    `
})
export class RdxSliderHorizontalComponent {
    private readonly rootContext = inject(RdxSliderRootComponent);

    @Input() dir: 'ltr' | 'rtl' = 'ltr';

    readonly inverted = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    @Input() min = 0;
    @Input() max = 100;

    @Input() className = '';

    readonly slideStart = output<number>();
    readonly slideMove = output<number>();
    readonly slideEnd = output<void>();
    readonly stepKeyDown = output<{ event: KeyboardEvent; direction: number }>();
    readonly endKeyDown = output<KeyboardEvent>();
    readonly homeKeyDown = output<KeyboardEvent>();

    private readonly sliderElement = viewChild<ElementRef>('sliderElement');

    private readonly rect = signal<DOMRect | undefined>(undefined);

    onSlideStart(event: PointerEvent) {
        const value = this.getValueFromPointer(event.clientX);
        this.slideStart.emit(value);
    }

    onSlideMove(event: PointerEvent) {
        const value = this.getValueFromPointer(event.clientX);
        this.slideMove.emit(value);
    }

    onSlideEnd() {
        this.rect.set(undefined);
        this.slideEnd.emit();
    }

    onStepKeyDown(event: KeyboardEvent) {
        const slideDirection = this.rootContext.isSlidingFromLeft() ? 'from-left' : 'from-right';
        const isBackKey = BACK_KEYS[slideDirection].includes(event.key);

        this.stepKeyDown.emit({ event, direction: isBackKey ? -1 : 1 });
    }

    private getValueFromPointer(pointerPosition: number): number {
        this.rect.set(this.sliderElement()?.nativeElement.getBoundingClientRect());
        const rect = this.rect();
        if (!rect) return 0;

        const input: [number, number] = [0, rect.width];
        const output: [number, number] = this.rootContext.isSlidingFromLeft()
            ? [this.min, this.max]
            : [this.max, this.min];

        const value = linearScale(input, output);
        this.rect.set(rect);

        return value(pointerPosition - rect.left);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/slider/src/slider-impl.directive.ts
```typescript
import { Directive, inject, output } from '@angular/core';
import { RdxSliderRootComponent } from './slider-root.component';
import { ARROW_KEYS, PAGE_KEYS } from './utils';

@Directive({
    selector: '[rdxSliderImpl]',
    host: {
        role: 'slider',
        tabindex: '0',
        '(keydown)': 'onKeyDown($event)',
        '(pointerdown)': 'onPointerDown($event)',
        '(pointermove)': 'onPointerMove($event)',
        '(pointerup)': 'onPointerUp($event)'
    }
})
export class RdxSliderImplDirective {
    protected readonly rootContext = inject(RdxSliderRootComponent);

    readonly slideStart = output<PointerEvent>();
    readonly slideMove = output<PointerEvent>();
    readonly slideEnd = output<PointerEvent>();
    readonly homeKeyDown = output<KeyboardEvent>();
    readonly endKeyDown = output<KeyboardEvent>();
    readonly stepKeyDown = output<KeyboardEvent>();

    onKeyDown(event: KeyboardEvent) {
        if (event.key === 'Home') {
            this.homeKeyDown.emit(event);
            // Prevent scrolling to page start
            event.preventDefault();
        } else if (event.key === 'End') {
            this.endKeyDown.emit(event);
            // Prevent scrolling to page end
            event.preventDefault();
        } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {
            this.stepKeyDown.emit(event);
            // Prevent scrolling for directional key presses
            event.preventDefault();
        }
    }

    onPointerDown(event: PointerEvent) {
        const target = event.target as HTMLElement;
        target.setPointerCapture(event.pointerId);

        // Prevent browser focus behaviour because we focus a thumb manually when values change.
        event.preventDefault();

        // Touch devices have a delay before focusing so won't focus if touch immediately moves
        // away from target (sliding). We want thumb to focus regardless.
        if (this.rootContext.thumbElements.includes(target)) {
            target.focus();
        } else {
            this.slideStart.emit(event);
        }
    }

    onPointerMove(event: PointerEvent) {
        const target = event.target as HTMLElement;
        if (target.hasPointerCapture(event.pointerId)) {
            this.slideMove.emit(event);
        }
    }

    onPointerUp(event: PointerEvent) {
        const target = event.target as HTMLElement;
        if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
            this.slideEnd.emit(event);
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/slider/src/slider-orientation-context.service.ts
```typescript
import { Injectable, signal } from '@angular/core';

export interface OrientationContext {
    startEdge: string;
    endEdge: string;
    direction: number;
    size: string;
}

@Injectable()
export class RdxSliderOrientationContextService {
    private contextSignal = signal<OrientationContext>({
        startEdge: 'left',
        endEdge: 'right',
        direction: 1,
        size: 'width'
    });

    get context() {
        return this.contextSignal();
    }

    updateContext(context: Partial<OrientationContext>) {
        this.contextSignal.update((current) => ({
            ...current,
            ...context
        }));
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/slider/src/slider-range.component.ts
```typescript
import { Component, computed, inject } from '@angular/core';
import { RdxSliderRootComponent } from './slider-root.component';
import { convertValueToPercentage } from './utils';

@Component({
    selector: 'rdx-slider-range',
    host: {
        '[attr.data-disabled]': 'rootContext.disabled() ? "" : undefined',
        '[attr.data-orientation]': 'rootContext.orientation()',
        '[style]': 'rangeStyles()'
    },
    template: `
        <ng-content />
    `
})
export class RdxSliderRangeComponent {
    protected readonly rootContext = inject(RdxSliderRootComponent);

    percentages = computed(() =>
        this.rootContext
            .modelValue()
            ?.map((value) => convertValueToPercentage(value, this.rootContext.min(), this.rootContext.max()))
    );

    offsetStart = computed(() => (this.rootContext.modelValue()!.length > 1 ? Math.min(...this.percentages()!) : 0));
    offsetEnd = computed(() => 100 - Math.max(...this.percentages()!));

    rangeStyles = computed(() => {
        const context = this.rootContext.orientationContext.context;

        return {
            [context.startEdge]: `${this.offsetStart()}%`,
            [context.endEdge]: `${this.offsetEnd()}%`
        };
    });
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/slider/src/slider-root.component.ts
```typescript
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import { NgIf, NgTemplateOutlet } from '@angular/common';
import {
    booleanAttribute,
    Component,
    computed,
    inject,
    input,
    Input,
    model,
    numberAttribute,
    OnInit,
    output
} from '@angular/core';
import { RdxSliderHorizontalComponent } from './slider-horizontal.component';
import { RdxSliderOrientationContextService } from './slider-orientation-context.service';
import { RdxSliderVerticalComponent } from './slider-vertical.component';
import {
    clamp,
    getClosestValueIndex,
    getDecimalCount,
    getNextSortedValues,
    hasMinStepsBetweenValues,
    roundValue
} from './utils';

/**
 * @group Components
 */
@Component({
    selector: 'rdx-slider',
    imports: [RdxSliderHorizontalComponent, RdxSliderVerticalComponent, NgIf, NgTemplateOutlet],
    providers: [RdxSliderOrientationContextService],
    template: `
        <ng-template #transclude><ng-content /></ng-template>

        <ng-container *ngIf="orientation() === 'horizontal'">
            <rdx-slider-horizontal
                [className]="styleClass() || className"
                [min]="min()"
                [max]="max()"
                [dir]="dir()"
                [inverted]="inverted()"
                [attr.aria-disabled]="disabled()"
                [attr.data-disabled]="disabled() ? '' : undefined"
                (pointerdown)="onPointerDown()"
                (slideStart)="handleSlideStart($event)"
                (slideMove)="handleSlideMove($event)"
                (slideEnd)="handleSlideEnd()"
                (homeKeyDown)="updateValues(min(), 0, true)"
                (endKeyDown)="updateValues(max(), modelValue().length - 1, true)"
                (stepKeyDown)="handleStepKeyDown($event)"
            >
                <ng-container *ngTemplateOutlet="transclude" />
            </rdx-slider-horizontal>
        </ng-container>

        <ng-container *ngIf="orientation() === 'vertical'">
            <rdx-slider-vertical
                [className]="styleClass() || className"
                [min]="min()"
                [max]="max()"
                [dir]="dir()"
                [inverted]="inverted()"
                [attr.aria-disabled]="disabled()"
                [attr.data-disabled]="disabled() ? '' : undefined"
                (pointerdown)="onPointerDown()"
                (slideStart)="handleSlideStart($event)"
                (slideMove)="handleSlideMove($event)"
                (slideEnd)="handleSlideEnd()"
                (homeKeyDown)="updateValues(min(), 0, true)"
                (endKeyDown)="updateValues(max(), modelValue().length - 1, true)"
                (stepKeyDown)="handleStepKeyDown($event)"
            >
                <ng-container *ngTemplateOutlet="transclude" />
            </rdx-slider-vertical>
        </ng-container>
    `
})
export class RdxSliderRootComponent implements OnInit {
    /** @ignore */
    readonly orientationContext = inject(RdxSliderOrientationContextService);

    /**
     * The minimum value for the range.
     *
     * @group Props
     * @defaultValue 0
     */
    readonly min = input<number, NumberInput>(0, { transform: numberAttribute });

    /**
     * The maximum value for the range.
     *
     * @group Props
     * @defaultValue 100
     */
    readonly max = input<number, NumberInput>(100, { transform: numberAttribute });

    /**
     * The stepping interval.
     *
     * @group Props
     * @defaultValue 1
     */
    readonly step = input<number, NumberInput>(1, { transform: numberAttribute });

    /**
     * The minimum permitted steps between multiple thumbs.
     *
     * @group Props
     * @defaultValue 0
     */
    readonly minStepsBetweenThumbs = input<number, NumberInput>(0, { transform: numberAttribute });

    /**
     * The orientation of the slider.
     *
     * @group Props
     * @defaultValue 'horizontal'
     */
    readonly orientation = input<'horizontal' | 'vertical'>('horizontal');

    /**
     * When true, prevents the user from interacting with the slider.
     *
     * @group Props
     * @defaultValue false
     */
    readonly disabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * Whether the slider is visually inverted.
     *
     * @group Props
     * @defaultValue false
     */
    readonly inverted = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * The reading direction of the combobox when applicable.
     *
     * @group Props
     * @defaultValue 'ltr'
     */
    readonly dir = input<'ltr' | 'rtl'>('ltr');

    @Input() className: string = '';

    /**
     * Style class of the component.
     *
     * @group Props
     */
    readonly styleClass = input<string>();

    /**
     * The controlled value of the slider.
     *
     * @group Props
     */
    readonly modelValue = model<number[]>([0]);

    /**
     * Event handler called when the slider value changes.
     *
     * @group Emits
     */
    readonly valueChange = output<number[]>();

    /**
     * Event handler called when the value changes at the end of an interaction.
     *
     * Useful when you only need to capture a final value e.g. to update a backend service.
     *
     * @group Emits
     */
    readonly valueCommit = output<number[]>();

    /** @ignore */
    readonly valueIndexToChange = model(0);

    /** @ignore */
    readonly valuesBeforeSlideStart = model<number[]>([]);

    /** @ignore */
    readonly isSlidingFromLeft = computed(
        () => (this.dir() === 'ltr' && !this.inverted()) || (this.dir() !== 'ltr' && this.inverted())
    );

    /** @ignore */
    readonly isSlidingFromBottom = computed(() => !this.inverted());

    /** @ignore */
    thumbElements: HTMLElement[] = [];

    /** @ignore */
    ngOnInit() {
        const isHorizontal = this.orientation() === 'horizontal';

        if (isHorizontal) {
            this.orientationContext.updateContext({
                direction: this.isSlidingFromLeft() ? 1 : -1,
                size: 'width',
                startEdge: this.isSlidingFromLeft() ? 'left' : 'right',
                endEdge: this.isSlidingFromLeft() ? 'right' : 'left'
            });
        } else {
            this.orientationContext.updateContext({
                direction: this.isSlidingFromBottom() ? -1 : 1,
                size: 'height',
                startEdge: this.isSlidingFromBottom() ? 'bottom' : 'top',
                endEdge: this.isSlidingFromBottom() ? 'top' : 'bottom'
            });
        }
    }

    /** @ignore */
    onPointerDown() {
        this.valuesBeforeSlideStart.set([...this.modelValue()]);
    }

    /** @ignore */
    handleSlideStart(value: number): void {
        const closestIndex = getClosestValueIndex(this.modelValue(), value);
        this.updateValues(value, closestIndex);
    }

    /** @ignore */
    handleSlideMove(value: number): void {
        this.updateValues(value, this.valueIndexToChange());
    }

    /** @ignore */
    handleSlideEnd(): void {
        const prevValue = this.valuesBeforeSlideStart()[this.valueIndexToChange()];
        const nextValue = this.modelValue()[this.valueIndexToChange()];
        const hasChanged = nextValue !== prevValue;

        if (hasChanged) {
            this.valueCommit.emit([...this.modelValue()]);
        }
    }

    /** @ignore */
    handleStepKeyDown(event: { event: KeyboardEvent; direction: number }): void {
        const stepInDirection = this.step() * event.direction;
        const atIndex = this.valueIndexToChange();
        const currentValue = this.modelValue()[atIndex];
        this.updateValues(currentValue + stepInDirection, atIndex, true);
    }

    /** @ignore */
    updateValues(value: number, atIndex: number, commit = false): void {
        const decimalCount = getDecimalCount(this.step());
        const snapToStep = roundValue(
            Math.round((value - this.min()) / this.step()) * this.step() + this.min(),
            decimalCount
        );
        const nextValue = clamp(snapToStep, this.min(), this.max());

        const nextValues = getNextSortedValues(this.modelValue(), nextValue, atIndex);

        if (hasMinStepsBetweenValues(nextValues, this.minStepsBetweenThumbs() * this.step())) {
            this.valueIndexToChange.set(nextValues.indexOf(nextValue));
            const hasChanged = String(nextValues) !== String(this.modelValue());

            if (hasChanged) {
                this.modelValue.set(nextValues);
                this.valueChange.emit([...this.modelValue()]);
                this.thumbElements[this.valueIndexToChange()]?.focus();

                if (commit) {
                    this.valueCommit.emit([...this.modelValue()]);
                }
            }
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/slider/src/slider-thumb-impl.directive.ts
```typescript
import { isPlatformBrowser } from '@angular/common';
import { computed, Directive, ElementRef, inject, OnDestroy, OnInit, PLATFORM_ID, signal } from '@angular/core';
import { RdxSliderRootComponent } from './slider-root.component';
import { convertValueToPercentage, getThumbInBoundsOffset } from './utils';

@Directive({
    selector: '[rdxSliderThumbImpl]',
    host: {
        role: 'slider',
        '[tabindex]': 'rootContext.disabled() ? undefined : 0',

        '[attr.aria-valuenow]': 'rootContext.modelValue()',
        '[attr.aria-valuemin]': 'rootContext.min()',
        '[attr.aria-valuemax]': 'rootContext.max()',
        '[attr.aria-orientation]': 'rootContext.orientation()',

        '[attr.data-orientation]': 'rootContext.orientation()',
        '[attr.data-disabled]': 'rootContext.disabled() ? "" : undefined',

        '[style]': 'combinedStyles()',

        '(focus)': 'onFocus()'
    }
})
export class RdxSliderThumbImplDirective implements OnInit, OnDestroy {
    protected readonly rootContext = inject(RdxSliderRootComponent);
    private readonly elementRef = inject(ElementRef);
    private readonly platformId = inject(PLATFORM_ID);
    private resizeObserver!: ResizeObserver;

    isMounted = signal(false);

    thumbIndex = computed(() => {
        const thumbElement = this.elementRef.nativeElement;
        const index = this.rootContext.thumbElements.indexOf(thumbElement);
        return index >= 0 ? index : null;
    });

    value = computed(() => {
        const index = this.thumbIndex();
        if (index === null) return undefined;
        return this.rootContext.modelValue()?.[index];
    });

    percent = computed(() => {
        const val = this.value();
        if (val === undefined) return 0;
        return convertValueToPercentage(val, this.rootContext.min(), this.rootContext.max());
    });

    transform = computed(() => {
        const percent = this.percent();
        const offset = this.thumbInBoundsOffset();
        return `calc(${percent}% + ${offset}px)`;
    });

    orientationSize = signal(0);

    thumbInBoundsOffset = computed(() => {
        const context = this.rootContext.orientationContext.context;

        const size = this.orientationSize();
        const percent = this.percent();
        const direction = context.direction;

        return size ? getThumbInBoundsOffset(size, percent, direction) : 0;
    });

    combinedStyles = computed(() => {
        const context = this.rootContext.orientationContext.context;

        const startEdge = context.startEdge;
        const percent = this.percent();
        const offset = this.thumbInBoundsOffset();

        return {
            position: 'absolute',
            transform: 'var(--rdx-slider-thumb-transform)',
            display: (this.isMounted() && this.value()) === false ? 'none' : undefined,
            [startEdge]: `calc(${percent}% + ${offset}px)`
        };
    });

    onFocus() {
        if (this.thumbIndex() !== null) {
            this.rootContext.valueIndexToChange.set(this.thumbIndex()!);
        }
    }

    ngOnInit() {
        if (isPlatformBrowser(this.platformId)) {
            const thumbElement = this.elementRef.nativeElement;
            this.rootContext.thumbElements.push(thumbElement);

            this.resizeObserver = new ResizeObserver(() => {
                const rect = thumbElement.getBoundingClientRect();
                const context = this.rootContext.orientationContext.context;
                const size = context.size === 'width' ? rect.width : rect.height;
                this.orientationSize.set(size);
            });

            this.resizeObserver.observe(thumbElement);

            this.isMounted.set(true);
        }
    }

    ngOnDestroy() {
        const thumbElement = this.elementRef.nativeElement;
        const index = this.rootContext.thumbElements.indexOf(thumbElement);
        if (index >= 0) this.rootContext.thumbElements.splice(index, 1);

        if (this.resizeObserver) {
            this.resizeObserver.unobserve(thumbElement);
        }

        this.isMounted.set(false);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/slider/src/slider-thumb.component.ts
```typescript
import { Component } from '@angular/core';
import { RdxSliderThumbImplDirective } from './slider-thumb-impl.directive';

@Component({
    selector: 'rdx-slider-thumb',
    hostDirectives: [RdxSliderThumbImplDirective],
    template: `
        <ng-content />
    `
})
export class RdxSliderThumbComponent {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/slider/src/slider-track.component.ts
```typescript
import { Component, inject } from '@angular/core';
import { RdxSliderRootComponent } from './slider-root.component';

@Component({
    selector: 'rdx-slider-track',
    host: {
        '[attr.data-disabled]': "rootContext.disabled() ? '' : undefined",
        '[attr.data-orientation]': 'rootContext.orientation()'
    },
    template: `
        <ng-content />
    `
})
export class RdxSliderTrackComponent {
    protected readonly rootContext = inject(RdxSliderRootComponent);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/slider/src/slider-vertical.component.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import {
    booleanAttribute,
    Component,
    ElementRef,
    inject,
    input,
    Input,
    output,
    signal,
    viewChild
} from '@angular/core';
import { RdxSliderImplDirective } from './slider-impl.directive';
import { RdxSliderRootComponent } from './slider-root.component';
import { BACK_KEYS, linearScale } from './utils';

@Component({
    selector: 'rdx-slider-vertical',
    imports: [RdxSliderImplDirective],
    template: `
        <span
            #sliderElement
            [class]="className"
            [attr.data-orientation]="'vertical'"
            [style]="{ '--rdx-slider-thumb-transform': 'translateY(-50%)' }"
            (slideStart)="onSlideStart($event)"
            (slideMove)="onSlideMove($event)"
            (slideEnd)="onSlideEnd()"
            (stepKeyDown)="onStepKeyDown($event)"
            (endKeyDown)="endKeyDown.emit($event)"
            (homeKeyDown)="homeKeyDown.emit($event)"
            rdxSliderImpl
        >
            <ng-content />
        </span>
    `
})
export class RdxSliderVerticalComponent {
    private readonly rootContext = inject(RdxSliderRootComponent);

    @Input() dir: 'ltr' | 'rtl' = 'ltr';

    readonly inverted = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    @Input() min = 0;
    @Input() max = 100;

    @Input() className = '';

    readonly slideStart = output<number>();
    readonly slideMove = output<number>();
    readonly slideEnd = output<void>();
    readonly stepKeyDown = output<{ event: KeyboardEvent; direction: number }>();
    readonly endKeyDown = output<KeyboardEvent>();
    readonly homeKeyDown = output<KeyboardEvent>();

    private readonly sliderElement = viewChild<ElementRef>('sliderElement');

    private readonly rect = signal<DOMRect | undefined>(undefined);

    onSlideStart(event: PointerEvent) {
        const value = this.getValueFromPointer(event.clientY);
        this.slideStart.emit(value);
    }

    onSlideMove(event: PointerEvent) {
        const value = this.getValueFromPointer(event.clientY);
        this.slideMove.emit(value);
    }

    onSlideEnd() {
        this.rect.set(undefined);
        this.slideEnd.emit();
    }

    onStepKeyDown(event: KeyboardEvent) {
        const slideDirection = this.rootContext.isSlidingFromBottom() ? 'from-bottom' : 'from-top';
        const isBackKey = BACK_KEYS[slideDirection].includes(event.key);

        this.stepKeyDown.emit({ event, direction: isBackKey ? -1 : 1 });
    }

    private getValueFromPointer(pointerPosition: number): number {
        this.rect.set(this.sliderElement()?.nativeElement.getBoundingClientRect());
        const rect = this.rect();
        if (!rect) return 0;

        const input: [number, number] = [0, rect.height];
        const output: [number, number] = this.rootContext.isSlidingFromBottom()
            ? [this.max, this.min]
            : [this.min, this.max];

        const value = linearScale(input, output);
        this.rect.set(rect);

        return value(pointerPosition - rect.top);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/slider/src/utils.ts
```typescript
// https://github.com/tmcw-up-for-adoption/simple-linear-scale/blob/master/index.js
export function linearScale(input: readonly [number, number], output: readonly [number, number]) {
    return (value: number) => {
        if (input[0] === input[1] || output[0] === output[1]) return output[0];
        const ratio = (output[1] - output[0]) / (input[1] - input[0]);
        return output[0] + ratio * (value - input[0]);
    };
}

/**
 * Verifies the minimum steps between all values is greater than or equal
 * to the expected minimum steps.
 *
 * @example
 * // returns false
 * hasMinStepsBetweenValues([1,2,3], 2);
 *
 * @example
 * // returns true
 * hasMinStepsBetweenValues([1,2,3], 1);
 */
export function hasMinStepsBetweenValues(values: number[], minStepsBetweenValues: number) {
    if (minStepsBetweenValues > 0) {
        const stepsBetweenValues = getStepsBetweenValues(values);
        const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
        return actualMinStepsBetweenValues >= minStepsBetweenValues;
    }
    return true;
}

/**
 * Given a `values` array and a `nextValue`, determine which value in
 * the array is closest to `nextValue` and return its index.
 *
 * @example
 * // returns 1
 * getClosestValueIndex([10, 30], 25);
 */
export function getClosestValueIndex(values: number[], nextValue: number) {
    if (values.length === 1) return 0;
    const distances = values.map((value) => Math.abs(value - nextValue));
    const closestDistance = Math.min(...distances);
    return distances.indexOf(closestDistance);
}

/**
 * Gets an array of steps between each value.
 *
 * @example
 * // returns [1, 9]
 * getStepsBetweenValues([10, 11, 20]);
 */
export function getStepsBetweenValues(values: number[]) {
    return values.slice(0, -1).map((value, index) => values[index + 1] - value);
}

/**
 * Offsets the thumb centre point while sliding to ensure it remains
 * within the bounds of the slider when reaching the edges
 */
export function getThumbInBoundsOffset(width: number, left: number, direction: number) {
    const halfWidth = width / 2;
    const halfPercent = 50;
    const offset = linearScale([0, halfPercent], [0, halfWidth]);
    return (halfWidth - offset(left) * direction) * direction;
}

export function convertValueToPercentage(value: number, min: number, max: number) {
    const maxSteps = max - min;
    const percentPerStep = 100 / maxSteps;
    const percentage = percentPerStep * (value - min);
    return clamp(percentage, 0, 100);
}

export function getDecimalCount(value: number) {
    return (String(value).split('.')[1] || '').length;
}

export function roundValue(value: number, decimalCount: number) {
    const rounder = 10 ** decimalCount;
    return Math.round(value * rounder) / rounder;
}

export function getNextSortedValues(prevValues: number[] = [], nextValue: number, atIndex: number) {
    const nextValues = [...prevValues];
    nextValues[atIndex] = nextValue;
    return nextValues.sort((a, b) => a - b);
}

export const PAGE_KEYS = ['PageUp', 'PageDown'];
export const ARROW_KEYS = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];

type SlideDirection = 'from-left' | 'from-right' | 'from-bottom' | 'from-top';
export const BACK_KEYS: Record<SlideDirection, string[]> = {
    'from-left': ['Home', 'PageDown', 'ArrowDown', 'ArrowLeft'],
    'from-right': ['Home', 'PageDown', 'ArrowDown', 'ArrowRight'],
    'from-bottom': ['Home', 'PageDown', 'ArrowDown', 'ArrowLeft'],
    'from-top': ['Home', 'PageDown', 'ArrowUp', 'ArrowLeft']
};

export interface OrientationContext {
    direction: number;
    size: 'width' | 'height';
    startEdge: 'left' | 'top';
    endEdge: 'right' | 'bottom';
}

export function clamp(
    value: number,
    min: number = Number.NEGATIVE_INFINITY,
    max: number = Number.POSITIVE_INFINITY
): number {
    return Math.min(Math.max(value, min), max);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/README.md
```
# @radix-ng/primitives/stepper

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/index.ts
```typescript
import { NgModule } from '@angular/core';
import { RdxStepperDescriptionDirective } from './src/stepper-description.directive';
import { RdxStepperIndicatorDirective } from './src/stepper-indicator.directive';
import { RdxStepperItemDirective } from './src/stepper-item.directive';
import { RdxStepperRootDirective } from './src/stepper-root.directive';
import { RdxStepperSeparatorDirective } from './src/stepper-separator.directive';
import { RdxStepperTitleDirective } from './src/stepper-title.directive';
import { RdxStepperTriggerDirective } from './src/stepper-trigger.directive';

export * from './src/stepper-description.directive';
export * from './src/stepper-indicator.directive';
export * from './src/stepper-item.directive';
export * from './src/stepper-root-context.token';
export * from './src/stepper-root.directive';
export * from './src/stepper-separator.directive';
export * from './src/stepper-title.directive';
export * from './src/stepper-trigger.directive';
export * from './src/types';

const _imports = [
    RdxStepperDescriptionDirective,
    RdxStepperTitleDirective,
    RdxStepperSeparatorDirective,
    RdxStepperItemDirective,
    RdxStepperIndicatorDirective,
    RdxStepperRootDirective,
    RdxStepperTriggerDirective
];

@NgModule({
    imports: [..._imports],
    exports: [..._imports]
})
export class RdxStepperModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/stories/stepper-navigation.component.ts
```typescript
import { Component, computed, signal } from '@angular/core';
import { ChevronLeft, ChevronRight, LucideAngularModule } from 'lucide-angular';
import { RdxStepperModule } from '../index';

@Component({
    selector: 'StepperNavigation',
    imports: [RdxStepperModule, LucideAngularModule],
    template: `
        <div class="StepperContainer">
            <div class="StepperNavigation">
                <button
                    class="StepperButton Button violet"
                    [disabled]="isFirstStep()"
                    (click)="prevStep()"
                    aria-label="Prev step"
                >
                    <lucide-angular
                        [img]="ChevronLeft"
                        size="16"
                        strokeWidth="2"
                        style="display: flex;"
                        aria-hidden="true"
                    />
                </button>

                <div class="Stepper" [value]="currentStep()" rdxStepperRoot>
                    @for (item of steps; track $index) {
                        <div class="StepperItem" [step]="item" rdxStepperItem>
                            <button class="StepperTrigger" rdxStepperTrigger>
                                <div class="StepperIndicator" rdxStepperIndicator>
                                    <span class="sr-only">{{ item }}</span>
                                </div>
                            </button>
                        </div>
                    }
                </div>

                <button
                    class="StepperButton Button violet"
                    [disabled]="isLastStep()"
                    (click)="nextStep()"
                    aria-label="Next step"
                >
                    <lucide-angular
                        [img]="ChevronRight"
                        style="display: flex;"
                        size="16"
                        strokeWidth="2"
                        aria-hidden="true"
                    />
                </button>
            </div>

            <p class="StepperPagination" role="region" aria-live="polite">Paginated stepper</p>
        </div>
    `,
    styles: `
        :host {
            button {
                all: unset;
            }
        }

        .StepperContainer {
            margin-left: auto;
            margin-right: auto;
            max-width: 40rem;
            text-align: center;
        }

        /* ÐšÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€ ÑˆÐ°Ð³Ð¾Ð² */
        .StepperNavigation {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .StepperButton {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 2.5rem;
            height: 2rem;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 4px;
        }

        .StepperButton:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .Stepper {
            display: flex;
            gap: 0.25rem;
            flex-grow: 1;
        }

        .StepperItem {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .StepperTrigger {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            width: 100%;
            gap: 0.5rem;
        }

        .StepperTrigger:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--gray-2);
            border-radius: 9999px;
        }

        .StepperIndicator {
            width: 100%;
            height: 4px;
            background-color: var(--border);
            border-radius: 4px;
        }

        .StepperItem[data-state='inactive'] .StepperIndicator {
            background-color: rgba(0, 0, 0, 0.38);
        }

        .StepperItem[data-state='active'] .StepperIndicator {
            background-color: #000;
        }

        .StepperItem[data-state='completed'] .StepperIndicator {
            background-color: var(--green-9);
        }

        .StepperPagination {
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: var(--white-a10);
        }

        .Button.violet {
            background-color: white;
            color: var(--violet-11);
            box-shadow: 0 2px 10px var(--black-a7);
        }

        .Button.violet:hover {
            background-color: var(--mauve-3);
        }

        .Button.violet:focus {
            box-shadow: 0 0 0 2px black;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
    `
})
export class StepperNavigationComponent {
    steps = [1, 2, 3, 4];

    readonly currentStep = signal(2);

    isFirstStep = computed(() => this.currentStep() === 1);
    isLastStep = computed(() => this.currentStep() === this.steps.length);

    prevStep() {
        if (!this.isFirstStep()) {
            this.currentStep.set(this.currentStep() - 1);
        }
    }

    nextStep() {
        if (!this.isLastStep()) {
            this.currentStep.set(this.currentStep() + 1);
        }
    }

    protected readonly ChevronLeft = ChevronLeft;
    protected readonly ChevronRight = ChevronRight;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/stories/stepper.docs.mdx
````
import { ArgTypes, Canvas, Meta } from '@storybook/blocks';
import * as Stories from './stepper.stories';
import {RdxStepperRootDirective} from "../src/stepper-root.directive";
import {RdxStepperItemDirective} from "../src/stepper-item.directive";

<Meta title="Primitives/Stepper" />

# Stepper

####  A set of steps that are used to indicate progress through a multi-step process.

<Canvas sourceState="hidden" of={Stories.Default} />

## Features

- âœ… Can be controlled or uncontrolled.
- âœ… Supports horizontal/vertical orientation.
- âœ… Supports linear/non-linear activation.
- âœ… Full keyboard navigation.

## Anatomy

Import all parts and piece them together.

```html
<div rdxStepperRoot >
    <div rdxStepperItem >
        <div rdxStepperSeparator></div>
        <button rdxStepperTrigger>
            <div rdxStepperIndicator></div>
        </button>

        <h4 rdxStepperTitle></h4>
        <p rdxStepperDescription></p>
    </div>
</div>
```

## API Reference

### Root

`RdxStepperRootDirective`

<ArgTypes of={RdxStepperRootDirective} />

### Item

`RdxStepperItemDirective`

The step item component.

<ArgTypes of={RdxStepperItemDirective} />

## Examples

### Vertical

<Canvas sourceState="hidden" of={Stories.Vertical} />

### Navigation

<Canvas sourceState="hidden" of={Stories.Navigation} />

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/stories/stepper.stories.ts
```typescript
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { RdxStepperIndicatorDirective } from '../src/stepper-indicator.directive';
import { RdxStepperItemDirective } from '../src/stepper-item.directive';
import { RdxStepperRootDirective } from '../src/stepper-root.directive';
import { RdxStepperSeparatorDirective } from '../src/stepper-separator.directive';
import { RdxStepperTriggerDirective } from '../src/stepper-trigger.directive';
import { StepperNavigationComponent } from './stepper-navigation.component';

const html = String.raw;

export default {
    title: 'Primitives/Stepper',
    decorators: [
        moduleMetadata({
            imports: [
                RdxStepperRootDirective,
                RdxStepperItemDirective,
                RdxStepperTriggerDirective,
                RdxStepperIndicatorDirective,
                RdxStepperSeparatorDirective,
                StepperNavigationComponent
            ]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div class="radix-themes light light-theme" data-radius="medium" data-scaling="100%">
                    ${story}

                    <style>
                        button {
                            all: unset;
                        }

                        /* StepperList */
                        .StepperList {
                            display: flex;
                            gap: 1rem;
                            max-width: 36rem;
                            width: 100%;
                            flex-direction: row;
                        }

                        .StepperList[data-orientation='vertical'] {
                            flex-direction: column;
                            max-width: 16rem;
                            /*align-items: center;*/
                            display: flex;
                        }

                        /* StepperItem */
                        .StepperItem {
                            padding-left: 1rem;
                            padding-right: 1rem;
                            position: relative;
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                        }

                        .StepperItem[data-orientation='vertical'] {
                            display: block;
                            padding: 0;
                        }

                        /* Disabled state */
                        .StepperItem[data-disabled] {
                            pointer-events: none;
                        }

                        .StepperItem[data-disabled] .StepperIndicator {
                            color: #9ca3af;
                        }

                        .StepperItem[data-disabled='true'] {
                            opacity: 0.5;
                            cursor: not-allowed;
                        }

                        /* Stepper states */
                        .StepperItem[data-state='inactive'] .StepperIndicator {
                            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.38);
                            background-color: rgba(0, 0, 0, 0.38);
                            color: white;
                        }

                        .StepperItem[data-state='active'] .StepperIndicator {
                            background-color: #000;
                            color: #fff;
                            box-shadow: 0 0 0 2px #000;
                        }

                        .StepperItem[data-state='completed'] .StepperIndicator {
                            background-color: var(--green-9);
                            color: #fff;
                            box-shadow: 0 0 0 2px var(--green-9);
                        }

                        /* StepperIndicator */
                        .StepperIndicator {
                            display: inline-flex;
                            align-items: center;
                            justify-content: center;
                            border-radius: 9999px;
                            width: 1.5rem;
                            height: 1.5rem;
                            color: var(--grass-11);
                            box-shadow: 0 0 0 2px #000;
                        }

                        .StepperIndicator[data-orientation='vertical'] {
                            margin-bottom: 0.5rem;
                        }

                        /* Stepper text elements */
                        .StepperItemText {
                            text-align: center;
                            top: 100%;
                            left: 0;
                            width: 100%;
                            margin-top: 0.5rem;
                            color: #57534e;
                        }

                        .StepperItemText[data-orientation='vertical'] {
                            text-align: left;
                            margin-top: -50px;
                            margin-left: 2.5rem;
                        }

                        .StepperTitle {
                            font-size: 0.875rem;
                            font-weight: 500;
                            color: white;
                        }

                        .StepperDescription {
                            font-size: 0.75rem;
                            color: white;
                        }

                        /* StepperSeparator */
                        .StepperSeparator {
                            position: absolute;
                            height: 1px;
                            left: calc(50% + 30px);
                            right: calc(-50% + 20px);
                            top: 21px;
                            background-color: var(--green-5);
                        }

                        .StepperSeparator[data-orientation='vertical'] {
                            width: 1px;
                            height: 70%;
                            top: 50%;
                            left: 8%;
                            right: auto;
                        }

                        /* StepperTrigger */
                        .StepperTrigger {
                            display: flex;
                            cursor: pointer;
                            gap: 0.5rem;
                            width: 2.5rem;
                            height: 2.5rem;
                            align-items: center;
                            justify-content: center;
                        }

                        .StepperTrigger:focus {
                            box-shadow: 0 0 0 2px black;
                            border-radius: 9999px;
                        }
                    </style>
                </div>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

const steps = [
    {
        step: 1,
        title: 'Address',
        description: 'Add your address here',
        icon: 'radix-icons:home'
    },
    {
        step: 2,
        title: 'Shipping',
        description: 'Set your preferred shipping method',
        icon: 'radix-icons:archive'
    },
    {
        step: 3,
        title: 'Trade-in',
        description: 'Add any trade-in items you have',
        icon: 'radix-icons:update'
    },
    {
        step: 4,
        title: 'Payment',
        description: 'Add any payment information you have',
        icon: 'radix-icons:sketch-logo'
    },
    {
        step: 5,
        title: 'Checkout',
        description: 'Confirm your order',
        icon: 'radix-icons:check'
    }
];

export const Default: Story = {
    render: () => ({
        props: {
            steps: steps
        },
        template: `
            <div rdxStepperRoot [value]="2" class="StepperList">
                @for (item of steps; track $index) {
                    <div rdxStepperItem [step]="item.step" class="StepperItem">
                        @if (item.step !== steps[steps.length - 1].step) {
                            <div rdxStepperSeparator class="StepperSeparator"></div>
                        }
                        <button rdxStepperTrigger class="StepperTrigger">
                            <div rdxStepperIndicator class="StepperIndicator">{{$index+1}}</div>
                        </button>
                        <div class="StepperItemText">
                            <h4 class="StepperTitle">
                               {{ item.title }}
                            </h4>
                            <p class="StepperDescription">
                               {{ item.description }}
                            </p>
                        </div>
                    </div>
                }
            </div>
        `
    })
};

export const Vertical: Story = {
    render: () => ({
        props: {
            steps: steps
        },
        template: `
            <div rdxStepperRoot [value]="2" orientation="vertical" class="StepperList">
                @for (item of steps; track $index) {
                    <div rdxStepperItem [step]="item.step" class="StepperItem">
                        @if (item.step !== steps[steps.length - 1].step) {
                            <div rdxStepperSeparator class="StepperSeparator"></div>
                        }
                        <button rdxStepperTrigger class="StepperTrigger">
                            <div rdxStepperIndicator class="StepperIndicator">{{$index+1}}</div>
                        </button>
                        <div class="StepperItemText" data-orientation='vertical'>
                            <h4 class="StepperTitle">
                               {{ item.title }}
                            </h4>
                            <p class="StepperDescription">
                               {{ item.description }}
                            </p>
                        </div>
                    </div>
                }
            </div>
        `
    })
};

export const Navigation: Story = {
    render: () => ({
        props: {
            steps: [1, 2, 3, 4]
        },
        template: `
              <StepperNavigation />
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/stepper-description.directive.ts
```typescript
import { Directive } from '@angular/core';
import { injectStepperItemContext } from './stepper-item-context.token';

@Directive({
    selector: '[rdxStepperDescription]',
    host: {
        '[attr.id]': 'itemContext.descriptionId'
    }
})
export class RdxStepperDescriptionDirective {
    readonly itemContext = injectStepperItemContext();
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/stepper-indicator.directive.ts
```typescript
import { Directive } from '@angular/core';
import { injectStepperItemContext } from './stepper-item-context.token';

@Directive({
    selector: '[rdxStepperIndicator]',
    exportAs: 'rdxStepperIndicator'
})
export class RdxStepperIndicatorDirective {
    readonly itemContext = injectStepperItemContext();
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/stepper-item-context.token.ts
```typescript
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import { inject, InjectionToken, InputSignalWithTransform, Signal } from '@angular/core';
import { StepperState } from './types';

export interface StepperItemContext {
    titleId: string;
    descriptionId: string;
    step: InputSignalWithTransform<number, NumberInput>;
    disabled: InputSignalWithTransform<boolean, BooleanInput>;
    isFocusable: Signal<boolean>;
    itemState: Signal<StepperState>;
}

export const STEPPER_ITEM_CONTEXT = new InjectionToken<StepperItemContext>('StepperItemContext');

export function injectStepperItemContext(): StepperItemContext {
    return inject(STEPPER_ITEM_CONTEXT);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/stepper-item.directive.ts
```typescript
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import { booleanAttribute, computed, Directive, forwardRef, inject, input, numberAttribute } from '@angular/core';
import { _IdGenerator } from '@radix-ng/primitives/core';
import { STEPPER_ITEM_CONTEXT, StepperItemContext } from './stepper-item-context.token';
import { injectStepperRootContext } from './stepper-root-context.token';
import { StepperState } from './types';

@Directive({
    selector: '[rdxStepperItem]',
    providers: [
        {
            provide: STEPPER_ITEM_CONTEXT,
            useExisting: forwardRef(() => RdxStepperItemDirective)
        }
    ],
    host: {
        '[attr.aria-current]': 'itemState() === "active" ? true : undefined',

        '[attr.data-state]': 'itemState()',
        '[attr.disabled]': 'disabled() || !isFocusable() ? "" : undefined',
        '[attr.data-disabled]': 'disabled() || !isFocusable() ? "" : undefined',
        '[attr.data-orientation]': 'rootContext.orientation()'
    }
})
export class RdxStepperItemDirective implements StepperItemContext {
    protected readonly rootContext = injectStepperRootContext();

    /** @ignore */
    readonly titleId = inject(_IdGenerator).getId('rdx-stepper-item-title');

    /** @ignore */
    readonly descriptionId = inject(_IdGenerator).getId('rdx-stepper-item-description');

    readonly step = input<number, NumberInput>(NaN, { transform: numberAttribute });

    readonly disabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /** @ignore */
    readonly completed = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /** @ignore */
    readonly itemState = computed<StepperState>(() => {
        if (this.completed()) return 'completed';
        if (this.rootContext.value() === this.step()) return 'active';

        const step = this.step() ?? 1;
        if (this.rootContext.value()! > step) {
            return 'completed';
        }

        return 'inactive';
    });

    /** @ignore */
    readonly isFocusable = computed(() => {
        if (this.disabled()) return false;

        const step = this.step() ?? 1;
        if (this.rootContext.linear()) {
            return step <= this.rootContext.value()! || step === this.rootContext.value()! + 1;
        }

        return true;
    });
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/stepper-root-context.token.ts
```typescript
import { Direction } from '@angular/cdk/bidi';
import { BooleanInput } from '@angular/cdk/coercion';
import {
    inject,
    InjectionToken,
    InputSignal,
    InputSignalWithTransform,
    ModelSignal,
    WritableSignal
} from '@angular/core';

export interface StepperRootContext {
    value: ModelSignal<number | undefined>;
    orientation: InputSignal<'vertical' | 'horizontal'>;
    dir: InputSignal<Direction>;
    linear: InputSignalWithTransform<boolean, BooleanInput>;
    totalStepperItems: WritableSignal<HTMLElement[]>;
}

export const STEPPER_ROOT_CONTEXT = new InjectionToken<StepperRootContext>('StepperRootContext');

export function injectStepperRootContext(): StepperRootContext {
    return inject(STEPPER_ROOT_CONTEXT);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/stepper-root.directive.ts
```typescript
import { LiveAnnouncer } from '@angular/cdk/a11y';
import { Direction } from '@angular/cdk/bidi';
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import {
    booleanAttribute,
    computed,
    Directive,
    effect,
    forwardRef,
    inject,
    input,
    model,
    numberAttribute,
    output,
    signal
} from '@angular/core';
import { STEPPER_ROOT_CONTEXT, StepperRootContext } from './stepper-root-context.token';

@Directive({
    selector: '[rdxStepperRoot]',
    exportAs: 'rdxStepperRoot',
    providers: [
        {
            provide: STEPPER_ROOT_CONTEXT,
            useExisting: forwardRef(() => RdxStepperRootDirective)
        }
    ],
    host: {
        role: 'group',
        '[attr.aria-label]': '"progress"',
        '[attr.data-linear]': 'linear() ? "" : undefined',
        '[attr.data-orientation]': 'orientation()'
    }
})
export class RdxStepperRootDirective implements StepperRootContext {
    private readonly liveAnnouncer = inject(LiveAnnouncer);

    readonly defaultValue = input<number, NumberInput>(undefined, { transform: numberAttribute });

    readonly value = model<number | undefined>(this.defaultValue());

    readonly linear = input<boolean, BooleanInput>(true, { transform: booleanAttribute });

    readonly dir = input<Direction>('ltr');

    readonly orientation = input<'vertical' | 'horizontal'>('horizontal');

    /** @ignore */
    readonly totalStepperItemsArray = computed(() => Array.from(this.totalStepperItems()));

    readonly onValueChange = output<number>();

    /** @ignore */
    readonly isFirstStep = computed(() => this.value() === 1);

    /** @ignore */
    readonly isLastStep = computed(() => this.value() === this.totalStepperItemsArray().length);

    /** @ignore */
    readonly totalSteps = computed(() => this.totalStepperItems().length);

    /** @ignore */
    readonly isNextDisabled = computed<boolean>(() => {
        const item = this.nextStepperItem();
        return item ? item.hasAttribute('disabled') : true;
    });

    /** @ignore */
    readonly isPrevDisabled = computed<boolean>(() => {
        const item = this.prevStepperItem();
        return item ? item.hasAttribute('disabled') : true;
    });

    /** @ignore */
    readonly totalStepperItems = signal<HTMLElement[]>([]);

    private readonly nextStepperItem = signal<HTMLElement | null>(null);
    private readonly prevStepperItem = signal<HTMLElement | null>(null);

    constructor() {
        effect(() => {
            const items = this.totalStepperItemsArray();
            const currentValue = this.value();

            if (currentValue) {
                if (items.length && currentValue < items.length) {
                    this.nextStepperItem.set(items[currentValue]);
                } else {
                    this.nextStepperItem.set(null);
                }

                if (items.length && currentValue > 1) {
                    this.prevStepperItem.set(items[currentValue - 2]);
                } else {
                    this.prevStepperItem.set(null);
                }

                this.onValueChange.emit(currentValue);
                this.liveAnnouncer.announce(`Step ${currentValue} of ${items.length}`);
            }
        });
    }

    goToStep(step: number) {
        if (step > this.totalSteps()) {
            return;
        }

        if (step < 1) {
            return;
        }

        if (
            this.totalStepperItems().length &&
            !!this.totalStepperItemsArray()[step] &&
            this.totalStepperItemsArray()[step].hasAttribute('disabled')
        ) {
            return;
        }

        if (this.linear()) {
            const currentValue = this.value() ?? 1;
            if (step > currentValue + 1) {
                return;
            }
        }
        this.value.set(step);
        this.onValueChange.emit(step);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/stepper-separator.directive.ts
```typescript
import { Directive, effect, inject } from '@angular/core';
import { RdxSeparatorRootDirective } from '@radix-ng/primitives/separator';
import { injectStepperItemContext } from './stepper-item-context.token';
import { injectStepperRootContext } from './stepper-root-context.token';

@Directive({
    selector: '[rdxStepperSeparator]',
    hostDirectives: [{ directive: RdxSeparatorRootDirective, inputs: ['orientation', 'decorative'] }],
    host: {
        '[attr.data-state]': 'itemContext.itemState()'
    }
})
export class RdxStepperSeparatorDirective {
    protected readonly rootContext = injectStepperRootContext();
    protected readonly itemContext = injectStepperItemContext();

    private readonly rdxSeparator = inject(RdxSeparatorRootDirective, { host: true });

    constructor() {
        effect(() => {
            this.rdxSeparator.updateDecorative(true);
            this.rdxSeparator.updateOrientation(this.rootContext.orientation());
        });
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/stepper-title.directive.ts
```typescript
import { Directive } from '@angular/core';
import { injectStepperItemContext } from './stepper-item-context.token';

@Directive({
    selector: '[rdxStepperTitle]',
    host: {
        '[attr.id]': 'itemContext.titleId'
    }
})
export class RdxStepperTitleDirective {
    readonly itemContext = injectStepperItemContext();
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/stepper-trigger.directive.ts
```typescript
import { computed, Directive, ElementRef, inject, OnDestroy, OnInit } from '@angular/core';
import * as kbd from '@radix-ng/primitives/core';
import { injectStepperItemContext } from './stepper-item-context.token';
import { injectStepperRootContext } from './stepper-root-context.token';
import { getActiveElement } from './utils/getActiveElement';
import { useArrowNavigation } from './utils/useArrowNavigation';

// as button
@Directive({
    selector: 'button[rdxStepperTrigger]',
    host: {
        '[attr.tabindex]': 'itemContext.isFocusable() ? 0 : -1',
        '[attr.aria-describedby]': 'itemContext.descriptionId',
        '[attr.aria-labelledby]': 'itemContext.titleId',

        '[attr.data-state]': 'itemContext.itemState()',
        '[attr.data-orientation]': 'rootContext.orientation()',
        '[attr.disabled]': 'itemContext.disabled() || !itemContext.isFocusable() ? "" : undefined',
        '[attr.data-disabled]': 'itemContext.disabled() || !itemContext.isFocusable() ? "" : undefined',

        '(mousedown)': 'handleMouseDown($event)',

        '(keydown.Enter)': 'handleKeyDown($event)',
        '(keydown.Space)': 'handleKeyDown($event)',
        '(keydown.ArrowLeft)': 'handleKeyDown($event)',
        '(keydown.ArrowRight)': 'handleKeyDown($event)',
        '(keydown.ArrowUp)': 'handleKeyDown($event)',
        '(keydown.ArrowDown)': 'handleKeyDown($event)'
    }
})
export class RdxStepperTriggerDirective implements OnInit, OnDestroy {
    protected readonly rootContext = injectStepperRootContext();
    protected readonly itemContext = injectStepperItemContext();

    private readonly elementRef = inject(ElementRef);

    readonly stepperItems = computed(() => Array.from(this.rootContext.totalStepperItems()));

    ngOnInit() {
        const current = this.rootContext.totalStepperItems();
        this.rootContext.totalStepperItems.set([...current, this.elementRef.nativeElement]);
    }

    ngOnDestroy() {
        const current = this.rootContext.totalStepperItems();
        const updated = current.filter((el: HTMLElement) => el !== this.elementRef.nativeElement);

        this.rootContext.totalStepperItems.set(updated);
    }

    handleMouseDown(event: MouseEvent) {
        if (this.itemContext.disabled()) {
            return;
        }

        // handler only left mouse click
        if (event.button !== 0) {
            return;
        }

        if (this.rootContext.linear()) {
            if (
                this.itemContext.step() <= this.rootContext.value()! ||
                this.itemContext.step() === this.rootContext.value()! + 1
            ) {
                if (!event.ctrlKey) {
                    this.rootContext.value.set(this.itemContext.step());
                    return;
                }
            }
        } else {
            if (!event.ctrlKey) {
                this.rootContext.value.set(this.itemContext.step());
                return;
            }
        }

        // prevent focus to avoid accidental activation
        event.preventDefault();
    }

    handleKeyDown(event: KeyboardEvent) {
        event.preventDefault();

        if (this.itemContext.disabled()) {
            return;
        }

        if ((event.key === kbd.ENTER || event.key === kbd.SPACE) && !event.ctrlKey && !event.shiftKey)
            this.rootContext.value.set(this.itemContext.step());

        if ([kbd.ARROW_LEFT, kbd.ARROW_RIGHT, kbd.ARROW_UP, kbd.ARROW_DOWN].includes(event.key)) {
            useArrowNavigation(event, getActiveElement() as HTMLElement, undefined, {
                itemsArray: this.stepperItems() as HTMLElement[],
                focus: true,
                loop: false,
                arrowKeyOptions: this.rootContext.orientation(),
                dir: this.rootContext.dir()
            });
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/types.ts
```typescript
export type StepperState = 'completed' | 'active' | 'inactive';

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/utils/getActiveElement.ts
```typescript
export function getActiveElement(): Element | null {
    let activeElement = document.activeElement;
    if (activeElement == null) {
        return null;
    }

    while (
        activeElement != null &&
        activeElement.shadowRoot != null &&
        activeElement.shadowRoot.activeElement != null
    ) {
        activeElement = activeElement.shadowRoot.activeElement;
    }

    return activeElement;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/utils/useArrowNavigation.ts
```typescript
// made by https://reka-ui.com/

import { Direction } from '@angular/cdk/bidi';

type ArrowKeyOptions = 'horizontal' | 'vertical' | 'both';

interface ArrowNavigationOptions {
    /**
     * The arrow key options to allow navigation
     *
     * @defaultValue "both"
     */
    arrowKeyOptions?: ArrowKeyOptions;

    /**
     * The attribute name to find the collection items in the parent element.
     *
     * @defaultValue "data-reka-collection-item"
     */
    attributeName?: string;

    /**
     * The parent element where contains all the collection items, this will collect every item to be used when nav
     * It will be ignored if attributeName is provided
     *
     * @defaultValue []
     */
    itemsArray?: HTMLElement[];

    /**
     * Allow loop navigation. If false, it will stop at the first and last element
     *
     * @defaultValue true
     */
    loop?: boolean;

    /**
     * The orientation of the collection
     *
     * @defaultValue "ltr"
     */
    dir?: Direction;

    /**
     * Prevent the scroll when navigating. This happens when the direction of the
     * key matches the scroll direction of any ancestor scrollable elements.
     *
     * @defaultValue true
     */
    preventScroll?: boolean;

    /**
     * By default all currentElement would trigger navigation. If `true`, currentElement nodeName in the ignore list will return null
     *
     * @defaultValue false
     */
    enableIgnoredElement?: boolean;

    /**
     * Focus the element after navigation
     *
     * @defaultValue false
     */
    focus?: boolean;
}

const ignoredElement = ['INPUT', 'TEXTAREA'];

/**
 * Allow arrow navigation for every html element with data-reka-collection-item tag
 *
 * @param e               Keyboard event
 * @param currentElement  Event initiator element or any element that wants to handle the navigation
 * @param parentElement   Parent element where contains all the collection items, this will collect every item to be used when nav
 * @param options         further options
 * @returns               the navigated html element or null if none
 */
export function useArrowNavigation(
    e: KeyboardEvent,
    currentElement: HTMLElement,
    parentElement: HTMLElement | undefined,
    options: ArrowNavigationOptions = {}
): HTMLElement | null {
    if (!currentElement || (options.enableIgnoredElement && ignoredElement.includes(currentElement.nodeName)))
        return null;

    const {
        arrowKeyOptions = 'both',
        attributeName = '[data-reka-collection-item]',
        itemsArray = [],
        loop = true,
        dir = 'ltr',
        preventScroll = true,
        focus = false
    } = options;

    const [right, left, up, down, home, end] = [
        e.key === 'ArrowRight',
        e.key === 'ArrowLeft',
        e.key === 'ArrowUp',
        e.key === 'ArrowDown',
        e.key === 'Home',
        e.key === 'End'
    ];
    const goingVertical = up || down;
    const goingHorizontal = right || left;
    if (
        !home &&
        !end &&
        ((!goingVertical && !goingHorizontal) ||
            (arrowKeyOptions === 'vertical' && goingHorizontal) ||
            (arrowKeyOptions === 'horizontal' && goingVertical))
    ) {
        return null;
    }

    const allCollectionItems: HTMLElement[] = parentElement
        ? Array.from(parentElement.querySelectorAll(attributeName))
        : itemsArray;

    if (!allCollectionItems.length) return null;

    if (preventScroll) e.preventDefault();

    let item: HTMLElement | null = null;

    if (goingHorizontal || goingVertical) {
        const goForward = goingVertical ? down : dir === 'ltr' ? right : left;
        item = findNextFocusableElement(allCollectionItems, currentElement, {
            goForward,
            loop
        });
    } else if (home) {
        item = allCollectionItems.length ? allCollectionItems[0] : null;
    } else if (end) {
        item = allCollectionItems.length ? allCollectionItems[allCollectionItems.length - 1] : null;
    }

    if (focus) item?.focus();

    return item;
}

interface FindNextFocusableElementOptions {
    /**
     * Whether to search forwards or backwards.
     */
    goForward: boolean;
    /**
     * Whether to allow looping the search. If false, it will stop at the first/last element.
     *
     * @default true
     */
    loop?: boolean;
}

/**
 * Recursive function to find the next focusable element to avoid disabled elements
 *
 * @param elements Elements to navigate
 * @param currentElement Current active element
 * @param options
 * @returns next focusable element
 */
function findNextFocusableElement(
    elements: HTMLElement[],
    currentElement: HTMLElement,
    options: FindNextFocusableElementOptions,
    iterations = elements.length
): HTMLElement | null {
    if (--iterations === 0) return null;

    const index = elements.indexOf(currentElement);
    const newIndex = options.goForward ? index + 1 : index - 1;

    if (!options.loop && (newIndex < 0 || newIndex >= elements.length)) return null;

    const adjustedNewIndex = (newIndex + elements.length) % elements.length;
    const candidate = elements[adjustedNewIndex];
    if (!candidate) return null;

    const isDisabled = candidate.hasAttribute('disabled') && candidate.getAttribute('disabled') !== 'false';
    if (isDisabled) {
        return findNextFocusableElement(elements, candidate, options, iterations);
    }
    return candidate;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toggle-group/README.md
```
# @radix-ng/primitives/toggle-group

Secondary entry point of `@radix-ng/primitives/toggle-group`.

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toggle-group/index.ts
```typescript
export * from './src/toggle-group-item.directive';
export * from './src/toggle-group-item.token';
export * from './src/toggle-group-without-focus.directive';
export * from './src/toggle-group.directive';
export * from './src/toggle-group.token';

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toggle-group/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toggle-group/stories/toggle-group.docs.mdx
````
import { ArgTypes, Canvas, Markdown, Meta } from '@storybook/blocks';
import * as ToggleGroupDirectiveStories from './toggle-group.stories';
import { RdxToggleGroupDirective } from '../src/toggle-group.directive';
import { RdxToggleGroupItemDirective } from '../src/toggle-group-item.directive';

<Meta title="Primitives/Toggle Group" />

# Toggle Group

#### A set of two-\_state buttons that can be toggled on or off.

<Canvas sourceState="hidden" of={ToggleGroupDirectiveStories.Default} />

## Features

- âœ… Full keyboard navigation.
- âœ… Supports horizontal/vertical orientation.
- âœ… Support single and multiple pressed buttons.
- âœ… Can be controlled or uncontrolled.

## Import

Get started with importing the directives:

```typescript
import {
  RdxToggleGroupDirective,
  RdxToggleGroupItemDirective
} from '@radix-ng/primitives/toggle-group';
```

## Examples

```html
<div class="ToggleGroup" rdxToggleGroup value="center" aria-label="Text alignment">
  <button class="ToggleGroupItem" rdxToggleGroupItem value="left" aria-label="Left aligned">
    <lucide-icon name="align-left" size="16"></lucide-icon>
  </button>
  <button class="ToggleGroupItem" rdxToggleGroupItem value="center" aria-label="Center aligned">
    <lucide-icon name="align-center" size="16"></lucide-icon>
  </button>
  <button class="ToggleGroupItem" rdxToggleGroupItem value="right" aria-label="Right aligned">
    <lucide-icon name="align-right" size="16"></lucide-icon>
  </button>
</div>
```

## API Reference

### Root

`RdxToggleGroupDirective`

<ArgTypes of={RdxToggleGroupDirective} />

<Markdown>
  {`
  | Data Attribute | Value |
  | ----------- | --------- |
  | [data-orientation]       | "vertical" or "horizontal"   |
  `}
</Markdown>

### Item

`RdxToggleGroupItemDirective`

<ArgTypes of={RdxToggleGroupItemDirective} />

## Accessibility

Uses [roving tabindex](https://www.w3.org/TR/wai-aria-practices-1.2/examples/radio/radio.html) to manage focus movement among items.

### Keyboard Interactions

<Markdown>
  {`
  | Key | Description |
  | ----------- | --------- |
  | Tab         | Moves focus to either the pressed item or the first item in the group. |
  | Space       | Activates/deactivates the item.       |
  | Enter       | Activates/deactivates the item.  |
  | ArrowDown   |    Moves focus to the next item in the group. |
  | ArrowRight  | Moves focus to the next item in the group. |
  | ArrowUp     | Moves focus to the previous item in the group. |
  | ArrowLeft   | Moves focus to the previous item in the group.  |
  | Home        | Moves focus to the first item. |
  | End         | Moves focus to the last item.  |
  `}
</Markdown>

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toggle-group/stories/toggle-group.stories.ts
```typescript
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { AlignCenter, AlignLeft, AlignRight, LucideAngularModule } from 'lucide-angular';
import { RdxToggleGroupItemDirective } from '../src/toggle-group-item.directive';
import { RdxToggleGroupDirective } from '../src/toggle-group.directive';

const html = String.raw;

export default {
    title: 'Primitives/Toggle Group',
    decorators: [
        moduleMetadata({
            imports: [
                RdxToggleGroupDirective,
                RdxToggleGroupItemDirective,
                LucideAngularModule,
                LucideAngularModule.pick({ AlignRight, AlignLeft, AlignCenter })
            ]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div class="radix-themes light light-theme" data-radius="medium" data-scaling="100%">
                    ${story}

                    <style>
                        button {
                            all: unset;
                        }
                        .ToggleGroup {
                            display: inline-flex;
                            background-color: var(--mauve-6);
                            border-radius: 4px;
                            box-shadow: 0 2px 10px var(--black-a7);
                        }

                        .ToggleGroupItem {
                            background-color: white;
                            color: var(--mauve-11);
                            height: 35px;
                            width: 35px;
                            display: flex;
                            font-size: 15px;
                            line-height: 1;
                            align-items: center;
                            justify-content: center;
                            margin-left: 1px;
                        }
                        .ToggleGroupItem[disabled] {
                            cursor: not-allowed;
                            opacity: 0.5;
                        }
                        .ToggleGroupItem:first-child {
                            margin-left: 0;
                            border-top-left-radius: 4px;
                            border-bottom-left-radius: 4px;
                        }
                        .ToggleGroupItem:last-child {
                            border-top-right-radius: 4px;
                            border-bottom-right-radius: 4px;
                        }
                        .ToggleGroupItem:hover {
                            background-color: var(--violet-3);
                        }
                        .ToggleGroupItem[data-state='on'] {
                            background-color: var(--violet-5);
                            color: var(--violet-11);
                        }
                        .ToggleGroupItem:focus {
                            position: relative;
                            box-shadow: 0 0 0 2px black;
                        }
                    </style>
                </div>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: html`
            <div class="ToggleGroup" rdxToggleGroup value="center" aria-label="Text alignment">
                <button class="ToggleGroupItem" rdxToggleGroupItem value="left" aria-label="Left aligned">
                    <lucide-icon name="align-left" size="12"></lucide-icon>
                </button>
                <button class="ToggleGroupItem" rdxToggleGroupItem value="center" aria-label="Center aligned">
                    <lucide-icon name="align-center" size="12"></lucide-icon>
                </button>
                <button class="ToggleGroupItem" rdxToggleGroupItem value="right" aria-label="Right aligned">
                    <lucide-icon name="align-right" size="12"></lucide-icon>
                </button>
            </div>
        `
    })
};

export const Multiple: Story = {
    render: () => ({
        props: {
            selectedValues: ['left', 'center']
        },
        template: html`
            <div
                class="ToggleGroup"
                rdxToggleGroup
                type="multiple"
                [value]="selectedValues"
                aria-label="Text alignment"
            >
                <button class="ToggleGroupItem" rdxToggleGroupItem value="left" aria-label="Left aligned">
                    <lucide-icon name="align-left" size="12"></lucide-icon>
                </button>
                <button class="ToggleGroupItem" rdxToggleGroupItem value="center" aria-label="Center aligned">
                    <lucide-icon name="align-center" size="12"></lucide-icon>
                </button>
                <button class="ToggleGroupItem" rdxToggleGroupItem value="right" aria-label="Right aligned">
                    <lucide-icon name="align-right" size="12"></lucide-icon>
                </button>
            </div>
        `
    })
};

export const Disable: Story = {
    render: () => ({
        props: {
            selectedValues: ['center']
        },
        template: html`
            <div
                class="ToggleGroup"
                rdxToggleGroup
                type="multiple"
                [value]="selectedValues"
                aria-label="Text alignment"
            >
                <button class="ToggleGroupItem" disabled rdxToggleGroupItem value="left" aria-label="Left aligned">
                    <lucide-icon name="align-left" size="12"></lucide-icon>
                </button>
                <button class="ToggleGroupItem" rdxToggleGroupItem value="center" aria-label="Center aligned">
                    <lucide-icon name="align-center" size="12"></lucide-icon>
                </button>
                <button class="ToggleGroupItem" disabled rdxToggleGroupItem value="right" aria-label="Right aligned">
                    <lucide-icon name="align-right" size="12"></lucide-icon>
                </button>
            </div>
        `
    })
};

export const DisableGroup: Story = {
    render: () => ({
        template: html`
            <div class="ToggleGroup" rdxToggleGroup aria-label="Text alignment" disabled>
                <button class="ToggleGroupItem" rdxToggleGroupItem value="left" aria-label="Left aligned">
                    <lucide-icon name="align-left" size="12"></lucide-icon>
                </button>
                <button class="ToggleGroupItem" rdxToggleGroupItem value="center" aria-label="Center aligned">
                    <lucide-icon name="align-center" size="12"></lucide-icon>
                </button>
                <button class="ToggleGroupItem" rdxToggleGroupItem value="right" aria-label="Right aligned">
                    <lucide-icon name="align-right" size="12"></lucide-icon>
                </button>
            </div>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toggle-group/src/toggle-group-item.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { booleanAttribute, computed, Directive, effect, inject, input } from '@angular/core';
import { RdxRovingFocusItemDirective } from '@radix-ng/primitives/roving-focus';
import { RdxToggleDirective } from '@radix-ng/primitives/toggle';
import { RdxToggleGroupItemToken } from './toggle-group-item.token';
import { injectToggleGroup } from './toggle-group.token';

/**
 * @group Components
 */
@Directive({
    selector: '[rdxToggleGroupItem]',
    exportAs: 'rdxToggleGroupItem',
    providers: [{ provide: RdxToggleGroupItemToken, useExisting: RdxToggleGroupItemDirective }],
    hostDirectives: [
        {
            directive: RdxRovingFocusItemDirective,
            inputs: ['focusable', 'active', 'allowShiftKey']
        },
        {
            directive: RdxToggleDirective,
            inputs: ['pressed', 'disabled']
        }
    ],
    host: {
        '(click)': 'toggle()'
    }
})
export class RdxToggleGroupItemDirective {
    private readonly rdxToggleDirective = inject(RdxToggleDirective);

    private readonly rdxRovingFocusItemDirective = inject(RdxRovingFocusItemDirective);

    /**
     * Access the toggle group.
     * @ignore
     */
    protected readonly rootContext = injectToggleGroup();

    /**
     * The value of this toggle button.
     *
     * @group Props
     */
    readonly value = input.required<string>();

    /**
     * Whether this toggle button is disabled.
     * @defaultValue false
     * @group Props
     */
    readonly disabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    private readonly isPressed = computed(() => {
        return this.rootContext.type() === 'single'
            ? this.rootContext.value() === this.value()
            : this.rootContext.value()?.includes(this.value());
    });

    private readonly isDisabled = computed(() => this.rootContext.disabled() || this.disabled());

    constructor() {
        effect(() => {
            this.rdxToggleDirective.pressed.set(!!this.isPressed());
            this.rdxToggleDirective.disabledModel.set(this.isDisabled());

            this.rdxRovingFocusItemDirective.active = !!this.isPressed();
        });
    }

    /**
     * @ignore
     */
    toggle(): void {
        if (this.disabled()) {
            return;
        }

        this.rootContext.toggle(this.value());
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toggle-group/src/toggle-group-item.token.ts
```typescript
import { inject, InjectionToken } from '@angular/core';
import type { RdxToggleGroupItemDirective } from './toggle-group-item.directive';

export const RdxToggleGroupItemToken = new InjectionToken<RdxToggleGroupItemDirective>('RdxToggleGroupItemToken');

export function injectToggleGroupItem(): RdxToggleGroupItemDirective {
    return inject(RdxToggleGroupItemToken);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toggle-group/src/toggle-group-without-focus.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { booleanAttribute, Directive, input, model, output, signal } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { provideValueAccessor } from '@radix-ng/primitives/core';
import { RdxToggleGroupToken } from './toggle-group.token';

let nextId = 0;

@Directive({
    selector: '[rdxToggleGroupWithoutFocus]',
    exportAs: 'rdxToggleGroupWithoutFocus',
    providers: [
        { provide: RdxToggleGroupToken, useExisting: RdxToggleGroupWithoutFocusDirective },
        provideValueAccessor(RdxToggleGroupWithoutFocusDirective)],
    host: {
        role: 'group',
        '(focusout)': 'onTouched?.()'
    }
})
export class RdxToggleGroupWithoutFocusDirective implements ControlValueAccessor {
    /**
     * @ignore
     */
    readonly id: string = `rdx-toggle-group-${nextId++}`;

    /**
     * @group Props
     */
    readonly value = model<string | string[] | undefined>(undefined);

    /**
     * @group Props
     */
    readonly type = input<'single' | 'multiple'>('single');

    /**
     * Whether the toggle group is disabled.
     * @defaultValue false
     * @group Props
     */
    readonly disabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * Event emitted when the selected toggle button changes.
     * @group Emits
     */
    readonly onValueChange = output<string[] | string | undefined>();

    /**
     * The value change callback.
     */
    private onChange?: (value: string | string[] | undefined) => void;

    /**
     * onTouch function registered via registerOnTouch (ControlValueAccessor).
     */
    protected onTouched?: () => void;

    /**
     * Toggle a value.
     * @param value The value to toggle.
     * @ignore
     */
    toggle(value: string): void {
        if (this.disabled()) {
            return;
        }

        if (this.type() === 'single') {
            this.value.set(value);
        } else {
            this.value.set(
                ((currentValue) =>
                    currentValue && Array.isArray(currentValue)
                        ? currentValue.includes(value)
                            ? currentValue.filter((v) => v !== value) // delete
                            : [...currentValue, value] // update
                        : [value])(this.value())
            );
        }

        this.onValueChange.emit(this.value());
        this.onChange?.(this.value());
    }

    /**
     * Select a value from Angular forms.
     * @param value The value to select.
     * @ignore
     */
    writeValue(value: string): void {
        this.value.set(value);
    }

    /**
     * Register a callback to be called when the value changes.
     * @param fn The callback to register.
     * @ignore
     */
    registerOnChange(fn: (value: string | string[] | undefined) => void): void {
        this.onChange = fn;
    }

    /**
     * Register a callback to be called when the toggle group is touched.
     * @param fn The callback to register.
     * @ignore
     */
    registerOnTouched(fn: () => void): void {
        this.onTouched = fn;
    }

    private readonly accessorDisabled = signal(false);

    /**
     * Set the disabled state of the toggle group.
     * @param isDisabled Whether the toggle group is disabled.
     * @ignore
     */
    setDisabledState(isDisabled: boolean): void {
        this.accessorDisabled.set(isDisabled);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toggle-group/src/toggle-group.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { booleanAttribute, Directive, input, model, output, signal } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { provideToken, provideValueAccessor } from '@radix-ng/primitives/core';
import { RdxRovingFocusGroupDirective } from '@radix-ng/primitives/roving-focus';
import { RdxToggleGroupToken } from './toggle-group.token';

let nextId = 0;

/**
 * @group Components
 */
@Directive({
    selector: '[rdxToggleGroup]',
    exportAs: 'rdxToggleGroup',
    providers: [
        provideToken(RdxToggleGroupToken, RdxToggleGroupDirective),
        provideValueAccessor(RdxToggleGroupDirective)],
    hostDirectives: [{ directive: RdxRovingFocusGroupDirective, inputs: ['dir', 'orientation', 'loop'] }],
    host: {
        role: 'group',

        '(focusout)': 'onTouched?.()'
    }
})
export class RdxToggleGroupDirective implements ControlValueAccessor {
    /**
     * @ignore
     */
    readonly id: string = `rdx-toggle-group-${nextId++}`;

    /**
     * @group Props
     */
    readonly value = model<string | string[] | undefined>(undefined);

    /**
     * @group Props
     */
    readonly type = input<'single' | 'multiple'>('single');

    /**
     * Whether the toggle group is disabled.
     * @defaultValue false
     * @group Props
     */
    readonly disabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * Event emitted when the selected toggle button changes.
     * @group Emits
     */
    readonly onValueChange = output<string[] | string | undefined>();

    /**
     * The value change callback.
     */
    private onChange?: (value: string | string[] | undefined) => void;

    /**
     * onTouch function registered via registerOnTouch (ControlValueAccessor).
     */
    protected onTouched?: () => void;

    /**
     * Toggle a value.
     * @param value The value to toggle.
     * @ignore
     */
    toggle(value: string): void {
        if (this.disabled()) {
            return;
        }

        if (this.type() === 'single') {
            this.value.set(value);
        } else {
            this.value.set(
                ((currentValue) =>
                    currentValue && Array.isArray(currentValue)
                        ? currentValue.includes(value)
                            ? currentValue.filter((v) => v !== value) // delete
                            : [...currentValue, value] // update
                        : [value])(this.value())
            );
        }

        this.onValueChange.emit(this.value());
        this.onChange?.(this.value());
    }

    /**
     * Select a value from Angular forms.
     * @param value The value to select.
     * @ignore
     */
    writeValue(value: string): void {
        this.value.set(value);
    }

    /**
     * Register a callback to be called when the value changes.
     * @param fn The callback to register.
     * @ignore
     */
    registerOnChange(fn: (value: string | string[] | undefined) => void): void {
        this.onChange = fn;
    }

    /**
     * Register a callback to be called when the toggle group is touched.
     * @param fn The callback to register.
     * @ignore
     */
    registerOnTouched(fn: () => void): void {
        this.onTouched = fn;
    }

    private readonly accessorDisabled = signal(false);
    /**
     * Set the disabled state of the toggle group.
     * @param isDisabled Whether the toggle group is disabled.
     * @ignore
     */
    setDisabledState(isDisabled: boolean): void {
        this.accessorDisabled.set(isDisabled);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toggle-group/src/toggle-group.token.ts
```typescript
import { inject, InjectionToken } from '@angular/core';

export interface IRdxToggleGroup {
    toggle(value: string): void;
    disabled: any;
    value: any;
    type: any;
}

export const RdxToggleGroupToken = new InjectionToken<IRdxToggleGroup>('RdxToggleGroupToken');

export function injectToggleGroup(): IRdxToggleGroup {
    return inject(RdxToggleGroupToken);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/context-menu/README.md
```
# @radix-ng/primitives/context-menu

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/context-menu/index.ts
```typescript
import { NgModule } from '@angular/core';
import { RdxContextMenuContentDirective } from './src/context-menu-content.directive';
import { RdxContextMenuItemCheckboxDirective } from './src/context-menu-item-checkbox.directive';
import { RdxContextMenuItemIndicatorDirective } from './src/context-menu-item-indicator.directive';
import { RdxContextMenuItemRadioGroupDirective } from './src/context-menu-item-radio-group.directive';
import { RdxContextMenuItemRadioDirective } from './src/context-menu-item-radio.directive';
import { RdxContextMenuSelectable } from './src/context-menu-item-selectable';
import { RdxContextMenuItemDirective } from './src/context-menu-item.directive';
import { RdxContextMenuLabelDirective } from './src/context-menu-label.directive';
import { RdxContextMenuSeparatorDirective } from './src/context-menu-separator.directive';
import { RdxContextMenuTriggerDirective } from './src/context-menu-trigger.directive';

export * from './src/context-menu-content.directive';
export * from './src/context-menu-item-checkbox.directive';
export * from './src/context-menu-item-indicator.directive';
export * from './src/context-menu-item-radio-group.directive';
export * from './src/context-menu-item-radio.directive';
export * from './src/context-menu-item-selectable';
export * from './src/context-menu-item.directive';
export * from './src/context-menu-label.directive';
export * from './src/context-menu-separator.directive';
export * from './src/context-menu-trigger.directive';

const _imports = [
    RdxContextMenuContentDirective,
    RdxContextMenuSelectable,
    RdxContextMenuItemCheckboxDirective,
    RdxContextMenuItemDirective,
    RdxContextMenuItemRadioGroupDirective,
    RdxContextMenuItemIndicatorDirective,
    RdxContextMenuItemRadioDirective,
    RdxContextMenuLabelDirective,
    RdxContextMenuSeparatorDirective,
    RdxContextMenuTriggerDirective
];

@NgModule({
    imports: [..._imports],
    exports: [..._imports]
})
export class RdxContextMenuModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/context-menu/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/context-menu/stories/context-menu.docs.mdx
```
import { Canvas, Meta } from '@storybook/blocks';
import * as ContextMenuStories from './context-menu.stories';

<Meta title="Primitives/Context Menu" />

# Context Menu

#### Displays a menu to the userâ€”such as a set of actions or functionsâ€”triggered by a button.

<Canvas sourceState="hidden" of={ContextMenuStories.Default} height="300px" />

## Features

- âœ… Supports submenus with configurable reading direction.
- âœ… Supports items, labels, groups of items.
- âœ… Supports checkable items (single or multiple) with optional indeterminate state.
- âœ… Supports modal and non-modal modes.
- âœ… Customize side, alignment, offsets, collision handling.
- âœ… Focus is fully managed.
- âœ… Full keyboard navigation.
- âœ… Typeahead support.
- âœ… Dismissing and layering behavior is highly customizable.
- âœ… Triggers with a long press on touch devices

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/context-menu/stories/context-menu.stories.ts
```typescript
import {
    RdxDropdownMenuContentDirective,
    RdxDropdownMenuItemDirective,
    RdxDropdownMenuTriggerDirective
} from '@radix-ng/primitives/dropdown-menu';
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { Check, Dot, LucideAngularModule, Menu } from 'lucide-angular';

import { RdxContextMenuContentDirective } from '../src/context-menu-content.directive';
import { RdxContextMenuItemCheckboxDirective } from '../src/context-menu-item-checkbox.directive';
import { RdxContextMenuItemIndicatorDirective } from '../src/context-menu-item-indicator.directive';
import { RdxContextMenuItemRadioGroupDirective } from '../src/context-menu-item-radio-group.directive';
import { RdxContextMenuItemRadioDirective } from '../src/context-menu-item-radio.directive';
import { RdxContextMenuItemDirective } from '../src/context-menu-item.directive';
import { RdxContextMenuSeparatorDirective } from '../src/context-menu-separator.directive';
import { RdxContextMenuTriggerDirective } from '../src/context-menu-trigger.directive';

export default {
    title: 'Primitives/Context Menu',
    decorators: [
        moduleMetadata({
            imports: [
                RdxContextMenuTriggerDirective,
                RdxDropdownMenuTriggerDirective,
                RdxContextMenuItemDirective,
                RdxDropdownMenuItemDirective,
                RdxContextMenuItemCheckboxDirective,
                RdxContextMenuItemRadioDirective,
                RdxContextMenuItemRadioGroupDirective,
                RdxContextMenuItemIndicatorDirective,
                RdxContextMenuSeparatorDirective,
                RdxContextMenuContentDirective,
                RdxDropdownMenuContentDirective,
                LucideAngularModule,
                LucideAngularModule.pick({ Menu, Check, Dot })
            ]
        }),
        componentWrapperDecorator(
            (story) => `
                <div class="radix-themes light light-theme radix-themes-default-fonts rt-Flex rt-r-ai-start rt-r-jc-center rt-r-position-relative"
                    data-accent-color="indigo"
                    data-radius="medium"
                    data-scaling="100%"
                >
                    ${story}
                </div>`
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: `
<div class="context-menu-trigger"
    [rdxContextMenuTrigger]="menu">
    Right click here
</div>

<ng-template #menu>
  <div class="ContextMenuContent" rdxContextMenuContent>
    <button class="ContextMenuItem" rdxContextMenuItem>
        Back <div class="RightSlot">âŒ˜ + [</div>
    </button>
    <button class="ContextMenuItem" rdxContextMenuItem disabled>
        Forward <div class="RightSlot">âŒ˜ + ]</div>
    </button>
    <button class="ContextMenuItem" rdxContextMenuItem>
        Reload <div class="RightSlot">âŒ˜ + R</div>
    </button>
    <button
        class="ContextMenuItem"
        rdxContextMenuItem
        [rdxDropdownMenuTrigger]="share"
        [side]="'right'"
    >
        More Tools <div class="RightSlot">></div>
    </button>

    <div rdxContextMenuSeparator class="ContextMenuSeparator"></div>

    <button class="ContextMenuItem" rdxContextMenuItemCheckbox [checked]="true">
        <div class="ContextMenuItemIndicator" rdxContextMenuItemIndicator>
            <lucide-icon size="16" name="check"></lucide-icon>
        </div>
        Show Bookmarks <div class="RightSlot">âŒ˜ + B</div>
    </button>
    <button class="ContextMenuItem" rdxContextMenuItemCheckbox>
        <div class="ContextMenuItemIndicator" rdxContextMenuItemIndicator>
            <lucide-icon size="16" name="check"></lucide-icon>
        </div>
        Show Full URLs
    </button>

    <div rdxContextMenuSeparator class="ContextMenuSeparator"></div>

    <div class="ContextMenuLabel" rdxContextMenuLabel>People</div>
    <div class="ContextMenuItemRadioGroup" rdxContextMenuItemRadioGroup [value]="'1'">
        <button class="ContextMenuItem" rdxContextMenuItemRadio [value]="'1'">
            <div class="ContextMenuItemIndicator" rdxContextMenuItemIndicator>
                <lucide-icon size="16" name="dot" strokeWidth="8"></lucide-icon>
            </div>
            Pedro Duarte
        </button>
        <button class="ContextMenuItem" rdxContextMenuItemRadio [value]="'2'">
            <div class="ContextMenuItemIndicator" rdxContextMenuItemIndicator>
                <lucide-icon size="16" name="dot" strokeWidth="8"></lucide-icon>
            </div>
            Colm Tuite
        </button>
    </div>
  </div>
</ng-template>

<ng-template #share>
  <div class="DropdownMenuContent" rdxDropdownMenuContent>
    <button class="DropdownMenuItem" rdxDropdownMenuItem>Undo</button>
    <button class="DropdownMenuItem" rdxDropdownMenuItem>Redo</button>
    <div rdxDropdownMenuSeparator class="DropdownMenuSeparator"></div>
    <button class="DropdownMenuItem" rdxDropdownMenuItem>Cut</button>
    <button class="DropdownMenuItem" rdxDropdownMenuItem>Copy</button>
    <button class="DropdownMenuItem" rdxDropdownMenuItem>Paste</button>
  </div>
</ng-template>

<style>
    .context-menu-trigger {
        display: block;
        border: 2px dashed #fff;
        color: #fff;
        border-radius: 4px;
        font-size: 15px;
        -webkit-user-select: none;
        user-select: none;
        padding: 45px 0;
        width: 300px;
        text-align: center;

      &:focus: {
        outline: none;
        box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.5);
      },

        &[data-state="open"]: {
            background-color: lightblue;
            /*display: flex;*/
            /*align-items: center;*/
            /*justify-content: center;*/
            /*width: 200vw;*/
            /*height: 200vh;*/
            /*gap: 20;*/
        }
    }
/* reset */
button {
  all: unset;
}

.ContextMenuContent,
.DropdownMenuContent {
  flex-direction: column;
  display: inline-flex;
  min-width: 220px;
  background-color: white;
  border-radius: 6px;
  padding: 5px;
  box-shadow: 0 10px 38px -10px rgba(22, 23, 24, 0.35), 0 10px 20px -15px rgba(22, 23, 24, 0.2);
  will-change: transform, opacity;
}

.ContextMenuItem,
.DropdownMenuItem,
.ContextMenuCheckboxItem,
.ContextMenuRadioItem {
  font-size: 13px;
  line-height: 1;
  color: var(--violet-11);
  border-radius: 3px;
  display: flex;
  align-items: center;
  height: 25px;
  position: relative;
  padding: 0 5px 0 25px;
  user-select: none;
  outline: none;
}

.ContextMenuItem[data-disabled],
.DropdownMenuItem[data-disabled],
.ContextMenuCheckboxItem[data-disabled],
.ContextMenuRadioItem[data-disabled] {
  color: var(--mauve-8);
  pointer-events: none;
}
.ContextMenuItem[data-highlighted],
.DropdownMenuItem[data-highlighted],
.ContextMenuCheckboxItem[data-highlighted],
.ContextMenuRadioItem[data-highlighted] {
  background-color: var(--violet-9);
  color: var(--violet-1);
}

.DropdownMenuSeparator,
.ContextMenuSeparator {
  height: 1px;
  background-color: var(--violet-6);
  margin: 5px;
}

.ContextMenuLabel {
  padding-left: 25px;
  font-size: 12px;
  line-height: 25px;
  color: var(--mauve-11);
}

.ContextMenuItemIndicator {
  position: absolute;
  left: 4px;
  width: 25px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.ContextMenuItemRadioGroup {
  display: flex;
  flex-direction: column;
}

.IconButton:hover {
  background-color: var(--violet-3);
}

.IconButton:focus {
  box-shadow: 0 0 0 2px black;
}

.RightSlot {
  margin-left: auto;
  padding-left: 20px;
  color: var(--mauve-9);
  display: flex;
  flex-direction: row;
  flex: 1;
  justify-content: flex-end;
}

</style>
`
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/context-menu/src/context-menu-content.directive.ts
```typescript
import { CdkMenu, CdkMenuItem } from '@angular/cdk/menu';
import { Directive, inject, Input } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { pairwise, startWith, Subject } from 'rxjs';
import { RdxContextMenuItemDirective } from './context-menu-item.directive';
import { RdxContextMenuTriggerDirective } from './context-menu-trigger.directive';

@Directive({
    selector: '[rdxContextMenuContent]',
    standalone: true,
    host: {
        '[attr.role]': "'menu'",
        '[attr.data-state]': "menuTrigger.isOpen() ? 'open': 'closed'",
        '[attr.data-orientation]': 'orientation'
    },
    providers: [
        {
            provide: CdkMenu,
            useExisting: RdxContextMenuContentDirective
        }
    ]
})
export class RdxContextMenuContentDirective extends CdkMenu {
    readonly highlighted = new Subject<RdxContextMenuItemDirective>();
    readonly menuTrigger = inject(RdxContextMenuTriggerDirective, { optional: true });

    @Input() onEscapeKeyDown: (event?: Event) => void = () => undefined;
    @Input() closeOnEscape = true;

    constructor() {
        super();

        this.highlighted.pipe(startWith(null), pairwise(), takeUntilDestroyed()).subscribe(([prev, item]) => {
            if (prev) {
                prev.highlighted = false;
            }

            if (item) {
                item.highlighted = true;
            }
        });
    }

    updateActiveItem(item: CdkMenuItem) {
        this.keyManager.updateActiveItem(item);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/context-menu/src/context-menu-item-checkbox.directive.ts
```typescript
import { CDK_MENU, CdkMenuItem } from '@angular/cdk/menu';
import { Directive } from '@angular/core';
import { RdxContextMenuContentDirective } from './context-menu-content.directive';
import { RdxContextMenuSelectable } from './context-menu-item-selectable';
import { RdxContextMenuItemDirective } from './context-menu-item.directive';

@Directive({
    selector: '[rdxContextMenuItemCheckbox]',
    standalone: true,
    host: {
        role: 'menuitemcheckbox'
    },
    providers: [
        { provide: RdxContextMenuSelectable, useExisting: RdxContextMenuItemCheckboxDirective },
        { provide: RdxContextMenuItemDirective, useExisting: RdxContextMenuSelectable },
        { provide: CdkMenuItem, useExisting: RdxContextMenuItemDirective },
        { provide: CDK_MENU, useExisting: RdxContextMenuContentDirective }
    ]
})
export class RdxContextMenuItemCheckboxDirective extends RdxContextMenuSelectable {
    override trigger(options?: { keepOpen: boolean }) {
        if (!this.disabled) {
            this.checked = !this.checked;

            this.checkedChange.emit(this.checked);
        }

        super.trigger(options);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/context-menu/src/context-menu-item-indicator.directive.ts
```typescript
import { Directive, inject } from '@angular/core';
import { RdxContextMenuSelectable } from './context-menu-item-selectable';

@Directive({
    selector: '[rdxContextMenuItemIndicator]',
    standalone: true,
    host: {
        '[style.display]': "item.checked ? 'block' : 'none'",
        '[attr.data-state]': "item.checked ? 'checked' : 'unchecked'"
    }
})
export class RdxContextMenuItemIndicatorDirective {
    item = inject(RdxContextMenuSelectable);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/context-menu/src/context-menu-item-radio-group.directive.ts
```typescript
import { UniqueSelectionDispatcher } from '@angular/cdk/collections';
import { AfterContentInit, Directive, EventEmitter, inject, Input, Output } from '@angular/core';

@Directive({
    selector: '[rdxContextMenuItemRadioGroup]',
    standalone: true,
    host: {
        role: 'group'
    },
    providers: [{ provide: UniqueSelectionDispatcher, useClass: UniqueSelectionDispatcher }]
})
export class RdxContextMenuItemRadioGroupDirective<T> implements AfterContentInit {
    private readonly selectionDispatcher = inject(UniqueSelectionDispatcher);

    @Input()
    set value(value: T | null) {
        this._value = value;
    }

    get value(): T | null {
        return this._value;
    }

    private _value: T | null = null;

    @Output() readonly valueChange = new EventEmitter();

    ngAfterContentInit(): void {
        this.selectionDispatcher.notify(this.value as string, '');
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/context-menu/src/context-menu-item-radio.directive.ts
```typescript
import { UniqueSelectionDispatcher } from '@angular/cdk/collections';
import { CDK_MENU, CdkMenuItem } from '@angular/cdk/menu';
import { AfterContentInit, Directive, inject, Input, OnDestroy } from '@angular/core';
import { RdxContextMenuContentDirective } from './context-menu-content.directive';
import { RdxContextMenuItemRadioGroupDirective } from './context-menu-item-radio-group.directive';
import { RdxContextMenuSelectable } from './context-menu-item-selectable';
import { RdxContextMenuItemDirective } from './context-menu-item.directive';

/** Counter used to set a unique id and name for a selectable item */
let nextId = 0;

@Directive({
    selector: '[rdxContextMenuItemRadio]',
    standalone: true,
    host: {
        role: 'menuitemradio'
    },
    providers: [
        { provide: RdxContextMenuSelectable, useExisting: RdxContextMenuItemRadioDirective },
        { provide: RdxContextMenuItemDirective, useExisting: RdxContextMenuSelectable },
        { provide: CdkMenuItem, useExisting: RdxContextMenuItemDirective },
        { provide: CDK_MENU, useExisting: RdxContextMenuContentDirective }
    ]
})
export class RdxContextMenuItemRadioDirective extends RdxContextMenuSelectable implements AfterContentInit, OnDestroy {
    /** The unique selection dispatcher for this radio's `RdxContextMenuItemRadioGroupDirective`. */
    private readonly selectionDispatcher = inject(UniqueSelectionDispatcher);

    private readonly group = inject(RdxContextMenuItemRadioGroupDirective);

    @Input()
    get value() {
        return this._value || this.id;
    }

    set value(value: string) {
        this._value = value;
    }

    private _value: string | undefined;

    /** An ID to identify this radio item to the `UniqueSelectionDispatcher`. */
    private id = `${nextId++}`;

    private removeDispatcherListener!: () => void;

    constructor() {
        super();

        this.triggered.subscribe(() => {
            if (!this.disabled) {
                this.selectionDispatcher.notify(this.value, '');

                this.group.valueChange.emit(this.value);
            }
        });
    }

    ngAfterContentInit() {
        this.removeDispatcherListener = this.selectionDispatcher.listen((id: string) => {
            this.checked = this.value === id;
        });
    }

    override ngOnDestroy() {
        super.ngOnDestroy();
        this.removeDispatcherListener();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/context-menu/src/context-menu-item-selectable.ts
```typescript
import { booleanAttribute, Directive, EventEmitter, Input, Output } from '@angular/core';
import { RdxContextMenuItemDirective } from './context-menu-item.directive';

/** Base class providing checked state for selectable ContextMenuItems. */
@Directive({
    standalone: true,
    host: {
        '[attr.aria-checked]': '!!checked',
        '[attr.aria-disabled]': 'disabled || null',
        '[attr.data-state]': 'checked ? "checked" : "unchecked"'
    }
})
export class RdxContextMenuSelectable extends RdxContextMenuItemDirective {
    /** Whether the element is checked */
    @Input({ transform: booleanAttribute }) checked = false;

    @Output() readonly checkedChange = new EventEmitter<boolean>();
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/context-menu/src/context-menu-item.directive.ts
```typescript
import { CDK_MENU, CdkMenuItem } from '@angular/cdk/menu';
import { booleanAttribute, Directive, ElementRef, EventEmitter, inject, Input, Output } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';

import { RdxContextMenuContentDirective } from './context-menu-content.directive';

@Directive({
    selector: '[rdxContextMenuItem]',
    standalone: true,
    host: {
        type: 'button',
        '[attr.data-orientation]': '"vertical"',
        '[attr.data-highlighted]': 'highlighted ? "" : null',
        '[attr.data-disabled]': 'disabled ? "" : null',
        '[attr.disabled]': 'disabled ? "" : null',
        '(pointermove)': 'onPointerMove()',
        '(focus)': 'menu.highlighted.next(this)',
        '(keydown)': 'onKeydown($event)'
    },
    providers: [
        { provide: CdkMenuItem, useExisting: RdxContextMenuItemDirective },
        { provide: CDK_MENU, useExisting: RdxContextMenuContentDirective }
    ]
})
export class RdxContextMenuItemDirective extends CdkMenuItem {
    protected readonly menu = inject(RdxContextMenuContentDirective);
    protected readonly nativeElement = inject(ElementRef).nativeElement;

    highlighted = false;

    @Input({ transform: booleanAttribute }) override disabled = false;

    @Output() readonly onSelect = new EventEmitter<void>();

    constructor() {
        super();

        this.menu.highlighted.pipe(takeUntilDestroyed()).subscribe((value) => {
            if (value !== this) {
                this.highlighted = false;
            }
        });

        this.triggered.subscribe(this.onSelect);
    }

    protected onPointerMove() {
        this.nativeElement.focus({ preventScroll: true });
        this.menu.updateActiveItem(this);
    }

    protected onKeydown(event: KeyboardEvent) {
        if (this.nativeElement.tagName !== 'BUTTON' && ['Enter', ' '].includes(event.key)) {
            event.preventDefault();
        }

        if (event.key === 'Escape') {
            if (!this.menu.closeOnEscape) {
                event.stopPropagation();
            } else {
                this.menu.onEscapeKeyDown(event);
            }
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/context-menu/src/context-menu-label.directive.ts
```typescript
import { Directive } from '@angular/core';

@Directive({
    selector: '[rdxContextMenuLabel]',
    standalone: true
})
export class RdxContextMenuLabelDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/context-menu/src/context-menu-separator.directive.ts
```typescript
import { Directive } from '@angular/core';
import { RdxSeparatorRootDirective } from '@radix-ng/primitives/separator';

@Directive({
    selector: '[rdxContextMenuSeparator]',
    standalone: true,
    hostDirectives: [RdxSeparatorRootDirective],
    host: {
        role: 'separator',
        '[attr.aria-orientation]': "'horizontal'"
    }
})
export class RdxContextMenuSeparatorDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/context-menu/src/context-menu-trigger.directive.ts
```typescript
import { CdkContextMenuTrigger, MENU_STACK, MENU_TRIGGER, MenuStack } from '@angular/cdk/menu';
import { ConnectedPosition } from '@angular/cdk/overlay';
import { booleanAttribute, Directive, Input, numberAttribute, TemplateRef } from '@angular/core';
import { outputFromObservable } from '@angular/core/rxjs-interop';

export enum ContextMenuSide {
    Top = 'top',
    Right = 'right',
    Bottom = 'bottom',
    Left = 'left'
}

const ContextMenuPositions: Record<ContextMenuSide, ConnectedPosition> = {
    top: {
        originX: 'start',
        originY: 'top',
        overlayX: 'start',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: 0
    },
    right: {
        originX: 'end',
        originY: 'top',
        overlayX: 'start',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 0
    },
    bottom: {
        originX: 'start',
        originY: 'bottom',
        overlayX: 'start',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 0
    },
    left: {
        originX: 'start',
        originY: 'top',
        overlayX: 'end',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 0
    }
};

@Directive({
    selector: '[rdxContextMenuTrigger]',
    standalone: true,
    host: {
        '[attr.data-state]': "isOpen() ? 'open': 'closed'",
        '[attr.data-disabled]': "disabled ? '' : null",

        '(contextmenu)': '_openOnContextMenu($event)'
    },
    providers: [
        { provide: MENU_TRIGGER, useExisting: RdxContextMenuTriggerDirective },
        { provide: MENU_STACK, useClass: MenuStack }
    ]
})
export class RdxContextMenuTriggerDirective extends CdkContextMenuTrigger {
    override menuPosition = [{ ...ContextMenuPositions[ContextMenuSide.Bottom] }];

    @Input()
    set rdxContextMenuTrigger(value: TemplateRef<unknown> | null) {
        this.menuTemplateRef = value;
    }

    @Input({ transform: numberAttribute })
    set alignOffset(value: number) {
        this.defaultPosition.offsetX = value;
    }

    @Input({ transform: booleanAttribute }) override disabled = false;

    onOpenChange = outputFromObservable(this.opened);

    get defaultPosition(): ConnectedPosition {
        return this.menuPosition[0];
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toggle/README.md
```
# @radix-ng/primitives/toggle

Secondary entry point of `@radix-ng/primitives/toggle`.

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toggle/index.ts
```typescript
export * from './src/toggle-visually-hidden-input.directive';
export * from './src/toggle.directive';

export type { DataState, ToggleProps } from './src/toggle.directive';

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toggle/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toggle/stories/toggle-forms.component.ts
```typescript
import { Component, OnInit } from '@angular/core';
import { FormControl, FormGroup, ReactiveFormsModule } from '@angular/forms';
import { RdxToggleVisuallyHiddenInputDirective } from '../src/toggle-visually-hidden-input.directive';
import { RdxToggleDirective } from '../src/toggle.directive';

@Component({
    selector: 'toggle-reactive-forms',
    imports: [ReactiveFormsModule, RdxToggleDirective, RdxToggleVisuallyHiddenInputDirective],
    styleUrl: 'toggle.styles.css',
    template: `
        <form [formGroup]="formGroup" (ngSubmit)="onSubmit()">
            <button class="Toggle" #toggle="rdxToggle" formControlName="pressed" rdxToggle aria-label="Toggle bold">
                <input
                    [name]="'toggleDef'"
                    [value]="toggle.pressed() ? 'on' : 'off'"
                    [required]="false"
                    rdxToggleVisuallyHiddenInput
                />
                @if (toggle.pressed()) {
                    On
                } @else {
                    Off
                }
            </button>

            <button class="Button violet" style="margin-top: 8px;" type="submit">Submit</button>
        </form>
    `
})
export class ToggleButtonReactiveForms implements OnInit {
    formGroup!: FormGroup;

    ngOnInit() {
        this.formGroup = new FormGroup({
            pressed: new FormControl<boolean>(true)
        });
    }

    onSubmit(): void {
        console.log(this.formGroup.value);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toggle/stories/toggle.docs.mdx
````
import { ArgTypes, Canvas, Markdown, Meta } from '@storybook/blocks';
import * as ToggleDirectiveStories from './toggle.stories';
import { RdxToggleDirective } from '../src/toggle.directive';
import { RdxToggleVisuallyHiddenInputDirective } from '../src/toggle-visually-hidden-input.directive';

<Meta title="Primitives/Toggle" />

# Toggle

#### A two-\_state button that can be either on or off.

<Canvas sourceState="hidden" of={ToggleDirectiveStories.Default} />

## Features

- âœ… Full keyboard navigation.
- âœ… Can be controlled or uncontrolled.

## Import

Get started with importing the directives:

```typescript
import { RdxToggleDirective } from '@radix-ng/primitives/toggle';
```

## Anatomy

```html
<button rdxToggle aria-label="Toggle italic">
  <icon />
</button>
```

## API Reference

### Toggle

`RdxToggleDirective`

The toggle.

<ArgTypes of={RdxToggleDirective} />

<Markdown>
    {`
  | Data Attribute | Value |
  | ----------- | --------- |
  | [data-state]       | "on" or "off"   |
  | [data-disabled]    | Present when disabled      |
  `}
</Markdown>

### ToggleInput

`RdxToggleVisuallyHiddenInputDirective`

Directive for a visually hidden `<input />`element, specifically designed for use with toggle components.
This directive simplifies the integration of hidden form inputs in toggle components, ensuring compatibility with form handling while maintaining a clean and accessible design.


## Accessibility

### Keyboard Interactions

<Markdown>
  {`
  | Key | Description |
  | ----------- | --------- |
  | Space       | Activates/deactivates the toggle.       |
  | Enter       | Activates/deactivates the toggle.  |
  `}
</Markdown>


## Examples

### Reactive Forms

Toggle can also be used with reactive forms. In this case, the formControlName property is used to bind the component to a form control.
<Canvas sourceState="hidden" of={ToggleDirectiveStories.ReactiveForm} />

### Disabled

When disabled is present, the element cannot be edited and focused.
<Canvas sourceState="hidden" of={ToggleDirectiveStories.Disabled} />

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toggle/stories/toggle.stories.ts
```typescript
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { Italic, LucideAngularModule } from 'lucide-angular';
import { RdxToggleVisuallyHiddenInputDirective } from '../src/toggle-visually-hidden-input.directive';
import { RdxToggleDirective } from '../src/toggle.directive';
import { ToggleButtonReactiveForms } from './toggle-forms.component';

const html = String.raw;

export default {
    title: 'Primitives/Toggle',
    decorators: [
        moduleMetadata({
            imports: [
                RdxToggleDirective,
                RdxToggleVisuallyHiddenInputDirective,
                ToggleButtonReactiveForms,
                LucideAngularModule,
                LucideAngularModule.pick({ Italic })
            ]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div class="radix-themes light light-theme" data-radius="medium" data-scaling="100%">
                    ${story}

                    <style>
                        button {
                            all: unset;
                        }
                        .Toggle {
                            background-color: white;
                            color: var(--mauve-11);
                            height: 35px;
                            width: 35px;
                            border-radius: 4px;
                            display: flex;
                            font-size: 15px;
                            line-height: 1;
                            align-items: center;
                            justify-content: center;
                            box-shadow: 0 2px 10px var(--black-a7);
                        }
                        .Toggle:hover {
                            background-color: var(--violet-3);
                        }
                        .Toggle[disabled] {
                            pointer-events: none;
                            opacity: 0.5;
                        }
                        .Toggle[data-state='on'] {
                            background-color: var(--violet-6);
                            color: var(--violet-12);
                        }
                        .Toggle:focus {
                            box-shadow: 0 0 0 2px black;
                        }
                    </style>
                </div>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: html`
            <button class="Toggle" rdxToggle aria-label="Toggle italic">
                <lucide-angular name="italic" size="12"></lucide-angular>
            </button>
        `
    })
};

export const State: Story = {
    argTypes: {
        pressed: {
            control: 'boolean'
        },
        disabled: {
            control: 'boolean'
        }
    },
    render: (args) => ({
        props: {
            config: args
        },
        template: html`
            <button
                class="Toggle"
                rdxToggle
                [disabled]="config.disabled"
                [pressed]="config.pressed"
                aria-label="Toggle italic"
            >
                <lucide-angular name="italic" size="12"></lucide-angular>
            </button>
        `
    })
};

export const Controlled: Story = {
    render: (args) => ({
        props: {
            config: args
        },
        template: html`
            <h1>Uncontrolled</h1>
            <span class="">default off</span>
            <button class="Toggle" rdxToggle [pressed]="false" aria-label="Toggle bold" #toggle="rdxToggle">
                <input
                    rdxToggleVisuallyHiddenInput
                    [name]="'toggleDef'"
                    [value]="toggle.pressed()"
                    [required]="false"
                />
                <lucide-angular name="italic" size="12"></lucide-angular>
            </button>

            <h1>Controlled</h1>
            <span class="">default on</span>
            <button
                class="Toggle"
                rdxToggle
                [defaultPressed]="true"
                [pressed]="true"
                aria-label="Toggle bold"
                #toggle="rdxToggle"
            >
                <input
                    rdxToggleVisuallyHiddenInput
                    [name]="'toggleDef'"
                    [value]="toggle.pressed()"
                    [required]="false"
                />
                <lucide-angular name="italic" size="12"></lucide-angular>
            </button>

            <span class="">default off</span>
            <button
                class="Toggle"
                rdxToggle
                [defaultPressed]="false"
                [pressed]="false"
                aria-label="Toggle bold"
                #toggle="rdxToggle"
            >
                <input
                    rdxToggleVisuallyHiddenInput
                    [name]="'toggleDef'"
                    [value]="toggle.pressed()"
                    [required]="false"
                />
                <lucide-angular name="italic" size="12"></lucide-angular>
            </button>

            <h1>Events</h1>
            <span class="">default off</span>
            <button class="Toggle" rdxToggle [pressed]="false" aria-label="Toggle bold" #toggle="rdxToggle">
                <input
                    rdxToggleVisuallyHiddenInput
                    [name]="'toggleDef'"
                    [value]="toggle.pressed()"
                    [required]="false"
                />
                <lucide-angular name="italic" size="12"></lucide-angular>
            </button>
        `
    })
};

export const Disabled: Story = {
    render: () => ({
        template: html`
            <button class="Toggle" disabled rdxToggle #toggle="rdxToggle" aria-label="Toggle disabled">
                <input
                    rdxToggleVisuallyHiddenInput
                    [name]="'toggleDef'"
                    [value]="toggle.pressed()"
                    [required]="false"
                    [disabled]="toggle.disabled()"
                />
                <lucide-angular name="italic" size="12"></lucide-angular>
            </button>
        `
    })
};

export const ReactiveForm: Story = {
    render: () => ({
        template: html`
            <toggle-reactive-forms></toggle-reactive-forms>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toggle/stories/toggle.styles.css
```css
button {
    all: unset;
}

.Toggle {
    background-color: white;
    color: var(--mauve-11);
    height: 35px;
    width: 35px;
    border-radius: 4px;
    display: flex;
    font-size: 15px;
    line-height: 1;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 10px var(--black-a7);
}

.Toggle:hover {
    background-color: var(--violet-3);
}

.Toggle[disabled] {
    pointer-events: none;
    opacity: 0.5;
}

.Toggle[data-state='on'] {
    background-color: var(--violet-6);
    color: var(--violet-12);
}

.Toggle:focus {
    box-shadow: 0 0 0 2px black;
}

.Button.violet {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    padding: 0 15px;
    font-size: 15px;
    line-height: 1;
    font-weight: 500;
    height: 35px;
    background-color: white;
    color: var(--violet-11);
    box-shadow: 0 2px 10px var(--black-a7);
}

.Button.violet:hover {
    background-color: var(--mauve-3);
}

.Button.violet:focus {
    box-shadow: 0 0 0 2px black;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toggle/__tests__/toggle.directive.spec.ts
```typescript
import { Component, DebugElement, Input } from '@angular/core';
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { RdxToggleDirective } from '../src/toggle.directive';

@Component({
    template:
        '<button rdxToggle [pressed]="pressed" [disabled]="disabled" (onPressedChange)="onToggle($event)">Toggle</button>',
    imports: [RdxToggleDirective]
})
class TestComponent {
    @Input() pressed = false;
    @Input() disabled = false;

    onToggle(pressed: boolean) {
        this.pressed = pressed;
    }
}

describe('RdxToggleDirective', () => {
    let component: TestComponent;
    let fixture: ComponentFixture<TestComponent>;
    let button: DebugElement;

    beforeEach(async () => {
        await TestBed.configureTestingModule({
            imports: [TestComponent]
        }).compileComponents();
    });

    beforeEach(() => {
        fixture = TestBed.createComponent(TestComponent);
        component = fixture.componentInstance;
        button = fixture.debugElement.query(By.css('button'));
        fixture.detectChanges();
    });

    it('should initialize with default values', () => {
        expect(component.pressed).toBe(false);
        expect(component.disabled).toBe(false);
    });

    it('should apply the correct aria-pressed attribute', () => {
        expect(button.nativeElement.getAttribute('aria-pressed')).toBe('false');
        component.pressed = true;
        fixture.detectChanges();
        expect(button.nativeElement.getAttribute('aria-pressed')).toBe('true');
    });

    it('should apply the correct data-state attribute', () => {
        expect(button.nativeElement.getAttribute('data-state')).toBe('off');
        component.pressed = true;
        fixture.detectChanges();
        expect(button.nativeElement.getAttribute('data-state')).toBe('on');
    });

    it('should apply the correct data-disabled attribute', () => {
        expect(button.nativeElement.getAttribute('data-disabled')).toBe(null);
        component.disabled = true;
        fixture.detectChanges();
        expect(button.nativeElement.getAttribute('data-disabled')).toBe('');
    });

    it('should toggle the pressed state on click', () => {
        expect(component.pressed).toBe(false);
        button.nativeElement.click();
        expect(component.pressed).toBe(true);
        button.nativeElement.click();
        expect(component.pressed).toBe(false);
    });

    it('should not toggle the pressed state when disabled', () => {
        component.disabled = true;
        fixture.detectChanges();
        expect(component.pressed).toBe(false);
        button.nativeElement.click();
        expect(component.pressed).toBe(false);
    });

    it('should emit the pressed state change event on toggle', () => {
        const spy = jest.spyOn(component, 'onToggle');
        button.nativeElement.click();
        expect(spy).toHaveBeenCalledWith(true);
        button.nativeElement.click();
        expect(spy).toHaveBeenCalledWith(false);
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toggle/src/toggle-visually-hidden-input.directive.ts
```typescript
import { Directive } from '@angular/core';
import { RdxVisuallyHiddenInputDirective } from '@radix-ng/primitives/visually-hidden';

@Directive({
    selector: 'input[rdxToggleVisuallyHiddenInput]',
    exportAs: 'rdxToggleVisuallyHiddenInput',
    hostDirectives: [
        {
            directive: RdxVisuallyHiddenInputDirective,
            inputs: [
                'name',
                'required',
                'value',
                'disabled'
            ]
        }
    ],
    host: {
        type: 'checkbox'
    }
})
export class RdxToggleVisuallyHiddenInputDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/toggle/src/toggle.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { booleanAttribute, computed, Directive, input, model, output, OutputEmitterRef, signal } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { provideValueAccessor } from '@radix-ng/primitives/core';

export interface ToggleProps {
    /**
     * The controlled state of the toggle.
     */
    pressed?: boolean;

    /**
     * The state of the toggle when initially rendered. Use `defaultPressed`
     * if you do not need to control the state of the toggle.
     * @defaultValue false
     */
    defaultPressed?: boolean;

    /**
     * The callback that fires when the state of the toggle changes.
     */
    onPressedChange?: OutputEmitterRef<boolean>;

    /**
     * Whether the toggle is disabled.
     * @defaultValue false
     */
    disabled?: boolean;
}

export type DataState = 'on' | 'off';

/**
 * @group Components
 */
@Directive({
    selector: '[rdxToggle]',
    exportAs: 'rdxToggle',
    providers: [provideValueAccessor(RdxToggleDirective)],
    host: {
        '[attr.aria-pressed]': 'pressed()',
        '[attr.data-state]': 'dataState()',
        '[attr.data-disabled]': 'disabledState() ? "" : undefined',
        '[disabled]': 'disabledState()',

        '(click)': 'togglePressed()'
    }
})
export class RdxToggleDirective implements ControlValueAccessor {
    /**
     * The pressed state of the toggle when it is initially rendered.
     * Use when you do not need to control its pressed state.
     *
     * @group Props
     */
    readonly defaultPressed = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * The controlled pressed state of the toggle.
     * Must be used in conjunction with `onPressedChange`.
     *
     * @group Props
     */
    readonly pressed = model<boolean>(this.defaultPressed());

    /**
     * When true, prevents the user from interacting with the toggle.
     *
     * @group Props
     */
    readonly disabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /** @ignore */
    readonly disabledModel = model<boolean>(this.disabled());

    /** @ignore */
    readonly disabledState = computed(() => this.disabled() || this.disabledModel() || this.accessorDisabled());

    protected readonly dataState = computed<DataState>(() => {
        return this.pressed() ? 'on' : 'off';
    });

    /**
     * Event handler called when the pressed state of the toggle changes.
     *
     * @group Emits
     */
    readonly onPressedChange = output<boolean>();

    protected togglePressed(): void {
        if (!this.disabled()) {
            this.pressed.set(!this.pressed());
            this.onChange(this.pressed());
            this.onPressedChange.emit(this.pressed());
        }
    }

    private readonly accessorDisabled = signal(false);

    private onChange: (value: any) => void = () => {};

    /** @ignore */
    onTouched: (() => void) | undefined;

    /** @ignore */
    writeValue(value: any): void {
        this.pressed.set(value);
    }

    /** @ignore */
    registerOnChange(fn: (value: any) => void): void {
        this.onChange = fn;
    }

    /** @ignore */
    registerOnTouched(fn: () => void): void {
        this.onTouched = fn;
    }

    /** @ignore */
    setDisabledState(isDisabled: boolean): void {
        this.accessorDisabled.set(isDisabled);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/README.md
```
# @radix-ng/primitives/dialog

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/index.ts
```typescript
import { NgModule } from '@angular/core';
import { RdxDialogCloseDirective } from './src/dialog-close.directive';
import { RdxDialogContentDirective } from './src/dialog-content.directive';
import { RdxDialogDescriptionDirective } from './src/dialog-description.directive';
import { RdxDialogDismissDirective } from './src/dialog-dismiss.directive';
import { RdxDialogTitleDirective } from './src/dialog-title.directive';
import { RdxDialogTriggerDirective } from './src/dialog-trigger.directive';

export * from './src/dialog-close.directive';
export * from './src/dialog-content.directive';
export * from './src/dialog-description.directive';
export * from './src/dialog-dismiss.directive';
export * from './src/dialog-ref';
export * from './src/dialog-title.directive';
export * from './src/dialog-trigger.directive';
export * from './src/dialog.config';
export * from './src/dialog.injectors';
export * from './src/dialog.providers';
export * from './src/dialog.service';

const _imports = [
    RdxDialogTriggerDirective,
    RdxDialogContentDirective,
    RdxDialogTitleDirective,
    RdxDialogCloseDirective,
    RdxDialogDescriptionDirective,
    RdxDialogDismissDirective
];

@NgModule({
    imports: [..._imports],
    exports: [..._imports]
})
export class RdxDialogModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/stories/dialog.docs.mdx
````
import { Canvas, Meta } from '@storybook/blocks';
import * as DialogStories from './dialog.stories';
import * as SheetStories from './sheet.stories';

<Meta title="Primitives/Dialog" />

# Dialog

#### A window overlaid on either the primary window or another dialog window, rendering the content underneath inert.

<Canvas sourceState="hidden" of={DialogStories.Default} />

## Features
- âœ… Supports modal and non-modal modes.
- âœ… Focus is automatically trapped when modal.
- âœ… Can be controlled or uncontrolled.
- âœ… Esc closes the component automatically.

### Anatomy
Import all parts and piece them together.

```html

<button [rdxDialogTrigger]="dialog">Open Dialog</button>

<ng-template #dialog>
    <div rdxDialogContent>
        <h2 rdxDialogTitle></h2>
        <p rdxDialogDescription></p>
        <button rdxDialogClose></button>
        <button rdxDialogDismiss>X</button>
    </div>
</ng-template>
```

## Examples

### Sheet

<Canvas sourceState="hidden" of={SheetStories.Default} />

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/stories/dialog.stories.ts
```typescript
import { applicationConfig, componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { RdxDialogCloseDirective } from '../src/dialog-close.directive';
import { RdxDialogContentDirective } from '../src/dialog-content.directive';
import { RdxDialogDescriptionDirective } from '../src/dialog-description.directive';
import { RdxDialogTitleDirective } from '../src/dialog-title.directive';
import { RdxDialogTriggerDirective } from '../src/dialog-trigger.directive';
import { provideRdxDialogConfig } from '../src/dialog.providers';

const html = String.raw;

export default {
    title: 'Primitives/Dialog',
    decorators: [
        applicationConfig({
            providers: [provideRdxDialogConfig()]
        }),
        moduleMetadata({
            imports: [
                RdxDialogTriggerDirective,
                RdxDialogContentDirective,
                RdxDialogTitleDirective,
                RdxDialogCloseDirective,
                RdxDialogDescriptionDirective
            ]
        }),
        componentWrapperDecorator(
            (story) => `
                <div class="radix-themes light light-theme radix-themes-default-fonts rt-Flex rt-r-ai-start rt-r-jc-center rt-r-position-relative"
                    data-accent-color="indigo"
                    data-radius="medium"
                    data-scaling="100%"
                >
                    ${story}
                </div>`
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    argTypes: {
        mode: {
            options: ['default', 'sheet-right', 'sheet-bottom'],
            control: {
                type: 'select'
            }
        }
    },
    render: (args) => ({
        props: {
            config: args
        },
        template: html`
            <button class="Button violet" [rdxDialogConfig]="config" [rdxDialogTrigger]="dialog">Open Dialog</button>

            <ng-template #dialog>
                <div class="DialogContent" rdxDialogContent>
                    <h2 class="DialogTitle" rdxDialogTitle>Edit profile</h2>
                    <p class="DialogDescription" rdxDialogDescription>
                        Make changes to your profile here. Click save when you're done.
                    </p>
                    <fieldset class="Fieldset">
                        <label class="Label" htmlFor="name">Name</label>
                        <input class="Input" id="name" defaultValue="Pedro Duarte" />
                    </fieldset>
                    <fieldset class="Fieldset">
                        <label class="Label" htmlFor="username">Username</label>
                        <input class="Input" id="username" defaultValue="@peduarte" />
                    </fieldset>
                    <div style="display:flex; margin-top: 25px; justify-content: flex-end;">
                        <button class="Button green" rdxDialogClose>Save changes</button>
                    </div>
                    <button class="IconButton" rdxDialogClose aria-label="Close">X</button>
                </div>
            </ng-template>

            <style>
                /* reset */
                button,
                fieldset,
                input {
                    all: unset;
                }

                .DialogOverlay {
                    background-color: var(--black-a9);
                    position: fixed;
                    inset: 0;
                    animation: overlayShow 150ms cubic-bezier(0.16, 1, 0.3, 1);
                }

                .DialogContent {
                    background-color: white;
                    border-radius: 6px;
                    box-shadow:
                        hsl(206 22% 7% / 35%) 0px 10px 38px -10px,
                        hsl(206 22% 7% / 20%) 0px 10px 20px -15px;
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: 90vw;
                    max-width: 450px;
                    max-height: 85vh;
                    padding: 25px;
                    animation: contentShow 150ms cubic-bezier(0.16, 1, 0.3, 1);
                }

                .DialogContent:focus {
                    outline: none;
                }

                .DialogTitle {
                    margin: 0;
                    font-weight: 500;
                    color: var(--mauve-12);
                    font-size: 17px;
                }

                .DialogDescription {
                    margin: 10px 0 20px;
                    color: var(--mauve-11);
                    font-size: 15px;
                    line-height: 1.5;
                }

                .Button {
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                    border-radius: 4px;
                    padding: 0 15px;
                    font-size: 15px;
                    line-height: 1;
                    font-weight: 500;
                    height: 35px;
                }

                .Button.violet {
                    background-color: white;
                    color: var(--violet-11);
                    box-shadow: 0 2px 10px var(--black-a7);
                }

                .Button.violet:hover {
                    background-color: var(--mauve-3);
                }

                .Button.violet:focus {
                    box-shadow: 0 0 0 2px black;
                }

                .Button.green {
                    background-color: var(--green-4);
                    color: var(--green-11);
                }

                .Button.green:hover {
                    background-color: var(--green-5);
                }

                .Button.green:focus {
                    box-shadow: 0 0 0 2px var(--green-7);
                }

                .IconButton {
                    font-family: inherit;
                    border-radius: 100%;
                    height: 25px;
                    width: 25px;
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                    color: var(--violet-11);
                    position: absolute;
                    top: 10px;
                    right: 10px;
                }

                .IconButton:hover {
                    background-color: var(--violet-4);
                }

                .IconButton:focus {
                    box-shadow: 0 0 0 2px var(--violet-7);
                }

                .Fieldset {
                    display: flex;
                    gap: 20px;
                    align-items: center;
                    margin-bottom: 15px;
                }

                .Label {
                    font-size: 15px;
                    color: var(--violet-11);
                    width: 90px;
                    text-align: right;
                }

                .Input {
                    width: 100%;
                    flex: 1;
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                    border-radius: 4px;
                    padding: 0 10px;
                    font-size: 15px;
                    line-height: 1;
                    color: var(--violet-11);
                    box-shadow: 0 0 0 1px var(--violet-7);
                    height: 35px;
                }

                .Input:focus {
                    box-shadow: 0 0 0 2px var(--violet-8);
                }
            </style>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/stories/sheet.docs.mdx
```
import { Canvas, Controls, Meta } from '@storybook/blocks';
import * as SheetStories from './sheet.stories';

<Meta of={SheetStories} title="Examples/Sheet" />

# Sheet

<Canvas sourceState="hidden" of={SheetStories.Default} />

<Controls />

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/stories/sheet.stories.ts
```typescript
import { applicationConfig, componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { RdxDialogCloseDirective } from '../src/dialog-close.directive';
import { RdxDialogContentDirective } from '../src/dialog-content.directive';
import { RdxDialogDescriptionDirective } from '../src/dialog-description.directive';
import { RdxDialogTitleDirective } from '../src/dialog-title.directive';
import { RdxDialogTriggerDirective } from '../src/dialog-trigger.directive';
import { provideRdxDialogConfig } from '../src/dialog.providers';

const html = String.raw;

export default {
    title: 'Examples/Sheet',
    decorators: [
        applicationConfig({
            providers: [provideRdxDialogConfig()]
        }),
        moduleMetadata({
            imports: [
                RdxDialogTriggerDirective,
                RdxDialogContentDirective,
                RdxDialogTitleDirective,
                RdxDialogCloseDirective,
                RdxDialogDescriptionDirective
            ]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div
                    class="radix-themes light light-theme radix-themes-default-fonts rt-Flex rt-r-ai-start rt-r-jc-center rt-r-position-relative"
                    data-accent-color="indigo"
                    data-radius="medium"
                    data-scaling="100%"
                >
                    ${story}
                </div>
            `
        )
    ],
    argTypes: {
        mode: {
            options: ['sheet-right', 'sheet-bottom'],
            control: {
                type: 'select'
            }
        },
        backdropClass: {
            options: ['cdk-overlay-dark-backdrop', 'DialogSheetOverlay'],
            control: {
                type: 'select'
            }
        }
    },
    render: (args) => {
        return {
            props: {
                config: args
            },
            template: html`
                <button class="Button violet" [rdxDialogConfig]="config" [rdxDialogTrigger]="sheetTpl">
                    Open Sheet
                </button>

                <ng-template #sheetTpl>
                    <div class="DialogContent" rdxDialogContent>
                        <h2 class="DialogTitle" rdxDialogTitle>Edit profile</h2>
                        <p class="DialogDescription" rdxDialogDescription>
                            Make changes to your profile here. Click save when you're done.
                        </p>
                        <fieldset class="Fieldset">
                            <label class="Label" htmlFor="name">Name</label>
                            <input class="Input" id="name" defaultValue="Pedro Duarte" />
                        </fieldset>
                        <fieldset class="Fieldset">
                            <label class="Label" htmlFor="username">Username</label>
                            <input class="Input" id="username" defaultValue="@peduarte" />
                        </fieldset>
                        <div style="display:flex; margin-top: 25px; justify-content: flex-end;">
                            <button class="Button green" rdxDialogClose>Save changes</button>
                        </div>
                        <button class="IconButton" rdxDialogClose aria-label="Close">X</button>
                    </div>
                </ng-template>

                <style>
                    /* reset */
                    button,
                    fieldset,
                    input {
                        all: unset;
                    }

                    .DialogContent {
                        margin: 25px;
                    }

                    .DialogTitle {
                        margin: 0;
                        font-weight: 500;
                        color: var(--mauve-12);
                        font-size: 17px;
                    }

                    .DialogDescription {
                        margin: 10px 0 20px;
                        color: var(--mauve-11);
                        font-size: 15px;
                        line-height: 1.5;
                    }

                    .Button {
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                        border-radius: 4px;
                        padding: 0 15px;
                        font-size: 15px;
                        line-height: 1;
                        font-weight: 500;
                        height: 35px;
                    }

                    .Button.violet {
                        background-color: white;
                        color: var(--violet-11);
                        box-shadow: 0 2px 10px var(--black-a7);
                    }

                    .Button.violet:hover {
                        background-color: var(--mauve-3);
                    }

                    .Button.violet:focus {
                        box-shadow: 0 0 0 2px black;
                    }

                    .Button.green {
                        background-color: var(--green-4);
                        color: var(--green-11);
                    }

                    .Button.green:hover {
                        background-color: var(--green-5);
                    }

                    .Button.green:focus {
                        box-shadow: 0 0 0 2px var(--green-7);
                    }

                    .IconButton {
                        font-family: inherit;
                        border-radius: 100%;
                        height: 25px;
                        width: 25px;
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                        color: var(--violet-11);
                        position: absolute;
                        top: 10px;
                        right: 10px;
                    }

                    .IconButton:hover {
                        background-color: var(--violet-4);
                    }

                    .IconButton:focus {
                        box-shadow: 0 0 0 2px var(--violet-7);
                    }

                    .Fieldset {
                        display: flex;
                        gap: 20px;
                        align-items: center;
                        margin-bottom: 15px;
                    }

                    .Label {
                        font-size: 15px;
                        color: var(--violet-11);
                        width: 90px;
                        text-align: right;
                    }

                    .Input {
                        width: 100%;
                        flex: 1;
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                        border-radius: 4px;
                        padding: 0 10px;
                        font-size: 15px;
                        line-height: 1;
                        color: var(--violet-11);
                        box-shadow: 0 0 0 1px var(--violet-7);
                        height: 35px;
                    }

                    .Input:focus {
                        box-shadow: 0 0 0 2px var(--violet-8);
                    }
                </style>
            `
        };
    }
} as Meta;

export const Default: StoryObj = {
    args: {
        backdropClass: 'cdk-overlay-dark-backdrop',
        mode: 'sheet-right',
        panelClasses: ['DialogSheet']
    }
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/stories/sheet/sheet.styles.scss
```
.DialogSheet {
    background-color: white;
    position: fixed !important;
    margin: auto;
    overflow: auto;
    display: flex;
    flex-direction: column;

    inset: 0 0 0 auto;
    width: 40rem;
    height: 100%;
    max-width: calc(100vw - 2rem);
    max-height: none;
    border-radius: 6px 0 0 6px;

    &:where(.mod-right) {
        animation: slideFromRight 250ms ease;
    }

    &:where(.mod-bottom) {
        inset: auto 0 0 0;
        width: 100%;
        height: fit-content;
        max-width: none;
        max-height: calc(100dvh - 2rem);
        border-radius: 6px 6px 0 0;

        animation: slideFromBottom 250ms ease;
    }

    @keyframes scaleIn {
        0% {
            transform: scale(0);
        }

        100% {
            transform: scale(1);
        }
    }

    @keyframes slideFromBottom {
        0% {
            transform: translateY(100%);
        }

        100% {
            transform: translateY(0);
        }
    }

    @keyframes slideFromRight {
        0% {
            transform: translateX(100%);
        }

        100% {
            transform: translateX(0);
        }
    }
}

.DialogSheetOverlay {
    background-color: var(--black-a9);
    position: fixed;
    inset: 0;
    opacity: 0.4;
    animation: overlayShow 150ms cubic-bezier(0.16, 1, 0.3, 1);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/__tests__/dialog-content.directive.spec.ts
```typescript
import { Component, DebugElement } from '@angular/core';
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { Subject } from 'rxjs';
import { RdxDialogContentDirective } from '../src/dialog-content.directive';
import { RdxDialogRef } from '../src/dialog-ref';

@Component({
    template: '<div rdxDialogContent>Dialog Content</div>',
    imports: [RdxDialogContentDirective]
})
class TestComponent {}

describe('RdxDialogContentDirective', () => {
    let fixture: ComponentFixture<TestComponent>;
    let directiveElement: DebugElement;
    let directive: RdxDialogContentDirective;
    let dialogRefMock: jest.Mocked<RdxDialogRef>;
    let closedSubject: Subject<any>;

    beforeEach(async () => {
        closedSubject = new Subject();
        dialogRefMock = {
            closed$: closedSubject.asObservable(),
            close: jest.fn(),
            dismiss: jest.fn()
        } as any;

        await TestBed.configureTestingModule({
            imports: [TestComponent],
            providers: [
                { provide: RdxDialogRef, useValue: dialogRefMock }]
        }).compileComponents();

        fixture = TestBed.createComponent(TestComponent);
        directiveElement = fixture.debugElement.query(By.directive(RdxDialogContentDirective));
        directive = directiveElement.injector.get(RdxDialogContentDirective);
        fixture.detectChanges();
    });

    it('should create', () => {
        expect(directive).toBeTruthy();
    });

    it('should have correct initial state', () => {
        expect(directive['state']()).toBe('open');
    });

    it('should update state when dialog is closed', () => {
        closedSubject.next(undefined);
        fixture.detectChanges();
        expect(directive['state']()).toBe('closed');
    });

    it('should call dialogRef.dismiss when dismiss method is called', () => {
        directive.dismiss();
        expect(dialogRefMock.dismiss).toHaveBeenCalled();
    });

    it('should call dialogRef.dismiss when dismiss method is called', () => {
        directive.dismiss();
        expect(dialogRefMock.dismiss).toHaveBeenCalled();
    });

    it('should have correct host bindings', () => {
        const element = directiveElement.nativeElement;
        expect(element.getAttribute('role')).toBe('dialog');
        expect(element.getAttribute('aria-describedby')).toBe('true');
        expect(element.getAttribute('aria-labelledby')).toBe('true');
        expect(element.getAttribute('data-state')).toBe('open');

        closedSubject.next(undefined);
        fixture.detectChanges();

        expect(element.getAttribute('data-state')).toBe('closed');
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/__tests__/dialog-trigger.directive.spec.ts
```typescript
import { Component, OnInit, TemplateRef, ViewChild } from '@angular/core';
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { of } from 'rxjs';
import { RdxDialogRef } from '../src/dialog-ref';
import { RdxDialogTriggerDirective } from '../src/dialog-trigger.directive';
import { RdxDialogConfig } from '../src/dialog.config';
import { RdxDialogService } from '../src/dialog.service';

@Component({
    template: `
        <button [rdxDialogTrigger]="dialogTemplate" [rdxDialogConfig]="config">Open Dialog</button>
        <ng-template #dialogTemplate>Dialog Content</ng-template>
    `,
    imports: [RdxDialogTriggerDirective]
})
class TestHostComponent implements OnInit {
    @ViewChild('dialogTemplate') dialogTemplate: TemplateRef<any>;

    config: RdxDialogConfig<unknown>;

    ngOnInit() {
        this.config = {
            content: this.dialogTemplate,
            modal: true,
            ariaLabel: 'Test Dialog',
            autoFocus: 'first-tabbable',
            canClose: () => true,
            canCloseWithBackdrop: true,
            mode: 'default'
        };
    }
}

describe('RdxDialogTriggerDirective', () => {
    let fixture: ComponentFixture<TestHostComponent>;
    let directive: RdxDialogTriggerDirective;
    let dialogServiceMock: jest.Mocked<RdxDialogService>;
    let dialogRefMock: jest.Mocked<RdxDialogRef>;

    beforeEach(async () => {
        dialogRefMock = {
            closed$: of(undefined)
        } as any;

        dialogServiceMock = {
            open: jest.fn().mockReturnValue(dialogRefMock)
        } as any;

        await TestBed.configureTestingModule({
            imports: [TestHostComponent],
            providers: [
                { provide: RdxDialogService, useValue: dialogServiceMock }]
        }).compileComponents();

        fixture = TestBed.createComponent(TestHostComponent);
        fixture.detectChanges();

        const directiveEl = fixture.debugElement.query(By.directive(RdxDialogTriggerDirective));
        directive = directiveEl.injector.get(RdxDialogTriggerDirective);
    });

    it('should create', () => {
        expect(directive).toBeTruthy();
    });

    it('should have correct initial state', () => {
        expect(directive.isOpen()).toBe(false);
        expect(directive.state()).toBe('closed');
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/src/dialog-close.directive.ts
```typescript
import { Directive, inject } from '@angular/core';
import { RdxDialogRef } from './dialog-ref';

@Directive({
    selector: '[rdxDialogClose]',
    standalone: true,
    host: {
        '(click)': 'onClick()'
    }
})
export class RdxDialogCloseDirective {
    private readonly ref = inject<RdxDialogRef>(RdxDialogRef);

    protected onClick(): void {
        this.ref.close();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/src/dialog-content.directive.ts
```typescript
import { computed, DestroyRef, Directive, inject, signal } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { RdxDialogRef } from './dialog-ref';
import { getState, RdxDialogResult } from './dialog.config';

@Directive({
    selector: '[rdxDialogContent]',
    standalone: true,
    host: {
        role: 'dialog',
        '[attr.aria-describedby]': '"true"',
        '[attr.aria-labelledby]': '"true"',
        '[attr.data-state]': 'state()'
    }
})
export class RdxDialogContentDirective<C = unknown> {
    private readonly dialogRef = inject<RdxDialogRef<C>>(RdxDialogRef);
    private readonly destroyRef = inject(DestroyRef);

    private readonly isOpen = signal(true);

    readonly state = computed(() => getState(this.isOpen()));

    constructor() {
        this.dialogRef.closed$.pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => {
            this.isOpen.set(false);
        });
    }

    /**
     * Closes the dialog with a specified result.
     *
     * @param result The result to be passed back when closing the dialog
     */
    close(result: RdxDialogResult<C>): void {
        this.dialogRef.close(result);
    }

    /**
     * Dismisses the dialog without a result.
     */
    dismiss(): void {
        this.dialogRef.dismiss();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/src/dialog-description.directive.ts
```typescript
import { Directive } from '@angular/core';

@Directive({
    selector: '[rdxDialogDescription]',
    standalone: true
})
export class RdxDialogDescriptionDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/src/dialog-dismiss.directive.ts
```typescript
import { Directive, inject } from '@angular/core';
import { RdxDialogRef } from './dialog-ref';

@Directive({
    selector: 'button[rdxDialogDismiss]',
    standalone: true,
    host: {
        type: 'button',
        '(click)': 'onClick()'
    }
})
export class RdxDialogDismissDirective {
    private readonly ref = inject<RdxDialogRef>(RdxDialogRef);

    protected onClick(): void {
        this.ref.dismiss();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/src/dialog-ref.ts
```typescript
import { DialogRef } from '@angular/cdk/dialog';
import { filter, isObservable, map, Observable, of, take } from 'rxjs';
import { RdxDialogConfig, RdxDialogResult } from './dialog.config';

export const DISMISSED_VALUE = {} as const;

function isDismissed(v: unknown): v is typeof DISMISSED_VALUE {
    return v === DISMISSED_VALUE;
}

/**
 * Represents a reference to an open dialog.
 * Provides methods and observables to interact with and monitor the dialog's state.
 * @template C - The type of the dialog's content component
 */
export class RdxDialogRef<C = unknown> {
    closed$: Observable<RdxDialogResult<C> | undefined> = this.cdkRef.closed.pipe(
        map((res): RdxDialogResult<C> | undefined => (isDismissed(res) ? undefined : res))
    );

    dismissed$: Observable<void> = this.cdkRef.closed.pipe(
        filter((res) => res === DISMISSED_VALUE),
        map((): void => undefined)
    );

    result$: Observable<RdxDialogResult<C>> = this.cdkRef.closed.pipe(
        filter((res): res is RdxDialogResult<C> => !isDismissed(res))
    );

    /**
     * @param cdkRef - Reference to the underlying CDK dialog
     * @param config - Configuration options for the dialog
     */
    constructor(
        public readonly cdkRef: DialogRef<RdxDialogResult<C> | typeof DISMISSED_VALUE, C>,
        public readonly config: RdxDialogConfig<C>
    ) {}

    get instance(): C | null {
        return this.cdkRef.componentInstance;
    }

    /**
     * Attempts to dismiss the dialog
     * Checks the canClose condition before dismissing
     */
    dismiss(): void {
        if (!this.instance || this.config.isAlert) {
            return;
        }

        const canClose = this.config.canClose?.(this.instance) ?? true;
        const canClose$ = isObservable(canClose) ? canClose : of(canClose);
        canClose$.pipe(take(1)).subscribe((close) => {
            if (close) {
                this.cdkRef.close(DISMISSED_VALUE);
            }
        });
    }

    close(result: RdxDialogResult<C>): void {
        this.cdkRef.close(result);
    }
}

/**
 * Represents a simplified interface for dialog interaction
 * Typically used by dialog content components
 * @template R - The type of the result when closing the dialog
 */
export type RdxDialogSelfRef<R> = { dismiss(): void; close(res: R): void };

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/src/dialog-title.directive.ts
```typescript
import { Directive } from '@angular/core';

@Directive({
    selector: '[rdxDialogTitle]',
    standalone: true
})
export class RdxDialogTitleDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/src/dialog-trigger.directive.ts
```typescript
import { computed, Directive, inject, Input, input, signal, TemplateRef } from '@angular/core';
import { RdxDialogRef } from './dialog-ref';
import { getState, RdxDialogConfig, RdxDialogState } from './dialog.config';
import { provideRdxDialog } from './dialog.providers';
import { RdxDialogService } from './dialog.service';

let nextId = 0;

/**
 * @group Components
 */
@Directive({
    selector: '[rdxDialogTrigger]',
    standalone: true,
    providers: [provideRdxDialog()],
    host: {
        type: 'button',
        '[attr.id]': 'id()',
        '[attr.aria-haspopup]': '"dialog"',
        '[attr.aria-expanded]': 'isOpen()',
        '[attr.aria-controls]': 'dialogId()',
        '[attr.data-state]': 'state()',
        '(click)': 'onClick()'
    }
})
export class RdxDialogTriggerDirective {
    private readonly dialogService = inject(RdxDialogService);

    /**
     * @group Props
     */
    readonly id = input(`rdx-dialog-trigger-${nextId++}`);
    readonly dialogId = computed(() => `rdx-dialog-${this.id()}`);

    /**
     * @group Props
     */
    @Input({ required: true, alias: 'rdxDialogTrigger' }) dialog: TemplateRef<void>;

    /**
     * @group Props
     */
    @Input({ alias: 'rdxDialogConfig' }) dialogConfig: RdxDialogConfig<unknown>;

    readonly isOpen = signal(false);
    readonly state = computed<RdxDialogState>(() => getState(this.isOpen()));

    private currentDialogRef: RdxDialogRef | null = null;

    protected onClick() {
        this.currentDialogRef = this.dialogService.open({
            ...this.dialogConfig,
            content: this.dialog
        });

        this.isOpen.set(true);

        this.currentDialogRef.closed$.subscribe(() => {
            this.isOpen.set(false);
            this.currentDialogRef = null;
        });
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/src/dialog.config.ts
```typescript
import { AutoFocusTarget, DialogConfig } from '@angular/cdk/dialog';
import { ComponentType } from '@angular/cdk/overlay';
import { TemplateRef } from '@angular/core';
import { Observable } from 'rxjs';

const ÉµdialogData = Symbol.for('rdxDialogData');
const ÉµdialogResult = Symbol.for('rdxDialogResult');

export type ÉµDialogDataFlag = { [ÉµdialogData]: unknown };
export type ÉµDialogResultFlag<R> = { [ÉµdialogResult]: R };

export type RdxDialogData<T> = {
    [K in keyof T]: T[K] extends ÉµDialogDataFlag ? Omit<T[K], typeof ÉµdialogData> : never;
}[keyof T];

type DialogRefProps<C> = { [K in keyof C]: C[K] extends ÉµDialogResultFlag<unknown> ? K : never }[keyof C] & keyof C;
export type RdxDialogResult<C> =
    DialogRefProps<C> extends never ? void : C[DialogRefProps<C>] extends ÉµDialogResultFlag<infer T> ? T : void;

type RdxDialogMode = 'default' | 'sheet' | 'sheet-bottom' | 'sheet-top' | 'sheet-left' | 'sheet-right';

type RdxBaseDialogConfig<C> = {
    content: ComponentType<C> | TemplateRef<C>;

    data: RdxDialogData<C>;

    modal?: boolean;

    ariaLabel?: string;

    autoFocus?: AutoFocusTarget | 'first-input' | string;

    canClose?: (comp: C) => boolean | Observable<boolean>;

    canCloseWithBackdrop?: boolean;

    cdkConfigOverride?: Partial<DialogConfig<C>>;

    mode?: RdxDialogMode;

    backdropClass?: string | string[];

    panelClasses?: string[];

    isAlert?: boolean;
};

export type RdxDialogConfig<T> =
    RdxDialogData<T> extends never
        ? Omit<RdxBaseDialogConfig<T>, 'data'>
        : RdxBaseDialogConfig<T> & { data: Required<RdxDialogData<T>> };

export type RdxDialogState = 'open' | 'closed';

export function getState(open: boolean): RdxDialogState {
    return open ? 'open' : 'closed';
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/src/dialog.injectors.ts
```typescript
import { DIALOG_DATA } from '@angular/cdk/dialog';
import { inject } from '@angular/core';
import { RdxDialogRef, RdxDialogSelfRef } from './dialog-ref';
import { ÉµDialogDataFlag, ÉµDialogResultFlag } from './dialog.config';

export function injectDialogData<TData>(): TData & ÉµDialogDataFlag {
    return inject<TData & ÉµDialogDataFlag>(DIALOG_DATA);
}

export function injectDialogRef<R = void>(): RdxDialogSelfRef<R> & ÉµDialogResultFlag<R> {
    return inject<RdxDialogSelfRef<R>>(RdxDialogRef) as RdxDialogSelfRef<R> & ÉµDialogResultFlag<R>;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/src/dialog.providers.ts
```typescript
import { DialogModule } from '@angular/cdk/dialog';
import { EnvironmentProviders, importProvidersFrom, makeEnvironmentProviders, Provider } from '@angular/core';
import { RdxDialogService } from './dialog.service';

/**
 * Configures the RdxDialog module by providing necessary dependencies.
 *
 * This function sets up the environment providers required for the RdxDialog to function,
 * specifically importing the Angular CDK's DialogModule.
 *
 * @returns {EnvironmentProviders} An EnvironmentProviders instance containing the DialogModule.
 */
export function provideRdxDialogConfig(): EnvironmentProviders {
    return makeEnvironmentProviders([importProvidersFrom(DialogModule)]);
}

/**
 * Provides the RdxDialogService for dependency injection.
 *
 * This function is used to make the RdxDialogService available for injection
 * in components, directives, or other services that require dialog functionality.
 *
 * @returns {Provider} A provider for the RdxDialogService.
 */
export function provideRdxDialog(): Provider {
    return RdxDialogService;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/dialog/src/dialog.service.ts
```typescript
import { Dialog } from '@angular/cdk/dialog';
import { inject, Injectable, Injector, Renderer2 } from '@angular/core';
import { filter, isObservable, merge, of, switchMap, take, takeUntil } from 'rxjs';
import { DISMISSED_VALUE, RdxDialogRef } from './dialog-ref';
import type { RdxDialogConfig, RdxDialogResult } from './dialog.config';

/**
 * Modality control: When `isModal` is set to `true`, the dialog will:
 *
 * - Have a backdrop that blocks interaction with the rest of the page
 * - Disable closing by clicking outside or pressing Escape
 * - Set `aria-modal="true"` for screen readers
 * - Automatically focus the first tabbable element in the dialog
 * - Restore focus to the element that opened the dialog when it's closed
 *
 *
 * When `isModal` is `false`, the dialog will:
 *
 * - Not have a backdrop, allowing interaction with the rest of the page
 * - Allow closing by clicking outside or pressing Escape
 * - Not set `aria-modal` attribute
 * - Not automatically manage focus
 */
@Injectable()
export class RdxDialogService {
    #cdkDialog = inject(Dialog);
    #injector = inject(Injector);

    open<C>(config: RdxDialogConfig<C>): RdxDialogRef<C> {
        let dialogRef: RdxDialogRef<C>;
        let modeClasses: string[] = [];

        switch (config.mode) {
            case 'sheet':
                modeClasses = ['mod-sheet', 'mod-right'];
                break;
            case 'sheet-right':
                modeClasses = ['mod-sheet', 'mod-right'];
                break;
            case 'sheet-bottom':
                modeClasses = ['mod-sheet', 'mod-bottom'];
                break;
            case 'sheet-left':
                modeClasses = ['mod-sheet', 'mod-left'];
                break;
            case 'sheet-top':
                modeClasses = ['mod-sheet', 'mod-top'];
                break;
        }

        const cdkRef = this.#cdkDialog.open<RdxDialogResult<C> | typeof DISMISSED_VALUE, unknown, C>(config.content, {
            ariaModal: config.modal ?? true,
            hasBackdrop: config.modal ?? true,
            data: 'data' in config ? config.data : null,
            restoreFocus: true,
            role: config.isAlert ? 'alertdialog' : 'dialog',
            disableClose: true,
            closeOnDestroy: true,
            injector: this.#injector,
            backdropClass: config.backdropClass ? config.backdropClass : 'cdk-overlay-dark-backdrop',
            panelClass: ['dialog', ...modeClasses, ...(config.panelClasses || [])],
            autoFocus: config.autoFocus === 'first-input' ? 'dialog' : (config.autoFocus ?? 'first-tabbable'),
            ariaLabel: config.ariaLabel,
            templateContext: () => ({ dialogRef: dialogRef }),
            providers: (ref) => {
                dialogRef = new RdxDialogRef(ref, config);
                return [
                    {
                        provide: RdxDialogRef,
                        useValue: dialogRef
                    }
                ];
            },
            // @FIXME
            ...(config.cdkConfigOverride || ({} as any))
        });

        if (cdkRef.componentRef) {
            cdkRef.componentRef.injector
                .get(Renderer2)
                .setStyle(cdkRef.componentRef.location.nativeElement, 'display', 'contents');
        }

        if (!config.isAlert) {
            merge(
                cdkRef.backdropClick,
                cdkRef.keydownEvents.pipe(filter((e) => e.key === 'Escape' && !e.defaultPrevented))
            )
                .pipe(
                    filter(() => config.canCloseWithBackdrop ?? true),
                    switchMap(() => {
                        const canClose =
                            (cdkRef.componentInstance && config.canClose?.(cdkRef.componentInstance)) ?? true;
                        const canClose$ = isObservable(canClose) ? canClose : of(canClose);
                        return canClose$.pipe(take(1));
                    }),

                    takeUntil(dialogRef!.closed$)
                )
                .subscribe((canClose) => {
                    if (canClose) {
                        cdkRef.close(DISMISSED_VALUE);
                    }
                });
        }

        return dialogRef!;
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/README.md
```
# @radix-ng/primitives/popover

Secondary entry point of `@radix-ng/primitives`. It can be used by importing from `@radix-ng/primitives/popover`.

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/index.ts
```typescript
import { NgModule } from '@angular/core';
import { RdxPopoverAnchorDirective } from './src/popover-anchor.directive';
import { RdxPopoverArrowDirective } from './src/popover-arrow.directive';
import { RdxPopoverCloseDirective } from './src/popover-close.directive';
import { RdxPopoverContentAttributesComponent } from './src/popover-content-attributes.component';
import { RdxPopoverContentDirective } from './src/popover-content.directive';
import { RdxPopoverRootDirective } from './src/popover-root.directive';
import { RdxPopoverTriggerDirective } from './src/popover-trigger.directive';

export * from './src/popover-anchor.directive';
export * from './src/popover-arrow.directive';
export * from './src/popover-close.directive';
export * from './src/popover-content-attributes.component';
export * from './src/popover-content.directive';
export * from './src/popover-root.directive';
export * from './src/popover-trigger.directive';

const _imports = [
    RdxPopoverArrowDirective,
    RdxPopoverCloseDirective,
    RdxPopoverContentDirective,
    RdxPopoverTriggerDirective,
    RdxPopoverRootDirective,
    RdxPopoverAnchorDirective,
    RdxPopoverContentAttributesComponent
];

@NgModule({
    imports: [..._imports],
    exports: [..._imports]
})
export class RdxPopoverModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/stories/popover-anchor.component.ts
```typescript
import { Component, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { LucideAngularModule, MapPin, MapPinPlus, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxPopoverModule } from '../index';
import { RdxPopoverAnchorDirective } from '../src/popover-anchor.directive';
import { RdxPopoverContentAttributesComponent } from '../src/popover-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-popover-anchor',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxPopoverModule,
        LucideAngularModule,
        RdxPopoverContentAttributesComponent,
        WithOptionPanelComponent,
        RdxPopoverAnchorDirective
    ],
    styles: styles(),
    template: `
        <p class="ExampleSubtitle">Internal Anchor (within PopoverRoot)</p>
        <popover-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container #root1="rdxPopoverRoot" rdxPopoverRoot>
                    <button class="reset IconButton InternalAnchor" rdxPopoverAnchor>
                        <lucide-angular [img]="LucideMapPinPlusInside" size="16" style="display: flex" />
                    </button>

                    <button class="reset IconButton" rdxPopoverTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxPopoverContent
                    >
                        <div class="PopoverContent" rdxPopoverContentAttributes>
                            <div style="display: flex; flex-direction: column; gap: 10px">
                                <p class="Text" style="margin-bottom: 10px">Dimensions</p>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="width">Width</label>
                                    <input class="reset Input" id="width" value="100%" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxWidth">Max. width</label>
                                    <input class="reset Input" id="maxWidth" value="300px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="height">Height</label>
                                    <input class="reset Input" id="height" value="25px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxHeight">Max. height</label>
                                    <input class="reset Input" id="maxHeight" value="none" />
                                </fieldset>
                            </div>
                            <button class="reset PopoverClose" rdxPopoverClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div
                                class="PopoverArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxPopoverArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="PopoverId">ID: {{ popoverRootDirective1()?.uniqueId() }}</div>
        </popover-with-option-panel>

        <p class="ExampleSubtitle">External Anchor (outside PopoverRoot)</p>
        <popover-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <button class="reset IconButton ExternalAnchor" #externalAnchor="rdxPopoverAnchor" rdxPopoverAnchor>
                    <lucide-angular [img]="LucideMapPinPlus" size="16" style="display: flex" />
                </button>

                <ng-container #root2="rdxPopoverRoot" [anchor]="externalAnchor" rdxPopoverRoot>
                    <button class="reset IconButton" rdxPopoverTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxPopoverContent
                    >
                        <div class="PopoverContent" rdxPopoverContentAttributes>
                            <button class="reset PopoverClose" rdxPopoverClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div style="display: flex; flex-direction: column; gap: 10px">
                                <p class="Text" style="margin-bottom: 10px">Dimensions</p>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="width">Width</label>
                                    <input class="reset Input" id="width" value="100%" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxWidth">Max. width</label>
                                    <input class="reset Input" id="maxWidth" value="300px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="height">Height</label>
                                    <input class="reset Input" id="height" value="25px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxHeight">Max. height</label>
                                    <input class="reset Input" id="maxHeight" value="none" />
                                </fieldset>
                            </div>
                            <div
                                class="PopoverArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxPopoverArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="PopoverId">ID: {{ popoverRootDirective2()?.uniqueId() }}</div>
        </popover-with-option-panel>
    `
})
export class RdxPopoverAnchorComponent extends OptionPanelBase {
    readonly popoverRootDirective1 = viewChild('root1');
    readonly popoverRootDirective2 = viewChild('root2');

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;
    readonly LucideMapPinPlusInside = MapPinPlus;
    readonly LucideMapPinPlus = MapPin;
    readonly TriangleAlert = TriangleAlert;
    readonly containerAlert = containerAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/stories/popover-animations.component.ts
```typescript
import { Component, signal, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { RdxPositionAlign, RdxPositionSide } from '@radix-ng/primitives/core';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxPopoverModule, RdxPopoverRootDirective } from '../index';
import { RdxPopoverContentAttributesComponent } from '../src/popover-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-popover-animations',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxPopoverModule,
        LucideAngularModule,
        RdxPopoverContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: styles(true),
    template: `
        <popover-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
        >
            <div class="ParamsContainer">
                <input [ngModel]="cssAnimation()" (ngModelChange)="cssAnimation.set($event)" type="checkbox" />
                CSS Animation
                <input
                    [ngModel]="cssOpeningAnimation()"
                    (ngModelChange)="cssOpeningAnimation.set($event)"
                    type="checkbox"
                />
                On Opening Animation
                <input
                    [ngModel]="cssClosingAnimation()"
                    (ngModelChange)="cssClosingAnimation.set($event)"
                    type="checkbox"
                />
                On Closing Animation
            </div>

            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container
                    [cssAnimation]="cssAnimation()"
                    [cssOpeningAnimation]="cssOpeningAnimation()"
                    [cssClosingAnimation]="cssClosingAnimation()"
                    rdxPopoverRoot
                >
                    <button class="IconButton reset" rdxPopoverTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxPopoverContent
                    >
                        <div class="PopoverContent" rdxPopoverContentAttributes>
                            <div style="display: flex; flex-direction: column; gap: 10px">
                                <p class="Text" style="margin-bottom: 10px">Dimensions</p>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="width">Width</label>
                                    <input class="reset Input" id="width" value="100%" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxWidth">Max. width</label>
                                    <input class="reset Input" id="maxWidth" value="300px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="height">Height</label>
                                    <input class="reset Input" id="height" value="25px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxHeight">Max. height</label>
                                    <input class="reset Input" id="maxHeight" value="none" />
                                </fieldset>
                            </div>
                            <button class="PopoverClose reset" rdxPopoverClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div
                                class="PopoverArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxPopoverArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="PopoverId">ID: {{ popoverRootDirective()?.uniqueId() }}</div>
        </popover-with-option-panel>
    `
})
export class RdxPopoverAnimationsComponent extends OptionPanelBase {
    readonly popoverRootDirective = viewChild(RdxPopoverRootDirective);

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;

    readonly sides = RdxPositionSide;
    readonly aligns = RdxPositionAlign;

    cssAnimation = signal<boolean>(true);
    cssOpeningAnimation = signal(true);
    cssClosingAnimation = signal(true);
    protected readonly TriangleAlert = TriangleAlert;
    protected readonly containerAlert = containerAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/stories/popover-default.component.ts
```typescript
import { Component, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxPopoverModule, RdxPopoverRootDirective } from '../index';
import { RdxPopoverContentAttributesComponent } from '../src/popover-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-popover-default',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxPopoverModule,
        LucideAngularModule,
        RdxPopoverContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: styles(),
    template: `
        <popover-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container rdxPopoverRoot>
                    <button class="reset IconButton" rdxPopoverTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxPopoverContent
                    >
                        <div class="PopoverContent" rdxPopoverContentAttributes>
                            <div style="display: flex; flex-direction: column; gap: 10px">
                                <p class="Text" style="margin-bottom: 10px">Dimensions</p>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="width">Width</label>
                                    <input class="reset Input" id="width" value="100%" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxWidth">Max. width</label>
                                    <input class="reset Input" id="maxWidth" value="300px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="height">Height</label>
                                    <input class="reset Input" id="height" value="25px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxHeight">Max. height</label>
                                    <input class="reset Input" id="maxHeight" value="none" />
                                </fieldset>
                            </div>
                            <button class="reset PopoverClose" rdxPopoverClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div
                                class="PopoverArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxPopoverArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="PopoverId">ID: {{ popoverRootDirective()?.uniqueId() }}</div>
        </popover-with-option-panel>
    `
})
export class RdxPopoverDefaultComponent extends OptionPanelBase {
    readonly popoverRootDirective = viewChild(RdxPopoverRootDirective);

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;
    protected readonly TriangleAlert = TriangleAlert;
    protected readonly containerAlert = containerAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/stories/popover-events.components.ts
```typescript
import { Component, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { RdxPositionAlign, RdxPositionSide } from '@radix-ng/primitives/core';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxPopoverModule, RdxPopoverRootDirective } from '../index';
import { RdxPopoverContentAttributesComponent } from '../src/popover-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-popover-events',
    providers: [provideRdxCdkEventService()],
    imports: [
        RdxPopoverModule,
        LucideAngularModule,
        FormsModule,
        RdxPopoverContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: `
        ${styles()}
    `,
    template: `
        <popover-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container rdxPopoverRoot>
                    <button class="reset IconButton" rdxPopoverTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        [sideOffset]="8"
                        rdxPopoverContent
                    >
                        <div class="PopoverContent" rdxPopoverContentAttributes>
                            <div style="display: flex; flex-direction: column; gap: 10px">
                                <p class="Text" style="margin-bottom: 10px">Dimensions</p>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="width">Width</label>
                                    <input class="reset Input" id="width" value="100%" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxWidth">Max. width</label>
                                    <input class="reset Input" id="maxWidth" value="300px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="height">Height</label>
                                    <input class="reset Input" id="height" value="25px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxHeight">Max. height</label>
                                    <input class="reset Input" id="maxHeight" value="none" />
                                </fieldset>
                            </div>
                            <button class="reset PopoverClose" rdxPopoverClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div
                                class="PopoverArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxPopoverArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="PopoverId">ID: {{ popoverRootDirective()?.uniqueId() }}</div>
        </popover-with-option-panel>
    `
})
export class RdxPopoverEventsComponent extends OptionPanelBase {
    readonly popoverRootDirective = viewChild(RdxPopoverRootDirective);

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;

    protected readonly sides = RdxPositionSide;
    protected readonly aligns = RdxPositionAlign;
    protected readonly containerAlert = containerAlert;
    protected readonly TriangleAlert = TriangleAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/stories/popover-initial-focus.component.ts
```typescript
import { Component, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { RdxFocusInitialDirective } from '@radix-ng/primitives/core';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxPopoverModule, RdxPopoverRootDirective } from '../index';
import { RdxPopoverContentAttributesComponent } from '../src/popover-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-popover-initial-focus',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxPopoverModule,
        LucideAngularModule,
        RdxPopoverContentAttributesComponent,
        WithOptionPanelComponent,
        RdxFocusInitialDirective
    ],
    styles: styles(),
    template: `
        <popover-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                <span>
                    To change the element that will first receive focus inside a popover, use the
                    <code>rdxFocusInitial</code>
                    directive.
                </span>
            </div>
            <div class="container">
                <ng-container rdxPopoverRoot>
                    <button class="reset IconButton" rdxPopoverTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        [sideOffset]="8"
                        rdxPopoverContent
                    >
                        <div class="PopoverContent" rdxPopoverContentAttributes>
                            <div style="display: flex; flex-direction: column; gap: 10px">
                                <p class="Text" style="margin-bottom: 10px">Dimensions</p>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="width">Width</label>
                                    <input class="reset Input" id="width" value="100%" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxWidth">Max. width (Initial focus)</label>
                                    <input class="reset Input" id="maxWidth" value="300px" rdxFocusInitial />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="height">Height</label>
                                    <input class="reset Input" id="height" value="25px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxHeight">Max. height</label>
                                    <input class="reset Input" id="maxHeight" value="none" />
                                </fieldset>
                            </div>
                            <button class="reset PopoverClose" rdxPopoverClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div
                                class="PopoverArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxPopoverArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="PopoverId">ID: {{ popoverRootDirective()?.uniqueId() }}</div>
        </popover-with-option-panel>
    `
})
export class RdxPopoverInitialFocusComponent extends OptionPanelBase {
    readonly popoverRootDirective = viewChild(RdxPopoverRootDirective);

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;
    protected readonly containerAlert = containerAlert;
    protected readonly TriangleAlert = TriangleAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/stories/popover-initially-open.component.ts
```typescript
import { Component, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxPopoverModule, RdxPopoverRootDirective } from '../index';
import { RdxPopoverContentAttributesComponent } from '../src/popover-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-popover-initially-open',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxPopoverModule,
        LucideAngularModule,
        RdxPopoverContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: styles(),
    template: `
        <popover-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container [defaultOpen]="true" rdxPopoverRoot>
                    <button class="reset IconButton" rdxPopoverTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        [sideOffset]="8"
                        rdxPopoverContent
                    >
                        <div class="PopoverContent" rdxPopoverContentAttributes>
                            <div style="display: flex; flex-direction: column; gap: 10px">
                                <p class="Text" style="margin-bottom: 10px">Dimensions</p>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="width">Width</label>
                                    <input class="reset Input" id="width" value="100%" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxWidth">Max. width</label>
                                    <input class="reset Input" id="maxWidth" value="300px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="height">Height</label>
                                    <input class="reset Input" id="height" value="25px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxHeight">Max. height</label>
                                    <input class="reset Input" id="maxHeight" value="none" />
                                </fieldset>
                            </div>
                            <button class="reset PopoverClose" rdxPopoverClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div
                                class="PopoverArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxPopoverArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="PopoverId">ID: {{ popoverRootDirective()?.uniqueId() }}</div>
        </popover-with-option-panel>
    `
})
export class RdxPopoverInitiallyOpenComponent extends OptionPanelBase {
    readonly popoverRootDirective = viewChild(RdxPopoverRootDirective);

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;
    protected readonly containerAlert = containerAlert;
    protected readonly TriangleAlert = TriangleAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/stories/popover-multiple.component.ts
```typescript
import { Component, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { RdxPositionAlign, RdxPositionSide } from '@radix-ng/primitives/core';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxPopoverModule } from '../index';
import { RdxPopoverContentAttributesComponent } from '../src/popover-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-popover-multiple',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxPopoverModule,
        LucideAngularModule,
        RdxPopoverContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: styles(),
    template: `
        <p class="ExampleSubtitle">Popover #1</p>
        <popover-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container #root1="rdxPopoverRoot" rdxPopoverRoot>
                    <button class="reset IconButton" rdxPopoverTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxPopoverContent
                    >
                        <div class="PopoverContent" rdxPopoverContentAttributes>
                            <div style="display: flex; flex-direction: column; gap: 10px">
                                <p class="Text" style="margin-bottom: 10px">Dimensions</p>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="width">Width</label>
                                    <input class="reset Input" id="width" value="100%" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxWidth">Max. width</label>
                                    <input class="reset Input" id="maxWidth" value="300px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="height">Height</label>
                                    <input class="reset Input" id="height" value="25px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxHeight">Max. height</label>
                                    <input class="reset Input" id="maxHeight" value="none" />
                                </fieldset>
                            </div>
                            <button class="reset PopoverClose" rdxPopoverClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div
                                class="PopoverArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxPopoverArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="PopoverId">ID: {{ popoverRootDirective1()?.uniqueId() }}</div>
        </popover-with-option-panel>

        <p class="ExampleSubtitle">Popover #2</p>
        <popover-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                <code>[side]="'left'"</code>
                <code>[align]="'start'"</code>
                <code>[sideOffset]="16"</code>
                <code>[alignOffset]="16"</code>
            </div>
            <div class="container">
                <ng-container #root2="rdxPopoverRoot" rdxPopoverRoot>
                    <button class="reset IconButton" rdxPopoverTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [side]="RdxPopoverSide.Left"
                        [align]="RdxPopoverAlign.Start"
                        [sideOffset]="16"
                        [alignOffset]="16"
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxPopoverContent
                    >
                        <div class="PopoverContent" rdxPopoverContentAttributes>
                            <div style="display: flex; flex-direction: column; gap: 10px">
                                <p class="Text" style="margin-bottom: 10px">Dimensions</p>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="width">Width</label>
                                    <input class="reset Input" id="width" value="100%" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxWidth">Max. width</label>
                                    <input class="reset Input" id="maxWidth" value="300px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="height">Height</label>
                                    <input class="reset Input" id="height" value="25px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxHeight">Max. height</label>
                                    <input class="reset Input" id="maxHeight" value="none" />
                                </fieldset>
                            </div>
                            <button class="reset PopoverClose" rdxPopoverClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div
                                class="PopoverArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxPopoverArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="PopoverId">ID: {{ popoverRootDirective2()?.uniqueId() }}</div>
        </popover-with-option-panel>

        <p class="ExampleSubtitle">Popover #3</p>
        <popover-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
        >
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                <code>[side]="'right'"</code>
                <code>[align]="'end'"</code>
                <code>[sideOffset]="60"</code>
                <code>[alignOffset]="60"</code>
            </div>
            <div class="container">
                <ng-container #root3="rdxPopoverRoot" rdxPopoverRoot>
                    <button class="reset IconButton" rdxPopoverTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [side]="RdxPopoverSide.Right"
                        [align]="RdxPopoverAlign.End"
                        [sideOffset]="60"
                        [alignOffset]="60"
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxPopoverContent
                    >
                        <div class="PopoverContent" rdxPopoverContentAttributes>
                            <div style="display: flex; flex-direction: column; gap: 10px">
                                <p class="Text" style="margin-bottom: 10px">Dimensions</p>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="width">Width</label>
                                    <input class="reset Input" id="width" value="100%" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxWidth">Max. width</label>
                                    <input class="reset Input" id="maxWidth" value="300px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="height">Height</label>
                                    <input class="reset Input" id="height" value="25px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxHeight">Max. height</label>
                                    <input class="reset Input" id="maxHeight" value="none" />
                                </fieldset>
                            </div>
                            <button class="reset PopoverClose" rdxPopoverClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div
                                class="PopoverArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxPopoverArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="PopoverId">ID: {{ popoverRootDirective3()?.uniqueId() }}</div>
        </popover-with-option-panel>
    `
})
export class RdxPopoverMultipleComponent extends OptionPanelBase {
    readonly popoverRootDirective1 = viewChild('root1');
    readonly popoverRootDirective2 = viewChild('root2');
    readonly popoverRootDirective3 = viewChild('root3');

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;
    readonly RdxPopoverSide = RdxPositionSide;
    readonly RdxPopoverAlign = RdxPositionAlign;
    protected readonly containerAlert = containerAlert;
    protected readonly TriangleAlert = TriangleAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/stories/popover-positioning.component.ts
```typescript
import { Component, signal, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { RdxPositionAlign, RdxPositionSide } from '@radix-ng/primitives/core';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxPopoverModule, RdxPopoverRootDirective } from '../index';
import { RdxPopoverContentAttributesComponent } from '../src/popover-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-popover-positioning',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxPopoverModule,
        LucideAngularModule,
        RdxPopoverContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: styles(),
    template: `
        <popover-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
        >
            <div class="ParamsContainer">
                Side:
                <select [ngModel]="selectedSide()" (ngModelChange)="selectedSide.set($event)">
                    <option [value]="sides.Top">{{ sides.Top }}</option>
                    <option [value]="sides.Bottom">{{ sides.Bottom }}</option>
                    <option [value]="sides.Left">{{ sides.Left }}</option>
                    <option [value]="sides.Right">{{ sides.Right }}</option>
                </select>
                Align:
                <select [ngModel]="selectedAlign()" (ngModelChange)="selectedAlign.set($event)">
                    <option [value]="aligns.Center">{{ aligns.Center }}</option>
                    <option [value]="aligns.Start">{{ aligns.Start }}</option>
                    <option [value]="aligns.End">{{ aligns.End }}</option>
                </select>
                SideOffset:
                <input [ngModel]="sideOffset()" (ngModelChange)="sideOffset.set($event)" type="number" />
                AlignOffset:
                <input [ngModel]="alignOffset()" (ngModelChange)="alignOffset.set($event)" type="number" />
            </div>

            <div class="ParamsContainer">
                <input
                    [ngModel]="disableAlternatePositions()"
                    (ngModelChange)="disableAlternatePositions.set($event)"
                    type="checkbox"
                />
                Disable alternate positions (to see the result, scroll the page to make the popover cross the viewport
                boundary)
            </div>

            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container rdxPopoverRoot>
                    <button class="reset IconButton" rdxPopoverTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [sideOffset]="sideOffset()"
                        [alignOffset]="alignOffset()"
                        [side]="selectedSide()"
                        [align]="selectedAlign()"
                        [alternatePositionsDisabled]="disableAlternatePositions()"
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        rdxPopoverContent
                    >
                        <div class="PopoverContent" rdxPopoverContentAttributes>
                            <div style="display: flex; flex-direction: column; gap: 10px">
                                <p class="Text" style="margin-bottom: 10px">Dimensions</p>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="width">Width</label>
                                    <input class="reset Input" id="width" value="100%" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxWidth">Max. width</label>
                                    <input class="reset Input" id="maxWidth" value="300px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="height">Height</label>
                                    <input class="reset Input" id="height" value="25px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxHeight">Max. height</label>
                                    <input class="reset Input" id="maxHeight" value="none" />
                                </fieldset>
                            </div>
                            <button class="reset PopoverClose" rdxPopoverClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div
                                class="PopoverArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxPopoverArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="PopoverId">ID: {{ popoverRootDirective()?.uniqueId() }}</div>
        </popover-with-option-panel>
    `
})
export class RdxPopoverPositioningComponent extends OptionPanelBase {
    readonly popoverRootDirective = viewChild(RdxPopoverRootDirective);

    readonly selectedSide = signal(RdxPositionSide.Top);
    readonly selectedAlign = signal(RdxPositionAlign.Center);
    readonly sideOffset = signal<number | undefined>(void 0);
    readonly alignOffset = signal<number | undefined>(void 0);
    readonly disableAlternatePositions = signal(false);

    readonly sides = RdxPositionSide;
    readonly aligns = RdxPositionAlign;

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;
    protected readonly containerAlert = containerAlert;
    protected readonly TriangleAlert = TriangleAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/stories/popover-triggering.component.ts
```typescript
import { Component, signal, viewChild } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { LucideAngularModule, MountainSnow, TriangleAlert, X } from 'lucide-angular';
import { RdxPopoverModule } from '../index';
import { RdxPopoverContentAttributesComponent } from '../src/popover-content-attributes.component';
import { provideRdxCdkEventService } from '../src/utils/cdk-event.service';
import { containerAlert } from './utils/constants';
import { OptionPanelBase } from './utils/option-panel-base.class';
import styles from './utils/styles.constants';
import { WithOptionPanelComponent } from './utils/with-option-panel.component';

@Component({
    selector: 'rdx-popover-triggering',
    providers: [provideRdxCdkEventService()],
    imports: [
        FormsModule,
        RdxPopoverModule,
        LucideAngularModule,
        RdxPopoverContentAttributesComponent,
        WithOptionPanelComponent
    ],
    styles: styles(),
    template: `
        <p class="ExampleSubtitle">Initially closed</p>
        <popover-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
        >
            <div class="ParamsContainer">
                <button (mouseup)="triggerOpenFalse()" type="button">Open: {{ isOpenFalse() }}</button>
                onOpenChange count: {{ counterOpenFalse() }}
            </div>

            <div class="ParamsContainer">
                <input
                    [ngModel]="externalControlFalse()"
                    (ngModelChange)="externalControlFalse.set($event)"
                    type="checkbox"
                />
                External control
            </div>

            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container
                    #root1="rdxPopoverRoot"
                    [open]="isOpenFalse()"
                    [externalControl]="externalControlFalse()"
                    rdxPopoverRoot
                >
                    <button class="reset IconButton" rdxPopoverTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [sideOffset]="8"
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        (onOpen)="countOpenFalse(true)"
                        (onClosed)="countOpenFalse(false)"
                        rdxPopoverContent
                    >
                        <div class="PopoverContent" rdxPopoverContentAttributes>
                            <div style="display: flex; flex-direction: column; gap: 10px">
                                <p class="Text" style="margin-bottom: 10px">Dimensions</p>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="width">Width</label>
                                    <input class="reset Input" id="width" value="100%" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxWidth">Max. width</label>
                                    <input class="reset Input" id="maxWidth" value="300px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="height">Height</label>
                                    <input class="reset Input" id="height" value="25px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxHeight">Max. height</label>
                                    <input class="reset Input" id="maxHeight" value="none" />
                                </fieldset>
                            </div>
                            <button class="reset PopoverClose" rdxPopoverClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div
                                class="PopoverArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxPopoverArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="PopoverId">ID: {{ popoverRootDirective1()?.uniqueId() }}</div>
        </popover-with-option-panel>

        <p class="ExampleSubtitle">Initially open</p>
        <popover-with-option-panel
            [arrowWidth]="arrowWidth()"
            [arrowHeight]="arrowHeight()"
            (onOverlayEscapeKeyDownDisabledChange)="onOverlayEscapeKeyDownDisabled.set($event)"
            (onOverlayOutsideClickDisabledChange)="onOverlayOutsideClickDisabled.set($event)"
            (arrowWidthChange)="arrowWidth.set($event)"
            (arrowHeightChange)="arrowHeight.set($event)"
        >
            <div class="ParamsContainer">
                <button (mouseup)="triggerOpenTrue()" type="button">Open: {{ isOpenTrue() }}</button>
                <span>onOpenChange count: {{ counterOpenTrue() }}</span>
            </div>

            <div class="ParamsContainer">
                <input
                    [ngModel]="externalControlTrue()"
                    (ngModelChange)="externalControlTrue.set($event)"
                    type="checkbox"
                />
                External control
            </div>

            <div class="ContainerAlerts">
                <lucide-angular [img]="TriangleAlert" size="16" />
                {{ containerAlert }}
            </div>
            <div class="container">
                <ng-container
                    #root2="rdxPopoverRoot"
                    [open]="isOpenTrue()"
                    [externalControl]="externalControlTrue()"
                    rdxPopoverRoot
                >
                    <button class="reset IconButton" rdxPopoverTrigger>
                        <lucide-angular [img]="MountainSnowIcon" size="16" style="display: flex" />
                    </button>

                    <ng-template
                        [sideOffset]="8"
                        [onOverlayEscapeKeyDownDisabled]="onOverlayEscapeKeyDownDisabled()"
                        [onOverlayOutsideClickDisabled]="onOverlayOutsideClickDisabled()"
                        (onOpen)="countOpenTrue(true)"
                        (onClosed)="countOpenTrue(false)"
                        rdxPopoverContent
                    >
                        <div class="PopoverContent" rdxPopoverContentAttributes>
                            <button class="reset PopoverClose" rdxPopoverClose aria-label="Close">
                                <lucide-angular [img]="XIcon" size="16" style="display: flex" />
                            </button>
                            <div style="display: flex; flex-direction: column; gap: 10px">
                                <p class="Text" style="margin-bottom: 10px">Dimensions</p>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="width">Width</label>
                                    <input class="reset Input" id="width" value="100%" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxWidth">Max. width</label>
                                    <input class="reset Input" id="maxWidth" value="300px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="height">Height</label>
                                    <input class="reset Input" id="height" value="25px" />
                                </fieldset>
                                <fieldset class="reset Fieldset">
                                    <label class="Label" for="maxHeight">Max. height</label>
                                    <input class="reset Input" id="maxHeight" value="none" />
                                </fieldset>
                            </div>
                            <div
                                class="PopoverArrow"
                                [width]="arrowWidth()"
                                [height]="arrowHeight()"
                                rdxPopoverArrow
                            ></div>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
            <div class="PopoverId">ID: {{ popoverRootDirective2()?.uniqueId() }}</div>
        </popover-with-option-panel>
    `
})
export class RdxPopoverTriggeringComponent extends OptionPanelBase {
    readonly popoverRootDirective1 = viewChild('root1');
    readonly popoverRootDirective2 = viewChild('root2');

    readonly MountainSnowIcon = MountainSnow;
    readonly XIcon = X;

    isOpenFalse = signal(false);
    counterOpenFalse = signal(0);
    externalControlFalse = signal(true);

    isOpenTrue = signal(true);
    counterOpenTrue = signal(0);
    externalControlTrue = signal(true);

    triggerOpenFalse(): void {
        this.isOpenFalse.update((value) => !value);
    }

    countOpenFalse(open: boolean): void {
        this.isOpenFalse.set(open);
        this.counterOpenFalse.update((value) => value + 1);
    }

    triggerOpenTrue(): void {
        this.isOpenTrue.update((value) => !value);
    }

    countOpenTrue(open: boolean): void {
        this.isOpenTrue.set(open);
        this.counterOpenTrue.update((value) => value + 1);
    }

    protected readonly containerAlert = containerAlert;
    protected readonly TriangleAlert = TriangleAlert;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/stories/popover.docs.mdx
````
import {ArgTypes, Canvas, Markdown, Meta, Source} from '@storybook/blocks';
import * as PopoverStories from "./popover.stories";
import {RdxPopoverRootDirective} from "../src/popover-root.directive";
import {RdxPopoverContentDirective} from "../src/popover-content.directive";
import {RdxPopoverArrowDirective} from "../src/popover-arrow.directive";
import {RdxPopoverAnchorDirective} from "../src/popover-anchor.directive";
import {RdxPopoverTriggerDirective} from "../src/popover-trigger.directive";
import {RdxPopoverCloseDirective} from "../src/popover-close.directive";
import {animationStylesOnly} from "./utils/styles.constants";
import {RdxPopoverContentAttributesComponent} from "../src/popover-content-attributes.component";

<Meta title="Primitives/Popover" />

# Popover

#### Displays rich content in a portal, triggered by a button.

<br />
<br />

## Examples
### Default

<Canvas sourceState="hidden" of={PopoverStories.Default} />

### Multiple

<Canvas sourceState="hidden" of={PopoverStories.Multiple} />

### Events

<Canvas sourceState="hidden" of={PopoverStories.Events} />

### Positioning

<Canvas sourceState="hidden" of={PopoverStories.Positioning} />

### External Triggering

<Canvas sourceState="hidden" of={PopoverStories.ExternalTriggering} />

### Anchor

<Canvas sourceState="hidden" of={PopoverStories.Anchor} />

### Initially Open

<Canvas sourceState="hidden" of={PopoverStories.InitiallyOpen} />

### Initial focus

<Canvas sourceState="hidden" of={PopoverStories.InitialFocus} />

### Animations

<Canvas sourceState="hidden" of={PopoverStories.Animations} />

### Animation Styles

<Source type="code" language="css" code={`${animationStylesOnly}`} />


## Features

- âœ… Opens when the trigger is clicked.
- âœ… Closes when the trigger is clicked again or when pressing escape.
- âœ… Controllable from outside.
- âœ… Focus is automatically trapped inside popover.
- âœ… It is possible to determine which element receives focus first by `rdxFocusInitial` directive.

## Anatomy

```html
<ng-container rdxPopoverRoot>
    <button class="IconButton" rdxPopoverTrigger>+</button>

    <ng-template rdxPopoverContent>
        <div class="PopoverContent" rdxPopoverContentAttributes>
            <button class="PopoverClose" rdxPopoverClose aria-label="Close">X</button>
            Popover Content
            <div class="PopoverArrow" rdxPopoverArrow></div>
        </div>
    </ng-template>
</ng-container>
```

## Import

Get started with importing the directives:

<Source type="code" language="typescript" code={`import {
  RdxPopoverRootDirective,
  RdxPopoverRootTrigger,
  RdxPopoverContentDirective,
  RdxPopoverArrowDirective,
  RdxPopoverAnchorDirective,
  RdxPopoverCloseDirective
} from '@radix-ng/primitives/popover';`} />

or

<Source type="code" language="typescript" code={`import { RdxPopoverModule } from '@radix-ng/primitives/popover';`} />

## API Reference

### Root
`RdxPopoverRootDirective`

Contains all the parts of a popover.

<ArgTypes of={RdxPopoverRootDirective} />

### Trigger
`RdxPopoverTriggerDirective`

The button that toggles the popover. By default, the PopoverContent will position itself against the trigger.

<Markdown>
{`
| Data attribute | Value          |
|----------------|----------------|
| [data-state]   | <code>"closed" | "open" (type RdxPopoverState)</code>
`}
</Markdown>

### Anchor
`RdxPopoverAnchorDirective`

An optional element to position the PopoverContent against. If this part is not used, the content will position alongside the PopoverTrigger.

### Content
`RdxPopoverContentDirective`

The component that pops out when the popover is open.

<ArgTypes of={RdxPopoverContentDirective} />

### Content Attributes
`RdxPopoverContentAttributesComponent`

A component with the content attributes that are necessary to run animations.

<ArgTypes of={RdxPopoverContentAttributesComponent} />

<Markdown>
{`
| Data attribute | Value          |
|----------------|----------------|
| [data-state]   | <code>"closed" | "open" (enum RdxPopoverState)</code>
| [data-side]    | <code>"left"   | "right" | "bottom" | "top" (enum RdxPositionSide)</code>
| [data-align]   | <code>"start"  | "end" | "center" (enum RdxPositionAlign)</code>
`}
</Markdown>

### Arrow
`RdxPopoverArrowDirective`

An optional arrow element to render alongside the popover. This can be used to help visually link the trigger with the PopoverContent. Must be rendered inside PopoverContent.

<ArgTypes of={RdxPopoverArrowDirective} />

### Close
`RdxPopoverCloseDirective`

An optional close button element to render alongside the popover. This can be used to close the PopoverContent. Must be rendered inside PopoverContent.

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/stories/popover.stories.ts
```typescript
import { provideAnimations } from '@angular/platform-browser/animations';
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { LucideAngularModule, MountainSnow, X } from 'lucide-angular';
import { RdxPopoverModule } from '../index';
import { RdxPopoverAnchorComponent } from './popover-anchor.component';
import { RdxPopoverAnimationsComponent } from './popover-animations.component';
import { RdxPopoverDefaultComponent } from './popover-default.component';
import { RdxPopoverEventsComponent } from './popover-events.components';
import { RdxPopoverInitialFocusComponent } from './popover-initial-focus.component';
import { RdxPopoverInitiallyOpenComponent } from './popover-initially-open.component';
import { RdxPopoverMultipleComponent } from './popover-multiple.component';
import { RdxPopoverPositioningComponent } from './popover-positioning.component';
import { RdxPopoverTriggeringComponent } from './popover-triggering.component';

const html = String.raw;

export default {
    title: 'Primitives/Popover',
    decorators: [
        moduleMetadata({
            imports: [
                RdxPopoverModule,
                RdxPopoverDefaultComponent,
                RdxPopoverEventsComponent,
                RdxPopoverPositioningComponent,
                RdxPopoverTriggeringComponent,
                RdxPopoverMultipleComponent,
                RdxPopoverAnimationsComponent,
                RdxPopoverInitiallyOpenComponent,
                RdxPopoverInitialFocusComponent,
                RdxPopoverAnchorComponent,
                LucideAngularModule,
                LucideAngularModule.pick({ MountainSnow, X })
            ],
            providers: [provideAnimations()]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div
                    class="radix-themes light light-theme radix-themes-default-fonts"
                    data-accent-color="indigo"
                    data-radius="medium"
                    data-scaling="100%"
                >
                    ${story}
                </div>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: html`
            <rdx-popover-default></rdx-popover-default>
        `
    })
};

export const Multiple: Story = {
    render: () => ({
        template: html`
            <rdx-popover-multiple></rdx-popover-multiple>
        `
    })
};

export const Events: Story = {
    render: () => ({
        template: html`
            <rdx-popover-events></rdx-popover-events>
        `
    })
};

export const Positioning: Story = {
    render: () => ({
        template: html`
            <rdx-popover-positioning></rdx-popover-positioning>
        `
    })
};

export const ExternalTriggering: Story = {
    render: () => ({
        template: html`
            <rdx-popover-triggering></rdx-popover-triggering>
        `
    })
};

export const Anchor: Story = {
    render: () => ({
        template: html`
            <rdx-popover-anchor></rdx-popover-anchor>
        `
    })
};

export const InitiallyOpen: Story = {
    render: () => ({
        template: html`
            <rdx-popover-initially-open></rdx-popover-initially-open>
        `
    })
};

export const InitialFocus: Story = {
    render: () => ({
        template: html`
            <rdx-popover-initial-focus></rdx-popover-initial-focus>
        `
    })
};

export const Animations: Story = {
    render: () => ({
        template: html`
            <rdx-popover-animations></rdx-popover-animations>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/stories/utils/constants.ts
```typescript
export const containerAlert =
    'For the sake of option panels to play with the stories, the "onOverlayEscapeKeyDown" & "onOverlayOutsideClick" events are limited to the area inside the rectangle marked with a dashed line - the events work when the area is active (focused)';

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/stories/utils/containers.registry.ts
```typescript
import { isDevMode } from '@angular/core';
import { RdxPopoverRootDirective } from '../../src/popover-root.directive';
import { injectRdxCdkEventService } from '../../src/utils/cdk-event.service';

const containerRegistry: Map<HTMLElement, RdxPopoverRootDirective> = new Map();
let rdxCdkEventService: ReturnType<typeof injectRdxCdkEventService> | undefined = void 0;

const domRootClickEventCallback: (event: MouseEvent) => void = (event: MouseEvent) => {
    const target = event.target as HTMLElement;
    const containers = Array.from(containerRegistry.keys());
    const containerContainingTarget = containers
        .map((container) => {
            container.classList.remove('focused');
            return container;
        })
        .find((container) => {
            return container.contains(target);
        });
    containerContainingTarget?.classList.add('focused');
    Array.from(containerRegistry.entries()).forEach((item) => {
        if (item[0] === containerContainingTarget) {
            rdxCdkEventService?.allowPrimitiveForCdkMultiEvents(item[1], [
                'cdkOverlayOutsideClick',
                'cdkOverlayEscapeKeyDown'
            ]);
        } else {
            rdxCdkEventService?.preventPrimitiveFromCdkMultiEvents(item[1], [
                'cdkOverlayOutsideClick',
                'cdkOverlayEscapeKeyDown'
            ]);
        }
    });
};

export function registerContainer(container: HTMLElement, popoverRoot: RdxPopoverRootDirective) {
    if (containerRegistry.has(container)) {
        return;
    }
    containerRegistry.set(container, popoverRoot);
    if (containerRegistry.size === 1) {
        rdxCdkEventService?.addClickDomRootEventCallback(domRootClickEventCallback);
    }
}

export function deregisterContainer(container: HTMLElement) {
    if (!containerRegistry.has(container)) {
        return;
    }
    containerRegistry.delete(container);
    if (containerRegistry.size === 0) {
        rdxCdkEventService?.removeClickDomRootEventCallback(domRootClickEventCallback);
        unsetRdxCdkEventService();
    }
}

export function setRdxCdkEventService(service: typeof rdxCdkEventService) {
    isDevMode() && console.log('setRdxCdkEventService', service, rdxCdkEventService === service);
    rdxCdkEventService ??= service;
}

export function unsetRdxCdkEventService() {
    rdxCdkEventService = void 0;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/stories/utils/option-panel-base.class.ts
```typescript
import { afterNextRender, DestroyRef, Directive, ElementRef, inject, signal, viewChildren } from '@angular/core';
import { injectDocument, RDX_POSITIONING_DEFAULTS } from '@radix-ng/primitives/core';
import { RdxPopoverRootDirective } from '../../src/popover-root.directive';
import { injectRdxCdkEventService } from '../../src/utils/cdk-event.service';
import { deregisterContainer, registerContainer, setRdxCdkEventService } from './containers.registry';
import { IArrowDimensions, IIgnoreClickOutsideContainer } from './types';

@Directive()
export abstract class OptionPanelBase implements IIgnoreClickOutsideContainer, IArrowDimensions {
    onOverlayEscapeKeyDownDisabled = signal(false);
    onOverlayOutsideClickDisabled = signal(false);

    arrowWidth = signal(RDX_POSITIONING_DEFAULTS.arrow.width);
    arrowHeight = signal(RDX_POSITIONING_DEFAULTS.arrow.height);

    readonly elementRef = inject<ElementRef<HTMLElement>>(ElementRef);
    readonly destroyRef = inject(DestroyRef);
    readonly rootDirectives = viewChildren(RdxPopoverRootDirective);
    readonly document = injectDocument();
    readonly rdxCdkEventService = injectRdxCdkEventService();

    protected constructor() {
        afterNextRender(() => {
            this.elementRef.nativeElement.querySelectorAll<HTMLElement>('.container').forEach((container) => {
                const popoverRootInsideContainer = this.rootDirectives().find((popoverRoot) =>
                    container.contains(popoverRoot.popoverTriggerDirective().elementRef.nativeElement)
                );
                if (popoverRootInsideContainer) {
                    setRdxCdkEventService(this.rdxCdkEventService);
                    registerContainer(container, popoverRootInsideContainer);
                    this.destroyRef.onDestroy(() => deregisterContainer(container));
                }
            });
        });
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/stories/utils/styles.constants.ts
```typescript
const appliedAnimations = `
.PopoverContent[data-state='open'][data-side='top'] {
    animation-name: rdxSlideDownAndFade;
}

.PopoverContent[data-state='open'][data-side='right'] {
    animation-name: rdxSlideLeftAndFade;
}

.PopoverContent[data-state='open'][data-side='bottom'] {
    animation-name: rdxSlideUpAndFade;
}

.PopoverContent[data-state='open'][data-side='left'] {
    animation-name: rdxSlideRightAndFade;
}

.PopoverContent[data-state='closed'][data-side='top'] {
    animation-name: rdxSlideDownAndFadeReverse;
}

.PopoverContent[data-state='closed'][data-side='right'] {
    animation-name: rdxSlideLeftAndFadeReverse;
}

.PopoverContent[data-state='closed'][data-side='bottom'] {
    animation-name: rdxSlideUpAndFadeReverse;
}

.PopoverContent[data-state='closed'][data-side='left'] {
    animation-name: rdxSlideRightAndFadeReverse;
}
`;

const animationParams = `
.PopoverContent {
    animation-duration: 400ms;
    animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
    will-change: transform, opacity;
}
`;

const animationDefs = `
/* Opening animations */

@keyframes rdxSlideUpAndFade {
    from {
        opacity: 0;
        transform: translateY(2px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes rdxSlideRightAndFade {
    from {
        opacity: 0;
        transform: translateX(-2px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

@keyframes rdxSlideDownAndFade {
    from {
        opacity: 0;
        transform: translateY(-2px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes rdxSlideLeftAndFade {
    from {
        opacity: 0;
        transform: translateX(2px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

/* Closing animations */

@keyframes rdxSlideUpAndFadeReverse {
    from {
        opacity: 1;
        transform: translateY(0);
    }
    to {
        opacity: 0;
        transform: translateY(2px);
    }
}

@keyframes rdxSlideRightAndFadeReverse {
    from {
        opacity: 1;
        transform: translateX(0);
    }
    to {
        opacity: 0;
        transform: translateX(-2px);
    }
}

@keyframes rdxSlideDownAndFadeReverse {
    from {
        opacity: 1;
        transform: translateY(0);
    }
    to {
        opacity: 0;
        transform: translateY(-2px);
    }
}

@keyframes rdxSlideLeftAndFadeReverse {
    from {
        opacity: 1;
        transform: translateX(0);
    }
    to {
        opacity: 0;
        transform: translateX(2px);
    }
}
`;

const events = `
/* =============== Event messages =============== */

.MessagesContainer {
    padding: 20px;
}

.Message {
    color: var(--white-a12);
    font-size: 15px;
    line-height: 19px;
    font-weight: bolder;
}

.MessageId {
    font-size: 75%;
    font-weight: light;
}
`;

const params = `
/* =============== Params layout =============== */

.ParamsContainer {
    display: flex;
    column-gap: 8px;
    color: var(--white-a12);
    padding-bottom: 32px;
}
`;

function styles(withAnimations = false, withEvents = false, withParams = true) {
    return `
.container {
    height: 500px;
    display: flex;
    justify-content: center;
    gap: 80px;
    align-items: center;
    border: 3px dashed var(--white-a8);
    border-radius: 12px;
    &.focused {
        border-color: var(--white-a12);
        -webkit-box-shadow: 0px 0px 24px 0px var(--white-a12);
        -moz-box-shadow: 0px 0px 24px 0px var(--white-a12);
        box-shadow: 0px 0px 24px 0px var(--white-a12);
    }
}

.ContainerAlerts {
    display: flex;
    gap: 6px;
    color: var(--white-a8);
    font-size: 16px;
    line-height: 16px;
    margin: 0 0 24px 0;
}

/* reset */
.reset {
    all: unset;
}

.ExampleSubtitle {
    color: var(--white-a12);
    font-size: 22px;
    line-height: 26px;
    font-weight: bolder;
    margin: 46px 0 34px 16px;
    padding-top: 22px;
    &:not(:first-child) {
        border-top: 2px solid var(--gray-a8);
    }
    &:first-child {
        margin-top: 0;
    }
}

.PopoverId {
    color: var(--white-a12);
    font-size: 12px;
    line-height: 14px;
    font-weight: 800;
    margin: 1px 0 24px 22px;
}

.PopoverContent {
    border-radius: 4px;
    padding: 20px;
    width: 260px;
    background-color: white;
    box-shadow:
        hsl(206 22% 7% / 35%) 0px 10px 38px -10px,
        hsl(206 22% 7% / 20%) 0px 10px 20px -15px;
}

${withAnimations ? animationParams : ''}

${withAnimations ? appliedAnimations : ''}

.PopoverContent:focus {
    box-shadow:
        hsl(206 22% 7% / 35%) 0px 10px 38px -10px,
        hsl(206 22% 7% / 20%) 0px 10px 20px -15px,
        0 0 0 2px var(--violet-7);
}

.PopoverArrow {
    fill: white;
}

.PopoverClose {
    font-family: inherit;
    border-radius: 100%;
    height: 25px;
    width: 25px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: var(--violet-11);
    position: absolute;
    top: 5px;
    right: 5px;
}

.PopoverClose:hover {
    background-color: var(--violet-4);
}

.PopoverClose:focus {
    box-shadow: 0 0 0 2px var(--violet-7);
}

.IconButton {
    font-family: inherit;
    border-radius: 100%;
    height: 35px;
    width: 35px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: var(--violet-11);
    background-color: white;
    box-shadow: 0 2px 10px var(--black-a7);
}

.IconButton:hover {
    background-color: var(--violet-3);
}

.IconButton:focus {
    box-shadow: 0 0 0 2px black;
}

.Fieldset {
    display: flex;
    gap: 20px;
    align-items: center;
}

.Label {
    font-size: 13px;
    color: var(--violet-11);
    width: 75px;
}

.Input {
    width: 100%;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    border-radius: 4px;
    padding: 0 10px;
    font-size: 13px;
    line-height: 1;
    color: var(--violet-11);
    box-shadow: 0 0 0 1px var(--violet-7);
    height: 25px;
}

.Input:focus {
    box-shadow: 0 0 0 2px var(--violet-8);
}

.Text {
    margin: 0;
    color: var(--mauve-12);
    font-size: 15px;
    line-height: 19px;
    font-weight: 500;
}

${withAnimations ? animationDefs : ''}

${withParams ? params : ''}

${withEvents ? events : ''}
`;
}

export const animationStylesOnly = `
${animationParams}

${appliedAnimations}

${animationDefs}
`;

export const paramsAndEventsOnly = `
${params}

${events}
`;

export default styles;

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/stories/utils/types.ts
```typescript
import { DestroyRef, ElementRef, Signal } from '@angular/core';
import { RdxPopoverRootDirective } from '../../src/popover-root.directive';
import { injectRdxCdkEventService } from '../../src/utils/cdk-event.service';

export interface IIgnoreClickOutsideContainer {
    onOverlayEscapeKeyDownDisabled: Signal<boolean>;
    onOverlayOutsideClickDisabled: Signal<boolean>;
    elementRef: ElementRef<Element>;
    destroyRef: DestroyRef;
    rootDirectives: Signal<ReadonlyArray<RdxPopoverRootDirective>>;
    document: Document;
    rdxCdkEventService: ReturnType<typeof injectRdxCdkEventService>;
}

export interface IArrowDimensions {
    arrowWidth: Signal<number | undefined>;
    arrowHeight: Signal<number | undefined>;
}

export type Message = { value: string; timeFromPrev: number };

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/stories/utils/with-option-panel.component.ts
```typescript
import { NgTemplateOutlet } from '@angular/common';
import {
    afterNextRender,
    Component,
    computed,
    contentChild,
    ElementRef,
    inject,
    isDevMode,
    model,
    signal
} from '@angular/core';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { RdxPopoverRootDirective } from '../../src/popover-root.directive';
import { paramsAndEventsOnly } from './styles.constants';
import { Message } from './types';

@Component({
    selector: 'popover-with-option-panel',
    styles: paramsAndEventsOnly,
    template: `
        <ng-content select=".ParamsContainer" />

        @if (paramsContainerCounter() > 2) {
            <hr />
        }

        <div class="ParamsContainer">
            <input
                [ngModel]="onOverlayEscapeKeyDownDisabled()"
                (ngModelChange)="onOverlayEscapeKeyDownDisabled.set($event)"
                type="checkbox"
            />
            Disable (onOverlayEscapeKeyDown) event
            <input
                [ngModel]="onOverlayOutsideClickDisabled()"
                (ngModelChange)="onOverlayOutsideClickDisabled.set($event)"
                type="checkbox"
            />
            Disable (onOverlayOutsideClick) event
        </div>

        <div class="ParamsContainer">
            Arrow width
            <input [ngModel]="arrowWidth()" (ngModelChange)="arrowWidth.set($event)" type="number" />
            Arrow height
            <input [ngModel]="arrowHeight()" (ngModelChange)="arrowHeight.set($event)" type="number" />
        </div>

        <ng-content />

        @if (messages().length) {
            <button class="SkipOutsideClickPrevention" (click)="messages.set([])" type="button">Clear messages</button>
            <div class="MessagesContainer">
                @for (message of messages(); track i; let i = $index) {
                    <ng-container
                        [ngTemplateOutlet]="messageTpl"
                        [ngTemplateOutletContext]="{ message: message, index: messages().length - i }"
                    />
                }
            </div>
        }

        <ng-template #messageTpl let-message="message" let-index="index">
            <p class="Message">
                {{ index }}.
                <span class="MessageId">[({{ message.timeFromPrev }}ms) POPOVER ID {{ rootUniqueId() }}]</span>
                {{ message.value }}
            </p>
        </ng-template>
    `,
    imports: [
        ReactiveFormsModule,
        FormsModule,
        NgTemplateOutlet
    ]
})
export class WithOptionPanelComponent {
    onOverlayEscapeKeyDownDisabled = model(false);
    onOverlayOutsideClickDisabled = model(false);

    arrowWidth = model<number>(0);
    arrowHeight = model<number>(0);

    readonly elementRef = inject<ElementRef<HTMLElement>>(ElementRef);

    readonly popoverRootDirective = contentChild.required(RdxPopoverRootDirective);

    readonly paramsContainerCounter = signal(0);

    readonly messages = signal<Message[]>([]);
    readonly rootUniqueId = computed(() => this.popoverRootDirective().uniqueId());

    /**
     * There should be only one container. If there is more, en error is thrown.
     */
    containers: Element[] | undefined = void 0;
    paramsContainers: Element[] | undefined = void 0;

    previousMessageTimestamp: number | undefined = void 0;

    timeFromPrev = () => {
        const now = Date.now();
        const timeFromPrev =
            typeof this.previousMessageTimestamp === 'undefined' ? 0 : Date.now() - this.previousMessageTimestamp;
        this.previousMessageTimestamp = now;
        return timeFromPrev;
    };

    constructor() {
        afterNextRender({
            read: () => {
                this.popoverRootDirective().popoverContentDirective().onOpen.subscribe(this.onOpen);
                this.popoverRootDirective().popoverContentDirective().onClosed.subscribe(this.onClose);
                this.popoverRootDirective()
                    .popoverContentDirective()
                    .onOverlayOutsideClick.subscribe(this.onOverlayOutsideClick);
                this.popoverRootDirective()
                    .popoverContentDirective()
                    .onOverlayEscapeKeyDown.subscribe(this.onOverlayEscapeKeyDown);

                /**
                 * There should be only one container. If there is more, en error is thrown.
                 */
                this.containers = Array.from(this.elementRef.nativeElement?.querySelectorAll('.container') ?? []);
                if (this.containers.length > 1) {
                    if (isDevMode()) {
                        console.error('<story>.elementRef.nativeElement', this.elementRef.nativeElement);
                        console.error('<story>.containers', this.containers);
                        throw Error('each story should have only one container!');
                    }
                }
                this.paramsContainers = Array.from(
                    this.elementRef.nativeElement?.querySelectorAll('.ParamsContainer') ?? []
                );

                this.paramsContainerCounter.set(this.paramsContainers.length ?? 0);
            }
        });
    }

    private inContainers(element: Element) {
        return !!this.containers?.find((container) => container.contains(element));
    }

    private inParamsContainers(element: Element) {
        return !!this.paramsContainers?.find((container) => container.contains(element));
    }

    private onOverlayEscapeKeyDown = () => {
        this.addMessage({
            value: `[PopoverRoot] Escape clicked! (disabled: ${this.onOverlayEscapeKeyDownDisabled()})`,
            timeFromPrev: this.timeFromPrev()
        });
    };

    private onOverlayOutsideClick = () => {
        this.addMessage({
            value: `[PopoverRoot] Mouse clicked outside the popover! (disabled: ${this.onOverlayOutsideClickDisabled()})`,
            timeFromPrev: this.timeFromPrev()
        });
    };

    private onOpen = () => {
        this.addMessage({ value: '[PopoverContent] Open', timeFromPrev: this.timeFromPrev() });
    };

    private onClose = () => {
        this.addMessage({ value: '[PopoverContent] Closed', timeFromPrev: this.timeFromPrev() });
    };

    protected addMessage = (message: Message) => {
        this.messages.update((messages) => {
            return [
                message,
                ...messages
            ];
        });
    };
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/src/popover-anchor.directive.ts
```typescript
import { CdkOverlayOrigin } from '@angular/cdk/overlay';
import { computed, Directive, ElementRef, forwardRef, inject } from '@angular/core';
import { injectDocument } from '@radix-ng/primitives/core';
import { RdxPopoverAnchorToken } from './popover-anchor.token';
import { RdxPopoverRootDirective } from './popover-root.directive';
import { injectPopoverRoot } from './popover-root.inject';

@Directive({
    selector: '[rdxPopoverAnchor]',
    exportAs: 'rdxPopoverAnchor',
    hostDirectives: [CdkOverlayOrigin],
    host: {
        type: 'button',
        '[attr.id]': 'name()',
        '[attr.aria-haspopup]': '"dialog"',
        '(click)': 'click()'
    },
    providers: [
        {
            provide: RdxPopoverAnchorToken,
            useExisting: forwardRef(() => RdxPopoverAnchorDirective)
        }
    ]
})
export class RdxPopoverAnchorDirective {
    /**
     * @ignore
     * If outside the root then null, otherwise the root directive - with optional `true` passed in as the first param.
     * If outside the root and non-null value that means the html structure is wrong - popover inside popover.
     * */
    protected popoverRoot = injectPopoverRoot(true);
    /** @ignore */
    readonly elementRef = inject(ElementRef);
    /** @ignore */
    readonly overlayOrigin = inject(CdkOverlayOrigin);
    /** @ignore */
    readonly document = injectDocument();

    /** @ignore */
    readonly name = computed(() => `rdx-popover-external-anchor-${this.popoverRoot?.uniqueId()}`);

    /** @ignore */
    click(): void {
        this.emitOutsideClick();
    }

    /** @ignore */
    setPopoverRoot(popoverRoot: RdxPopoverRootDirective) {
        this.popoverRoot = popoverRoot;
    }

    private emitOutsideClick() {
        if (
            !this.popoverRoot?.isOpen() ||
            this.popoverRoot?.popoverContentDirective().onOverlayOutsideClickDisabled()
        ) {
            return;
        }
        const clickEvent = new MouseEvent('click', {
            view: this.document.defaultView,
            bubbles: true,
            cancelable: true,
            relatedTarget: this.elementRef.nativeElement
        });
        this.popoverRoot?.popoverTriggerDirective().elementRef.nativeElement.dispatchEvent(clickEvent);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/src/popover-anchor.token.ts
```typescript
import { InjectionToken } from '@angular/core';
import { RdxPopoverAnchorDirective } from './popover-anchor.directive';

export const RdxPopoverAnchorToken = new InjectionToken<RdxPopoverAnchorDirective>('RdxPopoverAnchorToken');

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/src/popover-arrow.directive.ts
```typescript
import { NumberInput } from '@angular/cdk/coercion';
import { ConnectedOverlayPositionChange } from '@angular/cdk/overlay';
import {
    afterNextRender,
    computed,
    Directive,
    effect,
    ElementRef,
    forwardRef,
    inject,
    input,
    numberAttribute,
    Renderer2,
    signal,
    untracked
} from '@angular/core';
import { toSignal } from '@angular/core/rxjs-interop';
import {
    getArrowPositionParams,
    getSideAndAlignFromAllPossibleConnectedPositions,
    RDX_POSITIONING_DEFAULTS
} from '@radix-ng/primitives/core';
import { RdxPopoverArrowToken } from './popover-arrow.token';
import { injectPopoverRoot } from './popover-root.inject';

@Directive({
    selector: '[rdxPopoverArrow]',
    providers: [
        {
            provide: RdxPopoverArrowToken,
            useExisting: forwardRef(() => RdxPopoverArrowDirective)
        }
    ]
})
export class RdxPopoverArrowDirective {
    /** @ignore */
    private readonly renderer = inject(Renderer2);
    /** @ignore */
    private readonly popoverRoot = injectPopoverRoot();
    /** @ignore */
    readonly elementRef = inject(ElementRef);

    /**
     * @description The width of the arrow in pixels.
     * @default 10
     */
    readonly width = input<number, NumberInput>(RDX_POSITIONING_DEFAULTS.arrow.width, { transform: numberAttribute });

    /**
     * @description The height of the arrow in pixels.
     * @default 5
     */
    readonly height = input<number, NumberInput>(RDX_POSITIONING_DEFAULTS.arrow.height, { transform: numberAttribute });

    /** @ignore */
    readonly arrowSvgElement = computed<HTMLElement>(() => {
        const width = this.width();
        const height = this.height();

        const svgElement = this.renderer.createElement('svg', 'svg');
        this.renderer.setAttribute(svgElement, 'viewBox', '0 0 30 10');
        this.renderer.setAttribute(svgElement, 'width', String(width));
        this.renderer.setAttribute(svgElement, 'height', String(height));
        const polygonElement = this.renderer.createElement('polygon', 'svg');
        this.renderer.setAttribute(polygonElement, 'points', '0,0 30,0 15,10');
        this.renderer.setAttribute(svgElement, 'preserveAspectRatio', 'none');
        this.renderer.appendChild(svgElement, polygonElement);

        return svgElement;
    });

    /** @ignore */
    private readonly currentArrowSvgElement = signal<HTMLOrSVGElement | undefined>(void 0);
    /** @ignore */
    private readonly position = toSignal(this.popoverRoot.popoverContentDirective().positionChange());

    /** @ignore */
    private anchorOrTriggerRect: DOMRect;

    constructor() {
        afterNextRender({
            write: () => {
                if (this.elementRef.nativeElement.parentElement) {
                    this.renderer.setStyle(this.elementRef.nativeElement.parentElement, 'position', 'relative');
                }
                this.renderer.setStyle(this.elementRef.nativeElement, 'position', 'absolute');
                this.renderer.setStyle(this.elementRef.nativeElement, 'boxSizing', '');
                this.renderer.setStyle(this.elementRef.nativeElement, 'fontSize', '0px');
            }
        });
        this.onArrowSvgElementChangeEffect();
        this.onContentPositionAndArrowDimensionsChangeEffect();
    }

    /** @ignore */
    private setAnchorOrTriggerRect() {
        this.anchorOrTriggerRect = (
            this.popoverRoot.popoverAnchorDirective() ?? this.popoverRoot.popoverTriggerDirective()
        ).elementRef.nativeElement.getBoundingClientRect();
    }

    /** @ignore */
    private setPosition(position: ConnectedOverlayPositionChange, arrowDimensions: { width: number; height: number }) {
        this.setAnchorOrTriggerRect();
        const posParams = getArrowPositionParams(
            getSideAndAlignFromAllPossibleConnectedPositions(position.connectionPair),
            { width: arrowDimensions.width, height: arrowDimensions.height },
            { width: this.anchorOrTriggerRect.width, height: this.anchorOrTriggerRect.height }
        );

        this.renderer.setStyle(this.elementRef.nativeElement, 'top', posParams.top);
        this.renderer.setStyle(this.elementRef.nativeElement, 'bottom', '');
        this.renderer.setStyle(this.elementRef.nativeElement, 'left', posParams.left);
        this.renderer.setStyle(this.elementRef.nativeElement, 'right', '');
        this.renderer.setStyle(this.elementRef.nativeElement, 'transform', posParams.transform);
        this.renderer.setStyle(this.elementRef.nativeElement, 'transformOrigin', posParams.transformOrigin);
    }

    /** @ignore */
    private onArrowSvgElementChangeEffect() {
        effect(() => {
            const arrowElement = this.arrowSvgElement();
            untracked(() => {
                const currentArrowSvgElement = this.currentArrowSvgElement();
                if (currentArrowSvgElement) {
                    this.renderer.removeChild(this.elementRef.nativeElement, currentArrowSvgElement);
                }
                this.currentArrowSvgElement.set(arrowElement);
                this.renderer.setStyle(this.elementRef.nativeElement, 'width', `${this.width()}px`);
                this.renderer.setStyle(this.elementRef.nativeElement, 'height', `${this.height()}px`);
                this.renderer.appendChild(this.elementRef.nativeElement, this.currentArrowSvgElement());
            });
        });
    }

    /** @ignore */
    private onContentPositionAndArrowDimensionsChangeEffect() {
        effect(() => {
            const position = this.position();
            const arrowDimensions = { width: this.width(), height: this.height() };
            untracked(() => {
                if (!position) {
                    return;
                }
                this.setPosition(position, arrowDimensions);
            });
        });
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/src/popover-arrow.token.ts
```typescript
import { InjectionToken } from '@angular/core';
import { RdxPopoverArrowDirective } from './popover-arrow.directive';

export const RdxPopoverArrowToken = new InjectionToken<RdxPopoverArrowDirective>('RdxPopoverArrowToken');

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/src/popover-close.directive.ts
```typescript
import { Directive, effect, ElementRef, forwardRef, inject, Renderer2, untracked } from '@angular/core';
import { RdxPopoverCloseToken } from './popover-close.token';
import { injectPopoverRoot } from './popover-root.inject';

@Directive({
    selector: '[rdxPopoverClose]',
    host: {
        type: 'button',
        '(click)': 'popoverRoot.handleClose()'
    },
    providers: [
        {
            provide: RdxPopoverCloseToken,
            useExisting: forwardRef(() => RdxPopoverCloseDirective)
        }
    ]
})
export class RdxPopoverCloseDirective {
    /** @ignore */
    protected readonly popoverRoot = injectPopoverRoot();
    /** @ignore */
    readonly elementRef = inject(ElementRef);
    /** @ignore */
    private readonly renderer = inject(Renderer2);

    constructor() {
        this.onIsControlledExternallyEffect();
    }

    /** @ignore */
    private onIsControlledExternallyEffect() {
        effect(() => {
            const isControlledExternally = this.popoverRoot.controlledExternally()();

            untracked(() => {
                this.renderer.setStyle(
                    this.elementRef.nativeElement,
                    'display',
                    isControlledExternally ? 'none' : null
                );
            });
        });
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/src/popover-close.token.ts
```typescript
import { InjectionToken } from '@angular/core';
import { RdxPopoverCloseDirective } from './popover-close.directive';

export const RdxPopoverCloseToken = new InjectionToken<RdxPopoverCloseDirective>('RdxPopoverCloseToken');

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/src/popover-content-attributes.component.ts
```typescript
import { CdkTrapFocus } from '@angular/cdk/a11y';
import {
    afterNextRender,
    ChangeDetectionStrategy,
    Component,
    computed,
    ContentChild,
    forwardRef,
    inject
} from '@angular/core';
import { RdxFocusInitialDirective } from '@radix-ng/primitives/core';
import { RdxPopoverContentAttributesToken } from './popover-content-attributes.token';
import { injectPopoverRoot } from './popover-root.inject';
import { RdxPopoverAnimationStatus, RdxPopoverState } from './popover.types';

@Component({
    selector: '[rdxPopoverContentAttributes]',
    template: `
        <ng-content />
    `,
    host: {
        '[attr.role]': '"dialog"',
        '[attr.id]': 'name()',
        '[attr.data-state]': 'popoverRoot.state()',
        '[attr.data-side]': 'popoverRoot.popoverContentDirective().side()',
        '[attr.data-align]': 'popoverRoot.popoverContentDirective().align()',
        '[style]': 'disableAnimation() ? {animation: "none !important"} : null',
        '(animationstart)': 'onAnimationStart($event)',
        '(animationend)': 'onAnimationEnd($event)'
    },
    hostDirectives: [
        CdkTrapFocus
    ],
    providers: [
        {
            provide: RdxPopoverContentAttributesToken,
            useExisting: forwardRef(() => RdxPopoverContentAttributesComponent)
        }
    ],
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class RdxPopoverContentAttributesComponent {
    /** @ignore */
    private readonly focusTrapDirective = inject(CdkTrapFocus, { self: true });

    /** @ignore */
    @ContentChild(RdxFocusInitialDirective, { descendants: true })
    private readonly focusInitialDirective: RdxFocusInitialDirective;

    /** @ignore */
    protected readonly popoverRoot = injectPopoverRoot();

    /** @ignore */
    readonly name = computed(() => `rdx-popover-content-attributes-${this.popoverRoot.uniqueId()}`);

    /** @ignore */
    readonly disableAnimation = computed(() => !this.canAnimate());

    constructor() {
        afterNextRender({
            write: () => {
                if (this.focusInitialDirective) {
                    return this.focusInitialDirective.focus();
                }
                this.focusTrapDirective.focusTrap.focusFirstTabbableElement();
            }
        });
    }

    /** @ignore */
    protected onAnimationStart(_: AnimationEvent) {
        this.popoverRoot.cssAnimationStatus.set(
            this.popoverRoot.state() === RdxPopoverState.OPEN
                ? RdxPopoverAnimationStatus.OPEN_STARTED
                : RdxPopoverAnimationStatus.CLOSED_STARTED
        );
    }

    /** @ignore */
    protected onAnimationEnd(_: AnimationEvent) {
        this.popoverRoot.cssAnimationStatus.set(
            this.popoverRoot.state() === RdxPopoverState.OPEN
                ? RdxPopoverAnimationStatus.OPEN_ENDED
                : RdxPopoverAnimationStatus.CLOSED_ENDED
        );
    }

    /** @ignore */
    private canAnimate() {
        return (
            this.popoverRoot.cssAnimation() &&
            ((this.popoverRoot.cssOpeningAnimation() && this.popoverRoot.state() === RdxPopoverState.OPEN) ||
                (this.popoverRoot.cssClosingAnimation() && this.popoverRoot.state() === RdxPopoverState.CLOSED))
        );
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/src/popover-content-attributes.token.ts
```typescript
import { InjectionToken } from '@angular/core';
import { RdxPopoverContentAttributesComponent } from './popover-content-attributes.component';

export const RdxPopoverContentAttributesToken = new InjectionToken<RdxPopoverContentAttributesComponent>(
    'RdxPopoverContentAttributesToken'
);

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/src/popover-content.directive.ts
```typescript
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import { CdkConnectedOverlay, Overlay } from '@angular/cdk/overlay';
import {
    booleanAttribute,
    computed,
    DestroyRef,
    Directive,
    effect,
    inject,
    input,
    numberAttribute,
    OnInit,
    output,
    SimpleChange,
    TemplateRef,
    untracked
} from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import {
    getAllPossibleConnectedPositions,
    getContentPosition,
    RDX_POSITIONING_DEFAULTS,
    RdxPositionAlign,
    RdxPositionSide,
    RdxPositionSideAndAlignOffsets
} from '@radix-ng/primitives/core';
import { filter, tap } from 'rxjs';
import { injectPopoverRoot } from './popover-root.inject';
import { RdxPopoverAttachDetachEvent } from './popover.types';

@Directive({
    selector: '[rdxPopoverContent]',
    hostDirectives: [
        CdkConnectedOverlay
    ]
})
export class RdxPopoverContentDirective implements OnInit {
    /** @ignore */
    private readonly popoverRoot = injectPopoverRoot();
    /** @ignore */
    private readonly templateRef = inject(TemplateRef);
    /** @ignore */
    private readonly overlay = inject(Overlay);
    /** @ignore */
    private readonly destroyRef = inject(DestroyRef);
    /** @ignore */
    private readonly connectedOverlay = inject(CdkConnectedOverlay);

    /** @ignore */
    readonly name = computed(() => `rdx-popover-trigger-${this.popoverRoot.uniqueId()}`);

    /**
     * @description The preferred side of the trigger to render against when open. Will be reversed when collisions occur and avoidCollisions is enabled.
     * @default top
     */
    readonly side = input<RdxPositionSide>(RdxPositionSide.Top);
    /**
     * @description The distance in pixels from the trigger.
     * @default undefined
     */
    readonly sideOffset = input<number, NumberInput>(NaN, {
        transform: numberAttribute
    });
    /**
     * @description The preferred alignment against the trigger. May change when collisions occur.
     * @default center
     */
    readonly align = input<RdxPositionAlign>(RdxPositionAlign.Center);
    /**
     * @description An offset in pixels from the "start" or "end" alignment options.
     * @default undefined
     */
    readonly alignOffset = input<number, NumberInput>(NaN, {
        transform: numberAttribute
    });

    /**
     * @description Whether to add some alternate positions of the content.
     * @default false
     */
    readonly alternatePositionsDisabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /** @description Whether to prevent `onOverlayEscapeKeyDown` handler from calling. */
    readonly onOverlayEscapeKeyDownDisabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });
    /** @description Whether to prevent `onOverlayOutsideClick` handler from calling. */
    readonly onOverlayOutsideClickDisabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * @description Event handler called when the escape key is down.
     * It can be prevented by setting `onOverlayEscapeKeyDownDisabled` input to `true`.
     */
    readonly onOverlayEscapeKeyDown = output<KeyboardEvent>();
    /**
     * @description Event handler called when a pointer event occurs outside the bounds of the component.
     * It can be prevented by setting `onOverlayOutsideClickDisabled` input to `true`.
     */
    readonly onOverlayOutsideClick = output<MouseEvent>();

    /**
     * @description Event handler called after the overlay is open
     */
    readonly onOpen = output<void>();
    /**
     * @description Event handler called after the overlay is closed
     */
    readonly onClosed = output<void>();

    /** @ingore */
    readonly positions = computed(() => this.computePositions());

    constructor() {
        this.onOriginChangeEffect();
        this.onPositionChangeEffect();
    }

    /** @ignore */
    ngOnInit() {
        this.setScrollStrategy();
        this.setHasBackdrop();
        this.setDisableClose();
        this.onAttach();
        this.onDetach();
        this.connectKeydownEscape();
        this.connectOutsideClick();
    }

    /** @ignore */
    open() {
        if (this.connectedOverlay.open) {
            return;
        }
        const prevOpen = this.connectedOverlay.open;
        this.connectedOverlay.open = true;
        this.fireOverlayNgOnChanges('open', this.connectedOverlay.open, prevOpen);
    }

    /** @ignore */
    close() {
        if (!this.connectedOverlay.open) {
            return;
        }
        const prevOpen = this.connectedOverlay.open;
        this.connectedOverlay.open = false;
        this.fireOverlayNgOnChanges('open', this.connectedOverlay.open, prevOpen);
    }

    /** @ignore */
    positionChange() {
        return this.connectedOverlay.positionChange.asObservable();
    }

    /** @ignore */
    private connectKeydownEscape() {
        this.connectedOverlay.overlayKeydown
            .asObservable()
            .pipe(
                filter(
                    () =>
                        !this.onOverlayEscapeKeyDownDisabled() &&
                        !this.popoverRoot.rdxCdkEventService?.primitivePreventedFromCdkEvent(
                            this.popoverRoot,
                            'cdkOverlayEscapeKeyDown'
                        )
                ),
                filter((event) => event.key === 'Escape'),
                tap((event) => {
                    this.onOverlayEscapeKeyDown.emit(event);
                }),
                filter(() => !this.popoverRoot.firstDefaultOpen()),
                tap(() => {
                    this.popoverRoot.handleClose();
                }),
                takeUntilDestroyed(this.destroyRef)
            )
            .subscribe();
    }

    /** @ignore */
    private connectOutsideClick() {
        this.connectedOverlay.overlayOutsideClick
            .asObservable()
            .pipe(
                filter(
                    () =>
                        !this.onOverlayOutsideClickDisabled() &&
                        !this.popoverRoot.rdxCdkEventService?.primitivePreventedFromCdkEvent(
                            this.popoverRoot,
                            'cdkOverlayOutsideClick'
                        )
                ),
                /**
                 * Handle the situation when an anchor is added and the anchor becomes the origin of the overlay
                 * hence  the trigger will be considered the outside element
                 */
                filter((event) => {
                    return (
                        !this.popoverRoot.popoverAnchorDirective() ||
                        !this.popoverRoot
                            .popoverTriggerDirective()
                            .elementRef.nativeElement.contains(event.target as Element)
                    );
                }),
                tap((event) => {
                    this.onOverlayOutsideClick.emit(event);
                }),
                filter(() => !this.popoverRoot.firstDefaultOpen()),
                tap(() => {
                    this.popoverRoot.handleClose();
                }),
                takeUntilDestroyed(this.destroyRef)
            )
            .subscribe();
    }

    /** @ignore */
    private onAttach() {
        this.connectedOverlay.attach
            .asObservable()
            .pipe(
                tap(() => {
                    /**
                     * `this.onOpen.emit();` is being delegated to the root directive due to the opening animation
                     */
                    this.popoverRoot.attachDetachEvent.set(RdxPopoverAttachDetachEvent.ATTACH);
                }),
                takeUntilDestroyed(this.destroyRef)
            )
            .subscribe();
    }

    /** @ignore */
    private onDetach() {
        this.connectedOverlay.detach
            .asObservable()
            .pipe(
                tap(() => {
                    /**
                     * `this.onClosed.emit();` is being delegated to the root directive due to the closing animation
                     */
                    this.popoverRoot.attachDetachEvent.set(RdxPopoverAttachDetachEvent.DETACH);
                }),
                takeUntilDestroyed(this.destroyRef)
            )
            .subscribe();
    }

    /** @ignore */
    private setScrollStrategy() {
        const prevScrollStrategy = this.connectedOverlay.scrollStrategy;
        this.connectedOverlay.scrollStrategy = this.overlay.scrollStrategies.reposition();
        this.fireOverlayNgOnChanges('scrollStrategy', this.connectedOverlay.scrollStrategy, prevScrollStrategy);
    }

    /** @ignore */
    private setHasBackdrop() {
        const prevHasBackdrop = this.connectedOverlay.hasBackdrop;
        this.connectedOverlay.hasBackdrop = false;
        this.fireOverlayNgOnChanges('hasBackdrop', this.connectedOverlay.hasBackdrop, prevHasBackdrop);
    }

    /** @ignore */
    private setDisableClose() {
        const prevDisableClose = this.connectedOverlay.disableClose;
        this.connectedOverlay.disableClose = true;
        this.fireOverlayNgOnChanges('disableClose', this.connectedOverlay.disableClose, prevDisableClose);
    }

    /** @ignore */
    private setOrigin(origin: CdkConnectedOverlay['origin']) {
        const prevOrigin = this.connectedOverlay.origin;
        this.connectedOverlay.origin = origin;
        this.fireOverlayNgOnChanges('origin', this.connectedOverlay.origin, prevOrigin);
    }

    /** @ignore */
    private setPositions(positions: CdkConnectedOverlay['positions']) {
        const prevPositions = this.connectedOverlay.positions;
        this.connectedOverlay.positions = positions;
        this.fireOverlayNgOnChanges('positions', this.connectedOverlay.positions, prevPositions);
        this.connectedOverlay.overlayRef?.updatePosition();
    }

    /** @ignore */
    private computePositions() {
        const arrowHeight = this.popoverRoot.popoverArrowDirective()?.height() ?? 0;
        const offsets: RdxPositionSideAndAlignOffsets = {
            sideOffset:
                arrowHeight + (isNaN(this.sideOffset()) ? RDX_POSITIONING_DEFAULTS.offsets.side : this.sideOffset()),
            alignOffset: isNaN(this.alignOffset()) ? RDX_POSITIONING_DEFAULTS.offsets.align : this.alignOffset()
        };
        const basePosition = getContentPosition({
            side: this.side(),
            align: this.align(),
            sideOffset: offsets.sideOffset,
            alignOffset: offsets.alignOffset
        });
        const positions = [basePosition];
        if (!this.alternatePositionsDisabled()) {
            /**
             * Alternate positions for better user experience along the X/Y axis (e.g. vertical/horizontal scrolling)
             */
            const allPossibleConnectedPositions = getAllPossibleConnectedPositions();
            allPossibleConnectedPositions.forEach((_, key) => {
                const sideAndAlignArray = key.split('|');
                if (
                    (sideAndAlignArray[0] as RdxPositionSide) !== this.side() ||
                    (sideAndAlignArray[1] as RdxPositionAlign) !== this.align()
                ) {
                    positions.push(
                        getContentPosition({
                            side: sideAndAlignArray[0] as RdxPositionSide,
                            align: sideAndAlignArray[1] as RdxPositionAlign,
                            sideOffset: offsets.sideOffset,
                            alignOffset: offsets.alignOffset
                        })
                    );
                }
            });
        }
        return positions;
    }

    private onOriginChangeEffect() {
        effect(() => {
            const origin = (this.popoverRoot.popoverAnchorDirective() ?? this.popoverRoot.popoverTriggerDirective())
                .overlayOrigin;
            untracked(() => {
                this.setOrigin(origin);
            });
        });
    }

    /** @ignore */
    private onPositionChangeEffect() {
        effect(() => {
            const positions = this.positions();
            this.alternatePositionsDisabled();
            untracked(() => {
                this.setPositions(positions);
            });
        });
    }

    /** @ignore */
    private fireOverlayNgOnChanges<K extends keyof CdkConnectedOverlay, V extends CdkConnectedOverlay[K]>(
        input: K,
        currentValue: V,
        previousValue: V,
        firstChange = false
    ) {
        this.connectedOverlay.ngOnChanges({
            [input]: new SimpleChange(previousValue, currentValue, firstChange)
        });
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/src/popover-root.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import {
    afterNextRender,
    booleanAttribute,
    computed,
    contentChild,
    DestroyRef,
    Directive,
    effect,
    inject,
    input,
    signal,
    untracked,
    ViewContainerRef
} from '@angular/core';
import { RdxPopoverAnchorDirective } from './popover-anchor.directive';
import { RdxPopoverAnchorToken } from './popover-anchor.token';
import { RdxPopoverArrowToken } from './popover-arrow.token';
import { RdxPopoverCloseToken } from './popover-close.token';
import { RdxPopoverContentAttributesToken } from './popover-content-attributes.token';
import { RdxPopoverContentDirective } from './popover-content.directive';
import { RdxPopoverTriggerDirective } from './popover-trigger.directive';
import { RdxPopoverAnimationStatus, RdxPopoverAttachDetachEvent, RdxPopoverState } from './popover.types';
import { injectRdxCdkEventService } from './utils/cdk-event.service';

let nextId = 0;

@Directive({
    selector: '[rdxPopoverRoot]',
    exportAs: 'rdxPopoverRoot'
})
export class RdxPopoverRootDirective {
    /** @ignore */
    readonly uniqueId = signal(++nextId);
    /** @ignore */
    readonly name = computed(() => `rdx-popover-root-${this.uniqueId()}`);

    /**
     * @description The anchor directive that comes form outside the popover root
     * @default undefined
     */
    readonly anchor = input<RdxPopoverAnchorDirective | undefined>(void 0);
    /**
     * @description The open state of the popover when it is initially rendered. Use when you do not need to control its open state.
     * @default false
     */
    readonly defaultOpen = input<boolean, BooleanInput>(false, { transform: booleanAttribute });
    /**
     * @description The controlled state of the popover. `open` input take precedence of `defaultOpen` input.
     * @default undefined
     */
    readonly open = input<boolean | undefined, BooleanInput>(void 0, { transform: booleanAttribute });
    /**
     * @description Whether to control the state of the popover from external. Use in conjunction with `open` input.
     * @default undefined
     */
    readonly externalControl = input<boolean | undefined, BooleanInput>(void 0, { transform: booleanAttribute });
    /**
     * @description Whether to take into account CSS opening/closing animations.
     * @default false
     */
    readonly cssAnimation = input<boolean, BooleanInput>(false, { transform: booleanAttribute });
    /**
     * @description Whether to take into account CSS opening animations. `cssAnimation` input must be set to 'true'
     * @default false
     */
    readonly cssOpeningAnimation = input<boolean, BooleanInput>(false, { transform: booleanAttribute });
    /**
     * @description Whether to take into account CSS closing animations. `cssAnimation` input must be set to 'true'
     * @default false
     */
    readonly cssClosingAnimation = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /** @ignore */
    readonly cssAnimationStatus = signal<RdxPopoverAnimationStatus | null>(null);

    /** @ignore */
    readonly popoverContentDirective = contentChild.required(RdxPopoverContentDirective);
    /** @ignore */
    readonly popoverTriggerDirective = contentChild.required(RdxPopoverTriggerDirective);
    /** @ignore */
    readonly popoverArrowDirective = contentChild(RdxPopoverArrowToken);
    /** @ignore */
    readonly popoverCloseDirective = contentChild(RdxPopoverCloseToken);
    /** @ignore */
    readonly popoverContentAttributesComponent = contentChild(RdxPopoverContentAttributesToken);
    /** @ignore */
    private readonly internalPopoverAnchorDirective = contentChild(RdxPopoverAnchorToken);

    /** @ignore */
    readonly viewContainerRef = inject(ViewContainerRef);
    /** @ignore */
    readonly rdxCdkEventService = injectRdxCdkEventService();
    /** @ignore */
    readonly destroyRef = inject(DestroyRef);

    /** @ignore */
    readonly state = signal(RdxPopoverState.CLOSED);

    /** @ignore */
    readonly attachDetachEvent = signal(RdxPopoverAttachDetachEvent.DETACH);

    /** @ignore */
    private readonly isFirstDefaultOpen = signal(false);

    /** @ignore */
    readonly popoverAnchorDirective = computed(() => this.internalPopoverAnchorDirective() ?? this.anchor());

    constructor() {
        this.rdxCdkEventService?.registerPrimitive(this);
        this.destroyRef.onDestroy(() => this.rdxCdkEventService?.deregisterPrimitive(this));
        this.onStateChangeEffect();
        this.onCssAnimationStatusChangeChangeEffect();
        this.onOpenChangeEffect();
        this.onIsFirstDefaultOpenChangeEffect();
        this.onAnchorChangeEffect();
        this.emitOpenOrClosedEventEffect();
        afterNextRender({
            write: () => {
                if (this.defaultOpen() && !this.open()) {
                    this.isFirstDefaultOpen.set(true);
                }
            }
        });
    }

    /** @ignore */
    getAnimationParamsSnapshot() {
        return {
            cssAnimation: this.cssAnimation(),
            cssOpeningAnimation: this.cssOpeningAnimation(),
            cssClosingAnimation: this.cssClosingAnimation(),
            cssAnimationStatus: this.cssAnimationStatus(),
            attachDetachEvent: this.attachDetachEvent(),
            state: this.state(),
            canEmitOnOpenOrOnClosed: this.canEmitOnOpenOrOnClosed()
        };
    }

    /** @ignore */
    controlledExternally() {
        return this.externalControl;
    }

    /** @ignore */
    firstDefaultOpen() {
        return this.isFirstDefaultOpen();
    }

    /** @ignore */
    handleOpen(): void {
        if (this.externalControl()) {
            return;
        }
        this.setState(RdxPopoverState.OPEN);
    }

    /** @ignore */
    handleClose(): void {
        if (this.isFirstDefaultOpen()) {
            this.isFirstDefaultOpen.set(false);
        }
        if (this.externalControl()) {
            return;
        }
        this.setState(RdxPopoverState.CLOSED);
    }

    /** @ignore */
    handleToggle(): void {
        if (this.externalControl()) {
            return;
        }
        this.isOpen() ? this.handleClose() : this.handleOpen();
    }

    /** @ignore */
    isOpen(state?: RdxPopoverState) {
        return (state ?? this.state()) === RdxPopoverState.OPEN;
    }

    /** @ignore */
    private setState(state = RdxPopoverState.CLOSED): void {
        if (state === this.state()) {
            return;
        }
        this.state.set(state);
    }

    /** @ignore */
    private openContent(): void {
        this.popoverContentDirective().open();
        if (!this.cssAnimation() || !this.cssOpeningAnimation()) {
            this.cssAnimationStatus.set(null);
        }
    }

    /** @ignore */
    private closeContent(): void {
        this.popoverContentDirective().close();
        if (!this.cssAnimation() || !this.cssClosingAnimation()) {
            this.cssAnimationStatus.set(null);
        }
    }

    /** @ignore */
    private emitOnOpen(): void {
        this.popoverContentDirective().onOpen.emit();
    }

    /** @ignore */
    private emitOnClosed(): void {
        this.popoverContentDirective().onClosed.emit();
    }

    /** @ignore */
    private ifOpenOrCloseWithoutAnimations(state: RdxPopoverState) {
        return (
            !this.popoverContentAttributesComponent() ||
            !this.cssAnimation() ||
            (this.cssAnimation() && !this.cssClosingAnimation() && state === RdxPopoverState.CLOSED) ||
            (this.cssAnimation() && !this.cssOpeningAnimation() && state === RdxPopoverState.OPEN) ||
            // !this.cssAnimationStatus() ||
            (this.cssOpeningAnimation() &&
                state === RdxPopoverState.OPEN &&
                [RdxPopoverAnimationStatus.OPEN_STARTED].includes(this.cssAnimationStatus()!)) ||
            (this.cssClosingAnimation() &&
                state === RdxPopoverState.CLOSED &&
                [RdxPopoverAnimationStatus.CLOSED_STARTED].includes(this.cssAnimationStatus()!))
        );
    }

    /** @ignore */
    private ifOpenOrCloseWithAnimations(cssAnimationStatus: RdxPopoverAnimationStatus | null) {
        return (
            this.popoverContentAttributesComponent() &&
            this.cssAnimation() &&
            cssAnimationStatus &&
            ((this.cssOpeningAnimation() &&
                this.state() === RdxPopoverState.OPEN &&
                [RdxPopoverAnimationStatus.OPEN_ENDED].includes(cssAnimationStatus)) ||
                (this.cssClosingAnimation() &&
                    this.state() === RdxPopoverState.CLOSED &&
                    [RdxPopoverAnimationStatus.CLOSED_ENDED].includes(cssAnimationStatus)))
        );
    }

    /** @ignore */
    private openOrClose(state: RdxPopoverState) {
        const isOpen = this.isOpen(state);
        isOpen ? this.openContent() : this.closeContent();
    }

    /** @ignore */
    private emitOnOpenOrOnClosed(state: RdxPopoverState) {
        this.isOpen(state)
            ? this.attachDetachEvent() === RdxPopoverAttachDetachEvent.ATTACH && this.emitOnOpen()
            : this.attachDetachEvent() === RdxPopoverAttachDetachEvent.DETACH && this.emitOnClosed();
    }

    /** @ignore */
    private canEmitOnOpenOrOnClosed() {
        return (
            !this.cssAnimation() ||
            (!this.cssOpeningAnimation() && this.state() === RdxPopoverState.OPEN) ||
            (this.cssOpeningAnimation() &&
                this.state() === RdxPopoverState.OPEN &&
                this.cssAnimationStatus() === RdxPopoverAnimationStatus.OPEN_ENDED) ||
            (!this.cssClosingAnimation() && this.state() === RdxPopoverState.CLOSED) ||
            (this.cssClosingAnimation() &&
                this.state() === RdxPopoverState.CLOSED &&
                this.cssAnimationStatus() === RdxPopoverAnimationStatus.CLOSED_ENDED)
        );
    }

    /** @ignore */
    private onStateChangeEffect() {
        let isFirst = true;
        effect(() => {
            const state = this.state();
            untracked(() => {
                if (isFirst) {
                    isFirst = false;
                    return;
                }
                if (!this.ifOpenOrCloseWithoutAnimations(state)) {
                    return;
                }
                this.openOrClose(state);
            });
        }, {});
    }

    /** @ignore */
    private onCssAnimationStatusChangeChangeEffect() {
        let isFirst = true;
        effect(() => {
            const cssAnimationStatus = this.cssAnimationStatus();
            untracked(() => {
                if (isFirst) {
                    isFirst = false;
                    return;
                }
                if (!this.ifOpenOrCloseWithAnimations(cssAnimationStatus)) {
                    return;
                }
                this.openOrClose(this.state());
            });
        });
    }

    /** @ignore */
    private emitOpenOrClosedEventEffect() {
        let isFirst = true;
        effect(() => {
            this.attachDetachEvent();
            this.cssAnimationStatus();
            untracked(() => {
                if (isFirst) {
                    isFirst = false;
                    return;
                }
                const canEmitOpenClose = untracked(() => this.canEmitOnOpenOrOnClosed());
                if (!canEmitOpenClose) {
                    return;
                }
                this.emitOnOpenOrOnClosed(this.state());
            });
        });
    }

    /** @ignore */
    private onOpenChangeEffect() {
        effect(() => {
            const open = this.open();
            untracked(() => {
                this.setState(open ? RdxPopoverState.OPEN : RdxPopoverState.CLOSED);
            });
        });
    }

    /** @ignore */
    private onIsFirstDefaultOpenChangeEffect() {
        const effectRef = effect(() => {
            const defaultOpen = this.defaultOpen();
            untracked(() => {
                if (!defaultOpen || this.open()) {
                    effectRef.destroy();
                    return;
                }
                this.handleOpen();
            });
        });
    }

    /** @ignore */
    private onAnchorChangeEffect = () => {
        effect(() => {
            const anchor = this.anchor();
            untracked(() => {
                if (anchor) {
                    anchor.setPopoverRoot(this);
                }
            });
        });
    };
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/src/popover-root.inject.ts
```typescript
import { assertInInjectionContext, inject, isDevMode } from '@angular/core';
import { RdxPopoverRootDirective } from './popover-root.directive';

export function injectPopoverRoot(optional?: false): RdxPopoverRootDirective;
export function injectPopoverRoot(optional: true): RdxPopoverRootDirective | null;
export function injectPopoverRoot(optional = false): RdxPopoverRootDirective | null {
    isDevMode() && assertInInjectionContext(injectPopoverRoot);
    return inject(RdxPopoverRootDirective, { optional });
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/src/popover-trigger.directive.ts
```typescript
import { CdkOverlayOrigin } from '@angular/cdk/overlay';
import { computed, Directive, ElementRef, inject } from '@angular/core';
import { injectPopoverRoot } from './popover-root.inject';

@Directive({
    selector: '[rdxPopoverTrigger]',
    hostDirectives: [CdkOverlayOrigin],
    host: {
        type: 'button',
        '[attr.id]': 'name()',
        '[attr.aria-haspopup]': '"dialog"',
        '[attr.aria-expanded]': 'popoverRoot.isOpen()',
        '[attr.aria-controls]': 'popoverRoot.popoverContentDirective().name()',
        '[attr.data-state]': 'popoverRoot.state()',
        '(click)': 'click()'
    }
})
export class RdxPopoverTriggerDirective {
    /** @ignore */
    protected readonly popoverRoot = injectPopoverRoot();
    /** @ignore */
    readonly elementRef = inject<ElementRef<HTMLElement>>(ElementRef);
    /** @ignore */
    readonly overlayOrigin = inject(CdkOverlayOrigin);

    /** @ignore */
    readonly name = computed(() => `rdx-popover-trigger-${this.popoverRoot.uniqueId()}`);

    /** @ignore */
    protected click(): void {
        this.popoverRoot.handleToggle();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/src/popover.types.ts
```typescript
export enum RdxPopoverState {
    OPEN = 'open',
    CLOSED = 'closed'
}

export enum RdxPopoverAttachDetachEvent {
    ATTACH = 'attach',
    DETACH = 'detach'
}

export enum RdxPopoverAnimationStatus {
    OPEN_STARTED = 'open_started',
    OPEN_ENDED = 'open_ended',
    CLOSED_STARTED = 'closed_started',
    CLOSED_ENDED = 'closed_ended'
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/src/utils/cdk-event.service.ts
```typescript
import {
    DestroyRef,
    EnvironmentProviders,
    inject,
    Injectable,
    InjectionToken,
    isDevMode,
    makeEnvironmentProviders,
    NgZone,
    Provider,
    Renderer2,
    VERSION
} from '@angular/core';
import { injectDocument, injectWindow } from '@radix-ng/primitives/core';
import { RdxCdkEventServiceWindowKey } from './constants';
import { EventType, EventTypeAsPrimitiveConfigKey, PrimitiveConfig, PrimitiveConfigs } from './types';

function eventTypeAsPrimitiveConfigKey(eventType: EventType): EventTypeAsPrimitiveConfigKey {
    return `prevent${eventType[0].toUpperCase()}${eventType.slice(1)}` as EventTypeAsPrimitiveConfigKey;
}

@Injectable()
class RdxCdkEventService {
    document = injectDocument();
    destroyRef = inject(DestroyRef);
    ngZone = inject(NgZone);
    renderer2 = inject(Renderer2);
    window = injectWindow();

    primitiveConfigs?: PrimitiveConfigs;

    onDestroyCallbacks: Set<() => void> = new Set([() => deleteRdxCdkEventServiceWindowKey(this.window)]);

    #clickDomRootEventCallbacks: Set<(event: MouseEvent) => void> = new Set();

    constructor() {
        this.#listenToClickDomRootEvent();
        this.#registerOnDestroyCallbacks();
    }

    registerPrimitive<T extends object>(primitiveInstance: T) {
        if (!this.primitiveConfigs) {
            this.primitiveConfigs = new Map();
        }
        if (!this.primitiveConfigs.has(primitiveInstance)) {
            this.primitiveConfigs.set(primitiveInstance, {});
        }
    }

    deregisterPrimitive<T extends object>(primitiveInstance: T) {
        if (this.primitiveConfigs?.has(primitiveInstance)) {
            this.primitiveConfigs.delete(primitiveInstance);
        }
    }

    preventPrimitiveFromCdkEvent<T extends object>(primitiveInstance: T, eventType: EventType) {
        this.#setPreventPrimitiveFromCdkEvent(primitiveInstance, eventType, true);
    }

    allowPrimitiveForCdkEvent<T extends object>(primitiveInstance: T, eventType: EventType) {
        this.#setPreventPrimitiveFromCdkEvent(primitiveInstance, eventType, false);
    }

    preventPrimitiveFromCdkMultiEvents<T extends object>(primitiveInstance: T, eventTypes: EventType[]) {
        eventTypes.forEach((eventType) => {
            this.#setPreventPrimitiveFromCdkEvent(primitiveInstance, eventType, true);
        });
    }

    allowPrimitiveForCdkMultiEvents<T extends object>(primitiveInstance: T, eventTypes: EventType[]) {
        eventTypes.forEach((eventType) => {
            this.#setPreventPrimitiveFromCdkEvent(primitiveInstance, eventType, false);
        });
    }

    setPreventPrimitiveFromCdkMixEvents<T extends object>(primitiveInstance: T, eventTypes: PrimitiveConfig) {
        Object.keys(eventTypes).forEach((eventType) => {
            this.#setPreventPrimitiveFromCdkEvent(
                primitiveInstance,
                eventType as EventType,
                eventTypes[eventTypeAsPrimitiveConfigKey(eventType as EventType)]
            );
        });
    }

    primitivePreventedFromCdkEvent<T extends object>(primitiveInstance: T, eventType: EventType) {
        return this.primitiveConfigs?.get(primitiveInstance)?.[eventTypeAsPrimitiveConfigKey(eventType)];
    }

    addClickDomRootEventCallback(callback: (event: MouseEvent) => void) {
        this.#clickDomRootEventCallbacks.add(callback);
    }

    removeClickDomRootEventCallback(callback: (event: MouseEvent) => void) {
        return this.#clickDomRootEventCallbacks.delete(callback);
    }

    #setPreventPrimitiveFromCdkEvent<
        T extends object,
        R extends EventType,
        K extends PrimitiveConfig[EventTypeAsPrimitiveConfigKey<R>]
    >(primitiveInstance: T, eventType: R, value: K) {
        if (!this.primitiveConfigs?.has(primitiveInstance)) {
            isDevMode() &&
                console.error(
                    '[RdxCdkEventService.preventPrimitiveFromCdkEvent] RDX Primitive instance has not been registered!',
                    primitiveInstance
                );
            return;
        }
        switch (eventType) {
            case 'cdkOverlayOutsideClick':
                this.primitiveConfigs.get(primitiveInstance)!.preventCdkOverlayOutsideClick = value;
                break;
            case 'cdkOverlayEscapeKeyDown':
                this.primitiveConfigs.get(primitiveInstance)!.preventCdkOverlayEscapeKeyDown = value;
                break;
        }
    }

    #registerOnDestroyCallbacks() {
        this.destroyRef.onDestroy(() => {
            this.onDestroyCallbacks.forEach((onDestroyCallback) => onDestroyCallback());
            this.onDestroyCallbacks.clear();
        });
    }

    #listenToClickDomRootEvent() {
        const target = this.document;
        const eventName = 'click';
        const options: boolean | AddEventListenerOptions | undefined = { capture: true };
        const callback = (event: MouseEvent) => {
            this.#clickDomRootEventCallbacks.forEach((clickDomRootEventCallback) => clickDomRootEventCallback(event));
        };

        const major = parseInt(VERSION.major);
        const minor = parseInt(VERSION.minor);

        let destroyClickDomRootEventListener!: () => void;
        /**
         * @see src/cdk/platform/features/backwards-compatibility.ts in @angular/cdk
         */
        if (major > 19 || (major === 19 && minor > 0) || (major === 0 && minor === 0)) {
            destroyClickDomRootEventListener = this.ngZone.runOutsideAngular(() => {
                const destroyClickDomRootEventListenerInternal = this.renderer2.listen(
                    target,
                    eventName,
                    callback,

                    options
                );
                return () => {
                    destroyClickDomRootEventListenerInternal();
                    this.#clickDomRootEventCallbacks.clear();
                };
            });
        } else {
            /**
             * This part can get removed when v19.1 or higher is on the board
             */
            destroyClickDomRootEventListener = this.ngZone.runOutsideAngular(() => {
                target.addEventListener(eventName, callback, options);
                return () => {
                    this.ngZone.runOutsideAngular(() => target.removeEventListener(eventName, callback, options));
                    this.#clickDomRootEventCallbacks.clear();
                };
            });
        }
        this.onDestroyCallbacks.add(destroyClickDomRootEventListener);
    }
}

const RdxCdkEventServiceToken = new InjectionToken<RdxCdkEventService>('RdxCdkEventServiceToken');

const existsErrorMessage = 'RdxCdkEventService should be provided only once!';

const deleteRdxCdkEventServiceWindowKey = (window: Window & typeof globalThis) => {
    delete (window as any)[RdxCdkEventServiceWindowKey];
};

const getProvider: (throwWhenExists?: boolean) => Provider = (throwWhenExists = true) => ({
    provide: RdxCdkEventServiceToken,
    useFactory: () => {
        isDevMode() && console.log('providing RdxCdkEventService...');
        const window = injectWindow();
        if ((window as any)[RdxCdkEventServiceWindowKey]) {
            if (throwWhenExists) {
                throw Error(existsErrorMessage);
            } else {
                isDevMode() && console.warn(existsErrorMessage);
            }
        }
        (window as any)[RdxCdkEventServiceWindowKey] ??= new RdxCdkEventService();
        return (window as any)[RdxCdkEventServiceWindowKey];
    }
});

export const provideRdxCdkEventServiceInRoot: () => EnvironmentProviders = () =>
    makeEnvironmentProviders([getProvider()]);
export const provideRdxCdkEventService: () => Provider = () => getProvider(false);

export const injectRdxCdkEventService = () => inject(RdxCdkEventServiceToken, { optional: true });

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/src/utils/constants.ts
```typescript
export const RdxCdkEventServiceWindowKey = Symbol('__RdxCdkEventService__');

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/popover/src/utils/types.ts
```typescript
export type EventType = 'cdkOverlayOutsideClick' | 'cdkOverlayEscapeKeyDown';
export type EventTypeCapitalized<R extends EventType = EventType> = Capitalize<R>;
export type EventTypeAsPrimitiveConfigKey<R extends EventType = EventType> = `prevent${EventTypeCapitalized<R>}`;
export type PrimitiveConfig = {
    [value in EventTypeAsPrimitiveConfigKey]?: boolean;
};
export type PrimitiveConfigs = Map<object, PrimitiveConfig>;

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/presence/index.ts
```typescript
export * from './src/presence';
export * from './src/transitions/transition.collapse';
export * from './src/transitions/transition.toast';
export * from './src/types';

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/presence/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/presence/__test__/presence-test.component.ts
```typescript
import { Component, ElementRef, NgZone, OnInit } from '@angular/core';
import { usePresence } from '../src/presence';
import { CollapseContext, transitionCollapsing } from '../src/transitions/transition.collapse';

@Component({
    selector: 'app-presence',
    template: `
        <div #element>Presence Component</div>
    `,
    styles: [
        `
            .collapse {
                transition: height 0.5s ease-in-out;
            }
            .collapsing {
                height: 0px;
            }
            .show {
                height: auto;
            }
        `

    ]
})
export class PresenceComponent implements OnInit {
    private context: CollapseContext = {
        direction: 'show',
        dimension: 'height'
    };
    private element!: HTMLElement;

    constructor(
        private zone: NgZone,
        private elRef: ElementRef
    ) {}

    ngOnInit(): void {
        this.element = this.elRef.nativeElement.querySelector('div');
        const options = {
            context: this.context,
            animation: true,
            state: 'stop' as const
        };

        usePresence(this.zone, this.element, transitionCollapsing, options).subscribe();
    }

    getContext(): CollapseContext {
        return this.context;
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/presence/__test__/presence.spec.ts
```typescript
import { NgZone } from '@angular/core';
import { ComponentFixture, fakeAsync, TestBed, tick } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { PresenceComponent } from './presence-test.component';

describe('presence', () => {
    let component: PresenceComponent;
    let fixture: ComponentFixture<PresenceComponent>;
    let zone: NgZone;

    beforeEach(async () => {
        await TestBed.configureTestingModule({
            imports: [PresenceComponent],
            providers: [{ provide: NgZone, useValue: new NgZone({ enableLongStackTrace: false }) }]
        }).compileComponents();

        fixture = TestBed.createComponent(PresenceComponent);
        component = fixture.componentInstance;
        zone = TestBed.inject(NgZone);

        fixture.detectChanges(); // triggers ngOnInit
    });

    it('should create', () => {
        expect(component).toBeTruthy();
    });

    it('should initialize element and context correctly', () => {
        const element = fixture.debugElement.query(By.css('div')).nativeElement;

        const context = component.getContext();

        expect(component['element']).toBe(element);
        expect(context).toEqual({ direction: 'show', dimension: 'height', maxSize: '0px' });
    });

    it('should complete animation correctly', fakeAsync(() => {
        const element = fixture.debugElement.query(By.css('div')).nativeElement;

        zone.runOutsideAngular(() => {
            element.dispatchEvent(new Event('transitionend'));
        });

        tick(600);
        fixture.detectChanges();

        expect(element.classList.contains('collapsing')).toBe(false);
        expect(element.classList.contains('show')).toBe(true);
    }));
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/presence/stories/presence-story.componen.ts
```typescript
import { Component, ElementRef, inject, NgZone, OnInit } from '@angular/core';
import { usePresence } from '../src/presence';
import { CollapseContext, transitionCollapsing } from '../src/transitions/transition.collapse';

@Component({
    selector: 'app-presence',
    standalone: true,
    template: `
        <div>
            <button (click)="toggle()">Toggle</button>
            <div class="collapse-content" #collapseContent>Content to be collapsed</div>
        </div>
    `,
    styles: [
        `
            .collapse-content {
                overflow: hidden;
                transition: height 0.5s ease-in-out;
            }
            .collapse:not(.show) {
                display: none;
            }
            .show {
                height: auto;
            }
        `

    ]
})
export class PresenceStoryComponent implements OnInit {
    private elRef = inject(ElementRef);
    private zone = inject(NgZone);

    private element!: HTMLElement;

    private _isCollapsed = false;
    private afterInit = false;

    set collapsed(isCollapsed: boolean) {
        if (this._isCollapsed !== isCollapsed) {
            this._isCollapsed = isCollapsed;
            if (this.afterInit) {
                this.initCollapse(this._isCollapsed, true);
            }
        }
    }

    ngOnInit(): void {
        this.element = this.elRef.nativeElement.querySelector('.collapse-content');
        this.initCollapse(this._isCollapsed, false);
        this.afterInit = true;
    }

    toggle(open: boolean = this._isCollapsed) {
        this.collapsed = !open;
    }

    private initCollapse(collapsed: boolean, animation: boolean): void {
        const options = {
            context: {
                direction: collapsed ? 'hide' : 'show',
                dimension: 'height'
            } as CollapseContext,
            animation
        };

        usePresence(this.zone, this.element, transitionCollapsing, options).subscribe();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/presence/stories/presence.docs.mdx
````
import { ArgTypes, Canvas, Markdown, Meta } from '@storybook/blocks';

<Meta title="Primitives/Presence" />

# Presence

The `usePresence` function is a utility designed to manage transitions and animations
for DOM elements in an Angular application.
It provides a consistent way to handle animations, ensuring that they run correctly within Angular's zone.

By using `usePresence`, developers can manage transitions and animations in a consistent and performant manner, ensuring that their Angular applications remain responsive and efficient.

## Function Signature

```typescript
export const usePresence = <T>(
  zone: NgZone,
  element: HTMLElement,
  startFn: TransitionStartFn<T>,
  options: TransitionOptions<T>
): Observable<void> => { ... }

```

### Parameters

- `zone` (NgZone): Angular's NgZone service, which is used to manage change detection and ensure that transitions and animations are run outside of Angular's zone, avoiding unnecessary change detection cycles.
- `element` (HTMLElement): The DOM element that the transition will be applied to.
- startFn (`TransitionStartFn<T>`): A function that initiates the transition. It takes the element, the animation flag, and the context as parameters, and returns a cleanup function (TransitionEndFn) to be called when the transition ends.
- options (`TransitionOptions<T>`): An object containing options for the transition.
  - context (T): A context object that provides additional information needed for the transition.
  - animation (boolean): A boolean indicating whether the transition should include animation.
  - state ('stop' | 'continue'): Specifies whether to stop any running transition ('stop') or continue with the current one ('continue'). The default value is 'stop'.
  - transitionTimerDelayMs (number, optional): An optional delay (in milliseconds) to be added to the transition timer. Default value is 5.

## Notes

- Transition Context: The context object can hold any additional data required for the transition. It allows for flexible and reusable transition logic.
- Zone Management: Running transition logic outside Angular's zone prevents unnecessary change detection cycles, improving performance.
- Customizable Delay: The optional transitionTimerDelayMs allows for fine-tuning the transition timing.

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/presence/stories/presence.stories.ts
```typescript
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { PresenceStoryComponent } from './presence-story.componen';

export default {
    title: 'Primitives/Presence',
    decorators: [
        moduleMetadata({
            imports: [PresenceStoryComponent]
        }),
        componentWrapperDecorator(
            (story) =>
                `<div class="radix-themes light light-theme"
                      data-radius="medium"
                      data-scaling="100%">${story}</div>`
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: (args) => ({
        props: args,
        template: `
<app-presence></app-presence>

`
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/presence/src/presence.ts
```typescript
import { NgZone } from '@angular/core';
import { EMPTY, endWith, filter, fromEvent, Observable, of, race, Subject, takeUntil, timer } from 'rxjs';
import { TransitionContext, TransitionEndFn, TransitionOptions, TransitionStartFn } from './types';
import { getTransitionDurationMs, runInZone } from './utils';

const noopFn: TransitionEndFn = () => {
    /* Noop */
};
const TransitionsMap = new Map<HTMLElement, TransitionContext<any>>();

/**
 * Manages the presence of an element with optional transition animation.
 *
 * @template T - The type of the context object used in the transition.
 * @param {NgZone} zone - The Angular zone to control the change detection context.
 * @param {HTMLElement} element - The target HTML element to apply the transition.
 * @param {TransitionOptions<T>} options - Options for controlling the transition behavior.
 *   @param {T} [options.context] - An optional context object to pass through the transition.
 *   @param {boolean} options.animation - A flag indicating if the transition should be animated.
 *   @param {'start' | 'continue' | 'stop'} options.state - The desired state of the transition.
 * @param {TransitionStartFn<T>} startFn - A function to start the transition.
 * @returns {Observable<void>} - An observable that emits when the transition completes.
 *
 * The `usePresence` function is designed to manage the presence and visibility of an HTML element,
 * optionally applying a transition animation. It utilizes Angular's NgZone for efficient change
 * detection management and allows for different states of transitions ('start', 'continue', 'stop').
 * The function takes a start function to handle the beginning of the transition and returns an
 * observable that completes when the transition ends.
 *
 * Example usage:
 *
 * const options: TransitionOptions<MyContext> = {
 *   context: {}, // your context object
 *   animation: true,
 *   state: 'start'
 * };
 *
 * const startFn: TransitionStartFn<MyContext> = (el, animation, context) => {
 *   el.classList.add('active');
 *   return () => el.classList.remove('active');
 * };
 *
 * usePresence(zone, element, startFn, options).subscribe(() => {
 *   console.log('Transition completed');
 * });
 */
const usePresence = <T>(
    zone: NgZone,
    element: HTMLElement,
    startFn: TransitionStartFn<T>,
    options: TransitionOptions<T>
): Observable<void> => {
    let context = options.context || <T>{};

    const transitionTimerDelayMs = options.transitionTimerDelayMs ?? 5;
    const state = options.state ?? 'stop';

    const running = TransitionsMap.get(element);

    if (running) {
        switch (state) {
            case 'continue':
                return EMPTY;
            case 'stop':
                zone.run(() => running.transition$.complete());
                context = { ...running.context, ...context };
                TransitionsMap.delete(element);
                break;
        }
    }
    const endFn = startFn(element, options.animation, context) || noopFn;

    if (!options.animation || window.getComputedStyle(element).transitionProperty === 'none') {
        zone.run(() => endFn());
        return of(undefined).pipe(runInZone(zone));
    }

    const transition$ = new Subject<void>();
    const finishTransition$ = new Subject<void>();
    const stop$ = transition$.pipe(endWith(true));

    TransitionsMap.set(element, {
        transition$,
        complete: () => {
            finishTransition$.next();
            finishTransition$.complete();
        },
        context
    });

    const transitionDurationMs = getTransitionDurationMs(element);

    zone.runOutsideAngular(() => {
        const transitionEnd$ = fromEvent<TransitionEvent>(element, 'transitionend').pipe(
            filter(({ target }) => target === element),
            takeUntil(stop$)
        );
        const timer$ = timer(transitionDurationMs + transitionTimerDelayMs).pipe(takeUntil(stop$));

        race(timer$, transitionEnd$, finishTransition$)
            .pipe(takeUntil(stop$))
            .subscribe(() => {
                TransitionsMap.delete(element);
                zone.run(() => {
                    endFn();
                    transition$.next();
                    transition$.complete();
                });
            });
    });

    return transition$.asObservable();
};

const completeTransition = (element: HTMLElement) => {
    TransitionsMap.get(element)?.complete();
};

export { completeTransition, usePresence };

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/presence/src/types.ts
```typescript
import { Subject } from 'rxjs';

type TransitionOptions<T> = {
    context?: T;
    animation: boolean;
    state?: 'continue' | 'stop';
    transitionTimerDelayMs?: number;
};

type TransitionContext<T> = {
    transition$: Subject<any>;
    complete: () => void;
    context: T;
};

type TransitionStartFn<T = any> = (element: HTMLElement, animation: boolean, context: T) => TransitionEndFn | void;

type TransitionEndFn = () => void;

export { TransitionContext, TransitionEndFn, TransitionOptions, TransitionStartFn };

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/presence/src/utils.ts
```typescript
import { NgZone } from '@angular/core';
import { Observable } from 'rxjs';

/**
 * Ensures that the observable stream runs inside Angular's NgZone.
 *
 * This function is a higher-order function that takes an observable stream as input and ensures
 * that all emissions, errors, and completion notifications are run inside Angular's NgZone. This
 * is particularly useful for ensuring that change detection is triggered properly in Angular
 * applications.
 *
 * @template T - The type of the items emitted by the observable.
 * @param {NgZone} zone - The Angular zone to control the change detection context.
 * @returns {(source: Observable<T>) => Observable<T>} - A function that takes an observable as input
 * and returns an observable that runs inside Angular's NgZone.
 *
 * Example usage:
 *
 * const source$ = of('some value');
 * const zoned$ = source$.pipe(runInZone(zone));
 * zoned$.subscribe(value => {
 *   console.log('Value:', value);
 * });
 */
function runInZone<T>(zone: NgZone): (source: Observable<T>) => Observable<T> {
    return (source: Observable<T>) =>
        new Observable((observer) =>
            source.subscribe({
                next: (value) => zone.run(() => observer.next(value)),
                error: (err) => zone.run(() => observer.error(err)),
                complete: () => zone.run(() => observer.complete())
            })
        );
}

/**
 * Calculates the total transition duration in milliseconds for a given HTML element.
 *
 * This function retrieves the computed style of the specified element and extracts the
 * transition duration and delay properties. It then converts these values from seconds
 * to milliseconds and returns their sum, representing the total transition duration.
 *
 * @param {HTMLElement} element - The HTML element for which to calculate the transition duration.
 * @returns {number} - The total transition duration in milliseconds.
 *
 * Example usage:
 *
 * const durationMs = getTransitionDurationMs(element);
 * console.log(`Transition duration: ${durationMs} ms`);
 */
function getTransitionDurationMs(element: HTMLElement): number {
    const { transitionDelay, transitionDuration } = window.getComputedStyle(element);
    const transitionDelaySec = parseFloat(transitionDelay);
    const transitionDurationSec = parseFloat(transitionDuration);

    return (transitionDelaySec + transitionDurationSec) * 1000;
}

export { getTransitionDurationMs, runInZone };

export function triggerReflow(element: HTMLElement) {
    return (element || document.body).getBoundingClientRect();
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/presence/src/transitions/transition.collapse.ts
```typescript
import { TransitionStartFn } from '../types';
import { triggerReflow } from '../utils';

export type CollapseContext = {
    direction: 'show' | 'hide';
    dimension: 'width' | 'height';
    maxSize?: string;
};

// Define constants for class names
const COLLAPSE_CLASS = 'collapse';
const COLLAPSING_CLASS = 'collapsing';
const SHOW_CLASS = 'show';
/**
 * Function to handle the start of a collapsing transition.
 *
 * @param element - The HTML element to animate.
 * @param animation - Whether to use animation or not.
 * @param context - The context containing direction and dimension information.
 * @returns A function to clean up the animation.
 */
export const transitionCollapsing: TransitionStartFn<CollapseContext> = (
    element: HTMLElement,
    animation: boolean,
    context: CollapseContext
) => {
    const { direction, dimension } = context;
    let { maxSize } = context;
    const { classList } = element;

    /**
     * Sets initial classes based on the direction.
     */
    function setInitialClasses() {
        classList.add(COLLAPSE_CLASS);
        if (direction === 'show') {
            classList.add(SHOW_CLASS);
        } else {
            classList.remove(SHOW_CLASS);
        }
    }

    if (!animation) {
        setInitialClasses();
        return;
    }

    if (!maxSize) {
        maxSize = measureCollapsingElementDimensionPx(element, dimension);
        context.maxSize = maxSize;

        // Fix the height before starting the animation
        element.style[dimension] = direction !== 'show' ? maxSize : '0px';

        classList.remove(COLLAPSE_CLASS, COLLAPSING_CLASS, 'show');

        triggerReflow(element);

        // Start the animation
        classList.add(COLLAPSING_CLASS);
    }

    element.style[dimension] = direction === 'show' ? maxSize : '0px';

    return () => {
        setInitialClasses();
        classList.remove(COLLAPSING_CLASS);
        element.style[dimension] = '';
    };
};

/**
 * Measures the dimension of the collapsing element in pixels.
 *
 * @param element - The HTML element to measure.
 * @param dimension - The dimension ('width' or 'height') to measure.
 * @returns The size of the dimension in pixels.
 */
function measureCollapsingElementDimensionPx(element: HTMLElement, dimension: 'width' | 'height'): string {
    // SSR fix
    if (typeof navigator === 'undefined') {
        return '0px';
    }

    const { classList } = element;
    const hasShownClass = classList.contains(SHOW_CLASS);
    if (!hasShownClass) {
        classList.add(SHOW_CLASS);
    }

    element.style[dimension] = '';
    const dimensionSize = element.getBoundingClientRect()[dimension] + 'px';

    if (!hasShownClass) {
        classList.remove(SHOW_CLASS);
    }

    return dimensionSize;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/presence/src/transitions/transition.toast.ts
```typescript
import { TransitionStartFn } from '../types';
import { triggerReflow } from '../utils';

export const toastFadeInTransition: TransitionStartFn = (element: HTMLElement, animation: boolean) => {
    const { classList } = element;

    if (animation) {
        classList.add('fade');
    } else {
        classList.add('show');
        return;
    }

    triggerReflow(element);
    classList.add('show', 'showing');

    return () => {
        classList.remove('showing');
    };
};

export const toastFadeOutTransition: TransitionStartFn = ({ classList }: HTMLElement) => {
    classList.add('showing');
    return () => {
        classList.remove('show', 'showing');
    };
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/button/src/button.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { booleanAttribute, computed, Directive, input } from '@angular/core';

export type ButtonType = 'button' | 'submit' | 'reset';

let nextId = 0;

@Directive({
    selector: '[rdxButton]',
    standalone: true,
    host: {
        '[attr.id]': 'id()',
        '[attr.type]': 'type()',
        '[attr.tabindex]': 'tabIndex()',

        '[attr.aria-disabled]': 'ariaDisabled()',
        '[attr.aria-pressed]': 'isActive()',

        '[attr.disabled]': 'attrDisabled()'
    }
})
export abstract class RdxButtonDirective {
    readonly id = input<string>(`rdx-button-${nextId++}`);

    readonly type = input<ButtonType>('button');

    readonly active = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    readonly isLoading = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    readonly disabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    readonly #_disabled = computed(() => this.disabled());

    readonly ariaDisabled = computed(() => {
        return this.#_disabled() ? true : undefined;
    });

    readonly attrDisabled = computed(() => {
        return this.#_disabled() ? '' : undefined;
    });

    readonly tabIndex = computed(() => {
        return this.#_disabled() ? '-1' : undefined;
    });

    readonly isActive = computed(() => {
        return <boolean>this.active() || undefined;
    });
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/collapsible/README.md
```
# @radix-ng/primitives/collapsible

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/collapsible/index.ts
```typescript
export * from './src/collapsible-content.directive';
export * from './src/collapsible-root.directive';
export * from './src/collapsible-trigger.directive';

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/collapsible/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/collapsible/stories/collapsible-animation.component.ts
```typescript
import { animate, state, style, transition, trigger } from '@angular/animations';
import { Component } from '@angular/core';
import { LucideAngularModule } from 'lucide-angular';
import { RdxCollapsibleContentDirective } from '../src/collapsible-content.directive';
import { RdxCollapsibleRootDirective } from '../src/collapsible-root.directive';
import { RdxCollapsibleTriggerDirective } from '../src/collapsible-trigger.directive';

@Component({
    selector: 'rdx-collapsible-animation',
    imports: [
        RdxCollapsibleRootDirective,
        RdxCollapsibleTriggerDirective,
        RdxCollapsibleContentDirective,
        LucideAngularModule
    ],
    // prettier-ignore
    animations: [
        trigger('contentExpansion', [
            state('expanded', style({ height: '*', opacity: 1, visibility: 'visible' })),
            state('collapsed', style({ height: '0px', opacity: 0, visibility: 'hidden' })),
            transition('expanded <=> collapsed', animate('200ms cubic-bezier(.37,1.04,.68,.98)'))
        ])
    ],
    styles: `
        button {
            all: unset;
        }

        .CollapsibleRoot {
            width: 300px;
        }

        .IconButton {
            font-family: inherit;
            border-radius: 100%;
            height: 25px;
            width: 25px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: var(--violet-11);
            box-shadow: 0 2px 10px var(--black-a7);
        }

        .IconButton[data-state='closed'] {
            background-color: white;
        }

        .IconButton[data-state='open'] {
            background-color: var(--violet-3);
        }

        .IconButton:hover {
            background-color: var(--violet-3);
        }

        .IconButton:focus {
            box-shadow: 0 0 0 2px black;
        }

        .Text {
            color: var(--violet-11);
            font-size: 15px;
            line-height: 25px;
        }

        .Repository {
            background-color: white;
            border-radius: 4px;
            margin: 10px 0;
            padding: 10px;
            box-shadow: 0 2px 10px var(--black-a7);
        }
    `,
    template: `
        <div
            class="CollapsibleRoot"
            #collapsibleRoot="collapsibleRoot"
            [open]="open"
            (onOpenChange)="onOpenChange($event)"
            rdxCollapsibleRoot
        >
            <div style="display: flex; align-items: center; justify-content: space-between;">
                <span class="Text" style="color: white">&#64;peduarte starred 3 repositories</span>
                <button class="IconButton" rdxCollapsibleTrigger>
                    @if (open) {
                        <lucide-angular size="16" name="x" style="display: flex;" />
                    } @else {
                        <lucide-angular size="16" name="unfold-vertical" style="display: flex;" />
                    }
                </button>
            </div>

            <div class="Repository">
                <span class="Text">&#64;radix-ui/primitives</span>
            </div>

            <div [@contentExpansion]="collapsibleRoot.isOpen() ? 'expanded' : 'collapsed'" rdxCollapsibleContent>
                <div class="Repository">
                    <span class="Text">&#64;radix-ui/colors</span>
                </div>
                <div class="Repository">
                    <span class="Text">&#64;stitches/react</span>
                </div>
            </div>
        </div>
    `
})
export class RdxCollapsibleAnimationComponent {
    open = true;

    onOpenChange($event: boolean) {
        this.open = $event;
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/collapsible/stories/collapsible-external-triggering.component.ts
```typescript
import { Component } from '@angular/core';
import { LucideAngularModule } from 'lucide-angular';
import { RdxCollapsibleContentDirective } from '../src/collapsible-content.directive';
import { RdxCollapsibleRootDirective } from '../src/collapsible-root.directive';

@Component({
    selector: 'rdx-collapsible-external-triggering',
    imports: [
        RdxCollapsibleRootDirective,
        RdxCollapsibleContentDirective,
        LucideAngularModule
    ],
    styles: `
        .CollapsibleRoot {
            width: 300px;
        }

        .ExternalTrigger {
            font-family: inherit;
            border-radius: 8px;

            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: var(--violet-11);
            box-shadow: 0 2px 10px var(--black-a7);
            margin-bottom: 10px;
            padding: 4px;
        }

        .ExternalTrigger[data-state='closed'] {
            background-color: white;
        }

        .ExternalTrigger[data-state='open'] {
            background-color: var(--violet-3);
        }

        .ExternalTrigger:hover {
            background-color: var(--violet-3);
        }

        .ExternalTrigger:focus {
            box-shadow: 0 0 0 2px black;
        }

        .Text {
            color: var(--violet-11);
            font-size: 15px;
            line-height: 25px;
        }

        .Repository {
            background-color: white;
            border-radius: 4px;
            margin: 10px 0;
            padding: 10px;
            box-shadow: 0 2px 10px var(--black-a7);
        }
    `,
    template: `
        <button class="ExternalTrigger" (click)="open = !open">External Trigger</button>
        <div class="CollapsibleRoot" #collapsibleRoot="collapsibleRoot" [open]="open" rdxCollapsibleRoot>
            <div style="display: flex; align-items: center; justify-content: space-between;">
                <span class="Text" style="color: white">&#64;peduarte starred 3 repositories</span>
            </div>

            <div class="Repository">
                <span class="Text">&#64;radix-ui/primitives</span>
            </div>

            <div rdxCollapsibleContent>
                <div class="Repository">
                    <span class="Text">&#64;radix-ui/colors</span>
                </div>
                <div class="Repository">
                    <span class="Text">&#64;stitches/react</span>
                </div>
            </div>
        </div>
    `
})
export class RdxCollapsibleExternalTriggeringComponent {
    open = true;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/collapsible/stories/collapsible.docs.mdx
````
import { ArgTypes, Canvas, Meta } from '@storybook/blocks';
import * as CollapsibleStories from './collapsible.stories';
import { RdxCollapsibleRootDirective } from '../src/collapsible-root.directive';

<Meta title="Primitives/Collapsible" />

# Collapsible

#### An interactive component which expands/collapses a panel.

<Canvas sourceState="hidden" of={CollapsibleStories.Default} />

## Features

- âœ… Full keyboard navigation.
- âœ… Can be controlled or uncontrolled.

## Anatomy

```html
<div rdxCollapsibleRoot>
  <button rdxCollapsibleTrigger>Trigger</button>
  <div rdxCollapsibleContent>Content</div>
</div>
```

## Import

Get started with importing the directives:

```typescript
import {
  RdxCollapsibleRootDirective,
  RdxCollapsibleTriggerDirective,
  RdxCollapsibleContentDirective
} from '@radix-ng/primitives/collapsible';
```

## API Reference

### Root

`RdxCollapsibleRootDirective`

<ArgTypes of={RdxCollapsibleRootDirective} />

### Trigger

`RdxCollapsibleTriggerDirective`


### Content

`RdxCollapsibleContentDirective`

## Examples

### Animation

<Canvas sourceState="hidden" of={CollapsibleStories.Animation} />

### External Trigger

<Canvas sourceState="hidden" of={CollapsibleStories.ExternalTrigger} />

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/collapsible/stories/collapsible.stories.ts
```typescript
import { BrowserAnimationsModule, provideAnimations } from '@angular/platform-browser/animations';
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { LucideAngularModule, UnfoldVertical, X } from 'lucide-angular';
import { RdxCollapsibleContentDirective } from '../src/collapsible-content.directive';
import { RdxCollapsibleRootDirective } from '../src/collapsible-root.directive';
import { RdxCollapsibleTriggerDirective } from '../src/collapsible-trigger.directive';
import { RdxCollapsibleAnimationComponent } from './collapsible-animation.component';
import { RdxCollapsibleExternalTriggeringComponent } from './collapsible-external-triggering.component';

const html = String.raw;

export default {
    title: 'Primitives/Collapsible',
    decorators: [
        moduleMetadata({
            imports: [
                RdxCollapsibleRootDirective,
                RdxCollapsibleTriggerDirective,
                RdxCollapsibleContentDirective,
                RdxCollapsibleExternalTriggeringComponent,
                RdxCollapsibleAnimationComponent,
                BrowserAnimationsModule,
                LucideAngularModule,
                LucideAngularModule.pick({ X, UnfoldVertical })
            ],
            providers: [provideAnimations()]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div
                    class="radix-themes light light-theme radix-themes-default-fonts"
                    data-accent-color="indigo"
                    data-radius="medium"
                    data-scaling="100%"
                >
                    ${story}
                </div>

                <style>
                    button {
                        all: unset;
                    }
                    .CollapsibleRoot {
                        width: 300px;
                    }

                    .IconButton {
                        font-family: inherit;
                        border-radius: 100%;
                        height: 25px;
                        width: 25px;
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                        color: var(--violet-11);
                        box-shadow: 0 2px 10px var(--black-a7);
                    }

                    .IconButton[data-state='closed'] {
                        background-color: white;
                    }

                    .IconButton[data-state='open'] {
                        background-color: var(--violet-3);
                    }

                    .IconButton:hover {
                        background-color: var(--violet-3);
                    }

                    .IconButton:focus {
                        box-shadow: 0 0 0 2px black;
                    }

                    .Text {
                        color: var(--violet-11);
                        font-size: 15px;
                        line-height: 25px;
                    }

                    .Repository {
                        background-color: white;
                        border-radius: 4px;
                        margin: 10px 0;
                        padding: 10px;
                        box-shadow: 0 2px 10px var(--black-a7);
                    }
                </style>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: html`
            <div class="CollapsibleRoot" rdxCollapsibleRoot [open]="true" #collapsibleRoot="collapsibleRoot">
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <span class="Text" style="color: white">&#64;peduarte starred 3 repositories</span>
                    <button class="IconButton" rdxCollapsibleTrigger>
                        @if (collapsibleRoot.isOpen()) {
                        <lucide-angular size="16" name="x" style="display: flex;"></lucide-angular>
                        } @else {
                        <lucide-angular size="16" name="unfold-vertical" style="display: flex;"></lucide-angular>
                        }
                    </button>
                </div>

                <div class="Repository">
                    <span class="Text">&#64;radix-ui/primitives</span>
                </div>

                <div rdxCollapsibleContent>
                    <div class="Repository">
                        <span class="Text">&#64;radix-ui/colors</span>
                    </div>
                    <div class="Repository">
                        <span class="Text">&#64;stitches/react</span>
                    </div>
                </div>
            </div>
        `
    })
};

export const ExternalTrigger: Story = {
    render: () => ({
        template: html`
            <div
                class="radix-themes light light-theme radix-themes-default-fonts"
                data-accent-color="indigo"
                data-radius="medium"
                data-scaling="100%"
            >
                <rdx-collapsible-external-triggering></rdx-collapsible-external-triggering>
            </div>
        `
    })
};

export const Animation: Story = {
    render: () => ({
        template: html`
            <div
                class="radix-themes light light-theme radix-themes-default-fonts"
                data-accent-color="indigo"
                data-radius="medium"
                data-scaling="100%"
            >
                <rdx-collapsible-animation></rdx-collapsible-animation>
            </div>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/collapsible/__tests__/collapsible-content.directive.spec.ts
```typescript
import { Component } from '@angular/core';
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { RdxCollapsibleContentDirective } from '../src/collapsible-content.directive';
import { RdxCollapsibleRootDirective } from '../src/collapsible-root.directive';

@Component({
    selector: 'rdx-collapsible-mock-trigger',
    standalone: true,
    imports: [RdxCollapsibleRootDirective, RdxCollapsibleContentDirective],
    template: `
        <div CollapsibleRoot>
            <div CollapsibleContent>Content</div>
        </div>
    `
})
class RdxCollapsibleMockComponent {}

describe('RdxCollapsibleContentDirective', () => {
    let component: RdxCollapsibleMockComponent;
    let fixture: ComponentFixture<RdxCollapsibleMockComponent>;

    beforeEach(() => {
        fixture = TestBed.createComponent(RdxCollapsibleMockComponent);
        component = fixture.componentInstance;
    });

    it('should create an instance', () => {
        expect(component).toBeTruthy();
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/collapsible/__tests__/collapsible-root.directive.spec.ts
```typescript
import { Component } from '@angular/core';
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { RdxCollapsibleRootDirective } from '../src/collapsible-root.directive';

@Component({
    selector: 'rdx-collapsible-mock-trigger',
    standalone: true,
    imports: [RdxCollapsibleRootDirective],
    template: `
        <div CollapsibleRoot></div>
    `
})
class RdxCollapsibleMockComponent {}

describe('RdxCollapsibleRootDirective', () => {
    let component: RdxCollapsibleMockComponent;
    let fixture: ComponentFixture<RdxCollapsibleMockComponent>;

    beforeEach(() => {
        fixture = TestBed.createComponent(RdxCollapsibleMockComponent);
        component = fixture.componentInstance;
    });

    it('should create an instance', () => {
        expect(component).toBeTruthy();
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/collapsible/__tests__/collapsible-trigger.directive.spec.ts
```typescript
import { Component } from '@angular/core';
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { RdxCollapsibleRootDirective } from '../src/collapsible-root.directive';
import { RdxCollapsibleTriggerDirective } from '../src/collapsible-trigger.directive';

@Component({
    selector: 'rdx-collapsible-mock-trigger',
    standalone: true,
    imports: [RdxCollapsibleRootDirective, RdxCollapsibleTriggerDirective],
    template: `
        <div CollapsibleRoot>
            <button CollapsibleTrigger>Trigger</button>
        </div>
    `
})
class RdxCollapsibleMockComponent {}

describe('RdxCollapsibleTriggerDirective', () => {
    let component: RdxCollapsibleMockComponent;
    let fixture: ComponentFixture<RdxCollapsibleMockComponent>;

    beforeEach(() => {
        fixture = TestBed.createComponent(RdxCollapsibleMockComponent);
        component = fixture.componentInstance;
    });

    it('should create an instance', () => {
        expect(component).toBeTruthy();
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/collapsible/src/collapsible-content.directive.ts
```typescript
import { Directive, ElementRef, inject } from '@angular/core';
import { RdxCollapsibleContentToken } from './collapsible-content.token';
import { RdxCollapsibleRootDirective } from './collapsible-root.directive';

@Directive({
    selector: '[rdxCollapsibleContent]',
    providers: [
        {
            provide: RdxCollapsibleContentToken,
            useExisting: RdxCollapsibleContentDirective
        }
    ],
    host: {
        '[attr.data-state]': 'collapsible.getState()',
        '[attr.data-disabled]': 'getDisabled()'
    }
})
export class RdxCollapsibleContentDirective {
    protected readonly collapsible = inject(RdxCollapsibleRootDirective);

    /**
     * Reference to CollapsibleContent host element
     * @ignore
     */
    readonly elementRef = inject<ElementRef<HTMLElement>>(ElementRef);

    getDisabled(): string | undefined {
        return this.collapsible.disabled() ? 'disabled' : undefined;
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/collapsible/src/collapsible-content.token.ts
```typescript
import { InjectionToken } from '@angular/core';
import { RdxCollapsibleContentDirective } from './collapsible-content.directive';

export const RdxCollapsibleContentToken = new InjectionToken<RdxCollapsibleContentDirective>(
    'RdxCollapsibleContentToken'
);

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/collapsible/src/collapsible-root.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { booleanAttribute, contentChild, Directive, inject, InjectionToken, input, Input, output } from '@angular/core';
import { asyncScheduler } from 'rxjs';
import { RdxCollapsibleContentToken } from './collapsible-content.token';

const RdxCollapsibleRootToken = new InjectionToken<RdxCollapsibleRootDirective>('RdxCollapsibleRootToken');

export function injectCollapsible(): RdxCollapsibleRootDirective {
    return inject(RdxCollapsibleRootDirective);
}

export type RdxCollapsibleState = 'open' | 'closed';

/**
 * @group Components
 */
@Directive({
    selector: '[rdxCollapsibleRoot]',
    exportAs: 'collapsibleRoot',
    providers: [{ provide: RdxCollapsibleRootToken, useExisting: RdxCollapsibleRootDirective }],
    host: {
        '[attr.data-state]': 'getState()',
        '[attr.data-disabled]': 'disabled() ? "" : undefined'
    }
})
export class RdxCollapsibleRootDirective {
    /**
     * Reference to RdxCollapsibleContent directive
     */
    private readonly contentDirective = contentChild.required(RdxCollapsibleContentToken);

    /**
     * Determines whether a directive is available for interaction.
     * When true, prevents the user from interacting with the collapsible.
     *
     * @group Props
     */
    readonly disabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * The controlled open state of the collapsible.
     * Sets the state of the directive. `true` - expanded, `false` - collapsed
     *
     * @group Props
     * @defaultValue false
     */
    @Input() set open(value: boolean) {
        if (value !== this._open) {
            this.onOpenChange.emit(value);
        }

        this._open = value;
        this.setPresence();
    }

    get open(): boolean {
        return this._open;
    }

    /**
     * Stores collapsible state
     */
    private _open = false;

    /**
     * Emitted with new value when directive state changed.
     * Event handler called when the open state of the collapsible changes.
     *
     * @group Emits
     */
    readonly onOpenChange = output<boolean>();

    /**
     * Allows to change directive state
     * @param {boolean | undefined} value
     * @ignore
     */
    setOpen(value?: boolean) {
        if (this.disabled()) {
            return;
        }

        if (value === undefined) {
            this.open = !this.open;
        } else {
            this.open = value;
        }

        this.setPresence();
    }

    /**
     * Returns directive state (open | closed)
     * @ignore
     */
    getState(): RdxCollapsibleState {
        return this.open ? 'open' : 'closed';
    }

    /**
     * Returns current directive state
     * @ignore
     */
    isOpen(): boolean {
        return this.open;
    }

    /**
     * Controls visibility of content
     */
    private setPresence(): void {
        if (!this.contentDirective) {
            return;
        }

        if (this.isOpen()) {
            this.contentDirective().elementRef.nativeElement.removeAttribute('hidden');
        } else {
            asyncScheduler.schedule(() => {
                const animations = this.contentDirective().elementRef.nativeElement.getAnimations();

                if (animations === undefined || animations.length === 0) {
                    this.contentDirective().elementRef.nativeElement.setAttribute('hidden', '');
                }
            });
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/collapsible/src/collapsible-trigger.directive.ts
```typescript
import { Directive } from '@angular/core';
import { injectCollapsible, RdxCollapsibleState } from './collapsible-root.directive';

@Directive({
    selector: '[rdxCollapsibleTrigger]',
    host: {
        '[attr.data-state]': 'getState()',
        '[attr.data-disabled]': 'getDisabled()',
        '[attr.aria-expanded]': 'getState() === "open" ? "true" : "false"',
        '[disabled]': 'getDisabled()',

        '(click)': 'onOpenToggle()'
    }
})
export class RdxCollapsibleTriggerDirective {
    /**
     * Reference to CollapsibleRoot
     * @private
     * @ignore
     */
    private readonly collapsible = injectCollapsible();

    /**
     * Called on trigger clicked
     */
    onOpenToggle(): void {
        this.collapsible.setOpen();
    }

    /**
     * Returns current directive state (open | closed)
     * @ignore
     */
    getState(): RdxCollapsibleState {
        return this.collapsible.getState();
    }

    /**
     * Returns current trigger state
     * @ignore
     */
    getDisabled(): string | undefined {
        return this.collapsible.disabled() ? 'disabled' : undefined;
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/visually-hidden/README.md
```
# @radix-ng/primitives/visually-hidden

Secondary entry point of `@radix-ng/primitives`. It can be used by importing from `@radix-ng/primitives/visually-hidden`.

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/visually-hidden/index.ts
```typescript
export * from './src/visually-hidden-input-bubble.directive';
export * from './src/visually-hidden-input.directive';
export * from './src/visually-hidden.directive';

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/visually-hidden/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/visually-hidden/stories/visually-hidden-input.stories.ts
```typescript
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { RdxVisuallyHiddenInputBubbleDirective } from '../src/visually-hidden-input-bubble.directive';
import { RdxVisuallyHiddenInputDirective } from '../src/visually-hidden-input.directive';
import { RdxVisuallyHiddenDirective } from '../src/visually-hidden.directive';

const html = String.raw;

export default {
    title: 'Utilities/Visually-HiddenInput',
    decorators: [
        moduleMetadata({
            imports: [
                RdxVisuallyHiddenDirective,
                RdxVisuallyHiddenInputBubbleDirective,
                RdxVisuallyHiddenInputDirective
            ]
        }),
        componentWrapperDecorator(
            (story) =>
                `
                    <div class="radix-themes light light-theme"
                      data-radius="medium"
                      data-scaling="100%">${story}</div>`
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: (args) => ({
        props: args,
        template: html`
            <div>
                <div>
                    <label class="Label" for="visibleInput">Visible Input:</label>
                    <input class="Input" id="visibleInput" type="text" name="visibleInput" value="Visible Input" />
                </div>

                <div>
                    <label for="hiddenInput">Hidden Input:</label>
                    <input
                        rdxVisuallyHiddenInput
                        [feature]="'fully-hidden'"
                        [name]="'hiddenInput'"
                        [value]="'Hidden Value'"
                        [checked]="true"
                        [required]="true"
                        [disabled]="false"
                    />
                </div>

                <input
                    rdxVisuallyHiddenInput
                    [feature]="'fully-hidden'"
                    [name]="'testInput'"
                    [value]="{ key1: 'value1', key2: 'value2' }"
                    [checked]="true"
                    [required]="true"
                />
                <p>The input above is visually hidden but still interactable.</p>
            </div>

            <style>
                p {
                    color: white;
                    font-size: 15px;
                }

                input {
                    all: unset;
                }

                .Input {
                    width: 200px;
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                    border-radius: 4px;
                    padding: 0 10px;
                    margin-left: 10px;
                    height: 35px;
                    font-size: 15px;
                    line-height: 1;
                    color: white;
                    background-color: var(--black-a5);
                    box-shadow: 0 0 0 1px var(--black-a9);
                }

                .Input:focus {
                    box-shadow: 0 0 0 2px black;
                }
                .Input::selection {
                    background-color: var(--black-a9);
                    color: white;
                }

                label {
                    color: white;
                    font-size: 15px;
                    line-height: 35px;
                    font-weight: 500;
                }
            </style>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/visually-hidden/stories/visually-hidden.docs.mdx
````
import { Meta } from '@storybook/blocks';

<Meta title="Utilities/Visually Hidden" />

# Visually Hidden

#### Hides content from the screen in an accessible way.

#### You can use also [a11y](https://material.angular.io/cdk/a11y), they also have an auxiliary class for this.

## Features

- âœ… Visually hides content while preserving it for assistive technology.

## Import

Screen readers and other assistive technology skip elements that have display: none, visibility: hidden, opacity: 0, height: 0, or width: 0. In some cases you may need to visually hide an element while keeping it available to assistive technology.
You can do so using the a11y-visually-hidden Sass mixin, which emits the .cdk-visually-hidden CSS class:

```scss
@use '@angular/cdk';

@include cdk.a11y-visually-hidden();
```

## Examples

```html
<div class="custom-checkbox">
  <input class="cdk-visually-hidden" type="checkbox" />
</div>
```

## Accessibility

This is useful in certain scenarios as an alternative to traditional labelling with aria-label or aria-labelledby.

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/visually-hidden/src/visually-hidden-input-bubble.directive.ts
```typescript
import { Directive, effect, ElementRef, inject, input, linkedSignal } from '@angular/core';
import { RdxVisuallyHiddenDirective } from './visually-hidden.directive';

/**
 *
 */
@Directive({
    selector: 'input[rdxVisuallyHiddenInputBubble]',
    hostDirectives: [{ directive: RdxVisuallyHiddenDirective, inputs: ['feature: feature'] }],
    host: {
        '[attr.name]': 'name()',
        '[attr.required]': 'required()',
        '[attr.disabled]': 'disabled()',
        '[attr.checked]': 'checked()',
        '[value]': 'value()',
        '(change)': 'onChange()'
    }
})
export class RdxVisuallyHiddenInputBubbleDirective<T> {
    private readonly elementRef = inject(ElementRef);

    readonly name = input<string>('');
    readonly value = input<T | string | null>();
    readonly checked = input<boolean | undefined>(undefined);
    readonly required = input<boolean | undefined>(undefined);
    readonly disabled = input<boolean | undefined>(undefined);
    readonly feature = input<string>('fully-hidden');

    protected readonly valueEffect = linkedSignal({
        source: this.value,
        computation: (value: NoInfer<string | T | null | undefined>) => value
    });

    constructor() {
        effect(() => {
            this.updateInputValue();
        });
    }

    updateValue(value: string) {
        this.valueEffect.set(value);
    }

    protected onChange() {
        this.updateInputValue();
    }

    private updateInputValue() {
        let valueChanged = false;
        let checkedChanged = false;

        // Check if the value has changed before applying the update
        const currentValue = this.inputElement.value;
        const newValue = String(this.value());

        if (currentValue !== newValue) {
            this.inputElement.value = newValue;
            valueChanged = true;
        }

        if (this.inputElement.type === 'checkbox' || this.inputElement.type === 'radio') {
            const currentChecked = this.inputElement.checked;
            const newChecked = !!this.checked();

            if (currentChecked !== newChecked) {
                this.inputElement.checked = newChecked;
                checkedChanged = true;
            }
        }

        if (valueChanged || checkedChanged) {
            this.dispatchInputEvents();
        }
    }

    private get inputElement() {
        return this.elementRef.nativeElement;
    }

    private dispatchInputEvents() {
        const inputEvent = new Event('input', { bubbles: true });
        const changeEvent = new Event('change', { bubbles: true });

        this.inputElement.dispatchEvent(inputEvent);
        this.inputElement.dispatchEvent(changeEvent);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/visually-hidden/src/visually-hidden-input.directive.ts
```typescript
// Implementation from https://github.com/unovue/radix-vue

import { Directive, ElementRef, OnInit, computed, inject, input } from '@angular/core';
import { RdxVisuallyHiddenInputBubbleDirective } from './visually-hidden-input-bubble.directive';

@Directive({
    selector: '[rdxVisuallyHiddenInput]',
    hostDirectives: [
        {
            directive: RdxVisuallyHiddenInputBubbleDirective,
            inputs: [
                'feature: feature',
                'name: name ',
                'value: value',
                'checked: checked',
                'disabled: disabled',
                'required: required'
            ]
        }
    ]
})
export class RdxVisuallyHiddenInputDirective<T> implements OnInit {
    private readonly elementRef = inject(ElementRef);

    readonly name = input<string>('');
    readonly value = input<T | string>();
    readonly checked = input<boolean | undefined>(undefined);
    readonly required = input<boolean | undefined>(undefined);
    readonly disabled = input<boolean | undefined>(undefined);
    readonly feature = input<'focusable' | 'fully-hidden'>('fully-hidden');

    readonly parsedValue = computed<{ name: string; value: any }[]>(() => {
        const value = this.value();
        const name = this.name();

        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
            return [{ name, value }];
        }

        if (Array.isArray(value)) {
            return value.flatMap((obj, index) => {
                if (typeof obj === 'object') {
                    return Object.entries(obj).map(([key, val]) => ({
                        name: `[${name}][${index}][${key}]`,
                        value: val
                    }));
                } else {
                    return { name: `[${name}][${index}]`, value: obj };
                }
            });
        }

        if (value !== null && typeof value === 'object') {
            return Object.entries(value).map(([key, val]) => ({
                name: `[${name}][${key}]`,
                value: val
            }));
        }

        return [];
    });

    ngOnInit() {
        const parsedValues = this.parsedValue();

        parsedValues.forEach((parsed) => {
            const inputElement = this.elementRef.nativeElement;
            inputElement.setAttribute('name', parsed.name);
            inputElement.setAttribute('value', parsed.value);
        });
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/visually-hidden/src/visually-hidden.directive.ts
```typescript
import { Directive, input, linkedSignal } from '@angular/core';

/**
 *
 * <span rdxVisuallyHidden [feature]="'fully-hidden'">
 *   <ng-content></ng-content>
 * </span>
 *
 * <button (click)="directiveInstance.feature.set('focusable')">Make Focusable</button>
 * <button (click)="directiveInstance.feature.set('fully-hidden')">Hide</button>
 */
@Directive({
    selector: '[rdxVisuallyHidden]',
    host: {
        '[attr.aria-hidden]': 'feature() === "focusable" ? "true" : undefined',
        '[hidden]': 'feature() === "fully-hidden" ? true : undefined',
        '[attr.tabindex]': 'feature() === "fully-hidden" ? "-1" : undefined',
        '[style.position]': '"absolute"',
        '[style.border]': '"0"',
        '[style.display]': 'feature() === "focusable" ? "inline-block" : "none"',
        '[style.width]': '"1px"',
        '[style.height]': '"1px"',
        '[style.padding]': '"0"',
        '[style.margin]': '"-1px"',
        '[style.overflow]': '"hidden"',
        '[style.clip]': '"rect(0, 0, 0, 0)"',
        '[style.clipPath]': '"inset(50%)"',
        '[style.white-space]': '"nowrap"',
        '[style.word-wrap]': '"normal"'
    }
})
export class RdxVisuallyHiddenDirective {
    readonly feature = input<'focusable' | 'fully-hidden'>('focusable');

    protected readonly featureEffect = linkedSignal({
        source: this.feature,
        computation: (feature: 'focusable' | 'fully-hidden') => feature
    });

    updateFeature(feature: 'focusable' | 'fully-hidden') {
        this.featureEffect.set(feature);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/README.md
```
# @radix-ng/primitives/menu

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/index.ts
```typescript
import { NgModule } from '@angular/core';
import { RdxMenuContentDirective } from './src/menu-content.directive';
import { RdxMenuDirective } from './src/menu-directive';
import { RdxMenuGroupDirective } from './src/menu-group.directive';
import { RdxMenuItemCheckboxDirective } from './src/menu-item-checkbox.directive';
import { RdxMenuItemIndicatorDirective } from './src/menu-item-indicator.directive';
import { RdxMenuItemRadioDirective } from './src/menu-item-radio.directive';
import { RdxMenuItemDirective } from './src/menu-item.directive';
import { RdxMenuLabelDirective } from './src/menu-label.directive';
import { RdxMenuRadioGroupDirective } from './src/menu-radio-group.directive';
import { RdxMenuSeparatorDirective } from './src/menu-separator.directive';
import { RdxMenuTriggerDirective } from './src/menu-trigger.directive';

export * from './src/menu-content.directive';
export * from './src/menu-directive';
export * from './src/menu-group.directive';
export * from './src/menu-item-checkbox.directive';
export * from './src/menu-item-indicator.directive';
export * from './src/menu-item-radio.directive';
export * from './src/menu-item.directive';
export * from './src/menu-label.directive';
export * from './src/menu-radio-group.directive';
export * from './src/menu-separator.directive';
export * from './src/menu-trigger.directive';

export type { RdxMenuAlign, RdxMenuSide } from './src/menu-trigger.directive';

const menuImports = [
    RdxMenuDirective,
    RdxMenuItemCheckboxDirective,
    RdxMenuItemRadioDirective,
    RdxMenuItemIndicatorDirective,
    RdxMenuTriggerDirective,
    RdxMenuGroupDirective,
    RdxMenuRadioGroupDirective,
    RdxMenuItemDirective,
    RdxMenuSeparatorDirective,
    RdxMenuContentDirective,
    RdxMenuLabelDirective
];

@NgModule({
    imports: [...menuImports],
    exports: [...menuImports]
})
export class RdxMenuModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/stories/menu.stories.ts
```typescript
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { Check, Dot, LucideAngularModule } from 'lucide-angular';
import { RdxMenuModule } from '../index';
import { MenuCheckboxItemsStory } from './components/menu-checkbox-items';
import { MenuRadioItemsStory } from './components/menu-radio-items';
import { MenuWithLabelsItemsStory } from './components/menu-with-labels-items';
import { MenuWithSubMenuStory } from './components/menu-with-sub-menu';

const html = String.raw;

export default {
    title: 'Utilities/Menu',
    decorators: [
        moduleMetadata({
            imports: [
                RdxMenuModule,
                LucideAngularModule,
                MenuRadioItemsStory,
                MenuCheckboxItemsStory,
                MenuWithLabelsItemsStory,
                MenuWithSubMenuStory,
                LucideAngularModule.pick({ Check, Dot })
            ]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div
                    class="radix-themes light light-theme radix-themes-default-fonts rt-Flex rt-r-ai-start rt-r-jc-center rt-r-position-relative"
                    data-accent-color="indigo"
                    data-radius="medium"
                    data-scaling="100%"
                >
                    ${story}

                    <style>
                        /* reset */
                        button {
                            all: unset;
                        }

                        .MenuRoot {
                            display: flex;
                            background-color: white;
                            padding: 3px;
                            border-radius: 6px;
                            box-shadow: 0 2px 10px var(--black-a7);
                        }

                        .MenuTrigger {
                            padding: 8px 12px;
                            outline: none;
                            user-select: none;
                            font-weight: 500;
                            line-height: 1;
                            border-radius: 4px;
                            color: var(--violet-11);
                            font-size: 13px;
                            display: flex;
                            align-items: center;
                            justify-content: space-between;
                            gap: 2px;
                        }

                        .MenuTrigger[data-highlighted],
                        .MenuTrigger[data-state='open'] {
                            background-color: var(--violet-4);
                        }

                        .MenuContent,
                        .MenuSubContent {
                            min-width: 220px;
                            background-color: white;
                            border-radius: 6px;
                            padding: 5px;
                            box-shadow:
                                0px 10px 38px -10px rgba(22, 23, 24, 0.35),
                                0px 10px 20px -15px rgba(22, 23, 24, 0.2);
                            animation-duration: 400ms;
                            animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
                            will-change: transform, opacity;
                        }

                        .MenuItem,
                        .MenuSubTrigger,
                        .MenuCheckboxItem,
                        .MenuRadioItem {
                            all: unset;
                            font-size: 13px;
                            line-height: 1;
                            color: var(--violet-11);
                            border-radius: 4px;
                            display: flex;
                            align-items: center;
                            height: 25px;
                            padding: 0 10px;
                            position: relative;
                            user-select: none;
                        }

                        .MenuItem.inset,
                        .MenuSubTrigger.inset,
                        .MenuCheckboxItem.inset,
                        .MenuRadioItem.inset {
                            padding-left: 20px;
                        }

                        .MenuItem[data-state='open'],
                        .MenuSubTrigger[data-state='open'] {
                            background-color: var(--violet-4);
                            color: var(--violet-11);
                        }

                        .MenuItem[data-highlighted],
                        .MenuSubTrigger[data-highlighted],
                        .MenuCheckboxItem[data-highlighted],
                        .MenuRadioItem[data-highlighted] {
                            background-image: linear-gradient(135deg, var(--violet-9) 0%, var(--violet-10) 100%);
                            color: var(--violet-1);
                        }

                        .MenuItem[data-disabled],
                        .MenuSubTrigger[data-disabled],
                        .MenuCheckboxItem[data-disabled],
                        .MenuRadioItem[data-disabled] {
                            color: var(--mauve-8);
                            pointer-events: none;
                        }

                        .MenuItemIndicator {
                            position: absolute;
                            left: 0;
                            width: 20px;
                            display: inline-flex;
                            align-items: center;
                            justify-content: center;
                        }

                        .MenuSeparator {
                            height: 1px;
                            background-color: var(--violet-6);
                            margin: 5px;
                        }

                        [data-highlighted] > .RightSlot {
                            color: white;
                        }

                        [data-disabled] > .RightSlot {
                            color: var(--mauve-8);
                        }
                    </style>
                </div>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: html`
            <div class="MenuRoot" RdxMenuRoot>
                <div class="MenuTrigger" RdxMenuItem RdxMenuTrigger [menuTriggerFor]="file">File</div>
            </div>

            <ng-template #file>
                <div class="MenuContent" RdxMenuContent>
                    <div class="MenuItem" RdxMenuItem>Undo</div>
                    <div class="MenuItem" RdxMenuItem>Redo</div>
                    <div class="MenuSeparator" RdxMenuSeparator></div>
                    <div class="MenuItem" RdxMenuItem>Cut</div>
                    <div class="MenuItem" RdxMenuItem>Copy</div>
                    <div class="MenuItem" RdxMenuItem>Paste</div>
                </div>
            </ng-template>
        `
    })
};

export const ItemDisabled: Story = {
    render: () => ({
        template: html`
            <div class="MenuRoot" RdxMenuRoot>
                <div class="MenuTrigger" RdxMenuItem RdxMenuTrigger [menuTriggerFor]="file">File</div>
            </div>

            <ng-template #file>
                <div class="MenuContent" RdxMenuContent>
                    <div class="MenuItem" RdxMenuItem disabled>Undo</div>
                    <div class="MenuItem" RdxMenuItem>Redo</div>
                    <div class="MenuSeparator" RdxMenuSeparator></div>
                    <div class="MenuItem" RdxMenuItem>Cut</div>
                    <div class="MenuItem" RdxMenuItem disabled>Copy</div>
                    <div class="MenuItem" RdxMenuItem>Paste</div>
                </div>
            </ng-template>
        `
    })
};

export const RadioItem: Story = {
    render: () => ({
        template: html`
            <menu-radio-items-story />
        `
    })
};

export const CheckboxItem: Story = {
    render: () => ({
        template: html`
            <menu-checkbox-items-story />
        `
    })
};

export const WithLabels: Story = {
    render: () => ({
        template: html`
            <menu-with-labels-items-story />
        `
    })
};

export const WithSubMenu: Story = {
    render: () => ({
        template: html`
            <menu-with-sub-menu-story />
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/stories/components/menu-checkbox-items.ts
```typescript
import { ChangeDetectionStrategy, Component, signal } from '@angular/core';
import { RdxMenuModule } from '@radix-ng/primitives/menu';
import { LucideAngularModule, X } from 'lucide-angular';

@Component({
    selector: 'menu-checkbox-items-story',
    imports: [RdxMenuModule, LucideAngularModule],
    styleUrl: 'styles.css',
    changeDetection: ChangeDetectionStrategy.OnPush,
    template: `
        <div class="MenuRoot" RdxMenuRoot>
            <div
                class="MenuTrigger"
                [menuTriggerFor]="menuGroup"
                align="start"
                sideOffset="5"
                alignOffset="-3"
                RdxMenuItem
                RdxMenuTrigger
            >
                File
            </div>
        </div>

        <ng-template #menuGroup>
            <div class="MenuContent" RdxMenuContent>
                <div
                    class="MenuCheckboxItem inset"
                    [checked]="checkedState()"
                    (menuItemTriggered)="handleSelectAll()"
                    RdxMenuItemCheckbox
                >
                    Select All
                    <lucide-icon class="MenuItemIndicator" [img]="X" RdxMenuItemIndicator size="16" strokeWidth="2" />
                </div>

                <div class="MenuSeparator" RdxMenuSeparator></div>
                @for (item of options(); track $index) {
                    <div
                        class="MenuCheckboxItem inset"
                        [checked]="selectedItems.includes(item)"
                        (menuItemTriggered)="handleSelection(item)"
                        RdxMenuItemCheckbox
                    >
                        {{ item }}
                        <lucide-icon
                            class="MenuItemIndicator"
                            [img]="X"
                            RdxMenuItemIndicator
                            size="16"
                            strokeWidth="2"
                        />
                    </div>
                }
            </div>
        </ng-template>
    `
})
export class MenuCheckboxItemsStory {
    options = signal<string[]>(['Crows', 'Ravens', 'Magpies', 'Jackdaws']);

    selectedItems = this.options();

    handleSelection(option: string) {
        if (this.selectedItems.includes(option)) {
            this.selectedItems = this.selectedItems.filter((el) => el !== option);
        } else {
            this.selectedItems = this.selectedItems.concat(option);
        }
    }

    handleSelectAll() {
        if (this.selectedItems.length === this.options().length) this.selectedItems = [];
        else this.selectedItems = this.options();
    }

    checkedState() {
        return this.selectedItems.length === this.options().length
            ? true
            : this.selectedItems.length > 0
              ? 'indeterminate'
              : false;
    }

    protected readonly X = X;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/stories/components/menu-radio-items.ts
```typescript
import { ChangeDetectionStrategy, Component, signal } from '@angular/core';
import { RdxMenuModule } from '@radix-ng/primitives/menu';
import { Dot, LucideAngularModule } from 'lucide-angular';

@Component({
    selector: 'menu-radio-items-story',
    imports: [RdxMenuModule, LucideAngularModule],
    styleUrl: 'styles.css',
    changeDetection: ChangeDetectionStrategy.OnPush,
    template: `
        <div class="MenuRoot" RdxMenuRoot>
            <div
                class="MenuTrigger"
                [menuTriggerFor]="menuGroup"
                side="bottom"
                align="start"
                sideOffset="5"
                alignOffset="-3"
                RdxMenuItem
                RdxMenuTrigger
            >
                File
            </div>
        </div>

        <ng-template #menuGroup>
            <div class="MenuContent" RdxMenuContent>
                <div class="MenuItem inset" RdxMenuItem>Minimize window</div>
                <div class="MenuItem inset" RdxMenuItem>Zoom</div>
                <div class="MenuItem inset" RdxMenuItem>Smaller</div>

                <div class="MenuSeparator" RdxMenuSeparator></div>
                <div RdxMenuRadioGroup>
                    @for (item of items(); track $index) {
                        <div
                            class="MenuRadioItem inset"
                            [checked]="item === selectedItem"
                            (menuItemTriggered)="selectedItem = item"
                            RdxMenuItemRadio
                        >
                            {{ item }}
                            <lucide-icon
                                class="MenuItemIndicator"
                                [img]="Dot"
                                RdxMenuItemIndicator
                                size="16"
                                strokeWidth="5"
                            />
                        </div>
                    }
                </div>
            </div>
        </ng-template>
    `
})
export class MenuRadioItemsStory {
    readonly items = signal(['README.md', 'index.js', 'page.css']);

    selectedItem: string | undefined;

    protected readonly Dot = Dot;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/stories/components/menu-with-labels-items.ts
```typescript
import { ChangeDetectionStrategy, Component } from '@angular/core';
import { RdxMenuModule } from '@radix-ng/primitives/menu';

@Component({
    selector: 'menu-with-labels-items-story',
    imports: [
        RdxMenuModule
    ],
    styleUrl: 'styles.css',
    changeDetection: ChangeDetectionStrategy.OnPush,
    template: `
        <div class="MenuRoot" RdxMenuRoot>
            <div
                class="MenuTrigger"
                [menuTriggerFor]="menuGroup"
                align="center"
                sideOffset="8"
                RdxMenuItem
                RdxMenuTrigger
            >
                File
            </div>
        </div>

        <ng-template #menuGroup>
            <div class="MenuContent" RdxMenuContent>
                <div RdxMenuGroup>
                    @for (foodGroup of foodGroups; track $index) {
                        <div class="MenuLabel" RdxMenuLabel>{{ foodGroup.label }}</div>

                        @for (food of foodGroup.foods; track $index) {
                            <div class="MenuItem" (onSelect)="handleSelect(food.value)" RdxMenuItem>
                                {{ food.label }}
                            </div>
                        }
                        @if ($index < foodGroups.length - 1) {
                            <div class="MenuSeparator" RdxMenuSeparator></div>
                        }
                    }
                </div>
            </div>
        </ng-template>
    `
})
export class MenuWithLabelsItemsStory {
    handleSelect(food: string) {
        console.log(food);
    }

    readonly foodGroups: Array<{
        label?: string;
        foods: Array<{ value: string; label: string; disabled?: boolean }>;
    }> = [
        {
            label: 'Fruits',
            foods: [
                { value: 'apple', label: 'Apple' },
                { value: 'banana', label: 'Banana' },
                { value: 'blueberry', label: 'Blueberry' },
                { value: 'grapes', label: 'Grapes' },
                { value: 'pineapple', label: 'Pineapple' }
            ]
        },
        {
            label: 'Vegetables',
            foods: [
                { value: 'aubergine', label: 'Aubergine' },
                { value: 'broccoli', label: 'Broccoli' },
                { value: 'carrot', label: 'Carrot', disabled: true },
                { value: 'courgette', label: 'Courgette' },
                { value: 'leek', label: 'Leek' }
            ]
        },
        {
            label: 'Meat',
            foods: [
                { value: 'beef', label: 'Beef' },
                { value: 'beef-with-sauce', label: 'Beef with sauce' },
                { value: 'chicken', label: 'Chicken' },
                { value: 'lamb', label: 'Lamb' },
                { value: 'pork', label: 'Pork' }
            ]
        },
        {
            foods: [
                { value: 'candies', label: 'Candies' },
                { value: 'chocolates', label: 'Chocolates' }
            ]
        }
    ];
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/stories/components/menu-with-sub-menu.ts
```typescript
import { ChangeDetectionStrategy, Component } from '@angular/core';
import { RdxPositionAlign, RdxPositionSide } from '@radix-ng/primitives/core';
import { RdxMenuModule } from '@radix-ng/primitives/menu';
import { ArrowRight, LucideAngularModule } from 'lucide-angular';

@Component({
    selector: 'menu-with-sub-menu-story',
    imports: [RdxMenuModule, LucideAngularModule],
    styleUrl: 'styles.css',
    changeDetection: ChangeDetectionStrategy.OnPush,
    template: `
        <div class="MenuRoot" RdxMenuRoot>
            <div
                class="MenuTrigger"
                [menuTriggerFor]="menuGroup"
                align="start"
                sideOffset="5"
                alignOffset="-3"
                RdxMenuItem
                RdxMenuTrigger
            >
                File
            </div>
        </div>

        <ng-template #menuGroup>
            <div class="MenuContent" RdxMenuContent>
                <div class="MenuItem " RdxMenuItem>Undo</div>
                <div class="MenuItem " RdxMenuItem>Redo</div>
                <div class="MenuSeparator" RdxMenuSeparator></div>

                <div
                    class="MenuItem"
                    [menuTriggerFor]="subMenu"
                    align="start"
                    sideOffset="-20"
                    alignOffset="210"
                    RdxMenuItem
                    RdxMenuTrigger
                >
                    Find
                    <div class="RightSlot"><lucide-angular [img]="ArrowRight" size="16" strokeWidth="2" /></div>
                </div>

                <div class="MenuSeparator" RdxMenuSeparator></div>

                <div class="MenuItem " RdxMenuItem>Cut</div>
                <div class="MenuItem " RdxMenuItem>Copy</div>
                <div class="MenuItem " RdxMenuItem>Paste</div>
            </div>
        </ng-template>

        <ng-template #subMenu>
            <div class="MenuSubContent" RdxMenuContent>
                <div class="MenuItem" RdxMenuItem>Undo</div>
                <div class="MenuItem" RdxMenuItem>Redo</div>
                <div class="MenuSeparator" RdxMenuSeparator></div>
                <div class="MenuItem" RdxMenuItem>Cut</div>
                <div class="MenuItem" RdxMenuItem>Copy</div>
                <div class="MenuItem" RdxMenuItem>Paste</div>
            </div>
        </ng-template>
    `
})
export class MenuWithSubMenuStory {
    protected readonly ArrowRight = ArrowRight;
    protected readonly RdxPositionAlign = RdxPositionAlign;
    protected readonly RdxPositionSide = RdxPositionSide;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/stories/components/styles.css
```css
/* reset */
:host {
    button {
        all: unset;
    }
}

.MenuRoot {
    display: flex;
    background-color: white;
    padding: 3px;
    border-radius: 6px;
    box-shadow: 0 2px 10px var(--black-a7);
}

.MenuTrigger {
    padding: 8px 12px;
    outline: none;
    user-select: none;
    font-weight: 500;
    line-height: 1;
    border-radius: 4px;
    color: var(--violet-11);
    font-size: 13px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 2px;
}

.MenuTrigger[data-highlighted],
.MenuTrigger[data-state='open'] {
    background-color: var(--violet-4);
}

.MenuContent,
.MenuSubContent {
    min-width: 220px;
    background-color: white;
    border-radius: 6px;
    padding: 5px;
    box-shadow:
        0px 10px 38px -10px rgba(22, 23, 24, 0.35),
        0px 10px 20px -15px rgba(22, 23, 24, 0.2);
    animation-duration: 400ms;
    animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
    will-change: transform, opacity;
}

.MenuItem,
.MenuSubTrigger,
.MenuCheckboxItem,
.MenuRadioItem {
    all: unset;
    font-size: 13px;
    line-height: 1;
    color: var(--violet-11);
    border-radius: 4px;
    display: flex;
    align-items: center;
    height: 25px;
    padding: 0 10px;
    position: relative;
    user-select: none;
}

.MenuItem.inset,
.MenuSubTrigger.inset,
.MenuCheckboxItem.inset,
.MenuRadioItem.inset {
    padding-left: 20px;
}

.MenuItem[data-state='open'],
.MenuSubTrigger[data-state='open'] {
    background-color: var(--violet-4);
    color: var(--violet-11);
}

.MenuItem[data-highlighted],
.MenuSubTrigger[data-highlighted],
.MenuCheckboxItem[data-highlighted],
.MenuRadioItem[data-highlighted] {
    background-image: linear-gradient(135deg, var(--violet-9) 0%, var(--violet-10) 100%);
    color: var(--violet-1);
}

.MenuItem[data-disabled],
.MenuSubTrigger[data-disabled],
.MenuCheckboxItem[data-disabled],
.MenuRadioItem[data-disabled] {
    color: var(--mauve-8);
    pointer-events: none;
}

.MenuItemIndicator {
    position: absolute;
    left: 0;
    width: 20px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

.MenuSeparator {
    height: 1px;
    background-color: var(--violet-6);
    margin: 5px;
}

.MenuLabel {
    padding-left: 5px;
    font-size: 12px;
    line-height: 25px;
    color: var(--mauve-11);
}

.RightSlot {
    margin-left: auto;
    padding-left: 20px;
    color: var(--mauve-9);
}

[data-highlighted] > .RightSlot {
    color: white;
}

[data-disabled] > .RightSlot {
    color: var(--mauve-8);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/src/menu-content.directive.ts
```typescript
import { CdkMenu } from '@angular/cdk/menu';
import { Directive } from '@angular/core';

@Directive({
    selector: '[RdxMenuContent]',
    hostDirectives: [CdkMenu],
    host: {
        role: 'menu',
        '[attr.aria-orientation]': '"vertical"'
    }
})
export class RdxMenuContentDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/src/menu-directive.ts
```typescript
import { CdkMenu } from '@angular/cdk/menu';
import { Directive } from '@angular/core';

@Directive({
    selector: '[RdxMenuRoot],[RdxMenuSub]',
    hostDirectives: [CdkMenu]
})
export class RdxMenuDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/src/menu-group.directive.ts
```typescript
import { CdkMenuGroup } from '@angular/cdk/menu';
import { Directive } from '@angular/core';

@Directive({
    selector: '[RdxMenuGroup]',
    hostDirectives: [CdkMenuGroup],
    host: {
        role: 'group'
    }
})
export class RdxMenuGroupDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/src/menu-item-checkbox.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { CdkMenuItemCheckbox } from '@angular/cdk/menu';
import { booleanAttribute, computed, Directive, effect, inject, input, signal } from '@angular/core';
import { outputFromObservable } from '@angular/core/rxjs-interop';
import { getCheckedState, isIndeterminate } from './utils';

@Directive({
    selector: '[RdxMenuItemCheckbox]',
    hostDirectives: [
        {
            directive: CdkMenuItemCheckbox,
            outputs: ['cdkMenuItemTriggered: menuItemTriggered']
        }
    ],
    host: {
        role: 'menuitemcheckbox',
        '[attr.aria-checked]': 'isIndeterminate(checked()) ? "mixed" : checked()',
        '[attr.data-state]': 'getCheckedState(checked())',
        '[attr.data-highlighted]': "highlightedState() ? '' : undefined",

        '(focus)': 'onFocus()',
        '(blur)': 'onBlur()',
        '(pointermove)': 'onPointerMove($event)'
    }
})
export class RdxMenuItemCheckboxDirective {
    private readonly cdkMenuItemCheckbox = inject(CdkMenuItemCheckbox, { host: true });

    readonly disabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    readonly checked = input<boolean | 'indeterminate'>(false);

    readonly onCheckedChange = outputFromObservable(this.cdkMenuItemCheckbox.triggered);

    protected readonly disabledState = computed(() => this.disabled);

    protected readonly highlightedState = computed(() => this.isFocused());

    private readonly isFocused = signal(false);

    constructor() {
        effect(() => {
            if (isIndeterminate(this.checked())) {
                this.cdkMenuItemCheckbox.checked = true;
            } else {
                this.cdkMenuItemCheckbox.checked = !this.checked();
            }

            this.cdkMenuItemCheckbox.disabled = this.disabled();
        });
    }

    onFocus(): void {
        if (!this.disabled()) {
            this.isFocused.set(true);
        }
    }

    onBlur(): void {
        this.isFocused.set(false);
    }

    onPointerMove(event: PointerEvent) {
        if (event.defaultPrevented) return;

        if (!(event.pointerType === 'mouse')) return;

        if (!this.disabled()) {
            const item = event.currentTarget;
            (item as HTMLElement)?.focus({ preventScroll: true });
        }
    }

    protected readonly isIndeterminate = isIndeterminate;
    protected readonly getCheckedState = getCheckedState;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/src/menu-item-indicator.directive.ts
```typescript
import { Directive, inject } from '@angular/core';
import { RdxMenuItemCheckboxDirective } from './menu-item-checkbox.directive';
import { RdxMenuItemRadioDirective } from './menu-item-radio.directive';
import { getCheckedState, isIndeterminate } from './utils';

@Directive({
    selector: '[RdxMenuItemIndicator]',
    host: {
        '[attr.data-state]': 'getCheckedState(isChecked)',

        '[style.display]': 'isChecked ? "" : "none"'
    }
})
export class RdxMenuItemIndicatorDirective {
    private readonly menuItemRadio = inject(RdxMenuItemRadioDirective, { host: true, optional: true });

    private readonly menuCheckboxItem = inject(RdxMenuItemCheckboxDirective, { host: true, optional: true });

    get isChecked(): boolean {
        if (this.menuItemRadio) {
            return this.menuItemRadio.checked();
        }
        if (this.menuCheckboxItem) {
            return isIndeterminate(this.menuCheckboxItem.checked()) || this.menuCheckboxItem.checked() === true;
        }
        return false;
    }

    protected readonly getCheckedState = getCheckedState;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/src/menu-item-radio.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { CdkMenuItemRadio } from '@angular/cdk/menu';
import { booleanAttribute, computed, Directive, effect, inject, input, signal } from '@angular/core';
import { outputFromObservable } from '@angular/core/rxjs-interop';
import { getCheckedState } from './utils';

@Directive({
    selector: '[RdxMenuItemRadio]',
    hostDirectives: [
        {
            directive: CdkMenuItemRadio,
            outputs: ['cdkMenuItemTriggered: menuItemTriggered']
        }
    ],
    host: {
        role: 'menuitemradio',
        '[attr.aria-checked]': 'checked()',
        '[attr.data-state]': 'getCheckedState(checked())',
        '[attr.data-highlighted]': "highlightedState() ? '' : undefined",

        '(focus)': 'onFocus()',
        '(blur)': 'onBlur()',
        '(pointermove)': 'onPointerMove($event)'
    }
})
export class RdxMenuItemRadioDirective {
    private readonly cdkMenuItemRadio = inject(CdkMenuItemRadio, { host: true });

    readonly disabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    readonly checked = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    readonly onValueChange = outputFromObservable(this.cdkMenuItemRadio.triggered);

    protected readonly disabledState = computed(() => this.disabled());

    protected readonly highlightedState = computed(() => this.isFocused());

    private readonly isFocused = signal(false);

    constructor() {
        effect(() => {
            this.cdkMenuItemRadio.checked = this.checked();
            this.cdkMenuItemRadio.disabled = this.disabled();
        });
    }

    onFocus(): void {
        if (!this.disabled()) {
            this.isFocused.set(true);
        }
    }

    onBlur(): void {
        this.isFocused.set(false);
    }

    onPointerMove(event: PointerEvent) {
        if (event.defaultPrevented) return;

        if (!(event.pointerType === 'mouse')) return;

        if (!this.disabled()) {
            const item = event.currentTarget;
            (item as HTMLElement)?.focus({ preventScroll: true });
        }
    }

    protected readonly getCheckedState = getCheckedState;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/src/menu-item.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { CdkMenuItem } from '@angular/cdk/menu';
import { booleanAttribute, computed, Directive, effect, inject, input, signal } from '@angular/core';
import { outputFromObservable } from '@angular/core/rxjs-interop';

@Directive({
    selector: '[RdxMenuItem]',
    hostDirectives: [
        {
            directive: CdkMenuItem,
            outputs: ['cdkMenuItemTriggered: menuItemTriggered']
        }
    ],
    host: {
        role: 'menuitem',
        tabindex: '-1',
        '[attr.data-orientation]': "'horizontal'",
        '[attr.data-state]': 'isOpenState()',
        '[attr.aria-disabled]': "disabledState() ? '' : undefined",
        '[attr.data-disabled]': "disabledState() ? '' : undefined",
        '[attr.data-highlighted]': "highlightedState() ? '' : undefined",

        '(focus)': 'onFocus()',
        '(blur)': 'onBlur()',
        '(pointermove)': 'onPointerMove($event)'
    }
})
export class RdxMenuItemDirective {
    private readonly cdkMenuItem = inject(CdkMenuItem, { host: true });

    readonly disabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    readonly onSelect = outputFromObservable(this.cdkMenuItem.triggered);

    private readonly isFocused = signal(false);

    protected readonly disabledState = computed(() => this.disabled());

    protected readonly isOpenState = signal(false);

    protected readonly highlightedState = computed(() => this.isFocused());

    constructor() {
        effect(() => {
            this.cdkMenuItem.disabled = this.disabled();
            this.isOpenState.set(this.cdkMenuItem.isMenuOpen());
        });
    }

    onFocus(): void {
        if (!this.disabled()) {
            this.isFocused.set(true);
        }
    }

    onBlur(): void {
        this.isFocused.set(false);
    }

    onPointerMove(event: PointerEvent) {
        if (event.defaultPrevented) return;

        if (!(event.pointerType === 'mouse')) return;

        if (!this.disabled()) {
            const item = event.currentTarget;
            (item as HTMLElement)?.focus({ preventScroll: true });
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/src/menu-label.directive.ts
```typescript
import { Directive } from '@angular/core';

@Directive({
    selector: '[RdxMenuLabel]'
})
export class RdxMenuLabelDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/src/menu-radio-group.directive.ts
```typescript
import { CdkMenuGroup } from '@angular/cdk/menu';
import { Directive } from '@angular/core';

@Directive({
    selector: '[RdxMenuRadioGroup]',
    hostDirectives: [CdkMenuGroup]
})
export class RdxMenuRadioGroupDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/src/menu-separator.directive.ts
```typescript
import { Directive } from '@angular/core';

@Directive({
    selector: '[RdxMenuSeparator]',
    host: {
        role: 'separator',
        '[attr.aria-orientation]': "'horizontal'"
    }
})
export class RdxMenuSeparatorDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/src/menu-trigger.directive.ts
```typescript
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import { CdkMenuTrigger } from '@angular/cdk/menu';
import {
    booleanAttribute,
    computed,
    Directive,
    effect,
    inject,
    input,
    numberAttribute,
    SimpleChange,
    untracked
} from '@angular/core';

export type RdxMenuAlign = 'start' | 'center' | 'end';
export type RdxMenuSide = 'top' | 'right' | 'bottom' | 'left';

@Directive({
    selector: '[RdxMenuTrigger]',
    hostDirectives: [
        {
            directive: CdkMenuTrigger,
            inputs: ['cdkMenuTriggerFor: menuTriggerFor', 'cdkMenuPosition: menuPosition']
        }
    ],
    host: {
        role: 'menuitem',
        '[attr.aria-haspopup]': "'menu'",
        '[attr.aria-expanded]': 'cdkTrigger.isOpen()',
        '[attr.data-state]': "cdkTrigger.isOpen() ? 'open': 'closed'",
        '[attr.data-disabled]': "disabled() ? '' : undefined",

        '(pointerdown)': 'onPointerDown($event)'
    }
})
export class RdxMenuTriggerDirective {
    protected readonly cdkTrigger = inject(CdkMenuTrigger, { host: true });

    readonly menuTriggerFor = input.required();

    /**
     * @description The preferred side of the trigger to render against when open. Will be reversed when collisions occur and avoidCollisions is enabled.
     */
    readonly side = input<RdxMenuSide>();

    readonly align = input<RdxMenuAlign>();

    /**
     * @description The distance in pixels from the trigger.
     */
    readonly sideOffset = input<number, NumberInput>(NaN, {
        transform: numberAttribute
    });

    /**
     * @description An offset in pixels from the "start" or "end" alignment options.
     */
    readonly alignOffset = input<number, NumberInput>(NaN, {
        transform: numberAttribute
    });

    readonly disabled = input<boolean, BooleanInput>(false, {
        transform: booleanAttribute
    });

    private enablePositions = false;

    // TODO
    private readonly positions = computed(() => this.computePositions());

    private computePositions() {
        if (this.align() || this.sideOffset() || this.alignOffset() || this.side()) {
            this.enablePositions = true;
        }

        const side = this.side() || 'bottom';
        const align = this.align() || 'center';
        const sideOffset = this.sideOffset() || 0;
        const alignOffset = this.alignOffset() || 0;

        let originX: 'start' | 'center' | 'end' = 'center';
        let originY: 'top' | 'center' | 'bottom' = 'center';
        let overlayX: 'start' | 'center' | 'end' = 'center';
        let overlayY: 'top' | 'center' | 'bottom' = 'center';
        let offsetX = 0;
        let offsetY = 0;

        switch (side) {
            case 'top':
                originY = 'top';
                overlayY = 'bottom';
                offsetY = -sideOffset;
                break;
            case 'bottom':
                originY = 'bottom';
                overlayY = 'top';
                offsetY = sideOffset;
                break;
            case 'left':
                originX = 'start';
                overlayX = 'end';
                offsetX = -sideOffset;
                break;
            case 'right':
                originX = 'end';
                overlayX = 'start';
                offsetX = sideOffset;
                break;
        }

        switch (align) {
            case 'start':
                if (side === 'top' || side === 'bottom') {
                    originX = 'start';
                    overlayX = 'start';
                    offsetX = alignOffset;
                } else {
                    originY = 'top';
                    overlayY = 'top';
                    offsetY = alignOffset;
                }
                break;
            case 'end':
                if (side === 'top' || side === 'bottom') {
                    originX = 'end';
                    overlayX = 'end';
                    offsetX = -alignOffset;
                } else {
                    originY = 'bottom';
                    overlayY = 'bottom';
                    offsetY = -alignOffset;
                }
                break;
            case 'center':
            default:
                if (side === 'top' || side === 'bottom') {
                    originX = 'center';
                    overlayX = 'center';
                } else {
                    originY = 'center';
                    overlayY = 'center';
                }
                break;
        }

        return {
            originX,
            originY,
            overlayX,
            overlayY,
            offsetX,
            offsetY
        };
    }

    constructor() {
        this.onMenuPositionEffect();
    }

    /** @ignore */
    onPointerDown($event: MouseEvent) {
        // only call handler if it's the left button (mousedown gets triggered by all mouse buttons)
        // but not when the control key is pressed (avoiding MacOS right click)
        if (!this.disabled() && $event.button === 0 && !$event.ctrlKey) {
            /* empty */
            if (!this.cdkTrigger.isOpen()) {
                // prevent trigger focusing when opening
                // this allows the content to be given focus without competition
                $event.preventDefault();
            }
        }
    }

    private onMenuPositionEffect() {
        effect(() => {
            const positions = this.positions();

            untracked(() => {
                if (this.enablePositions) {
                    this.setMenuPositions([positions]);
                }
            });
        });
    }

    private setMenuPositions(positions: CdkMenuTrigger['menuPosition']) {
        const prevMenuPosition = this.cdkTrigger.menuPosition;
        this.cdkTrigger.menuPosition = positions;
        this.fireNgOnChanges('menuPosition', this.cdkTrigger.menuPosition, prevMenuPosition);
    }

    private fireNgOnChanges<K extends keyof CdkMenuTrigger, V extends CdkMenuTrigger[K]>(
        input: K,
        currentValue: V,
        previousValue: V,
        firstChange = false
    ) {
        this.cdkTrigger.ngOnChanges({
            [input]: new SimpleChange(previousValue, currentValue, firstChange)
        });
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/menu/src/utils.ts
```typescript
export type CheckedState = boolean | 'indeterminate';

export function isIndeterminate(checked?: CheckedState): checked is 'indeterminate' {
    return checked === 'indeterminate';
}

export function getCheckedState(checked: CheckedState) {
    return isIndeterminate(checked) ? 'indeterminate' : checked ? 'checked' : 'unchecked';
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/avatar/README.md
```
# @radix-ng/primitives/avatar

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/avatar/index.ts
```typescript
import { NgModule } from '@angular/core';
import { RdxAvatarFallbackDirective } from './src/avatar-fallback.directive';
import { RdxAvatarImageDirective } from './src/avatar-image.directive';
import { RdxAvatarRootDirective } from './src/avatar-root.directive';

export * from './src/avatar-fallback.directive';
export * from './src/avatar-image.directive';
export * from './src/avatar-root.directive';
export type { RdxImageLoadingStatus } from './src/avatar-root.directive';
export * from './src/avatar.config';

const _imports = [
    RdxAvatarRootDirective,
    RdxAvatarFallbackDirective,
    RdxAvatarImageDirective
];

@NgModule({
    imports: [..._imports],
    exports: [..._imports]
})
export class RdxCheckboxModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/avatar/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/avatar/stories/avatar.docs.mdx
````
import { Canvas, Meta } from '@storybook/blocks';
import * as AvatarDirectiveStories from './avatar.stories';

<Meta title="Primitives/Avatar" />

# Avatar

#### An image element with a fallback for representing the user.

<Canvas sourceState="hidden" of={AvatarDirectiveStories.Default} />

## Features

- âœ… Automatic and manual control over when the image renders.
- âœ… Fallback part accepts any children.
- âœ… Optionally delayMs fallback rendering to avoid content flashing.

## Global Configuration

You can configure the default options for all avatars in your application by using the `provideRdxAvatarConfig` function in a providers array.

```ts
import { provideRdxAvatarConfig } from '@radix-ng/primitives/avatar';

bootstrapApplication(AppComponent, {
  providers: [provideRdxAvatarConfig({ delayMs: 1000 })]
});
```

## Anatomy

```html
<span rdxAvatarRoot>
  <img rdxAvatarImage src="..." alt="..." />
  <span rdxAvatarFallback>Angular</span>
</span>
```

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/avatar/stories/avatar.stories.ts
```typescript
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { RdxAvatarFallbackDirective } from '../src/avatar-fallback.directive';
import { RdxAvatarImageDirective } from '../src/avatar-image.directive';
import { RdxAvatarRootDirective } from '../src/avatar-root.directive';

const html = String.raw;

export default {
    title: 'Primitives/Avatar',
    decorators: [
        moduleMetadata({
            imports: [RdxAvatarRootDirective, RdxAvatarImageDirective, RdxAvatarFallbackDirective]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div
                    class="radix-themes light light-theme radix-themes-default-fonts"
                    data-accent-color="indigo"
                    data-radius="medium"
                    data-scaling="100%"
                >
                    ${story}

                    <style>
                        .AvatarRoot {
                            display: inline-flex;
                            align-items: center;
                            justify-content: center;
                            vertical-align: middle;
                            overflow: hidden;
                            user-select: none;
                            width: 45px;
                            height: 45px;
                            border-radius: 100%;
                            background-color: var(--black-a3);
                        }

                        .AvatarImage {
                            width: 100%;
                            height: 100%;
                            object-fit: cover;
                            border-radius: inherit;
                        }

                        .AvatarFallback {
                            width: 100%;
                            height: 100%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            background-color: white;
                            color: var(--violet-11);
                            font-size: 15px;
                            line-height: 1;
                            font-weight: 500;
                        }
                    </style>
                </div>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: html`
            <div style=" display: flex; gap: 20px">
                <span class="AvatarRoot" rdxAvatarRoot>
                    <img
                        class="AvatarImage"
                        rdxAvatarImage
                        src="https://images.unsplash.com/photo-1492633423870-43d1cd2775eb?&w=128&h=128&dpr=2&q=80"
                        alt="Colm Tuite"
                    />
                    <span class="AvatarFallback" rdxAvatarFallback [delayMs]="600">CT</span>
                </span>

                <span class="AvatarRoot" rdxAvatarRoot>
                    <img
                        class="AvatarImage"
                        rdxAvatarImage
                        src="https://images.unsplash.com/photo-1511485977113-f34c92461ad9?ixlib=rb-1.2.1&w=128&h=128&dpr=2&q=80"
                        alt="Pedro Duarte"
                    />
                    <span class="AvatarFallback" rdxAvatarFallback [delayMs]="600">JD</span>
                </span>

                <span class="AvatarRoot" rdxAvatarRoot>
                    <span class="AvatarFallback" rdxAvatarFallback>PD</span>
                </span>

                <span class="AvatarRoot" rdxAvatarRoot>
                    <img class="AvatarImage" rdxAvatarImage src="" alt="Pedro Duarte" />
                    <span class="AvatarFallback" rdxAvatarFallback>PD</span>
                </span>
            </div>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/avatar/__tests__/avatar-fallback.directive.spec.ts
```typescript
import { Component, PLATFORM_ID } from '@angular/core';
import { ComponentFixture, TestBed, fakeAsync, tick } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { RdxAvatarFallbackDirective } from '../src/avatar-fallback.directive';
import { RdxAvatarRootDirective } from '../src/avatar-root.directive';

@Component({
    selector: 'rdx-mock-component',
    standalone: true,
    imports: [RdxAvatarFallbackDirective, RdxAvatarRootDirective],
    template: `
        <span rdxAvatarRoot>
            <span [delayMs]="delay" rdxAvatarFallback>fallback</span>
            <span rdxAvatarFallback>fallback2</span>
        </span>
    `
})
class RdxMockComponent {
    delay = 1000;
}

describe('RdxAvatarFallbackDirective', () => {
    let component: RdxMockComponent;
    let fixture: ComponentFixture<RdxMockComponent>;

    beforeEach(() => {
        fixture = TestBed.overrideProvider(PLATFORM_ID, { useValue: 'browser' }).createComponent(RdxMockComponent);
        component = fixture.componentInstance;
    });

    it('should compile', () => {
        expect(component).toBeTruthy();
    });

    it('should hide fallback initially', () => {
        fixture.detectChanges();
        const fallbackElement = fixture.debugElement.query(By.css('span[rdxAvatarFallback]'));
        expect(fallbackElement.nativeElement.style.display).toBe('none');
    });

    it('should show fallback after delay', fakeAsync(() => {
        fixture.detectChanges();

        tick(1000);
        fixture.detectChanges();

        const fallbackElement = fixture.debugElement.query(By.css('span[rdxAvatarFallback]'));
        expect(fallbackElement.nativeElement.style.display).not.toBe('none');
    }));
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/avatar/__tests__/avatar-image.directive.spec.ts
```typescript
import { Component } from '@angular/core';
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { RdxAvatarFallbackDirective } from '../src/avatar-fallback.directive';
import { RdxAvatarImageDirective } from '../src/avatar-image.directive';
import { RdxAvatarRootDirective } from '../src/avatar-root.directive';

@Component({
    selector: 'rdx-mock-component',
    standalone: true,
    imports: [RdxAvatarImageDirective, RdxAvatarRootDirective, RdxAvatarFallbackDirective],
    template: `
        <span rdxAvatarRoot>
            <img
                rdxAvatarImage
                alt="Angular Logo"
                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNTAgMjUwIj4KICAgIDxwYXRoIGZpbGw9IiNERDAwMzEiIGQ9Ik0xMjUgMzBMMzEuOSA2My4ybDE0LjIgMTIzLjFMMTI1IDIzMGw3OC45LTQzLjcgMTQuMi0xMjMuMXoiIC8+CiAgICA8cGF0aCBmaWxsPSIjQzMwMDJGIiBkPSJNMTI1IDMwdjIyLjItLjFWMjMwbDc4LjktNDMuNyAxNC4yLTEyMy4xTDEyNSAzMHoiIC8+CiAgICA8cGF0aCAgZmlsbD0iI0ZGRkZGRiIgZD0iTTEyNSA1Mi4xTDY2LjggMTgyLjZoMjEuN2wxMS43LTI5LjJoNDkuNGwxMS43IDI5LjJIMTgzTDEyNSA1Mi4xem0xNyA4My4zaC0zNGwxNy00MC45IDE3IDQwLjl6IiAvPgogIDwvc3ZnPg=="
            />
            <span rdxAvatarFallback>Angular Logo</span>
        </span>
    `
})
class RdxMockComponent {}

describe('RdxAvatarImageDirective', () => {
    let component: RdxMockComponent;
    let fixture: ComponentFixture<RdxMockComponent>;

    beforeEach(() => {
        fixture = TestBed.createComponent(RdxMockComponent);
        component = fixture.componentInstance;
    });

    it('should compile', () => {
        expect(component).toBeTruthy();
    });

    it('should display the image initially', () => {
        const imgElement = fixture.debugElement.query(By.css('img[rdxAvatarImage]'));
        expect(imgElement).toBeTruthy();
        expect(imgElement.nativeElement.src).toContain('data:image/svg+xml');
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/avatar/src/avatar-fallback.directive.ts
```typescript
import { computed, Directive, effect, inject, input, OnDestroy, signal } from '@angular/core';
import { RdxAvatarRootContext } from './avatar-root.directive';
import { injectAvatarConfig } from './avatar.config';

/**
 * @group Components
 */
@Directive({
    selector: 'span[rdxAvatarFallback]',
    standalone: true,
    exportAs: 'rdxAvatarFallback',
    host: {
        '[style.display]': 'shouldRender() ? null : "none" '
    }
})
export class RdxAvatarFallbackDirective implements OnDestroy {
    protected readonly avatarRoot = inject(RdxAvatarRootContext);

    private readonly config = injectAvatarConfig();

    /**
     * Useful for delaying rendering so it only appears for those with slower connections.
     *
     * @group Props
     * @defaultValue 0
     */
    readonly delayMs = input<number>(this.config.delayMs);

    readonly shouldRender = computed(() => this.canRender() && this.avatarRoot.imageLoadingStatus() !== 'loaded');

    protected readonly canRender = signal(false);
    private timeoutId: ReturnType<typeof setTimeout> | null = null;

    constructor() {
        effect(() => {
            const status = this.avatarRoot.imageLoadingStatus();
            if (status === 'loading') {
                this.startDelayTimer();
            } else {
                this.clearDelayTimer();
                this.canRender.set(true);
            }
        });
    }

    private startDelayTimer() {
        this.clearDelayTimer();
        if (this.delayMs() > 0) {
            this.timeoutId = setTimeout(() => {
                this.canRender.set(true);
            }, this.delayMs());
        } else {
            this.canRender.set(true);
        }
    }

    private clearDelayTimer() {
        if (this.timeoutId !== null) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
    }

    ngOnDestroy() {
        this.clearDelayTimer();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/avatar/src/avatar-image.directive.ts
```typescript
import { computed, Directive, ElementRef, inject, input, OnInit, output } from '@angular/core';
import { RdxAvatarRootContext, RdxImageLoadingStatus } from './avatar-root.directive';

/**
 * @group Components
 */
@Directive({
    selector: 'img[rdxAvatarImage]',
    standalone: true,
    exportAs: 'rdxAvatarImage',
    host: {
        '(load)': 'onLoad()',
        '(error)': 'onError()',
        '[style.display]': '(imageLoadingStatus() === "loaded")? null : "none"'
    }
})
export class RdxAvatarImageDirective implements OnInit {
    private readonly avatarRoot = inject(RdxAvatarRootContext);
    private readonly elementRef = inject(ElementRef<HTMLImageElement>);

    /**
     * @group Props
     */
    readonly src = input<string>();

    /**
     * A callback providing information about the loading status of the image.
     * This is useful in case you want to control more precisely what to render as the image is loading.
     *
     * @group Emits
     */
    readonly onLoadingStatusChange = output<RdxImageLoadingStatus>();

    protected readonly imageLoadingStatus = computed(() => this.avatarRoot.imageLoadingStatus());

    ngOnInit(): void {
        this.nativeElement.src = this.src();

        if (!this.nativeElement.src) {
            this.setImageStatus('error');
        } else if (this.nativeElement.complete) {
            this.setImageStatus('loaded');
        } else {
            this.setImageStatus('loading');
        }
    }

    onLoad() {
        this.setImageStatus('loaded');
    }

    onError() {
        this.setImageStatus('error');
    }

    private setImageStatus(status: RdxImageLoadingStatus) {
        this.avatarRoot.imageLoadingStatus.set(status);
        this.onLoadingStatusChange.emit(status);
    }

    get nativeElement() {
        return this.elementRef.nativeElement;
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/avatar/src/avatar-root.directive.ts
```typescript
import { Directive, Injectable, signal } from '@angular/core';

export type RdxImageLoadingStatus = 'idle' | 'loading' | 'loaded' | 'error';

@Injectable()
export class RdxAvatarRootContext {
    readonly imageLoadingStatus = signal<RdxImageLoadingStatus>('loading');
}

@Directive({
    selector: 'span[rdxAvatarRoot]',
    exportAs: 'rdxAvatarRoot',
    standalone: true,
    providers: [RdxAvatarRootContext]
})
export class RdxAvatarRootDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/avatar/src/avatar.config.ts
```typescript
import { inject, InjectionToken, Provider } from '@angular/core';

export interface RdxAvatarConfig {
    /**
     * Define a delay before the fallback is shown.
     * This is useful to only show the fallback for those with slower connections.
     * @default 0
     */
    delayMs: number;
}

export const defaultAvatarConfig: RdxAvatarConfig = {
    delayMs: 0
};

export const RdxAvatarConfigToken = new InjectionToken<RdxAvatarConfig>('RdxAvatarConfigToken');

export function provideRdxAvatarConfig(config: Partial<RdxAvatarConfig>): Provider[] {
    return [
        {
            provide: RdxAvatarConfigToken,
            useValue: { ...defaultAvatarConfig, ...config }
        }
    ];
}

export function injectAvatarConfig(): RdxAvatarConfig {
    return inject(RdxAvatarConfigToken, { optional: true }) ?? defaultAvatarConfig;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/aspect-ratio/README.md
```
# @radix-ng/primitives/avatar

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/aspect-ratio/index.ts
```typescript
export * from './src/aspect-ratio.directive';

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/aspect-ratio/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/aspect-ratio/stories/aspect-ratio.docs.mdx
```
import { Canvas, Meta } from '@storybook/blocks';
import * as AspectRatioStories from './aspect-ratio.stories';

<Meta title="Primitives/Aspect Ratio" />

# Aspect Ratio

#### Displays content within a desired ratio.

<Canvas sourceState="hidden" of={AspectRatioStories.Default} />

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/aspect-ratio/stories/aspect-ratio.stories.ts
```typescript
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { RdxAspectRatioDirective } from '../src/aspect-ratio.directive';

const html = String.raw;

export default {
    title: 'Primitives/Aspect Ratio',
    decorators: [
        moduleMetadata({
            imports: [RdxAspectRatioDirective]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div
                    class="radix-themes light light-theme radix-themes-default-fonts"
                    data-accent-color="indigo"
                    data-radius="medium"
                    data-scaling="100%"
                >
                    ${story}

                    <style>
                        .Container {
                            width: 300px;
                            border-radius: 6px;
                            overflow: hidden;
                            box-shadow: 0 2px 10px var(--black-a7);
                        }

                        .Image {
                            object-fit: cover;
                            width: 100%;
                            height: 100%;
                        }
                    </style>
                </div>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: html`
            <div class="Container">
                <div rdxAspectRatio [ratio]="16/9">
                    <img
                        class="Image"
                        src="https://images.unsplash.com/photo-1535025183041-0991a977e25b?w=300&dpr=2&q=80"
                        alt="Landscape photograph by Tobias Tullius"
                    />
                </div>
            </div>
        `
    })
};

export const Ratios: Story = {
    render: () => ({
        template: html`
            <div style="display: flex; gap: 20px;">
                <div style="width: 200px;">
                    <span style="color: white">1/2</span>
                    <div rdxAspectRatio [ratio]="1/2">
                        <img
                            class="Image"
                            src="https://images.unsplash.com/photo-1535025183041-0991a977e25b?w=300&dpr=2&q=80"
                            alt="Landscape photograph by Tobias Tullius"
                        />
                    </div>
                </div>
                <div style="width: 200px;">
                    <span style="color: white">1</span>
                    <div rdxAspectRatio>
                        <img
                            class="Image"
                            src="https://images.unsplash.com/photo-1535025183041-0991a977e25b?w=300&dpr=2&q=80"
                            alt="Landscape photograph by Tobias Tullius"
                        />
                    </div>
                </div>
                <div style="width: 200px;">
                    <span style="color: white">16/9</span>
                    <div rdxAspectRatio [ratio]="16/9">
                        <img
                            class="Image"
                            src="https://images.unsplash.com/photo-1535025183041-0991a977e25b?w=300&dpr=2&q=80"
                            alt="Landscape photograph by Tobias Tullius"
                        />
                    </div>
                </div>
                <div style="width: 200px;">
                    <span style="color: white">2/1</span>
                    <div rdxAspectRatio [ratio]="2/1">
                        <img
                            class="Image"
                            src="https://images.unsplash.com/photo-1535025183041-0991a977e25b?w=300&dpr=2&q=80"
                            alt="Landscape photograph by Tobias Tullius"
                        />
                    </div>
                </div>
            </div>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/aspect-ratio/__tests__/aspect-ratio.directive.spec.ts
```typescript
import { Component } from '@angular/core';
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { RdxAspectRatioDirective } from '../src/aspect-ratio.directive';

@Component({
    template: `
        <div [ratio]="ratio" rdxAspectRatio></div>
    `,
    imports: [RdxAspectRatioDirective]
})
class TestComponent {
    ratio = 16 / 9;
}

describe('AspectRatioDirective', () => {
    let fixture: ComponentFixture<TestComponent>;
    let component: TestComponent;

    beforeEach(() => {
        fixture = TestBed.configureTestingModule({
            imports: [TestComponent]
        }).createComponent(TestComponent);

        component = fixture.componentInstance;
        fixture.detectChanges();
    });

    it('should set paddingBottom correctly with rounded value', () => {
        const div: HTMLElement = fixture.nativeElement.querySelector('div');

        // 1 / (16/9) * 100 = 56.25%
        expect(div.style.paddingBottom).toBe('56.25%');
    });

    it('should set position to relative and width to 100%', () => {
        const div: HTMLElement = fixture.nativeElement.querySelector('div');

        expect(div.style.position).toBe('relative');
        expect(div.style.width).toBe('100%');
    });

    it('should update paddingBottom when ratio changes', () => {
        const div: HTMLElement = fixture.nativeElement.querySelector('div');

        component.ratio = 4 / 3;
        fixture.detectChanges();

        // 1 / (4/3) * 100 = 75%
        expect(div.style.paddingBottom).toBe('75%');
    });

    it('should set paddingBottom correctly for small ratios', () => {
        const div: HTMLElement = fixture.nativeElement.querySelector('div');

        component.ratio = 1 / 1;
        fixture.detectChanges();

        // 1 / (1/1) * 100 = 100%
        expect(div.style.paddingBottom).toBe('100%'); //
    });

    it('should set paddingBottom to 0% when ratio is 0 to avoid division by zero', () => {
        const div: HTMLElement = fixture.nativeElement.querySelector('div');

        component.ratio = 0;
        fixture.detectChanges();

        expect(div.style.paddingBottom).toBe('0%');
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/aspect-ratio/src/aspect-ratio.directive.ts
```typescript
import { NumberInput } from '@angular/cdk/coercion';
import {
    AfterViewInit,
    computed,
    Directive,
    ElementRef,
    inject,
    input,
    numberAttribute,
    Renderer2
} from '@angular/core';

/**
 * Directive to maintain an aspect ratio for an element.
 * The element will have its `padding-bottom` dynamically calculated
 * based on the provided aspect ratio to maintain the desired ratio.
 * The content inside the element will be positioned absolutely.
 * @group Components
 */
@Directive({
    selector: '[rdxAspectRatio]',
    exportAs: 'rdxAspectRatio',
    standalone: true,
    host: {
        '[style.position]': `'relative'`,
        '[style.width]': `'100%'`,
        '[style.padding-bottom]': 'paddingBottom()'
    }
})
export class RdxAspectRatioDirective implements AfterViewInit {
    private readonly element = inject(ElementRef);
    private readonly renderer = inject(Renderer2);

    /**
     * The desired aspect ratio (e.g., 16/9).
     * By default, it is set to 1 (which results in a square, 1:1).
     * @group Props
     * @defaultValue 1
     */
    readonly ratio = input<number, NumberInput>(1, { transform: numberAttribute });

    /**
     * Dynamically computed `padding-bottom` style for the element.
     * This value is calculated based on the inverse of the aspect ratio.
     *
     * If the ratio is zero, it defaults to `0%` to avoid division by zero.
     *
     */
    protected readonly paddingBottom = computed(() => {
        const ratioValue = this.ratio();
        return `${ratioValue !== 0 ? (1 / ratioValue) * 100 : 0}%`;
    });

    ngAfterViewInit() {
        const content = this.element.nativeElement.firstElementChild;
        if (content) {
            // Set the content to cover the entire element with absolute positioning
            this.renderer.setStyle(content, 'position', 'absolute');
            this.renderer.setStyle(content, 'inset', '0');
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/switch/README.md
```
# @radix-ng/primitives/switch

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/switch/index.ts
```typescript
import { NgModule } from '@angular/core';
import { RdxSwitchInputDirective } from './src/switch-input.directive';
import { RdxSwitchRootDirective } from './src/switch-root.directive';
import { RdxSwitchThumbDirective } from './src/switch-thumb.directive';

export * from './src/switch-input.directive';
export * from './src/switch-root.directive';
export * from './src/switch-thumb.directive';

export type { SwitchProps } from './src/switch-root.directive';

const switchImports = [
    RdxSwitchRootDirective,
    RdxSwitchInputDirective,
    RdxSwitchThumbDirective
];

@NgModule({
    imports: [...switchImports],
    exports: [...switchImports]
})
export class RdxSwitchModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/switch/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/switch/stories/switch-forms.component.ts
```typescript
import { Component, OnInit } from '@angular/core';
import { FormControl, FormGroup, ReactiveFormsModule } from '@angular/forms';
import { RdxLabelDirective } from '@radix-ng/primitives/label';
import { RdxSwitchInputDirective } from '../src/switch-input.directive';
import { RdxSwitchRootDirective } from '../src/switch-root.directive';
import { RdxSwitchThumbDirective } from '../src/switch-thumb.directive';

@Component({
    selector: 'switch-reactive-forms',
    imports: [
        ReactiveFormsModule,
        RdxLabelDirective,
        RdxSwitchRootDirective,
        RdxSwitchInputDirective,
        RdxSwitchThumbDirective
    ],
    styleUrl: './switch.styles.css',
    template: `
        <form [formGroup]="formGroup" (ngSubmit)="onSubmit()">
            <label class="Label" rdxLabel htmlFor="airplane-mode-form">
                Airplane mode
                <button class="SwitchRoot" id="airplane-mode-form" formControlName="policy" rdxSwitchRoot>
                    <input rdxSwitchInput />
                    <span class="SwitchThumb" rdxSwitchThumb></span>
                </button>
            </label>
            <button class="Button violet" style="margin-top: 8px;" type="submit">Submit</button>
        </form>
        <p>
            <button class="Button violet" (click)="setValue()">Set preset value</button>
        </p>
    `
})
export class SwitchReactiveForms implements OnInit {
    formGroup!: FormGroup;

    ngOnInit() {
        this.formGroup = new FormGroup({
            policy: new FormControl<boolean>(true)
        });
    }

    onSubmit(): void {
        console.log(this.formGroup.value);
    }

    setValue() {
        this.formGroup.setValue({ policy: false });
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/switch/stories/switch.docs.mdx
````
import { ArgTypes, Canvas, Markdown, Meta } from '@storybook/blocks';
import { switchExclude } from '../../../../apps/storybook-radix/docs/utils/storybook';
import { RdxSwitchRootDirective } from '../src/switch-root.directive';
import * as SwitchDirectiveStories from './switch.stories';

<Meta title="Primitives/Switch" />

# Switch

#### A control that allows the user to toggle between checked and not checked.

<Canvas sourceState="hidden" of={SwitchDirectiveStories.Default} />

## Features

- âœ… Full keyboard navigation.
- âœ… Can be controlled or uncontrolled.

## Import

Get started with importing the directives:

```typescript
import { RdxSwitchRootDirective, RdxSwitchThumbDirective, RdxSwitchInputDirective } from '@radix-ng/primitives/switch';
```

## Examples

```html
<label rdxLabel htmlFor="airplane-mode">Airplane mode</label>
<button id="airplane-mode" rdxSwitchRoot [(checked)]="checked">
  <span rdxSwitchThumb></span>
</button>
```

```html
<label rdxLabel htmlFor="airplane-mode">Airplane mode</label>
<button id="airplane-mode" rdxSwitchRoot [(checked)]="checked">
  <input rdxSwitchInput />
  <span rdxSwitchThumb></span>
</button>
```

## API Reference

### Root

`RdxSwitchRootDirective`
<ArgTypes exclude={switchExclude} of={RdxSwitchRootDirective} />

<Markdown>
  {`
  | Data Attribute     | Value |
  | ------------------ | -------------------------- |
  | [data-state]       | "checked" or "unchecked"   |
  | [data-disabled]    | Present when disabled      |
  `}
</Markdown>

### Thumb

`RdxThumbDirective`
<Markdown>
  {`
  | Data Attribute     | Value |
  | ------------------ | -------------------------- |
  | [data-state]       | "checked" or "unchecked"   |
  | [data-disabled]    | Present when disabled      |
  `}
</Markdown>

## Accessibility

Adheres to the [`switch` role requirements](https://www.w3.org/WAI/ARIA/apg/patterns/switch).

### Keyboard Interactions

<Markdown>
  {`
  | Key | Description |
  | ----------- | --------- |
  | Space       | Toggles the component's state.        |
  | Enter       | Toggles the component's state.    |
  `}
</Markdown>

### Screen Reader

Switch component uses a hidden native checkbox element with `switch` role internally that is only visible to screen readers.
Value to describe the component can either be provided via `label` tag using `ariaLabelledBy`, `ariaLabel` props.

```html
<label for="switch1">Remember Me</label>
<button rdxSwitchRoot id="switch1" ></button>

<span id="switch2">Remember Me</span>
<button rdxSwitchRoot ariaLabelledBy="switch2"></button>

<button rdxSwitchRoot ariaLabel="Remember Me"></button>
```


## Examples

### Reactive Forms

Switch can also be used with reactive forms. In this case, the `formControlName` property is used to bind the component to a form control.

<Canvas sourceState="hidden" of={SwitchDirectiveStories.ReactiveForm} />

### Disabled

When `disabled` is present, the element cannot be edited and focused.

<Canvas sourceState="hidden" of={SwitchDirectiveStories.Disabled} />

### Preselection

Enabling `checked` property displays the component as active initially.

<Canvas sourceState="hidden" of={SwitchDirectiveStories.Preselection} />

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/switch/stories/switch.stories.ts
```typescript
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { RdxLabelDirective } from '../../label';
import { RdxSwitchInputDirective } from '../src/switch-input.directive';
import { RdxSwitchRootDirective } from '../src/switch-root.directive';
import { RdxSwitchThumbDirective } from '../src/switch-thumb.directive';
import { SwitchReactiveForms } from './switch-forms.component';

const html = String.raw;

export default {
    title: 'Primitives/Switch',
    decorators: [
        moduleMetadata({
            imports: [
                RdxLabelDirective,
                RdxSwitchRootDirective,
                RdxSwitchInputDirective,
                RdxSwitchThumbDirective,
                SwitchReactiveForms
            ]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div class="radix-themes light light-theme" data-radius="medium" data-scaling="100%">
                    ${story}

                    <style>
                        button {
                            all: unset;
                        }

                        .SwitchRoot {
                            width: 42px;
                            height: 25px;
                            background-color: var(--black-a9);
                            border-radius: 9999px;
                            margin-left: 15px;
                            position: relative;
                            box-shadow: 0 2px 10px var(--black-a7);
                            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
                        }
                        .SwitchRoot:focus {
                            box-shadow: 0 0 0 2px black;
                        }
                        .SwitchRoot[data-state='checked'] {
                            background-color: black;
                        }
                        .SwitchRoot[data-disabled='true'] {
                            background-color: var(--black-a6);
                            cursor: not-allowed;
                            box-shadow: none;
                        }

                        .SwitchThumb {
                            display: block;
                            width: 21px;
                            height: 21px;
                            background-color: white;
                            border-radius: 9999px;
                            box-shadow: 0 2px 2px var(--black-a7);
                            transition: transform 100ms;
                            transform: translateX(2px);
                            will-change: transform;
                        }
                        .SwitchThumb[data-state='checked'] {
                            transform: translateX(19px);
                        }

                        .Label {
                            color: white;
                            font-size: 15px;
                            line-height: 1;
                            display: flex;
                            align-items: center;
                        }
                    </style>
                </div>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: html`
            <label class="Label" rdxLabel htmlFor="airplane-mode">
                Airplane mode
                <button class="SwitchRoot" id="airplane-mode" rdxSwitchRoot defaultChecked>
                    <span class="SwitchThumb" rdxSwitchThumb></span>
                </button>
            </label>
        `
    })
};

export const Preselection: Story = {
    argTypes: {
        checked: {
            control: {
                type: 'boolean'
            }
        }
    },
    args: {
        checked: true
    },
    render: (args) => ({
        props: {
            config: args
        },
        template: html`
            <label class="Label" rdxLabel htmlFor="airplane-mode-model">
                Airplane mode
                <button class="SwitchRoot" id="airplane-mode-model" rdxSwitchRoot [checked]="config.checked">
                    <input rdxSwitchInput />
                    <span class="SwitchThumb" rdxSwitchThumb></span>
                </button>
            </label>
        `
    })
};

export const Disabled: Story = {
    name: 'Disabled',
    render: () => ({
        template: html`
            <label class="Label" rdxLabel htmlFor="airplane-mode-disabled">
                Airplane mode
                <button class="SwitchRoot" id="airplane-mode-disabled" rdxSwitchRoot disabled>
                    <input rdxSwitchInput />
                    <span class="SwitchThumb" rdxSwitchThumb></span>
                </button>
            </label>
        `
    })
};

export const ReactiveForm: Story = {
    render: () => ({
        template: html`
            <switch-reactive-forms />
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/switch/stories/switch.styles.css
```css
button {
    all: unset;
}

.SwitchRoot {
    width: 42px;
    height: 25px;
    background-color: var(--black-a9);
    border-radius: 9999px;
    margin-left: 15px;
    position: relative;
    box-shadow: 0 2px 10px var(--black-a7);
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}

.SwitchRoot:focus {
    box-shadow: 0 0 0 2px black;
}

.SwitchRoot[data-state='checked'] {
    background-color: black;
}

.SwitchRoot[data-disabled='true'] {
    background-color: var(--black-a6);
    cursor: not-allowed;
    box-shadow: none;
}

.SwitchThumb {
    display: block;
    width: 21px;
    height: 21px;
    background-color: white;
    border-radius: 9999px;
    box-shadow: 0 2px 2px var(--black-a7);
    transition: transform 100ms;
    transform: translateX(2px);
    will-change: transform;
}

.SwitchThumb[data-state='checked'] {
    transform: translateX(19px);
}

.Label {
    color: white;
    font-size: 15px;
    line-height: 1;
    display: flex;
    align-items: center;
}

.Button.violet {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    padding: 0 15px;
    font-size: 15px;
    line-height: 1;
    font-weight: 500;
    height: 35px;
    background-color: white;
    color: var(--violet-11);
    box-shadow: 0 2px 10px var(--black-a7);
}

.Button.violet:hover {
    background-color: var(--mauve-3);
}

.Button.violet:focus {
    box-shadow: 0 0 0 2px black;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/switch/__tests__/switch.directive.spec.ts
```typescript
import { TestBed } from '@angular/core/testing';

import { ElementRef } from '@angular/core';
import { RdxSwitchRootDirective } from '../src/switch-root.directive';

describe('RdxSwitchRootDirective', () => {
    let directive: RdxSwitchRootDirective;

    beforeEach(() => {
        TestBed.configureTestingModule({
            providers: [
                RdxSwitchRootDirective,
                { provide: ElementRef, useValue: new ElementRef(document.createElement('button')) }]
        });

        directive = TestBed.inject(RdxSwitchRootDirective);
    });

    it('should initialize with default state', () => {
        expect(directive.checked()).toBe(false);
        expect(directive.required()).toBe(false);
        expect(directive.disabled()).toBe(false);
    });

    it('should toggle checked state and emit event', () => {
        const onCheckedChangeSpy = jest.spyOn(directive.onCheckedChange, 'emit');
        directive.toggle();

        expect(directive.checked()).toBe(true);
        expect(onCheckedChangeSpy).toHaveBeenCalledWith(true);

        directive.toggle();

        expect(directive.checked()).toBe(false);
        expect(onCheckedChangeSpy).toHaveBeenCalledWith(false);
    });

    it('should set disabled state using ControlValueAccessor', () => {
        directive.setDisabledState(true);
        expect(directive.disabledState()).toBe(true);

        directive.setDisabledState(false);
        expect(directive.disabledState()).toBe(false);
    });

    it('should emit correct values for controlled checked state', () => {
        const onCheckedChangeSpy = jest.spyOn(directive.onCheckedChange, 'emit');

        directive.checked.set(true);
        directive.toggle(); // Controlled state logic
        expect(directive.checked()).toBe(false);
        expect(onCheckedChangeSpy).toHaveBeenCalledWith(false);
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/switch/src/switch-input.directive.ts
```typescript
import { Directive } from '@angular/core';
import { injectSwitch } from './switch-root.directive';

/**
 * @group Components
 */
@Directive({
    selector: 'input[rdxSwitchInput]',
    exportAs: 'rdxSwitchInput',
    host: {
        type: 'checkbox',
        role: 'switch',
        tabindex: '-1',
        '[attr.id]': 'switchRoot.inputId()',
        '[attr.defaultChecked]': 'switchRoot.checkedState()',
        '[attr.aria-checked]': 'switchRoot.checkedState()',
        '[attr.aria-hidden]': 'true',
        '[attr.aria-label]': 'switchRoot.ariaLabel()',
        '[attr.aria-labelledby]': 'switchRoot.ariaLabelledBy()',
        '[attr.aria-required]': 'switchRoot.required()',
        '[attr.data-state]': 'switchRoot.checkedState() ? "checked" : "unchecked"',
        '[attr.data-disabled]': 'switchRoot.disabledState() ? "true" : null',
        '[attr.disabled]': 'switchRoot.disabledState() ? switchRoot.disabledState() : null',
        '[attr.value]': 'switchRoot.checkedState() ? "on" : "off"',
        style: 'transform: translateX(-100%); position: absolute; overflow: hidden; pointerEvents: none; opacity: 0; margin: 0;',

        '(blur)': 'onBlur()'
    }
})
export class RdxSwitchInputDirective {
    protected readonly switchRoot = injectSwitch();

    /** @ignore */
    protected onBlur() {
        this.switchRoot.onTouched?.();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/switch/src/switch-root.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import {
    booleanAttribute,
    computed,
    Directive,
    effect,
    inject,
    InjectionToken,
    input,
    InputSignalWithTransform,
    model,
    ModelSignal,
    output,
    OutputEmitterRef,
    signal
} from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { provideToken, provideValueAccessor } from '@radix-ng/primitives/core';

export const RdxSwitchToken = new InjectionToken<RdxSwitchRootDirective>('RdxSwitchToken');

export function injectSwitch(): RdxSwitchRootDirective {
    return inject(RdxSwitchToken);
}

export interface SwitchProps {
    checked?: ModelSignal<boolean>;
    defaultChecked?: InputSignalWithTransform<boolean, BooleanInput>;
    required?: InputSignalWithTransform<boolean, BooleanInput>;
    onCheckedChange?: OutputEmitterRef<boolean>;
}

let idIterator = 0;

/**
 * @group Components
 */
@Directive({
    selector: 'button[rdxSwitchRoot]',
    exportAs: 'rdxSwitchRoot',
    providers: [
        provideToken(RdxSwitchToken, RdxSwitchRootDirective),
        provideValueAccessor(RdxSwitchRootDirective)],
    host: {
        type: 'button',
        '[id]': 'elementId()',
        '[attr.aria-checked]': 'checkedState()',
        '[attr.aria-required]': 'required()',
        '[attr.data-state]': 'checkedState() ? "checked" : "unchecked"',
        '[attr.data-disabled]': 'disabledState() ? "true" : null',
        '[attr.disabled]': 'disabledState() ? disabledState() : null',

        '(click)': 'toggle()'
    }
})
export class RdxSwitchRootDirective implements SwitchProps, ControlValueAccessor {
    readonly id = input<string | null>(`rdx-switch-${idIterator++}`);

    protected readonly elementId = computed(() => (this.id() ? this.id() : null));

    readonly inputId = input<string | null>(null);

    /**
     * When true, indicates that the user must check the switch before the owning form can be submitted.
     *
     * @default false
     * @group Props
     */
    readonly required = input<boolean, BooleanInput>(false, {
        transform: booleanAttribute
    });

    /**
     * Establishes relationships between the component and label(s) where its value should be one or more element IDs.
     * @default null
     * @group Props
     */
    readonly ariaLabelledBy = input<string | undefined>(undefined, {
        alias: 'aria-labelledby'
    });

    /**
     * Used to define a string that autocomplete attribute the current element.
     * @default null
     * @group Props
     */
    readonly ariaLabel = input<string | undefined>(undefined, {
        alias: 'aria-label'
    });

    /**
     * The controlled state of the switch. Must be used in conjunction with onCheckedChange.
     * @defaultValue false
     * @group Props
     */
    readonly checked = model<boolean>(false);

    /**
     * The state of the switch when it is initially rendered. Use when you do not need to control its state.
     * @default false
     * @group Props
     */
    readonly defaultChecked = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * The state of the switch.
     * If `defaultChecked` is provided, it takes precedence over the `checked` state.
     * @ignore
     */
    readonly checkedState = computed(() => this.checked());

    /**
     * When `true`, prevents the user from interacting with the switch.
     * @default false
     * @group Props
     */
    readonly disabled = input<boolean, BooleanInput>(false, {
        transform: booleanAttribute
    });

    /** @ignore */
    readonly disabledState = computed(() => this.disabled() || this.accessorDisabled());

    /**
     * Event handler called when the state of the switch changes.
     *
     * @param {boolean} value - Boolean value indicates that the option is changed.
     * @group Emits
     */
    readonly onCheckedChange = output<boolean>();

    private readonly defaultCheckedUsed = computed(() => this.defaultChecked());

    constructor() {
        effect(() => {
            if (this.defaultCheckedUsed()) {
                this.checked.set(this.defaultChecked());
            }
        });
    }

    /**
     * Toggles the checked state of the switch.
     * If the switch is disabled, the function returns early.
     * @ignore
     */
    toggle(): void {
        if (this.disabledState()) {
            return;
        }

        this.checked.set(!this.checked());

        this.onChange(this.checked());
        this.onCheckedChange.emit(this.checked());
    }

    private readonly accessorDisabled = signal(false);

    private onChange: (value: any) => void = () => {};
    /** @ignore */
    onTouched: (() => void) | undefined;

    /** @ignore */
    writeValue(value: any): void {
        this.checked.set(value);
    }

    /** @ignore */
    registerOnChange(fn: (value: any) => void): void {
        this.onChange = fn;
    }

    /** @ignore */
    registerOnTouched(fn: () => void): void {
        this.onTouched = fn;
    }

    /** @ignore */
    setDisabledState(isDisabled: boolean): void {
        this.accessorDisabled.set(isDisabled);
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/switch/src/switch-thumb.directive.ts
```typescript
import { Directive } from '@angular/core';
import { injectSwitch } from './switch-root.directive';

/**
 * @group Components
 */
@Directive({
    selector: 'span[rdxSwitchThumb]',
    exportAs: 'rdxSwitchThumb',
    host: {
        '[attr.data-disabled]': 'switchRoot.disabledState() ? "true" : null',
        '[attr.data-state]': 'switchRoot.checkedState() ? "checked" : "unchecked"'
    }
})
export class RdxSwitchThumbDirective {
    protected readonly switchRoot = injectSwitch();
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/select/README.md
```
# @radix-ng/primitives/select

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/select/index.ts
```typescript
import { NgModule } from '@angular/core';
import { RdxSelectContentDirective } from './src/select-content.directive';
import { RdxSelectGroupDirective } from './src/select-group.directive';
import { RdxSelectIconDirective } from './src/select-icon.directive';
import { RdxSelectItemIndicatorDirective } from './src/select-item-indicator.directive';
import { RdxSelectItemDirective } from './src/select-item.directive';
import { RdxSelectLabelDirective } from './src/select-label.directive';
import { RdxSelectSeparatorDirective } from './src/select-separator.directive';
import { RdxSelectTriggerDirective } from './src/select-trigger.directive';
import { RdxSelectValueDirective } from './src/select-value.directive';
import { RdxSelectComponent } from './src/select.component';

export * from './src/select-content.directive';
export * from './src/select-group.directive';
export * from './src/select-icon.directive';
export * from './src/select-item-indicator.directive';
export * from './src/select-item.directive';
export * from './src/select-label.directive';
export * from './src/select-separator.directive';
export * from './src/select-trigger.directive';
export * from './src/select-value.directive';
export * from './src/select.component';

const _imports = [
    RdxSelectContentDirective,
    RdxSelectGroupDirective,
    RdxSelectItemDirective,
    RdxSelectItemIndicatorDirective,
    RdxSelectLabelDirective,
    RdxSelectComponent,
    RdxSelectSeparatorDirective,
    RdxSelectTriggerDirective,
    RdxSelectValueDirective,
    RdxSelectIconDirective
];

@NgModule({
    imports: [..._imports],
    exports: [..._imports]
})
export class RdxSelectModule {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/select/ng-package.json
```json
{
    "lib": {
        "entryFile": "index.ts"
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/select/stories/select.docs.mdx
````
import { ArgTypes, Canvas, Meta } from '@storybook/blocks';
import * as SelectStories from './select.stories';
import { RdxSelectComponent } from '../src/select.component';
import { RdxSelectItemDirective } from '../src/select-item.directive';
import { RdxSelectTriggerDirective } from '../src/select-trigger.directive';
import { RdxSelectContentDirective } from '../src/select-content.directive';

<Meta title="Primitives/Select" />

# Select

#### A vertically stacked set of interactive headings that each reveal an associated section of content.

## Single

<Canvas sourceState="hidden" of={SelectStories.Default} />

## Features

- âœ… Can be controlled or uncontrolled.
- âœ… Offers 2 positioning modes.
- âœ… Supports items, labels, groups of items.
- âœ… Focus is fully managed.
- âœ… Full keyboard navigation.
- âœ… Supports custom placeholder.
- âœ… Typeahead support.
- âœ… Supports Right to Left direction.

## Anatomy

```html
<div rdxSelectRoot>
    <div rdxSelectContent>
        <div rdxSelectItem></div>
    </div>
</div>
```

## Import

Get started with importing the directives:

```typescript
import {
  RdxAccordionRootDirective,
  RdxAccordionItemDirective,
  RdxAccordionTriggerDirective,
  RdxAccordionContentDirective
} from '@radix-ng/primitives/select';
```

## API Reference

### Root
`RdxSelectComponent`

<ArgTypes of={RdxSelectComponent} />

### Item
`RdxSelectItemDirective`

<ArgTypes of={RdxSelectItemDirective} />

### Trigger
`RdxSelectTriggerDirective`

<ArgTypes of={RdxSelectTriggerDirective} />

### Content
`RdxSelectContentDirective`

<ArgTypes of={RdxSelectContentDirective} />

````
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/select/stories/select.stories.ts
```typescript
import { BrowserAnimationsModule, provideAnimations } from '@angular/platform-browser/animations';
import {
    RdxSelectComponent,
    RdxSelectContentDirective,
    RdxSelectGroupDirective,
    RdxSelectIconDirective,
    RdxSelectItemDirective,
    RdxSelectItemIndicatorDirective,
    RdxSelectLabelDirective,
    RdxSelectSeparatorDirective,
    RdxSelectTriggerDirective,
    RdxSelectValueDirective
} from '@radix-ng/primitives/select';
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { Check, ChevronDown, LucideAngularModule } from 'lucide-angular';

const html = String.raw;

export default {
    title: 'Primitives/Select',
    decorators: [
        moduleMetadata({
            imports: [
                RdxSelectComponent,
                RdxSelectSeparatorDirective,
                RdxSelectLabelDirective,
                RdxSelectItemIndicatorDirective,
                RdxSelectItemDirective,
                RdxSelectGroupDirective,
                BrowserAnimationsModule,
                RdxSelectContentDirective,
                RdxSelectTriggerDirective,
                RdxSelectValueDirective,
                RdxSelectIconDirective,
                LucideAngularModule,
                LucideAngularModule.pick({ ChevronDown, Check })
            ],
            providers: [provideAnimations()]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div
                    class="radix-themes light light-theme radix-themes-default-fonts"
                    data-accent-color="indigo"
                    data-radius="medium"
                    data-scaling="100%"
                >
                    ${story}
                </div>

                <style>
                    /* reset */
                    button {
                        all: unset;
                    }

                    .SelectTrigger {
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                        border-radius: 4px;
                        padding: 0 15px;
                        font-size: 13px;
                        line-height: 1;
                        height: 35px;
                        gap: 5px;
                        background-color: white;
                        color: var(--violet-11);
                        box-shadow: 0 2px 10px var(--black-a7);
                    }
                    .SelectTrigger:hover {
                        background-color: var(--mauve-3);
                    }
                    .SelectTrigger:focus {
                        box-shadow: 0 0 0 2px black;
                    }
                    .SelectTrigger[data-placeholder] {
                        color: var(--violet-9);
                    }

                    .SelectIcon {
                        color: Var(--violet-11);
                    }

                    .SelectContent {
                        overflow: hidden;
                        background-color: white;
                        border-radius: 6px;
                        box-shadow:
                            0px 10px 38px -10px rgba(22, 23, 24, 0.35),
                            0px 10px 20px -15px rgba(22, 23, 24, 0.2);
                    }

                    .SelectViewport {
                        padding: 5px;
                    }

                    .SelectItem {
                        font-size: 13px;
                        line-height: 1;
                        color: var(--violet-11);
                        border-radius: 3px;
                        display: flex;
                        align-items: center;
                        height: 25px;
                        padding: 0 35px 0 25px;
                        position: relative;
                        user-select: none;
                    }
                    .SelectItem[data-disabled] {
                        color: var(--mauve-8);
                        pointer-events: none;
                    }
                    .SelectItem[data-highlighted] {
                        outline: none;
                        background-color: var(--violet-9);
                        color: var(--violet-1);
                    }

                    .SelectLabel {
                        padding: 0 25px;
                        font-size: 12px;
                        line-height: 25px;
                        color: var(--mauve-11);
                    }

                    .SelectSeparator {
                        height: 1px;
                        background-color: var(--violet-6);
                        margin: 5px;
                    }

                    .SelectItemIndicator {
                        position: absolute;
                        left: 0;
                        width: 25px;
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                    }

                    .SelectScrollButton {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        height: 25px;
                        background-color: white;
                        color: var(--violet-11);
                        cursor: default;
                    }
                </style>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    args: {
        foodGroups: [
            {
                label: 'Fruits',
                foods: [
                    { value: 'apple', label: 'Apple' },
                    { value: 'banana', label: 'Banana' },
                    { value: 'blueberry', label: 'Blueberry' },
                    { value: 'grapes', label: 'Grapes' },
                    { value: 'pineapple', label: 'Pineapple' }
                ]
            },
            {
                label: 'Vegetables',
                foods: [
                    { value: 'aubergine', label: 'Aubergine' },
                    { value: 'broccoli', label: 'Broccoli' },
                    { value: 'carrot', label: 'Carrot', disabled: true },
                    { value: 'courgette', label: 'Courgette' },
                    { value: 'leek', label: 'Leek' }
                ]
            },
            {
                label: 'Meat',
                foods: [
                    { value: 'beef', label: 'Beef' },
                    { value: 'beef-with-sauce', label: 'Beef with sauce' },
                    { value: 'chicken', label: 'Chicken' },
                    { value: 'lamb', label: 'Lamb' },
                    { value: 'pork', label: 'Pork' }
                ]
            },
            {
                foods: [
                    { value: 'candies', label: 'Candies' },
                    { value: 'chocolates', label: 'Chocolates' }
                ]
            }
        ]
    },
    render: (args) => ({
        props: args,
        template: html`
            <span rdxSelect>
                <button class="SelectTrigger" rdxSelectTrigger>
                    <span rdxSelectValue placeholder="Select a fruitâ€¦"></span>
                    <lucide-icon class="SelectIcon" size="16" name="chevron-down" rdxSelectIcon />
                </button>
                <div class="SelectContent SelectViewport" rdxSelectContent>
                    @for (group of foodGroups; track group; let last = $last) {
                    <div class="SelectGroup" rdxSelectGroup>
                        <div class="SelectLabel" rdxSelectLabel>{{ group.label }}</div>
                        @for (food of group.foods; track food) {
                        <div class="SelectItem" rdxSelectItem [value]="food.value" [disabled]="food.disabled">
                            <lucide-icon class="SelectItemIndicator" rdxSelectItemIndicator size="16" name="check" />
                            {{ food.label }}
                        </div>
                        }
                    </div>
                    @if (!last) {
                    <div class="SelectSeparator" rdxSelectSeparator></div>
                    } }
                </div>
            </span>
        `
    })
};

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/select/__tests__/select-content.directive.spec.ts
```typescript
import { RdxSelectContentDirective } from '../src/select-content.directive';

xdescribe('RdxSelectContentDirective', () => {
    it('should create an instance', () => {
        const directive = new RdxSelectContentDirective();
        expect(directive).toBeTruthy();
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/select/__tests__/select-item.directive.spec.ts
```typescript
import { RdxSelectItemDirective } from '../src/select-item.directive';

xdescribe('RdxSelectItemDirective', () => {
    it('should create an instance', () => {
        const directive = new RdxSelectItemDirective();
        expect(directive).toBeTruthy();
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/select/__tests__/select-trigger.directive.spec.ts
```typescript
import { RdxSelectTriggerDirective } from '../src/select-trigger.directive';

xdescribe('RdxSelectTriggerDirective', () => {
    it('should create an instance', () => {
        const directive = new RdxSelectTriggerDirective();
        expect(directive).toBeTruthy();
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/select/__tests__/select.directive.spec.ts
```typescript
import { RdxSelectComponent } from '../src/select.component';

xdescribe('RdxSelectDirective', () => {
    it('should create an instance', () => {
        const directive = new RdxSelectComponent();
        expect(directive).toBeTruthy();
    });
});

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/select/src/select-content.directive.ts
```typescript
import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';
import { Directionality } from '@angular/cdk/bidi';
import { AfterContentInit, ContentChildren, DestroyRef, Directive, inject, QueryList } from '@angular/core';
import { pairwise, startWith, Subject } from 'rxjs';
import { RdxSelectItemDirective } from './select-item.directive';
import { RdxSelectComponent } from './select.component';

@Directive({
    selector: '[rdxSelectContent]',
    standalone: true,
    exportAs: 'rdxSelectContent',
    host: {
        '[attr.role]': '"listbox"',
        '[attr.data-state]': "select.open ? 'open': 'closed'",
        '[attr.data-side]': 'true',
        '[attr.data-align]': 'true',
        '(keydown)': 'keyManager.onKeydown($event)'
    }
})
export class RdxSelectContentDirective implements AfterContentInit {
    protected readonly destroyRef = inject(DestroyRef);
    protected readonly dir = inject(Directionality, { optional: true });
    protected select = inject(RdxSelectComponent);

    readonly highlighted = new Subject<RdxSelectItemDirective>();

    keyManager: ActiveDescendantKeyManager<RdxSelectItemDirective>;

    @ContentChildren(RdxSelectItemDirective, { descendants: true })
    options: QueryList<RdxSelectItemDirective>;

    constructor() {
        this.highlighted.pipe(startWith(null), pairwise()).subscribe(([prev, item]) => {
            if (prev) {
                prev.highlighted = false;
            }

            if (item) {
                item.highlighted = true;
            }
        });
    }

    initKeyManager() {
        return new ActiveDescendantKeyManager<RdxSelectItemDirective>(this.options)
            .withTypeAhead()
            .withVerticalOrientation()
            .withHorizontalOrientation(this.dir?.value ?? 'ltr');
    }

    ngAfterContentInit(): void {
        this.keyManager = this.initKeyManager();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/select/src/select-group.directive.ts
```typescript
import { Directive } from '@angular/core';

@Directive({
    selector: '[rdxSelectGroup]',
    standalone: true,
    exportAs: 'rdxSelectGroup',
    host: {
        '[attr.role]': '"group"'
    }
})
export class RdxSelectGroupDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/select/src/select-icon.directive.ts
```typescript
import { Directive } from '@angular/core';

@Directive({
    selector: '[rdxSelectIcon]',
    standalone: true,
    exportAs: 'rdxSelectIcon',
    host: {
        '[attr.aria-hidden]': 'true'
    }
})
export class RdxSelectIconDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/select/src/select-item-indicator.directive.ts
```typescript
import { Directive, inject } from '@angular/core';
import { RdxSelectItemDirective } from './select-item.directive';

@Directive({
    selector: '[rdxSelectItemIndicator]',
    standalone: true,
    exportAs: 'rdxSelectItemIndicator',
    host: {
        '[attr.aria-hidden]': 'true',
        '[style.display]': 'item.selected ? "" : "none"'
    }
})
export class RdxSelectItemIndicatorDirective {
    protected item = inject(RdxSelectItemDirective);
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/select/src/select-item.directive.ts
```typescript
import { Highlightable } from '@angular/cdk/a11y';
import { ENTER, SPACE } from '@angular/cdk/keycodes';
import { booleanAttribute, Directive, ElementRef, EventEmitter, inject, Input } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { RdxSelectContentDirective } from './select-content.directive';
import { RdxSelectComponent } from './select.component';

let nextId = 0;

export class RdxSelectItemChange<T = RdxSelectItemDirective> {
    constructor(public source: T) {}
}

@Directive({
    selector: '[rdxSelectItem]',
    standalone: true,
    exportAs: 'rdxSelectItem',
    host: {
        '[attr.role]': '"option"',
        '[attr.data-state]': 'dataState',
        '[attr.aria-selected]': 'selected',
        '[attr.data-disabled]': 'disabled || null',
        '[attr.data-highlighted]': 'highlighted || null',
        '[attr.tabindex]': '-1',
        '(focus)': 'content.highlighted.next(this)',
        '(click)': 'selectViaInteraction()',
        '(keydown)': 'handleKeydown($event)',
        '(pointermove)': 'onPointerMove()'
    }
})
export class RdxSelectItemDirective implements Highlightable {
    protected readonly select = inject(RdxSelectComponent);
    protected readonly content = inject(RdxSelectContentDirective);
    readonly onSelectionChange = new EventEmitter<RdxSelectItemChange>();
    protected readonly nativeElement = inject(ElementRef).nativeElement;

    highlighted: boolean = false;

    selected: boolean;

    get dataState(): string {
        return this.selected ? 'checked' : 'unchecked';
    }

    /**
     * The unique SelectItem id.
     * @ignore
     */
    readonly id: string = `rdx-select-item-${nextId++}`;

    @Input()
    set value(value: string) {
        this._value = value;
    }

    get value(): string {
        return this._value || this.id;
    }

    private _value?: string;

    @Input() textValue: string | null = null;

    /** Whether the SelectItem is disabled. */
    @Input({ transform: booleanAttribute })
    set disabled(value: boolean) {
        this._disabled = value;
    }

    get disabled(): boolean {
        return this._disabled;
    }

    private _disabled: boolean;

    get viewValue(): string {
        return this.textValue ?? this.nativeElement.textContent;
    }

    constructor() {
        this.content.highlighted.pipe(takeUntilDestroyed()).subscribe((value) => {
            if (value !== this) {
                this.highlighted = false;
            }
        });
    }

    /** Gets the label to be used when determining whether the option should be focused.
     * @ignore
     */
    getLabel(): string {
        return this.viewValue;
    }

    /**
     * `Selects the option while indicating the selection came from the user. Used to
     * determine if the select's view -> model callback should be invoked.`
     * @ignore
     */
    selectViaInteraction(): void {
        if (!this.disabled) {
            this.selected = true;

            this.onSelectionChange.emit(new RdxSelectItemChange(this));
        }
    }

    /** @ignore */
    handleKeydown(event: KeyboardEvent): void {
        if (event.keyCode === ENTER || event.keyCode === SPACE) {
            this.selectViaInteraction();

            // Prevent the page from scrolling down and form submits.
            event.preventDefault();
            event.stopPropagation();
        }
    }

    /** @ignore */
    setActiveStyles(): void {
        this.highlighted = true;
        this.nativeElement.focus({ preventScroll: true });
    }

    /** @ignore */
    setInactiveStyles(): void {
        this.highlighted = false;
    }

    protected onPointerMove(): void {
        if (!this.highlighted) {
            this.nativeElement.focus({ preventScroll: true });
            this.select.updateActiveItem(this);
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/select/src/select-label.directive.ts
```typescript
import { Directive } from '@angular/core';

@Directive({
    selector: '[rdxSelectLabel]',
    standalone: true,
    exportAs: 'rdxSelectLabel'
})
export class RdxSelectLabelDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/select/src/select-separator.directive.ts
```typescript
import { Directive } from '@angular/core';

@Directive({
    selector: '[rdxSelectSeparator]',
    standalone: true,
    exportAs: 'rdxSelectSeparator',
    host: {
        '[attr.aria-hidden]': 'true'
    }
})
export class RdxSelectSeparatorDirective {}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/select/src/select-trigger.directive.ts
```typescript
import { ContentChild, Directive, ElementRef, inject } from '@angular/core';
import { RdxSelectValueDirective } from './select-value.directive';
import { RdxSelectComponent } from './select.component';

@Directive({
    selector: '[rdxSelectTrigger]',
    standalone: true,
    host: {
        '[attr.type]': '"button"',
        '[attr.role]': '"combobox"',
        '[attr.aria-autocomplete]': '"none"',
        '[attr.dir]': 'select.dir.value',
        '[attr.aria-expanded]': 'select.open',
        '[attr.aria-required]': 'select.required',

        '[attr.disabled]': 'select.disabled ? "" : null',
        '[attr.data-disabled]': 'select.disabled ? "" : null',
        '[attr.data-state]': "select.open ? 'open': 'closed'",
        '[attr.data-placeholder]': 'value.placeholder || null'
    }
})
export class RdxSelectTriggerDirective {
    protected nativeElement = inject(ElementRef).nativeElement;
    protected select = inject(RdxSelectComponent);

    @ContentChild(RdxSelectValueDirective) protected value: RdxSelectValueDirective;

    focus() {
        this.nativeElement.focus();
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/select/src/select-value.directive.ts
```typescript
import { Component, inject, Input } from '@angular/core';
import { RdxSelectComponent } from './select.component';

@Component({
    selector: '[rdxSelectValue]',
    standalone: true,
    exportAs: 'rdxSelectValue',
    template: `
        {{ select.selectionModel.isEmpty() ? placeholder : select.selected }}
    `,
    styles: `
        /* we don't want events from the children to bubble through the item they came from */
        :host {
            pointer-events: none;
        }
    `
})
export class RdxSelectValueDirective {
    select = inject(RdxSelectComponent);

    @Input() placeholder: string;
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/select/src/select.component.ts
```typescript
import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';
import { Directionality } from '@angular/cdk/bidi';
import { SelectionModel } from '@angular/cdk/collections';
import { CdkConnectedOverlay, ConnectedPosition, Overlay, OverlayModule } from '@angular/cdk/overlay';
import {
    AfterContentInit,
    booleanAttribute,
    ChangeDetectorRef,
    Component,
    ContentChild,
    ContentChildren,
    DestroyRef,
    ElementRef,
    EventEmitter,
    forwardRef,
    inject,
    Input,
    NgZone,
    OnInit,
    Output,
    QueryList,
    ViewChild
} from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { defer, delay, merge, Observable, Subscription, switchMap, take } from 'rxjs';
import { RdxSelectContentDirective } from './select-content.directive';
import { RdxSelectItemChange, RdxSelectItemDirective } from './select-item.directive';
import { RdxSelectTriggerDirective } from './select-trigger.directive';

let nextId = 0;

@Component({
    selector: '[rdxSelect]',
    template: `
        <ng-content select="[rdxSelectTrigger]" />

        <ng-template
            [cdkConnectedOverlayOpen]="open"
            [cdkConnectedOverlayOrigin]="elementRef"
            [cdkConnectedOverlayPositions]="positions"
            [cdkConnectedOverlayScrollStrategy]="overlay.scrollStrategies.reposition()"
            (attach)="onAttached()"
            (backdropClick)="close()"
            (detach)="onDetach()"
            cdkConnectedOverlay
        >
            <ng-content select="[rdxSelectContent]" />
        </ng-template>
    `,
    host: {
        '(click)': 'toggle()',
        '(keydown)': 'content.keyManager.onKeydown($event)'
    },
    imports: [
        OverlayModule
    ]
})
export class RdxSelectComponent implements OnInit, AfterContentInit {
    protected overlay = inject(Overlay);
    protected elementRef = inject(ElementRef);
    protected changeDetectorRef = inject(ChangeDetectorRef);
    private readonly destroyRef = inject(DestroyRef);
    private readonly ngZone = inject(NgZone);

    @ContentChild(RdxSelectTriggerDirective) protected trigger: RdxSelectTriggerDirective;

    @ContentChild(forwardRef(() => RdxSelectContentDirective))
    protected content: RdxSelectContentDirective;

    @ContentChildren(forwardRef(() => RdxSelectItemDirective), { descendants: true })
    items: QueryList<RdxSelectItemDirective>;

    @ViewChild(CdkConnectedOverlay, { static: false }) overlayDir: CdkConnectedOverlay;

    /** Deals with the selection logic. */
    selectionModel: SelectionModel<RdxSelectItemDirective>;

    /**
     * This position config ensures that the top "start" corner of the overlay
     * is aligned with the top "start" of the origin by default (overlapping
     * the trigger completely). If the panel cannot fit below the trigger, it
     * will fall back to a position above the trigger.
     */
    positions: ConnectedPosition[] = [
        {
            originX: 'start',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'top'
        },
        {
            originX: 'start',
            originY: 'top',
            overlayX: 'start',
            overlayY: 'bottom'
        }
    ];

    private closeSubscription = Subscription.EMPTY;

    /**
     * @ignore
     */
    readonly dir = inject(Directionality, { optional: true });

    /**
     * @ignore
     */
    protected keyManager: ActiveDescendantKeyManager<RdxSelectItemDirective>;

    /**
     * @ignore
     */
    readonly id: string = `rdx-select-${nextId++}`;

    @Input() defaultValue: string;
    @Input() name: string;

    @Input({ transform: booleanAttribute }) defaultOpen: boolean;

    @Input({ transform: booleanAttribute }) open: boolean = false;

    /** Whether the Select is disabled. */
    @Input({ transform: booleanAttribute }) disabled: boolean;

    @Input({ transform: booleanAttribute }) required: boolean;

    /**
     * The controlled value of the item to expand
     */
    @Input()
    set value(value: string) {
        if (this._value !== value) {
            this._value = value;

            this.selectValue(value);

            this.changeDetectorRef.markForCheck();
        }
    }

    get value(): string | null {
        return this._value ?? this.defaultValue;
    }

    private _value?: string;

    @Output() readonly onValueChange: EventEmitter<string> = new EventEmitter<string>();

    @Output() readonly onOpenChange: EventEmitter<boolean> = new EventEmitter<boolean>();

    readonly optionSelectionChanges: Observable<RdxSelectItemChange> = defer(() => {
        if (this.content.options) {
            return merge(...this.content.options.map((option) => option.onSelectionChange));
        }

        return this.ngZone.onStable.asObservable().pipe(
            take(1),
            switchMap(() => this.optionSelectionChanges)
        );
    }) as Observable<RdxSelectItemChange>;

    get selected(): string | null {
        return this.selectionModel.selected[0].viewValue || null;
    }

    ngOnInit() {
        this.selectionModel = new SelectionModel<RdxSelectItemDirective>();

        this.selectionModel.changed.subscribe((changes) => {
            if (changes.added.length) {
                this.onValueChange.emit(this.selectionModel.selected[0].value);
            }

            if (changes.removed.length) {
                changes.removed.forEach((item) => (item.selected = false));
            }
        });
    }

    ngAfterContentInit() {
        this.selectDefaultValue();

        this.optionSelectionChanges.subscribe((event) => {
            this.selectionModel.clear();

            this.selectionModel.select(event.source);

            this.close();
            this.trigger.focus();
        });

        this.content.keyManager.tabOut.subscribe(() => {
            if (this.open) this.close();
        });

        if (this.defaultOpen) {
            this.openPanel();
        }
    }

    /**
     * Callback that is invoked when the overlay panel has been attached.
     */
    onAttached(): void {
        this.closeSubscription = this.closingActions()
            .pipe(takeUntilDestroyed(this.destroyRef))
            .pipe(delay(0))
            .subscribe(() => this.close());
    }

    onDetach() {
        this.close();
        this.closeSubscription.unsubscribe();
    }

    /** Toggles the overlay panel open or closed. */
    toggle(): void {
        if (this.open) {
            this.close();
        } else {
            this.openPanel();
        }
    }

    openPanel() {
        this.open = true;

        this.onOpenChange.emit(this.open);
    }

    close() {
        this.open = false;

        this.onOpenChange.emit(this.open);
    }

    updateActiveItem(item: RdxSelectItemDirective) {
        this.content.keyManager.updateActiveItem(item);
    }

    private selectDefaultValue(): void {
        if (!this.defaultValue) return;

        this.selectValue(this.defaultValue);
    }

    private selectValue(value: string): void {
        const option = this.content?.options.find((option) => option.value === value);

        if (option) {
            option.selected = true;
            option.highlighted = true;

            this.selectionModel.select(option);
            this.updateActiveItem(option);
        }
    }

    private closingActions() {
        return merge(this.overlayDir.overlayRef!.outsidePointerEvents(), this.overlayDir.overlayRef!.detachments());
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/schematics/collection.json
```json
{
    "$schema": "../node_modules/@angular-devkit/schematics/collection-schema.json",
    "schematics": {
        "ng-add": {
            "description": "Add RadixNG to the application.",
            "factory": "./ng-add/index#ngAdd",
            "aliases": ["install"]
        }
    }
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/schematics/ng-add/index.ts
```typescript
import { Rule, SchematicContext, SchematicsException, Tree } from '@angular-devkit/schematics';
import { NodePackageInstallTask } from '@angular-devkit/schematics/tasks';
import { addPackageJsonDependency, NodeDependency, NodeDependencyType } from '@schematics/angular/utility/dependencies';
import * as pkgJson from '../../package.json';
import { getPackageVersionFromPackageJson, PackageJson } from './package-config';

/**
 * This is executed when `ng add @radix-ng/primitives` is run.
 * It installs all dependencies in the 'package.json'.
 */
export function ngAdd(): Rule {
    return (tree: Tree, context: SchematicContext) => {
        const pkg = pkgJson as unknown as PackageJson;

        context.logger.info(``);
        context.logger.info(`Installing ${pkg.name} dependencies...`);

        const ngCoreVersionTag = getPackageVersionFromPackageJson(tree, '@angular/core');
        context.logger.info(`@angular/core version ${ngCoreVersionTag}`);

        if (!ngCoreVersionTag) {
            throw new SchematicsException('@angular/core version not found');
        }

        const projectDeps: NodeDependency[] = [
            {
                name: '@angular/animations',
                type: NodeDependencyType.Default,
                version: ngCoreVersionTag,
                overwrite: false
            },
            { name: '@angular/common', type: NodeDependencyType.Default, version: ngCoreVersionTag, overwrite: false },
            { name: '@angular/core', type: NodeDependencyType.Default, version: ngCoreVersionTag, overwrite: false }
        ];

        projectDeps.forEach((dep) => {
            addPackageJsonDependency(tree, dep);
            context.logger.info(`Added dependency: ${dep.name}@${dep.version}`);
        });

        const libraryDeps: NodeDependency[] = [
            {
                name: '@angular/cdk',
                type: NodeDependencyType.Default,
                version: pkg.peerDependencies['@angular/cdk'],
                overwrite: false
            }
        ];

        libraryDeps.forEach((dep) => {
            addPackageJsonDependency(tree, dep);
            context.logger.info(`Added dependency: ${dep.name}@${dep.version}`);
        });

        const library: NodeDependency = {
            name: pkg.name,
            type: NodeDependencyType.Default,
            version: `~${pkg.version}`,
            overwrite: true
        };

        addPackageJsonDependency(tree, library);
        context.logger.info(`Installing ${library.name}@${library.version}`);

        context.addTask(new NodePackageInstallTask());

        return tree;
    };
}

```
/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/schematics/ng-add/package-config.ts
```typescript
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

import { Tree } from '@angular-devkit/schematics';

export interface PackageJson {
    dependencies: Record<string, string>;
    name: string;
    peerDependencies: Record<string, string>;
    version: string;
}

/**
 * Sorts the keys of the given object.
 * @returns A new object instance with sorted keys
 */
function sortObjectByKeys(obj: Record<string, string>) {
    return Object.keys(obj)
        .sort()
        .reduce(
            (result, key) => {
                result[key] = obj[key];
                return result;
            },
            {} as Record<string, string>
        );
}

/** Adds a package to the package.json in the given host tree. */
export function addPackageToPackageJson(host: Tree, pkg: string, version: string): Tree {
    if (host.exists('package.json')) {
        const sourceText = host.read('package.json')!.toString('utf-8');
        const json = JSON.parse(sourceText) as PackageJson;

        if (!json.dependencies) {
            json.dependencies = {};
        }

        if (!json.dependencies[pkg]) {
            json.dependencies[pkg] = version;
            json.dependencies = sortObjectByKeys(json.dependencies);
        }

        host.overwrite('package.json', JSON.stringify(json, null, 2));
    }

    return host;
}

/** Gets the version of the specified package by looking at the package.json in the given tree. */
export function getPackageVersionFromPackageJson(tree: Tree, name: string): string | null {
    if (!tree.exists('package.json')) {
        return null;
    }

    const packageJson = JSON.parse(tree.read('package.json')!.toString('utf8')) as PackageJson;

    if (packageJson.dependencies && packageJson.dependencies[name]) {
        return packageJson.dependencies[name];
    }

    return null;
}

```
