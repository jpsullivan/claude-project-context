<documents>
<document index="1">
<source>/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/checkbox/README.md</source>
<document_content>
# @spartan-ng/brain/checkbox

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/checkbox`.

</document_content>
</document>
<document index="2">
<source>/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/checkbox/ng-package.json</source>
<document_content>
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

</document_content>
</document>
<document index="3">
<source>/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/checkbox/src/index.ts</source>
<document_content>
import { NgModule } from '@angular/core';

import { BrnCheckboxComponent } from './lib/brn-checkbox.component';

export * from './lib/brn-checkbox.component';

export const BrnCheckboxImports = [BrnCheckboxComponent] as const;

@NgModule({
	imports: [...BrnCheckboxImports],
	exports: [...BrnCheckboxImports],
})
export class BrnCheckboxModule {}

</document_content>
</document>
<document index="4">
<source>/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/checkbox/src/lib/brn-checkbox-ng-model.spec.ts</source>
<document_content>
import { render, screen } from '@testing-library/angular';
import userEvent from '@testing-library/user-event';

import { Component, input, model } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { BrnCheckboxComponent } from './brn-checkbox.component';

@Component({
	selector: 'brn-checkbox-ng-model',
	standalone: true,
	template: `
		<label>
			Airplane mode is: {{ airplaneMode() ? 'on' : 'off' }}
			<brn-checkbox [disabled]="disabled()" [(ngModel)]="airplaneMode"></brn-checkbox>
		</label>
	`,
	imports: [BrnCheckboxComponent, FormsModule],
})
export class BrnCheckboxNgModelSpecComponent {
	public readonly disabled = input(false);

	public readonly airplaneMode = model(false);
}

describe('BrnCheckboxComponentNgModelIntegration', () => {
	const setup = async (airplaneMode = false, disabled = false) => {
		const container = await render(BrnCheckboxNgModelSpecComponent, {
			componentInputs: {
				disabled,
				airplaneMode,
			},
		});
		const labelMatch = airplaneMode ? /airplane mode is: on/i : /airplane mode is: off/i;
		return {
			user: userEvent.setup(),
			container,
			checkboxElement: screen.getByLabelText(labelMatch),
			labelElement: screen.getByText(labelMatch),
		};
	};

	it('click should toggle value correctly', async () => {
		const { labelElement, user, container } = await setup();
		expect(labelElement).toBeInTheDocument();
		await user.click(labelElement);
		await screen.findByDisplayValue('on');
		expect(container.fixture.componentInstance.airplaneMode()).toBe(true);
	});

	it('should set input as default correctly and click should toggle then', async () => {
		const { labelElement, user, container } = await setup(true);

		await user.click(labelElement);
		await screen.findByDisplayValue('off');
		expect(container.fixture.componentInstance.airplaneMode()).toBe(false);

		await user.click(labelElement);
		await screen.findByDisplayValue('on');
		expect(container.fixture.componentInstance.airplaneMode()).toBe(true);
	});

	it('should set input as default correctly and enter should toggle then', async () => {
		const { user, container } = await setup(true);

		await user.keyboard('[Tab][Enter]');
		expect(container.fixture.componentInstance.airplaneMode()).toBe(false);

		await user.keyboard('[Enter]');
		expect(container.fixture.componentInstance.airplaneMode()).toBe(true);
	});

	it('should do nothing when disabled', async () => {
		const { labelElement, user, container } = await setup(false, true);

		await user.click(labelElement);
		await screen.findByDisplayValue('off');
		expect(container.fixture.componentInstance.airplaneMode()).toBe(false);

		await user.click(labelElement);
		await screen.findByDisplayValue('off');
		expect(container.fixture.componentInstance.airplaneMode()).toBe(false);
	});
});

</document_content>
</document>
<document index="5">
<source>/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/checkbox/src/lib/brn-checkbox.component.spec.ts</source>
<document_content>
import { render, screen } from '@testing-library/angular';
import userEvent from '@testing-library/user-event';
import { axe } from 'jest-axe';
import { BrnCheckboxComponent } from './brn-checkbox.component';

describe('BrnCheckboxComponent', () => {
	const setup = async () => {
		const container = await render(
			`
     <brn-checkbox id='checkboxId' name='checkboxName' data-testid='checkbox' aria-label='checkbox'>
      </brn-checkbox>
    `,
			{
				imports: [BrnCheckboxComponent],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			checkboxElement: screen.getByLabelText('checkbox'),
		};
	};

	const setupInsideLabel = async () => {
		const container = await render(
			`
     <label data-testid='label'>
     Checkbox Inside Label
     <brn-checkbox id='checkboxId' data-testid='checkbox' name='checkboxName'>
      </brn-checkbox>
      </label>
    `,
			{
				imports: [BrnCheckboxComponent],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			checkboxElement: screen.getByLabelText(/checkbox inside label/i),
			labelElement: screen.getByText(/checkbox inside label/i),
		};
	};
	const setupInsideLabelDisabled = async () => {
		const container = await render(
			`
     <label data-testid='label'>
     Checkbox Inside Label
     <brn-checkbox disabled id='checkboxId' data-testid='checkbox' name='checkboxName'>
      </brn-checkbox>
      </label>
    `,
			{
				imports: [BrnCheckboxComponent],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			checkboxElement: screen.getByLabelText(/checkbox inside label/i),
			labelElement: screen.getByText(/checkbox inside label/i),
		};
	};

	const setupOutsideLabelWithAriaLabelledBy = async () => {
		const container = await render(
			`
     <!-- need for because arialabelledby only provides accessible name -->
     <label id='labelId' for='checkboxId' data-testid='label'>
     Checkbox Outside Label with ariaLabelledBy
     </label>
     <brn-checkbox id='checkboxId' name='checkboxName' data-testid='checkbox' aria-labelledby='labelId'>
      </brn-checkbox>
    `,
			{
				imports: [BrnCheckboxComponent],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			checkboxElement: screen.getByLabelText(/checkbox outside label with arialabelledby/i),
			labelElement: screen.getByText(/checkbox outside label with arialabelledby/i),
		};
	};

	const setupOutsideLabelWithForAndId = async () => {
		const container = await render(
			`
     <label for='checkboxId' data-testid='label'>
     Checkbox Outside Label with id
     </label>
     <brn-checkbox id='checkboxId' name='checkboxName' data-testid='checkbox'>
      </brn-checkbox>
    `,
			{
				imports: [BrnCheckboxComponent],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			checkboxElement: screen.getByLabelText(/checkbox outside label with id/i),
			labelElement: screen.getByText(/checkbox outside label with id/i),
		};
	};
	const setupOutsideLabelWithForAndIdDisabled = async () => {
		const container = await render(
			`
     <label for='checkboxId' data-testid='label'>
     Checkbox Outside Label with id
     </label>
     <brn-checkbox disabled id='checkboxId' name='checkboxName' data-testid='checkbox'>
      </brn-checkbox>
    `,
			{
				imports: [BrnCheckboxComponent],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			checkboxElement: screen.getByLabelText(/checkbox outside label with id/i),
			labelElement: screen.getByText(/checkbox outside label with id/i),
		};
	};

	type Options = Partial<{ focus: boolean; focusVisible: boolean; disabled: boolean }>;

	const validateAttributes = async (
		inputElement: HTMLElement,
		checkboxElement: HTMLElement,
		shouldBeChecked: boolean,
		opts?: Options,
	) => {
		expect(inputElement).toBeInTheDocument();
		expect(inputElement).toHaveAttribute('role', 'checkbox');
		expect(inputElement).toHaveAttribute('id', 'checkboxId');
		expect(inputElement).toHaveAttribute('name', 'checkboxName');
		expect(await axe(inputElement)).toHaveNoViolations();

		expect(checkboxElement).toHaveAttribute('id', 'checkboxId-checkbox');
		expect(checkboxElement).toHaveAttribute('name', 'checkboxName-checkbox');
		expect(checkboxElement).toHaveAttribute('data-state', shouldBeChecked ? 'checked' : 'unchecked');
		expect(checkboxElement).toHaveAttribute('data-disabled', `${!!opts?.disabled}`);
		expect(checkboxElement).toHaveAttribute('data-focus', `${!!opts?.focus}`);
		expect(checkboxElement).toHaveAttribute('data-focus-visible', `${!!opts?.focusVisible}`);
		expect(await axe(checkboxElement)).toHaveNoViolations();
	};
	const validateCheckboxOn = async (opts?: Options) => {
		const inputElement = await screen.findByDisplayValue('on');
		const checkboxElement = await screen.findByTestId('checkbox');

		await validateAttributes(inputElement, checkboxElement, true, opts);
	};
	const validateCheckboxOff = async (opts?: Options) => {
		const inputElement = await screen.findByDisplayValue('off');
		const checkboxElement = await screen.findByTestId('checkbox');

		await validateAttributes(inputElement, checkboxElement, false, opts);
	};

	describe('with aria-label', () => {
		it('unchecked by default', async () => {
			await setup();
			await validateCheckboxOff();
		});
		it('mouse click on element toggles', async () => {
			const { user, checkboxElement } = await setup();
			await validateCheckboxOff();
			await user.click(checkboxElement);
			await validateCheckboxOn({ focus: true });
			await user.click(checkboxElement);
			await validateCheckboxOff({ focus: true });
		});
		it('focus with tab and enter toggles', async () => {
			const { user } = await setup();
			const options = { focus: true, focusVisible: true };
			await validateCheckboxOff();
			await user.keyboard('[Tab][Enter]');
			await validateCheckboxOn(options);
			await user.keyboard('[Enter]');
			await validateCheckboxOff(options);
			await user.keyboard('[Enter]');
			await validateCheckboxOn(options);
		});
		it('focus with tab and space toggles', async () => {
			const { user } = await setup();
			const options = { focus: true, focusVisible: true };
			await validateCheckboxOff();
			await user.keyboard('[Tab][Space]');
			await validateCheckboxOn(options);
			await user.keyboard('[Space]');
			await validateCheckboxOff(options);
			await user.keyboard('[Space]');
			await validateCheckboxOn(options);
		});
	});

	describe('inside <label>', () => {
		it('unchecked by default', async () => {
			await setupInsideLabel();
			await validateCheckboxOff();
		});
		it('mouse click on element toggles', async () => {
			const { user, labelElement } = await setupInsideLabel();
			await validateCheckboxOff();
			await user.click(labelElement);
			await validateCheckboxOn({ focus: true });
			await user.click(labelElement);
			await validateCheckboxOff({ focus: true });
		});
		it('focus with tab and enter toggles', async () => {
			const { user } = await setupInsideLabel();
			const options = { focus: true, focusVisible: true };
			await validateCheckboxOff();
			await user.keyboard('[Tab][Enter]');
			await validateCheckboxOn(options);
			await user.keyboard('[Enter]');
			await validateCheckboxOff(options);
			await user.keyboard('[Enter]');
			await validateCheckboxOn(options);
		});
		it('focus with tab and space toggles', async () => {
			const { user } = await setupInsideLabel();
			const options = { focus: true, focusVisible: true };
			await validateCheckboxOff();
			await user.keyboard('[Tab][Space]');
			await validateCheckboxOn(options);
			await user.keyboard('[Space]');
			await validateCheckboxOff(options);
			await user.keyboard('[Space]');
			await validateCheckboxOn(options);
		});
		it('disabled', async () => {
			const { user } = await setupInsideLabelDisabled();
			// await validateCheckboxOff({ focus: false, focusVisible: false, disabled: true });
			const options = { focus: false, focusVisible: false, disabled: true };
			await user.keyboard('[Tab][Space]');
			await validateCheckboxOff(options);
			await user.keyboard('[Space]');
			await validateCheckboxOff(options);
			await user.keyboard('[Space]');
			await validateCheckboxOff(options);
			const label = await screen.findByTestId('label');
			expect(label).toHaveAttribute('data-disabled', 'true');
		});
	});

	describe('outside <label> with aria-labelledby', () => {
		it('unchecked by default', async () => {
			await setupOutsideLabelWithAriaLabelledBy();
			await validateCheckboxOff();
		});
		it('mouse click on element toggles', async () => {
			const { user, labelElement } = await setupOutsideLabelWithAriaLabelledBy();
			await validateCheckboxOff();
			await user.click(labelElement);
			await validateCheckboxOn({ focus: true });
			await user.click(labelElement);
			await validateCheckboxOff({ focus: true });
		});
		it('focus with tab and enter toggles', async () => {
			const { user } = await setupOutsideLabelWithAriaLabelledBy();
			const options = { focus: true, focusVisible: true };
			await validateCheckboxOff();
			await user.keyboard('[Tab][Enter]');
			await validateCheckboxOn(options);
			await user.keyboard('[Enter]');
			await validateCheckboxOff(options);
			await user.keyboard('[Enter]');
			await validateCheckboxOn(options);
		});
		it('focus with tab and space toggles', async () => {
			const { user } = await setupOutsideLabelWithAriaLabelledBy();
			const options = { focus: true, focusVisible: true };
			await validateCheckboxOff();
			await user.keyboard('[Tab][Space]');
			await validateCheckboxOn(options);
			await user.keyboard('[Space]');
			await validateCheckboxOff(options);
			await user.keyboard('[Space]');
			await validateCheckboxOn(options);
		});
	});

	describe('outside <label> with for and id', () => {
		it('unchecked by default', async () => {
			await setupOutsideLabelWithForAndId();
			await validateCheckboxOff();
		});
		it('mouse click on element toggles', async () => {
			const { user, labelElement } = await setupOutsideLabelWithForAndId();
			await validateCheckboxOff();
			await user.click(labelElement);
			await validateCheckboxOn({ focus: true });
			await user.click(labelElement);
			await validateCheckboxOff({ focus: true });
		});
		it('focus with tab and enter toggles', async () => {
			const { user } = await setupOutsideLabelWithForAndId();
			const options = { focus: true, focusVisible: true };
			await validateCheckboxOff();
			await user.keyboard('[Tab][Enter]');
			await validateCheckboxOn(options);
			await user.keyboard('[Enter]');
			await validateCheckboxOff(options);
			await user.keyboard('[Enter]');
			await validateCheckboxOn(options);
		});
		it('focus with tab and space toggles', async () => {
			const { user } = await setupOutsideLabelWithForAndId();
			const options = { focus: true, focusVisible: true };
			await validateCheckboxOff();
			await user.keyboard('[Tab][Space]');
			await validateCheckboxOn(options);
			await user.keyboard('[Space]');
			await validateCheckboxOff(options);
			await user.keyboard('[Space]');
			await validateCheckboxOn(options);
			const label = await screen.findByTestId('label');
			expect(label).toHaveAttribute('data-disabled', 'false');
		});
		it('sets data-disabled to the label toggles do not change anything', async () => {
			const { user } = await setupOutsideLabelWithForAndIdDisabled();
			const options = { focus: false, focusVisible: false, disabled: true };
			await validateCheckboxOff(options);
			await user.keyboard('[Tab][Space]');
			await validateCheckboxOff(options);
			await user.keyboard('[Space]');
			await validateCheckboxOff(options);
			await user.keyboard('[Space]');
			await validateCheckboxOff(options);
			const label = await screen.findByTestId('label');
			expect(label).toHaveAttribute('data-disabled', 'true');
		});
	});
});

</document_content>
</document>
<document index="6">
<source>/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/checkbox/src/lib/brn-checkbox.component.ts</source>
<document_content>
import { FocusMonitor } from '@angular/cdk/a11y';
import { NgStyle, isPlatformBrowser } from '@angular/common';
import {
	type AfterContentInit,
	ChangeDetectionStrategy,
	Component,
	ElementRef,
	HostListener,
	type OnDestroy,
	PLATFORM_ID,
	Renderer2,
	ViewEncapsulation,
	booleanAttribute,
	computed,
	effect,
	forwardRef,
	inject,
	input,
	model,
	output,
	signal,
	viewChild,
} from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { ChangeFn, TouchFn } from '@spartan-ng/brain/forms';

export const BRN_CHECKBOX_VALUE_ACCESSOR = {
	provide: NG_VALUE_ACCESSOR,
	useExisting: forwardRef(() => BrnCheckboxComponent),
	multi: true,
};

export function indeterminateBooleanAttribute(value: unknown): boolean | 'indeterminate' {
	if (value === 'indeterminate') return 'indeterminate';
	return booleanAttribute(value);
}

const CONTAINER_POST_FIX = '-checkbox';

@Component({
	selector: 'brn-checkbox',
	imports: [NgStyle],
	template: `
		<input
			#checkBox
			tabindex="-1"
			type="checkbox"
			role="checkbox"
			[ngStyle]="{
				position: 'absolute',
				width: '1px',
				height: '1px',
				padding: '0',
				margin: '-1px',
				overflow: 'hidden',
				clip: 'rect(0, 0, 0, 0)',
				whiteSpace: 'nowrap',
				borderWidth: '0',
			}"
			[id]="id() ?? ''"
			[name]="name() ?? ''"
			[value]="_value()"
			[checked]="isChecked()"
			[required]="required()"
			[attr.aria-label]="ariaLabel()"
			[attr.aria-labelledby]="ariaLabelledby()"
			[attr.aria-describedby]="ariaDescribedby()"
			[attr.aria-required]="required() || null"
			[attr.aria-checked]="_ariaChecked()"
		/>
		<ng-content />
	`,
	host: {
		'[attr.tabindex]': 'state().disabled() ? "-1" : "0"',
		'[attr.data-state]': '_dataState()',
		'[attr.data-focus-visible]': 'focusVisible()',
		'[attr.data-focus]': 'focused()',
		'[attr.data-disabled]': 'state().disabled()',
		'[attr.aria-labelledby]': 'null',
		'[attr.aria-label]': 'null',
		'[attr.aria-describedby]': 'null',
		'[attr.id]': 'hostId()',
		'[attr.name]': 'hostName()',
	},
	providers: [BRN_CHECKBOX_VALUE_ACCESSOR],
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class BrnCheckboxComponent implements AfterContentInit, OnDestroy {
	private readonly _renderer = inject(Renderer2);
	private readonly _elementRef = inject(ElementRef);
	private readonly _focusMonitor = inject(FocusMonitor);
	private readonly _isBrowser = isPlatformBrowser(inject(PLATFORM_ID));

	private readonly _focusVisible = signal(false);
	public readonly focusVisible = this._focusVisible.asReadonly();
	private readonly _focused = signal(false);
	public readonly focused = this._focused.asReadonly();

	public readonly checked = model<BrnCheckboxValue>(false);
	public readonly isChecked = this.checked.asReadonly();

	protected readonly _dataState = computed(() => {
		const checked = this.checked();
		if (checked === 'indeterminate') return 'indeterminate';
		return checked ? 'checked' : 'unchecked';
	});
	protected readonly _ariaChecked = computed(() => {
		const checked = this.checked();
		if (checked === 'indeterminate') return 'mixed';
		return checked ? 'true' : 'false';
	});
	protected readonly _value = computed(() => {
		const checked = this.checked();
		if (checked === 'indeterminate') return '';
		return checked ? 'on' : 'off';
	});

	/** Used to set the id on the underlying input element. */
	public readonly id = input<string | null>(null);
	protected readonly hostId = computed(() => (this.id() ? this.id() + CONTAINER_POST_FIX : null));

	/** Used to set the name attribute on the underlying input element. */
	public readonly name = input<string | null>(null);
	protected readonly hostName = computed(() => (this.name() ? this.name() + CONTAINER_POST_FIX : null));

	/** Used to set the aria-label attribute on the underlying input element. */
	public readonly ariaLabel = input<string | null>(null, { alias: 'aria-label' });

	/** Used to set the aria-labelledby attribute on the underlying input element. */
	public readonly ariaLabelledby = input<string | null>(null, { alias: 'aria-labelledby' });

	public readonly ariaDescribedby = input<string | null>(null, { alias: 'aria-describedby' });

	public readonly required = input(false, { transform: booleanAttribute });

	public readonly disabled = input(false, { transform: booleanAttribute });

	protected readonly state = computed(() => ({
		disabled: signal(this.disabled()),
	}));

	// eslint-disable-next-line @typescript-eslint/no-empty-function
	protected _onChange: ChangeFn<BrnCheckboxValue> = () => {};
	// eslint-disable-next-line @typescript-eslint/no-empty-function
	private _onTouched: TouchFn = () => {};

	public readonly checkbox = viewChild.required<ElementRef<HTMLInputElement>>('checkBox');

	public readonly changed = output<BrnCheckboxValue>();

	constructor() {
		effect(() => {
			const parent = this._renderer.parentNode(this._elementRef.nativeElement);
			if (!parent) return;
			// check if parent is a label and assume it is for this checkbox
			if (parent?.tagName === 'LABEL') {
				this._renderer.setAttribute(parent, 'data-disabled', this.state().disabled() ? 'true' : 'false');
				return;
			}
			if (!this._isBrowser) return;

			const label = parent?.querySelector(`label[for="${this.id()}"]`);
			if (!label) return;
			this._renderer.setAttribute(label, 'data-disabled', this.state().disabled() ? 'true' : 'false');
		});
	}

	@HostListener('click', ['$event'])
	@HostListener('keyup.space', ['$event'])
	@HostListener('keyup.enter', ['$event'])
	toggle(event: Event) {
		if (this.state().disabled()) return;
		event.preventDefault();
		const previousChecked = this.checked();
		this.checked.set(previousChecked === 'indeterminate' ? true : !previousChecked);
		this._onChange(!previousChecked);
		this.changed.emit(!previousChecked);
	}

	ngAfterContentInit() {
		this._focusMonitor.monitor(this._elementRef, true).subscribe((focusOrigin) => {
			if (focusOrigin) this._focused.set(true);
			if (focusOrigin === 'keyboard' || focusOrigin === 'program') {
				this._focusVisible.set(true);
			}
			if (!focusOrigin) {
				// When a focused element becomes disabled, the browser *immediately* fires a blur event.
				// Angular does not expect events to be raised during change detection, so any state
				// change (such as a form control's ng-touched) will cause a changed-after-checked error.
				// See https://github.com/angular/angular/issues/17793. To work around this, we defer
				// telling the form control it has been touched until the next tick.
				Promise.resolve().then(() => {
					this._focusVisible.set(false);
					this._focused.set(false);
					this._onTouched();
				});
			}
		});

		this.checkbox().nativeElement.indeterminate = this.checked() === 'indeterminate';
		if (this.checkbox().nativeElement.indeterminate) {
			this.checkbox().nativeElement.value = 'indeterminate';
		} else {
			this.checkbox().nativeElement.value = this.checked() ? 'on' : 'off';
		}
		this.checkbox().nativeElement.dispatchEvent(new Event('change'));
	}

	ngOnDestroy() {
		this._focusMonitor.stopMonitoring(this._elementRef);
	}

	writeValue(value: BrnCheckboxValue): void {
		if (value === 'indeterminate') {
			this.checked.set('indeterminate');
		} else {
			this.checked.set(!!value);
		}
	}

	registerOnChange(fn: ChangeFn<BrnCheckboxValue>): void {
		this._onChange = fn;
	}

	registerOnTouched(fn: TouchFn): void {
		this._onTouched = fn;
	}

	/** Implemented as a part of ControlValueAccessor. */
	setDisabledState(isDisabled: boolean): void {
		this.state().disabled.set(isDisabled);
	}

	/**
	 * If the space key is pressed, prevent the default action to stop the page from scrolling.
	 */
	@HostListener('keydown.space', ['$event'])
	protected preventScrolling(event: KeyboardEvent): void {
		event.preventDefault();
	}
}

type BrnCheckboxValue = boolean | 'indeterminate';

</document_content>
</document>
</documents>
