<documents>
<document index="1">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/README.md</source>
<document_content>
# @radix-ng/primitives/calendar

</document_content>
</document>
<document index="2">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/index.ts</source>
<document_content>
import { NgModule } from '@angular/core';

export { RdxCalendarCellTriggerDirective } from './src/calendar-cell-trigger.directive';
export { RdxCalendarCellDirective } from './src/calendar-cell.directive';
export { RdxCalendarGridBodyDirective } from './src/calendar-grid-body.directive';
export { RdxCalendarGridHeadDirective } from './src/calendar-grid-head.directive';
export { RdxCalendarGridRowDirective } from './src/calendar-grid-row.directive';
export { RdxCalendarGridDirective } from './src/calendar-grid.directive';
export { RdxCalendarHeadCellDirective } from './src/calendar-head-cell.directive';
export { RdxCalendarHeaderDirective } from './src/calendar-header.directive';
export { RdxCalendarHeadingDirective } from './src/calendar-heading.directive';
export { RdxCalendarNextDirective } from './src/calendar-next.directive';
export { RdxCalendarPrevDirective } from './src/calendar-prev.directive';
export { RdxCalendarRootDirective } from './src/calendar-root.directive';

import { RdxCalendarCellTriggerDirective } from './src/calendar-cell-trigger.directive';
import { RdxCalendarCellDirective } from './src/calendar-cell.directive';
import { RdxCalendarGridBodyDirective } from './src/calendar-grid-body.directive';
import { RdxCalendarGridHeadDirective } from './src/calendar-grid-head.directive';
import { RdxCalendarGridRowDirective } from './src/calendar-grid-row.directive';
import { RdxCalendarGridDirective } from './src/calendar-grid.directive';
import { RdxCalendarHeadCellDirective } from './src/calendar-head-cell.directive';
import { RdxCalendarHeaderDirective } from './src/calendar-header.directive';
import { RdxCalendarHeadingDirective } from './src/calendar-heading.directive';
import { RdxCalendarNextDirective } from './src/calendar-next.directive';
import { RdxCalendarPrevDirective } from './src/calendar-prev.directive';
import { RdxCalendarRootDirective } from './src/calendar-root.directive';

const _imports = [
    RdxCalendarCellTriggerDirective,
    RdxCalendarCellDirective,
    RdxCalendarGridBodyDirective,
    RdxCalendarGridHeadDirective,
    RdxCalendarGridRowDirective,
    RdxCalendarGridDirective,
    RdxCalendarHeadCellDirective,
    RdxCalendarHeaderDirective,
    RdxCalendarPrevDirective,
    RdxCalendarRootDirective,
    RdxCalendarHeadingDirective,
    RdxCalendarNextDirective
];

@NgModule({
    imports: [..._imports],
    exports: [..._imports]
})
export class RdxCalendarModule {}

</document_content>
</document>
<document index="3">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/ng-package.json</source>
<document_content>
{
    "lib": {
        "entryFile": "index.ts"
    }
}

</document_content>
</document>
<document index="4">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/stories/calendar-default.component.ts</source>
<document_content>
import { Component } from '@angular/core';
import { CalendarDate, DateValue } from '@internationalized/date';
import { ChevronLeft, ChevronRight, LucideAngularModule } from 'lucide-angular';
import { RdxCalendarCellTriggerDirective } from '../src/calendar-cell-trigger.directive';
import { RdxCalendarCellDirective } from '../src/calendar-cell.directive';
import { RdxCalendarGridHeadDirective } from '../src/calendar-grid-head.directive';
import { RdxCalendarGridDirective } from '../src/calendar-grid.directive';
import { RdxCalendarHeadCellDirective } from '../src/calendar-head-cell.directive';
import { RdxCalendarHeaderDirective } from '../src/calendar-header.directive';
import { RdxCalendarHeadingDirective } from '../src/calendar-heading.directive';
import { RdxCalendarNextDirective } from '../src/calendar-next.directive';
import { RdxCalendarPrevDirective } from '../src/calendar-prev.directive';
import { RdxCalendarRootDirective } from '../src/calendar-root.directive';

@Component({
    selector: 'app-calendar-default',
    imports: [
        RdxCalendarRootDirective,
        RdxCalendarHeaderDirective,
        RdxCalendarGridDirective,
        RdxCalendarGridHeadDirective,
        RdxCalendarCellTriggerDirective,
        RdxCalendarCellDirective,
        RdxCalendarHeadingDirective,
        RdxCalendarNextDirective,
        RdxCalendarPrevDirective,
        LucideAngularModule,
        RdxCalendarHeadCellDirective
    ],
    styleUrl: 'calendar-default.style.css',
    template: `
        <div class="wrapper">
            <div
                class="calendar-root"
                #root="rdxCalendarRoot"
                [value]="date"
                data-testid="calendar"
                rdxCalendarRoot
                fixedWeeks
            >
                <div class="calendar-header" rdxCalendarHeader>
                    <button class="icon-button" type="button" rdxCalendarPrev>
                        <lucide-angular [img]="ChevronLeft" size="16" style="display: flex;" />
                    </button>
                    <div class="calendar-heading" #head="rdxCalendarHeading" data-testid="heading" rdxCalendarHeading>
                        {{ head.headingValue() }}
                    </div>
                    <button class="icon-button" type="button" data-testid="next-button" rdxCalendarNext>
                        <lucide-angular [img]="ChevronRight" size="16" style="display: flex;" />
                    </button>
                </div>

                <div class="calendar-container">
                    <table class="calendar-grid" rdxCalendarGrid>
                        @for (month of root.months(); track $index) {
                            <thead rdxCalendarGridHead>
                                <tr class="calendar-grid-head-row">
                                    @for (day of root.weekDays(); track $index) {
                                        <th class="calendar-head-cell" rdxCalendarHeadCell>{{ day }}</th>
                                    }
                                </tr>
                            </thead>
                            <tbody class="calendar-grid-body" rdxCalendarGridBody>
                                @for (weekDates of month.weeks; track $index) {
                                    <tr class="calendar-week-row">
                                        @for (weekDate of weekDates; track $index) {
                                            <td class="calendar-cell-wrapper" [date]="weekDate" rdxCalendarCell>
                                                <div
                                                    class="calendar-day"
                                                    #cell="rdxCalendarCellTrigger"
                                                    [day]="weekDate"
                                                    [month]="month.value"
                                                    rdxCalendarCellTrigger
                                                >
                                                    {{ cell.dayValue() }}
                                                </div>
                                            </td>
                                        }
                                    </tr>
                                }
                            </tbody>
                        }
                    </table>
                </div>
            </div>
        </div>
    `
})
export class CalendarDefaultComponent {
    date: DateValue = new CalendarDate(2024, 10, 3);

    protected readonly ChevronLeft = ChevronLeft;
    protected readonly ChevronRight = ChevronRight;
}

</document_content>
</document>
<document index="5">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/stories/calendar-default.style.css</source>
<document_content>
/* calendar-default.style.css */

/* Общие обёртки */
.wrapper {
    max-width: 680px;
    width: 300px;
}

.calendar-root {
    margin-top: 1.5rem;
    border-radius: 0.75rem;
    background-color: #ffffff;
    padding: 1rem;
    box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    border: 1px solid #e5e7eb;
}

/* Заголовок календаря */
.calendar-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.calendar-heading {
    font-size: 0.875rem;
    color: #000000;
    font-weight: 500;
}

/* Кнопки навигации */
button {
    all: unset;
}

.icon-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: #000000;
    background-color: transparent;
    border-radius: 0.375rem;
    width: 1.75rem;
    height: 1.75rem;
}

.icon-button:hover {
    background-color: #f5f5f4;
}

.icon-button:active {
    transform: scale(0.98);
    transition: all 0.1s ease;
}

.icon-button:focus {
    box-shadow: 0 0 0 2px black;
}

/* Контейнер таблицы */
.calendar-container {
    display: flex;
    flex-direction: column;
    padding-top: 1rem;
}

/* Сетка календаря */
.calendar-grid {
    width: 100%;
    border-collapse: collapse;
    user-select: none;
}

/* Заголовок дней недели */
.calendar-grid-head-row {
    display: grid;
    width: 100%;
    grid-template-columns: repeat(7, minmax(0, 1fr));
    margin-bottom: 0.25rem;
}

.calendar-head-cell {
    border-radius: 0.375rem;
    font-size: 0.75rem;
    color: #30a46c;
    text-align: center;
}

/* Тело календаря */
.calendar-grid-body {
    display: grid;
}

.calendar-week-row {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
}

.calendar-cell-wrapper {
    position: relative;
    text-align: center;
    font-size: 0.8rem;
}

/* Клетки дней */
.calendar-day {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 2rem;
    height: 2rem;
    border-radius: 9999px;
    white-space: nowrap;
    font-size: 0.875rem;
    font-weight: 400;
    color: black;
    outline: none;
    cursor: pointer;
}

.calendar-day:focus {
    box-shadow: 0 0 0 2px black;
}

.calendar-day:hover {
    background-color: #c3e8d1;
}

.calendar-day[data-selected] {
    background-color: #30a46c !important;
    color: white;
}

.calendar-day[data-outside-view],
.calendar-day[data-unavailable] {
    color: rgba(0, 0, 0, 0.3);
}

.calendar-day[data-unavailable] {
    pointer-events: none;
    text-decoration: line-through;
}

.calendar-day::before {
    content: '';
    position: absolute;
    top: 5px;
    width: 0.25rem;
    height: 0.25rem;
    border-radius: 9999px;
    background-color: white;
    display: none;
}

.calendar-day[data-today]::before {
    display: block;
    background-color: #298459;
}

.calendar-day[data-highlighted] {
    background-color: #c3e8d1;
}

</document_content>
</document>
<document index="6">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/stories/calendar-with-locale.component.ts</source>
<document_content>
import { Component, computed, signal } from '@angular/core';
import { createCalendar, getLocalTimeZone, toCalendar, today } from '@internationalized/date';
import { ChevronLeft, ChevronRight, LucideAngularModule } from 'lucide-angular';
import { RdxCalendarCellTriggerDirective } from '../src/calendar-cell-trigger.directive';
import { RdxCalendarGridHeadDirective } from '../src/calendar-grid-head.directive';
import { RdxCalendarGridDirective } from '../src/calendar-grid.directive';
import { RdxCalendarHeaderDirective } from '../src/calendar-header.directive';
import { RdxCalendarHeadingDirective } from '../src/calendar-heading.directive';
import { RdxCalendarNextDirective } from '../src/calendar-next.directive';
import { RdxCalendarPrevDirective } from '../src/calendar-prev.directive';
import { RdxCalendarRootDirective } from '../src/calendar-root.directive';

@Component({
    selector: 'app-calendar-with-locale',
    imports: [
        RdxCalendarRootDirective,
        RdxCalendarHeaderDirective,
        RdxCalendarGridDirective,
        RdxCalendarGridHeadDirective,
        RdxCalendarCellTriggerDirective,
        RdxCalendarHeadingDirective,
        RdxCalendarNextDirective,
        RdxCalendarPrevDirective,
        LucideAngularModule
    ],
    styleUrl: 'calendar-default.style.css',
    template: `
        <div class="wrapper" style="display: flex; flex-direction: column; gap: 1rem;">
            <label style="color: white;">Locale</label>
            <select [value]="locale()" (change)="updateLocale($event)">
                @for (option of preferences; track $index) {
                    <option [value]="option.locale">{{ option.label }}</option>
                }
            </select>

            <label style="color: white;">Calendar</label>
            <select [value]="calendar()">
                @for (option of preferredCalendars(); track $index) {
                    <option [value]="option!.key">{{ option!.name }}</option>
                }
            </select>

            <div
                class="calendar-root"
                #root="rdxCalendarRoot"
                [value]="value()"
                [locale]="locale()"
                rdxCalendarRoot
                fixedWeeks
            >
                <div class="calendar-header" rdxCalendarHeader>
                    <button class="icon-button" type="button" rdxCalendarPrev>
                        <lucide-angular [img]="ChevronLeft" size="16" style="display: flex;" />
                    </button>
                    <div class="calendar-heading" #head="rdxCalendarHeading" rdxCalendarHeading>
                        {{ head.headingValue() }}
                    </div>
                    <button class="icon-button" type="button" rdxCalendarNext>
                        <lucide-angular [img]="ChevronRight" size="16" style="display: flex;" />
                    </button>
                </div>

                <div class="calendar-container">
                    <table class="calendar-grid" rdxCalendarGrid>
                        @for (month of root.months(); track $index) {
                            <thead rdxCalendarGridHead>
                                <tr class="calendar-grid-head-row">
                                    @for (day of root.weekDays(); track $index) {
                                        <th class="calendar-head-cell">{{ day }}</th>
                                    }
                                </tr>
                            </thead>
                            <tbody class="calendar-grid-body" rdxCalendarGridBody>
                                @for (weekDates of month.weeks; track $index) {
                                    <tr class="calendar-week-row">
                                        @for (weekDate of weekDates; track $index) {
                                            <td class="calendar-cell-wrapper">
                                                <div
                                                    class="calendar-day"
                                                    #cell="rdxCalendarCellTrigger"
                                                    [day]="weekDate"
                                                    [month]="month.value"
                                                    rdxCalendarCellTrigger
                                                >
                                                    {{ cell.dayValue() }}
                                                </div>
                                            </td>
                                        }
                                    </tr>
                                }
                            </tbody>
                        }
                    </table>
                </div>
            </div>
        </div>
    `
})
export class CalendarWithLocaleComponent {
    readonly preferences = [
        { locale: 'en-US', label: 'Default', ordering: 'gregory' },
        {
            label: 'Arabic (Algeria)',
            locale: 'ar-DZ',
            territories: 'DJ DZ EH ER IQ JO KM LB LY MA MR OM PS SD SY TD TN YE',
            ordering: 'gregory islamic islamic-civil islamic-tbla'
        },
        {
            label: 'Arabic (United Arab Emirates)',
            locale: 'ar-AE',
            territories: 'AE BH KW QA',
            ordering: 'gregory islamic-umalqura islamic islamic-civil islamic-tbla'
        },
        {
            label: 'Arabic (Egypt)',
            locale: 'AR-EG',
            territories: 'EG',
            ordering: 'gregory coptic islamic islamic-civil islamic-tbla'
        },
        {
            label: 'Arabic (Saudi Arabia)',
            locale: 'ar-SA',
            territories: 'SA',
            ordering: 'islamic-umalqura gregory islamic islamic-rgsa'
        },
        {
            label: 'Farsi (Iran)',
            locale: 'fa-IR',
            territories: 'IR',
            ordering: 'persian gregory islamic islamic-civil islamic-tbla'
        },
        {
            label: 'Farsi (Afghanistan)',
            locale: 'fa-AF',
            territories: 'AF IR',
            ordering: 'persian gregory islamic islamic-civil islamic-tbla'
        },
        { label: 'Amharic (Ethiopia)', locale: 'am-ET', territories: 'ET', ordering: 'gregory ethiopic ethioaa' },
        {
            label: 'Hebrew (Israel)',
            locale: 'he-IL',
            territories: 'IL',
            ordering: 'gregory hebrew islamic islamic-civil islamic-tbla'
        },
        { label: 'Hindi (India)', locale: 'hi-IN', territories: 'IN', ordering: 'gregory indian' },
        { label: 'Japanese (Japan)', locale: 'ja-JP', territories: 'JP', ordering: 'gregory japanese' },
        { label: 'Thai (Thailand)', locale: 'th-TH', territories: 'TH', ordering: 'buddhist gregory' },
        { label: 'Chinese (Taiwan)', locale: 'zh-TW', territories: 'TW', ordering: 'gregory roc chinese' }
    ];

    readonly calendars = [
        { key: 'gregory', name: 'Gregorian' },
        { key: 'japanese', name: 'Japanese' },
        { key: 'buddhist', name: 'Buddhist' },
        { key: 'roc', name: 'Taiwan' },
        { key: 'persian', name: 'Persian' },
        { key: 'indian', name: 'Indian' },
        { key: 'islamic-umalqura', name: 'Islamic (Umm al-Qura)' },
        { key: 'islamic-civil', name: 'Islamic Civil' },
        { key: 'islamic-tbla', name: 'Islamic Tabular' },
        { key: 'hebrew', name: 'Hebrew' },
        { key: 'coptic', name: 'Coptic' },
        { key: 'ethiopic', name: 'Ethiopic' },
        { key: 'ethioaa', name: 'Ethiopic (Amete Alem)' }
    ];

    readonly locale = signal(this.preferences[0].locale);
    readonly calendar = signal(this.calendars[0].key);

    readonly pref = computed(() => this.preferences.find((p) => p.locale === this.locale()));

    readonly preferredCalendars = computed(() => {
        const currentPref = this.pref();
        return currentPref
            ? currentPref.ordering
                  .split(' ')
                  .map((p) => this.calendars.find((c) => c.key === p))
                  .filter(Boolean)
            : [this.calendars[0]];
    });

    readonly otherCalendars = computed(() =>
        this.calendars.filter((c) => !this.preferredCalendars().some((p) => p!.key === c.key))
    );

    readonly value = computed(() => toCalendar(today(getLocalTimeZone()), createCalendar(this.calendar())));

    updateLocale(event: Event) {
        const newLocale = (event.target as HTMLSelectElement).value;

        this.locale.set(newLocale);
        this.calendar.set(this.pref()!.ordering.split(' ')[0]);
    }

    protected readonly ChevronLeft = ChevronLeft;
    protected readonly ChevronRight = ChevronRight;
}

</document_content>
</document>
<document index="7">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/stories/calendar.docs.mdx</source>
<document_content>
import { ArgTypes, Canvas, Markdown, Meta } from "@storybook/blocks";
import * as Stories from './calendar.stories';
import { RdxCalendarRootDirective } from "../src/calendar-root.directive";
import {RdxCalendarPrevDirective} from "../src/calendar-prev.directive";
import {RdxCalendarNextDirective} from "../src/calendar-next.directive";
import {RdxCalendarCellDirective} from "../src/calendar-cell.directive";

<Meta title="Primitives/Calendar" />

# Calendar

####  Displays dates and days of the week, facilitating date-related interactions.

<Canvas sourceState="hidden" of={Stories.Default} />

## Features

- ✅ Full keyboard navigation.
- ✅ Can be controlled or uncontrolled
- ✅ Focus is fully managed
- ✅ Localization support
- ✅ Highly composable

## Preface

The component depends on the [@internationalized/date package](https://react-spectrum.adobe.com/internationalized/date/index.html),
which solves a lot of the problems that come with working with dates and times in JavaScript.

We highly recommend reading through the documentation for the package to get a solid feel
for how it works, and you'll need to install it in your project to use the date-related components.

## Installation

Install the date package.

```bash
npm install @internationalized/date
```

Install the component from your command line.

```bash
npm install @radix-ng/primitives
```

## Anatomy

Import all parts and piece them together.

```html
<div
    rdxCalendarRoot
    #root="rdxCalendarRoot">
    <div rdxCalendarHeader>
        <button type="button" rdxCalendarPrev></button>
        <div #head="rdxCalendarHeading" rdxCalendarHeading>
            {{ head.headingValue() }}
        </div>
        <button type="button" rdxCalendarNext></button>
    </div>

    <table rdxCalendarGrid>
        @for (month of root.months(); track $index) {
            <thead rdxCalendarGridHead>
                <tr rdxCalendarGridRow>
                    @for (day of root.weekDays(); track $index) {
                        <th rdxCalendarHeadCell>{{ day }}</th>
                    }
                </tr>
            </thead>
            <tbody rdxCalendarGridBody>
                @for (weekDates of month.weeks; track $index) {
                    <tr rdxCalendarGridRow>
                        @for (weekDate of weekDates; track $index) {
                            <td rdxCalendarCell>
                                <div
                                    #cell="rdxCalendarCellTrigger"
                                    rdxCalendarCellTrigger
                                >
                                    {{ cell.dayValue() }}
                                </div>
                            </td>
                        }
                    </tr>
                }
            </tbody>
        }
    </table>
</div>
```

## API Reference

### Root

`RdxCalendarRootDirective` Contains all the parts of a calendar

<ArgTypes of={RdxCalendarRootDirective} />

### Header

`RdxCalendarHeaderDirective` Contains the navigation buttons and the heading segments.

### Prev Button

`RdxCalendarPrevDirective` Calendar navigation button. It navigates the calendar one month/year/decade in the past based on the current calendar view.

<ArgTypes of={RdxCalendarPrevDirective} />

### Next Button

`RdxCalendarNextDirective` Calendar navigation button. It navigates the calendar one month/year/decade in the future based on the current calendar view.

<ArgTypes of={RdxCalendarNextDirective} />

### Heading

`RdxCalendarHeadingDirective` Heading for displaying the current month and year.


| exportAs       | Description |
| ------------- | --------- |
| `headingValue`  | `string` Current month and year |

### Grid

`RdxCalendarGridDirective` Container for wrapping the calendar grid.

| Data Attribute     | Value |
| ------------------ | --------- |
| `[data-readonly]`  | Present when readonly |
| `[data-disabled]`  | Present when disabled |

### Grid Head

`RdxCalendarGridHeadDirective` Container for wrapping the grid head as `thead`.

### Grid Body

`RdxCalendarGridBodyDirective` Container for wrapping the grid body as `tbody`.

### Grid Row

`RdxCalendarGridRowDirective` Container for wrapping the grid row as `tr`.

### Head Cell

`RdxCalendarHeadCellDirective` Container for wrapping the head cell. Used for displaying the week days as `th`.

### Cell

`RdxCalendarCellDirective` Container for wrapping the calendar cells as `td`.

<ArgTypes of={RdxCalendarCellDirective} />

| Data Attribute     | Value |
| ------------------ | --------- |
| `[data-disabled]`  | Present when disabled |

### Cell Trigger

`RdxCalendarCellTriggerDirective` Interactable container for displaying the cell dates. Clicking it selects the date.

| Data Attribute     | Value |
| ------------------ | --------- |
| `[data-selected]`  | Present when selected |
| `[data-value]`  | The ISO string value of the date. |
| `[data-disabled]`  | Present when disabled |
| `[data-unavailable]`  | Present when unavailable |
| `[data-today]`  | Present when today |
| `[data-outside-view]`  | Present when the date is outside the current month it is displayed in. |
| `[data-outside-visible-view]`  | Present when the date is outside the months that are visible on the calendar. |
| `[data-focused]`  | Present when focused |

## Examples

### Calendar with Locale and Calendar System Selection

This example showcases some of the available locales and how the calendar systems are displayed.

<Canvas sourceState="hidden" of={Stories.WithLocale} />


## Accessibility

### Keyboard Interactions
| Key     | Description |
| ------------------ | --------- |
| `Tab`  | When focus moves onto the calendar, focuses the first navigation button. |
| `Space`  |  When the focus is on either `CalendarNext` or `CalendarPrev`, it navigates the calendar. Otherwise, it selects the date.  |
| `Enter`  |  When the focus is on either `CalendarNext` or `CalendarPrev`, it navigates the calendar. Otherwise, it selects the date.  |
| `ArrowLeft` `ArrowRight` `ArrowUp` `ArrowDown`  |  When the focus is on `CalendarCellTrigger`, it navigates the dates, changing the month/year/decade if necessary.  |

</document_content>
</document>
<document index="8">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/stories/calendar.stories.ts</source>
<document_content>
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { CalendarDefaultComponent } from './calendar-default.component';
import { CalendarWithLocaleComponent } from './calendar-with-locale.component';

const html = String.raw;

export default {
    title: 'Primitives/Calendar',
    decorators: [
        moduleMetadata({
            imports: [
                CalendarDefaultComponent,
                CalendarWithLocaleComponent
            ]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div
                    class="radix-themes light light-theme radix-themes-default-fonts"
                    data-accent-color="indigo"
                    data-radius="medium"
                    data-scaling="100%"
                >
                    ${story}
                </div>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

export const Default: Story = {
    render: () => ({
        template: html`
            <app-calendar-default />
        `
    })
};

export const WithLocale: Story = {
    render: () => ({
        template: html`
            <app-calendar-with-locale />
        `
    })
};

</document_content>
</document>
<document index="9">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/__tests__/calendar.spec.ts</source>
<document_content>
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { CalendarDate, CalendarDateTime, DateValue, toZoned } from '@internationalized/date';
import { userEvent } from '@testing-library/user-event';
import { axe } from 'jest-axe';
import { CalendarDefaultComponent } from '../stories/calendar-default.component';

type SetupConfig = {
    modelValue?: DateValue;
    prevPage?: (placeholder: DateValue) => DateValue;
};

function getSelectedDay(calendar: HTMLElement) {
    return calendar.querySelector<HTMLElement>('[data-selected]') as HTMLElement;
}

function getByTestId(id: string, hostEl: HTMLElement) {
    return hostEl.querySelector<HTMLElement>(`[data-testId=${id}]`)!;
}

const calendarDate = new CalendarDate(1980, 1, 20);
const calendarDateTime = new CalendarDateTime(1980, 1, 20, 12, 30, 0, 0);
const zonedDateTime = toZoned(calendarDateTime, 'America/New_York');

const months = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December'
];

describe('Calendar', () => {
    let fixture: ComponentFixture<CalendarDefaultComponent>;
    let component: CalendarDefaultComponent;
    let hostEl: HTMLElement;

    beforeEach(async () => {
        await TestBed.configureTestingModule({
            imports: [
                CalendarDefaultComponent
            ]
        }).compileComponents();

        fixture = TestBed.createComponent(CalendarDefaultComponent);
        component = fixture.componentInstance;
        hostEl = fixture.nativeElement;
    });

    async function setup({ modelValue }: SetupConfig = {}) {
        if (modelValue !== undefined) {
            component.date = modelValue;
        }

        fixture.detectChanges();

        const user = userEvent.setup();

        const calendar = hostEl.querySelector<HTMLElement>('[data-testId="calendar"]')!;
        expect(calendar).toBeTruthy();

        return { fixture, component, hostEl, calendar, user };
    }

    it('should pass axe accessibility tests', async () => {
        const { calendar } = await setup({ modelValue: calendarDate });

        expect(await axe(calendar)).toHaveNoViolations();
    });

    it('respects a default value if provided - `CalendarDate`', async () => {
        const { calendar } = await setup({ modelValue: calendarDate });
        expect(getSelectedDay(calendar)).toHaveTextContent(String(calendarDate.day));
        expect(getByTestId('heading', hostEl)).toHaveTextContent('January 1980');
    });

    it('respects a default value if provided - `CalendarDateTime`', async () => {
        const { calendar } = await setup({ modelValue: calendarDateTime });

        expect(getSelectedDay(calendar)).toHaveTextContent(String(calendarDateTime.day));
        expect(getByTestId('heading', hostEl)).toHaveTextContent('January 1980');
    });

    it('respects a default value if provided - `ZonedDateTime`', async () => {
        const { calendar } = await setup({ modelValue: zonedDateTime });

        expect(getSelectedDay(calendar)).toHaveTextContent(String(zonedDateTime.day));
        expect(getByTestId('heading', hostEl)).toHaveTextContent('January 1980');
    });

    it('navigates the months forward using the next button', async () => {
        const { user } = await setup({ modelValue: calendarDate });

        const heading = getByTestId('heading', hostEl);
        const nextBtn = getByTestId('next-button', hostEl);

        for (const month of months) {
            expect(heading).toHaveTextContent(`${month} 1980`);
            await user.click(nextBtn);
            fixture.detectChanges();
        }
        expect(heading).toHaveTextContent('January 1981');
    });
});

</document_content>
</document>
<document index="10">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-cell-trigger.directive.ts</source>
<document_content>
import { AfterViewInit, computed, Directive, ElementRef, inject, input } from '@angular/core';
import { DateValue, getLocalTimeZone, isSameDay, isSameMonth, isToday } from '@internationalized/date';
import * as kbd from '@radix-ng/primitives/core';
import { getDaysInMonth, toDate } from '@radix-ng/primitives/core';
import { injectCalendarRootContext } from './сalendar-сontext.token';

@Directive({
    selector: '[rdxCalendarCellTrigger]',
    exportAs: 'rdxCalendarCellTrigger',
    host: {
        role: 'button',
        '[attr.aria-label]': 'labelText()',
        '[attr.aria-disabled]': 'isDisabled() || isUnavailable() ? true : undefined',
        '[attr.data-rdx-calendar-cell-trigger]': '""',
        '[attr.tabindex]': 'isFocusedDate() ? 0 : isOutsideView() || isDisabled() ? undefined : -1',
        '[attr.data-value]': 'day()?.toString()',
        '[attr.data-disabled]': 'isDisabled() ? "" : undefined',
        '[attr.data-today]': 'isDateToday() ? "" : undefined',
        '[attr.data-outside-view]': 'isOutsideView() ? "" : undefined',
        '[attr.data-selected]': 'isSelectedDate() ? "" : undefined',
        '[attr.data-unavailable]': 'isUnavailable() ? "" : undefined',
        '[attr.data-focus]': 'isFocusedDate() ? "" : undefined',

        '(click)': 'onClick()',

        '(keydown)': 'onArrowKey($event)'
    }
})
export class RdxCalendarCellTriggerDirective implements AfterViewInit {
    private readonly rootContext = injectCalendarRootContext();
    private readonly elementRef = inject(ElementRef<HTMLElement>);

    /**
     * The date value provided to the cell trigger
     */
    readonly day = input<DateValue>();

    /**
     * The month in which the cell is rendered
     */
    readonly month = input<DateValue>();

    /**
     * Current day
     */
    readonly dayValue = computed(() => this.day()?.day.toLocaleString());

    /**
     * Current today state
     */
    readonly isDateToday = computed(() => {
        return isToday(<DateValue>this.day(), getLocalTimeZone());
    });

    /**
     * Current selected state
     */
    readonly isSelectedDate = computed(() => this.rootContext.isDateSelected!(<DateValue>this.day()));

    readonly isDisabled = computed(() => this.rootContext.isDateDisabled!(<DateValue>this.day()));

    readonly isOutsideView = computed(() => {
        return !isSameMonth(<DateValue>this.day(), <DateValue>this.month());
    });

    readonly isFocusedDate = computed(() => {
        return !this.rootContext.disabled() && isSameDay(<DateValue>this.day(), this.rootContext.placeholder());
    });

    readonly isUnavailable = computed(() => this.rootContext.isDateUnavailable?.(<DateValue>this.day()) ?? false);

    readonly labelText = computed(() => {
        return this.rootContext.formatter.custom(toDate(<DateValue>this.day()), {
            weekday: 'long',
            month: 'long',
            day: 'numeric',
            year: 'numeric'
        });
    });

    /**
     * @ignore
     */
    currentElement!: HTMLElement;

    ngAfterViewInit() {
        this.currentElement = this.elementRef.nativeElement;
    }

    protected onClick() {
        this.changeDate(this.day()!);
    }

    protected onArrowKey(event: KeyboardEvent) {
        const code = event.code;
        if (![
                kbd.ARROW_RIGHT,
                kbd.ARROW_LEFT,
                kbd.ARROW_UP,
                kbd.ARROW_DOWN,
                kbd.ENTER,
                kbd.SPACE_CODE
            ].includes(code)) {
            return;
        }

        event.preventDefault();
        event.stopPropagation();

        const indexIncrementation = 7;
        const sign = this.rootContext.dir() === 'rtl' ? -1 : 1;

        switch (code) {
            case kbd.ARROW_RIGHT:
                this.shiftFocus(this.currentElement, sign);
                break;
            case kbd.ARROW_LEFT:
                this.shiftFocus(this.currentElement, -sign);
                break;
            case kbd.ARROW_UP:
                this.shiftFocus(this.currentElement, -indexIncrementation);
                break;
            case kbd.ARROW_DOWN:
                this.shiftFocus(this.currentElement, indexIncrementation);
                break;
            case kbd.ENTER:
            case kbd.SPACE_CODE:
                this.changeDate(<DateValue>this.day());
        }
    }

    private shiftFocus(node: HTMLElement, add: number) {
        const parentElement = this.rootContext.currentElement;

        const allCollectionItems: HTMLElement[] = this.getSelectableCells(parentElement);
        if (!allCollectionItems.length) return;

        const index = allCollectionItems.indexOf(node);
        const newIndex = index + add;

        if (newIndex >= 0 && newIndex < allCollectionItems.length) {
            if (allCollectionItems[newIndex].hasAttribute('data-disabled')) {
                this.shiftFocus(allCollectionItems[newIndex], add);
            }
            allCollectionItems[newIndex].focus();
            return;
        }

        if (newIndex < 0) {
            if (!this.rootContext.prevPage) return;

            this.rootContext.prevPage();

            setTimeout(() => {
                const newCollectionItems = this.getSelectableCells(parentElement);
                if (!newCollectionItems.length) return;

                if (!this.rootContext.pagedNavigation && this.rootContext.numberOfMonths() > 1) {
                    // Placeholder is set to the first month of the new page
                    const numberOfDays = getDaysInMonth(this.rootContext.placeholder());
                    const computedIndex = numberOfDays - Math.abs(newIndex);
                    if (newCollectionItems[computedIndex].hasAttribute('data-disabled')) {
                        this.shiftFocus(newCollectionItems[computedIndex], add);
                    }
                    newCollectionItems[computedIndex].focus();
                    return;
                }

                const computedIndex = newCollectionItems.length - Math.abs(newIndex);
                if (newCollectionItems[computedIndex].hasAttribute('data-disabled')) {
                    this.shiftFocus(newCollectionItems[computedIndex], add);
                }
                newCollectionItems[computedIndex].focus();
            });
        }

        if (newIndex >= allCollectionItems.length) {
            if (!this.rootContext.nextPage) return;

            this.rootContext.nextPage();

            setTimeout(() => {
                const newCollectionItems = this.getSelectableCells(parentElement);
                if (!newCollectionItems.length) return;

                if (!this.rootContext.pagedNavigation && this.rootContext.numberOfMonths() > 1) {
                    const numberOfDays = getDaysInMonth(
                        this.rootContext.placeholder().add({ months: this.rootContext.numberOfMonths() - 1 })
                    );

                    const computedIndex =
                        newIndex - allCollectionItems.length + (newCollectionItems.length - numberOfDays);

                    if (newCollectionItems[computedIndex].hasAttribute('data-disabled')) {
                        this.shiftFocus(newCollectionItems[computedIndex], add);
                    }
                    newCollectionItems[computedIndex].focus();
                    return;
                }

                const computedIndex = newIndex - allCollectionItems.length;
                if (newCollectionItems[computedIndex].hasAttribute('data-disabled')) {
                    this.shiftFocus(newCollectionItems[computedIndex], add);
                }

                newCollectionItems[computedIndex].focus();
            });
        }
    }

    /**
     * @ignore
     */
    SELECTOR = '[data-rdx-calendar-cell-trigger]:not([data-outside-view]):not([data-outside-visible-view])';

    /**
     * @ignore
     */
    getSelectableCells(calendar: HTMLElement): HTMLElement[] {
        return Array.from(calendar.querySelectorAll(this.SELECTOR)) ?? [];
    }

    /**
     * @ignore
     */
    changeDate(date: DateValue) {
        this.rootContext.onDateChange(date);
    }
}

</document_content>
</document>
<document index="11">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-cell.directive.ts</source>
<document_content>
import { Directive, input } from '@angular/core';
import { DateValue } from '@internationalized/date';
import { injectCalendarRootContext } from './сalendar-сontext.token';

@Directive({
    selector: 'td[rdxCalendarCell]',
    host: {
        role: 'gridcell',
        '[attr.aria-selected]': 'rootContext.isDateSelected?.(date()!) ? true : undefined',
        '[attr.aria-disabled]': 'rootContext.isDateSelected?.(date()!) ||  rootContext.isDateUnavailable?.(date()!)',
        '[attr.data-disabled]': 'rootContext.isDateSelected?.(date()!) ? "" : undefined'
    }
})
export class RdxCalendarCellDirective {
    protected readonly rootContext = injectCalendarRootContext();

    /**
     * The date of the cell
     */
    readonly date = input<DateValue>();
}

</document_content>
</document>
<document index="12">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-grid-body.directive.ts</source>
<document_content>
import { Directive } from '@angular/core';

@Directive({
    selector: 'tbody[rdxCalendarGridBody]'
})
export class RdxCalendarGridBodyDirective {}

</document_content>
</document>
<document index="13">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-grid-head.directive.ts</source>
<document_content>
import { Directive } from '@angular/core';

@Directive({
    selector: 'thead[rdxCalendarGridHead]',
    host: {
        '[attr.aria-hidden]': 'true'
    }
})
export class RdxCalendarGridHeadDirective {}

</document_content>
</document>
<document index="14">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-grid-row.directive.ts</source>
<document_content>
import { Directive } from '@angular/core';

@Directive({
    selector: 'tr[rdxCalendarGridRow]'
})
export class RdxCalendarGridRowDirective {}

</document_content>
</document>
<document index="15">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-grid.directive.ts</source>
<document_content>
import { computed, Directive } from '@angular/core';
import { injectCalendarRootContext } from './сalendar-сontext.token';

@Directive({
    selector: 'table[rdxCalendarGrid]',
    host: {
        tabindex: '-1',
        role: 'grid',
        '[attr.aria-readonly]': 'readonly()',
        '[attr.aria-disabled]': 'disabled()',
        '[attr.data-readonly]': 'readonly() && ""',
        '[attr.data-disabled]': 'disabled() && ""'
    }
})
export class RdxCalendarGridDirective {
    private readonly rootContext = injectCalendarRootContext();

    readonly disabled = computed(() => (this.rootContext.disabled() ? true : undefined));
    readonly readonly = computed(() => (this.rootContext.readonly ? true : undefined));
}

</document_content>
</document>
<document index="16">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-head-cell.directive.ts</source>
<document_content>
import { Directive } from '@angular/core';

@Directive({
    selector: 'th[rdxCalendarHeadCell]'
})
export class RdxCalendarHeadCellDirective {}

</document_content>
</document>
<document index="17">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-header.directive.ts</source>
<document_content>
import { Directive } from '@angular/core';

@Directive({
    selector: 'div[rdxCalendarHeader]'
})
export class RdxCalendarHeaderDirective {}

</document_content>
</document>
<document index="18">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-heading.directive.ts</source>
<document_content>
import { computed, Directive } from '@angular/core';
import { injectCalendarRootContext } from './сalendar-сontext.token';

@Directive({
    selector: 'div[rdxCalendarHeading]',
    exportAs: 'rdxCalendarHeading',
    host: {
        '[attr.data-disabled]': 'rootContext.disabled() ? "" : undefined'
    }
})
export class RdxCalendarHeadingDirective {
    protected readonly rootContext = injectCalendarRootContext();

    readonly headingValue = computed(() => this.rootContext.headingValue());
}

</document_content>
</document>
<document index="19">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-next.directive.ts</source>
<document_content>
import { computed, Directive, input } from '@angular/core';
import { DateValue } from '@internationalized/date';
import { injectCalendarRootContext } from './сalendar-сontext.token';

@Directive({
    selector: 'button[rdxCalendarNext]',
    exportAs: 'rdxCalendarNext',
    host: {
        '(click)': 'onClick()',
        '[disabled]': 'disabled()',
        '[attr.data-disabled]': 'disabled() ? "" : undefined',
        '[attr.aria-disabled]': 'disabled() ? "" : undefined',
        'aria-label': 'Next page'
    }
})
export class RdxCalendarNextDirective {
    protected readonly rootContext = injectCalendarRootContext();

    /**
     * The function to be used for the `next page`. Overwrites the nextPage function set on the `CalendarRoot`.
     */
    readonly nextPage = input<(placeholder: DateValue) => DateValue>();

    /**
     * @ignore
     */
    readonly disabled = computed(
        () => this.rootContext.disabled() || this.rootContext.isNextButtonDisabled(this.nextPage())
    );

    protected onClick() {
        this.rootContext.nextPage!(this.nextPage());
    }
}

</document_content>
</document>
<document index="20">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-prev.directive.ts</source>
<document_content>
import { computed, Directive, input } from '@angular/core';
import { DateValue } from '@internationalized/date';
import { injectCalendarRootContext } from './сalendar-сontext.token';

@Directive({
    selector: 'button[rdxCalendarPrev]',
    exportAs: 'rdxCalendarPrev',
    host: {
        '(click)': 'onClick()',
        '[disabled]': 'disabled()',
        '[attr.data-disabled]': 'disabled() ? "" : undefined',
        '[attr.aria-disabled]': 'disabled() ? "" : undefined',
        'aria-label': 'Previous page'
    }
})
export class RdxCalendarPrevDirective {
    protected readonly rootContext = injectCalendarRootContext();

    /**
     * The function to be used for the `prev page`. Overwrites the prevPage function set on the `CalendarRoot`.
     */
    readonly prevPage = input<(placeholder: DateValue) => DateValue>();

    /**
     * @ignore
     */
    readonly disabled = computed(
        () => this.rootContext.disabled() || this.rootContext.isNextButtonDisabled(this.prevPage())
    );

    protected onClick() {
        this.rootContext.prevPage!(this.prevPage());
    }
}

</document_content>
</document>
<document index="21">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar-root.directive.ts</source>
<document_content>
import { BooleanInput } from '@angular/cdk/coercion';
import {
    AfterViewInit,
    booleanAttribute,
    Directive,
    effect,
    ElementRef,
    forwardRef,
    inject,
    input,
    linkedSignal,
    model,
    signal
} from '@angular/core';
import { DateValue, isEqualDay, isSameDay } from '@internationalized/date';
import { DateMatcher, Formatter, getDefaultDate, Month, watch } from '@radix-ng/primitives/core';
import { calendar, calendarState } from './calendar';
import { CALENDAR_ROOT_CONTEXT } from './сalendar-сontext.token';

@Directive({
    selector: '[rdxCalendarRoot]',
    exportAs: 'rdxCalendarRoot',
    providers: [
        { provide: CALENDAR_ROOT_CONTEXT, useExisting: forwardRef(() => RdxCalendarRootDirective) }],
    host: {
        role: 'application',
        '[attr.aria-label]': 'fullCalendarLabel()',
        '[attr.data-disabled]': 'disabled() ? "" : undefined',
        '[attr.data-readonly]': 'readonly() ? "" : undefined',
        '[attr.data-invalid]': 'isInvalid ? "" : undefined',
        '[attr.dir]': 'dir()'
    }
})
export class RdxCalendarRootDirective implements AfterViewInit {
    private readonly elementRef = inject(ElementRef<HTMLElement>);

    /**
     * The controlled checked state of the calendar
     */
    readonly value = model<DateValue | DateValue[] | undefined>();

    /**
     * The default placeholder date
     */
    readonly defaultPlaceholder = model<DateValue>();

    readonly locale = input<string>('en');

    readonly defaultDate = getDefaultDate({
        defaultPlaceholder: this.defaultPlaceholder(),
        defaultValue: this.value(),
        locale: this.locale()
    });

    /**
     * The placeholder date, which is used to determine what month to display when no date is selected.
     * This updates as the user navigates the calendar and can be used to programmatically control the calendar view
     */
    readonly placeholder = model<DateValue>(this.defaultPlaceholder() ?? this.defaultDate.copy());

    readonly multiple = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * Whether to always display 6 weeks in the calendar
     */
    readonly fixedWeeks = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * Whether the calendar is disabled
     */
    readonly disabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * Whether to prevent the user from deselecting a date without selecting another date first
     */
    readonly preventDeselect = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * The day of the week to start the calendar on
     */
    readonly weekStartsOn = input<0 | 1 | 2 | 3 | 4 | 5 | 6>(1);

    /**
     * The number of months to display at once
     */
    readonly numberOfMonths = input<number>(1);

    /**
     * The reading direction of the calendar when applicable.
     */
    readonly dir = input<'ltr' | 'rtl'>('ltr');

    /**
     * The minimum date that can be selected
     */
    readonly minValue = input<DateValue>();

    /**
     * The maximum date that can be selected
     */
    readonly maxValue = input<DateValue>();

    /**
     * The format to use for the weekday strings provided via the weekdays slot prop
     */
    readonly weekdayFormat = input<Intl.DateTimeFormatOptions['weekday']>('narrow');

    /**
     * The accessible label for the calendar
     */
    readonly calendarLabel = input<string>();

    /**
     * Whether the calendar is readonly
     */
    readonly readonly = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /**
     * This property causes the previous and next buttons to navigate by the number of months displayed at once, rather than one month
     */
    readonly pagedNavigation = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    readonly propsNextPage = input<(placeholder: DateValue) => DateValue>();

    readonly propsPrevPage = input<(placeholder: DateValue) => DateValue>();

    /**
     * A function that returns whether a date is disabled
     */
    readonly isDateDisabled = input<DateMatcher>();

    /**
     * A function that returns whether a date is unavailable
     */
    readonly isDateUnavailable = input<DateMatcher>();

    readonly initialFocus = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    readonly months = model<Month<DateValue>[]>();

    /**
     * The days of the week
     */
    readonly weekDays = model<string[]>();

    protected readonly _fixedWeeks = linkedSignal(this.fixedWeeks);

    protected readonly _disabled = linkedSignal(this.disabled);

    protected readonly _pagedNavigation = linkedSignal(this.pagedNavigation);

    /**
     * @ignore
     */
    readonly headingValue = signal<string>('');

    /**
     * @ignore
     */
    readonly fullCalendarLabel = signal<string>('');

    /**
     * @ignore
     */
    nextPage: (nextPageFunc?: (date: DateValue) => DateValue) => void;

    /**
     * @ignore
     */
    prevPage: (nextPageFunc?: (date: DateValue) => DateValue) => void;

    /**
     * @ignore
     */
    isNextButtonDisabled: (nextPageFunc?: (date: DateValue) => DateValue) => boolean;

    /**
     * @ignore
     */
    isPrevButtonDisabled: (nextPageFunc?: (date: DateValue) => DateValue) => boolean;

    /**
     * @ignore
     */
    isDateSelected: DateMatcher;

    /**
     * @ignore
     */
    isInvalid: boolean;

    /**
     * @ignore
     */
    isOutsideVisibleView: (date: DateValue) => boolean;

    /**
     * @ignore
     */
    formatter: Formatter;

    /**
     * @ignore
     */
    currentElement!: HTMLElement;

    private readonly calendar = calendar({
        locale: this.locale,
        placeholder: this.placeholder,
        weekStartsOn: this.weekStartsOn,
        fixedWeeks: this._fixedWeeks,
        numberOfMonths: this.numberOfMonths,
        minValue: this.minValue,
        maxValue: this.maxValue,
        disabled: this._disabled,
        weekdayFormat: this.weekdayFormat,
        pagedNavigation: this._pagedNavigation,
        isDateDisabled: this.isDateDisabled,
        isDateUnavailable: this.isDateUnavailable,
        calendarLabel: this.calendarLabel,
        nextPage: this.propsNextPage,
        prevPage: this.propsPrevPage
    });

    constructor() {
        this.nextPage = this.calendar.nextPage;
        this.prevPage = this.calendar.prevPage;
        this.isOutsideVisibleView = this.calendar.isOutsideVisibleView;
        this.isNextButtonDisabled = this.calendar.isNextButtonDisabled;
        this.isPrevButtonDisabled = this.calendar.isPrevButtonDisabled;
        this.formatter = this.calendar.formatter;

        effect(() => {
            this.months.set(this.calendar.month());

            this.weekDays.set(this.calendar.weekdays());

            this.fullCalendarLabel.set(this.calendar.fullCalendarLabel());

            this.headingValue.set(this.calendar.headingValue());

            const { isInvalid, isDateSelected } = calendarState({
                date: this.value,
                isDateDisabled: this.isDateDisabled(),
                isDateUnavailable: this.isDateUnavailable()
            });

            this.isDateSelected = isDateSelected;
            this.isInvalid = isInvalid();
        });

        watch([this.value], (_modelValue) => {
            if (Array.isArray(_modelValue) && _modelValue.length) {
                const lastValue = _modelValue[_modelValue.length - 1];
                if (lastValue && !isEqualDay(this.placeholder(), <DateValue>lastValue)) {
                    this.onPlaceholderChange(<DateValue>lastValue);
                }
            } else if (!Array.isArray(_modelValue) && _modelValue && !isEqualDay(this.placeholder(), _modelValue)) {
                this.onPlaceholderChange(_modelValue);
            }
        });
    }

    ngAfterViewInit() {
        this.currentElement = this.elementRef.nativeElement;
    }

    /**
     * @ignore
     */
    onPlaceholderChange(value: DateValue) {
        this.placeholder.set(value.copy());
    }

    /**
     * @ignore
     */
    onDateChange(date: DateValue) {
        const currentValue = this.value();

        if (!this.multiple()) {
            // for single selection
            if (!this.value()) {
                this.value.set(date.copy());
                return;
            }

            if (!this.preventDeselect() && isEqualDay(this.value() as DateValue, date)) {
                this.placeholder.set(date.copy());
                this.value.set(undefined);
            } else {
                this.value.set(date.copy());
            }
        } else if (!this.value()) {
            // for multiple selection
            this.value.set([date.copy()]);
        } else if (Array.isArray(currentValue)) {
            const index = currentValue.findIndex((d: DateValue) => isSameDay(d, date));
            if (index === -1) {
                this.value.set([...currentValue, date.copy()]);
            } else if (!this.preventDeselect()) {
                const next = currentValue.filter((d: DateValue) => !isSameDay(d, date));
                if (next.length === 0) {
                    this.placeholder.set(date.copy());
                    this.value.set(undefined);
                    return;
                }
                this.value.set(next.map((d) => d.copy()));
            }
        }
    }
}

</document_content>
</document>
<document index="22">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/calendar.ts</source>
<document_content>
import { computed, InputSignal, ModelSignal, signal, WritableSignal } from '@angular/core';
import { DateFields, DateValue, isEqualMonth, isSameDay } from '@internationalized/date';
import {
    createFormatter,
    createMonths,
    DateFormatterOptions,
    DateMatcher,
    getDaysInMonth,
    isAfter,
    isBefore,
    Month,
    toDate,
    watch
} from '@radix-ng/primitives/core';

export type CalendarProps = {
    locale: InputSignal<string>;
    placeholder: WritableSignal<DateValue>;
    weekStartsOn: InputSignal<0 | 1 | 2 | 3 | 4 | 5 | 6>;
    fixedWeeks: WritableSignal<boolean>;
    numberOfMonths: InputSignal<number>;
    minValue: InputSignal<DateValue | undefined>;
    maxValue: InputSignal<DateValue | undefined>;
    disabled: WritableSignal<boolean>;
    weekdayFormat: InputSignal<Intl.DateTimeFormatOptions['weekday']>;
    pagedNavigation: WritableSignal<boolean>;
    isDateDisabled?: InputSignal<DateMatcher | undefined>;
    isDateUnavailable?: InputSignal<DateMatcher | undefined>;
    calendarLabel: InputSignal<string | undefined>;
    nextPage: InputSignal<((placeholder: DateValue) => DateValue) | undefined>;
    prevPage: InputSignal<((placeholder: DateValue) => DateValue) | undefined>;
};

export type CalendarStateProps = {
    date: ModelSignal<DateValue | DateValue[] | undefined>;
    isDateDisabled?: DateMatcher;
    isDateUnavailable?: DateMatcher;
};

export function calendarState(props: CalendarStateProps) {
    function isDateSelected(dateObj: DateValue): boolean {
        const currentValue = props.date(); // signal read

        if (Array.isArray(currentValue)) {
            return currentValue.some((d) => isSameDay(d, dateObj));
        } else if (!currentValue) {
            return false;
        } else {
            return isSameDay(currentValue, dateObj);
        }
    }

    const isInvalid = computed(() => {
        const currentValue = props.date();

        if (Array.isArray(currentValue)) {
            if (!currentValue.length) {
                return false;
            }
            for (const dateObj of currentValue) {
                if (props.isDateDisabled?.(dateObj)) return true;
                if (props.isDateUnavailable?.(dateObj)) return true;
            }
        } else {
            if (!currentValue) {
                return false;
            }
            if (props.isDateDisabled?.(currentValue)) return true;
            if (props.isDateUnavailable?.(currentValue)) return true;
        }
        return false;
    });

    return {
        isDateSelected,
        isInvalid
    };
}

function handleNextDisabled(lastPeriodInView: DateValue, nextPageFunc: (date: DateValue) => DateValue): DateValue {
    const firstPeriodOfNextPage = nextPageFunc(lastPeriodInView);
    const diff = firstPeriodOfNextPage.compare(lastPeriodInView);
    const duration: DateFields = {};
    if (diff >= 7) duration.day = 1;
    if (diff >= getDaysInMonth(lastPeriodInView)) duration.month = 1;
    return firstPeriodOfNextPage.set({ ...duration });
}

function handlePrevDisabled(firstPeriodInView: DateValue, prevPageFunc: (date: DateValue) => DateValue): DateValue {
    const lastPeriodOfPrevPage = prevPageFunc(firstPeriodInView);
    const diff = firstPeriodInView.compare(lastPeriodOfPrevPage);
    const duration: DateFields = {};
    if (diff >= 7) duration.day = 35;
    if (diff >= getDaysInMonth(firstPeriodInView)) duration.month = 13;
    return lastPeriodOfPrevPage.set({ ...duration });
}

function handleNextPage(date: DateValue, nextPageFunc: (date: DateValue) => DateValue): DateValue {
    return nextPageFunc(date);
}

function handlePrevPage(date: DateValue, prevPageFunc: (date: DateValue) => DateValue): DateValue {
    return prevPageFunc(date);
}

export function calendar(props: CalendarProps) {
    const formatter = createFormatter(props.locale());

    const headingFormatOptions = computed(() => {
        const options: DateFormatterOptions = {
            calendar: props.placeholder().calendar.identifier
        };

        if (props.placeholder().calendar.identifier === 'gregory' && props.placeholder().era === 'BC') {
            options.era = 'short';
        }

        return options;
    });

    const month = signal<Month<DateValue>[]>(
        createMonths({
            dateObj: props.placeholder(),
            weekStartsOn: props.weekStartsOn(),
            locale: props.locale(),
            fixedWeeks: props.fixedWeeks(),
            numberOfMonths: props.numberOfMonths()
        })
    );

    const visibleView = computed(() => {
        return month().map((month) => month.value);
    });

    function isOutsideVisibleView(date: DateValue) {
        return !visibleView().some((month) => isEqualMonth(date, month));
    }

    const isNextButtonDisabled = (nextPageFunc?: (date: DateValue) => DateValue) => {
        if (!props.maxValue() || !month().length) return false;
        if (props.disabled()) return true;

        const lastPeriodInView = month()[month().length - 1].value;

        if (!nextPageFunc && !props.nextPage()) {
            const firstPeriodOfNextPage = lastPeriodInView.add({ months: 1 }).set({ day: 1 });
            return isAfter(firstPeriodOfNextPage, <DateValue>props.maxValue());
        }

        const firstPeriodOfNextPage = handleNextDisabled(lastPeriodInView, nextPageFunc || props.nextPage()!);
        return isAfter(firstPeriodOfNextPage, <DateValue>props.maxValue());
    };

    const isPrevButtonDisabled = (prevPageFunc?: (date: DateValue) => DateValue) => {
        if (!props.minValue() || !month().length) return false;
        if (props.disabled()) return true;
        const firstPeriodInView = month()[0].value;

        if (!prevPageFunc && !props.prevPage()) {
            const lastPeriodOfPrevPage = firstPeriodInView.subtract({ months: 1 }).set({ day: 35 });
            return isBefore(lastPeriodOfPrevPage, <DateValue>props.minValue());
        }

        const lastPeriodOfPrevPage = handlePrevDisabled(firstPeriodInView, prevPageFunc || props.prevPage()!);
        return isBefore(lastPeriodOfPrevPage, <DateValue>props.minValue());
    };

    const nextPage = (nextPageFunc?: (date: DateValue) => DateValue) => {
        const firstDate = month()[0].value;

        if (!nextPageFunc && !props.nextPage()) {
            const newDate = firstDate.add({ months: props.pagedNavigation() ? props.numberOfMonths() : 1 });

            const newMonth = createMonths({
                dateObj: newDate,
                weekStartsOn: props.weekStartsOn(),
                locale: props.locale(),
                fixedWeeks: props.fixedWeeks(),
                numberOfMonths: props.numberOfMonths()
            });

            month.set(newMonth);
            props.placeholder.set(newMonth[0].value.set({ day: 1 }));

            return;
        }

        const newDate = handleNextPage(firstDate, nextPageFunc || props.nextPage()!);
        const newMonth = createMonths({
            dateObj: newDate,
            weekStartsOn: props.weekStartsOn(),
            locale: props.locale(),
            fixedWeeks: props.fixedWeeks(),
            numberOfMonths: props.numberOfMonths()
        });

        month.set(newMonth);

        const duration: DateFields = {};

        if (!nextPageFunc) {
            const diff = newMonth[0].value.compare(firstDate);
            if (diff >= getDaysInMonth(firstDate)) {
                duration.day = 1;
            }

            if (diff >= 365) {
                duration.month = 1;
            }
        }

        props.placeholder.set(newMonth[0].value.set({ ...duration }));
    };

    const prevPage = (prevPageFunc?: (date: DateValue) => DateValue) => {
        const firstDate = month()[0].value;

        if (!prevPageFunc && !props.prevPage()) {
            const newDate = firstDate.subtract({ months: props.pagedNavigation() ? props.numberOfMonths() : 1 });

            const newMonth = createMonths({
                dateObj: newDate,
                weekStartsOn: props.weekStartsOn(),
                locale: props.locale(),
                fixedWeeks: props.fixedWeeks(),
                numberOfMonths: props.numberOfMonths()
            });

            month.set(newMonth);

            props.placeholder.set(newMonth[0].value.set({ day: 1 }));
            return;
        }

        const newDate = handlePrevPage(firstDate, prevPageFunc || props.prevPage()!);
        const newMonth = createMonths({
            dateObj: newDate,
            weekStartsOn: props.weekStartsOn(),
            locale: props.locale(),
            fixedWeeks: props.fixedWeeks(),
            numberOfMonths: props.numberOfMonths()
        });

        month.set(newMonth);

        const duration: DateFields = {};

        // Do not adjust the placeholder if the prevPageFunc is defined (overwrite)
        if (!prevPageFunc) {
            const diff = firstDate.compare(newMonth[0].value);
            if (diff >= getDaysInMonth(firstDate)) duration.day = 1;

            if (diff >= 365) duration.month = 1;
        }

        props.placeholder.set(newMonth[0].value.set({ ...duration }));
    };

    function isDateDisabled(dateObj: DateValue) {
        if (props.isDateDisabled?.()?.(dateObj) || props.disabled()) return true;
        if (props.maxValue() && isAfter(dateObj, <DateValue>props.maxValue())) return true;
        if (props.minValue() && isBefore(dateObj, <DateValue>props.minValue())) return true;
        return false;
    }

    const isDateUnavailable = (date: DateValue) => {
        return !!props.isDateUnavailable?.()?.(date);
    };

    const weekdays = computed(() => {
        if (!month().length) return [];
        return month()[0].weeks[0].map((date) => {
            return formatter.dayOfWeek(toDate(date), props.weekdayFormat());
        });
    });

    watch([props.placeholder], ([placeholder]) => {
        if (visibleView().some((month) => isEqualMonth(month, placeholder))) {
            return;
        }

        month.set(
            createMonths({
                dateObj: placeholder,
                weekStartsOn: props.weekStartsOn(),
                locale: props.locale(),
                fixedWeeks: props.fixedWeeks(),
                numberOfMonths: props.numberOfMonths()
            })
        );
    });

    watch(
        [props.locale, props.weekStartsOn, props.fixedWeeks, props.numberOfMonths],
        ([locale, weekStartsOn, fixedWeeks, numberOfMonths]) => {
            month.set(
                createMonths({
                    dateObj: props.placeholder(),
                    weekStartsOn: weekStartsOn,
                    locale: locale,
                    fixedWeeks: fixedWeeks,
                    numberOfMonths: numberOfMonths
                })
            );
        }
    );

    const headingValue = computed(() => {
        if (!month().length) {
            return '';
        }

        if (props.locale() !== formatter.getLocale()) formatter.setLocale(props.locale());

        if (month().length === 1) {
            const _month = month()[0].value;
            return `${formatter.fullMonthAndYear(toDate(_month), headingFormatOptions())}`;
        }

        const startMonth = toDate(month()[0].value);
        const endMonth = toDate(month()[month().length - 1].value);

        const startMonthName = formatter.fullMonth(startMonth, headingFormatOptions());
        const endMonthName = formatter.fullMonth(endMonth, headingFormatOptions());
        const startMonthYear = formatter.fullYear(startMonth, headingFormatOptions());
        const endMonthYear = formatter.fullYear(endMonth, headingFormatOptions());

        return startMonthYear === endMonthYear
            ? `${startMonthName} - ${endMonthName} ${endMonthYear}`
            : `${startMonthName} ${startMonthYear} - ${endMonthName} ${endMonthYear}`;
    });

    const fullCalendarLabel = computed(() => `${props.calendarLabel() ?? 'Event Date'}, ${headingValue()}`);

    return {
        isDateDisabled,
        isDateUnavailable,
        isNextButtonDisabled,
        isPrevButtonDisabled,
        month,
        weekdays,
        visibleView,
        isOutsideVisibleView,
        formatter,
        nextPage,
        prevPage,
        headingValue,
        fullCalendarLabel
    };
}

</document_content>
</document>
<document index="23">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/calendar/src/сalendar-сontext.token.ts</source>
<document_content>
import { inject, InjectionToken, InputSignal, ModelSignal, WritableSignal } from '@angular/core';
import { DateValue } from '@internationalized/date';
import { DateMatcher, Formatter } from '@radix-ng/primitives/core';

export interface CalendarRootContextToken {
    nextPage?: (nextPageFunc?: (date: DateValue) => DateValue) => void;
    prevPage?: (nextPageFunc?: (date: DateValue) => DateValue) => void;
    isNextButtonDisabled: (nextPageFunc?: (date: DateValue) => DateValue) => boolean;
    isPrevButtonDisabled: (nextPageFunc?: (date: DateValue) => DateValue) => boolean;
    headingValue: WritableSignal<string>;
    dir: InputSignal<'ltr' | 'rtl'>;
    readonly: boolean;
    numberOfMonths: InputSignal<number>;
    placeholder: ModelSignal<DateValue>;
    pagedNavigation: boolean;
    disabled: InputSignal<boolean>;
    isDateSelected?: DateMatcher;
    isDateDisabled?: DateMatcher;
    isDateUnavailable: DateMatcher;
    formatter: Formatter;
    onDateChange: (date: DateValue) => void;
    currentElement: HTMLElement;
}

export const CALENDAR_ROOT_CONTEXT = new InjectionToken<CalendarRootContextToken>('CalendarRootContext');

export function injectCalendarRootContext(): CalendarRootContextToken {
    return inject(CALENDAR_ROOT_CONTEXT);
}

</document_content>
</document>
</documents>
