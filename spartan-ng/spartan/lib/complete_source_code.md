/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/README.md
```
# UI library

## Overall Architecture

Components are made up out of a brain, which is a headless accessible implementation
of the component. A UI component can be an Angular component or an Angular directive applied
to an existing HTML element or a combination of both if the UI component is more complicated.

On top of these brain components we put our helmet. Our helmet adds SPARTAN-like swagger to our UI.
Most of the time our helmets are added by applying the hlm + component name directive.
An example:
`<button hlmBtn >...</button>` this applies the SPARTAN styles to the button element.

Appearance only UI components that do not provide any other functionality are also
Angular components, e.g. the `<hlm-skeleton/>` component allows you to build a skeleton UI.

## Roadmap (37/43)

- [x] Accordion
- [x] Alert
- [x] Alert Dialog
- [x] Aspect Ratio
- [x] Avatar
- [x] Badge
- [x] Button
- [ ] Calendar
- [x] Card
- [x] Checkbox
- [x] Collapsible
- [x] Combobox
- [x] Command
- [x] Context Menu
- [x] Data Table (needs better docs)
- [ ] Date Picker
- [x] Dialog
- [x] Dropdown Menu
- [x] Hover Card
- [x] Icon
- [x] Input
- [x] Input OTP
- [x] Label
- [x] Menubar
- [ ] Navigation Menu
- [x] Pagination
- [x] Popover
- [x] Progress
- [x] Radio Group
- [x] Scroll Area
- [ ] Select
- [x] Separator
- [x] Sheet
- [x] Skeleton
- [ ] Slider
- [x] Spinner
- [x] Switch
- [x] Table (needs better docs)
- [x] Tabs
- [x] Textarea (covered by hlmInput directive)
- [ ] Toast
- [x] Toggle
- [x] Tooltip
- [x] Typography

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tabs/tabs.stories.ts
```typescript
import { BrnTabsDirective, BrnTabsImports } from '@spartan-ng/brain/tabs';
import { type Meta, type StoryObj, argsToTemplate, moduleMetadata } from '@storybook/angular';
import { HlmButtonDirective } from '../button/helm/src';
import { HlmCardImports } from '../card/helm/src';
import { HlmInputDirective } from '../input/helm/src';
import { HlmLabelDirective } from '../label/helm/src';
import { HlmTabsImports } from './helm/src';

const meta: Meta<BrnTabsDirective> = {
	title: 'Tabs',
	component: BrnTabsDirective,
	tags: ['autodocs'],
	argTypes: {
		activationMode: {
			options: ['manual', 'automatic'],
			control: {
				type: 'select',
			},
		},
	},
	decorators: [
		moduleMetadata({
			imports: [
				BrnTabsImports,
				HlmTabsImports,
				HlmCardImports,
				HlmLabelDirective,
				HlmInputDirective,
				HlmButtonDirective,
			],
		}),
	],
};

export default meta;
type Story = StoryObj<BrnTabsDirective>;
export const Default: Story = {
	render: ({ ...args }) => ({
		props: args,
		template: /* HTML */ `
			<hlm-tabs tab="account" ${argsToTemplate(args)} class="mx-auto block max-w-3xl">
				<hlm-tabs-list class="grid w-full grid-cols-2" aria-label="tabs example">
					<button hlmTabsTrigger="account">Account</button>
					<button hlmTabsTrigger="password">Password</button>
				</hlm-tabs-list>
				<div hlmTabsContent="account">
					<section hlmCard>
						<div hlmCardHeader>
							<h3 hlmCardTitle>Account</h3>
							<p hlmCardDescription>Make changes to your account here. Click save when you're done.</p>
						</div>
						<p hlmCardContent>
							<label class="my-4 block" hlmLabel>
								Name
								<input class="mt-1.5 w-full" value="Pedro Duarte" hlmInput />
							</label>
							<label class="my-4 block" hlmLabel>
								Username
								<input class="mt-1.5 w-full" placeholder="@peduarte" hlmInput />
							</label>
						</p>
						<div hlmCardFooter>
							<button hlmBtn>Save Changes</button>
						</div>
					</section>
				</div>
				<div hlmTabsContent="password">
					<section hlmCard>
						<div hlmCardHeader>
							<h3 hlmCardTitle>Password</h3>
							<p hlmCardDescription>Change your password here. After saving, you'll be logged out.</p>
						</div>
						<p hlmCardContent>
							<label class="my-4 block" hlmLabel>
								Old Password
								<input class="mt-1.5 w-full" type="password" hlmInput />
							</label>
							<label class="my-4 block" hlmLabel>
								New Password
								<input class="mt-1.5 w-full" type="password" hlmInput />
							</label>
						</p>
						<div hlmCardFooter>
							<button hlmBtn>Save Password</button>
						</div>
					</section>
				</div>
			</hlm-tabs>
		`,
	}),
};

export const Vertical: Story = {
	render: ({ activationMode }) => ({
		props: { activationMode },
		template: /* HTML */ `
			<hlm-tabs tab="account" class="mx-auto flex max-w-3xl flex-row space-x-2" orientation="vertical">
				<hlm-tabs-list orientation="vertical" aria-label="tabs example">
					<button class="w-full" hlmTabsTrigger="account">Account</button>
					<button class="w-full" hlmTabsTrigger="password">Password</button>
					<button class="w-full" hlmTabsTrigger="danger">Danger Zone</button>
				</hlm-tabs-list>
				<div hlmTabsContent="account">
					<section hlmCard>
						<div hlmCardHeader>
							<h3 hlmCardTitle>Account</h3>
							<p hlmCardDescription>Make changes to your account here. Click save when you're done.</p>
						</div>
						<p hlmCardContent>
							<label class="my-4 block" hlmLabel>
								Name
								<input class="mt-1.5 w-full" value="Pedro Duarte" hlmInput />
							</label>
							<label class="my-4 block" hlmLabel>
								Username
								<input class="mt-1.5 w-full" placeholder="@peduarte" hlmInput />
							</label>
						</p>
						<div hlmCardFooter>
							<button hlmBtn>Save Changes</button>
						</div>
					</section>
				</div>
				<div hlmTabsContent="password">
					<section hlmCard>
						<div hlmCardHeader>
							<h3 hlmCardTitle>Password</h3>
							<p hlmCardDescription>Change your password here. After saving, you'll be logged out.</p>
						</div>
						<p hlmCardContent>
							<label class="my-4 block" hlmLabel>
								Old Password
								<input class="mt-1.5 w-full" type="password" hlmInput />
							</label>
							<label class="my-4 block" hlmLabel>
								New Password
								<input class="mt-1.5 w-full" type="password" hlmInput />
							</label>
						</p>
						<div hlmCardFooter>
							<button hlmBtn>Save Password</button>
						</div>
					</section>
				</div>
				<div hlmTabsContent="danger">
					<section hlmCard>
						<div hlmCardHeader>
							<h3 hlmCardTitle>Delete Account</h3>
							<p hlmCardDescription>Are you sure you want to delete your account? You cannot undo this action.</p>
						</div>
						<div hlmCardFooter>
							<button variant="destructive" hlmBtn>Delete Account</button>
						</div>
					</section>
				</div>
			</hlm-tabs>
		`,
	}),
};

export const Paginated: Story = {
	render: () => ({
		template: /* HTML */ `
			<hlm-tabs tab="1" class="mx-auto block max-w-3xl">
				<hlm-paginated-tabs-list>
					<button hlmTabsTrigger="1">Tab 1</button>
					<button hlmTabsTrigger="2">Tab 2</button>
					<button hlmTabsTrigger="3">Tab 3</button>
					<button hlmTabsTrigger="4">Tab 4</button>
					<button hlmTabsTrigger="5">Tab 5</button>
					<button hlmTabsTrigger="6">Tab 6</button>
					<button hlmTabsTrigger="7">Tab 7</button>
					<button hlmTabsTrigger="8">Tab 8</button>
					<button hlmTabsTrigger="9">Tab 9</button>
					<button hlmTabsTrigger="10">Tab 10</button>
					<button hlmTabsTrigger="11">Tab 11</button>
					<button hlmTabsTrigger="12">Tab 12</button>
					<button hlmTabsTrigger="13">Tab 13</button>
					<button hlmTabsTrigger="14">Tab 14</button>
					<button hlmTabsTrigger="15">Tab 15</button>
					<button hlmTabsTrigger="16">Tab 16</button>
					<button hlmTabsTrigger="17">Tab 17</button>
					<button hlmTabsTrigger="18">Tab 18</button>
					<button hlmTabsTrigger="19">Tab 19</button>
					<button hlmTabsTrigger="20">Tab 20</button>
				</hlm-paginated-tabs-list>
				<div hlmTabsContent="1">Tab 1</div>
				<div hlmTabsContent="2">Tab 2</div>
				<div hlmTabsContent="3">Tab 3</div>
				<div hlmTabsContent="4">Tab 4</div>
				<div hlmTabsContent="5">Tab 5</div>
				<div hlmTabsContent="6">Tab 6</div>
				<div hlmTabsContent="7">Tab 7</div>
				<div hlmTabsContent="8">Tab 8</div>
				<div hlmTabsContent="9">Tab 9</div>
				<div hlmTabsContent="10">Tab 10</div>
				<div hlmTabsContent="11">Tab 11</div>
				<div hlmTabsContent="12">Tab 12</div>
				<div hlmTabsContent="13">Tab 13</div>
				<div hlmTabsContent="14">Tab 14</div>
				<div hlmTabsContent="15">Tab 15</div>
				<div hlmTabsContent="16">Tab 16</div>
				<div hlmTabsContent="17">Tab 17</div>
				<div hlmTabsContent="18">Tab 18</div>
				<div hlmTabsContent="19">Tab 19</div>
				<div hlmTabsContent="20">Tab 20</div>
			</hlm-tabs>
		`,
	}),
};

export const BrnOnly: Story = {
	render: () => ({
		props: { activationMode: 'automatic' },
		template: /* HTML */ `
			<div brnTabs="account" [activationMode]="activationMode" class="mx-auto block max-w-3xl">
				<div brnTabsList class="grid w-full grid-cols-2" [attr.aria-label]="'tabs example'">
					<button brnTabsTrigger="account">Account</button>
					<button brnTabsTrigger="password">Password</button>
				</div>
				<div brnTabsContent="account">Account content</div>
				<div brnTabsContent="password">Password content</div>
			</div>
		`,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tabs/helm/README.md
```
# ui-tabs-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-tabs-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tabs/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {
			'@angular-eslint/template/interactive-supports-focus': 'off',
		},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tabs/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-tabs-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tabs/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/tabs/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tabs/helm/package.json
```json
{
	"name": "@spartan-ng/ui-tabs-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/cdk": ">=19.0.0",
		"@angular/core": ">=19.0.0",
		"@ng-icons/core": ">=29.0.0",
		"@ng-icons/lucide": ">=29.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"@spartan-ng/ui-button-helm": "0.0.1-alpha.381",
		"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
		"class-variance-authority": "^0.7.0",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tabs/helm/project.json
```json
{
	"name": "ui-tabs-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/tabs/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/tabs/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/tabs/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/tabs/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/tabs/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-tabs-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tabs/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tabs/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tabs/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tabs/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tabs/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { HlmTabsContentDirective } from './lib/hlm-tabs-content.directive';
import { HlmTabsListComponent } from './lib/hlm-tabs-list.component';
import { HlmTabsPaginatedListComponent } from './lib/hlm-tabs-paginated-list.component';
import { HlmTabsTriggerDirective } from './lib/hlm-tabs-trigger.directive';
import { HlmTabsComponent } from './lib/hlm-tabs.component';

export * from './lib/hlm-tabs-content.directive';
export * from './lib/hlm-tabs-list.component';
export * from './lib/hlm-tabs-paginated-list.component';
export * from './lib/hlm-tabs-trigger.directive';
export * from './lib/hlm-tabs.component';

export const HlmTabsImports = [
	HlmTabsComponent,
	HlmTabsListComponent,
	HlmTabsTriggerDirective,
	HlmTabsContentDirective,
	HlmTabsPaginatedListComponent,
] as const;

@NgModule({
	imports: [...HlmTabsImports],
	exports: [...HlmTabsImports],
})
export class HlmTabsModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tabs/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tabs/helm/src/lib/hlm-tabs-content.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnTabsContentDirective } from '@spartan-ng/brain/tabs';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmTabsContent]',
	standalone: true,
	hostDirectives: [{ directive: BrnTabsContentDirective, inputs: ['brnTabsContent: hlmTabsContent'] }],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmTabsContentDirective {
	public readonly contentFor = input.required<string>({ alias: 'hlmTabsContent' });

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tabs/helm/src/lib/hlm-tabs-list.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnTabsListDirective } from '@spartan-ng/brain/tabs';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const listVariants = cva(
	'inline-flex items-center justify-center rounded-md bg-muted p-1 text-muted-foreground',
	{
		variants: {
			orientation: {
				horizontal: 'h-10 space-x-1',
				vertical: 'mt-2 flex-col h-fit space-y-1',
			},
		},
		defaultVariants: {
			orientation: 'horizontal',
		},
	},
);
type ListVariants = VariantProps<typeof listVariants>;

@Component({
	selector: 'hlm-tabs-list',
	standalone: true,
	hostDirectives: [BrnTabsListDirective],
	template: '<ng-content/>',
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmTabsListComponent {
	public readonly orientation = input<ListVariants['orientation']>('horizontal');

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(listVariants({ orientation: this.orientation() }), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tabs/helm/src/lib/hlm-tabs-paginated-list.component.ts
```typescript
import { CdkObserveContent } from '@angular/cdk/observers';
import { Component, type ElementRef, computed, contentChildren, input, viewChild } from '@angular/core';
import { toObservable } from '@angular/core/rxjs-interop';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronLeft, lucideChevronRight } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { BrnTabsPaginatedListDirective, BrnTabsTriggerDirective } from '@spartan-ng/brain/tabs';
import { buttonVariants } from '@spartan-ng/ui-button-helm';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';
import { listVariants } from './hlm-tabs-list.component';

@Component({
	selector: 'hlm-paginated-tabs-list',
	imports: [CdkObserveContent, NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideChevronRight, lucideChevronLeft })],
	template: `
		<button
			#previousPaginator
			data-pagination="previous"
			type="button"
			aria-hidden="true"
			tabindex="-1"
			[class.flex]="_showPaginationControls()"
			[class.hidden]="!_showPaginationControls()"
			[class]="_paginationButtonClass()"
			[disabled]="_disableScrollBefore || null"
			(click)="_handlePaginatorClick('before')"
			(mousedown)="_handlePaginatorPress('before', $event)"
			(touchend)="_stopInterval()"
		>
			<ng-icon hlm size="base" name="lucideChevronLeft" />
		</button>

		<div #tabListContainer class="z-[1] flex grow overflow-hidden" (keydown)="_handleKeydown($event)">
			<div class="relative grow transition-transform" #tabList role="tablist" (cdkObserveContent)="_onContentChanges()">
				<div #tabListInner [class]="_tabListClass()">
					<ng-content></ng-content>
				</div>
			</div>
		</div>

		<button
			#nextPaginator
			data-pagination="next"
			type="button"
			aria-hidden="true"
			tabindex="-1"
			[class.flex]="_showPaginationControls()"
			[class.hidden]="!_showPaginationControls()"
			[class]="_paginationButtonClass()"
			[disabled]="_disableScrollAfter || null"
			(click)="_handlePaginatorClick('after')"
			(mousedown)="_handlePaginatorPress('after', $event)"
			(touchend)="_stopInterval()"
		>
			<ng-icon hlm size="base" name="lucideChevronRight" />
		</button>
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmTabsPaginatedListComponent extends BrnTabsPaginatedListDirective {
	public readonly _items = contentChildren(BrnTabsTriggerDirective, { descendants: false });
	public readonly _itemsChanges = toObservable(this._items);

	public readonly _tabListContainer = viewChild.required<ElementRef<HTMLElement>>('tabListContainer');
	public readonly _tabList = viewChild.required<ElementRef<HTMLElement>>('tabList');
	public readonly _tabListInner = viewChild.required<ElementRef<HTMLElement>>('tabListInner');
	public readonly _nextPaginator = viewChild.required<ElementRef<HTMLElement>>('nextPaginator');
	public readonly _previousPaginator = viewChild.required<ElementRef<HTMLElement>>('previousPaginator');

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm('flex overflow-hidden relative gap-1 flex-shrink-0', this.userClass()),
	);

	public readonly tabLisClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _tabListClass = computed(() => hlm(listVariants(), this.tabLisClass()));

	public readonly paginationButtonClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _paginationButtonClass = computed(() =>
		hlm(
			'relative z-[2] select-none disabled:cursor-default',
			buttonVariants({ variant: 'ghost', size: 'icon' }),
			this.paginationButtonClass(),
		),
	);

	protected _itemSelected(event: KeyboardEvent) {
		event.preventDefault();
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tabs/helm/src/lib/hlm-tabs-trigger.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnTabsTriggerDirective } from '@spartan-ng/brain/tabs';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmTabsTrigger]',
	standalone: true,
	hostDirectives: [{ directive: BrnTabsTriggerDirective, inputs: ['brnTabsTrigger: hlmTabsTrigger', 'disabled'] }],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmTabsTriggerDirective {
	public readonly triggerFor = input.required<string>({ alias: 'hlmTabsTrigger' });

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tabs/helm/src/lib/hlm-tabs.component.ts
```typescript
import { Component, input } from '@angular/core';
import { BrnTabsDirective } from '@spartan-ng/brain/tabs';

@Component({
	selector: 'hlm-tabs',
	standalone: true,
	hostDirectives: [
		{
			directive: BrnTabsDirective,
			inputs: ['orientation', 'direction', 'activationMode', 'brnTabs: tab'],
			outputs: ['tabActivated'],
		},
	],
	template: '<ng-content/>',
})
export class HlmTabsComponent {
	public readonly tab = input.required<string>();
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/pagination.stories.ts
```typescript
import { RouterTestingModule } from '@angular/router/testing';
import type { Meta, StoryObj } from '@storybook/angular';
import { moduleMetadata } from '@storybook/angular';
import { HlmPaginationDirective, HlmPaginationImports } from './helm/src';

const meta: Meta<HlmPaginationDirective> = {
	title: 'Pagination',
	component: HlmPaginationDirective,
	tags: ['autodocs'],
	decorators: [
		moduleMetadata({
			imports: [HlmPaginationImports, RouterTestingModule],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmPaginationDirective>;

export const Default: Story = {
	render: () => ({
		template: `
    <nav hlmPagination>
			<ul hlmPaginationContent>
				<li hlmPaginationItem>
					<hlm-pagination-previous link="#" />
				</li>
				<li hlmPaginationItem>
					<a hlmPaginationLink link="#">1</a>
				</li>
				<li hlmPaginationItem>
					<a hlmPaginationLink link="#" isActive>2</a>
				</li>
				<li hlmPaginationItem>
					<a hlmPaginationLink link="#">3</a>
				</li>
				<li hlmPaginationItem>
					<hlm-pagination-ellipsis />
				</li>
				<li hlmPaginationItem>
					<hlm-pagination-next link="#" />
				</li>
			</ul>
		</nav>
    `,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/helm/README.md
```
# ui-pagination-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-pagination-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {
			// ideally these would be enabled
			'@angular-eslint/template/click-events-have-key-events': 'off',
			'@angular-eslint/template/interactive-supports-focus': 'off',
		},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-pagination-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/pagination/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/helm/package.json
```json
{
	"name": "@spartan-ng/ui-pagination-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"peerDependencies": {
		"@angular/cdk": ">=19.0.0",
		"@angular/core": ">=19.0.0",
		"@angular/forms": ">=19.0.0",
		"@angular/router": ">=19.0.0",
		"@ng-icons/core": ">=29.0.0",
		"@ng-icons/lucide": ">=29.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"@spartan-ng/ui-button-helm": "0.0.1-alpha.381",
		"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
		"@spartan-ng/ui-select-helm": "0.0.1-alpha.381",
		"class-variance-authority": "^0.7.0",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/helm/project.json
```json
{
	"name": "ui-pagination-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/pagination/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/pagination/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/pagination/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/pagination/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/pagination/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-pagination-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { HlmNumberedPaginationComponent } from './lib/hlm-numbered-pagination.component';
import { HlmPaginationContentDirective } from './lib/hlm-pagination-content.directive';
import { HlmPaginationEllipsisComponent } from './lib/hlm-pagination-ellipsis.component';
import { HlmPaginationItemDirective } from './lib/hlm-pagination-item.directive';
import { HlmPaginationLinkDirective } from './lib/hlm-pagination-link.directive';
import { HlmPaginationNextComponent } from './lib/hlm-pagination-next.component';
import { HlmPaginationPreviousComponent } from './lib/hlm-pagination-previous.component';
import { HlmPaginationDirective } from './lib/hlm-pagination.directive';

export * from './lib/hlm-numbered-pagination.component';
export * from './lib/hlm-pagination-content.directive';
export * from './lib/hlm-pagination-ellipsis.component';
export * from './lib/hlm-pagination-item.directive';
export * from './lib/hlm-pagination-link.directive';
export * from './lib/hlm-pagination-next.component';
export * from './lib/hlm-pagination-previous.component';
export * from './lib/hlm-pagination.directive';

export const HlmPaginationImports = [
	HlmPaginationDirective,
	HlmPaginationContentDirective,
	HlmPaginationItemDirective,
	HlmPaginationLinkDirective,
	HlmPaginationPreviousComponent,
	HlmPaginationNextComponent,
	HlmPaginationEllipsisComponent,
	HlmNumberedPaginationComponent,
] as const;

@NgModule({
	imports: [...HlmPaginationImports],
	exports: [...HlmPaginationImports],
})
export class HlmPaginationModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/helm/src/lib/hlm-numbered-pagination.component.ts
```typescript
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import {
	ChangeDetectionStrategy,
	Component,
	booleanAttribute,
	computed,
	input,
	model,
	numberAttribute,
	untracked,
} from '@angular/core';
import { FormsModule } from '@angular/forms';
import { BrnSelectImports } from '@spartan-ng/brain/select';
import { HlmSelectImports } from '@spartan-ng/ui-select-helm';
import { HlmPaginationContentDirective } from './hlm-pagination-content.directive';
import { HlmPaginationEllipsisComponent } from './hlm-pagination-ellipsis.component';
import { HlmPaginationItemDirective } from './hlm-pagination-item.directive';
import { HlmPaginationLinkDirective } from './hlm-pagination-link.directive';
import { HlmPaginationNextComponent } from './hlm-pagination-next.component';
import { HlmPaginationPreviousComponent } from './hlm-pagination-previous.component';
import { HlmPaginationDirective } from './hlm-pagination.directive';

@Component({
	selector: 'hlm-numbered-pagination',
	template: `
		<div class="flex items-center justify-between gap-2 px-4 py-2">
			<div class="flex items-center gap-1 text-nowrap text-sm text-gray-600">
				<b>{{ totalItems() }}</b>
				total items |
				<b>{{ pages().length }}</b>
				pages
			</div>

			<nav hlmPagination>
				<ul hlmPaginationContent>
					@if (showEdges() && !isFirstPageActive()) {
						<li hlmPaginationItem (click)="goToPrevious()">
							<hlm-pagination-previous />
						</li>
					}

					@for (page of pages(); track page) {
						<li hlmPaginationItem>
							@if (page === '...') {
								<hlm-pagination-ellipsis />
							} @else {
								<a hlmPaginationLink [isActive]="currentPage() === page" (click)="currentPage.set(page)">
									{{ page }}
								</a>
							}
						</li>
					}

					@if (showEdges() && !isLastPageActive()) {
						<li hlmPaginationItem (click)="goToNext()">
							<hlm-pagination-next />
						</li>
					}
				</ul>
			</nav>

			<!-- Show Page Size selector -->
			<brn-select [(ngModel)]="itemsPerPage" class="ml-auto" placeholder="Page size">
				<hlm-select-trigger class="w-fit">
					<hlm-select-value />
				</hlm-select-trigger>
				<hlm-select-content>
					@for (pageSize of pageSizesWithCurrent(); track pageSize) {
						<hlm-option [value]="pageSize">{{ pageSize }} / page</hlm-option>
					}
				</hlm-select-content>
			</brn-select>
		</div>
	`,
	imports: [
		FormsModule,
		HlmPaginationDirective,
		HlmPaginationContentDirective,
		HlmPaginationItemDirective,
		HlmPaginationPreviousComponent,
		HlmPaginationNextComponent,
		HlmPaginationLinkDirective,
		HlmPaginationEllipsisComponent,
		BrnSelectImports,
		HlmSelectImports,
	],
	changeDetection: ChangeDetectionStrategy.OnPush,
})
export class HlmNumberedPaginationComponent {
	/**
	 * The current (active) page.
	 */
	public readonly currentPage = model.required<number>();

	/**
	 * The number of items per paginated page.
	 */
	public readonly itemsPerPage = model.required<number>();

	/**
	 * The total number of items in the collection. Only useful when
	 * doing server-side paging, where the collection size is limited
	 * to a single page returned by the server API.
	 */
	public readonly totalItems = input.required<number, NumberInput>({
		transform: numberAttribute,
	});

	/**
	 * The number of page links to show.
	 */
	public readonly maxSize = input<number, NumberInput>(7, {
		transform: numberAttribute,
	});

	/**
	 * Show the first and last page buttons.
	 */
	public readonly showEdges = input<boolean, BooleanInput>(true, {
		transform: booleanAttribute,
	});

	/**
	 * The page sizes to show.
	 * Defaults to [10, 20, 50, 100]
	 */
	public readonly pageSizes = input<number[]>([10, 20, 50, 100]);

	protected readonly pageSizesWithCurrent = computed(() => {
		const pageSizes = this.pageSizes();
		return pageSizes.includes(this.itemsPerPage())
			? pageSizes // if current page size is included, return the same array
			: [...pageSizes, this.itemsPerPage()].sort((a, b) => a - b); // otherwise, add current page size and sort the array
	});

	protected readonly isFirstPageActive = computed(() => this.currentPage() === 1);
	protected readonly isLastPageActive = computed(() => this.currentPage() === this.lastPageNumber());

	protected readonly lastPageNumber = computed(() => {
		if (this.totalItems() < 1) {
			// when there are 0 or fewer (an error case) items, there are no "pages" as such,
			// but it makes sense to consider a single, empty page as the last page.
			return 1;
		}
		return Math.ceil(this.totalItems() / this.itemsPerPage());
	});

	protected readonly pages = computed(() => {
		const correctedCurrentPage = outOfBoundCorrection(this.totalItems(), this.itemsPerPage(), this.currentPage());

		if (correctedCurrentPage !== this.currentPage()) {
			// update the current page
			untracked(() => this.currentPage.set(correctedCurrentPage));
		}

		return createPageArray(correctedCurrentPage, this.itemsPerPage(), this.totalItems(), this.maxSize());
	});

	protected goToPrevious(): void {
		this.currentPage.set(this.currentPage() - 1);
	}

	protected goToNext(): void {
		this.currentPage.set(this.currentPage() + 1);
	}

	protected goToFirst(): void {
		this.currentPage.set(1);
	}

	protected goToLast(): void {
		this.currentPage.set(this.lastPageNumber());
	}
}

type Page = number | '...';

/**
 * Checks that the instance.currentPage property is within bounds for the current page range.
 * If not, return a correct value for currentPage, or the current value if OK.
 *
 * Copied from 'ngx-pagination' package
 */
function outOfBoundCorrection(totalItems: number, itemsPerPage: number, currentPage: number): number {
	const totalPages = Math.ceil(totalItems / itemsPerPage);
	if (totalPages < currentPage && 0 < totalPages) {
		return totalPages;
	}

	if (currentPage < 1) {
		return 1;
	}

	return currentPage;
}

/**
 * Returns an array of Page objects to use in the pagination controls.
 *
 * Copied from 'ngx-pagination' package
 */
function createPageArray(
	currentPage: number,
	itemsPerPage: number,
	totalItems: number,
	paginationRange: number,
): Page[] {
	// paginationRange could be a string if passed from attribute, so cast to number.
	paginationRange = +paginationRange;
	const pages: Page[] = [];

	// Return 1 as default page number
	// Make sense to show 1 instead of empty when there are no items
	const totalPages = Math.max(Math.ceil(totalItems / itemsPerPage), 1);
	const halfWay = Math.ceil(paginationRange / 2);

	const isStart = currentPage <= halfWay;
	const isEnd = totalPages - halfWay < currentPage;
	const isMiddle = !isStart && !isEnd;

	const ellipsesNeeded = paginationRange < totalPages;
	let i = 1;

	while (i <= totalPages && i <= paginationRange) {
		let label: number | '...';
		const pageNumber = calculatePageNumber(i, currentPage, paginationRange, totalPages);
		const openingEllipsesNeeded = i === 2 && (isMiddle || isEnd);
		const closingEllipsesNeeded = i === paginationRange - 1 && (isMiddle || isStart);
		if (ellipsesNeeded && (openingEllipsesNeeded || closingEllipsesNeeded)) {
			label = '...';
		} else {
			label = pageNumber;
		}
		pages.push(label);
		i++;
	}

	return pages;
}

/**
 * Given the position in the sequence of pagination links [i],
 * figure out what page number corresponds to that position.
 *
 * Copied from 'ngx-pagination' package
 */
function calculatePageNumber(i: number, currentPage: number, paginationRange: number, totalPages: number) {
	const halfWay = Math.ceil(paginationRange / 2);
	if (i === paginationRange) {
		return totalPages;
	}

	if (i === 1) {
		return i;
	}

	if (paginationRange < totalPages) {
		if (totalPages - halfWay < currentPage) {
			return totalPages - paginationRange + i;
		}
		if (halfWay < currentPage) {
			return currentPage - halfWay + i;
		}
		return i;
	}

	return i;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/helm/src/lib/hlm-pagination-content.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import { ClassValue } from 'clsx';

export const paginationContentVariants = cva('flex flex-row items-center gap-1', {
	variants: {},
	defaultVariants: {},
});
export type PaginationContentVariants = VariantProps<typeof paginationContentVariants>;

@Directive({
	selector: '[hlmPaginationContent]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmPaginationContentDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm(paginationContentVariants(), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/helm/src/lib/hlm-pagination-ellipsis.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideEllipsis } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-pagination-ellipsis',
	imports: [NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideEllipsis })],
	template: `
		<span [class]="_computedClass()">
			<ng-icon hlm size="sm" name="lucideEllipsis" />
			<span class="sr-only">More pages</span>
		</span>
	`,
})
export class HlmPaginationEllipsisComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() => hlm('flex h-9 w-9 items-center justify-center', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/helm/src/lib/hlm-pagination-item.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import { ClassValue } from 'clsx';

export const paginationItemVariants = cva('', {
	variants: {},
	defaultVariants: {},
});

export type PaginationItemVariants = VariantProps<typeof paginationItemVariants>;

@Directive({
	selector: '[hlmPaginationItem]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmPaginationItemDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() => hlm(paginationItemVariants(), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/helm/src/lib/hlm-pagination-link.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { Directive, booleanAttribute, computed, input } from '@angular/core';
import { RouterLink } from '@angular/router';
import { hlm } from '@spartan-ng/brain/core';
import { type ButtonVariants, buttonVariants } from '@spartan-ng/ui-button-helm';
import { type VariantProps, cva } from 'class-variance-authority';
import { ClassValue } from 'clsx';

export const paginationLinkVariants = cva('', {
	variants: {},
	defaultVariants: {},
});
export type PaginationLinkVariants = VariantProps<typeof paginationLinkVariants>;

@Directive({
	selector: '[hlmPaginationLink]',
	standalone: true,
	hostDirectives: [
		{
			directive: RouterLink,
			inputs: [
				'target',
				'queryParams',
				'fragment',
				'queryParamsHandling',
				'state',
				'info',
				'relativeTo',
				'preserveFragment',
				'skipLocationChange',
				'replaceUrl',
				'routerLink: link',
			],
		},
	],
	host: {
		'[class]': '_computedClass()',
		'[attr.aria-current]': 'isActive() ? "page" : null',
	},
})
export class HlmPaginationLinkDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly isActive = input<boolean, BooleanInput>(false, { transform: booleanAttribute });
	public readonly size = input<ButtonVariants['size']>('icon');
	public readonly link = input<RouterLink['routerLink']>();

	protected readonly _computedClass = computed(() =>
		hlm(
			paginationLinkVariants(),
			this.link() === undefined ? 'cursor-pointer' : '',
			buttonVariants({
				variant: this.isActive() ? 'outline' : 'ghost',
				size: this.size(),
			}),
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/helm/src/lib/hlm-pagination-next.component.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { booleanAttribute, Component, computed, input } from '@angular/core';
import { RouterLink } from '@angular/router';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronRight } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { ButtonVariants } from '@spartan-ng/ui-button-helm';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import { ClassValue } from 'clsx';
import { HlmPaginationLinkDirective } from './hlm-pagination-link.directive';

@Component({
	selector: 'hlm-pagination-next',
	imports: [HlmPaginationLinkDirective, NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideChevronRight })],
	template: `
		<a
			[class]="_computedClass()"
			hlmPaginationLink
			[link]="link()"
			[queryParams]="queryParams()"
			[queryParamsHandling]="queryParamsHandling()"
			[size]="size()"
			[attr.aria-label]="ariaLabel()"
		>
			<span [class.sr-only]="iconOnly()">{{ text() }}</span>
			<ng-icon hlm size="sm" name="lucideChevronRight" />
		</a>
	`,
})
export class HlmPaginationNextComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly link = input<RouterLink['routerLink']>();
	public readonly queryParams = input<RouterLink['queryParams']>();
	public readonly queryParamsHandling = input<RouterLink['queryParamsHandling']>();

	public readonly ariaLabel = input<string>('Go to next page', { alias: 'aria-label' });
	public readonly text = input<string>('Next');
	public readonly iconOnly = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	protected readonly size = computed<ButtonVariants['size']>(() => (this.iconOnly() ? 'icon' : 'default'));

	protected readonly _computedClass = computed(() => hlm('gap-1', !this.iconOnly() ? 'pr-2.5' : '', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/helm/src/lib/hlm-pagination-previous.component.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { booleanAttribute, Component, computed, input } from '@angular/core';
import { RouterLink } from '@angular/router';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronLeft } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { ButtonVariants } from '@spartan-ng/ui-button-helm';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import { ClassValue } from 'clsx';
import { HlmPaginationLinkDirective } from './hlm-pagination-link.directive';

@Component({
	selector: 'hlm-pagination-previous',
	imports: [HlmPaginationLinkDirective, NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideChevronLeft })],
	template: `
		<a
			[class]="_computedClass()"
			hlmPaginationLink
			[link]="link()"
			[queryParams]="queryParams()"
			[queryParamsHandling]="queryParamsHandling()"
			[size]="size()"
			[attr.aria-label]="ariaLabel()"
		>
			<ng-icon hlm size="sm" name="lucideChevronLeft" />
			<span [class.sr-only]="iconOnly()">{{ text() }}</span>
		</a>
	`,
})
export class HlmPaginationPreviousComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly link = input<RouterLink['routerLink']>();
	public readonly queryParams = input<RouterLink['queryParams']>();
	public readonly queryParamsHandling = input<RouterLink['queryParamsHandling']>();

	public readonly ariaLabel = input<string>('Go to previous page', { alias: 'aria-label' });
	public readonly text = input<string>('Previous');
	public readonly iconOnly = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	protected readonly size = computed<ButtonVariants['size']>(() => (this.iconOnly() ? 'icon' : 'default'));

	protected readonly _computedClass = computed(() => hlm('gap-1', !this.iconOnly() ? 'pl-2.5' : '', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/pagination/helm/src/lib/hlm-pagination.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const paginationVariants = cva('mx-auto flex w-full justify-center', {
	variants: {},
	defaultVariants: {},
});
export type PaginationVariants = VariantProps<typeof paginationVariants>;

@Directive({
	selector: '[hlmPagination]',
	standalone: true,
	host: {
		role: 'navigation',
		'[class]': '_computedClass()',
		'[attr.aria-label]': 'ariaLabel()',
	},
})
export class HlmPaginationDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	public readonly ariaLabel = input<string>('pagination', { alias: 'aria-label' });

	protected readonly _computedClass = computed(() => hlm(paginationVariants(), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/storybook/README.md
```
# ui-storybook

This library was generated with [Nx](https://nx.dev).

## Running Storybook

Run `nx storybook ui-storybook` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/storybook/postcss.config.js
```javascript
const { join } = require('node:path');

module.exports = {
	plugins: {
		tailwindcss: {
			config: join(__dirname, 'tailwind.config.js'),
		},
		autoprefixer: {},
	},
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/storybook/project.json
```json
{
	"name": "ui-storybook",
	"$schema": "../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/storybook/src",
	"prefix": "spartan-ng",
	"tags": [],
	"projectType": "library",
	"targets": {
		"storybook": {
			"executor": "@storybook/angular:start-storybook",
			"options": {
				"port": 4400,
				"configDir": "libs/ui/storybook/.storybook",
				"browserTarget": "ui-storybook:build-storybook",
				"compodoc": false,
				"styles": ["libs/ui/storybook/.storybook/tailwind.css"]
			},
			"configurations": {
				"ci": {
					"quiet": true
				}
			}
		},
		"build-storybook": {
			"executor": "@storybook/angular:build-storybook",
			"outputs": ["{options.outputDir}"],
			"options": {
				"outputDir": "dist/storybook/ui-storybook",
				"configDir": "libs/ui/storybook/.storybook",
				"browserTarget": "ui-storybook:build-storybook",
				"compodoc": false,
				"styles": ["libs/ui/storybook/.storybook/tailwind.css"]
			},
			"configurations": {
				"ci": {
					"quiet": true
				}
			}
		},
		"static-storybook": {
			"executor": "@nx/web:file-server",
			"options": {
				"buildTarget": "ui-storybook:build-storybook",
				"staticFilePath": "dist/storybook/ui-storybook"
			},
			"configurations": {
				"ci": {
					"buildTarget": "ui-storybook:build-storybook:ci"
				}
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/storybook/tailwind.config.js
```javascript
const { createGlobPatternsForDependencies } = require('@nx/angular/tailwind');
const { join } = require('node:path');

/** @type {import('tailwindcss').Config} */
module.exports = {
	darkMode: ['class', '[data-mode="dark"]'],
	presets: [require('../../../libs/brain/hlm-tailwind-preset.js')],
	content: [join(__dirname, '../**/!(*.spec).{ts,html}'), ...createGlobPatternsForDependencies(__dirname)],
	theme: {
		extend: {},
	},
	plugins: [],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/storybook/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./.storybook/tsconfig.json"
		}
	],
	"extends": "../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/storybook/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": [
		"src/**/*.spec.ts",
		"src/test-setup.ts",
		"jest.config.ts",
		"src/**/*.test.ts",
		"**/*.stories.ts",
		"**/*.stories.js"
	],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/storybook/src/index.ts
```typescript
// placeholder as this project is simply a wrapper for
// running storybook for all ui primitives

console.log('I should not be an empty file!');

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tooltip/tooltip.stories.ts
```typescript
import { Component, signal } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucidePlus } from '@ng-icons/lucide';
import { BrnTooltipContentDirective } from '@spartan-ng/brain/tooltip';
import { type Meta, type StoryObj, argsToTemplate, moduleMetadata } from '@storybook/angular';
import { HlmButtonDirective } from '../button/helm/src';
import { HlmIconDirective } from '../icon/helm/src';
import { HlmTooltipComponent, HlmTooltipTriggerDirective } from './helm/src';

const meta: Meta<HlmTooltipComponent> = {
	title: 'Tooltip',
	component: HlmTooltipComponent,
	tags: ['autodocs'],
	argTypes: {},
	decorators: [
		moduleMetadata({
			imports: [
				HlmButtonDirective,
				HlmTooltipComponent,
				BrnTooltipContentDirective,
				HlmTooltipTriggerDirective,
				NgIcon,
				HlmIconDirective,
			],
			providers: [provideIcons({ lucidePlus })],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmTooltipComponent>;
export const Default: Story = {
	argTypes: {
		position: {
			control: { type: 'radio' },
			options: ['above', 'below', 'left', 'right'],
			defaultValue: 'above',
		},
	},
	render: ({ ...args }) => ({
		props: args,
		template: `
<div class='p-40'>
  <hlm-tooltip>
    <button hlmTooltipTrigger ${argsToTemplate(args)} aria-describedby='Hello world' hlmBtn variant='outline'>Test</button>
    <span *brnTooltipContent class='flex items-center'>
      Add to library <ng-icon hlm class='ml-2' size='sm' name='lucidePlus'/>
     </span>
  </hlm-tooltip>
</div>
`,
	}),
};

@Component({
	selector: 'simple-tooltip-story',
	standalone: true,
	imports: [
		HlmButtonDirective,
		HlmTooltipComponent,
		BrnTooltipContentDirective,
		HlmTooltipTriggerDirective,
		NgIcon,
		HlmIconDirective,
	],
	providers: [provideIcons({ lucidePlus })],
	template: `
		<div class="p-40">
			<button
				(click)="disabled.set(!disabled())"
				aria-describedby="Add to library"
				[hlmTooltipTrigger]="'Add to library'"
				[hlmTooltipDisabled]="disabled()"
				hlmBtn
				variant="icon"
			>
				<ng-icon hlm name="lucidePlus" size="sm" />
			</button>
		</div>
	`,
})
class SimpleTooltip {
	protected readonly disabled = signal(false);
}

export const Simple: Story = {
	render: () => ({
		moduleMetadata: {
			imports: [SimpleTooltip],
		},
		template: '<simple-tooltip-story/>',
	}),
};

@Component({
	selector: 'disabled-tooltip-story',
	standalone: true,
	imports: [
		HlmButtonDirective,
		HlmTooltipComponent,
		BrnTooltipContentDirective,
		HlmTooltipTriggerDirective,
		NgIcon,
		HlmIconDirective,
	],
	providers: [provideIcons({ lucidePlus })],
	template: `
		<div class="p-40">
			<hlm-tooltip>
				<button
					(click)="disabled.set(!disabled())"
					hlmTooltipTrigger
					[hlmTooltipDisabled]="disabled()"
					aria-describedby="Hello world"
					hlmBtn
					variant="outline"
				>
					Test
				</button>
				<span *brnTooltipContent class="flex items-center">
					Add to library
					<ng-icon hlm class="ml-2" size="sm" name="lucidePlus" />
				</span>
			</hlm-tooltip>
			<p>{{ disabled() ? 'disabled' : 'enabled' }}</p>
		</div>
	`,
})
class DisabledTooltip {
	protected readonly disabled = signal(false);
}

export const Disabled: Story = {
	render: () => ({
		moduleMetadata: {
			imports: [DisabledTooltip],
		},
		template: '<disabled-tooltip-story/>',
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tooltip/helm/README.md
```
# ui-tooltip-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-tooltip-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tooltip/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tooltip/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-tooltip-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tooltip/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/tooltip/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tooltip/helm/package.json
```json
{
	"name": "@spartan-ng/ui-tooltip-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tooltip/helm/project.json
```json
{
	"name": "ui-tooltip-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/tooltip/helm/src",
	"prefix": "helm",
	"tags": ["scope:helm"],
	"projectType": "library",
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/tooltip/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/tooltip/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/tooltip/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/tooltip/helm/jest.config.ts",
				"passWithNoTests": true
			},
			"configurations": {
				"ci": {
					"ci": true,
					"codeCoverage": true
				}
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"],
			"options": {
				"lintFilePatterns": [
					"libs/ui/tooltip/helm/**/*.ts",
					"libs/ui/tooltip/helm/**/*.html",
					"libs/ui/tooltip/helm/package.json",
					"libs/ui/tooltip/helm/project.json"
				]
			}
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-tooltip-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tooltip/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tooltip/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tooltip/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tooltip/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tooltip/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmTooltipTriggerDirective } from './lib/hlm-tooltip-trigger.directive';
import { HlmTooltipComponent } from './lib/hlm-tooltip.component';

export * from './lib/hlm-tooltip-trigger.directive';
export * from './lib/hlm-tooltip.component';

export const HlmTooltipImports = [HlmTooltipComponent, HlmTooltipTriggerDirective] as const;

@NgModule({
	imports: [...HlmTooltipImports],
	exports: [...HlmTooltipImports],
})
export class HlmTooltipModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tooltip/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tooltip/helm/src/lib/hlm-tooltip-trigger.directive.ts
```typescript
import { Directive } from '@angular/core';
import { BrnTooltipTriggerDirective, provideBrnTooltipDefaultOptions } from '@spartan-ng/brain/tooltip';

const DEFAULT_TOOLTIP_CONTENT_CLASSES =
	'overflow-hidden rounded-md border border-border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md fade-in-0 zoom-in-95 ' +
	'data-[state=open]:animate-in ' +
	'data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 ' +
	'data-[side=below]:slide-in-from-top-2 data-[side=above]:slide-in-from-bottom-2 ' +
	'data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 ';

@Directive({
	selector: '[hlmTooltipTrigger]',
	standalone: true,
	providers: [
		provideBrnTooltipDefaultOptions({
			showDelay: 150,
			hideDelay: 300,
			exitAnimationDuration: 150,
			tooltipContentClasses: DEFAULT_TOOLTIP_CONTENT_CLASSES,
		}),
	],
	hostDirectives: [
		{
			directive: BrnTooltipTriggerDirective,
			inputs: [
				'brnTooltipDisabled: hlmTooltipDisabled',
				'brnTooltipTrigger: hlmTooltipTrigger',
				'aria-describedby',
				'position',
				'positionAtOrigin',
				'hideDelay',
				'showDelay',
				'exitAnimationDuration',
				'touchGestures',
			],
		},
	],
})
export class HlmTooltipTriggerDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/tooltip/helm/src/lib/hlm-tooltip.component.ts
```typescript
import { ChangeDetectionStrategy, Component, ViewEncapsulation } from '@angular/core';
import { BrnTooltipDirective } from '@spartan-ng/brain/tooltip';

@Component({
	selector: 'hlm-tooltip',
	encapsulation: ViewEncapsulation.None,
	changeDetection: ChangeDetectionStrategy.OnPush,
	host: {
		'[style]': '{display: "contents"}',
	},
	hostDirectives: [BrnTooltipDirective],
	template: `
		<ng-content />
	`,
})
export class HlmTooltipComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input-otp/input-otp.stories.ts
```typescript
import { BrnInputOtpComponent } from '@spartan-ng/brain/input-otp';
import { type Meta, type StoryObj, moduleMetadata } from '@storybook/angular';
import {
	HlmInputOtpDirective,
	HlmInputOtpGroupDirective,
	HlmInputOtpSeparatorComponent,
	HlmInputOtpSlotComponent,
} from './helm/src/index';

const meta: Meta<BrnInputOtpComponent> = {
	title: 'Input OTP',
	component: BrnInputOtpComponent,
	tags: ['autodocs'],
	args: {},
	argTypes: {},
	decorators: [
		moduleMetadata({
			imports: [
				BrnInputOtpComponent,
				HlmInputOtpDirective,
				HlmInputOtpGroupDirective,
				HlmInputOtpSeparatorComponent,
				HlmInputOtpSlotComponent,
			],
		}),
	],
	render: ({ ...args }) => ({
		props: args,
		template: `
		<brn-input-otp hlm maxLength="6" inputClass="disabled:cursor-not-allowed">
			<div hlmInputOtpGroup>
				<hlm-input-otp-slot index="0" />
				<hlm-input-otp-slot index="1" />
				<hlm-input-otp-slot index="2" />
			</div>
			<hlm-input-otp-separator />
			<div hlmInputOtpGroup>
				<hlm-input-otp-slot index="3" />
				<hlm-input-otp-slot index="4" />
				<hlm-input-otp-slot index="5" />
			</div>
		</brn-input-otp>
		`,
	}),
};

export default meta;

type Story = StoryObj<BrnInputOtpComponent>;

export const Default: Story = {
	args: {},
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input-otp/helm/README.md
```
# ui-input-otp-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-input-otp-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input-otp/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input-otp/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-input-otp-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	coverageDirectory: '../../../../coverage/libs/button/helm',
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input-otp/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/input-otp/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input-otp/helm/package.json
```json
{
	"name": "@spartan-ng/ui-input-otp-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"peerDependencies": {
		"@angular/cdk": "19.2.2",
		"@angular/core": ">=19.0.0",
		"@ng-icons/core": "29.10.0",
		"@ng-icons/lucide": "30.3.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input-otp/helm/project.json
```json
{
	"name": "ui-input-otp-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/input-otp/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/input-otp/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/input-otp/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/input-otp/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/input-otp/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-input-otp-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input-otp/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input-otp/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input-otp/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input-otp/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input-otp/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmInputOtpFakeCaretComponent } from './lib/hlm-input-otp-fake-caret.component';
import { HlmInputOtpGroupDirective } from './lib/hlm-input-otp-group.directive';
import { HlmInputOtpSeparatorComponent } from './lib/hlm-input-otp-separator.component';
import { HlmInputOtpSlotComponent } from './lib/hlm-input-otp-slot.component';
import { HlmInputOtpDirective } from './lib/hlm-input-otp.directive';

export * from './lib/hlm-input-otp-fake-caret.component';
export * from './lib/hlm-input-otp-group.directive';
export * from './lib/hlm-input-otp-separator.component';
export * from './lib/hlm-input-otp-slot.component';
export * from './lib/hlm-input-otp.directive';

@NgModule({
	imports: [
		HlmInputOtpDirective,
		HlmInputOtpGroupDirective,
		HlmInputOtpSeparatorComponent,
		HlmInputOtpSlotComponent,
		HlmInputOtpFakeCaretComponent,
	],
	exports: [
		HlmInputOtpDirective,
		HlmInputOtpGroupDirective,
		HlmInputOtpSeparatorComponent,
		HlmInputOtpSlotComponent,
		HlmInputOtpFakeCaretComponent,
	],
})
export class HlmInputOtpModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input-otp/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input-otp/helm/src/lib/hlm-input-otp-fake-caret.component.ts
```typescript
import { Component } from '@angular/core';

@Component({
	selector: 'hlm-input-otp-fake-caret',
	standalone: true,
	template: `
		<div class="pointer-events-none absolute inset-0 flex items-center justify-center">
			<div class="animate-caret-blink bg-foreground h-4 w-px duration-1000"></div>
		</div>
	`,
})
export class HlmInputOtpFakeCaretComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input-otp/helm/src/lib/hlm-input-otp-group.directive.ts
```typescript
import { computed, Directive, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type ClassValue } from 'clsx';

@Directive({
	selector: '[hlmInputOtpGroup]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmInputOtpGroupDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() => hlm('flex items-center', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input-otp/helm/src/lib/hlm-input-otp-separator.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideDot } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import { type ClassValue } from 'clsx';

@Component({
	selector: 'hlm-input-otp-separator',
	imports: [HlmIconDirective, NgIcon],
	providers: [provideIcons({ lucideDot })],
	template: `
		<ng-icon hlm name="lucideDot" />
	`,
	host: {
		role: 'separator',
		'[class]': '_computedClass()',
	},
})
export class HlmInputOtpSeparatorComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() => hlm(this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input-otp/helm/src/lib/hlm-input-otp-slot.component.ts
```typescript
import { NumberInput } from '@angular/cdk/coercion';
import { Component, computed, input, numberAttribute } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnInputOtpSlotComponent } from '@spartan-ng/brain/input-otp';
import { type ClassValue } from 'clsx';
import { HlmInputOtpFakeCaretComponent } from './hlm-input-otp-fake-caret.component';

@Component({
	selector: 'hlm-input-otp-slot',
	imports: [BrnInputOtpSlotComponent, HlmInputOtpFakeCaretComponent],
	template: `
		<brn-input-otp-slot [index]="index()">
			<hlm-input-otp-fake-caret />
		</brn-input-otp-slot>
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmInputOtpSlotComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	public readonly index = input.required<number, NumberInput>({ transform: numberAttribute });

	protected readonly _computedClass = computed(() =>
		hlm(
			'relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md',
			'has-[brn-input-otp-slot[data-active="true"]]:z-10 has-[brn-input-otp-slot[data-active="true"]]:ring-2 has-[brn-input-otp-slot[data-active="true"]]:ring-ring has-[brn-input-otp-slot[data-active="true"]]:ring-offset-background',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input-otp/helm/src/lib/hlm-input-otp.directive.ts
```typescript
import { computed, Directive, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type ClassValue } from 'clsx';

@Directive({
	selector: 'brn-input-otp [hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmInputOtpDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm('flex items-center gap-2 has-[:disabled]:opacity-50', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/calendar/calendar.stories.ts
```typescript
import { type Meta, type StoryObj, moduleMetadata } from '@storybook/angular';
import { HlmCalendarComponent } from './helm/src/lib/hlm-calendar.component';

const meta: Meta<HlmCalendarComponent<Date>> = {
	title: 'Calendar',
	component: HlmCalendarComponent,
	tags: ['autodocs'],
	args: {},
	argTypes: {},
	decorators: [
		moduleMetadata({
			imports: [HlmCalendarComponent],
		}),
	],
	render: ({ ...args }) => ({
		props: args,
		template: `
		<div class="preview flex min-h-[350px] w-full justify-center p-10 items-center">
			<hlm-calendar [(date)]="date" [min]="min" [max]="max" />
		</div>
		`,
	}),
};

export default meta;

type Story = StoryObj<HlmCalendarComponent<Date>>;

export const Default: Story = {
	args: {
		date: new Date(2024, 5, 1),
		min: new Date(2024, 4, 1),
		max: new Date(2024, 6, 1),
	},
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/calendar/helm/README.md
```
# ui-calendar-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-calendar-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/calendar/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/calendar/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-calendar-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	coverageDirectory: '../../../../coverage/libs/ui/calendar/helm',
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/calendar/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/calendar/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/calendar/helm/package.json
```json
{
	"name": "@spartan-ng/ui-calendar-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"peerDependencies": {
		"@angular/cdk": ">=19.0.0",
		"@angular/core": ">=19.0.0",
		"@ng-icons/core": ">=29.0.0",
		"@ng-icons/lucide": ">=29.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"@spartan-ng/ui-button-helm": "0.0.1-alpha.381",
		"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
		"clsx": "^2.1.1"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/calendar/helm/project.json
```json
{
	"name": "ui-calendar-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/calendar/helm/src",
	"prefix": "brn",
	"projectType": "library",
	"tags": ["scope:help"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/calendar/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/calendar/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/calendar/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/calendar/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint"
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-calendar-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/calendar/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/calendar/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/calendar/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/calendar/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/calendar/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmCalendarMultiComponent } from './lib/hlm-calendar-multi.component';
import { HlmCalendarComponent } from './lib/hlm-calendar.component';

export * from './lib/hlm-calendar-multi.component';
export * from './lib/hlm-calendar.component';

export const HlmCalendarImports = [HlmCalendarComponent, HlmCalendarMultiComponent] as const;

@NgModule({
	imports: [...HlmCalendarImports],
	exports: [...HlmCalendarImports],
})
export class HlmCalendarModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/calendar/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/calendar/helm/src/lib/hlm-calendar-multi.component.ts
```typescript
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import { Component, booleanAttribute, computed, input, model, numberAttribute, viewChild } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronLeft, lucideChevronRight } from '@ng-icons/lucide';
import {
	BrnCalendarCellButtonDirective,
	BrnCalendarCellDirective,
	BrnCalendarGridDirective,
	BrnCalendarHeaderDirective,
	BrnCalendarMultiDirective,
	BrnCalendarNextButtonDirective,
	BrnCalendarPreviousButtonDirective,
	BrnCalendarWeekDirective,
	BrnCalendarWeekdayDirective,
	Weekday,
	injectBrnCalendarI18n,
} from '@spartan-ng/brain/calendar';
import { hlm } from '@spartan-ng/brain/core';
import { injectDateAdapter } from '@spartan-ng/brain/date-time';
import { buttonVariants } from '@spartan-ng/ui-button-helm';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-calendar-multi',
	imports: [
		BrnCalendarMultiDirective,
		BrnCalendarHeaderDirective,
		BrnCalendarNextButtonDirective,
		BrnCalendarPreviousButtonDirective,
		BrnCalendarWeekdayDirective,
		BrnCalendarWeekDirective,
		BrnCalendarCellButtonDirective,
		BrnCalendarCellDirective,
		BrnCalendarGridDirective,
		NgIcon,
		HlmIconDirective,
	],
	viewProviders: [provideIcons({ lucideChevronLeft, lucideChevronRight })],
	template: `
		<div
			brnCalendarMulti
			[min]="min()"
			[max]="max()"
			[minSelection]="minSelection()"
			[maxSelection]="maxSelection()"
			[disabled]="disabled()"
			[(date)]="date"
			[dateDisabled]="dateDisabled()"
			[weekStartsOn]="weekStartsOn()"
			[defaultFocusedDate]="defaultFocusedDate()"
			[class]="_computedCalenderClass()"
		>
			<div class="inline-flex flex-col space-y-4">
				<!-- Header -->
				<div class="space-y-4">
					<div class="relative flex items-center justify-center pt-1">
						<div brnCalendarHeader class="text-sm font-medium">
							{{ heading() }}
						</div>

						<div class="flex items-center space-x-1">
							<button
								brnCalendarPreviousButton
								class="ring-offset-background focus-visible:ring-ring border-input hover:bg-accent hover:text-accent-foreground absolute left-1 inline-flex h-7 w-7 items-center justify-center whitespace-nowrap rounded-md border bg-transparent p-0 text-sm font-medium opacity-50 transition-colors hover:opacity-100 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50"
							>
								<ng-icon hlm name="lucideChevronLeft" size="sm" />
							</button>

							<button
								brnCalendarNextButton
								class="ring-offset-background focus-visible:ring-ring border-input hover:bg-accent hover:text-accent-foreground absolute right-1 inline-flex h-7 w-7 items-center justify-center whitespace-nowrap rounded-md border bg-transparent p-0 text-sm font-medium opacity-50 transition-colors hover:opacity-100 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50"
							>
								<ng-icon hlm name="lucideChevronRight" size="sm" />
							</button>
						</div>
					</div>
				</div>

				<table class="w-full border-collapse space-y-1" brnCalendarGrid>
					<thead>
						<tr class="flex">
							<th
								*brnCalendarWeekday="let weekday"
								scope="col"
								class="text-muted-foreground w-9 rounded-md text-[0.8rem] font-normal"
								[attr.aria-label]="i18n.labelWeekday(weekday)"
							>
								{{ i18n.formatWeekdayName(weekday) }}
							</th>
						</tr>
					</thead>

					<tbody role="rowgroup">
						<tr *brnCalendarWeek="let week" class="mt-2 flex w-full">
							@for (date of week; track dateAdapter.getTime(date)) {
								<td
									brnCalendarCell
									class="data-[selected]:data-[outside]:bg-accent/50 data-[selected]:bg-accent relative h-9 w-9 p-0 text-center text-sm focus-within:relative focus-within:z-20 first:data-[selected]:rounded-l-md last:data-[selected]:rounded-r-md [&:has([aria-selected].day-range-end)]:rounded-r-md"
								>
									<button brnCalendarCellButton [date]="date" [class]="btnClass">
										{{ dateAdapter.getDate(date) }}
									</button>
								</td>
							}
						</tr>
					</tbody>
				</table>
			</div>
		</div>
	`,
})
export class HlmCalendarMultiComponent<T> {
	public readonly calendarClass = input<ClassValue>('');

	protected readonly _computedCalenderClass = computed(() => hlm('rounded-md border p-3', this.calendarClass()));

	/** Access the calendar i18n */
	protected readonly i18n = injectBrnCalendarI18n();

	/** Access the date time adapter */
	protected readonly dateAdapter = injectDateAdapter<T>();

	/** The minimum date that can be selected.*/
	public readonly min = input<T>();

	/** The maximum date that can be selected. */
	public readonly max = input<T>();

	/** The minimum selectable dates.  */
	public readonly minSelection = input<number, NumberInput>(undefined, {
		transform: numberAttribute,
	});

	/** The maximum selectable dates.  */
	public readonly maxSelection = input<number, NumberInput>(undefined, {
		transform: numberAttribute,
	});

	/** Determine if the date picker is disabled. */
	public readonly disabled = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** The selected value. */
	public readonly date = model<T[]>();

	/** Whether a specific date is disabled. */
	public readonly dateDisabled = input<(date: T) => boolean>(() => false);

	/** The day the week starts on */
	public readonly weekStartsOn = input<Weekday, NumberInput>(0, {
		transform: (v: unknown) => numberAttribute(v) as Weekday,
	});

	/** The default focused date. */
	public readonly defaultFocusedDate = input<T>();

	/** Access the calendar directive */
	private readonly _calendar = viewChild.required(BrnCalendarMultiDirective);

	/** Get the heading for the current month and year */
	protected heading = computed(() =>
		this.i18n.formatHeader(
			this.dateAdapter.getMonth(this._calendar().focusedDate()),
			this.dateAdapter.getYear(this._calendar().focusedDate()),
		),
	);

	protected readonly btnClass = hlm(
		buttonVariants({ variant: 'ghost' }),
		'h-9 w-9 p-0 font-normal aria-selected:opacity-100',
		'data-[outside]:text-muted-foreground data-[outside]:opacity-50 data-[outside]:aria-selected:bg-accent/50 data-[outside]:aria-selected:text-muted-foreground data-[outside]:aria-selected:opacity-30',
		'data-[today]:bg-accent data-[today]:text-accent-foreground',
		'data-[selected]:bg-primary data-[selected]:text-primary-foreground data-[selected]:hover:bg-primary data-[selected]:hover:text-primary-foreground data-[selected]:focus:bg-primary data-[selected]:focus:text-primary-foreground',
		'data-[disabled]:text-muted-foreground data-[disabled]:opacity-50',
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/calendar/helm/src/lib/hlm-calendar.component.ts
```typescript
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import { Component, booleanAttribute, computed, input, model, numberAttribute, viewChild } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronLeft, lucideChevronRight } from '@ng-icons/lucide';
import {
	BrnCalendarCellButtonDirective,
	BrnCalendarCellDirective,
	BrnCalendarDirective,
	BrnCalendarGridDirective,
	BrnCalendarHeaderDirective,
	BrnCalendarNextButtonDirective,
	BrnCalendarPreviousButtonDirective,
	BrnCalendarWeekDirective,
	BrnCalendarWeekdayDirective,
	Weekday,
	injectBrnCalendarI18n,
} from '@spartan-ng/brain/calendar';
import { hlm } from '@spartan-ng/brain/core';
import { injectDateAdapter } from '@spartan-ng/brain/date-time';
import { buttonVariants } from '@spartan-ng/ui-button-helm';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-calendar',
	imports: [
		BrnCalendarDirective,
		BrnCalendarHeaderDirective,
		BrnCalendarNextButtonDirective,
		BrnCalendarPreviousButtonDirective,
		BrnCalendarWeekdayDirective,
		BrnCalendarWeekDirective,
		BrnCalendarCellButtonDirective,
		BrnCalendarCellDirective,
		BrnCalendarGridDirective,
		NgIcon,
		HlmIconDirective,
	],
	viewProviders: [provideIcons({ lucideChevronLeft, lucideChevronRight })],
	template: `
		<div
			brnCalendar
			[min]="min()"
			[max]="max()"
			[disabled]="disabled()"
			[(date)]="date"
			[dateDisabled]="dateDisabled()"
			[weekStartsOn]="weekStartsOn()"
			[defaultFocusedDate]="defaultFocusedDate()"
			[class]="_computedCalenderClass()"
		>
			<div class="inline-flex flex-col space-y-4">
				<!-- Header -->
				<div class="space-y-4">
					<div class="relative flex items-center justify-center pt-1">
						<div brnCalendarHeader class="text-sm font-medium">
							{{ heading() }}
						</div>

						<div class="flex items-center space-x-1">
							<button
								brnCalendarPreviousButton
								class="ring-offset-background focus-visible:ring-ring border-input hover:bg-accent hover:text-accent-foreground absolute left-1 inline-flex h-7 w-7 items-center justify-center whitespace-nowrap rounded-md border bg-transparent p-0 text-sm font-medium opacity-50 transition-colors hover:opacity-100 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50"
							>
								<ng-icon hlm name="lucideChevronLeft" size="sm" />
							</button>

							<button
								brnCalendarNextButton
								class="ring-offset-background focus-visible:ring-ring border-input hover:bg-accent hover:text-accent-foreground absolute right-1 inline-flex h-7 w-7 items-center justify-center whitespace-nowrap rounded-md border bg-transparent p-0 text-sm font-medium opacity-50 transition-colors hover:opacity-100 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50"
							>
								<ng-icon hlm name="lucideChevronRight" size="sm" />
							</button>
						</div>
					</div>
				</div>

				<table class="w-full border-collapse space-y-1" brnCalendarGrid>
					<thead>
						<tr class="flex">
							<th
								*brnCalendarWeekday="let weekday"
								scope="col"
								class="text-muted-foreground w-9 rounded-md text-[0.8rem] font-normal"
								[attr.aria-label]="i18n.labelWeekday(weekday)"
							>
								{{ i18n.formatWeekdayName(weekday) }}
							</th>
						</tr>
					</thead>

					<tbody role="rowgroup">
						<tr *brnCalendarWeek="let week" class="mt-2 flex w-full">
							@for (date of week; track dateAdapter.getTime(date)) {
								<td
									brnCalendarCell
									class="data-[selected]:data-[outside]:bg-accent/50 data-[selected]:bg-accent relative h-9 w-9 p-0 text-center text-sm focus-within:relative focus-within:z-20 first:data-[selected]:rounded-l-md last:data-[selected]:rounded-r-md [&:has([aria-selected].day-range-end)]:rounded-r-md"
								>
									<button brnCalendarCellButton [date]="date" [class]="btnClass">
										{{ dateAdapter.getDate(date) }}
									</button>
								</td>
							}
						</tr>
					</tbody>
				</table>
			</div>
		</div>
	`,
})
export class HlmCalendarComponent<T> {
	public readonly calendarClass = input<ClassValue>('');

	protected readonly _computedCalenderClass = computed(() => hlm('rounded-md border p-3', this.calendarClass()));

	/** Access the calendar i18n */
	protected readonly i18n = injectBrnCalendarI18n();

	/** Access the date time adapter */
	protected readonly dateAdapter = injectDateAdapter<T>();

	/** The minimum date that can be selected.*/
	public readonly min = input<T>();

	/** The maximum date that can be selected. */
	public readonly max = input<T>();

	/** Determine if the date picker is disabled. */
	public readonly disabled = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** The selected value. */
	public readonly date = model<T>();

	/** Whether a specific date is disabled. */
	public readonly dateDisabled = input<(date: T) => boolean>(() => false);

	/** The day the week starts on */
	public readonly weekStartsOn = input<Weekday, NumberInput>(0, {
		transform: (v: unknown) => numberAttribute(v) as Weekday,
	});

	/** The default focused date. */
	public readonly defaultFocusedDate = input<T>();

	/** Access the calendar directive */
	private readonly _calendar = viewChild.required(BrnCalendarDirective);

	/** Get the heading for the current month and year */
	protected heading = computed(() =>
		this.i18n.formatHeader(
			this.dateAdapter.getMonth(this._calendar().focusedDate()),
			this.dateAdapter.getYear(this._calendar().focusedDate()),
		),
	);

	protected readonly btnClass = hlm(
		buttonVariants({ variant: 'ghost' }),
		'h-9 w-9 p-0 font-normal aria-selected:opacity-100',
		'data-[outside]:text-muted-foreground data-[outside]:opacity-50 data-[outside]:aria-selected:bg-accent/50 data-[outside]:aria-selected:text-muted-foreground data-[outside]:aria-selected:opacity-30',
		'data-[today]:bg-accent data-[today]:text-accent-foreground',
		'data-[selected]:bg-primary data-[selected]:text-primary-foreground data-[selected]:hover:bg-primary data-[selected]:hover:text-primary-foreground data-[selected]:focus:bg-primary data-[selected]:focus:text-primary-foreground',
		'data-[disabled]:text-muted-foreground data-[disabled]:opacity-50',
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/card/card.stories.ts
```typescript
import type { Meta, StoryObj } from '@storybook/angular';
import { moduleMetadata } from '@storybook/angular';
import { HlmBadgeDirective } from '../badge/helm/src';
import { HlmButtonDirective } from '../button/helm/src';
import { HlmInputDirective } from '../input/helm/src';
import { HlmLabelDirective } from '../label/helm/src';
import { HlmCardDirective, HlmCardImports } from './helm/src';

const meta: Meta<HlmCardDirective> = {
	title: 'Card',
	component: HlmCardDirective,
	tags: ['autodocs'],
	decorators: [
		moduleMetadata({
			imports: [HlmCardImports, HlmLabelDirective, HlmInputDirective, HlmButtonDirective, HlmBadgeDirective],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmCardDirective>;

export const Default: Story = {
	render: () => ({
		template: `
    <section class='max-w-lg mx-auto' hlmCard>
       <div hlmCardHeader>
        <h3 hlmCardTitle>Create new project</h3>
        <p hlmCardDescription>
          Deploy your new project in one-click.
        </p>
      </div>
      <p hlmCardContent>
       <label class='block' hlmLabel>Name
       <input class='w-full mt-1.5' placeholder='Name of your project' hlmInput>
       </label>

       <label class='block my-4' hlmLabel>Framework
       <select class='w-full mt-1.5' hlmInput>
        <option>Angular</option>
        <option>React</option>
        <option>Vue</option>
       </select>
       </label>
      </p>
      <div hlmCardFooter class='justify-between'>
        <button hlmBtn variant='ghost'>Cancel</button>
        <button hlmBtn>Create</button>
      </div>
    </section>
    `,
	}),
};

export const Transposed: Story = {
	render: () => ({
		template: `
    <section class='max-w-lg mx-auto' hlmCard>
       <div hlmCardHeader direction='row'>
        <h3 hlmCardTitle>AngularGPT</h3>
        <p hlmCardDescription>
          <span variant='secondary' hlmBadge>beta</span>
        </p>
      </div>
      <p hlmCardContent>
       <label class='block' hlmLabel>E-mail
       <input class='w-full mt-1.5' placeholder='you@spartan-ng' hlmInput>
       </label>
         <label class='block my-4' hlmLabel>Password
       <input class='w-full mt-1.5' type='password' hlmInput>
       </label>
      </p>
      <div hlmCardFooter direction='column'>
        <button hlmBtn>Sign In</button>
        <button hlmBtn variant='ghost'>Create Account</button>
      </div>
    </section>
    `,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/card/helm/README.md
```
# ui-card-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-card-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/card/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/card/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-card-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/card/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/card/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/card/helm/package.json
```json
{
	"name": "@spartan-ng/ui-card-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"class-variance-authority": "^0.7.0",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/card/helm/project.json
```json
{
	"name": "ui-card-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/card/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/card/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/card/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/card/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/card/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-card-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/card/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/card/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/card/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/card/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/card/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { HlmCardContentDirective } from './lib/hlm-card-content.directive';
import { HlmCardDescriptionDirective } from './lib/hlm-card-description.directive';
import { HlmCardFooterDirective } from './lib/hlm-card-footer.directive';
import { HlmCardHeaderDirective } from './lib/hlm-card-header.directive';
import { HlmCardTitleDirective } from './lib/hlm-card-title.directive';
import { HlmCardDirective } from './lib/hlm-card.directive';

export * from './lib/hlm-card-content.directive';
export * from './lib/hlm-card-description.directive';
export * from './lib/hlm-card-footer.directive';
export * from './lib/hlm-card-header.directive';
export * from './lib/hlm-card-title.directive';
export * from './lib/hlm-card.directive';

export const HlmCardImports = [
	HlmCardDirective,
	HlmCardHeaderDirective,
	HlmCardFooterDirective,
	HlmCardTitleDirective,
	HlmCardDescriptionDirective,
	HlmCardContentDirective,
] as const;

@NgModule({
	imports: [...HlmCardImports],
	exports: [...HlmCardImports],
})
export class HlmCardModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/card/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/card/helm/src/lib/hlm-card-content.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const cardContentVariants = cva('p-6 pt-0', {
	variants: {},
	defaultVariants: {},
});
export type CardContentVariants = VariantProps<typeof cardContentVariants>;

@Directive({
	selector: '[hlmCardContent]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCardContentDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(cardContentVariants(), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/card/helm/src/lib/hlm-card-description.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const cardDescriptionVariants = cva('text-sm text-muted-foreground', {
	variants: {},
	defaultVariants: {},
});
export type CardDescriptionVariants = VariantProps<typeof cardDescriptionVariants>;

@Directive({
	selector: '[hlmCardDescription]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCardDescriptionDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(cardDescriptionVariants(), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/card/helm/src/lib/hlm-card-footer.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const cardFooterVariants = cva('flex p-6 pt-0', {
	variants: {
		direction: {
			row: 'flex-row items-center space-x-1.5',
			column: 'flex-col space-y-1.5',
		},
	},
	defaultVariants: {
		direction: 'row',
	},
});
export type CardFooterVariants = VariantProps<typeof cardFooterVariants>;

@Directive({
	selector: '[hlmCardFooter]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCardFooterDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(cardFooterVariants({ direction: this.direction() }), this.userClass()));

	public readonly direction = input<CardFooterVariants['direction']>('row');
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/card/helm/src/lib/hlm-card-header.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const cardHeaderVariants = cva('flex p-6', {
	variants: {
		direction: {
			row: 'flex-row items-center space-x-1.5',
			column: 'flex-col space-y-1.5',
		},
	},
	defaultVariants: {
		direction: 'column',
	},
});
export type CardHeaderVariants = VariantProps<typeof cardHeaderVariants>;

@Directive({
	selector: '[hlmCardHeader]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCardHeaderDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(cardHeaderVariants({ direction: this.direction() }), this.userClass()));

	public readonly direction = input<CardHeaderVariants['direction']>('column');
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/card/helm/src/lib/hlm-card-title.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const cardTitleVariants = cva('text-lg font-semibold leading-none tracking-tight', {
	variants: {},
	defaultVariants: {},
});
export type CardTitleVariants = VariantProps<typeof cardTitleVariants>;

@Directive({
	selector: '[hlmCardTitle]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCardTitleDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(cardTitleVariants(), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/card/helm/src/lib/hlm-card.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const cardVariants = cva(
	'rounded-lg border border-border bg-card focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 text-card-foreground shadow-sm',
	{
		variants: {},
		defaultVariants: {},
	},
);
export type CardVariants = VariantProps<typeof cardVariants>;

@Directive({
	selector: '[hlmCard]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCardDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(cardVariants(), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/core/package.json
```json

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/progress/progress.stories.ts
```typescript
import { BrnProgressComponent, BrnProgressImports } from '@spartan-ng/brain/progress';
import { type Meta, type StoryObj, argsToTemplate, moduleMetadata } from '@storybook/angular';
import { HlmLabelDirective } from '../label/helm/src';
import { HlmProgressImports } from './helm/src';

const meta: Meta<BrnProgressComponent> = {
	title: 'Progress',
	component: BrnProgressComponent,
	tags: ['autodocs'],
	args: {
		value: 30,
	},
	argTypes: {
		value: {
			control: { type: 'range', min: 0, max: 100, step: 2 },
		},
	},
	decorators: [
		moduleMetadata({
			imports: [BrnProgressImports, HlmProgressImports, HlmLabelDirective],
		}),
	],
};

export default meta;
type Story = StoryObj<BrnProgressComponent>;

export const LoadingNotStarted: Story = {
	args: {
		value: 0,
	},
	render: ({ ...args }) => ({
		props: { ...args },
		template: `
    <h2 hlmLabel id='loading'>Loading (not started)</h2>
    <brn-progress class='mt-2 mb-8' aria-labelledby='loading' hlm ${argsToTemplate(args)}>
      <brn-progress-indicator hlm/>
    </brn-progress>
    `,
	}),
};

export const LoadingStarted: Story = {
	render: ({ ...args }) => ({
		props: { ...args },
		template: `
    <h2 hlmLabel id='loading'>Loading (started)</h2>
    <brn-progress class='mt-2 mb-8' aria-labelledby='loading started' hlm ${argsToTemplate(args)}>
      <brn-progress-indicator hlm/>
    </brn-progress>
    `,
	}),
};

export const Indeterminate: Story = {
	args: {
		value: null,
	},
	render: ({ ...args }) => ({
		props: args,
		template: `
    <h2 hlmLabel id='indeterminate'>Indeterminate</h2>
    <brn-progress class='mt-2 mb-8' aria-labelledby='indeterminate' hlm ${argsToTemplate(args)}>
      <brn-progress-indicator hlm/>
    </brn-progress>
    `,
	}),
};

export const Complete: Story = {
	args: {
		value: 100,
	},
	render: ({ ...args }) => ({
		props: args,
		template: `
    <h2 hlmLabel id='complete'>Complete</h2>
    <brn-progress class='mt-2 mb-8' aria-labelledby='complete' hlm ${argsToTemplate(args)}>
      <brn-progress-indicator hlm/>
    </brn-progress>
    `,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/progress/helm/README.md
```
# ui-progress-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-progress-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/progress/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/progress/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-progress-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/progress/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/progress/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/progress/helm/package.json
```json
{
	"name": "@spartan-ng/ui-progress-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/progress/helm/project.json
```json
{
	"name": "ui-progress-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/progress/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/progress/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/progress/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/progress/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/progress/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-progress-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/progress/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/progress/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/progress/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/progress/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/progress/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { HlmProgressIndicatorDirective } from './lib/hlm-progress-indicator.directive';
import { HlmProgressDirective } from './lib/hlm-progress.directive';

export * from './lib/hlm-progress-indicator.directive';
export * from './lib/hlm-progress.directive';

export const HlmProgressImports = [HlmProgressDirective, HlmProgressIndicatorDirective] as const;

@NgModule({
	imports: [...HlmProgressImports],
	exports: [...HlmProgressImports],
})
export class HlmProgressModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/progress/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/progress/helm/src/lib/hlm-progress-indicator.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { injectBrnProgress } from '@spartan-ng/brain/progress';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmProgressIndicator],brn-progress-indicator[hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		'[class.animate-indeterminate]': 'indeterminate()',
		'[style.transform]': 'transform()',
	},
})
export class HlmProgressIndicatorDirective {
	private readonly _progress = injectBrnProgress();
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm('inline-flex transform-gpu h-full w-full flex-1 bg-primary transition-all', this.userClass()),
	);

	protected readonly transform = computed(() => `translateX(-${100 - (this._progress.value() ?? 100)}%)`);

	protected readonly indeterminate = computed(
		() => this._progress.value() === null || this._progress.value() === undefined,
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/progress/helm/src/lib/hlm-progress.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmProgress],brn-progress[hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmProgressDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm('inline-flex relative h-4 w-full overflow-hidden rounded-full bg-secondary', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/alert-dialog.stories.ts
```typescript
import { BrnAlertDialogImports } from '@spartan-ng/brain/alert-dialog';
import { type Meta, type StoryObj, moduleMetadata } from '@storybook/angular';
import { HlmButtonDirective } from '../button/helm/src';
import { HlmAlertDialogComponent, HlmAlertDialogImports } from './helm/src';

const meta: Meta<HlmAlertDialogComponent> = {
	title: 'Alert Dialog',
	component: HlmAlertDialogComponent,
	tags: ['autodocs'],
	args: {},
	argTypes: {},
	decorators: [
		moduleMetadata({
			imports: [BrnAlertDialogImports, HlmAlertDialogImports, HlmButtonDirective],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmAlertDialogComponent>;

export const Default: Story = {
	render: () => ({
		template: `
    <hlm-alert-dialog>
      <button id='delete-account' variant='outline' brnAlertDialogTrigger hlmBtn>Delete Account</button>
      <hlm-alert-dialog-content *brnAlertDialogContent='let ctx'>
           <hlm-alert-dialog-header>
            <h3 hlmAlertDialogTitle>Are you absolutely sure?</h3>
            <p hlmAlertDialogDescription>
            This action cannot be undone. This will permanently delete your
            account and remove your data from our servers.
            </p>
          </hlm-alert-dialog-header>
          <hlm-alert-dialog-footer>
            <button hlmAlertDialogCancel (click)='ctx.close()'>Cancel</button>
            <button hlmAlertDialogAction type='submit'>Delete account</button>
          </hlm-alert-dialog-footer>
      </hlm-alert-dialog-content>
    </hlm-alert-dialog>
    `,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/README.md
```
# ui-alert-dialog-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-alert-dialog-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-alert-dialog-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/alert-dialog/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/package.json
```json
{
	"name": "@spartan-ng/ui-alertdialog-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"@spartan-ng/ui-button-helm": "0.0.1-alpha.381",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/project.json
```json
{
	"name": "ui-alert-dialog-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/alert-dialog/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/alert-dialog/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/alert-dialog/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/alert-dialog/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/alert-dialog/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-alert-dialog-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { HlmAlertDialogActionButtonDirective } from './lib/hlm-alert-dialog-action-button.directive';
import { HlmAlertDialogCancelButtonDirective } from './lib/hlm-alert-dialog-cancel-button.directive';
import { HlmAlertDialogContentComponent } from './lib/hlm-alert-dialog-content.component';
import { HlmAlertDialogDescriptionDirective } from './lib/hlm-alert-dialog-description.directive';
import { HlmAlertDialogFooterComponent } from './lib/hlm-alert-dialog-footer.component';
import { HlmAlertDialogHeaderComponent } from './lib/hlm-alert-dialog-header.component';
import { HlmAlertDialogOverlayDirective } from './lib/hlm-alert-dialog-overlay.directive';
import { HlmAlertDialogTitleDirective } from './lib/hlm-alert-dialog-title.directive';
import { HlmAlertDialogComponent } from './lib/hlm-alert-dialog.component';

export * from './lib/hlm-alert-dialog-action-button.directive';
export * from './lib/hlm-alert-dialog-cancel-button.directive';
export * from './lib/hlm-alert-dialog-content.component';
export * from './lib/hlm-alert-dialog-description.directive';
export * from './lib/hlm-alert-dialog-footer.component';
export * from './lib/hlm-alert-dialog-header.component';
export * from './lib/hlm-alert-dialog-overlay.directive';
export * from './lib/hlm-alert-dialog-title.directive';
export * from './lib/hlm-alert-dialog.component';

export const HlmAlertDialogImports = [
	HlmAlertDialogContentComponent,
	HlmAlertDialogDescriptionDirective,
	HlmAlertDialogFooterComponent,
	HlmAlertDialogHeaderComponent,
	HlmAlertDialogOverlayDirective,
	HlmAlertDialogTitleDirective,
	HlmAlertDialogActionButtonDirective,
	HlmAlertDialogCancelButtonDirective,
	HlmAlertDialogComponent,
] as const;

@NgModule({
	imports: [...HlmAlertDialogImports],
	exports: [...HlmAlertDialogImports],
})
export class HlmAlertDialogModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/src/lib/hlm-alert-dialog-action-button.directive.ts
```typescript
import { Directive } from '@angular/core';
import { HlmButtonDirective } from '@spartan-ng/ui-button-helm';

@Directive({
	selector: 'button[hlmAlertDialogAction]',
	standalone: true,
	hostDirectives: [HlmButtonDirective],
})
export class HlmAlertDialogActionButtonDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/src/lib/hlm-alert-dialog-cancel-button.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { HlmButtonDirective, provideBrnButtonConfig } from '@spartan-ng/ui-button-helm';
import type { ClassValue } from 'clsx';

@Directive({
	selector: 'button[hlmAlertDialogCancel]',
	standalone: true,
	hostDirectives: [HlmButtonDirective],
	providers: [provideBrnButtonConfig({ variant: 'outline' })],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmAlertDialogCancelButtonDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm('mt-2 sm:mt-0', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/src/lib/hlm-alert-dialog-content.component.ts
```typescript
import { ChangeDetectionStrategy, Component, ViewEncapsulation, computed, input, signal } from '@angular/core';
import { hlm, injectExposesStateProvider } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-alert-dialog-content',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		'[attr.data-state]': 'state()',
	},
	template: `
		<ng-content />
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class HlmAlertDialogContentComponent {
	private readonly _stateProvider = injectExposesStateProvider({ optional: true, host: true });
	public readonly state = this._stateProvider?.state ?? signal('closed');

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'relative grid w-full max-w-lg gap-4 border-border border bg-background p-6 shadow-lg [animation-duration:200] data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-top-[2%]  data-[state=open]:slide-in-from-top-[2%] sm:rounded-lg md:w-full',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/src/lib/hlm-alert-dialog-description.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { BrnAlertDialogDescriptionDirective } from '@spartan-ng/brain/alert-dialog';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmAlertDialogDescription]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnAlertDialogDescriptionDirective],
})
export class HlmAlertDialogDescriptionDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm('text-sm text-muted-foreground', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/src/lib/hlm-alert-dialog-footer.component.ts
```typescript
import { ChangeDetectionStrategy, Component, ViewEncapsulation, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-alert-dialog-footer',
	standalone: true,
	template: `
		<ng-content />
	`,
	host: {
		'[class]': '_computedClass()',
	},
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class HlmAlertDialogFooterComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm('flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/src/lib/hlm-alert-dialog-header.component.ts
```typescript
import { ChangeDetectionStrategy, Component, ViewEncapsulation, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-alert-dialog-header',
	standalone: true,
	template: `
		<ng-content />
	`,
	host: {
		'[class]': '_computedClass()',
	},
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class HlmAlertDialogHeaderComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm('flex flex-col space-y-2 text-center sm:text-left', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/src/lib/hlm-alert-dialog-overlay.directive.ts
```typescript
import { Directive, computed, effect, input, untracked } from '@angular/core';
import { hlm, injectCustomClassSettable } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmAlertDialogOverlay],brn-alert-dialog-overlay[hlm]',
	standalone: true,
})
export class HlmAlertDialogOverlayDirective {
	private readonly _classSettable = injectCustomClassSettable({ optional: true, host: true });

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
			this.userClass(),
		),
	);

	constructor() {
		effect(() => {
			const classValue = this._computedClass();
			untracked(() => this._classSettable?.setClassToCustomElement(classValue));
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/src/lib/hlm-alert-dialog-title.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { BrnAlertDialogTitleDirective } from '@spartan-ng/brain/alert-dialog';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmAlertDialogTitle]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnAlertDialogTitleDirective],
})
export class HlmAlertDialogTitleDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm('text-lg font-semibold', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert-dialog/helm/src/lib/hlm-alert-dialog.component.ts
```typescript
import { ChangeDetectionStrategy, Component, forwardRef, ViewEncapsulation } from '@angular/core';
import {
	BRN_ALERT_DIALOG_DEFAULT_OPTIONS,
	BrnAlertDialogComponent,
	BrnAlertDialogOverlayComponent,
} from '@spartan-ng/brain/alert-dialog';
import { BrnDialogComponent, provideBrnDialogDefaultOptions } from '@spartan-ng/brain/dialog';
import { HlmAlertDialogOverlayDirective } from './hlm-alert-dialog-overlay.directive';

@Component({
	selector: 'hlm-alert-dialog',
	template: `
		<brn-alert-dialog-overlay hlm />
		<ng-content />
	`,
	providers: [
		{
			provide: BrnDialogComponent,
			useExisting: forwardRef(() => HlmAlertDialogComponent),
		},
		provideBrnDialogDefaultOptions({
			...BRN_ALERT_DIALOG_DEFAULT_OPTIONS,
		}),
	],
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	exportAs: 'hlmAlertDialog',
	imports: [BrnAlertDialogOverlayComponent, HlmAlertDialogOverlayDirective],
})
export class HlmAlertDialogComponent extends BrnAlertDialogComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input/input.stories.ts
```typescript
import { FormsModule } from '@angular/forms';
import { type Meta, type StoryObj, argsToTemplate, moduleMetadata } from '@storybook/angular';
import { HlmButtonDirective } from '../button/helm/src';
import { HlmLabelDirective } from '../label/helm/src';
import { HlmInputDirective } from './helm/src';

const meta: Meta<HlmInputDirective> = {
	title: 'Input',
	component: HlmInputDirective,
	tags: ['autodocs'],
	args: {
		size: 'default',
		error: 'auto',
	},
	argTypes: {
		size: {
			options: ['default', 'sm', 'lg'],
			control: {
				type: 'select',
			},
		},
		error: {
			options: ['auto', 'true'],
			control: {
				type: 'select',
			},
		},
	},
	decorators: [
		moduleMetadata({
			imports: [HlmInputDirective, HlmLabelDirective, HlmButtonDirective, FormsModule],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmInputDirective>;

export const Default: Story = {
	render: ({ ...args }) => ({
		props: args,
		template: `
    <input aria-label='Email' class='w-80' hlmInput ${argsToTemplate(args)} type='email' placeholder='Email'/>
    `,
	}),
};

export const File: Story = {
	render: ({ ...args }) => ({
		props: args,
		template: `
    <div class="grid w-full max-w-sm items-center gap-1.5">
      <label hlmLabel for="picture">Picture</label>
      <input class='w-80' hlmInput ${argsToTemplate(args)} id="picture" type="file" />
    </div>`,
	}),
};

export const Disabled: Story = {
	render: ({ ...args }) => ({
		props: args,
		template: `
    <input aria-label='Email' disabled class='w-80' hlmInput ${argsToTemplate(args)} type='email' placeholder='Email'/>
    `,
	}),
};

export const Required: Story = {
	render: ({ ...args }) => ({
		props: { value: '', ...args },
		template: `
    <input aria-label='Email *' [(ngModel)]="value" class='w-80' hlmInput ${argsToTemplate(args)} type='email' required placeholder='Email *'/>
    `,
	}),
};

export const Error: Story = {
	render: ({ ...args }) => ({
		props: { ...args, error: 'true' },
		template: `
    <input aria-label='Email' class='w-80' hlmInput ${argsToTemplate(args)} type='email' placeholder='Email' />
    `,
	}),
};

export const WithButton: Story = {
	name: 'With Button',
	render: ({ ...args }) => ({
		props: args,
		template: `
    <div class="flex items-center w-full max-w-sm space-x-2">
    <input aria-label='Email' class='w-80' hlmInput ${argsToTemplate(args)} type='email' placeholder='Email'/>
    <button hlmBtn>Subscribe</button>
    </div>
    `,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input/helm/README.md
```
# ui-input-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-input-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-input-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	coverageDirectory: '../../../../coverage/libs/button/helm',
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/input/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input/helm/package.json
```json
{
	"name": "@spartan-ng/ui-input-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@angular/forms": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"class-variance-authority": "^0.7.0",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input/helm/project.json
```json
{
	"name": "ui-input-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/input/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/input/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/input/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/input/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/input/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-input-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmInputErrorDirective } from './lib/hlm-input-error.directive';
import { HlmInputDirective } from './lib/hlm-input.directive';

export * from './lib/hlm-input-error.directive';
export * from './lib/hlm-input.directive';

@NgModule({
	imports: [HlmInputDirective, HlmInputErrorDirective],
	exports: [HlmInputDirective, HlmInputErrorDirective],
})
export class HlmInputModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input/helm/src/lib/hlm-input-error.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const inputErrorVariants = cva('text-destructive text-sm font-medium', {
	variants: {},
	defaultVariants: {},
});
export type InputErrorVariants = VariantProps<typeof inputErrorVariants>;

@Directive({
	selector: '[hlmInputError]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmInputErrorDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(inputErrorVariants(), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/input/helm/src/lib/hlm-input.directive.ts
```typescript
import { Directive, type DoCheck, Injector, computed, effect, inject, input, signal, untracked } from '@angular/core';
import { FormGroupDirective, NgControl, NgForm } from '@angular/forms';
import { hlm } from '@spartan-ng/brain/core';
import { BrnFormFieldControl } from '@spartan-ng/brain/form-field';
import { ErrorStateMatcher, ErrorStateTracker } from '@spartan-ng/brain/forms';

import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const inputVariants = cva(
	'flex rounded-md border font-normal border-input bg-transparent text-base md:text-sm ring-offset-background file:border-0 file:text-foreground file:bg-transparent file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
	{
		variants: {
			size: {
				default: 'h-10 py-2 px-4 file:max-md:py-0',
				sm: 'h-9 px-3 file:md:py-2 file:max-md:py-1.5',
				lg: 'h-11 px-8 file:md:py-3 file:max-md:py-2.5',
			},
			error: {
				auto: '[&.ng-invalid.ng-touched]:text-destructive [&.ng-invalid.ng-touched]:border-destructive [&.ng-invalid.ng-touched]:focus-visible:ring-destructive',
				true: 'text-destructive border-destructive focus-visible:ring-destructive',
			},
		},
		defaultVariants: {
			size: 'default',
			error: 'auto',
		},
	},
);
type InputVariants = VariantProps<typeof inputVariants>;

@Directive({
	selector: '[hlmInput]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	providers: [
		{
			provide: BrnFormFieldControl,
			useExisting: HlmInputDirective,
		},
	],
})
export class HlmInputDirective implements BrnFormFieldControl, DoCheck {
	public readonly size = input<InputVariants['size']>('default');

	public readonly error = input<InputVariants['error']>('auto');

	protected readonly state = computed(() => ({
		error: signal(this.error()),
	}));

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(inputVariants({ size: this.size(), error: this.state().error() }), this.userClass()),
	);

	private readonly _injector = inject(Injector);

	public readonly ngControl: NgControl | null = this._injector.get(NgControl, null);

	private readonly _errorStateTracker: ErrorStateTracker;

	private readonly _defaultErrorStateMatcher = inject(ErrorStateMatcher);
	private readonly _parentForm = inject(NgForm, { optional: true });
	private readonly _parentFormGroup = inject(FormGroupDirective, { optional: true });

	public readonly errorState = computed(() => this._errorStateTracker.errorState());

	constructor() {
		this._errorStateTracker = new ErrorStateTracker(
			this._defaultErrorStateMatcher,
			this.ngControl,
			this._parentFormGroup,
			this._parentForm,
		);

		effect(() => {
			const error = this._errorStateTracker.errorState();
			untracked(() => {
				if (this.ngControl) {
					this.setError(error);
				}
			});
		});
	}

	ngDoCheck() {
		this._errorStateTracker.updateErrorState();
	}

	setError(error: InputVariants['error']) {
		this.state().error.set(error);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert/alert.stories.ts
```typescript
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideCircleAlert, lucideInfo } from '@ng-icons/lucide';
import type { Meta, StoryObj } from '@storybook/angular';
import { argsToTemplate, moduleMetadata } from '@storybook/angular';
import { HlmIconDirective } from '../icon/helm/src';
import { HlmAlertDirective, HlmAlertImports } from './helm/src';

const meta: Meta<HlmAlertDirective> = {
	title: 'Alert',
	component: HlmAlertDirective,
	tags: ['autodocs'],
	argTypes: {
		variant: {
			options: ['default', 'destructive'],
			control: {
				type: 'select',
			},
		},
	},
	decorators: [
		moduleMetadata({
			imports: [HlmAlertImports, NgIcon, HlmIconDirective],
			providers: [provideIcons({ lucideInfo, lucideCircleAlert })],
		}),
	],
	render: ({ ...args }) => ({
		props: args,
		template: `
     <div class='max-w-xl' hlmAlert ${argsToTemplate(args)}>
      <ng-icon hlm name='lucideInfo' hlmAlertIcon />
      <h4 hlmAlertTitle>Introducing SPARTAN helm & brain</h4>
      <p hlmAlertDesc>
        The components used on this page are also the intial building blocks of a new UI library. It is made up of
        headless UI providers, the brain components/directives, which add ARIA compliant markup and interactions. On top
        of the brain we add helm(et) directives, which add shadcn-like styles to
        our application.
      </p>
    </div>
    `,
	}),
};

export default meta;
type Story = StoryObj<HlmAlertDirective>;

export const Default: Story = {
	args: {
		variant: 'default',
	},
};

export const Destructive: Story = {
	args: {
		variant: 'destructive',
	},
	render: ({ ...args }) => ({
		props: args,
		template: `
     <div hlmAlert class='max-w-xl' ${argsToTemplate(args)}>
      <ng-icon hlm name='lucideCircleAlert' hlmAlertIcon />
      <h4 hlmAlertTitle>Something went wrong...</h4>
      <p hlmAlertDesc>
        Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aliquam aperiam at autem culpa debitis eius eveniet exercitationem, facilis illo magni mollitia, necessitatibus nesciunt quam quos recusandae tempore ullam velit veniam!
      </p>
     </div>
    `,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert/helm/README.md
```
# ui-alert-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-alert-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-alert-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/alert/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert/helm/package.json
```json
{
	"name": "@spartan-ng/ui-alert-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
		"class-variance-authority": "^0.7.0",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert/helm/project.json
```json
{
	"name": "ui-alert-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/alert/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/alert/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/alert/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/alert/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/alert/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-alert-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { HlmAlertDescriptionDirective } from './lib/hlm-alert-description.directive';
import { HlmAlertIconDirective } from './lib/hlm-alert-icon.directive';
import { HlmAlertTitleDirective } from './lib/hlm-alert-title.directive';
import { HlmAlertDirective } from './lib/hlm-alert.directive';

export * from './lib/hlm-alert-description.directive';
export * from './lib/hlm-alert-icon.directive';
export * from './lib/hlm-alert-title.directive';
export * from './lib/hlm-alert.directive';

export const HlmAlertImports = [
	HlmAlertDirective,
	HlmAlertTitleDirective,
	HlmAlertDescriptionDirective,
	HlmAlertIconDirective,
] as const;

@NgModule({
	imports: [...HlmAlertImports],
	exports: [...HlmAlertImports],
})
export class HlmAlertModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert/helm/src/lib/hlm-alert-description.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const alertDescriptionVariants = cva('text-sm [&_p]:leading-relaxed', {
	variants: {},
});
export type AlertDescriptionVariants = VariantProps<typeof alertDescriptionVariants>;

@Directive({
	selector: '[hlmAlertDesc],[hlmAlertDescription]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmAlertDescriptionDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm(alertDescriptionVariants(), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert/helm/src/lib/hlm-alert-icon.directive.ts
```typescript
import { Directive } from '@angular/core';
import { provideHlmIconConfig } from '@spartan-ng/ui-icon-helm';

@Directive({
	selector: '[hlmAlertIcon]',
	standalone: true,
	providers: [provideHlmIconConfig({ size: 'sm' })],
})
export class HlmAlertIconDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert/helm/src/lib/hlm-alert-title.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const alertTitleVariants = cva('mb-1 font-medium leading-none tracking-tight', {
	variants: {},
});
export type AlertTitleVariants = VariantProps<typeof alertTitleVariants>;

@Directive({
	selector: '[hlmAlertTitle]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmAlertTitleDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm(alertTitleVariants(), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/alert/helm/src/lib/hlm-alert.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const alertVariants = cva(
	'relative w-full rounded-lg border border-border p-4 [&>[hlmAlertIcon]]:absolute [&>[hlmAlertIcon]]:text-foreground [&>[hlmAlertIcon]]:left-4 [&>[hlmAlertIcon]]:top-4 [&>[hlmAlertIcon]+div]:translate-y-[-3px] [&>[hlmAlertIcon]~*]:pl-7',
	{
		variants: {
			variant: {
				default: 'bg-background text-foreground',
				destructive:
					'text-destructive border-destructive/50 dark:border-destructive [&>[hlmAlertIcon]]:text-destructive',
			},
		},
		defaultVariants: {
			variant: 'default',
		},
	},
);
export type AlertVariants = VariantProps<typeof alertVariants>;

@Directive({
	selector: '[hlmAlert]',
	standalone: true,
	host: {
		role: 'alert',
		'[class]': '_computedClass()',
	},
})
export class HlmAlertDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm(alertVariants({ variant: this.variant() }), this.userClass()));

	public readonly variant = input<AlertVariants['variant']>('default');
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/accordion/accordion.stories.ts
```typescript
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronDown } from '@ng-icons/lucide';
import { BrnAccordionDirective, BrnAccordionImports } from '@spartan-ng/brain/accordion';
import { HlmInputDirective } from '@spartan-ng/ui-input-helm';
import type { Meta, StoryObj } from '@storybook/angular';
import { moduleMetadata } from '@storybook/angular';
import { HlmIconDirective } from '../icon/helm/src';
import { HlmAccordionImports } from './helm/src';

const meta: Meta<BrnAccordionDirective> = {
	title: 'Accordion',
	component: BrnAccordionDirective,
	tags: ['autodocs'],
	decorators: [
		moduleMetadata({
			imports: [BrnAccordionImports, HlmAccordionImports, NgIcon, HlmIconDirective, HlmInputDirective],
			providers: [provideIcons({ lucideChevronDown })],
		}),
	],
};

export default meta;
type Story = StoryObj<BrnAccordionDirective>;

export const Default: Story = {
	render: () => ({
		template: /* HTML */ `
			<hlm-accordion>
				<hlm-accordion-item>
					<button hlmAccordionTrigger>
						Is it accessible?
						<ng-icon name="lucideChevronDown" hlm hlmAccIcon />
					</button>
					<hlm-accordion-content>Yes. It adheres to the WAI-ARIA design pattern.</hlm-accordion-content>
				</hlm-accordion-item>

				<hlm-accordion-item>
					<button hlmAccordionTrigger>
						Is it styled?
						<ng-icon name="lucideChevronDown" hlm hlmAccIcon />
					</button>
					<hlm-accordion-content>
						Yes. It comes with default styles that match the other components' aesthetics.
					</hlm-accordion-content>
				</hlm-accordion-item>

				<hlm-accordion-item>
					<button hlmAccordionTrigger>
						Is it animated?
						<ng-icon name="lucideChevronDown" hlm hlmAccIcon />
					</button>
					<hlm-accordion-content>
						Yes. It's animated by default, but you can disable it if you prefer.
					</hlm-accordion-content>
				</hlm-accordion-item>
			</hlm-accordion>
		`,
	}),
};

export const TwoAccordions: Story = {
	render: () => ({
		template: /* HTML */ `
			<hlm-accordion>
				<hlm-accordion-item>
					<button hlmAccordionTrigger>
						Is it accessible?
						<ng-icon name="lucideChevronDown" hlm hlmAccIcon />
					</button>
					<hlm-accordion-content>Yes. It adheres to the WAI-ARIA design pattern.</hlm-accordion-content>
				</hlm-accordion-item>

				<hlm-accordion-item>
					<button hlmAccordionTrigger>
						Is it styled?
						<ng-icon name="lucideChevronDown" hlm hlmAccIcon />
					</button>
					<hlm-accordion-content>
						Yes. It comes with default styles that match the other components' aesthetics.
					</hlm-accordion-content>
				</hlm-accordion-item>

				<hlm-accordion-item>
					<button hlmAccordionTrigger>
						Is it animated?
						<ng-icon name="lucideChevronDown" hlm hlmAccIcon />
					</button>
					<hlm-accordion-content>
						Yes. It's animated by default, but you can disable it if you prefer.
					</hlm-accordion-content>
				</hlm-accordion-item>
			</hlm-accordion>

			<hlm-accordion>
				<hlm-accordion-item>
					<button hlmAccordionTrigger>
						Is it accessible?
						<ng-icon name="lucideChevronDown" hlm hlmAccIcon />
					</button>
					<hlm-accordion-content>Yes. It adheres to the WAI-ARIA design pattern.</hlm-accordion-content>
				</hlm-accordion-item>

				<hlm-accordion-item>
					<button hlmAccordionTrigger>
						Is it styled?
						<ng-icon name="lucideChevronDown" hlm hlmAccIcon />
					</button>
					<hlm-accordion-content>
						Yes. It comes with default styles that match the other components' aesthetics.
					</hlm-accordion-content>
				</hlm-accordion-item>

				<hlm-accordion-item>
					<button hlmAccordionTrigger>
						Is it styled?
						<ng-icon name="lucideChevronDown" hlm hlmAccIcon />
					</button>
					<hlm-accordion-content>
						Yes. It comes with default styles that match the other components' aesthetics.
					</hlm-accordion-content>
				</hlm-accordion-item>

				<hlm-accordion-item>
					<button hlmAccordionTrigger>
						Is it styled?
						<ng-icon name="lucideChevronDown" hlm hlmAccIcon />
					</button>
					<hlm-accordion-content>
						Yes. It comes with default styles that match the other components' aesthetics.
					</hlm-accordion-content>
				</hlm-accordion-item>
			</hlm-accordion>
		`,
	}),
};
export const SetOpenState: Story = {
	render: () => ({
		template: /* HTML */ `
			<hlm-accordion [type]="multiple">
				<hlm-accordion-item isOpened>
					<button hlmAccordionTrigger>
						Is it accessible?
						<ng-icon name="lucideChevronDown" hlm hlmAccIcon />
					</button>
					<hlm-accordion-content>Yes. It adheres to the WAI-ARIA design pattern.</hlm-accordion-content>
				</hlm-accordion-item>

				<hlm-accordion-item>
					<button hlmAccordionTrigger>
						Is it styled?
						<ng-icon name="lucideChevronDown" hlm hlmAccIcon />
					</button>
					<hlm-accordion-content>
						Yes. It comes with default styles that match the other components' aesthetics.
					</hlm-accordion-content>
				</hlm-accordion-item>

				<hlm-accordion-item isOpened>
					<button hlmAccordionTrigger>
						Is it animated?
						<ng-icon name="lucideChevronDown" hlm hlmAccIcon />
					</button>
					<hlm-accordion-content>
						Yes. It's animated by default, but you can disable it if you prefer.
					</hlm-accordion-content>
				</hlm-accordion-item>
			</hlm-accordion>
		`,
	}),
};
export const WithTapable: Story = {
	render: () => ({
		template: /* HTML */ `
			<hlm-accordion>
				<hlm-accordion-item>
					<button hlmAccordionTrigger>
						Is the button tapable when closed?
						<ng-icon name="lucideChevronDown" hlm hlmAccIcon />
					</button>
					<hlm-accordion-content>
						<button data-testid="not-tapable-when-closed">It should not be when closed</button>
					</hlm-accordion-content>
				</hlm-accordion-item>

				<hlm-accordion-item>
					<button hlmAccordionTrigger>
						Is the button tapable when open?
						<ng-icon name="lucideChevronDown" hlm hlmAccIcon />
					</button>
					<hlm-accordion-content>
						<button data-testid="tapable-when-open">It should be when open</button>
					</hlm-accordion-content>
				</hlm-accordion-item>
			</hlm-accordion>
		`,
	}),
};

export const AccordionWithInput: Story = {
	render: () => ({
		template: /* HTML */ `
			<hlm-accordion>
				<hlm-accordion-item>
					<button hlmAccordionTrigger>
						Enter your name
						<ng-icon name="lucideChevronDown" hlm hlmAccIcon />
					</button>
					<hlm-accordion-content>
						<div class="px-1">
							<input type="text" placeholder="Type your name here" hlmInput />
						</div>
					</hlm-accordion-content>
				</hlm-accordion-item>
			</hlm-accordion>
		`,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/accordion/helm/README.md
```
# ui-accordion-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-accordion-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/accordion/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/accordion/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-accordion-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/accordion/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/accordion/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/accordion/helm/package.json
```json
{
	"name": "@spartan-ng/ui-accordion-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@ng-icons/core": ">=29.0.0",
		"@ng-icons/lucide": ">=29.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/accordion/helm/project.json
```json
{
	"name": "ui-accordion-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/accordion/helm/src",
	"prefix": "hlm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/accordion/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/accordion/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/accordion/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/accordion/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-accordion-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/accordion/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/accordion/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/accordion/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/accordion/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/accordion/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { HlmAccordionContentComponent } from './lib/hlm-accordion-content.component';
import { HlmAccordionIconDirective } from './lib/hlm-accordion-icon.directive';
import { HlmAccordionItemDirective } from './lib/hlm-accordion-item.directive';
import { HlmAccordionTriggerDirective } from './lib/hlm-accordion-trigger.directive';
import { HlmAccordionDirective } from './lib/hlm-accordion.directive';

export * from './lib/hlm-accordion-content.component';
export * from './lib/hlm-accordion-icon.directive';
export * from './lib/hlm-accordion-item.directive';
export * from './lib/hlm-accordion-trigger.directive';
export * from './lib/hlm-accordion.directive';

export const HlmAccordionImports = [
	HlmAccordionDirective,
	HlmAccordionItemDirective,
	HlmAccordionTriggerDirective,
	HlmAccordionIconDirective,
	HlmAccordionContentComponent,
] as const;

@NgModule({
	imports: [...HlmAccordionImports],
	exports: [...HlmAccordionImports],
})
export class HlmAccordionModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/accordion/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/accordion/helm/src/lib/hlm-accordion-content.component.ts
```typescript
import { ChangeDetectionStrategy, Component, ViewEncapsulation, computed, input } from '@angular/core';
import { BrnAccordionContentComponent } from '@spartan-ng/brain/accordion';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-accordion-content',
	template: `
		<div [attr.inert]="_addInert()" style="overflow: hidden">
			<p [class]="_contentClass()">
				<ng-content />
			</p>
		</div>
	`,
	standalone: true,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmAccordionContentComponent extends BrnAccordionContentComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => {
		const gridRows = this.state() === 'open' ? 'grid-rows-[1fr]' : 'grid-rows-[0fr]';
		return hlm('text-sm transition-all grid', gridRows, this.userClass());
	});

	constructor() {
		super();
		this.setClassToCustomElement('pt-1 pb-4');
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/accordion/helm/src/lib/hlm-accordion-icon.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { provideIcons } from '@ng-icons/core';
import { lucideChevronDown } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { provideHlmIconConfig } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

@Directive({
	selector: 'ng-icon[hlmAccordionIcon], ng-icon[hlmAccIcon]',
	standalone: true,
	providers: [provideIcons({ lucideChevronDown }), provideHlmIconConfig({ size: 'sm' })],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmAccordionIconDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm('inline-block h-4 w-4 transition-transform [animation-duration:200]', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/accordion/helm/src/lib/hlm-accordion-item.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { BrnAccordionItemDirective } from '@spartan-ng/brain/accordion';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmAccordionItem],brn-accordion-item[hlm],hlm-accordion-item',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [
		{
			directive: BrnAccordionItemDirective,
			inputs: ['isOpened'],
		},
	],
})
export class HlmAccordionItemDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm('flex flex-1 flex-col border-b border-border', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/accordion/helm/src/lib/hlm-accordion-trigger.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { BrnAccordionTriggerDirective } from '@spartan-ng/brain/accordion';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmAccordionTrigger]',
	standalone: true,
	host: {
		'[style.--tw-ring-offset-shadow]': '"0 0 #000"',
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnAccordionTriggerDirective],
})
export class HlmAccordionTriggerDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'w-full focus-visible:outline-none text-sm focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-2 flex flex-1 items-center justify-between py-4 px-0.5 font-medium underline-offset-4 hover:underline [&[data-state=open]>[hlmAccordionIcon]]:rotate-180 [&[data-state=open]>[hlmAccIcon]]:rotate-180',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/accordion/helm/src/lib/hlm-accordion.directive.ts
```typescript
import { Directive, computed, inject, input } from '@angular/core';
import { BrnAccordionDirective } from '@spartan-ng/brain/accordion';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmAccordion], hlm-accordion',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [{ directive: BrnAccordionDirective, inputs: ['type', 'dir', 'orientation'] }],
})
export class HlmAccordionDirective {
	private readonly _brn = inject(BrnAccordionDirective);

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm('flex', this._brn.orientation() === 'horizontal' ? 'flex-row' : 'flex-col', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/skeleton/skeleton.stories.ts
```typescript
import type { Meta, StoryObj } from '@storybook/angular';
import { moduleMetadata } from '@storybook/angular';
import { HlmSkeletonComponent } from './helm/src';

const meta: Meta<HlmSkeletonComponent> = {
	title: 'Skeleton',
	component: HlmSkeletonComponent,
	tags: ['autodocs'],
	decorators: [
		moduleMetadata({
			imports: [HlmSkeletonComponent],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmSkeletonComponent>;

export const Default: Story = {
	render: () => ({
		template: `
   <div class='flex items-center p-4 m-4 border rounded-lg w-fit border-border space-x-4'>
      <hlm-skeleton class='w-12 h-12 rounded-full' />
      <div class='space-y-2'>
        <hlm-skeleton class='h-4 w-[250px]' />
        <hlm-skeleton class='h-4 w-[200px]' />
      </div>
    </div>
    `,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/skeleton/helm/README.md
```
# ui-skeleton-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-skeleton-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/skeleton/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/skeleton/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-skeleton-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	coverageDirectory: '../../../../coverage/libs/button/helm',
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/skeleton/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/skeleton/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/skeleton/helm/package.json
```json
{
	"name": "@spartan-ng/ui-skeleton-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/skeleton/helm/project.json
```json
{
	"name": "ui-skeleton-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/skeleton/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/skeleton/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/skeleton/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/skeleton/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/skeleton/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-skeleton-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/skeleton/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/skeleton/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/skeleton/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/skeleton/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/skeleton/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmSkeletonComponent } from './lib/hlm-skeleton.component';

export * from './lib/hlm-skeleton.component';

@NgModule({
	imports: [HlmSkeletonComponent],
	exports: [HlmSkeletonComponent],
})
export class HlmSkeletonModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/skeleton/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/skeleton/helm/src/lib/hlm-skeleton.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-skeleton',
	standalone: true,
	template: '',
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSkeletonComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('block animate-pulse rounded-md bg-muted', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/separator/separator.stories.ts
```typescript
import { BrnSeparatorComponent } from '@spartan-ng/brain/separator';
import { type Meta, type StoryObj, argsToTemplate, moduleMetadata } from '@storybook/angular';
import { HlmSeparatorDirective } from './helm/src';

const meta: Meta<BrnSeparatorComponent> = {
	title: 'Separator',
	component: BrnSeparatorComponent,
	tags: ['autodocs'],
	args: {
		orientation: 'horizontal',
		decorative: false,
	},
	argTypes: {
		orientation: {
			options: ['horizontal', 'vertical'],
			control: {
				type: 'select',
			},
			table: {
				defaultValue: { summary: 'horizontal' },
			},
		},
		decorative: {
			control: {
				type: 'boolean',
			},
			table: {
				defaultValue: { summary: 'false' },
			},
		},
	},
	decorators: [
		moduleMetadata({
			imports: [BrnSeparatorComponent, HlmSeparatorDirective],
		}),
	],
};

export default meta;
type Story = StoryObj<BrnSeparatorComponent>;

export const Default: Story = {
	render: ({ ...args }) => ({
		props: args,
		template: `
    <div>
      <div class='space-y-1'>
        <h4 class='text-sm font-medium leading-none'>Radix Primitives</h4>
        <p class='text-sm text-muted-foreground'>
          An open-source UI component library.
        </p>
      </div>
      <brn-separator hlmSeparator ${argsToTemplate(args)} class='my-4' />
      <div class='flex items-center h-5 text-sm space-x-4'>
        <div>Blog</div>
        <brn-separator decorative hlmSeparator orientation='vertical' />
        <div>Docs</div>
        <brn-separator decorative hlmSeparator orientation='vertical' />
        <div>Source</div>
      </div>
    </div>
       `,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/separator/helm/README.md
```
# ui-separator-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-separator-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/separator/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/separator/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-separator-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/separator/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/separator/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/separator/helm/package.json
```json
{
	"name": "@spartan-ng/ui-separator-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/separator/helm/project.json
```json
{
	"name": "ui-separator-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/separator/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/separator/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/separator/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/separator/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/separator/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-separator-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/separator/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/separator/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/separator/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/separator/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/separator/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmSeparatorDirective } from './lib/hlm-separator.directive';

export * from './lib/hlm-separator.directive';

@NgModule({
	imports: [HlmSeparatorDirective],
	exports: [HlmSeparatorDirective],
})
export class HlmSeparatorModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/separator/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/separator/helm/src/lib/hlm-separator.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export type HlmSeparatorOrientation = 'horizontal' | 'vertical';
@Directive({
	selector: '[hlmSeparator],brn-separator[hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSeparatorDirective {
	public readonly orientation = input<HlmSeparatorOrientation>('horizontal');
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'inline-flex shrink-0 border-0 bg-border',
			this.orientation() === 'horizontal' ? 'h-[1px] w-full' : 'h-full w-[1px]',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/hover-card/hover-card.stories.ts
```typescript
import { Component } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideCalendarDays } from '@ng-icons/lucide';
import { type BrnHoverCardComponent, BrnHoverCardModule } from '@spartan-ng/brain/hover-card';
import { type Meta, type StoryObj, moduleMetadata } from '@storybook/angular';
import { HlmAvatarModule } from '../avatar/helm/src';
import { HlmButtonDirective } from '../button/helm/src';
import { HlmCardDirective } from '../card/helm/src';
import { HlmIconDirective } from '../icon/helm/src';
import { HlmHoverCardModule } from './helm/src';

@Component({
	selector: 'hover-card-example',
	standalone: true,
	imports: [BrnHoverCardModule, HlmHoverCardModule, HlmButtonDirective, NgIcon, HlmIconDirective, HlmAvatarModule],
	providers: [provideIcons({ lucideCalendarDays })],
	host: {
		class: 'flex w-full h-full justify-center py-80',
	},
	template: `
		<brn-hover-card>
			<button hlmBtn variant="link" brnHoverCardTrigger>&#64;analogjs</button>
			<hlm-hover-card-content *brnHoverCardContent class="w-80">
				<div class="flex justify-between space-x-4">
					<hlm-avatar variant="small" id="avatar-small">
						<img src="https://analogjs.org/img/logos/analog-logo.svg" alt="AnalogLogo" hlmAvatarImage />
						<span class="bg-sky-600 text-sky-50" hlmAvatarFallback>AN</span>
					</hlm-avatar>
					<div class="space-y-1">
						<h4 class="text-sm font-semibold">&#64;analogjs</h4>
						<p class="text-sm">The Angular meta-framework  build Angular applications faster.</p>
						<div class="flex items-center pt-2">
							<ng-icon hlm size="sm" name="lucideCalendarDays" class="mr-2 opacity-70" />
							<span class="text-muted-foreground text-xs">Joined December 2021</span>
						</div>
					</div>
				</div>
			</hlm-hover-card-content>
		</brn-hover-card>
	`,
})
class HoverCardExampleComponent {}

const meta: Meta<BrnHoverCardComponent> = {
	title: 'Hover Card',
	component: HlmCardDirective,
	tags: ['autodocs'],
	decorators: [
		moduleMetadata({
			imports: [HoverCardExampleComponent],
		}),
	],
};

export default meta;
type Story = StoryObj<BrnHoverCardComponent>;

export const Default: Story = {
	render: () => ({
		template: '<hover-card-example/>',
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/hover-card/helm/README.md
```
# ui-hover-card-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-hover-card-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/hover-card/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/hover-card/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-hover-card-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/hover-card/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/hover-card/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/hover-card/helm/package.json
```json
{
	"name": "@spartan-ng/ui-hovercard-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/hover-card/helm/project.json
```json
{
	"name": "ui-hover-card-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/hover-card/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/hover-card/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/hover-card/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/hover-card/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/hover-card/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-hover-card-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/hover-card/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/hover-card/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/hover-card/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/hover-card/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/hover-card/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmHoverCardContentComponent } from './lib/hlm-hover-card-content.component';

export { HlmHoverCardContentComponent } from './lib/hlm-hover-card-content.component';

export const HlmHoverCardImports = [HlmHoverCardContentComponent] as const;

@NgModule({
	imports: [...HlmHoverCardImports],
	exports: [...HlmHoverCardImports],
})
export class HlmHoverCardModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/hover-card/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/hover-card/helm/src/lib/hlm-hover-card-content.component.ts
```typescript
import { Component, ElementRef, Renderer2, computed, effect, inject, input, signal } from '@angular/core';
import { hlm, injectExposedSideProvider, injectExposesStateProvider } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-hover-card-content',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	template: `
		<ng-content />
	`,
})
export class HlmHoverCardContentComponent {
	private readonly _renderer = inject(Renderer2);
	private readonly _element = inject(ElementRef);

	public readonly state = injectExposesStateProvider({ host: true }).state ?? signal('closed').asReadonly();
	public readonly side = injectExposedSideProvider({ host: true }).side ?? signal('bottom').asReadonly();

	constructor() {
		effect(() => {
			this._renderer.setAttribute(this._element.nativeElement, 'data-state', this.state());
			this._renderer.setAttribute(this._element.nativeElement, 'data-side', this.side());
		});
	}

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'z-50 w-64 rounded-md border border-border bg-popover p-4 text-popover-foreground shadow-md outline-none',
			'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/checkbox/checkbox.stories.ts
```typescript
import { NgIcon } from '@ng-icons/core';
import type { Meta, StoryObj } from '@storybook/angular';
import { moduleMetadata } from '@storybook/angular';

import { Component, inject } from '@angular/core';
import { FormBuilder, ReactiveFormsModule } from '@angular/forms';
import { HlmButtonModule } from '../button/helm/src';
import { HlmIconDirective } from '../icon/helm/src';
import { HlmLabelDirective } from '../label/helm/src';
import { HlmCheckboxComponent, HlmCheckboxImports } from './helm/src';

@Component({
	selector: 'hlm-checkbox-component-tester',
	template: `
		<div class="flex items-center gap-4" [formGroup]="form">
			<label id="checkbox-label" for="testCheckboxDis1" hlmLabel>
				Test Disabled Checkbox with Reactive Forms
				<hlm-checkbox class="ml-2" id="testCheckboxDis1" aria-labelledby="testCheckbox" formControlName="checkbox" />
			</label>

			<button hlmBtn type="button" role="button" (click)="enableOrDisableCheckbox()">Enable or disable button</button>
		</div>
	`,
})
class HlmCheckboxComponentTester {
	form = inject(FormBuilder).group({
		checkbox: [false],
	});

	enableOrDisableCheckbox(): void {
		this.form.enabled ? this.form.disable() : this.form.enable();
	}
}

const meta: Meta<HlmCheckboxComponent> = {
	title: 'Checkbox',
	component: HlmCheckboxComponent,
	tags: ['autodocs'],
	decorators: [
		moduleMetadata({
			imports: [
				HlmCheckboxImports,
				HlmLabelDirective,
				NgIcon,
				HlmIconDirective,
				ReactiveFormsModule,
				HlmButtonModule,
				HlmCheckboxComponentTester,
			],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmCheckboxComponent>;

export const Default: Story = {
	render: () => ({
		template: /* HTML */ `
			<label id="checkbox-label" class="" hlmLabel>
				Test Checkbox
				<hlm-checkbox id="testCheckbox" aria-checked="mixed" aria-label="test checkbox" />
			</label>
		`,
	}),
};

export const InsideLabel: Story = {
	render: () => ({
		template: /* HTML */ `
			<label id="checkbox-label" class="flex items-center" hlmLabel>
				Test Checkbox
				<hlm-checkbox class="ml-2" id="testCheckbox" />
			</label>
		`,
	}),
};

export const LabeledWithAriaLabeledBy: Story = {
	render: () => ({
		template: /* HTML */ `
			<div id="checkbox-label" class="flex items-center">
				<label id="testCheckbox" for="testCheckboxAria" hlmLabel>Test Checkbox</label>
				<hlm-checkbox class="ml-2" id="testCheckboxAria" aria-labelledby="testCheckbox" />
			</div>
		`,
	}),
};

export const disabled: Story = {
	render: () => ({
		template: /* HTML */ `
			<div class="flex items-center">
				<label id="checkbox-label" for="testCheckboxDis1" hlmLabel>Test Checkbox</label>
				<hlm-checkbox disabled class="ml-2" id="testCheckboxDis1" aria-labelledby="testCheckbox" />
			</div>

			<div class="flex items-center pt-4">
				<hlm-checkbox disabled id="testCheckboxDis2" />
				<label class="ml-2" for="testCheckboxDis2" hlmLabel>Test Checkbox 2</label>
			</div>

			<div class="flex items-center pt-4">
				<hlm-checkbox id="testCheckboxDis3" />
				<label class="ml-2" for="testCheckboxDis3" hlmLabel>Test Checkbox 3 enabled</label>
			</div>
		`,
	}),
};

export const disabledWithForms: Story = {
	render: () => ({
		template: /* HTML */ `
			<hlm-checkbox-component-tester />
		`,
	}),
};

export const indeterminate: Story = {
	render: () => ({
		template: /* HTML */ `
			<div id="checkbox-label" class="flex items-center">
				<label id="testCheckbox" for="testCheckboxIndeterminate" hlmLabel>Test Checkbox</label>
				<hlm-checkbox
					checked="indeterminate"
					class="ml-2"
					id="testCheckboxIndeterminate"
					aria-labelledby="testCheckbox"
				/>
			</div>
		`,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/checkbox/helm/README.md
```
# ui-checkbox-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-checkbox-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/checkbox/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/checkbox/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-checkbox-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	coverageDirectory: '../../../../coverage/libs/ui/checkbox/helm',
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/checkbox/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/checkbox/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/checkbox/helm/package.json
```json
{
	"name": "@spartan-ng/ui-checkbox-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@angular/forms": ">=19.0.0",
		"@ng-icons/core": ">=29.0.0",
		"@ng-icons/lucide": ">=29.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/checkbox/helm/project.json
```json
{
	"name": "ui-checkbox-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/checkbox/helm/src",
	"prefix": "hlm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/checkbox/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/checkbox/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/checkbox/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/checkbox/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-checkbox-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/checkbox/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/checkbox/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/checkbox/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/checkbox/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/checkbox/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { HlmCheckboxComponent } from './lib/hlm-checkbox.component';

export * from './lib/hlm-checkbox.component';

export const HlmCheckboxImports = [HlmCheckboxComponent] as const;
@NgModule({
	imports: [...HlmCheckboxImports],
	exports: [...HlmCheckboxImports],
})
export class HlmCheckboxModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/checkbox/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/checkbox/helm/src/lib/hlm-checkbox.component.ts
```typescript
import { Component, booleanAttribute, computed, forwardRef, input, model, output, signal } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideCheck } from '@ng-icons/lucide';
import { BrnCheckboxComponent } from '@spartan-ng/brain/checkbox';
import { hlm } from '@spartan-ng/brain/core';
import type { ChangeFn, TouchFn } from '@spartan-ng/brain/forms';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

export const HLM_CHECKBOX_VALUE_ACCESSOR = {
	provide: NG_VALUE_ACCESSOR,
	useExisting: forwardRef(() => HlmCheckboxComponent),
	multi: true,
};

@Component({
	selector: 'hlm-checkbox',
	imports: [BrnCheckboxComponent, NgIcon, HlmIconDirective],
	template: `
		<brn-checkbox
			[id]="id()"
			[name]="name()"
			[class]="_computedClass()"
			[checked]="checked()"
			[disabled]="state().disabled()"
			[required]="required()"
			[aria-label]="ariaLabel()"
			[aria-labelledby]="ariaLabelledby()"
			[aria-describedby]="ariaDescribedby()"
			(changed)="_handleChange()"
			(touched)="_onTouched?.()"
		>
			<ng-icon [class]="_computedIconClass()" hlm size="sm" name="lucideCheck" />
		</brn-checkbox>
	`,
	host: {
		class: 'contents',
		'[attr.id]': 'null',
		'[attr.aria-label]': 'null',
		'[attr.aria-labelledby]': 'null',
		'[attr.aria-describedby]': 'null',
	},
	providers: [HLM_CHECKBOX_VALUE_ACCESSOR],
	viewProviders: [provideIcons({ lucideCheck })],
})
export class HlmCheckboxComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm(
			'group inline-flex border border-foreground shrink-0 cursor-pointer items-center rounded-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring' +
				' focus-visible:ring-offset-2 focus-visible:ring-offset-background data-[state=checked]:text-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-background',
			this.userClass(),
			this.state().disabled() ? 'cursor-not-allowed opacity-50' : '',
		),
	);

	protected readonly _computedIconClass = computed(() =>
		hlm('leading-none group-data-[state=unchecked]:opacity-0', this.checked() === 'indeterminate' ? 'opacity-50' : ''),
	);

	/** Used to set the id on the underlying brn element. */
	public readonly id = input<string | null>(null);

	/** Used to set the aria-label attribute on the underlying brn element. */
	public readonly ariaLabel = input<string | null>(null, { alias: 'aria-label' });

	/** Used to set the aria-labelledby attribute on the underlying brn element. */
	public readonly ariaLabelledby = input<string | null>(null, { alias: 'aria-labelledby' });

	/** Used to set the aria-describedby attribute on the underlying brn element. */
	public readonly ariaDescribedby = input<string | null>(null, { alias: 'aria-describedby' });

	/** The checked state of the checkbox. */
	public readonly checked = model<CheckboxValue>(false);

	/** The name attribute of the checkbox. */
	public readonly name = input<string | null>(null);

	/** Whether the checkbox is required. */
	public readonly required = input(false, { transform: booleanAttribute });

	/** Whether the checkbox is disabled. */
	public readonly disabled = input(false, { transform: booleanAttribute });

	protected readonly state = computed(() => ({
		disabled: signal(this.disabled()),
	}));

	public readonly changed = output<boolean>();

	protected _onChange?: ChangeFn<CheckboxValue>;
	protected _onTouched?: TouchFn;

	protected _handleChange(): void {
		if (this.state().disabled()) return;

		const previousChecked = this.checked();
		this.checked.set(previousChecked === 'indeterminate' ? true : !previousChecked);
		this._onChange?.(!previousChecked);
		this.changed.emit(!previousChecked);
	}

	/** CONROL VALUE ACCESSOR */
	writeValue(value: CheckboxValue): void {
		this.checked.set(!!value);
	}

	registerOnChange(fn: ChangeFn<CheckboxValue>): void {
		this._onChange = fn;
	}

	registerOnTouched(fn: TouchFn): void {
		this._onTouched = fn;
	}

	setDisabledState(isDisabled: boolean): void {
		this.state().disabled.set(isDisabled);
	}
}

type CheckboxValue = boolean | 'indeterminate';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/label/label.stories.ts
```typescript
import { FormsModule } from '@angular/forms';
import { BrnLabelDirective } from '@spartan-ng/brain/label';
import { type Meta, type StoryObj, argsToTemplate, moduleMetadata } from '@storybook/angular';
import { HlmInputDirective } from '../input/helm/src';
import { HlmLabelDirective } from './helm/src';

const meta: Meta<{}> = {
	title: 'Label',
	component: HlmLabelDirective,
	tags: ['autodocs'],
	args: {
		variant: 'default',
		error: 'auto',
	},
	argTypes: {
		variant: {
			options: ['default'],
			control: {
				type: 'select',
			},
		},
		error: {
			options: ['auto', 'true'],
			control: {
				type: 'select',
			},
		},
		id: {
			control: 'text',
		},
	},
	decorators: [
		moduleMetadata({
			imports: [HlmInputDirective, HlmLabelDirective, BrnLabelDirective, FormsModule],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmLabelDirective>;

export const Default: Story = {
	render: ({ ...args }) => ({
		props: args,
		template: `
    <label hlmLabel ${argsToTemplate(args)}>E-Mail
        <input class='w-80' hlmInput  type='email' placeholder='Email'/>
    </label>
    `,
	}),
};

export const InputRequired: Story = {
	render: ({ ...args }) => ({
		props: { ...args, value: '' },
		template: `
    <label hlmLabel ${argsToTemplate(args)}>E-Mail *
        <input [(ngModel)]="value" class='w-80' hlmInput  type='email' placeholder='Email *' required/>
    </label>
    `,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/label/helm/README.md
```
# ui-label-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-label-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/label/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/label/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-label-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	coverageDirectory: '../../../../coverage/libs/button/helm',
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/label/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/label/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/label/helm/package.json
```json
{
	"name": "@spartan-ng/ui-label-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"class-variance-authority": "^0.7.0",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/label/helm/project.json
```json
{
	"name": "ui-label-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/label/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/label/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/label/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/label/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/label/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-label-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/label/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/label/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/label/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/label/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/label/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmLabelDirective } from './lib/hlm-label.directive';

export * from './lib/hlm-label.directive';

@NgModule({
	imports: [HlmLabelDirective],
	exports: [HlmLabelDirective],
})
export class HlmLabelModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/label/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/label/helm/src/lib/hlm-label.directive.ts
```typescript
import { Directive, computed, inject, input, signal } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnLabelDirective } from '@spartan-ng/brain/label';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const labelVariants = cva(
	'text-sm font-medium leading-none [&>[hlmInput]]:my-1 [&:has([hlmInput]:disabled)]:cursor-not-allowed [&:has([hlmInput]:disabled)]:opacity-70',
	{
		variants: {
			variant: {
				default: '',
			},
			error: {
				auto: '[&:has([hlmInput].ng-invalid.ng-touched)]:text-destructive',
				true: 'text-destructive',
			},
			disabled: {
				auto: '[&:has([hlmInput]:disabled)]:opacity-70',
				true: 'opacity-70',
				false: '',
			},
		},
		defaultVariants: {
			variant: 'default',
			error: 'auto',
		},
	},
);
export type LabelVariants = VariantProps<typeof labelVariants>;

@Directive({
	selector: '[hlmLabel]',
	standalone: true,
	hostDirectives: [
		{
			directive: BrnLabelDirective,
			inputs: ['id'],
		},
	],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmLabelDirective {
	private readonly _brn = inject(BrnLabelDirective, { host: true });

	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	public readonly variant = input<LabelVariants['variant']>('default');

	public readonly error = input<LabelVariants['error']>('auto');

	protected readonly state = computed(() => ({
		error: signal(this.error()),
	}));

	protected readonly _computedClass = computed(() =>
		hlm(
			labelVariants({
				variant: this.variant(),
				error: this.state().error(),
				disabled: this._brn?.dataDisabled() ?? 'auto',
			}),
			'[&.ng-invalid.ng-touched]:text-destructive',
			this.userClass(),
		),
	);

	setError(error: LabelVariants['error']): void {
		this.state().error.set(error);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/slider/slider.stories.ts
```typescript
import { signal } from '@angular/core';
import { FormControl, FormGroup, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { BrnSliderImports } from '@spartan-ng/brain/slider';
import { type Meta, type StoryObj, argsToTemplate, moduleMetadata } from '@storybook/angular';
import { HlmSliderImports } from './helm/src';

interface BrnSliderStoryArgs {
	value: number;
	disabled: boolean;
	min: number;
	max: number;
	step: number;
	showTicks: boolean;
}

const meta: Meta<BrnSliderStoryArgs> = {
	title: 'Slider',
	tags: ['autodocs'],
	args: {
		disabled: false,
	},
	decorators: [
		moduleMetadata({
			imports: [FormsModule, ReactiveFormsModule, HlmSliderImports, BrnSliderImports],
		}),
	],
};

export default meta;
type Story = StoryObj<BrnSliderStoryArgs>;

export const Default: Story = {
	render: (args) => ({
		props: { ...args },
		template: /* HTML */ `
			<hlm-slider ${argsToTemplate(args)} />

			<div>{{value}}</div>
		`,
	}),
};

export const Disabled: Story = {
	args: {
		value: 50,
		disabled: true,
	},
	render: ({ ...args }) => ({
		props: args,
		template: /* HTML */ `
			<hlm-slider ${argsToTemplate(args)} />
		`,
	}),
};

export const Min: Story = {
	args: {
		min: 10,
	},
	render: ({ ...args }) => ({
		props: args,
		template: /* HTML */ `
			<hlm-slider ${argsToTemplate(args)} (valueChange)="value = $event" />

			<div>{{value}}</div>
		`,
	}),
};

export const Max: Story = {
	args: {
		value: 0,
		max: 75,
	},
	render: ({ ...args }) => ({
		props: args,
		template: /* HTML */ `
			<hlm-slider ${argsToTemplate(args)} (valueChange)="value = $event" />

			<div>{{value}}</div>
		`,
	}),
};

export const MinMax: Story = {
	args: {
		min: 10,
		max: 90,
	},
	render: ({ ...args }) => ({
		props: args,
		template: /* HTML */ `
			<hlm-slider ${argsToTemplate(args)} (valueChange)="value = $event" />

			<div>{{value}}</div>
		`,
	}),
};

export const Step: Story = {
	args: {
		step: 5,
	},
	render: ({ ...args }) => ({
		props: args,
		template: /* HTML */ `
			<hlm-slider ${argsToTemplate(args)} (valueChange)="value = $event" />

			<div>{{value}}</div>
		`,
	}),
};

export const Ticks: Story = {
	args: {
		step: 5,
		showTicks: true,
	},
	render: ({ ...args }) => ({
		props: args,
		template: /* HTML */ `
			<hlm-slider ${argsToTemplate(args)} (valueChange)="value = $event" />

			<div>{{value}}</div>
		`,
	}),
};

export const TemplateDrivenForm: Story = {
	render: (args) => ({
		props: { ...args, temperature: signal('0') },
		template: /* HTML */ `
			<form ngForm>
				<div>
					<pre>{{temperature()}}</pre>
				</div>
				<hlm-slider ${argsToTemplate(args)} [(ngModel)]="temperature" name="temperature" />

				<button (click)="temperature.set(25)">Change temperature value</button>
			</form>
		`,
	}),
};

export const TemplateDrivenFormWithInitialValue: Story = {
	render: (args) => ({
		props: { ...args, temperature: signal(12) },
		template: /* HTML */ `
			<form ngForm>
				<div>
					<pre>{{temperature()}}</pre>
				</div>
				<hlm-slider ${argsToTemplate(args)} [(ngModel)]="temperature" name="temperature" />

				<button (click)="temperature.set(25)">Change temperature value</button>
			</form>
		`,
	}),
};

export const ReactiveFormControl: Story = {
	render: (args) => ({
		props: { ...args, temperatureGroup: new FormGroup({ temperature: new FormControl() }) },
		template: /* HTML */ `
			<div class="mb-3">
				<pre>Form Control Value: {{ temperatureGroup.controls.temperature.valueChanges | async | json }}</pre>
			</div>
			<form [formGroup]="temperatureGroup">
				<hlm-slider ${argsToTemplate(args)} formControlName="temperature" />
			</form>
		`,
	}),
};

export const ReactiveFormControlWithInitialValue: Story = {
	render: (args) => ({
		props: { ...args, temperatureGroup: new FormGroup({ temperature: new FormControl(26) }) },
		template: /* HTML */ `
			<div class="mb-3">
				<pre>Form Control Value: {{ temperatureGroup.controls.temperature.valueChanges | async | json }}</pre>
			</div>
			<form [formGroup]="temperatureGroup">
				<hlm-slider ${argsToTemplate(args)} formControlName="temperature" />
			</form>
		`,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/slider/helm/README.md
```
# ui-slider-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-slider-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/slider/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/slider/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-slider-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	coverageDirectory: '../../../../coverage/libs/ui/slider/helm',
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/slider/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/slider/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/slider/helm/package.json
```json
{
	"name": "@spartan-ng/ui-slider-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"clsx": "^2.1.1"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/slider/helm/project.json
```json
{
	"name": "ui-slider-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/slider/helm/src",
	"prefix": "lib",
	"projectType": "library",
	"tags": [],
	"targets": {
		"build": {
			"executor": "@nx/angular:ng-packagr-lite",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/slider/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/slider/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/slider/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/slider/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint"
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/slider/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/slider/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/slider/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/slider/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/slider/helm/src/index.ts
```typescript
export * from './lib/hlm-slider.component';
import { HlmSliderComponent } from './lib/hlm-slider.component';

export const HlmSliderImports = [HlmSliderComponent] as const;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/slider/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/slider/helm/src/lib/hlm-slider.component.ts
```typescript
import { ChangeDetectionStrategy, Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import {
	BrnSliderDirective,
	BrnSliderRangeDirective,
	BrnSliderThumbDirective,
	BrnSliderTickDirective,
	BrnSliderTrackDirective,
	injectBrnSlider,
} from '@spartan-ng/brain/slider';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-slider, brn-slider [hlm]',
	changeDetection: ChangeDetectionStrategy.OnPush,
	hostDirectives: [
		{
			directive: BrnSliderDirective,
			inputs: ['value', 'disabled', 'min', 'max', 'step', 'showTicks'],
			outputs: ['valueChange'],
		},
	],
	template: `
		<div brnSliderTrack class="bg-secondary relative h-2 w-full grow overflow-hidden rounded-full">
			<div class="bg-primary absolute h-full" brnSliderRange></div>
		</div>

		@if (slider.showTicks()) {
			<div class="pointer-events-none absolute -inset-x-px top-2 h-1 w-full cursor-pointer transition-all">
				<div
					*brnSliderTick="let tick; let position = position"
					class="absolute size-1 rounded-full"
					[class.bg-secondary]="tick"
					[class.bg-primary]="!tick"
					[style.inset-inline-start.%]="position"
				></div>
			</div>
		}

		<span
			class="border-primary bg-background ring-offset-background focus-visible:ring-ring absolute block h-5 w-5 -translate-x-1/2 rounded-full border-2 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50"
			brnSliderThumb
		></span>
	`,
	host: {
		'[class]': '_computedClass()',
	},
	imports: [BrnSliderThumbDirective, BrnSliderTrackDirective, BrnSliderRangeDirective, BrnSliderTickDirective],
})
export class HlmSliderComponent {
	protected readonly slider = injectBrnSlider();
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'w-full h-5 flex relative select-none items-center touch-none',
			this.slider.disabled() ? 'opacity-40' : '',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/spinner/spinner.stories.ts
```typescript
import { type Meta, type StoryObj, argsToTemplate, moduleMetadata } from '@storybook/angular';
import { HlmSpinnerComponent } from './helm/src';

const meta: Meta<HlmSpinnerComponent> = {
	title: 'Spinner',
	component: HlmSpinnerComponent,
	tags: ['autodocs'],
	argTypes: {
		size: {
			options: ['default', 'xs', 'sm'],
			control: {
				type: 'select',
			},
		},
	},
	decorators: [
		moduleMetadata({
			imports: [HlmSpinnerComponent],
		}),
	],
	render: ({ ...args }) => ({
		props: args,
		template: `
    <hlm-spinner ${argsToTemplate(args)}></hlm-spinner>
    `,
	}),
};

export default meta;
type Story = StoryObj<HlmSpinnerComponent>;

export const Default: Story = {};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/spinner/helm/README.md
```
# ui-spinner-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-spinner-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/spinner/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/spinner/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-spinner-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	coverageDirectory: '../../../../coverage/libs/button/helm',
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/spinner/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/spinner/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/spinner/helm/package.json
```json
{
	"name": "@spartan-ng/ui-spinner-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"class-variance-authority": "^0.7.0",
		"clsx": "^2.1.1"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/spinner/helm/project.json
```json
{
	"name": "ui-spinner-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/spinner/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/spinner/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/spinner/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/spinner/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/spinner/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/spinner/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/spinner/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/spinner/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/spinner/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/spinner/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmSpinnerComponent } from './lib/hlm-spinner.component';

export * from './lib/hlm-spinner.component';

@NgModule({
	imports: [HlmSpinnerComponent],
	exports: [HlmSpinnerComponent],
})
export class HlmSpinnerModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/spinner/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/spinner/helm/src/lib/hlm-spinner.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const spinnerVariants = cva('inline-block', {
	variants: {
		variant: {
			default: 'animate-spin [&>svg]:text-foreground/30 [&>svg]:fill-accent',
		},
		size: {
			xs: 'h-4 w-4',
			sm: 'h-6 w-6',
			default: 'w-8 h-8 ',
			lg: 'w-12 h-12',
			xl: 'w-16 h-16',
		},
	},
	defaultVariants: {
		variant: 'default',
		size: 'default',
	},
});
export type SpinnerVariants = VariantProps<typeof spinnerVariants>;

@Component({
	selector: 'hlm-spinner',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		role: 'status',
	},
	template: `
		<svg aria-hidden="true" class="animate-spin" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg">
			<path
				d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z"
				fill="currentColor"
			/>
			<path
				d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z"
				fill="currentFill"
			/>
		</svg>
		<span class="sr-only"><ng-content /></span>
	`,
})
export class HlmSpinnerComponent {
	public readonly size = input<SpinnerVariants['size']>('default');
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(spinnerVariants({ size: this.size() }), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/carousel/carousel.stories.ts
```typescript
import { argsToTemplate, Meta, moduleMetadata, StoryObj } from '@storybook/angular';

import Autoplay from 'embla-carousel-autoplay';
import { HlmCardContentDirective, HlmCardDirective } from '../card/helm/src';
import { HlmCarouselComponent, HlmCarouselImports } from './helm/src';

const meta: Meta<HlmCarouselComponent> = {
	title: 'Carousel',
	component: HlmCarouselComponent,
	tags: ['autodocs'],
	decorators: [
		moduleMetadata({
			imports: [HlmCarouselImports, HlmCardDirective, HlmCardContentDirective],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmCarouselComponent>;

export const Default: Story = {
	render: () => ({
		template: `
    <div class="flex items-center justify-center w-full p-4">
      <hlm-carousel class="w-full max-w-xs">
        <hlm-carousel-content>
        ${Array.from(
					{ length: 5 },
					(_, i) => `
        <hlm-carousel-item>
          <div class="p-1">
            <section hlmCard>
              <p hlmCardContent class="flex items-center justify-center p-6 aspect-square">
                <span class="text-4xl font-semibold">${i + 1}</span>
              </p>
            </section>
          </div>
        </hlm-carousel-item>
        `,
				).join('\n')}
        </hlm-carousel-content>
        <button hlm-carousel-previous></button>
        <button hlm-carousel-next></button>
      </hlm-carousel>
    </div>
    `,
	}),
};

export const Sizes: Story = {
	render: () => ({
		template: `
    <div class="flex items-center justify-center w-full p-4">
      <hlm-carousel class="w-full max-w-xs">
        <hlm-carousel-content>
					${Array.from(
						{ length: 5 },
						(_, i) => `
					<hlm-carousel-item class="md:basis-1/2 lg:basis-1/3">
						<div class="p-1">
							<section hlmCard>
								<p hlmCardContent class="flex items-center justify-center p-6 aspect-square">
									<span class="text-4xl font-semibold">${i + 1}</span>
								</p>
							</section>
						</div>
					</hlm-carousel-item>
					`,
					).join('\n')}
        </hlm-carousel-content>
        <button hlm-carousel-previous></button>
        <button hlm-carousel-next></button>
      </hlm-carousel>
    </div>
    `,
	}),
};

export const Spacing: Story = {
	render: () => ({
		template: `
    <div class="flex items-center justify-center w-full p-4">
      <hlm-carousel class="w-full max-w-xs">
        <hlm-carousel-content class="-ml-1">
					${Array.from(
						{ length: 5 },
						(_, i) => `
					<hlm-carousel-item class="pl-1 md:basis-1/2 lg:basis-1/3">
						<div class="p-1">
							<section hlmCard>
								<p hlmCardContent class="flex items-center justify-center p-6 aspect-square">
									<span class="text-4xl font-semibold">${i + 1}</span>
								</p>
							</section>
						</div>
					</hlm-carousel-item>
					`,
					).join('\n')}
        </hlm-carousel-content>
        <button hlm-carousel-previous></button>
        <button hlm-carousel-next></button>
      </hlm-carousel>
    </div>
    `,
	}),
};

export const Orientation: Story = {
	render: () => ({
		template: `
    <div class="flex items-center justify-center w-full p-4">
      <hlm-carousel class="w-full max-w-xs" orientation="vertical">
        <hlm-carousel-content class="-mt-1 h-[200px]">
					${Array.from(
						{ length: 5 },
						(_, i) => `
					<hlm-carousel-item class="pt-1 md:basis-1/2">
						<div class="p-1">
							<section hlmCard>
								<p hlmCardContent class="flex items-center justify-center p-6">
									<span class="text-4xl font-semibold">${i + 1}</span>
								</p>
							</section>
						</div>
					</hlm-carousel-item>
					`,
					).join('\n')}
        </hlm-carousel-content>
        <button hlm-carousel-previous></button>
        <button hlm-carousel-next></button>
      </hlm-carousel>
    </div>
    `,
	}),
};

export const Plugins: Story = {
	args: {
		plugins: [Autoplay({ delay: 3000 })],
	},
	render: ({ ...args }) => ({
		props: args,
		template: `
    <div class="flex items-center justify-center w-full p-4">
      <hlm-carousel class="w-full max-w-xs" ${argsToTemplate(args)}>
        <hlm-carousel-content>
        ${Array.from(
					{ length: 5 },
					(_, i) => `
        <hlm-carousel-item>
          <div class="p-1">
            <section hlmCard>
              <p hlmCardContent class="flex items-center justify-center p-6 aspect-square">
                <span class="text-4xl font-semibold">${i + 1}</span>
              </p>
            </section>
          </div>
        </hlm-carousel-item>
        `,
				).join('\n')}
        </hlm-carousel-content>
        <button hlm-carousel-previous></button>
        <button hlm-carousel-next></button>
      </hlm-carousel>
    </div>
    `,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/carousel/helm/README.md
```
# ui-carousel-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-carousel-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/carousel/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: ['attribute', 'element'],
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/carousel/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-carousel-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	coverageDirectory: '../../../../coverage/libs/ui/carousel/helm',
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/carousel/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/carousel/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/carousel/helm/package.json
```json
{
	"name": "@spartan-ng/ui-carousel-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@ng-icons/core": ">=29.0.0",
		"@ng-icons/lucide": ">=29.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"@spartan-ng/ui-button-helm": "0.0.1-alpha.381",
		"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
		"clsx": "^2.1.1",
		"embla-carousel-angular": "19.0.0"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/carousel/helm/project.json
```json
{
	"name": "ui-carousel-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/carousel/helm/src",
	"prefix": "hlm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/carousel/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/carousel/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/carousel/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/carousel/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-carousel-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/carousel/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/carousel/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/carousel/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/carousel/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/carousel/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmCarouselContentComponent } from './lib/hlm-carousel-content.component';
import { HlmCarouselItemComponent } from './lib/hlm-carousel-item.component';
import { HlmCarouselNextComponent } from './lib/hlm-carousel-next.component';
import { HlmCarouselPreviousComponent } from './lib/hlm-carousel-previous.component';
import { HlmCarouselComponent } from './lib/hlm-carousel.component';

export * from './lib/hlm-carousel-content.component';
export * from './lib/hlm-carousel-item.component';
export * from './lib/hlm-carousel-next.component';
export * from './lib/hlm-carousel-previous.component';
export * from './lib/hlm-carousel.component';

export const HlmCarouselImports = [
	HlmCarouselComponent,
	HlmCarouselContentComponent,
	HlmCarouselItemComponent,
	HlmCarouselPreviousComponent,
	HlmCarouselNextComponent,
] as const;

@NgModule({
	imports: [...HlmCarouselImports],
	exports: [...HlmCarouselImports],
})
export class HlmCarouselModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/carousel/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/carousel/helm/src/lib/hlm-carousel-content.component.ts
```typescript
import { ChangeDetectionStrategy, Component, ViewEncapsulation, computed, inject, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';
import { HlmCarouselComponent } from './hlm-carousel.component';

@Component({
	selector: 'hlm-carousel-content',
	standalone: true,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	host: {
		'[class]': '_computedClass()',
	},
	template: `
		<ng-content />
	`,
})
export class HlmCarouselContentComponent {
	private readonly _orientation = inject(HlmCarouselComponent).orientation;

	public _userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm('flex', this._orientation() === 'horizontal' ? '-ml-4' : '-mt-4 flex-col', this._userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/carousel/helm/src/lib/hlm-carousel-item.component.ts
```typescript
import { ChangeDetectionStrategy, Component, ViewEncapsulation, computed, inject, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';
import { HlmCarouselComponent } from './hlm-carousel.component';

@Component({
	selector: 'hlm-carousel-item',
	standalone: true,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	host: {
		'[class]': '_computedClass()',
		role: 'group',
		'aria-roledescription': 'slide',
	},
	template: `
		<ng-content />
	`,
})
export class HlmCarouselItemComponent {
	public _userClass = input<ClassValue>('', { alias: 'class' });
	private readonly _orientation = inject(HlmCarouselComponent).orientation;
	protected _computedClass = computed(() =>
		hlm(
			'min-w-0 shrink-0 grow-0 basis-full',
			this._orientation() === 'horizontal' ? 'pl-4' : 'pt-4',
			this._userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/carousel/helm/src/lib/hlm-carousel-next.component.ts
```typescript
import {
	ChangeDetectionStrategy,
	Component,
	ViewEncapsulation,
	computed,
	effect,
	inject,
	input,
	untracked,
} from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideArrowRight } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { HlmButtonDirective, provideBrnButtonConfig } from '@spartan-ng/ui-button-helm';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';
import { HlmCarouselComponent } from './hlm-carousel.component';

@Component({
	selector: 'button[hlm-carousel-next], button[hlmCarouselNext]',
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	host: {
		'[disabled]': 'isDisabled()',
		'(click)': '_carousel.scrollNext()',
	},
	hostDirectives: [{ directive: HlmButtonDirective, inputs: ['variant', 'size'] }],
	providers: [provideIcons({ lucideArrowRight }), provideBrnButtonConfig({ variant: 'outline', size: 'icon' })],
	imports: [NgIcon, HlmIconDirective],
	template: `
		<ng-icon hlm size="sm" name="lucideArrowRight" />
		<span class="sr-only">Next slide</span>
	`,
})
export class HlmCarouselNextComponent {
	private readonly _button = inject(HlmButtonDirective);
	private readonly _carousel = inject(HlmCarouselComponent);
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	private readonly _computedClass = computed(() =>
		hlm(
			'absolute h-8 w-8 rounded-full',
			this._carousel.orientation() === 'horizontal'
				? '-right-12 top-1/2 -translate-y-1/2'
				: '-bottom-12 left-1/2 -translate-x-1/2 rotate-90',
			this.userClass(),
		),
	);
	protected readonly isDisabled = () => !this._carousel.canScrollNext();

	constructor() {
		effect(() => {
			const computedClass = this._computedClass();

			untracked(() => this._button.setClass(computedClass));
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/carousel/helm/src/lib/hlm-carousel-previous.component.ts
```typescript
import {
	ChangeDetectionStrategy,
	Component,
	ViewEncapsulation,
	computed,
	effect,
	inject,
	input,
	untracked,
} from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideArrowLeft } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { HlmButtonDirective, provideBrnButtonConfig } from '@spartan-ng/ui-button-helm';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';
import { HlmCarouselComponent } from './hlm-carousel.component';

@Component({
	selector: 'button[hlm-carousel-previous], button[hlmCarouselPrevious]',
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	host: {
		'[disabled]': 'isDisabled()',
		'(click)': '_carousel.scrollPrev()',
	},
	hostDirectives: [{ directive: HlmButtonDirective, inputs: ['variant', 'size'] }],
	providers: [provideIcons({ lucideArrowLeft }), provideBrnButtonConfig({ variant: 'outline', size: 'icon' })],
	imports: [NgIcon, HlmIconDirective],
	template: `
		<ng-icon hlm size="sm" name="lucideArrowLeft" />
		<span class="sr-only">Previous slide</span>
	`,
})
export class HlmCarouselPreviousComponent {
	private readonly _button = inject(HlmButtonDirective);

	protected readonly _carousel = inject(HlmCarouselComponent);

	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	private readonly _computedClass = computed(() =>
		hlm(
			'absolute h-8 w-8 rounded-full',
			this._carousel.orientation() === 'horizontal'
				? '-left-12 top-1/2 -translate-y-1/2'
				: '-top-12 left-1/2 -translate-x-1/2 rotate-90',
			this.userClass(),
		),
	);
	protected readonly isDisabled = () => !this._carousel.canScrollPrev();

	constructor() {
		effect(() => {
			const computedClass = this._computedClass();

			untracked(() => this._button.setClass(computedClass));
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/carousel/helm/src/lib/hlm-carousel.component.ts
```typescript
import {
	ChangeDetectionStrategy,
	Component,
	HostListener,
	type InputSignal,
	type Signal,
	ViewChild,
	ViewEncapsulation,
	computed,
	input,
	signal,
} from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';
import {
	EmblaCarouselDirective,
	type EmblaEventType,
	type EmblaOptionsType,
	type EmblaPluginType,
} from 'embla-carousel-angular';

@Component({
	selector: 'hlm-carousel',
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	host: {
		'[class]': '_computedClass()',
		role: 'region',
		'aria-roledescription': 'carousel',
	},
	imports: [EmblaCarouselDirective],
	template: `
		<div
			emblaCarousel
			class="overflow-hidden"
			[plugins]="plugins()"
			[options]="emblaOptions()"
			[subscribeToEvents]="['init', 'select', 'reInit']"
			(emblaChange)="onEmblaEvent($event)"
		>
			<ng-content select="hlm-carousel-content" />
		</div>
		<ng-content />
	`,
})
export class HlmCarouselComponent {
	@ViewChild(EmblaCarouselDirective) protected emblaCarousel?: EmblaCarouselDirective;

	public _userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('relative', this._userClass()));

	public orientation = input<'horizontal' | 'vertical'>('horizontal');
	public options: InputSignal<Omit<EmblaOptionsType, 'axis'> | undefined> = input();
	public plugins: InputSignal<EmblaPluginType[]> = input([] as EmblaPluginType[]);

	protected emblaOptions: Signal<EmblaOptionsType> = computed(() => ({
		...this.options(),
		axis: this.orientation() === 'horizontal' ? 'x' : 'y',
	}));

	private readonly _canScrollPrev = signal(false);
	public canScrollPrev = this._canScrollPrev.asReadonly();
	private readonly _canScrollNext = signal(false);
	public canScrollNext = this._canScrollNext.asReadonly();

	protected onEmblaEvent(event: EmblaEventType) {
		const emblaApi = this.emblaCarousel?.emblaApi;

		if (!emblaApi) {
			return;
		}

		if (event === 'select' || event === 'init' || event === 'reInit') {
			this._canScrollPrev.set(emblaApi.canScrollPrev());
			this._canScrollNext.set(emblaApi.canScrollNext());
		}
	}

	@HostListener('keydown', ['$event'])
	protected onKeydown(event: KeyboardEvent) {
		if (event.key === 'ArrowLeft') {
			event.preventDefault();
			this.emblaCarousel?.scrollPrev();
		} else if (event.key === 'ArrowRight') {
			event.preventDefault();
			this.emblaCarousel?.scrollNext();
		}
	}

	scrollPrev() {
		this.emblaCarousel?.scrollPrev();
	}

	scrollNext() {
		this.emblaCarousel?.scrollNext();
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/combobox/combobox.stories.ts
```typescript
import { Component, signal } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import * as lucide from '@ng-icons/lucide';
import { BrnCommandImports } from '@spartan-ng/brain/command';
import { BrnPopoverImports } from '@spartan-ng/brain/popover';
import type { Meta, StoryObj } from '@storybook/angular';
import { moduleMetadata } from '@storybook/angular';
import { HlmButtonDirective } from '../button/helm/src';
import { HlmCommandImports } from '../command/helm/src';
import { HlmIconDirective } from '../icon/helm/src';
import { HlmPopoverContentDirective } from '../popover/helm/src';

const meta: Meta<{}> = {
	title: 'Combobox',
	decorators: [
		moduleMetadata({
			providers: [provideIcons(lucide)],
			imports: [BrnCommandImports, HlmCommandImports, NgIcon, HlmIconDirective, HlmButtonDirective],
		}),
	],
};

export default meta;
type Story = StoryObj<{}>;
type Framework = { label: string; value: string };

@Component({
	selector: 'combobox-component',
	standalone: true,
	imports: [
		BrnCommandImports,
		HlmCommandImports,
		BrnPopoverImports,
		HlmPopoverContentDirective,
		NgIcon,
		HlmIconDirective,
		HlmButtonDirective,
	],
	template: `
		<brn-popover [state]="state()" (stateChanged)="stateChanged($event)" sideOffset="5">
			<button
				class="w-[200px] justify-between"
				id="edit-profile"
				variant="outline"
				brnPopoverTrigger
				(click)="state.set('open')"
				hlmBtn
			>
				{{ currentFramework() ? currentFramework().label : 'Select framework...' }}
				<ng-icon hlm size="sm" name="lucideChevronsUpDown" />
			</button>
			<hlm-command *brnPopoverContent="let ctx" hlmPopoverContent class="w-[200px] p-0">
				<hlm-command-search>
					<ng-icon hlm name="lucideSearch" />
					<input placeholder="Search framework..." hlm-command-search-input />
				</hlm-command-search>
				<div *brnCommandEmpty hlmCommandEmpty>No results found.</div>
				<hlm-command-list>
					<hlm-command-group>
						@for (framework of frameworks; track framework) {
							<button hlm-command-item [value]="framework.value" (selected)="commandSelected(framework)">
								<ng-icon
									hlm
									[class.opacity-0]="currentFramework()?.value !== framework.value"
									name="lucideCheck"
									hlmCommandIcon
								/>
								{{ framework.label }}
							</button>
						}
					</hlm-command-group>
				</hlm-command-list>
			</hlm-command>
		</brn-popover>
	`,
})
class ComboboxComponent {
	public frameworks = [
		{
			label: 'AnalogJs',
			value: 'analogjs',
		},
		{
			label: 'Angular',
			value: 'angular',
		},
		{
			label: 'Vue',
			value: 'vue',
		},
		{
			label: 'Nuxt',
			value: 'nuxt',
		},
		{
			label: 'React',
			value: 'react',
		},
		{
			label: 'NextJs',
			value: 'nextjs',
		},
	];
	public currentFramework = signal<Framework | undefined>(undefined);
	public state = signal<'closed' | 'open'>('closed');

	stateChanged(state: 'open' | 'closed') {
		this.state.set(state);
	}

	commandSelected(framework: Framework) {
		this.state.set('closed');
		if (this.currentFramework()?.value === framework.value) {
			this.currentFramework.set(undefined);
		} else {
			this.currentFramework.set(framework);
		}
	}
}

export const Default: Story = {
	decorators: [
		moduleMetadata({
			imports: [ComboboxComponent],
		}),
	],
	render: () => ({
		template: '<combobox-component/>',
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle-group/toggle-group.stories.ts
```typescript
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideBold, lucideItalic, lucideUnderline } from '@ng-icons/lucide';
import {
	BrnToggleGroupComponent,
	BrnToggleGroupItemDirective,
	BrnToggleGroupModule,
} from '@spartan-ng/brain/toggle-group';
import type { Meta, StoryObj } from '@storybook/angular';
import { argsToTemplate, moduleMetadata } from '@storybook/angular';

import { BooleanInput } from '@angular/cdk/coercion';
import { JsonPipe } from '@angular/common';
import { Component, input, signal } from '@angular/core';
import { FormControl, FormGroup, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { HlmButtonDirective } from '../button/helm/src';
import { HlmIconDirective } from '../icon/helm/src';
import { hlmP } from '../typography/helm/src';
import { HlmToggleGroupDirective, HlmToggleGroupItemDirective, HlmToggleGroupModule } from './helm/src';

const meta: Meta<HlmToggleGroupDirective> = {
	title: 'Toggle Group',
	component: HlmToggleGroupDirective,
	tags: ['autodocs'],
	argTypes: {
		variant: {
			control: 'select',
			options: ['default', 'outline'],
			description: 'The visual style of the toggle group',
			defaultValue: 'default',
		},
		size: {
			control: 'select',
			options: ['default', 'sm', 'lg'],
			description: 'The size of the toggle group',
			defaultValue: 'default',
		},
		userClass: {
			control: 'text',
			description: 'Additional CSS classes to apply to the toggle group',
		},
	},
	decorators: [
		moduleMetadata({
			imports: [
				BrnToggleGroupComponent,
				// BrnToggleGroupModule,
				HlmToggleGroupModule,
				BrnToggleGroupItemDirective,
				HlmToggleGroupDirective,
				HlmToggleGroupItemDirective,
				NgIcon,
				HlmIconDirective,
			],
			providers: [provideIcons({ lucideBold, lucideItalic, lucideUnderline })],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmToggleGroupDirective>;

export const Default: Story = {
	render: (args) => ({
		template: `
		<div class="flex items-center justify-center p-4">
	 <brn-toggle-group hlm multiple="false" nullable="true" ${argsToTemplate(args)} >
	 <button aria-label="Bold Toggle" value="bold" hlmToggleGroupItem>
	   <ng-icon hlm size="sm" name="lucideBold" ${argsToTemplate(args)} />
	 </button>

	 <button aria-label="Italic Toggle" value="italic" hlmToggleGroupItem>
	   <ng-icon hlm size="sm" name="lucideItalic" ${argsToTemplate(args)} />
	 </button>

	 <button aria-label="Underline Toggle" value="underline" hlmToggleGroupItem>
	   <ng-icon hlm size="sm" name="lucideUnderline" ${argsToTemplate(args)} />
	 </button>
			</brn-toggle-group>
		</div>
		`,
	}),
};

export const Outline: Story = {
	render: (args) => ({
		template: `
		<div class="flex items-center justify-center p-4">
	<brn-toggle-group hlm size="sm" variant="outline" multiple="true" nullable="true" ${argsToTemplate(args)}>
	 <button aria-label="Bold" value="bold" hlmToggleGroupItem>
		 <ng-icon hlm size="sm" name="lucideBold" />
	 </button>

	 <button aria-label="Italic" value="italic" hlmToggleGroupItem>
	   <ng-icon hlm size="sm" name="lucideItalic" />
	 </button>

	 <button aria-label="Underline" value="underline" hlmToggleGroupItem>
	 	 <ng-icon hlm size="sm" name="lucideUnderline" />
	 </button>
	</brn-toggle-group>
		</div>
		`,
	}),
};

export const Small: Story = {
	render: (args) => ({
		template: `
	<div class="flex items-center justify-center p-4">
	<brn-toggle-group hlm size="sm" ${argsToTemplate(args)} multiple="false" nullable="true" >
	<button aria-label="Bold" value="bold" hlmToggleGroupItem>
	 <ng-icon hlm size="sm" name="lucideBold" />
	</button>
	<button aria-label="Italic" value="italic" hlmToggleGroupItem>
	  <ng-icon hlm size="sm" name="lucideItalic" />
	</button>
	<button aria-label="Underline" value="underline" hlmToggleGroupItem>
		 <ng-icon hlm size="sm" name="lucideUnderline" />
	</button>
	</brn-toggle-group>
	</div>
		`,
	}),
};

export const Large: Story = {
	render: (args) => ({
		template: `
		<div class="flex items-center justify-center p-4">
<brn-toggle-group hlm ${argsToTemplate(args)} multiple="false" nullable="true" size="lg">
	 <button aria-label="Bold" value="bold" hlmToggleGroupItem>
		 <ng-icon hlm size="lg" name="lucideBold" />
	 </button>

	 <button aria-label="Italic" value="italic" hlmToggleGroupItem>
	   <ng-icon hlm size="lg" name="lucideItalic" />
	 </button>

	 <button aria-label="Underline" value="underline" hlmToggleGroupItem>
	 	 <ng-icon hlm size="lg" name="lucideUnderline" />
	 </button>
	</brn-toggle-group>
		</div>
		`,
	}),
};

export const Disabled: Story = {
	render: () => ({
		template: `
	<div class="flex items-center justify-center p-4">
  <brn-toggle-group hlm multiple="false" nullable="true" size="sm" disabled>
	<button aria-label="Bold" value="bold" hlmToggleGroupItem>
		 <ng-icon hlm size="sm" name="lucideBold" />
	</button>
	<button aria-label="Italic" value="italic" hlmToggleGroupItem>
	  <ng-icon hlm size="sm" name="lucideItalic" />
	</button>
	<button aria-label="Underline" value="underline" hlmToggleGroupItem>
		 <ng-icon hlm size="sm" name="lucideUnderline" />
	</button>
	</brn-toggle-group>
	</div>
		`,
	}),
};

type City = { name: string; population: number };
const CITIES = [
	{
		name: 'Sparta',
		population: 23234233,
	},
	{
		name: 'Athens',
		population: 989889,
	},
	{
		name: 'Corinth',
		population: 988989,
	},
	{
		name: 'Syracuse',
		population: 998889,
	},
];

@Component({
	selector: 'hlm-toggle-group-story',
	standalone: true,
	imports: [BrnToggleGroupModule, HlmToggleGroupModule, HlmToggleGroupItemDirective, HlmButtonDirective, FormsModule],
	template: `
		<div class="flex space-x-4 p-4">
			<brn-toggle-group
				hlm
				[disabled]="disabled()"
				[nullable]="nullable()"
				[multiple]="multiple()"
				[(ngModel)]="selected"
				variant="merged"
			>
				@for (city of cities; track city.name; let last = $last) {
					<button [value]="city" hlmToggleGroupItem>
						{{ city.name }}
					</button>
				}
			</brn-toggle-group>

			<button hlmBtn size="sm" (click)="setToSyracuse()">Set to Syracuse</button>
			<button hlmBtn size="sm" (click)="addCity()">Add Piraeus</button>
		</div>

		<p class="${hlmP}">{{ multiple() ? 'Cities selected' : 'City selected' }}: {{ selectedCities }}</p>
	`,
})
class HlmToggleGroupStoryComponent {
	public multiple = input<BooleanInput>(false);
	public nullable = input<BooleanInput>(false);
	public disabled = input<BooleanInput>(false);
	public defaultValue = input<City | City[] | undefined>(undefined);
	public selected = signal<City | City[] | undefined>(undefined);

	private _cities: City[] = [...CITIES];
	public get cities(): City[] {
		return this._cities;
	}

	ngOnInit() {
		this.selected.set(this.defaultValue());
	}

	get selectedCities() {
		if (!this.selected()) {
			return this.multiple() ? 'No cities selected' : 'No city selected';
		}

		if (Array.isArray(this.selected())) {
			const selectedArray = this.selected() as City[];
			if (selectedArray.length === 0) return 'No cities selected';

			return selectedArray.map((c) => c.name).join(',');
		}

		// At this point, selected must be a single City
		const selectedCity = this.selected() as City;
		return selectedCity.name;
	}

	setToSyracuse() {
		this.selected.set(this.multiple() ? [this.cities[3]] : this.cities[3]);
	}

	addCity() {
		this.cities.push({
			name: 'Piraeus',
			population: 998889,
		});
	}
}

export const ToggleGroupSingleNullable: Story = {
	name: 'Toggle Group - Single Nullable',
	decorators: [
		moduleMetadata({
			imports: [HlmToggleGroupStoryComponent],
		}),
	],
	render: () => ({
		template: '<hlm-toggle-group-story nullable="true"/>',
	}),
};

export const ToggleGroupMultipleNullable: Story = {
	name: 'Toggle Group - Multiple Nullable',
	decorators: [
		moduleMetadata({
			imports: [HlmToggleGroupStoryComponent],
		}),
	],
	render: () => ({
		template: '<hlm-toggle-group-story nullable="true" multiple="true"/>',
	}),
};

export const ToggleGroupSingle: StoryObj<{ defaultValue: City }> = {
	name: 'Toggle Group - Single',
	decorators: [
		moduleMetadata({
			imports: [HlmToggleGroupStoryComponent],
		}),
	],
	args: {
		defaultValue: CITIES[0],
	},
	render: ({ defaultValue }) => ({
		props: { defaultValue },
		template: '<hlm-toggle-group-story nullable="false" [defaultValue]="defaultValue"/>',
	}),
};

export const ToggleGroupDisabled: Story = {
	name: 'Toggle Group - Disabled',
	decorators: [
		moduleMetadata({
			imports: [HlmToggleGroupStoryComponent],
		}),
	],
	render: () => ({
		template: '<hlm-toggle-group-story [disabled]="true"/>',
	}),
};

export const ToggleGroupMultiple: StoryObj<{ defaultValue: City[] }> = {
	name: 'Toggle Group - Multiple',
	decorators: [
		moduleMetadata({
			imports: [HlmToggleGroupStoryComponent],
		}),
	],
	args: {
		defaultValue: [CITIES[0]],
	},
	render: ({ defaultValue }) => ({
		props: { defaultValue },
		template: '<hlm-toggle-group-story multiple="true" [defaultValue]="defaultValue"/>',
	}),
};

@Component({
	selector: 'hlm-toggle-group-form-story',
	standalone: true,
	imports: [
		BrnToggleGroupModule,
		HlmToggleGroupModule,
		HlmToggleGroupItemDirective,
		FormsModule,
		ReactiveFormsModule,
		JsonPipe,
	],
	template: `
		<form class="flex space-x-4 p-4" [formGroup]="citiesForm">
			<brn-toggle-group hlm formControlName="selectedCity" variant="merged">
				@for (city of cities; track city.name; let last = $last) {
					<button [value]="city" hlmToggleGroupItem>
						{{ city.name }}
					</button>
				}
			</brn-toggle-group>
		</form>

		<pre class="${hlmP}" data-testid="selectedCity">{{ citiesForm.controls.selectedCity?.getRawValue()?.name }}</pre>
	`,
})
class HlmToggleGroupFormStoryComponent {
	protected readonly cities: City[] = CITIES;
	protected readonly citiesForm = new FormGroup({
		selectedCity: new FormControl(CITIES[0]),
	});
}

export const ToggleGroupForm: Story = {
	name: 'Toggle Group - Form',
	decorators: [
		moduleMetadata({
			imports: [HlmToggleGroupFormStoryComponent],
		}),
	],
	render: () => ({
		template: '<hlm-toggle-group-form-story/>',
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle-group/helm/README.md
```
# ui-toggle-group-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-toggle-group-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle-group/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle-group/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-toggle-group-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle-group/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/toggle-group/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle-group/helm/package.json
```json
{
	"name": "@spartan-ng/ui-toggle-group-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=18.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"class-variance-authority": "^0.7.0",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle-group/helm/project.json
```json
{
	"name": "ui-toggle-group-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/toggle-group/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/toggle-group/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/toggle-group/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/toggle-group/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/toggle-group/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-toggle-group-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle-group/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle-group/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle-group/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle-group/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle-group/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmToggleGroupDirective } from './lib/hlm-toggle-group.directive';
import { HlmToggleGroupItemDirective } from './lib/hlm-toggle-item.directive';

export * from './lib/hlm-toggle-group.directive';
export * from './lib/hlm-toggle-item.directive';

@NgModule({
	imports: [HlmToggleGroupItemDirective, HlmToggleGroupDirective],
	exports: [HlmToggleGroupItemDirective, HlmToggleGroupDirective],
})
export class HlmToggleGroupModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle-group/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle-group/helm/src/lib/hlm-toggle-group.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { VariantProps } from 'class-variance-authority';
import type { ClassValue } from 'clsx';
import { provideHlmToggleGroup } from './hlm-toggle-group.token';
import { toggleGroupItemVariants } from './hlm-toggle-item.directive';

type ToggleGroupItemVariants = VariantProps<typeof toggleGroupItemVariants>;
@Directive({
	selector: 'brn-toggle-group[hlm],[hlmToggleGroup]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	providers: [provideHlmToggleGroup(HlmToggleGroupDirective)],
})
export class HlmToggleGroupDirective {
	public readonly variant = input<ToggleGroupItemVariants['variant']>('default');
	public readonly size = input<ToggleGroupItemVariants['size']>('default');
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm('inline-flex items-center gap-x-2 focus:[&>[hlm][brnToggle]]:z-10', {
			'gap-x-0 rounded-md first-of-type:[&>[hlmToggleGroupItem]]:rounded-l-md last-of-type:[&>[hlmToggleGroupItem]]:rounded-r-md [&>[hlmToggleGroupItem][variant="outline"]]:-mx-[0.5px] [&>[hlmToggleGroupItem]]:rounded-none':
				this.variant() === 'merged',
			[String(this.userClass())]: !!this.userClass(),
		}),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle-group/helm/src/lib/hlm-toggle-group.token.ts
```typescript
import { ExistingProvider, InjectionToken, Type, inject } from '@angular/core';
import type { HlmToggleGroupDirective } from './hlm-toggle-group.directive';

const HlmToggleGroupToken = new InjectionToken<HlmToggleGroupDirective>('HlmToggleGroupToken');

export function provideHlmToggleGroup(config: Type<HlmToggleGroupDirective>): ExistingProvider {
	return { provide: HlmToggleGroupToken, useExisting: config };
}

export function injectHlmToggleGroup(): HlmToggleGroupDirective {
	return inject(HlmToggleGroupToken, { optional: true }) as HlmToggleGroupDirective;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle-group/helm/src/lib/hlm-toggle-item.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';
import { injectHlmToggleGroup } from './hlm-toggle-group.token';

export const toggleGroupItemVariants = cva(
	'inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground',
	{
		variants: {
			variant: {
				default: 'bg-transparent',
				outline: 'border border-input bg-transparent hover:bg-accent hover:text-accent-foreground',
				merged:
					'border border-l-0 first-of-type:border-l border-input bg-transparent hover:bg-accent hover:text-accent-foreground',
			},
			size: {
				default: 'h-9 px-3',
				sm: 'h-8 px-2',
				lg: 'h-10 px-3',
			},
		},
		defaultVariants: {
			variant: 'default',
			size: 'default',
		},
	},
);
type ToggleGroupItemVariants = VariantProps<typeof toggleGroupItemVariants>;

@Directive({
	selector: '[hlmToggleGroupItem],[brnToggleGroupItem][hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmToggleGroupItemDirective {
	private readonly _parentGroup = injectHlmToggleGroup();
	public readonly variant = input<ToggleGroupItemVariants['variant']>('default');
	public readonly size = input<ToggleGroupItemVariants['size']>('default');
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => {
		const variantToUse = this._parentGroup?.variant() ?? this.variant();
		const sizeToUse = this._parentGroup?.size() ?? this.size();
		const userClass = this._parentGroup?.userClass() ?? this.userClass();
		return hlm(
			toggleGroupItemVariants({
				variant: variantToUse,
				size: sizeToUse,
			}),
			userClass,
		);
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle/toggle.stories.ts
```typescript
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideItalic } from '@ng-icons/lucide';
import { BrnToggleDirective } from '@spartan-ng/brain/toggle';
import { type Meta, type StoryObj, moduleMetadata } from '@storybook/angular';

import { HlmIconDirective } from '../icon/helm/src';
import { HlmToggleDirective } from './helm/src';

const meta: Meta<HlmToggleDirective> = {
	title: 'Toggle',
	component: HlmToggleDirective,
	tags: ['autodocs'],
	decorators: [
		moduleMetadata({
			imports: [HlmToggleDirective, BrnToggleDirective, NgIcon, HlmIconDirective],
			providers: [provideIcons({ lucideItalic })],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmToggleDirective>;

export const Default: Story = {
	render: () => ({
		template: `
    <div class='space-x-3'>
    <button aria-label='Italic Toggle' size='sm' hlmToggle><ng-icon hlm name='lucideItalic'/></button>
    <button aria-label='Italic Toggle' hlmToggle><ng-icon hlm name='lucideItalic'/></button>
    <button aria-label='Italic Toggle' size='lg' hlmToggle><ng-icon hlm name='lucideItalic'/></button>
    <button aria-label='Italic Toggle' variant='outline' hlmToggle><ng-icon hlm name='lucideItalic'/></button>
    <button aria-label='Italic Toggle' disabled hlmToggle><ng-icon hlm name='lucideItalic'/></button>
    </div>
    `,
	}),
};

export const WithText: Story = {
	name: 'With Text',
	render: () => ({
		template: `
    <div class='space-x-3'>
    <button size='sm' hlmToggle><ng-icon hlm name='lucideItalic'/> <span class='ml-2'>Italic</span></button>
    <button hlmToggle><ng-icon hlm name='lucideItalic'/> <span class='ml-2'>Italic</span></button>
    <button size='lg' hlmToggle><ng-icon hlm name='lucideItalic'/> <span class='ml-2'>Italic</span></button>
    <button variant='outline' hlmToggle><ng-icon hlm name='lucideItalic'/> <span class='ml-2'>Italic</span></button>
    <button disabled hlmToggle><ng-icon hlm name='lucideItalic'/> <span class='ml-2'>Italic</span></button>
    </div>
`,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle/helm/README.md
```
# ui-toggle-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-toggle-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-toggle-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/toggle/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle/helm/package.json
```json
{
	"name": "@spartan-ng/ui-toggle-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"class-variance-authority": "^0.7.0",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle/helm/project.json
```json
{
	"name": "ui-toggle-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/toggle/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/toggle/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/toggle/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/toggle/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/toggle/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-toggle-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmToggleDirective } from './lib/hlm-toggle.directive';

export * from './lib/hlm-toggle.directive';
@NgModule({
	imports: [HlmToggleDirective],
	exports: [HlmToggleDirective],
})
export class HlmToggleModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/toggle/helm/src/lib/hlm-toggle.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { cva, type VariantProps } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const toggleVariants = cva(
	'inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground',
	{
		variants: {
			variant: {
				default: 'bg-transparent',
				outline: 'border border-input bg-transparent hover:bg-accent hover:text-accent-foreground',
			},
			size: {
				default: 'h-9 px-3',
				sm: 'h-8 px-2',
				lg: 'h-10 px-3',
			},
		},
		defaultVariants: {
			variant: 'default',
			size: 'default',
		},
	},
);
export type ToggleVariants = VariantProps<typeof toggleVariants>;

@Directive({
	selector: '[hlmToggle],[brnToggle][hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmToggleDirective {
	public readonly variant = input<ToggleVariants['variant']>('default');
	public readonly size = input<ToggleVariants['size']>('default');
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() => {
		const variantToUse = this.variant();
		const sizeToUse = this.size();
		const userClass = this.userClass();

		return hlm(
			toggleVariants({
				variant: variantToUse,
				size: sizeToUse,
			}),
			userClass,
		);
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/dialog.stories.ts
```typescript
import { Component, HostBinding, inject } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideCheck } from '@ng-icons/lucide';
import {
	BrnDialogContentDirective,
	BrnDialogImports,
	BrnDialogRef,
	BrnDialogTriggerDirective,
	injectBrnDialogContext,
} from '@spartan-ng/brain/dialog';
import { type Meta, type StoryObj, moduleMetadata } from '@storybook/angular';
import { HlmButtonDirective } from '../button/helm/src';
import { HlmIconDirective } from '../icon/helm/src';
import { HlmInputDirective } from '../input/helm/src';
import { HlmLabelDirective } from '../label/helm/src';
import { HlmTableComponent, HlmTdComponent, HlmThComponent, HlmTrowComponent } from '../table/helm/src';
import {
	HlmDialogComponent,
	HlmDialogContentComponent,
	HlmDialogDescriptionDirective,
	HlmDialogHeaderComponent,
	HlmDialogImports,
	HlmDialogService,
	HlmDialogTitleDirective,
} from './helm/src';

const meta: Meta<HlmDialogComponent> = {
	title: 'Dialog',
	component: HlmDialogComponent,
	tags: ['autodocs'],
	decorators: [
		moduleMetadata({
			imports: [BrnDialogImports, HlmDialogImports, HlmLabelDirective, HlmButtonDirective, HlmInputDirective],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmDialogComponent>;

export const Default: Story = {
	render: () => ({
		template: `
    <hlm-dialog>
    <button id='edit-profile' brnDialogTrigger hlmBtn>Edit Profile</button>
    <hlm-dialog-content class='sm:max-w-[425px]' *brnDialogContent='let ctx'>
         <hlm-dialog-header>
          <h3 hlmDialogTitle>Edit profile</h3>
          <p hlmDialogDescription>
            Make changes to your profile here. Click save when you're done.
          </p>
        </hlm-dialog-header>
        <div class='py-4 grid gap-4'>
          <div class='items-center grid grid-cols-4 gap-4'>
            <label hlmLabel for='name' class='text-right'>
              Name
            </label>
            <input hlmInput id='name' value='Pedro Duarte' class='col-span-3' />
          </div>
          <div class='items-center grid grid-cols-4 gap-4'>
            <label hlmLabel for='username' class='text-right'>
              Username
            </label>
            <input hlmInput id='username' value='@peduarte' class='col-span-3' />
          </div>
        </div>
        <hlm-dialog-footer>
          <button hlmBtn type='submit'>Save changes</button>
        </hlm-dialog-footer>
    </hlm-dialog-content>
    </hlm-dialog>
    `,
	}),
};

@Component({
	selector: 'nested-dialog-story',
	standalone: true,
	imports: [
		HlmDialogComponent,
		HlmButtonDirective,
		BrnDialogTriggerDirective,
		BrnDialogContentDirective,
		HlmDialogContentComponent,
		HlmDialogHeaderComponent,
		HlmDialogDescriptionDirective,
		HlmDialogTitleDirective,
	],
	template: `
		<hlm-dialog>
			<button brnDialogTrigger hlmBtn>Open Dialog</button>
			<hlm-dialog-content *brnDialogContent>
				<hlm-dialog-header>
					<h3 hlmDialogTitle>First dialog</h3>
					<p hlmDialogDescription>Click the button below to open a nested dialog.</p>
				</hlm-dialog-header>

				<hlm-dialog>
					<button brnDialogTrigger hlmBtn class="w-full">Open Nested Dialog</button>
					<hlm-dialog-content *brnDialogContent="let ctx">
						<hlm-dialog-header>
							<h3 hlmDialogTitle>Nested dialog</h3>
							<p hlmDialogDescription>I am a nested dialog!</p>
						</hlm-dialog-header>

						<button hlmBtn (click)="ctx.close()">Close Nested Dialog</button>
					</hlm-dialog-content>
				</hlm-dialog>
			</hlm-dialog-content>
		</hlm-dialog>
	`,
})
class NestedDialogStory {}

export const NestedDialog: Story = {
	name: 'Nested Dialog',
	decorators: [
		moduleMetadata({
			imports: [NestedDialogStory],
		}),
	],
	render: () => ({
		template: '<nested-dialog-story />',
	}),
};

type ExampleUser = {
	name: string;
	email: string;
	phone: string;
};

@Component({
	selector: 'dialog-dynamic-component-story',
	standalone: true,
	imports: [HlmButtonDirective],
	template: `
		<button hlmBtn (click)="openDynamicComponent()">Select User</button>
	`,
})
class DialogDynamicComponentStory {
	private readonly _hlmDialogService = inject(HlmDialogService);

	private readonly _users: ExampleUser[] = [
		{
			name: 'Helena Chambers',
			email: 'helenachambers@chorizon.com',
			phone: '+1 (812) 588-3759',
		},
		{
			name: 'Josie Crane',
			email: 'josiecrane@hinway.com',
			phone: '+1 (884) 523-3324',
		},
		{
			name: 'Lou Hartman',
			email: 'louhartman@optyk.com',
			phone: '+1 (912) 479-3998',
		},
		{
			name: 'Lydia Zimmerman',
			email: 'lydiazimmerman@ultrasure.com',
			phone: '+1 (944) 511-2111',
		},
	];

	public openDynamicComponent() {
		const dialogRef = this._hlmDialogService.open(SelectUserComponent, {
			context: {
				users: this._users,
			},
			contentClass: 'sm:!max-w-[750px]',
		});

		dialogRef.closed$.subscribe((user) => {
			if (user) {
				console.log('Selected user:', user);
			}
		});
	}
}

@Component({
	selector: 'dynamic-content',
	standalone: true,
	imports: [
		HlmDialogHeaderComponent,
		HlmDialogTitleDirective,
		HlmDialogDescriptionDirective,
		HlmTableComponent,
		HlmThComponent,
		HlmTrowComponent,
		HlmTdComponent,
		HlmButtonDirective,
		NgIcon,
		HlmIconDirective,
	],
	providers: [provideIcons({ lucideCheck })],
	template: `
		<hlm-dialog-header>
			<h3 hlmDialogTitle>Select user</h3>
			<p hlmDialogDescription>Click a row to select a user.</p>
		</hlm-dialog-header>

		<hlm-table>
			<hlm-trow>
				<hlm-th class="w-44">Name</hlm-th>
				<hlm-th class="w-60">Email</hlm-th>
				<hlm-th class="w-48">Phone</hlm-th>
			</hlm-trow>
			@for (user of users; track user.name) {
				<button class="text-left" (click)="selectUser(user)">
					<hlm-trow>
						<hlm-td truncate class="w-44 font-medium">{{ user.name }}</hlm-td>
						<hlm-td class="w-60">{{ user.email }}</hlm-td>
						<hlm-td class="w-48">{{ user.phone }}</hlm-td>
					</hlm-trow>
				</button>
			}
		</hlm-table>
	`,
})
class SelectUserComponent {
	@HostBinding('class') private readonly _class: string = 'flex flex-col gap-4';

	private readonly _hlmDialogService = inject(HlmDialogService);
	private readonly _dialogRef = inject<BrnDialogRef<ExampleUser>>(BrnDialogRef);
	private readonly _dialogContext = injectBrnDialogContext<{ users: ExampleUser[] }>();

	protected readonly users = this._dialogContext.users;

	public selectUser(user: ExampleUser) {
		this._hlmDialogService.open(SelectUserComponent, { context: { users: [user] }, contentClass: 'sm:!max-w-[750px]' });
		// this._dialogRef.close(user);
	}
}

export const DynamicComponent: Story = {
	name: 'Dynamic Component',
	decorators: [
		moduleMetadata({
			imports: [DialogDynamicComponentStory],
		}),
	],
	render: () => ({
		template: '<dialog-dynamic-component-story />',
	}),
};

@Component({
	selector: 'nested-dialog-dynamic-first',
	standalone: true,
	imports: [
		HlmButtonDirective,
		HlmDialogContentComponent,
		HlmDialogHeaderComponent,
		HlmDialogTitleDirective,
		HlmDialogDescriptionDirective,
	],
	template: `
		<hlm-dialog-header>
			<h3 hlmDialogTitle>First dialog</h3>
			<p hlmDialogDescription>Click the button below to open a nested dialog.</p>
		</hlm-dialog-header>

		<button hlmBtn (click)="openNestedDialog()">Open Nested Dialog</button>
	`,
	host: {
		class: 'flex flex-col gap-4',
	},
})
class NestedDialogDynamicFirstComponent {
	private readonly _hlmDialogService = inject(HlmDialogService);

	public openNestedDialog() {
		this._hlmDialogService.open(NestedDialogDynamicNestedComponent);
	}
}

@Component({
	selector: 'nested-dialog-dynamic-nested',
	standalone: true,
	imports: [HlmButtonDirective, HlmDialogHeaderComponent, HlmDialogTitleDirective, HlmDialogDescriptionDirective],
	template: `
		<hlm-dialog-header>
			<h3 hlmDialogTitle>Nested dialog</h3>
			<p hlmDialogDescription>I am a nested dialog!</p>
		</hlm-dialog-header>

		<button hlmBtn (click)="close()">Close Nested Dialog</button>
	`,
	host: {
		class: 'flex flex-col gap-4',
	},
})
class NestedDialogDynamicNestedComponent {
	private readonly _brnDialogRef = inject(BrnDialogRef);

	public close() {
		this._brnDialogRef.close();
	}
}

@Component({
	selector: 'nested-dialog-dynamic-content-story',
	standalone: true,
	imports: [HlmButtonDirective],
	template: `
		<button hlmBtn (click)="openDialog()">Open Dialog</button>
	`,
})
class NestedDialogDynamicComponentStory {
	private readonly _hlmDialogService = inject(HlmDialogService);

	public openDialog() {
		this._hlmDialogService.open(NestedDialogDynamicFirstComponent);
	}
}

export const NestedDynamicComponent: Story = {
	name: 'Nested Dynamic Component',
	decorators: [
		moduleMetadata({
			imports: [NestedDialogDynamicComponentStory],
		}),
	],
	render: () => ({
		template: '<nested-dialog-dynamic-content-story />',
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/README.md
```
# ui-dialog-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-dialog-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-dialog-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/dialog/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/package.json
```json
{
	"name": "@spartan-ng/ui-dialog-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/cdk": ">=19.0.0",
		"@angular/common": ">=19.0.0",
		"@angular/core": ">=19.0.0",
		"@ng-icons/core": ">=29.0.0",
		"@ng-icons/lucide": ">=29.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/project.json
```json
{
	"name": "ui-dialog-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/dialog/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/dialog/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/dialog/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/dialog/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/dialog/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-dialog-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { HlmDialogCloseDirective } from './lib/hlm-dialog-close.directive';
import { HlmDialogContentComponent } from './lib/hlm-dialog-content.component';
import { HlmDialogDescriptionDirective } from './lib/hlm-dialog-description.directive';
import { HlmDialogFooterComponent } from './lib/hlm-dialog-footer.component';
import { HlmDialogHeaderComponent } from './lib/hlm-dialog-header.component';
import { HlmDialogOverlayDirective } from './lib/hlm-dialog-overlay.directive';
import { HlmDialogTitleDirective } from './lib/hlm-dialog-title.directive';
import { HlmDialogComponent } from './lib/hlm-dialog.component';

export * from './lib/hlm-dialog-close.directive';
export * from './lib/hlm-dialog-content.component';
export * from './lib/hlm-dialog-description.directive';
export * from './lib/hlm-dialog-footer.component';
export * from './lib/hlm-dialog-header.component';
export * from './lib/hlm-dialog-overlay.directive';
export * from './lib/hlm-dialog-title.directive';
export * from './lib/hlm-dialog.component';
export * from './lib/hlm-dialog.service';

export const HlmDialogImports = [
	HlmDialogComponent,
	HlmDialogCloseDirective,
	HlmDialogContentComponent,
	HlmDialogDescriptionDirective,
	HlmDialogFooterComponent,
	HlmDialogHeaderComponent,
	HlmDialogOverlayDirective,
	HlmDialogTitleDirective,
] as const;

@NgModule({
	imports: [...HlmDialogImports],
	exports: [...HlmDialogImports],
})
export class HlmDialogModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/src/lib/hlm-dialog-close.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmDialogClose],[brnDialogClose][hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmDialogCloseDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm(
			'absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/src/lib/hlm-dialog-content.component.ts
```typescript
import { NgComponentOutlet } from '@angular/common';
import { ChangeDetectionStrategy, Component, ViewEncapsulation, computed, inject, input } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideX } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { BrnDialogCloseDirective, BrnDialogRef, injectBrnDialogContext } from '@spartan-ng/brain/dialog';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';
import { HlmDialogCloseDirective } from './hlm-dialog-close.directive';

@Component({
	selector: 'hlm-dialog-content',
	imports: [NgComponentOutlet, BrnDialogCloseDirective, HlmDialogCloseDirective, NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideX })],
	host: {
		'[class]': '_computedClass()',
		'[attr.data-state]': 'state()',
	},
	template: `
		@if (component) {
			<ng-container [ngComponentOutlet]="component" />
		} @else {
			<ng-content />
		}

		<button brnDialogClose hlm>
			<span class="sr-only">Close</span>
			<ng-icon hlm size="sm" name="lucideX" />
		</button>
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class HlmDialogContentComponent {
	private readonly _dialogRef = inject(BrnDialogRef);
	private readonly _dialogContext = injectBrnDialogContext({ optional: true });

	public readonly state = computed(() => this._dialogRef?.state() ?? 'closed');

	public readonly component = this._dialogContext?.$component;
	private readonly _dynamicComponentClass = this._dialogContext?.$dynamicComponentClass;

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'border-border grid w-full max-w-lg relative gap-4 border bg-background p-6 shadow-lg [animation-duration:200] data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-top-[2%]  data-[state=open]:slide-in-from-top-[2%] sm:rounded-lg md:w-full',
			this.userClass(),
			this._dynamicComponentClass,
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/src/lib/hlm-dialog-description.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnDialogDescriptionDirective } from '@spartan-ng/brain/dialog';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmDialogDescription]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnDialogDescriptionDirective],
})
export class HlmDialogDescriptionDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('text-sm text-muted-foreground', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/src/lib/hlm-dialog-footer.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-dialog-footer',
	standalone: true,
	template: `
		<ng-content />
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmDialogFooterComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm('flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/src/lib/hlm-dialog-header.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-dialog-header',
	standalone: true,
	template: `
		<ng-content />
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmDialogHeaderComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm('flex flex-col space-y-1.5 text-center sm:text-left', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/src/lib/hlm-dialog-overlay.directive.ts
```typescript
import { Directive, computed, effect, input, untracked } from '@angular/core';
import { hlm, injectCustomClassSettable } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmDialogOverlayClass =
	'bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0';

@Directive({
	selector: '[hlmDialogOverlay],brn-dialog-overlay[hlm]',
	standalone: true,
})
export class HlmDialogOverlayDirective {
	private readonly _classSettable = injectCustomClassSettable({ optional: true, host: true });

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm(hlmDialogOverlayClass, this.userClass()));

	constructor() {
		effect(() => {
			const newClass = this._computedClass();
			untracked(() => this._classSettable?.setClassToCustomElement(newClass));
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/src/lib/hlm-dialog-title.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnDialogTitleDirective } from '@spartan-ng/brain/dialog';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmDialogTitle]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnDialogTitleDirective],
})
export class HlmDialogTitleDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('text-lg font-semibold leading-none tracking-tight', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/src/lib/hlm-dialog.component.ts
```typescript
import { ChangeDetectionStrategy, Component, forwardRef, ViewEncapsulation } from '@angular/core';
import {
	BrnDialogComponent,
	BrnDialogOverlayComponent,
	provideBrnDialogDefaultOptions,
} from '@spartan-ng/brain/dialog';
import { HlmDialogOverlayDirective } from './hlm-dialog-overlay.directive';

@Component({
	selector: 'hlm-dialog',
	imports: [BrnDialogOverlayComponent, HlmDialogOverlayDirective],
	providers: [
		{
			provide: BrnDialogComponent,
			useExisting: forwardRef(() => HlmDialogComponent),
		},
		provideBrnDialogDefaultOptions({
			// add custom options here
		}),
	],
	template: `
		<brn-dialog-overlay hlm />
		<ng-content />
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	exportAs: 'hlmDialog',
})
export class HlmDialogComponent extends BrnDialogComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/dialog/helm/src/lib/hlm-dialog.service.ts
```typescript
import type { ComponentType } from '@angular/cdk/portal';
import { Injectable, type TemplateRef, inject } from '@angular/core';
import {
	type BrnDialogOptions,
	BrnDialogService,
	DEFAULT_BRN_DIALOG_OPTIONS,
	cssClassesToArray,
} from '@spartan-ng/brain/dialog';
import { HlmDialogContentComponent } from './hlm-dialog-content.component';
import { hlmDialogOverlayClass } from './hlm-dialog-overlay.directive';

export type HlmDialogOptions<DialogContext = unknown> = BrnDialogOptions & {
	contentClass?: string;
	context?: DialogContext;
};

@Injectable({
	providedIn: 'root',
})
export class HlmDialogService {
	private readonly _brnDialogService = inject(BrnDialogService);

	public open(component: ComponentType<unknown> | TemplateRef<unknown>, options?: Partial<HlmDialogOptions>) {
		const mergedOptions = {
			...DEFAULT_BRN_DIALOG_OPTIONS,

			...(options ?? {}),
			backdropClass: cssClassesToArray(`${hlmDialogOverlayClass} ${options?.backdropClass ?? ''}`),
			context: { ...(options?.context ?? {}), $component: component, $dynamicComponentClass: options?.contentClass },
		};

		return this._brnDialogService.open(HlmDialogContentComponent, undefined, mergedOptions.context, mergedOptions);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/form-field/form-field.stories.ts
```typescript
import { Component, type OnInit, inject } from '@angular/core';
import { FormBuilder, FormControl, FormsModule, ReactiveFormsModule, Validators } from '@angular/forms';
import { ErrorStateMatcher, ShowOnDirtyErrorStateMatcher } from '@spartan-ng/brain/forms';
import { BrnSelectImports } from '@spartan-ng/brain/select';
import { type Meta, type StoryObj, moduleMetadata } from '@storybook/angular';
import { HlmButtonDirective, HlmButtonModule } from '../button/helm/src';
import { HlmInputDirective } from '../input/helm/src';
import { HlmSelectImports, HlmSelectModule } from '../select/helm/src';
import { HlmFormFieldComponent, HlmFormFieldModule } from './helm/src';

const meta: Meta<HlmFormFieldComponent> = {
	title: 'Form Field',
	component: HlmFormFieldComponent,
	tags: ['autodocs'],
	decorators: [
		moduleMetadata({
			imports: [HlmFormFieldModule, HlmInputDirective, FormsModule, ReactiveFormsModule, HlmButtonDirective],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmFormFieldComponent>;

export const Default: Story = {
	render: ({ ...args }) => ({
		props: { name: new FormControl('', Validators.required), ...args },
		template: `
			<hlm-form-field>
			 	<input aria-label='Your Name' [formControl]="name" class='w-80' hlmInput type='text' placeholder='Your Name'/>
				<hlm-error>Your name is required</hlm-error>
			</hlm-form-field>
		`,
	}),
};

@Component({
	standalone: true,
	selector: 'form-field-error-story',
	imports: [ReactiveFormsModule, HlmFormFieldModule, HlmInputDirective],
	template: `
		<hlm-form-field>
			<input aria-label="Your Name" class="w-80" [formControl]="name" hlmInput type="text" placeholder="Your Name" />
			<hlm-error>Your name is required</hlm-error>
		</hlm-form-field>
	`,
})
class FormFieldErrorStory implements OnInit {
	name = new FormControl('', Validators.required);

	ngOnInit(): void {
		this.name.markAsTouched();
	}
}

export const Error: Story = {
	decorators: [
		moduleMetadata({
			imports: [FormFieldErrorStory],
		}),
	],
	render: () => ({
		template: '<form-field-error-story />',
	}),
};

export const Hint: Story = {
	render: ({ ...args }) => ({
		props: {
			...args,
		},
		template: `
		<hlm-form-field>
			<input aria-label='Your Name' class='w-80' hlmInput type='text' placeholder='shadcn'/>
			<hlm-hint>This is your public display name.</hlm-hint>
		</hlm-form-field>
		`,
	}),
};

@Component({
	standalone: true,
	selector: 'form-field-form-story',
	imports: [
		ReactiveFormsModule,
		HlmFormFieldModule,
		HlmSelectModule,
		HlmInputDirective,
		HlmSelectImports,
		BrnSelectImports,
		HlmButtonModule,
	],
	template: `
		<form [formGroup]="form" class="space-y-6">
			<hlm-form-field>
				<input
					aria-label="Your Name"
					formControlName="name"
					class="w-80"
					hlmInput
					type="text"
					placeholder="Your Name"
				/>
				<hlm-error>Your name is required</hlm-error>
			</hlm-form-field>
			<hlm-form-field>
				<brn-select class="inline-block" placeholder="Select some fruit" formControlName="fruit">
					<hlm-select-trigger class="w-80">
						<hlm-select-value />
					</hlm-select-trigger>
					<hlm-select-content>
						<hlm-select-label>Fruits</hlm-select-label>
						@for (option of options; track option.value) {
							<hlm-option [value]="option.value">{{ option.label }}</hlm-option>
						}
					</hlm-select-content>
				</brn-select>
				<hlm-error>The fruit is required</hlm-error>
			</hlm-form-field>

			<button type="submit" hlmBtn>Submit</button>
		</form>
	`,
})
class FormFieldFormStory {
	private _formBuilder = inject(FormBuilder);

	form = this._formBuilder.group({
		name: ['', Validators.required],
		fruit: ['', Validators.required],
	});

	options = [
		{ value: 'apple', label: 'Apple' },
		{ value: 'banana', label: 'Banana' },
		{ value: 'blueberry', label: 'Blueberry' },
		{ value: 'grapes', label: 'Grapes' },
		{ value: 'pineapple', label: 'Pineapple' },
	];
}

export const FormWithDefaultErrorStateMatcher: Story = {
	decorators: [
		moduleMetadata({
			imports: [FormFieldFormStory],
		}),
	],
	render: () => ({
		template: '<form-field-form-story />',
	}),
};

export const FormWithDirtyErrorStateMatcher: Story = {
	decorators: [
		moduleMetadata({
			imports: [FormFieldFormStory],
			providers: [{ provide: ErrorStateMatcher, useClass: ShowOnDirtyErrorStateMatcher }],
		}),
	],
	render: () => ({
		template: '<form-field-form-story />',
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/form-field/helm/README.md
```
# ui-form-field-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-form-field-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/form-field/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/form-field/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-form-field-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	coverageDirectory: '../../../../coverage/libs/form-field/helm',
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/form-field/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/form-field/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/form-field/helm/package.json
```json
{
	"name": "@spartan-ng/ui-formfield-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/form-field/helm/project.json
```json
{
	"name": "ui-form-field-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/form-field/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/form-field/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/form-field/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/form-field/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/form-field/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-form-field-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/form-field/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/form-field/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/form-field/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/form-field/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/form-field/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmErrorDirective } from './lib/hlm-error.directive';
import { HlmFormFieldComponent } from './lib/hlm-form-field.component';
import { HlmHintDirective } from './lib/hlm-hint.directive';

export * from './lib/hlm-error.directive';
export * from './lib/hlm-form-field.component';
export * from './lib/hlm-hint.directive';

@NgModule({
	imports: [HlmFormFieldComponent, HlmErrorDirective, HlmHintDirective],
	exports: [HlmFormFieldComponent, HlmErrorDirective, HlmHintDirective],
})
export class HlmFormFieldModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/form-field/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/form-field/helm/src/lib/form-field.spec.ts
```typescript
/* eslint-disable @angular-eslint/component-class-suffix */
/* eslint-disable @angular-eslint/component-selector */
import { Component } from '@angular/core';
import { FormControl, ReactiveFormsModule, Validators } from '@angular/forms';
import { render, screen } from '@testing-library/angular';
import userEvent from '@testing-library/user-event';

import { HlmInputDirective } from '@spartan-ng/ui-input-helm';

import { ErrorStateMatcher, ShowOnDirtyErrorStateMatcher } from '@spartan-ng/brain/forms';
import { HlmErrorDirective } from './hlm-error.directive';
import { HlmFormFieldComponent } from './hlm-form-field.component';
import { HlmHintDirective } from './hlm-hint.directive';

const DIRECTIVES = [HlmFormFieldComponent, HlmErrorDirective, HlmHintDirective, HlmInputDirective];

@Component({
	standalone: true,
	selector: 'single-form-field-example',
	imports: [ReactiveFormsModule, ...DIRECTIVES],
	template: `
		<hlm-form-field>
			<input
				data-testid="hlm-input"
				aria-label="Your Name"
				[formControl]="name"
				class="w-80"
				hlmInput
				type="text"
				placeholder="Your Name"
			/>
			<hlm-error data-testid="hlm-error">Your name is required</hlm-error>
			<hlm-hint data-testid="hlm-hint">This is your public display name.</hlm-hint>
		</hlm-form-field>
	`,
})
class SingleFormFieldMock {
	public name = new FormControl('', Validators.required);
}

@Component({
	standalone: true,
	selector: 'single-form-field-dirty-example',
	imports: [ReactiveFormsModule, ...DIRECTIVES],
	template: `
		<hlm-form-field>
			<input
				data-testid="hlm-input"
				aria-label="Your Name"
				[formControl]="name"
				class="w-80"
				hlmInput
				type="text"
				placeholder="Your Name"
			/>
			<hlm-error data-testid="hlm-error">Your name is required</hlm-error>
			<hlm-hint data-testid="hlm-hint">This is your public display name.</hlm-hint>
		</hlm-form-field>
	`,
	providers: [{ provide: ErrorStateMatcher, useClass: ShowOnDirtyErrorStateMatcher }],
})
class SingleFormFieldDirtyMock {
	public name = new FormControl('', Validators.required);
}

describe('Hlm Form Field Component', () => {
	const TEXT_HINT = 'This is your public display name.';
	const TEXT_ERROR = 'Your name is required';

	const setupFormField = async () => {
		const { fixture } = await render(SingleFormFieldMock);
		return {
			user: userEvent.setup(),
			fixture,
			hint: screen.getByTestId('hlm-hint'),
			error: () => screen.queryByTestId('hlm-error'),
			trigger: screen.getByTestId('hlm-input'),
		};
	};

	const setupFormFieldWithErrorStateDirty = async () => {
		const { fixture } = await render(SingleFormFieldDirtyMock);
		return {
			user: userEvent.setup(),
			fixture,
			hint: screen.getByTestId('hlm-hint'),
			error: () => screen.queryByTestId('hlm-error'),
			trigger: screen.getByTestId('hlm-input'),
		};
	};

	describe('SingleFormField', () => {
		it('should show the hint if the errorState is false', async () => {
			const { hint } = await setupFormField();

			expect(hint.textContent).toBe(TEXT_HINT);
		});

		it('should show the error if the errorState is true', async () => {
			const { user, error, trigger } = await setupFormField();

			expect(error()).toBeNull();

			await user.click(trigger);

			await user.click(document.body);

			expect(screen.queryByTestId('hlm-hint')).toBeNull();
			expect(error()?.textContent?.trim()).toBe(TEXT_ERROR);
		});
	});

	describe('SingleFormFieldDirty', () => {
		it('should not display the error if the input does not have the dirty state due to the ErrorStateMatcher', async () => {
			const { error, user, trigger } = await setupFormFieldWithErrorStateDirty();

			await user.click(trigger);

			await user.click(document.body);

			expect(error()).toBeNull();
		});

		it('should display the error if the input has the dirty state due to the ErrorStateMatcher', async () => {
			const { error, user, trigger } = await setupFormFieldWithErrorStateDirty();

			await user.click(trigger);
			await user.type(trigger, 'a');
			await user.clear(trigger);

			await user.click(document.body);

			expect(error()?.textContent?.trim()).toBe(TEXT_ERROR);
		});
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/form-field/helm/src/lib/hlm-error.directive.ts
```typescript
import { Directive } from '@angular/core';

@Directive({
	standalone: true,
	// eslint-disable-next-line @angular-eslint/directive-selector
	selector: 'hlm-error',
	host: {
		class: 'block text-destructive text-sm font-medium',
	},
})
export class HlmErrorDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/form-field/helm/src/lib/hlm-form-field.component.ts
```typescript
import { Component, computed, contentChild, contentChildren, effect } from '@angular/core';
import { BrnFormFieldControl } from '@spartan-ng/brain/form-field';
import { HlmErrorDirective } from './hlm-error.directive';

@Component({
	selector: 'hlm-form-field',
	template: `
		<ng-content />

		@switch (hasDisplayedMessage()) {
			@case ('error') {
				<ng-content select="hlm-error" />
			}
			@default {
				<ng-content select="hlm-hint" />
			}
		}
	`,
	standalone: true,
	host: {
		class: 'space-y-2 block',
	},
})
export class HlmFormFieldComponent {
	public readonly control = contentChild(BrnFormFieldControl);

	public readonly errorChildren = contentChildren(HlmErrorDirective);

	protected readonly hasDisplayedMessage = computed<'error' | 'hint'>(() =>
		this.errorChildren() && this.errorChildren().length > 0 && this.control()?.errorState() ? 'error' : 'hint',
	);

	constructor() {
		effect(() => {
			if (!this.control()) {
				throw new Error('hlm-form-field must contain a BrnFormFieldControl.');
			}
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/form-field/helm/src/lib/hlm-hint.directive.ts
```typescript
import { Directive } from '@angular/core';

@Directive({
	// eslint-disable-next-line @angular-eslint/directive-selector
	selector: 'hlm-hint',
	standalone: true,
	host: {
		class: 'block text-sm text-muted-foreground',
	},
})
export class HlmHintDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/popover/popover.stories.ts
```typescript
import { NgIcon } from '@ng-icons/core';
import { BrnPopoverComponent, BrnPopoverImports } from '@spartan-ng/brain/popover';
import { type Meta, type StoryObj, argsToTemplate, moduleMetadata } from '@storybook/angular';
import { HlmButtonDirective } from '../button/helm/src';
import { HlmIconDirective } from '../icon/helm/src';
import { HlmInputDirective } from '../input/helm/src';
import { HlmLabelDirective } from '../label/helm/src';
import { HlmPopoverImports } from './helm/src';

const meta: Meta<BrnPopoverComponent> = {
	title: 'Popover',
	component: BrnPopoverComponent,
	tags: ['autodocs'],
	args: {
		align: 'center',
		sideOffset: 4,
	},
	argTypes: {
		align: { control: 'select', options: ['start', 'center', 'end'] },
		sideOffset: { control: 'number' },
	},
	decorators: [
		moduleMetadata({
			imports: [
				BrnPopoverImports,
				HlmPopoverImports,
				HlmButtonDirective,
				HlmLabelDirective,
				HlmInputDirective,
				NgIcon,
				HlmIconDirective,
			],
		}),
	],
};

export default meta;
type Story = StoryObj<BrnPopoverComponent>;

export const Default: Story = {
	render: ({ ...args }) => ({
		props: args,
		template: `
    <brn-popover ${argsToTemplate(args)}>
    <div class='flex flex-col items-center justify-center py-80'>
        <button id='edit-profile' variant='outline' brnPopoverTrigger hlmBtn>Open Popover</button>
    </div>
    <div hlmPopoverContent class='w-80 grid gap-4' *brnPopoverContent='let ctx'>
          <div class='space-y-2'>
            <h4 class='font-medium leading-none'>Dimensions</h4>
            <p class='text-sm text-muted-foreground'>
              Set the dimensions for the layer.
            </p>
          </div>
          <div class='grid gap-2'>
            <div class='items-center grid grid-cols-3 gap-4'>
              <label hlmLabel for='width'>Width</label>
              <input hlmInput
                id='width'
                [defaultValue]="'100%'"
                class='h-8 col-span-2'
              />
            </div>
            <div class='items-center grid grid-cols-3 gap-4'>
              <label hlmLabel for='maxWidth'>Max. width</label>
              <input hlmInput
                id='maxWidth'
                [defaultValue]="'300px'"
                class='h-8 col-span-2'
              />
            </div>
            <div class='items-center grid grid-cols-3 gap-4'>
              <label hlmLabel for='height'>Height</label>
              <input hlmInput
                id='height'
                [defaultValue]="'25px'"
                class='h-8 col-span-2'
              />
            </div>
            <div class='items-center grid grid-cols-3 gap-4'>
              <label hlmLabel for='maxHeight'>Max. height</label>
              <input hlmInput
                id='maxHeight'
                [defaultValue]="'none'"
                class='h-8 col-span-2'
              />
            </div>
          </div>
    </div>
    </brn-popover>
    `,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/popover/helm/README.md
```
# ui-popover-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-popover-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/popover/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/popover/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-popover-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/popover/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/popover/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/popover/helm/package.json
```json
{
	"name": "@spartan-ng/ui-popover-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/popover/helm/project.json
```json
{
	"name": "ui-popover-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/popover/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/popover/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/popover/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/popover/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/popover/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-popover-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/popover/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/popover/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/popover/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/popover/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/popover/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { HlmPopoverCloseDirective } from './lib/hlm-popover-close.directive';
import { HlmPopoverContentDirective } from './lib/hlm-popover-content.directive';

export * from './lib/hlm-popover-close.directive';
export * from './lib/hlm-popover-content.directive';

export const HlmPopoverImports = [HlmPopoverContentDirective, HlmPopoverCloseDirective] as const;

@NgModule({
	imports: [...HlmPopoverImports],
	exports: [...HlmPopoverImports],
})
export class HlmPopoverModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/popover/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/popover/helm/src/lib/hlm-popover-close.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmPopoverClose],[brnPopoverClose][hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmPopoverCloseDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/popover/helm/src/lib/hlm-popover-content.directive.ts
```typescript
import { Directive, ElementRef, Renderer2, computed, effect, inject, input, signal } from '@angular/core';
import { hlm, injectExposesStateProvider } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmPopoverContent],[brnPopoverContent][hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmPopoverContentDirective {
	private readonly _stateProvider = injectExposesStateProvider({ host: true });
	public state = this._stateProvider.state ?? signal('closed');
	private readonly _renderer = inject(Renderer2);
	private readonly _element = inject(ElementRef);

	constructor() {
		effect(() => {
			this._renderer.setAttribute(this._element.nativeElement, 'data-state', this.state());
		});
	}

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'relative border-border w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sonner/sonner.stories.ts
```typescript
import { Component } from '@angular/core';
import type { Meta, StoryObj } from '@storybook/angular';
import { moduleMetadata } from '@storybook/angular';
import { toast } from 'ngx-sonner';
import { HlmButtonDirective } from '../button/helm/src';
import { HlmToasterComponent } from './helm/src';

const meta: Meta<HlmToasterComponent> = {
	title: 'Sonner',
	component: HlmToasterComponent,
	tags: ['autodocs'],
	decorators: [
		moduleMetadata({
			imports: [HlmToasterComponent, HlmButtonDirective],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmToasterComponent>;

@Component({
	selector: 'sonner-story',
	standalone: true,
	imports: [HlmToasterComponent, HlmButtonDirective],
	template: `
		<hlm-toaster />
		<button hlmBtn (click)="showToast()">Show Toast</button>
	`,
})
export class SonnerStory {
	showToast() {
		toast('Event has been created', {
			description: 'Sunday, December 03, 2023 at 9:00 AM',
			action: {
				label: 'Undo',
				onClick: () => console.log('Undo'),
			},
		});
	}
}

export const Default: Story = {
	render: () => ({
		template: '<sonner-story />',
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sonner/helm/README.md
```
# ui-sonner-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-sonner-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sonner/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sonner/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-sonner-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	coverageDirectory: '../../../../coverage/libs/ui/sonner/helm',
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sonner/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/sonner/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sonner/helm/package.json
```json
{
	"name": "@spartan-ng/ui-sonner-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {
		"tslib": "^2.3.0"
	},
	"peerDependencies": {
		"@angular/common": "^18.1.0",
		"@angular/core": "^18.1.0",
		"@ng-icons/lucide": "^26.3.0",
		"@spartan-ng/brain": "0.0.1-alpha.381",
		"clsx": "^2.1.1",
		"ngx-sonner": "^3.0.0"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sonner/helm/project.json
```json
{
	"name": "ui-sonner-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/sonner/helm/src",
	"prefix": "lib",
	"tags": ["scope:helm"],
	"projectType": "library",
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/sonner/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/sonner/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/sonner/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/sonner/helm/jest.config.ts"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sonner/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sonner/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sonner/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sonner/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sonner/helm/src/index.ts
```typescript
export * from './lib/hlm-toaster.component';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sonner/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sonner/helm/src/lib/hlm-toaster.component.ts
```typescript
import { ChangeDetectionStrategy, Component, booleanAttribute, computed, input, numberAttribute } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';
import { NgxSonnerToaster, type ToasterProps } from 'ngx-sonner';

@Component({
	selector: 'hlm-toaster',
	imports: [NgxSonnerToaster],
	template: `
		<ngx-sonner-toaster
			[class]="_computedClass()"
			[invert]="invert()"
			[theme]="theme()"
			[position]="position()"
			[hotKey]="hotKey()"
			[richColors]="richColors()"
			[expand]="expand()"
			[duration]="duration()"
			[visibleToasts]="visibleToasts()"
			[closeButton]="closeButton()"
			[toastOptions]="toastOptions()"
			[offset]="offset()"
			[dir]="dir()"
			[style]="userStyle()"
		/>
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
})
export class HlmToasterComponent {
	public readonly invert = input<ToasterProps['invert'], boolean | string>(false, {
		transform: booleanAttribute,
	});
	public readonly theme = input<ToasterProps['theme']>('light');
	public readonly position = input<ToasterProps['position']>('bottom-right');
	public readonly hotKey = input<ToasterProps['hotkey']>(['altKey', 'KeyT']);
	public readonly richColors = input<ToasterProps['richColors'], boolean | string>(false, {
		transform: booleanAttribute,
	});
	public readonly expand = input<ToasterProps['expand'], boolean | string>(false, {
		transform: booleanAttribute,
	});
	public readonly duration = input<ToasterProps['duration'], number | string>(4000, {
		transform: numberAttribute,
	});
	public readonly visibleToasts = input<ToasterProps['visibleToasts'], number | string>(3, {
		transform: numberAttribute,
	});
	public readonly closeButton = input<ToasterProps['closeButton'], boolean | string>(false, {
		transform: booleanAttribute,
	});
	public readonly toastOptions = input<ToasterProps['toastOptions']>({
		classes: {
			toast:
				'group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg',
			description: 'group-[.toast]:text-muted-foreground',
			actionButton: 'group-[.toast]:bg-primary group-[.toast]:text-primary-foreground',
			cancelButton: 'group-[.toast]:bg-muted group-[.toast]:text-muted-foreground',
		},
	});
	public readonly offset = input<ToasterProps['offset']>(null);
	public readonly dir = input<ToasterProps['dir']>('auto');
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly userStyle = input<Record<string, string>>({}, { alias: 'style' });

	protected readonly _computedClass = computed(() => hlm('toaster group', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/button/button.stories.ts
```typescript
import { type Meta, type StoryObj, argsToTemplate, moduleMetadata } from '@storybook/angular';
import { HlmButtonDirective } from './helm/src';

const meta: Meta<HlmButtonDirective> = {
	title: 'Button',
	component: HlmButtonDirective,
	tags: ['autodocs'],
	args: {
		variant: 'default',
		size: 'default',
	},
	argTypes: {
		variant: {
			options: ['default', 'destructive', 'outline', 'secondary', 'ghost', 'link'],
			control: {
				type: 'select',
			},
		},
		size: {
			options: ['default', 'sm', 'lg', 'icon'],
			control: {
				type: 'select',
			},
		},
	},
	decorators: [
		moduleMetadata({
			imports: [HlmButtonDirective],
		}),
	],
	render: ({ ...args }) => ({
		props: args,
		template: `<button hlmBtn ${argsToTemplate(args)}>Click me</button>`,
	}),
};

export default meta;
type Story = StoryObj<HlmButtonDirective>;

export const Default: Story = {
	args: {
		variant: 'default',
		size: 'default',
	},
};

export const Destructive: Story = {
	args: {
		variant: 'destructive',
		size: 'default',
	},
};

export const Outline: Story = {
	args: {
		variant: 'outline',
		size: 'default',
	},
};

export const Secondary: Story = {
	args: {
		variant: 'secondary',
		size: 'default',
	},
};

export const Ghost: Story = {
	args: {
		variant: 'ghost',
		size: 'default',
	},
};

export const Link: Story = {
	args: {
		variant: 'link',
		size: 'default',
	},
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/button/helm/README.md
```
# ui-button-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-button-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/button/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/button/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-button-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/button/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/button/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/button/helm/package.json
```json
{
	"name": "@spartan-ng/ui-button-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"class-variance-authority": "^0.7.0",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/button/helm/project.json
```json
{
	"name": "ui-button-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/button/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/button/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/button/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/button/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/button/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-button-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/button/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/button/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/button/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/button/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/button/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmButtonDirective } from './lib/hlm-button.directive';
export * from './lib/hlm-button.token';

export * from './lib/hlm-button.directive';

@NgModule({
	imports: [HlmButtonDirective],
	exports: [HlmButtonDirective],
})
export class HlmButtonModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/button/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/button/helm/src/lib/hlm-button.directive.ts
```typescript
import { Directive, computed, input, signal } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';
import { injectBrnButtonConfig } from './hlm-button.token';

export const buttonVariants = cva(
	'inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background',
	{
		variants: {
			variant: {
				default: 'bg-primary text-primary-foreground hover:bg-primary/90',
				destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
				outline: 'border border-input hover:bg-accent hover:text-accent-foreground',
				secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
				ghost: 'hover:bg-accent hover:text-accent-foreground',
				link: 'underline-offset-4 hover:underline text-primary',
			},
			size: {
				default: 'h-10 py-2 px-4',
				sm: 'h-9 px-3 rounded-md',
				lg: 'h-11 px-8 rounded-md',
				icon: 'h-10 w-10',
			},
		},
		defaultVariants: {
			variant: 'default',
			size: 'default',
		},
	},
);
export type ButtonVariants = VariantProps<typeof buttonVariants>;

@Directive({
	selector: '[hlmBtn]',
	standalone: true,
	exportAs: 'hlmBtn',
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmButtonDirective {
	private readonly _config = injectBrnButtonConfig();

	private readonly _additionalClasses = signal<ClassValue>('');

	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm(buttonVariants({ variant: this.variant(), size: this.size() }), this.userClass(), this._additionalClasses()),
	);

	public readonly variant = input<ButtonVariants['variant']>(this._config.variant);

	public readonly size = input<ButtonVariants['size']>(this._config.size);

	setClass(classes: string): void {
		this._additionalClasses.set(classes);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/button/helm/src/lib/hlm-button.token.ts
```typescript
import { InjectionToken, ValueProvider, inject } from '@angular/core';
import type { ButtonVariants } from './hlm-button.directive';

export interface BrnButtonConfig {
	variant: ButtonVariants['variant'];
	size: ButtonVariants['size'];
}

const defaultConfig: BrnButtonConfig = {
	variant: 'default',
	size: 'default',
};

const BrnButtonConfigToken = new InjectionToken<BrnButtonConfig>('BrnButtonConfig');

export function provideBrnButtonConfig(config: Partial<BrnButtonConfig>): ValueProvider {
	return { provide: BrnButtonConfigToken, useValue: { ...defaultConfig, ...config } };
}

export function injectBrnButtonConfig(): BrnButtonConfig {
	return inject(BrnButtonConfigToken, { optional: true }) ?? defaultConfig;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/date-picker/date-picker.stories.ts
```typescript
import { type Meta, type StoryObj, moduleMetadata } from '@storybook/angular';
import { HlmDatePickerComponent } from './helm/src/lib/hlm-date-picker.component';

const meta: Meta<HlmDatePickerComponent<Date>> = {
	title: 'Date Picker',
	component: HlmDatePickerComponent,
	tags: ['autodocs'],
	args: {},
	argTypes: {},
	decorators: [
		moduleMetadata({
			imports: [HlmDatePickerComponent],
		}),
	],
	render: ({ ...args }) => ({
		props: args,
		template: `
		<div class="preview flex min-h-[350px] w-full justify-center p-10 items-center">
			<hlm-date-picker [min]="min" [max]="max">
                <span>Pick a date</span>
            </hlm-date-picker>
		</div>
		`,
	}),
};

export default meta;

type Story = StoryObj<HlmDatePickerComponent<Date>>;

export const Default: Story = {
	args: { min: new Date(2020, 4, 1), max: new Date(2030, 6, 1) },
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/date-picker/helm/README.md
```
# ui-calendar-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-calendar-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/date-picker/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/date-picker/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-calendar-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	coverageDirectory: '../../../../coverage/libs/ui/calendar/helm',
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/date-picker/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/date-picker/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/date-picker/helm/package.json
```json
{
	"name": "@spartan-ng/ui-date-picker-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"peerDependencies": {
		"@angular/cdk": ">=19.0.0",
		"@angular/core": ">=19.0.0",
		"@angular/forms": ">=19.0.0",
		"@ng-icons/core": ">=29.0.0",
		"@ng-icons/lucide": ">=29.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"@spartan-ng/ui-calendar-helm": "0.0.1-alpha.381",
		"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
		"@spartan-ng/ui-popover-helm": "0.0.1-alpha.381",
		"clsx": "^2.1.1"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/date-picker/helm/project.json
```json
{
	"name": "ui-date-picker-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/date-picker/helm/src",
	"prefix": "brn",
	"projectType": "library",
	"tags": ["scope:help"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/date-picker/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/date-picker/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/date-picker/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/date-picker/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint"
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-date-picker-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/date-picker/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/date-picker/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/date-picker/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/date-picker/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/date-picker/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmDatePickerMultiComponent } from './lib/hlm-date-picker-multi.component';
import { HlmDatePickerComponent } from './lib/hlm-date-picker.component';

export * from './lib/hlm-date-picker.token';

export * from './lib/hlm-date-picker-multi.component';
export * from './lib/hlm-date-picker.component';

export const HlmDatePickerImports = [HlmDatePickerComponent, HlmDatePickerMultiComponent] as const;

@NgModule({
	imports: [...HlmDatePickerImports],
	exports: [...HlmDatePickerImports],
})
export class HlmDatePickerModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/date-picker/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/date-picker/helm/src/lib/hlm-date-picker-multi.component.ts
```typescript
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import {
	booleanAttribute,
	Component,
	computed,
	forwardRef,
	input,
	model,
	numberAttribute,
	output,
	signal,
} from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideCalendar } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { BrnDialogState } from '@spartan-ng/brain/dialog';
import { type ChangeFn, type TouchFn } from '@spartan-ng/brain/forms';
import { BrnPopoverComponent, BrnPopoverContentDirective, BrnPopoverTriggerDirective } from '@spartan-ng/brain/popover';
import { HlmCalendarMultiComponent } from '@spartan-ng/ui-calendar-helm';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import { HlmPopoverContentDirective } from '@spartan-ng/ui-popover-helm';
import type { ClassValue } from 'clsx';
import { injectHlmDatePickerMultiConfig } from './hlm-date-picker-multi.token';

export const HLM_DATE_PICKER_MUTLI_VALUE_ACCESSOR = {
	provide: NG_VALUE_ACCESSOR,
	useExisting: forwardRef(() => HlmDatePickerMultiComponent),
	multi: true,
};

@Component({
	selector: 'hlm-date-picker-multi',
	imports: [
		NgIcon,
		HlmIconDirective,
		BrnPopoverComponent,
		BrnPopoverTriggerDirective,
		BrnPopoverContentDirective,
		HlmPopoverContentDirective,
		HlmCalendarMultiComponent,
	],
	providers: [HLM_DATE_PICKER_MUTLI_VALUE_ACCESSOR, provideIcons({ lucideCalendar })],
	template: `
		<brn-popover sideOffset="5" [state]="popoverState()" (stateChanged)="popoverState.set($event)">
			<button type="button" [class]="_computedClass()" [disabled]="state().disabled()" brnPopoverTrigger>
				<ng-icon hlm size="sm" name="lucideCalendar" />

				<span class="truncate">
					@if (formattedDate(); as formattedDate) {
						{{ formattedDate }}
					} @else {
						<ng-content />
					}
				</span>
			</button>

			<div hlmPopoverContent class="w-auto p-0" *brnPopoverContent="let ctx">
				<hlm-calendar-multi
					calendarClass="border-0 rounded-none"
					[date]="date()"
					[min]="min()"
					[max]="max()"
					[minSelection]="minSelection()"
					[maxSelection]="maxSelection()"
					[disabled]="state().disabled()"
					(dateChange)="_handleChange($event)"
				/>
			</div>
		</brn-popover>
	`,
	host: {
		class: 'block',
	},
})
export class HlmDatePickerMultiComponent<T> {
	private readonly _config = injectHlmDatePickerMultiConfig<T>();

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'inline-flex items-center gap-2 whitespace-nowrap rounded-md text-sm ring-offset-background transition-colors border border-input bg-background hover:bg-accent hover:text-accent-foreground h-10 px-4 py-2 w-[280px] justify-start text-left font-normal',
			'focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2',
			'disabled:pointer-events-none disabled:opacity-50',
			'[&_ng-icon]:pointer-events-none [&_ng-icon]:shrink-0',
			!this.date() ? 'text-muted-foreground' : '',
			this.userClass(),
		),
	);

	/** The minimum date that can be selected.*/
	public readonly min = input<T>();

	/** The maximum date that can be selected. */
	public readonly max = input<T>();

	/** The minimum selectable dates.  */
	public readonly minSelection = input<number, NumberInput>(undefined, {
		transform: numberAttribute,
	});

	/** The maximum selectable dates.  */
	public readonly maxSelection = input<number, NumberInput>(undefined, {
		transform: numberAttribute,
	});

	/** Determine if the date picker is disabled. */
	public readonly disabled = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** The selected value. */
	public readonly date = model<T[]>();

	/** If true, the date picker will close when the max selection of dates is reached.. */
	public readonly autoCloseOnMaxSelection = input<boolean, BooleanInput>(this._config.autoCloseOnMaxSelection, {
		transform: booleanAttribute,
	});

	/** Defines how the date should be displayed in the UI.  */
	public readonly formatDates = input<(date: T[]) => string>(this._config.formatDates);

	/** Defines how the date should be transformed before saving to model/form. */
	public readonly transformDates = input<(date: T[]) => T[]>(this._config.transformDates);

	protected readonly popoverState = signal<BrnDialogState | null>(null);

	protected readonly state = computed(() => ({
		disabled: signal(this.disabled()),
	}));

	protected readonly formattedDate = computed(() => {
		const dates = this.date();
		return dates ? this.formatDates()(dates) : undefined;
	});

	public readonly changed = output<T[]>();

	protected _onChange?: ChangeFn<T[]>;
	protected _onTouched?: TouchFn;

	protected _handleChange(value: T[] | undefined) {
		if (value === undefined) return;

		if (this.state().disabled()) return;
		const transformedDate = this.transformDates()(value);

		this.date.set(transformedDate);
		this._onChange?.(transformedDate);
		this.changed.emit(transformedDate);

		if (this.autoCloseOnMaxSelection() && this.date()?.length === this.maxSelection()) {
			this.popoverState.set('closed');
		}
	}

	/** CONROL VALUE ACCESSOR */
	writeValue(value: T[] | null): void {
		// optional FormControl is initialized with null value
		if (value === null) return;

		this.date.set(this.transformDates()(value));
	}

	registerOnChange(fn: ChangeFn<T[]>): void {
		this._onChange = fn;
	}

	registerOnTouched(fn: TouchFn): void {
		this._onTouched = fn;
	}

	setDisabledState(isDisabled: boolean): void {
		this.state().disabled.set(isDisabled);
	}

	open() {
		this.popoverState.set('open');
	}

	close() {
		this.popoverState.set('closed');
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/date-picker/helm/src/lib/hlm-date-picker-multi.token.ts
```typescript
import { inject, InjectionToken, ValueProvider } from '@angular/core';

export interface HlmDatePickerMultiConfig<T> {
	/**
	 * If true, the date picker will close when the max selection of dates is reached.
	 */
	autoCloseOnMaxSelection: boolean;

	/**
	 * Defines how the date should be displayed in the UI.
	 *
	 * @param dates
	 * @returns formatted date
	 */
	formatDates: (dates: T[]) => string;

	/**
	 * Defines how the date should be transformed before saving to model/form.
	 *
	 * @param dates
	 * @returns transformed date
	 */
	transformDates: (dates: T[]) => T[];
}

function getDefaultConfig<T>(): HlmDatePickerMultiConfig<T> {
	return {
		formatDates: (dates) => dates.map((date) => (date instanceof Date ? date.toDateString() : `${date}`)).join(', '),
		transformDates: (dates) => dates,
		autoCloseOnMaxSelection: false,
	};
}

const HlmDatePickerMultiConfigToken = new InjectionToken<HlmDatePickerMultiConfig<unknown>>('HlmDatePickerMultiConfig');

export function provideHlmDatePickerConfig<T>(config: Partial<HlmDatePickerMultiConfig<T>>): ValueProvider {
	return { provide: HlmDatePickerMultiConfigToken, useValue: { ...getDefaultConfig(), ...config } };
}

export function injectHlmDatePickerMultiConfig<T>(): HlmDatePickerMultiConfig<T> {
	const injectedConfig = inject(HlmDatePickerMultiConfigToken, { optional: true });
	return injectedConfig ? (injectedConfig as HlmDatePickerMultiConfig<T>) : getDefaultConfig();
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/date-picker/helm/src/lib/hlm-date-picker.component.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { booleanAttribute, Component, computed, forwardRef, input, model, output, signal } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideCalendar } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { BrnDialogState } from '@spartan-ng/brain/dialog';
import { type ChangeFn, type TouchFn } from '@spartan-ng/brain/forms';
import { BrnPopoverComponent, BrnPopoverContentDirective, BrnPopoverTriggerDirective } from '@spartan-ng/brain/popover';
import { HlmCalendarComponent } from '@spartan-ng/ui-calendar-helm';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import { HlmPopoverContentDirective } from '@spartan-ng/ui-popover-helm';
import type { ClassValue } from 'clsx';
import { injectHlmDatePickerConfig } from './hlm-date-picker.token';

export const HLM_DATE_PICKER_VALUE_ACCESSOR = {
	provide: NG_VALUE_ACCESSOR,
	useExisting: forwardRef(() => HlmDatePickerComponent),
	multi: true,
};

@Component({
	selector: 'hlm-date-picker',
	imports: [
		NgIcon,
		HlmIconDirective,
		BrnPopoverComponent,
		BrnPopoverTriggerDirective,
		BrnPopoverContentDirective,
		HlmPopoverContentDirective,
		HlmCalendarComponent,
	],
	providers: [HLM_DATE_PICKER_VALUE_ACCESSOR, provideIcons({ lucideCalendar })],
	template: `
		<brn-popover sideOffset="5" [state]="popoverState()" (stateChanged)="popoverState.set($event)">
			<button type="button" [class]="_computedClass()" [disabled]="state().disabled()" brnPopoverTrigger>
				<ng-icon hlm size="sm" name="lucideCalendar" />

				<span class="truncate">
					@if (formattedDate(); as formattedDate) {
						{{ formattedDate }}
					} @else {
						<ng-content />
					}
				</span>
			</button>

			<div hlmPopoverContent class="w-auto p-0" *brnPopoverContent="let ctx">
				<hlm-calendar
					calendarClass="border-0 rounded-none"
					[date]="date()"
					[min]="min()"
					[max]="max()"
					[disabled]="state().disabled()"
					(dateChange)="_handleChange($event)"
				/>
			</div>
		</brn-popover>
	`,
	host: {
		class: 'block',
	},
})
export class HlmDatePickerComponent<T> {
	private readonly _config = injectHlmDatePickerConfig<T>();

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'inline-flex items-center gap-2 whitespace-nowrap rounded-md text-sm ring-offset-background transition-colors border border-input bg-background hover:bg-accent hover:text-accent-foreground h-10 px-4 py-2 w-[280px] justify-start text-left font-normal',
			'focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2',
			'disabled:pointer-events-none disabled:opacity-50',
			'[&_ng-icon]:pointer-events-none [&_ng-icon]:shrink-0',
			!this.date() ? 'text-muted-foreground' : '',
			this.userClass(),
		),
	);

	/** The minimum date that can be selected.*/
	public readonly min = input<T>();

	/** The maximum date that can be selected. */
	public readonly max = input<T>();

	/** Determine if the date picker is disabled. */
	public readonly disabled = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** The selected value. */
	public readonly date = model<T>();

	/** If true, the date picker will close when a date is selected. */
	public readonly autoCloseOnSelect = input<boolean, BooleanInput>(this._config.autoCloseOnSelect, {
		transform: booleanAttribute,
	});

	/** Defines how the date should be displayed in the UI.  */
	public readonly formatDate = input<(date: T) => string>(this._config.formatDate);

	/** Defines how the date should be transformed before saving to model/form. */
	public readonly transformDate = input<(date: T) => T>(this._config.transformDate);

	protected readonly popoverState = signal<BrnDialogState | null>(null);

	protected readonly state = computed(() => ({
		disabled: signal(this.disabled()),
	}));

	protected readonly formattedDate = computed(() => {
		const date = this.date();
		return date ? this.formatDate()(date) : undefined;
	});

	public readonly changed = output<T>();

	protected _onChange?: ChangeFn<T>;
	protected _onTouched?: TouchFn;

	protected _handleChange(value: T) {
		if (this.state().disabled()) return;
		const transformedDate = this.transformDate()(value);

		this.date.set(transformedDate);
		this._onChange?.(transformedDate);
		this.changed.emit(transformedDate);

		if (this.autoCloseOnSelect()) {
			this.popoverState.set('closed');
		}
	}

	/** CONROL VALUE ACCESSOR */
	writeValue(value: T | null): void {
		// optional FormControl is initialized with null value
		if (value === null) return;

		this.date.set(this.transformDate()(value));
	}

	registerOnChange(fn: ChangeFn<T>): void {
		this._onChange = fn;
	}

	registerOnTouched(fn: TouchFn): void {
		this._onTouched = fn;
	}

	setDisabledState(isDisabled: boolean): void {
		this.state().disabled.set(isDisabled);
	}

	open() {
		this.popoverState.set('open');
	}

	close() {
		this.popoverState.set('closed');
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/date-picker/helm/src/lib/hlm-date-picker.token.ts
```typescript
import { inject, InjectionToken, ValueProvider } from '@angular/core';

export interface HlmDatePickerConfig<T> {
	/**
	 * If true, the date picker will close when a date is selected.
	 */
	autoCloseOnSelect: boolean;

	/**
	 * Defines how the date should be displayed in the UI.
	 *
	 * @param date
	 * @returns formatted date
	 */
	formatDate: (date: T) => string;

	/**
	 * Defines how the date should be transformed before saving to model/form.
	 *
	 * @param date
	 * @returns transformed date
	 */
	transformDate: (date: T) => T;
}

function getDefaultConfig<T>(): HlmDatePickerConfig<T> {
	return {
		formatDate: (date) => (date instanceof Date ? date.toDateString() : `${date}`),
		transformDate: (date) => date,
		autoCloseOnSelect: false,
	};
}

const HlmDatePickerConfigToken = new InjectionToken<HlmDatePickerConfig<unknown>>('HlmDatePickerConfig');

export function provideHlmDatePickerConfig<T>(config: Partial<HlmDatePickerConfig<T>>): ValueProvider {
	return { provide: HlmDatePickerConfigToken, useValue: { ...getDefaultConfig(), ...config } };
}

export function injectHlmDatePickerConfig<T>(): HlmDatePickerConfig<T> {
	const injectedConfig = inject(HlmDatePickerConfigToken, { optional: true });
	return injectedConfig ? (injectedConfig as HlmDatePickerConfig<T>) : getDefaultConfig();
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/scroll-area/scroll-area.stories.ts
```typescript
import { Component } from '@angular/core';
import type { Meta, StoryObj } from '@storybook/angular';
import { argsToTemplate, moduleMetadata } from '@storybook/angular';
import { NgScrollbar, NgScrollbarModule } from 'ngx-scrollbar';
import { HlmSeparatorDirective } from '../separator/helm/src';
import { HlmScrollAreaDirective } from './helm/src';

@Component({
	selector: 'scroll-area-stories',
	standalone: true,
	imports: [HlmSeparatorDirective, HlmScrollAreaDirective, NgScrollbarModule],
	template: `
		<ng-scrollbar hlm class="border-border h-72 w-48 rounded-md border">
			<div class="p-4">
				<h4 class="mb-4 text-sm font-medium leading-none">Tags</h4>
				@for (tag of tags; track tag) {
					<div class="text-sm">
						{{ tag }}
						<div hlmSeparator class="my-2"></div>
					</div>
				}
			</div>
		</ng-scrollbar>
	`,
})
class ScrollAreaStoriesComponent {
	tags = Array.from({ length: 50 }).map((_, i, a) => `v1.2.0-beta.${a.length - i}`);
}

const meta: Meta<NgScrollbar> = {
	title: 'Scroll Area',
	component: NgScrollbar,
	tags: ['autodocs'],
	args: {
		track: 'all',
		visibility: 'native',
	} as any, // this is required as storybook isn't inferring types from signals
	argTypes: {
		track: {
			options: ['vertical', 'horizontal', 'all'],
			control: {
				type: 'select',
			},
			table: {
				defaultValue: { summary: 'all' },
			},
		},
		visibility: {
			options: ['hover', 'always', 'native'],
			control: {
				type: 'select',
			},
			table: {
				defaultValue: { summary: 'native' },
			},
		},
	} as any,
	decorators: [
		moduleMetadata({
			imports: [HlmScrollAreaDirective, NgScrollbarModule, ScrollAreaStoriesComponent],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmScrollAreaDirective>;

export const Default: Story = {
	render: () => ({
		template: `
       <scroll-area-stories/>
    `,
	}),
};

export const Vertical: Story = {
	render: ({ ...args }) => ({
		props: args,
		template: `
        <ng-scrollbar hlm ${argsToTemplate(args)} class="border w-72 rounded-md border-border">
        <div class='p-6 whitespace-nowrap'>
            Lorem ipsum dolor sit amet, consectetur adipisicing elit. Accusantium architecto,<br>
        asperiores beatae consequuntur dolor ducimus et exercitationem facilis fugiat magni<br>
        nisi officiis quibusdam rem repellat reprehenderit totam veritatis voluptatibus! Nobis.
        </div>
        </ng-scrollbar>`,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/scroll-area/helm/README.md
```
# ui-scroll-area-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-scroll-area-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/scroll-area/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
	{
		files: ['**/*.json'],
		rules: {
			'@nx/dependency-checks': [
				'error',
				{
					ignoredDependencies: ['ngx-scrollbar', 'jest-preset-angular'],
				},
			],
		},
		languageOptions: {
			parser: require('jsonc-eslint-parser'),
		},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/scroll-area/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-scroll-area-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	coverageDirectory: '../../../../coverage/libs/ui/scroll-area/helm',
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/scroll-area/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/scroll-area/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/scroll-area/helm/package.json
```json
{
	"name": "@spartan-ng/ui-scrollarea-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"clsx": "^2.1.1",
		"ngx-scrollbar": ">=16.0.0"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/scroll-area/helm/project.json
```json
{
	"name": "ui-scroll-area-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/scroll-area/helm/src",
	"prefix": "hlm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/scroll-area/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/scroll-area/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/scroll-area/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/scroll-area/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-scroll-area-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/scroll-area/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/scroll-area/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/scroll-area/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/scroll-area/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/scroll-area/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmScrollAreaDirective } from './lib/hlm-scroll-area.directive';

export * from './lib/hlm-scroll-area.directive';

@NgModule({
	imports: [HlmScrollAreaDirective],
	exports: [HlmScrollAreaDirective],
})
export class HlmScrollAreaModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/scroll-area/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/scroll-area/helm/src/lib/hlm-scroll-area.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: 'ng-scrollbar[hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		'[style.--scrollbar-border-radius.px]': '100',
		'[style.--scrollbar-offset]': '3',
		'[style.--scrollbar-thumb-color]': '"hsl(var(--border))"',
		'[style.--scrollbar-thumb-hover-color]': '"hsl(var(--border))"',
		'[style.--scrollbar-thickness]': '7',
	},
})
export class HlmScrollAreaDirective {
	protected readonly _computedClass = computed(() => hlm('block', this.userClass()));
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/table/table.stories.ts
```typescript
import { TitleCasePipe } from '@angular/common';
import { Component, type TrackByFunction, computed, effect, signal, untracked } from '@angular/core';
import { toObservable, toSignal } from '@angular/core/rxjs-interop';
import { FormsModule } from '@angular/forms';
import { faker } from '@faker-js/faker';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronDown } from '@ng-icons/lucide';
import { BrnMenuModule } from '@spartan-ng/brain/menu';
import { BrnTableModule, type PaginatorState, useBrnColumnManager } from '@spartan-ng/brain/table';
import { BrnToggleGroupModule } from '@spartan-ng/brain/toggle-group';
import { type Meta, type StoryObj, moduleMetadata } from '@storybook/angular';
import { debounceTime } from 'rxjs';
import { HlmButtonDirective, HlmButtonModule } from '../button/helm/src';
import { HlmIconDirective } from '../icon/helm/src';
import { HlmInputDirective } from '../input/helm/src';
import { HlmMenuModule } from '../menu/helm/src';
import { HlmToggleGroupModule } from '../toggle-group/helm/src';
import { HlmTableComponent, HlmTableModule } from './helm/src';

const createUsers = (numUsers = 5) => {
	return Array.from({ length: numUsers }, () => ({
		name: faker.person.fullName(),
		age: faker.number.int({ min: 10, max: 100 }),
		height: faker.number.int({ min: 140, max: 210 }),
	}));
};

@Component({
	selector: 'table-story',
	standalone: true,
	imports: [
		FormsModule,
		BrnTableModule,
		HlmTableModule,
		BrnMenuModule,
		HlmMenuModule,
		HlmInputDirective,
		HlmButtonDirective,
		NgIcon,
		HlmIconDirective,
		TitleCasePipe,
	],
	providers: [provideIcons({ lucideChevronDown })],
	template: `
		<div class="flex justify-between">
			<input
				hlmInput
				placeholder="Filter by name"
				[ngModel]="_nameFilter()"
				(ngModelChange)="_rawFilterInput.set($event)"
			/>

			<button hlmBtn variant="outline" align="end" [brnMenuTriggerFor]="menu">
				Columns
				<ng-icon hlm name="lucideChevronDown" class="ml-2" size="sm" />
			</button>
			<ng-template #menu>
				<hlm-menu class="w-40">
					@for (column of _brnColumnManager.allColumns; track column) {
						<button
							hlmMenuItemCheckbox
							[disabled]="_brnColumnManager.isColumnDisabled(column.name)"
							[checked]="_brnColumnManager.isColumnVisible(column.name)"
							(triggered)="_brnColumnManager.toggleVisibility(column.name)"
						>
							<hlm-menu-item-check />
							<span>{{ column.label }}</span>
						</button>
					}
				</hlm-menu>
			</ng-template>
		</div>

		<brn-table
			hlm
			stickyHeader
			class="border-border mt-4 block h-[337px] overflow-scroll rounded-md border"
			[dataSource]="_data()"
			[displayedColumns]="_brnColumnManager.displayedColumns()"
			[trackBy]="_trackBy"
		>
			<brn-column-def name="name" class="w-40">
				<hlm-th truncate *brnHeaderDef>Name</hlm-th>
				<hlm-td truncate *brnCellDef="let element">
					{{ element.name }}
				</hlm-td>
			</brn-column-def>
			<brn-column-def name="age" class="w-40 justify-end">
				<hlm-th *brnHeaderDef>Age</hlm-th>
				<hlm-td class="tabular-nums" *brnCellDef="let element">
					{{ element.age }}
				</hlm-td>
			</brn-column-def>
			<brn-column-def name="height" class="w-40 justify-end tabular-nums">
				<hlm-th *brnHeaderDef>Height</hlm-th>
				<hlm-td *brnCellDef="let element">
					{{ element.height }}
				</hlm-td>
			</brn-column-def>
		</brn-table>
		<div
			class="mt-2 flex items-center justify-between"
			*brnPaginator="let ctx; totalElements: _totalElements(); pageSize: _pageSize(); onStateChange: _onStateChange"
		>
			<span class="text-sm tabular-nums">
				Showing entries {{ ctx.state().startIndex + 1 }} - {{ ctx.state().endIndex + 1 }} of {{ _totalElements() }}
			</span>
			<div class="flex">
				<select
					[ngModel]="_pageSize()"
					(ngModelChange)="_pageSize.set($event)"
					hlmInput
					size="sm"
					class="mr-1 inline-flex pr-8"
				>
					@for (size of _availablePageSizes; track size) {
						<option [value]="size">{{ size === 10000 ? 'All' : size }}</option>
					}
				</select>

				<div class="flex space-x-1">
					<button size="sm" variant="outline" hlmBtn [disabled]="!ctx.decrementable()" (click)="ctx.decrement()">
						Previous
					</button>
					<button size="sm" variant="outline" hlmBtn [disabled]="!ctx.incrementable()" (click)="ctx.increment()">
						Next
					</button>
				</div>
			</div>
		</div>
		<button size="sm" variant="outline" hlmBtn (click)="_loadNewUsers()">Mix it up</button>
	`,
})
class TableStory {
	private readonly _startEndIndex = signal({ start: 0, end: 0 });
	protected readonly _availablePageSizes = [10, 20, 50, 100, 10000];
	protected readonly _pageSize = signal(this._availablePageSizes[0]);

	protected readonly _brnColumnManager = useBrnColumnManager({
		name: { visible: true, label: 'Name' },
		age: { visible: false, label: 'Alter' },
		height: { visible: false, label: 'Gre' },
	});

	protected readonly _rawFilterInput = signal('');
	protected readonly _nameFilter = signal('');
	private readonly _debouncedFilter = toSignal(toObservable(this._rawFilterInput).pipe(debounceTime(300)));

	private readonly _users = signal(createUsers(20));
	private readonly _filteredUsers = computed(() =>
		this._users().filter((user) => {
			const nameFilter = this._nameFilter();
			return !nameFilter || user.name.toLowerCase().includes(nameFilter.toLowerCase());
		}),
	);
	protected readonly _data = computed(() =>
		this._filteredUsers().slice(this._startEndIndex().start, this._startEndIndex().end + 1),
	);
	protected readonly _trackBy: TrackByFunction<{ name: string }> = (_index: number, user: { name: string }) =>
		user.name;
	protected readonly _totalElements = computed(() => this._filteredUsers().length);
	protected readonly _onStateChange = (state: PaginatorState) => {
		this._startEndIndex.set({ start: state.startIndex, end: state.endIndex });
	};

	constructor() {
		// needed to sync the debounced filter to the name filter, but being able to override the
		// filter when loading new users without debounce
		effect(() => {
			const debouncedFilter = this._debouncedFilter();
			untracked(() => {
				this._nameFilter.set(debouncedFilter ?? '');
			});
		});
	}

	protected _loadNewUsers() {
		this._nameFilter.set('');
		this._users.set(createUsers(Math.random() * 200));
	}
}

@Component({
	selector: 'table-toggle-story',
	standalone: true,
	imports: [FormsModule, BrnTableModule, HlmTableModule, HlmButtonModule, BrnToggleGroupModule, HlmToggleGroupModule],
	template: `
		<brn-toggle-group
			aria-label="Show selected or all "
			hlm
			class="mb-2.5 w-full sm:w-fit"
			[ngModel]="_onlyAbove180()"
			(ngModelChange)="_setOnlyAbove180($event)"
		>
			<button class="w-full sm:w-40" variant="outline" [value]="false" hlm brnToggleGroupItem>All</button>
			<button class="w-full tabular-nums sm:w-40" variant="outline" [value]="true" hlm brnToggleGroupItem>
				Above 150
			</button>
		</brn-toggle-group>
		<brn-table
			hlm
			stickyHeader
			class="border-border mt-4 block h-[337px] overflow-scroll rounded-md border"
			[dataSource]="_data()"
			[displayedColumns]="_brnColumnManager.displayedColumns()"
			[trackBy]="_trackBy"
		>
			<brn-column-def name="name">
				<hlm-th truncate class="w-40" *brnHeaderDef>Name</hlm-th>
				<hlm-td truncate class="w-40" *brnCellDef="let element">
					{{ element.name }}
				</hlm-td>
			</brn-column-def>
			<brn-column-def name="age">
				<hlm-th class="w-40 justify-end" *brnHeaderDef>Age</hlm-th>
				<hlm-td class="w-40 justify-end tabular-nums" *brnCellDef="let element">
					{{ element.age }}
				</hlm-td>
			</brn-column-def>
			<brn-column-def name="height">
				<hlm-th class="w-40 justify-end" *brnHeaderDef>Height</hlm-th>
				<hlm-td class="w-40 justify-end tabular-nums" *brnCellDef="let element">
					{{ element.height }}
				</hlm-td>
			</brn-column-def>
		</brn-table>
		<div
			class="mt-2 flex items-center justify-between"
			*brnPaginator="let ctx; totalElements: _totalElements(); pageSize: _pageSize(); onStateChange: _onStateChange"
		>
			<span class="text-sm tabular-nums">
				Showing entries {{ ctx.state().startIndex + 1 }} - {{ ctx.state().endIndex + 1 }} of {{ _totalElements() }}
			</span>
			<div class="flex">
				<select
					[ngModel]="_pageSize()"
					(ngModelChange)="_pageSize.set($event)"
					hlmInput
					size="sm"
					class="mr-1 inline-flex pr-8"
				>
					@for (size of _availablePageSizes; track size) {
						<option [value]="size">{{ size === 10000 ? 'All' : size }}</option>
					}
				</select>

				<div class="flex space-x-1">
					<button size="sm" variant="outline" hlmBtn [disabled]="!ctx.decrementable()" (click)="ctx.decrement()">
						Previous
					</button>
					<button size="sm" variant="outline" hlmBtn [disabled]="!ctx.incrementable()" (click)="ctx.increment()">
						Next
					</button>
				</div>
			</div>
		</div>
		<button size="sm" variant="outline" hlmBtn (click)="_loadNewUsers()">Mix it up</button>
	`,
})
class TableToggleStory {
	private readonly _startEndIndex = signal({ start: 0, end: 0 });
	protected readonly _availablePageSizes = [10, 20, 50, 100, 10000];
	protected readonly _pageSize = signal(this._availablePageSizes[0]);

	protected readonly _onlyAbove180 = signal<boolean>(false);
	protected readonly _brnColumnManager = useBrnColumnManager({
		name: true,
		age: false,
		height: true,
	});

	private readonly _users = signal(createUsers(20));
	private readonly _filteredUsers = computed(() => {
		if (this._onlyAbove180()) return this._users().filter((u) => u.height > 180);
		return this._users();
	});
	protected readonly _data = computed(() =>
		this._filteredUsers().slice(this._startEndIndex().start, this._startEndIndex().end + 1),
	);
	protected readonly _trackBy: TrackByFunction<{ name: string }> = (_index: number, user: { name: string }) =>
		user.name;
	protected readonly _totalElements = computed(() => this._filteredUsers().length);
	protected readonly _onStateChange = (state: PaginatorState) => {
		this._startEndIndex.set({ start: state.startIndex, end: state.endIndex });
	};

	protected _loadNewUsers() {
		this._users.set(createUsers(Math.random() * 200));
	}

	protected _setOnlyAbove180(newVal: boolean) {
		if (newVal) {
			this._brnColumnManager.setInvisible('age');
		} else {
			this._brnColumnManager.setVisible('age');
		}
		this._onlyAbove180.set(newVal);
	}
}

@Component({
	selector: 'table-presentation-only-story',
	standalone: true,
	imports: [HlmTableModule],
	template: `
		<hlm-table>
			<hlm-trow>
				<hlm-th truncate class="w-40">Name</hlm-th>
				<hlm-th class="w-24 justify-end">Age</hlm-th>
				<hlm-th class="w-40 justify-center">Height</hlm-th>
			</hlm-trow>
			@for (row of _data(); track row) {
				<hlm-trow>
					<hlm-td truncate class="w-40">{{ row.name }}</hlm-td>
					<hlm-td class="w-24 justify-end">{{ row.age }}</hlm-td>
					<hlm-td class="w-40 justify-center">{{ row.height }}</hlm-td>
				</hlm-trow>
			}
		</hlm-table>
	`,
})
class TablePresentationOnlyStory {
	protected readonly _data = signal(createUsers(20));
}

const meta: Meta<HlmTableComponent> = {
	title: 'Table',
	component: HlmTableComponent,
	tags: ['autodocs'],
	decorators: [
		moduleMetadata({
			imports: [TableStory, TableToggleStory],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmTableComponent>;

export const Default: Story = {
	render: () => ({
		moduleMetadata: {
			imports: [TableStory],
		},
		template: '<table-story/>',
	}),
};

export const PresentationOnly: Story = {
	render: () => ({
		moduleMetadata: {
			imports: [TablePresentationOnlyStory],
		},
		template: '<table-presentation-only-story/>',
	}),
};

export const Toggle: Story = {
	render: () => ({
		template: '<table-toggle-story/>',
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/table/helm/README.md
```
# ui-table-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-table-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/table/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/table/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-table-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	coverageDirectory: '../../../../coverage/libs/ui/table/helm',
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/table/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/table/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/table/helm/package.json
```json
{
	"name": "@spartan-ng/ui-table-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/common": ">=19.0.0",
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"clsx": "^2.1.1"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/table/helm/project.json
```json
{
	"name": "ui-table-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/table/helm/src",
	"prefix": "spartan-ng",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/table/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/table/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/table/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/table/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/table/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/table/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/table/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/table/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/table/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { HlmCaptionComponent } from './lib/hlm-caption.component';
import { HlmTableComponent } from './lib/hlm-table.component';
import { HlmTableDirective } from './lib/hlm-table.directive';
import { HlmTdComponent } from './lib/hlm-td.component';
import { HlmThComponent } from './lib/hlm-th.component';
import { HlmTrowComponent } from './lib/hlm-trow.component';

export { HlmCaptionComponent } from './lib/hlm-caption.component';
export { HlmTableComponent } from './lib/hlm-table.component';
export { HlmTableDirective } from './lib/hlm-table.directive';
export { HlmTdComponent } from './lib/hlm-td.component';
export { HlmThComponent } from './lib/hlm-th.component';
export { HlmTrowComponent } from './lib/hlm-trow.component';

export const HlmTableImports = [
	HlmTableComponent,
	HlmTableDirective,
	HlmCaptionComponent,
	HlmThComponent,
	HlmTdComponent,
	HlmTrowComponent,
] as const;

@NgModule({
	imports: [...HlmTableImports],
	exports: [...HlmTableImports],
})
export class HlmTableModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/table/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/table/helm/src/lib/hlm-caption.component.ts
```typescript
import {
	ChangeDetectionStrategy,
	Component,
	ViewEncapsulation,
	booleanAttribute,
	computed,
	effect,
	inject,
	input,
	untracked,
} from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';
import { HlmTableComponent } from './hlm-table.component';

let captionIdSequence = 0;

@Component({
	selector: 'hlm-caption',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		'[id]': 'id()',
	},
	template: `
		<ng-content />
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class HlmCaptionComponent {
	private readonly _table = inject(HlmTableComponent, { optional: true });

	protected readonly id = input<string | null | undefined>(`${captionIdSequence++}`);

	public readonly hidden = input(false, { transform: booleanAttribute });
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'text-center block mt-4 text-sm text-muted-foreground',
			this.hidden() ? 'sr-only' : 'order-last',
			this.userClass(),
		),
	);

	constructor() {
		effect(() => {
			const id = this.id();
			untracked(() => {
				if (!this._table) return;
				this._table.labeledBy.set(id);
			});
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/table/helm/src/lib/hlm-table.component.ts
```typescript
import {
	ChangeDetectionStrategy,
	Component,
	ViewEncapsulation,
	computed,
	effect,
	input,
	signal,
	untracked,
} from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-table',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		role: 'table',
		'[attr.aria-labelledby]': 'labeledBy()',
	},
	template: `
		<ng-content />
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class HlmTableComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm('flex flex-col text-sm [&_hlm-trow:last-child]:border-0', this.userClass()),
	);

	// we aria-labelledby to be settable from outside but use the input by default.
	public readonly _labeledByInput = input<string | null | undefined>(undefined, { alias: 'aria-labelledby' });
	public readonly labeledBy = signal<string | null | undefined>(undefined);

	constructor() {
		effect(() => {
			const labeledBy = this._labeledByInput();
			untracked(() => {
				this.labeledBy.set(labeledBy);
			});
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/table/helm/src/lib/hlm-table.directive.ts
```typescript
import { Directive } from '@angular/core';
import { injectTableClassesSettable } from '@spartan-ng/brain/core';

@Directive({ standalone: true, selector: '[hlmTable],brn-table[hlm]' })
export class HlmTableDirective {
	private readonly _tableClassesSettable = injectTableClassesSettable({ host: true, optional: true });

	constructor() {
		this._tableClassesSettable?.setTableClasses({
			table: 'flex flex-col text-sm [&_cdk-row:last-child]:border-0',
			headerRow:
				'flex min-w-[100%] w-fit border-b border-border [&.cdk-table-sticky]:bg-background ' +
				'[&.cdk-table-sticky>*]:z-[101] [&.cdk-table-sticky]:before:z-0 [&.cdk-table-sticky]:before:block [&.cdk-table-sticky]:hover:before:bg-muted/50 [&.cdk-table-sticky]:before:absolute [&.cdk-table-sticky]:before:inset-0',
			bodyRow:
				'flex min-w-[100%] w-fit border-b border-border transition-[background-color] hover:bg-muted/50 [&:has([role=checkbox][aria-checked=true])]:bg-muted',
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/table/helm/src/lib/hlm-td.component.ts
```typescript
import { NgTemplateOutlet } from '@angular/common';
import {
	ChangeDetectionStrategy,
	Component,
	ViewEncapsulation,
	booleanAttribute,
	computed,
	inject,
	input,
} from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnColumnDefComponent } from '@spartan-ng/brain/table';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-td',
	imports: [NgTemplateOutlet],
	host: {
		'[class]': '_computedClass()',
	},
	template: `
		<ng-template #content>
			<ng-content />
		</ng-template>
		@if (truncate()) {
			<span class="flex-1 truncate">
				<ng-container [ngTemplateOutlet]="content" />
			</span>
		} @else {
			<ng-container [ngTemplateOutlet]="content" />
		}
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class HlmTdComponent {
	private readonly _columnDef? = inject(BrnColumnDefComponent, { optional: true });
	public readonly truncate = input(false, { transform: booleanAttribute });

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm('flex flex-none p-4 items-center [&:has([role=checkbox])]:pr-0', this._columnDef?.class(), this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/table/helm/src/lib/hlm-th.component.ts
```typescript
import { NgTemplateOutlet } from '@angular/common';
import {
	ChangeDetectionStrategy,
	Component,
	ViewEncapsulation,
	booleanAttribute,
	computed,
	inject,
	input,
} from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnColumnDefComponent } from '@spartan-ng/brain/table';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-th',
	imports: [NgTemplateOutlet],
	host: {
		'[class]': '_computedClass()',
	},
	template: `
		<ng-template #content>
			<ng-content />
		</ng-template>
		@if (truncate()) {
			<span class="flex-1 truncate">
				<ng-container [ngTemplateOutlet]="content" />
			</span>
		} @else {
			<ng-container [ngTemplateOutlet]="content" />
		}
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class HlmThComponent {
	private readonly _columnDef? = inject(BrnColumnDefComponent, { optional: true });
	public readonly truncate = input(false, { transform: booleanAttribute });

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'flex flex-none h-12 px-4 text-sm items-center font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0',
			this._columnDef?.class(),
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/table/helm/src/lib/hlm-trow.component.ts
```typescript
import { ChangeDetectionStrategy, Component, ViewEncapsulation, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-trow',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		role: 'row',
	},
	template: `
		<ng-content />
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class HlmTrowComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'flex flex border-b border-border transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/collapsible/collapsible.stories.ts
```typescript
import { BrnCollapsibleComponent, BrnCollapsibleImports } from '@spartan-ng/brain/collapsible';
import type { Meta, StoryObj } from '@storybook/angular';
import { argsToTemplate, moduleMetadata } from '@storybook/angular';
import { HlmButtonDirective } from '../button/helm/src';

const meta: Meta<BrnCollapsibleComponent> = {
	title: 'Collapsible',
	component: BrnCollapsibleComponent,
	tags: ['autodocs'],
	args: {
		disabled: false,
	},
	argTypes: {
		disabled: {
			control: {
				type: 'boolean',
			},
		},
	},
	decorators: [
		moduleMetadata({
			imports: [HlmButtonDirective, BrnCollapsibleImports],
		}),
	],
};

export default meta;
type Story = StoryObj<{}>;

export const Default: Story = {
	render: ({ ...args }) => ({
		template: `
    <brn-collapsible class="flex flex-col w-[350px] space-y-2" ${argsToTemplate(args)}>
      <div class="flex items-center justify-between px-4 space-x-4">
        <h4 class="text-sm font-semibold">
          &#64;peduarte starred 3 repositories
        </h4>
        <button brnCollapsibleTrigger hlmBtn variant="ghost" size="sm" class="p-0 w-9">
           <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
             <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 15L12 18.75 15.75 15m-7.5-6L12 5.25 15.75 9" />
             </svg>
            <span class="sr-only">Toggle</span>
          </button>
      </div>
      <div class="px-4 py-3 font-mono text-sm border rounded-md border-border">
        &#64;radix-ui/primitives
      </div>
      <brn-collapsible-content class="space-y-2">
        <div class="px-4 py-3 font-mono text-sm border rounded-md border-border">
          &#64;radix-ui/colors
        </div>
        <div class="px-4 py-3 font-mono text-sm border rounded-md border-border">
          &#64;stitches/react
        </div>
      </brn-collapsible-content>
    </brn-collapsible>
    `,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/context-menu.stories.ts
```typescript
import { NgIcon } from '@ng-icons/core';
import { BrnContextMenuTriggerDirective, BrnMenuTriggerDirective } from '@spartan-ng/brain/menu';
import { type Meta, type StoryObj, argsToTemplate, moduleMetadata } from '@storybook/angular';
import { HlmButtonDirective } from '../button/helm/src';
import { HlmIconDirective } from '../icon/helm/src';
import { HlmMenuComponent, HlmMenuImports } from './helm/src';

const meta: Meta<HlmMenuComponent> = {
	title: 'Context Menu',
	component: HlmMenuComponent,
	tags: ['autodocs'],
	args: {
		variant: 'default',
	},
	argTypes: {
		variant: {
			options: ['default', 'menubar'],
			control: {
				type: 'select',
			},
		},
	},
	decorators: [
		moduleMetadata({
			imports: [
				BrnContextMenuTriggerDirective,
				BrnMenuTriggerDirective,
				HlmMenuImports,
				HlmButtonDirective,
				NgIcon,
				HlmIconDirective,
			],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmMenuComponent>;

export const Default: Story = {
	render: ({ ...args }) => ({
		props: args,
		template: `
        <div [brnCtxMenuTriggerFor]='menu'
         class='border-border flex h-[150px] w-[300px] items-center justify-center rounded-md border border-dashed text-sm'>
      Right click here
    </div>

    <ng-template #menu>
      <hlm-menu ${argsToTemplate(args)} class='w-64'>
        <hlm-menu-group>
          <button inset hlmMenuItem>
            Back
            <hlm-menu-shortcut>[</hlm-menu-shortcut>
          </button>

          <button disabled inset hlmMenuItem>
            Forward
            <hlm-menu-shortcut>]</hlm-menu-shortcut>
          </button>

          <button disabled inset hlmMenuItem>
            Reload
            <hlm-menu-shortcut>R</hlm-menu-shortcut>
          </button>

          <button inset hlmMenuItem [brnMenuTriggerFor]='moreTools'>
            More Tools
            <hlm-menu-item-sub-indicator />
          </button>
        </hlm-menu-group>

        <hlm-menu-separator />

        <hlm-menu-group>
          <button hlmMenuItemCheckbox checked>
            <hlm-menu-item-check />
            Show Booksmarks Bar
            <hlm-menu-shortcut>B</hlm-menu-shortcut>
          </button>
          <button hlmMenuItemCheckbox>
            <hlm-menu-item-check />
            Show full URLs
          </button>
        </hlm-menu-group>

        <hlm-menu-separator />
        <hlm-menu-label inset>People</hlm-menu-label>
        <hlm-menu-separator />
        <hlm-menu-group>
          <button hlmMenuItemRadio checked>
            <hlm-menu-item-radio />
            Pedro Duarte
          </button>
          <button hlmMenuItemRadio>
            <hlm-menu-item-radio />
            Colm Tuite
          </button>
        </hlm-menu-group>
      </hlm-menu>
    </ng-template>

    <ng-template #moreTools>
      <hlm-sub-menu class='w-48'>
        <button hlmMenuItem>
          Save Page as...
          <hlm-menu-shortcut>S</hlm-menu-shortcut>
        </button>
        <button hlmMenuItem>
          Create Shortcut...
        </button>
        <button hlmMenuItem>
          Name Window...
        </button>
        <hlm-menu-separator />
        <button hlmMenuItem>Developer Tools</button>
      </hlm-sub-menu>
    </ng-template>
    `,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/dropdown-menu-bar.stories.ts
```typescript
import { NgIcon } from '@ng-icons/core';
import { BrnMenuTriggerDirective } from '@spartan-ng/brain/menu';
import { type Meta, type StoryObj, argsToTemplate, moduleMetadata } from '@storybook/angular';
import { HlmButtonDirective } from '../button/helm/src';
import { HlmIconDirective } from '../icon/helm/src';
import { HlmMenuBarImports, HlmMenuComponent, HlmMenuImports } from './helm/src';

const meta: Meta<HlmMenuComponent> = {
	title: ' Menubar',
	component: HlmMenuComponent,
	tags: ['autodocs'],
	args: {
		variant: 'default',
	},
	argTypes: {
		variant: {
			options: ['default', 'menubar'],
			control: {
				type: 'select',
			},
		},
	},
	decorators: [
		moduleMetadata({
			imports: [
				BrnMenuTriggerDirective,
				HlmMenuImports,
				HlmMenuBarImports,
				HlmButtonDirective,
				NgIcon,
				HlmIconDirective,
			],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmMenuComponent>;

export const Default: Story = {
	render: ({ ...args }) => ({
		props: args,
		template: `
        <hlm-menu-bar class='w-fit'>
      <button hlmMenuBarItem [brnMenuTriggerFor]='file'>File</button>
      <button hlmMenuBarItem [brnMenuTriggerFor]='edit'>Edit</button>
      <button hlmMenuBarItem [brnMenuTriggerFor]='view'>View</button>
      <button hlmMenuBarItem [brnMenuTriggerFor]='profiles'>Profiles</button>
    </hlm-menu-bar>

    <ng-template #file>
      <hlm-menu ${argsToTemplate(args)} variant='menubar' class='w-48'>
        <hlm-menu-group>
          <button hlmMenuItem>
            New Tab
            <hlm-menu-shortcut>T</hlm-menu-shortcut>
          </button>
          <button hlmMenuItem>
            New Window
            <hlm-menu-shortcut>N</hlm-menu-shortcut>
          </button>
          <button hlmMenuItem disabled>New Incognito Window</button>

        </hlm-menu-group>

        <hlm-menu-separator />

        <button hlmMenuItem [brnMenuTriggerFor]='share'>
          Share
          <hlm-menu-item-sub-indicator />
        </button>

        <hlm-menu-separator />

        <button hlmMenuItem>
          Print...
          <hlm-menu-shortcut>P</hlm-menu-shortcut>
        </button>

      </hlm-menu>
    </ng-template>
    <ng-template #share>
      <hlm-sub-menu>
        <button hlmMenuItem>
          Email link
        </button>
        <button hlmMenuItem>
          Messages
        </button>
        <button hlmMenuItem>
          Notes
        </button>
      </hlm-sub-menu>
    </ng-template>

    <ng-template #edit>
      <hlm-menu variant='menubar' class='w-48'>
        <hlm-menu-group>
          <button hlmMenuItem>
            Undo
            <hlm-menu-shortcut>Z</hlm-menu-shortcut>
          </button>
          <button hlmMenuItem>
            Redo
            <hlm-menu-shortcut>Z</hlm-menu-shortcut>
          </button>
        </hlm-menu-group>

        <hlm-menu-separator />

        <button hlmMenuItem [brnMenuTriggerFor]='find'>
          Share
          <hlm-menu-item-sub-indicator />
        </button>

        <hlm-menu-separator />

        <button hlmMenuItem>Cut</button>
        <button hlmMenuItem>Copy</button>
        <button hlmMenuItem>Paste</button>

      </hlm-menu>
    </ng-template>
    <ng-template #find>
      <hlm-sub-menu>
        <button hlmMenuItem>
          Search the web
        </button>
        <hlm-menu-separator />
        <button hlmMenuItem>
          Find...
        </button>
        <button hlmMenuItem>
          Find Next
        </button>
        <button hlmMenuItem>
          Find Previous
        </button>
      </hlm-sub-menu>
    </ng-template>

    <ng-template #view>
      <hlm-menu variant='menubar'>
        <button hlmMenuItemCheckbox>
          <hlm-menu-item-check />
          Always Show Bookmarks Bar
        </button>
        <button hlmMenuItemCheckbox checked>
          <hlm-menu-item-check />
          Always Show Full URLs
        </button>
        <hlm-menu-separator />
        <button inset hlmMenuItem>
          Reload
          <hlm-menu-shortcut>R</hlm-menu-shortcut>
        </button>
        <button inset disabled hlmMenuItem>
          Force Reload
          <hlm-menu-shortcut>R</hlm-menu-shortcut>
        </button>
        <hlm-menu-separator />
        <button inset hlmMenuItem>
          Toggle Fullscreen
        </button>
        <hlm-menu-separator />
        <button inset hlmMenuItem>
          Hide Sidebar
        </button>
      </hlm-menu>
    </ng-template>

    <ng-template #profiles>
      <hlm-menu variant='menubar' class='w-48'>
        <button hlmMenuItemRadio>
          <hlm-menu-item-radio />
          Andy
        </button>
        <button hlmMenuItemRadio checked>
          <hlm-menu-item-radio />
          Benoit
        </button>
        <button hlmMenuItemRadio>
          <hlm-menu-item-radio />
          Lewis
        </button>
        <hlm-menu-separator />
        <button inset hlmMenuItem>
          Edit...
        </button>
        <hlm-menu-separator />
        <button inset hlmMenuItem>
          Add Profile...
        </button>
      </hlm-menu>
    </ng-template>
    `,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/dropdown-menu.stories.ts
```typescript
import { Component } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import * as lucide from '@ng-icons/lucide';
import { BrnMenuTriggerDirective } from '@spartan-ng/brain/menu';
import { type Meta, type StoryObj, argsToTemplate, moduleMetadata } from '@storybook/angular';
import { HlmButtonDirective } from '../button/helm/src';
import { HlmIconDirective } from '../icon/helm/src';
import { HlmMenuComponent, HlmMenuImports, HlmMenuItemCheckComponent, HlmMenuItemRadioComponent } from './helm/src';

const meta: Meta<HlmMenuComponent> = {
	title: 'Dropdown Menu',
	component: HlmMenuComponent,
	tags: ['autodocs'],
	args: {
		variant: 'default',
	},
	argTypes: {
		variant: {
			options: ['default', 'menubar'],
			control: {
				type: 'select',
			},
		},
	},
	decorators: [
		moduleMetadata({
			providers: [provideIcons(lucide)],
			imports: [BrnMenuTriggerDirective, HlmMenuImports, HlmButtonDirective, NgIcon, HlmIconDirective],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmMenuComponent>;

export const Default: Story = {
	render: ({ ...args }) => ({
		props: args,
		template: `
    <div class='w-full flex justify-center items-center pt-[20%]'>
      <button hlmBtn variant='outline' align='end' [brnMenuTriggerFor]='menu'>Open</button>
    </div>
    <ng-template #menu>
      <hlm-menu ${argsToTemplate(args)} class='w-56'>
        <hlm-menu-label>My Account</hlm-menu-label>
        <hlm-menu-separator />
        <hlm-menu-group>
          <button hlmMenuItem>
            <ng-icon hlm name='lucideUser' hlmMenuIcon />
            <span>Profile</span>
            <hlm-menu-shortcut>P</hlm-menu-shortcut>
          </button>

          <button hlmMenuItem>
            <ng-icon hlm name='lucideCreditCard' hlmMenuIcon />
            <span>Billing</span>
            <hlm-menu-shortcut>B</hlm-menu-shortcut>
          </button>

          <button hlmMenuItem>
            <ng-icon hlm name='lucideSettings' hlmMenuIcon />
            <span>Settings</span>
            <hlm-menu-shortcut>S</hlm-menu-shortcut>
          </button>

          <button hlmMenuItem>
            <ng-icon hlm name='lucideKeyboard' hlmMenuIcon />
            <span>Keyboard Shortcuts</span>
            <hlm-menu-shortcut>K</hlm-menu-shortcut>
          </button>
        </hlm-menu-group>

        <hlm-menu-separator />

        <hlm-menu-group>
          <button hlmMenuItem>
            <ng-icon hlm name='lucideUsers' hlmMenuIcon />
            <span>Team</span>
            <hlm-menu-shortcut>B</hlm-menu-shortcut>
          </button>

          <button hlmMenuItem [brnMenuTriggerFor]='invite'>
            <ng-icon hlm name='lucideUserPlus' hlmMenuIcon />
            <span>Invite Users</span>
            <hlm-menu-item-sub-indicator />
          </button>

          <button hlmMenuItem>
            <ng-icon hlm name='lucidePlus' hlmMenuIcon />
            <span>New Team</span>
            <hlm-menu-shortcut>+T</hlm-menu-shortcut>
          </button>
        </hlm-menu-group>

        <hlm-menu-separator />

        <hlm-menu-group>
          <button hlmMenuItem [disabled]='false'>
            <ng-icon hlm name='lucideGithub' hlmMenuIcon />
            <span>Github</span>
          </button>

          <button hlmMenuItem [disabled]='true'>
            <ng-icon hlm name='lucideLifeBuoy' hlmMenuIcon />
            <span>Support</span>
          </button>

          <button hlmMenuItem disabled>
            <ng-icon hlm name='lucideCloud' hlmMenuIcon />
            <span>API</span>
          </button>
        </hlm-menu-group>

        <hlm-menu-separator />

        <button hlmMenuItem>
          <ng-icon hlm name='lucideLogOut' hlmMenuIcon />
          <span>Logout</span>
          <hlm-menu-shortcut>Q</hlm-menu-shortcut>
        </button>

      </hlm-menu>
    </ng-template>

    <ng-template #invite>
      <hlm-sub-menu>
        <button hlmMenuItem>
          <ng-icon hlm name='lucideMail' hlmMenuIcon />
          Email
        </button>

        <button hlmMenuItem>
          <ng-icon hlm name='lucideMessageSquare' hlmMenuIcon />
          Message
        </button>
        <hlm-menu-separator />
        <button hlmMenuItem>
          <ng-icon hlm name='lucideCirclePlus' hlmMenuIcon />
          <span>More</span>
        </button>
      </hlm-sub-menu>
    </ng-template>
    `,
	}),
};

@Component({
	selector: 'stateful-dropdown-story',
	standalone: true,
	imports: [
		BrnMenuTriggerDirective,
		HlmMenuImports,
		HlmButtonDirective,
		NgIcon,
		HlmIconDirective,
		HlmMenuItemCheckComponent,
		HlmMenuItemRadioComponent,
	],
	template: `
		<div class="flex w-full items-center justify-center pt-[20%]">
			<button hlmBtn variant="outline" align="center" [brnMenuTriggerFor]="menu">Open</button>
		</div>
		<ng-template #menu>
			<hlm-menu class="w-56">
				<hlm-menu-group>
					<hlm-menu-label>Appearance</hlm-menu-label>

					<button hlmMenuItemCheckbox [checked]="isPanel" (triggered)="isPanel = !isPanel">
						<hlm-menu-item-check />
						<span>Panel</span>
					</button>

					<button hlmMenuItemCheckbox disabled [checked]="isActivityBar" (triggered)="isActivityBar = !isActivityBar">
						<hlm-menu-item-check />
						<span>Activity Bar</span>
					</button>

					<button hlmMenuItemCheckbox [checked]="isStatusBar" (triggered)="isStatusBar = !isStatusBar">
						<hlm-menu-item-check />
						<span>Status Bar</span>
					</button>
				</hlm-menu-group>

				<hlm-menu-separator />

				<hlm-menu-label>Panel Position</hlm-menu-label>

				<hlm-menu-group>
					@for (size of panelPositions; track size) {
						<button hlmMenuItemRadio [checked]="size === selectedPosition" (triggered)="selectedPosition = size">
							<hlm-menu-item-radio />
							<span>{{ size }}</span>
						</button>
					}
				</hlm-menu-group>

				<hlm-menu-separator />

				<button hlmMenuItem (triggered)="reset()">
					<ng-icon hlm name="lucideUndo2" hlmMenuIcon />
					Reset
				</button>
			</hlm-menu>
		</ng-template>
	`,
})
class StatefulStory {
	isStatusBar = false;
	isPanel = false;
	isActivityBar = false;

	panelPositions = ['Top', 'Bottom', 'Right', 'Left'] as const;
	selectedPosition: (typeof this.panelPositions)[number] | undefined = 'Bottom';

	reset() {
		this.isStatusBar = false;
		this.isPanel = false;
		this.isActivityBar = false;
		this.selectedPosition = 'Bottom';
	}
}

export const Stateful: Story = {
	render: () => ({
		moduleMetadata: {
			imports: [StatefulStory],
		},
		template: '<stateful-dropdown-story/>',
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/README.md
```
# ui-menu-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-menu-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-menu-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/menu/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/package.json
```json
{
	"name": "@spartan-ng/ui-menu-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@ng-icons/core": ">=29.0.0",
		"@ng-icons/lucide": ">=29.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
		"class-variance-authority": "^0.7.0",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/project.json
```json
{
	"name": "ui-menu-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/menu/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/menu/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/menu/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/menu/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/menu/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-menu-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { HlmMenuBarItemDirective } from './lib/hlm-menu-bar-item.directive';
import { HlmMenuBarComponent } from './lib/hlm-menu-bar.component';
import { HlmMenuGroupComponent } from './lib/hlm-menu-group.component';
import { HlmMenuItemCheckComponent } from './lib/hlm-menu-item-check.component';
import { HlmMenuItemCheckboxDirective } from './lib/hlm-menu-item-checkbox.directive';
import { HlmMenuItemIconDirective } from './lib/hlm-menu-item-icon.directive';
import { HlmMenuItemRadioComponent } from './lib/hlm-menu-item-radio.component';
import { HlmMenuItemRadioDirective } from './lib/hlm-menu-item-radio.directive';
import { HlmMenuItemSubIndicatorComponent } from './lib/hlm-menu-item-sub-indicator.component';
import { HlmMenuItemDirective } from './lib/hlm-menu-item.directive';
import { HlmMenuLabelComponent } from './lib/hlm-menu-label.component';
import { HlmMenuSeparatorComponent } from './lib/hlm-menu-separator.component';
import { HlmMenuShortcutComponent } from './lib/hlm-menu-shortcut.component';
import { HlmMenuComponent } from './lib/hlm-menu.component';
import { HlmSubMenuComponent } from './lib/hlm-sub-menu.component';

export * from './lib/hlm-menu-bar-item.directive';
export * from './lib/hlm-menu-bar.component';
export * from './lib/hlm-menu-group.component';
export * from './lib/hlm-menu-item-check.component';
export * from './lib/hlm-menu-item-checkbox.directive';
export * from './lib/hlm-menu-item-icon.directive';
export * from './lib/hlm-menu-item-radio.component';
export * from './lib/hlm-menu-item-radio.directive';
export * from './lib/hlm-menu-item-sub-indicator.component';
export * from './lib/hlm-menu-item.directive';
export * from './lib/hlm-menu-label.component';
export * from './lib/hlm-menu-separator.component';
export * from './lib/hlm-menu-shortcut.component';
export * from './lib/hlm-menu.component';
export * from './lib/hlm-sub-menu.component';

export const HlmMenuItemImports = [
	HlmMenuItemDirective,
	HlmMenuItemIconDirective,
	HlmMenuGroupComponent,
	HlmMenuItemSubIndicatorComponent,
	HlmMenuItemRadioComponent,
	HlmMenuItemCheckComponent,
	HlmMenuShortcutComponent,
	HlmMenuItemCheckboxDirective,
	HlmMenuItemRadioDirective,
];
export const HlmMenuStructureImports = [HlmMenuLabelComponent, HlmMenuSeparatorComponent] as const;
export const HlmMenuImports = [
	...HlmMenuItemImports,
	...HlmMenuStructureImports,
	HlmMenuComponent,
	HlmSubMenuComponent,
] as const;
export const HlmMenuBarImports = [...HlmMenuImports, HlmMenuBarComponent, HlmMenuBarItemDirective] as const;

@NgModule({
	imports: [...HlmMenuItemImports],
	exports: [...HlmMenuItemImports],
})
export class HlmMenuItemModule {}

@NgModule({
	imports: [...HlmMenuImports],
	exports: [...HlmMenuImports],
})
export class HlmMenuModule {}

@NgModule({
	imports: [...HlmMenuBarImports],
	exports: [...HlmMenuBarImports],
})
export class HlmMenuBarModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/src/lib/hlm-menu-bar-item.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnMenuItemDirective } from '@spartan-ng/brain/menu';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmMenuBarItem]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnMenuItemDirective],
})
export class HlmMenuBarItemDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground aria-expanded:bg-accent aria-expanded:text-accent-foreground',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/src/lib/hlm-menu-bar.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnMenuBarDirective } from '@spartan-ng/brain/menu';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-menu-bar',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnMenuBarDirective],
	template: '<ng-content/>',
})
export class HlmMenuBarComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm('border-border flex h-10 items-center space-x-1 rounded-md border bg-background p-1', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/src/lib/hlm-menu-group.component.ts
```typescript
import { Component } from '@angular/core';
import { BrnMenuGroupDirective } from '@spartan-ng/brain/menu';

@Component({
	selector: 'hlm-menu-group',
	standalone: true,
	host: {
		class: 'block',
	},
	hostDirectives: [BrnMenuGroupDirective],
	template: `
		<ng-content />
	`,
})
export class HlmMenuGroupComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/src/lib/hlm-menu-item-check.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideCheck } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-menu-item-check',
	providers: [provideIcons({ lucideCheck })],
	imports: [NgIcon, HlmIconDirective],
	template: `
		<!-- Using 1rem for size to mimick h-4 w-4 -->
		<ng-icon hlm size="1rem" name="lucideCheck" />
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmMenuItemCheckComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'group-[.checked]:opacity-100 opacity-0 absolute left-2 flex h-3.5 w-3.5 items-center justify-center',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/src/lib/hlm-menu-item-checkbox.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnMenuItemCheckboxDirective } from '@spartan-ng/brain/menu';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmMenuItemCheckbox]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [
		{
			directive: BrnMenuItemCheckboxDirective,
			inputs: ['disabled: disabled', 'checked: checked'],
			outputs: ['triggered: triggered'],
		},
	],
})
export class HlmMenuItemCheckboxDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'group w-full relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:bg-accent focus-visible:text-accent-foreground disabled:pointer-events-none disabled:opacity-50',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/src/lib/hlm-menu-item-icon.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { provideHlmIconConfig } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmMenuIcon]',
	standalone: true,
	providers: [provideHlmIconConfig({ size: 'sm' })],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmMenuItemIconDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('mr-2', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/src/lib/hlm-menu-item-radio.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideCircle } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-menu-item-radio',
	providers: [provideIcons({ lucideCircle })],
	imports: [NgIcon, HlmIconDirective],
	template: `
		<!-- Using 0.5rem for size to mimick h-2 w-2 -->
		<ng-icon hlm size="0.5rem" class="*:*:fill-current" name="lucideCircle" />
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmMenuItemRadioComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'group-[.checked]:opacity-100 opacity-0 absolute left-2 flex h-3.5 w-3.5 items-center justify-center',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/src/lib/hlm-menu-item-radio.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnMenuItemRadioDirective } from '@spartan-ng/brain/menu';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmMenuItemRadio]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [
		{
			directive: BrnMenuItemRadioDirective,
			inputs: ['disabled: disabled', 'checked: checked'],
			outputs: ['triggered: triggered'],
		},
	],
})
export class HlmMenuItemRadioDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'group w-full relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:bg-accent focus-visible:text-accent-foreground disabled:pointer-events-none disabled:opacity-50',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/src/lib/hlm-menu-item-sub-indicator.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronRight } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-menu-item-sub-indicator',
	providers: [provideIcons({ lucideChevronRight })],
	imports: [NgIcon, HlmIconDirective],
	template: `
		<ng-icon hlm size="none" class="h-full w-full" name="lucideChevronRight" />
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmMenuItemSubIndicatorComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('inline-block ml-auto h-4 w-4', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/src/lib/hlm-menu-item.directive.ts
```typescript
import { Directive, Input, booleanAttribute, computed, input, signal } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnMenuItemDirective } from '@spartan-ng/brain/menu';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const hlmMenuItemVariants = cva(
	'group w-full relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:bg-accent focus-visible:text-accent-foreground disabled:pointer-events-none disabled:opacity-50',
	{
		variants: { inset: { true: 'pl-8', false: '' } },
		defaultVariants: { inset: false },
	},
);
export type HlmMenuItemVariants = VariantProps<typeof hlmMenuItemVariants>;

@Directive({
	selector: '[hlmMenuItem]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [
		{
			directive: BrnMenuItemDirective,
			inputs: ['disabled: disabled'],
			outputs: ['triggered: triggered'],
		},
	],
})
export class HlmMenuItemDirective {
	private readonly _inset = signal<boolean>(false);

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmMenuItemVariants({ inset: this._inset() }), this.userClass()));

	@Input({ transform: booleanAttribute })
	public set inset(value: boolean) {
		this._inset.set(value);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/src/lib/hlm-menu-label.component.ts
```typescript
import { Component, Input, booleanAttribute, computed, input, signal } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-menu-label',
	standalone: true,
	template: `
		<ng-content />
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmMenuLabelComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm('block px-2 py-1.5 text-sm font-semibold', this._inset() && 'pl-8', this.userClass()),
	);

	private readonly _inset = signal<ClassValue>(false);
	@Input({ transform: booleanAttribute })
	public set inset(value: boolean) {
		this._inset.set(value);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/src/lib/hlm-menu-separator.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-menu-separator',
	standalone: true,
	template: '',
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmMenuSeparatorComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('block -mx-1 my-1 h-px bg-muted', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/src/lib/hlm-menu-shortcut.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-menu-shortcut',
	standalone: true,
	template: `
		<ng-content />
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmMenuShortcutComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm('ml-auto font-light text-xs tracking-widest opacity-60', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/src/lib/hlm-menu.component.ts
```typescript
import { Component, Input, computed, input, signal } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnMenuDirective } from '@spartan-ng/brain/menu';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const menuVariants = cva(
	'block border-border min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
	{
		variants: {
			variant: {
				default: 'my-0.5',
				menubar: 'my-2',
			},
		},
		defaultVariants: {
			variant: 'default',
		},
	},
);
type MenuVariants = VariantProps<typeof menuVariants>;

@Component({
	selector: 'hlm-menu',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnMenuDirective],
	template: `
		<ng-content />
	`,
})
export class HlmMenuComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(menuVariants({ variant: this._variant() }), this.userClass()));

	private readonly _variant = signal<MenuVariants['variant']>('default');
	@Input()
	public set variant(value: MenuVariants['variant']) {
		this._variant.set(value);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/menu/helm/src/lib/hlm-sub-menu.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnMenuDirective } from '@spartan-ng/brain/menu';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-sub-menu',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnMenuDirective],
	template: `
		<ng-content />
	`,
})
export class HlmSubMenuComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'border-border min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/avatar.stories.ts
```typescript
import { type Meta, type StoryObj, argsToTemplate, moduleMetadata } from '@storybook/angular';
import { HlmAvatarComponent, HlmAvatarImports } from './helm/src';

const meta: Meta<HlmAvatarComponent> = {
	title: 'Avatar',
	component: HlmAvatarComponent,
	tags: ['autodocs'],
	argTypes: {
		variant: {
			options: ['small', 'medium', 'large'],
			control: {
				type: 'select',
			},
		},
	},
	decorators: [
		moduleMetadata({
			imports: [HlmAvatarImports],
		}),
	],
	render: ({ ...args }) => ({
		props: { args },
		template: `
    <hlm-avatar ${argsToTemplate(args)}>
      <img src='/mountains.jpg' alt='Spartan logo. A red spearhead with the Angular A'  hlmAvatarImage>
      <span class='bg-sky-600 text-sky-50' hlmAvatarFallback>MT</span>
    </hlm-avatar>
`,
	}),
};

export default meta;
type Story = StoryObj<HlmAvatarComponent>;

export const Small: Story = {
	args: {
		variant: 'small',
	},
};

export const Medium: Story = {
	args: {
		variant: 'medium',
	},
};

export const Large: Story = {
	args: {
		variant: 'large',
	},
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/helm/README.md
```
# ui-avatar-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-avatar-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-avatar-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/avatar/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/helm/package.json
```json
{
	"name": "@spartan-ng/ui-avatar-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"class-variance-authority": "^0.7.0",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/helm/project.json
```json
{
	"name": "ui-avatar-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/avatar/helm/src",
	"prefix": "hlm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/avatar/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/avatar/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/avatar/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/avatar/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-avatar-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { HlmAvatarFallbackDirective } from './lib/fallback';
import { HlmAvatarComponent } from './lib/hlm-avatar.component';
import { HlmAvatarImageDirective } from './lib/image';

export * from './lib/fallback';
export * from './lib/hlm-avatar.component';
export * from './lib/image';

export const HlmAvatarImports = [HlmAvatarFallbackDirective, HlmAvatarImageDirective, HlmAvatarComponent] as const;

@NgModule({
	imports: [...HlmAvatarImports],
	exports: [...HlmAvatarImports],
})
export class HlmAvatarModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/helm/src/lib/hlm-avatar.component.spec.ts
```typescript
import { Component, Input } from '@angular/core';
import { type ComponentFixture, TestBed } from '@angular/core/testing';
import { BrnAvatarFallbackDirective, BrnAvatarImageDirective } from '@spartan-ng/brain/avatar';
import { HlmAvatarComponent } from './hlm-avatar.component';

@Component({
	selector: 'hlm-mock',
	imports: [BrnAvatarImageDirective, BrnAvatarFallbackDirective, HlmAvatarComponent],
	template: `
		<hlm-avatar [class]="class" id="fallbackOnly">
			<span brnAvatarFallback>fallback</span>
		</hlm-avatar>
	`,
	standalone: true,
})
class MockComponent {
	@Input() public class = '';
}

describe('HlmAvatarComponent', () => {
	let component: HlmAvatarComponent;
	let fixture: ComponentFixture<HlmAvatarComponent>;

	beforeEach(() => {
		fixture = TestBed.createComponent(HlmAvatarComponent);
		component = fixture.componentInstance;
	});

	it('should compile', () => {
		expect(component).toBeTruthy();
	});

	it('should add the default classes if no inputs are provided', () => {
		fixture.detectChanges();
		expect(fixture.nativeElement.className).toBe('flex h-10 overflow-hidden relative rounded-full shrink-0 w-10');
	});

	it('should add any user defined classes', () => {
		const mockFixture = TestBed.createComponent(MockComponent);
		mockFixture.componentRef.setInput('class', 'test-class');
		mockFixture.detectChanges();
		const avatar = mockFixture.nativeElement.querySelector('hlm-avatar');
		expect(avatar.className).toContain('test-class');
	});

	it('should change the size when the variant is changed', () => {
		fixture.componentRef.setInput('variant', 'small');
		fixture.detectChanges();
		expect(fixture.nativeElement.className).toContain('h-6');
		expect(fixture.nativeElement.className).toContain('w-6');
		expect(fixture.nativeElement.className).toContain('text-xs');

		fixture.componentRef.setInput('variant', 'large');
		fixture.detectChanges();
		expect(fixture.nativeElement.className).toContain('h-14');
		expect(fixture.nativeElement.className).toContain('w-14');
		expect(fixture.nativeElement.className).toContain('text-lg');
	});

	it('should support brn directives', () => {
		const mockFixture = TestBed.createComponent(MockComponent);
		mockFixture.detectChanges();
		expect(mockFixture.nativeElement.querySelector('span').textContent).toBe('fallback');
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/helm/src/lib/hlm-avatar.component.ts
```typescript
import { ChangeDetectionStrategy, Component, ViewEncapsulation, computed, input } from '@angular/core';
import { BrnAvatarComponent } from '@spartan-ng/brain/avatar';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const avatarVariants = cva('relative flex shrink-0 overflow-hidden rounded-full', {
	variants: {
		variant: {
			small: 'h-6 w-6 text-xs',
			medium: 'h-10 w-10',
			large: 'h-14 w-14 text-lg',
		},
	},
	defaultVariants: {
		variant: 'medium',
	},
});

export type AvatarVariants = VariantProps<typeof avatarVariants>;

@Component({
	selector: 'hlm-avatar',
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	template: `
		@if (image()?.canShow()) {
			<ng-content select="[hlmAvatarImage],[brnAvatarImage]" />
		} @else {
			<ng-content select="[hlmAvatarFallback],[brnAvatarFallback]" />
		}
	`,
})
export class HlmAvatarComponent extends BrnAvatarComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly variant = input<AvatarVariants['variant']>('medium');

	protected readonly _computedClass = computed(() =>
		hlm(avatarVariants({ variant: this.variant() }), this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/helm/src/lib/fallback/hlm-avatar-fallback.directive.spec.ts
```typescript
import { Component, PLATFORM_ID } from '@angular/core';
import { type ComponentFixture, TestBed, fakeAsync } from '@angular/core/testing';
import { hexColorFor, isBright } from '@spartan-ng/brain/avatar';
import { HlmAvatarFallbackDirective } from './hlm-avatar-fallback.directive';

@Component({
	selector: 'hlm-mock',
	standalone: true,
	imports: [HlmAvatarFallbackDirective],
	template: `
		<span hlmAvatarFallback [class]="userCls" [autoColor]="autoColor">fallback2</span>
	`,
})
class HlmMockComponent {
	public userCls = '';
	public autoColor = false;
}

describe('HlmAvatarFallbackDirective', () => {
	let component: HlmMockComponent;
	let fixture: ComponentFixture<HlmMockComponent>;

	beforeEach(() => {
		fixture = TestBed.overrideProvider(PLATFORM_ID, { useValue: 'browser' }).createComponent(HlmMockComponent);
		component = fixture.componentInstance;
	});

	it('should compile', () => {
		expect(component).toBeTruthy();
	});

	it('should contain the default classes if no inputs are provided', () => {
		fixture.detectChanges();
		expect(fixture.nativeElement.querySelector('span').className).toBe(
			'bg-muted flex h-full items-center justify-center rounded-full w-full',
		);
	});

	it('should add any user defined classes', async () => {
		component.userCls = 'test-class';

		fixture.detectChanges();
		expect(fixture.nativeElement.querySelector('span').className).toContain('test-class');
	});
	it('should merge bg-destructive correctly when set as user defined class, therefore removing bg-muted', async () => {
		component.userCls = 'bg-destructive ';

		fixture.detectChanges();
		expect(fixture.nativeElement.querySelector('span').className).toContain('bg-destructive');
	});

	describe('autoColor', () => {
		beforeEach(() => {
			component.autoColor = true;
			fixture.detectChanges();
		});

		it('should remove the bg-muted class from the component', fakeAsync(() => {
			fixture.detectChanges();
			expect(fixture.nativeElement.querySelector('span').className).not.toContain('bg-muted');
		}));

		it('should remove add a text color class and hex backgroundColor style depending on its content', () => {
			const hex = hexColorFor('fallback2');
			const textCls = isBright(hex) ? 'text-black' : 'text-white';
			expect(fixture.nativeElement.querySelector('span').className).toContain(textCls);
			expect(fixture.nativeElement.querySelector('span').style.backgroundColor).toBe('rgb(144, 53, 149)');
		});
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/helm/src/lib/fallback/hlm-avatar-fallback.directive.ts
```typescript
import { Directive, computed, inject } from '@angular/core';
import { BrnAvatarFallbackDirective, hexColorFor, isBright } from '@spartan-ng/brain/avatar';
import { hlm } from '@spartan-ng/brain/core';

@Directive({
	selector: '[hlmAvatarFallback]',
	standalone: true,
	exportAs: 'avatarFallback',
	hostDirectives: [
		{
			directive: BrnAvatarFallbackDirective,
			inputs: ['class:class', 'autoColor:autoColor'],
		},
	],
	host: {
		'[class]': '_computedClass()',
		'[style.backgroundColor]': "_hex() || ''",
	},
})
export class HlmAvatarFallbackDirective {
	private readonly _brn = inject(BrnAvatarFallbackDirective);
	private readonly _hex = computed(() => {
		if (!this._brn.autoColor() || !this._brn.getTextContent()) return;
		return hexColorFor(this._brn.getTextContent());
	});

	private readonly _autoColorTextCls = computed(() => {
		const hex = this._hex();
		if (!hex) return;
		return `${isBright(hex) ? 'text-black' : 'text-white'}`;
	});

	protected readonly _computedClass = computed(() => {
		return hlm(
			'flex h-full w-full items-center justify-center rounded-full',
			this._autoColorTextCls() ?? 'bg-muted',
			this._brn?.userClass(),
		);
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/helm/src/lib/fallback/index.ts
```typescript
export * from './hlm-avatar-fallback.directive';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/helm/src/lib/image/hlm-avatar-image.directive.spec.ts
```typescript
import { Component } from '@angular/core';
import { type ComponentFixture, TestBed } from '@angular/core/testing';
import { HlmAvatarImageDirective } from './hlm-avatar-image.directive';

@Component({
	selector: 'hlm-mock',
	standalone: true,
	imports: [HlmAvatarImageDirective],
	template: `
		<img hlmAvatarImage alt="Avatar image" [class]="userCls" />
	`,
})
class HlmMockComponent {
	public userCls = '';
}

describe('HlmAvatarImageDirective', () => {
	let component: HlmMockComponent;
	let fixture: ComponentFixture<HlmMockComponent>;

	beforeEach(() => {
		fixture = TestBed.createComponent(HlmMockComponent);
		component = fixture.componentInstance;
	});

	it('should compile', () => {
		expect(component).toBeTruthy();
	});

	it('should add the default classes if no inputs are provided', () => {
		fixture.detectChanges();
		expect(fixture.nativeElement.querySelector('img').className).toBe('aspect-square h-full object-cover w-full');
	});

	it('should add any user defined classes', async () => {
		component.userCls = 'test-class';
		fixture.detectChanges();

		// fallback uses Promise.resolve().then() so we need to wait for the next tick
		setTimeout(() => {
			expect(fixture.nativeElement.querySelector('img').className).toContain('test-class');
		});
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/helm/src/lib/image/hlm-avatar-image.directive.ts
```typescript
import { Directive, computed, inject, input } from '@angular/core';
import { BrnAvatarImageDirective } from '@spartan-ng/brain/avatar';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: 'img[hlmAvatarImage]',
	standalone: true,
	exportAs: 'avatarImage',
	hostDirectives: [BrnAvatarImageDirective],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmAvatarImageDirective {
	public canShow = inject(BrnAvatarImageDirective).canShow;

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('aspect-square object-cover h-full w-full', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/avatar/helm/src/lib/image/index.ts
```typescript
export * from './hlm-avatar-image.directive';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/typography.stories.ts
```typescript
import type { Meta, StoryObj } from '@storybook/angular';
import { moduleMetadata } from '@storybook/angular';
import { hlmBlockquote, hlmH1, hlmH2, hlmH3, hlmLead, hlmP, hlmUl } from './helm/src';

const meta: Meta<{}> = {
	title: 'Typography',
	tags: ['autodocs'],
	decorators: [
		moduleMetadata({
			imports: [],
		}),
	],
};

export default meta;
type Story = StoryObj<{}>;

export const Default: Story = {
	render: () => ({
		template: `
    <h1 class="${hlmH1}">The Joke Tax Chronicles</h1>
    <p class="${hlmLead} mt-4">
      Once upon a time, in a far-off land, there was a very lazy king who spent all day lounging on his throne. One day,
      his advisors came to him with a problem: the kingdom was running out of money.
    </p>
    <h2 class="${hlmH2} mt-10">The King's Plan</h2>
    <p class="${hlmP}">
      The king thought long and hard, and finally came up with a brilliant plan : he would tax the jokes in the kingdom.
    </p>
    <blockquote class="${hlmBlockquote}">
      "After all," he said, "everyone enjoys a good joke, so it's only fair that they should pay for the privilege."
    </blockquote>
    <h3 class="${hlmH3} mt-8">The Joke Tax</h3>
    <p class="${hlmP}">The king's subjects were not amused. They grumbled and complained, but the king was firm:</p>
    <ul class="${hlmUl}">
      <li>1st level of puns: 5 gold coins</li>
      <li>2nd level of jokes: 10 gold coins</li>
      <li>3rd level of one-liners : 20 gold coins</li>
    </ul>
    <p class="${hlmP}">
      As a result, people stopped telling jokes, and the kingdom fell into a gloom. But there was one person who refused
      to let the king's foolishness get him down: a court jester named Jokester.
    </p>
    <h3 class="${hlmH3} mt-8">Jokester's Revolt</h3>
    <p class="${hlmP}">
      Jokester began sneaking into the castle in the middle of the night and leaving jokes all over the place: under the
      king's pillow, in his soup, even in the royal toilet. The king was furious, but he couldn't seem to stop Jokester.
    </p>
    <p class="${hlmP}">
      And then, one day, the people of the kingdom discovered that the jokes left by Jokester were so funny that they
      couldn't help but laugh. And once they started laughing, they couldn't stop.
    </p>
    <h3 class="${hlmH3} mt-8">The People's Rebellion</h3>
    <p class="${hlmP}">
      The people of the kingdom, feeling uplifted by the laughter, started to tell jokes and puns again, and soon the
      entire kingdom was in on the joke.
    </p>
    <p class="${hlmP}">
      The king, seeing how much happier his subjects were, realized the error of his ways and repealed the joke tax.
      Jokester was declared a hero, and the kingdom lived happily ever after.
    </p>
    <p class="${hlmP}">
      The moral of the story is: never underestimate the power of a good laugh and always be careful of bad ideas.
    </p>
    `,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/README.md
```
# ui-typography-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-typography-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-typography-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	coverageDirectory: '../../../../coverage/libs/button/helm',
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/typography/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/package.json
```json
{
	"name": "@spartan-ng/ui-typography-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/project.json
```json
{
	"name": "ui-typography-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/typography/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/typography/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/typography/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/typography/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/typography/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-typography-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/src/index.ts
```typescript
export * from './lib/hlm-blockquote.directive';
export * from './lib/hlm-code.directive';
export * from './lib/hlm-h1.directive';
export * from './lib/hlm-h2.directive';
export * from './lib/hlm-h3.directive';
export * from './lib/hlm-h4.directive';
export * from './lib/hlm-large.directive';
export * from './lib/hlm-lead.directive';
export * from './lib/hlm-muted.directive';
export * from './lib/hlm-p.directive';
export * from './lib/hlm-small.directive';
export * from './lib/hlm-ul.directive';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/src/lib/hlm-blockquote.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmBlockquote = 'mt-6 border-border border-l-2 pl-6 italic';

@Directive({
	selector: '[hlmBlockquote]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmBlockquoteDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmBlockquote, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/src/lib/hlm-code.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmCode = 'relative rounded bg-muted px-[0.3rem] py-[0.2rem] font-mono text-sm font-semibold';

@Directive({
	selector: '[hlmCode]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCodeDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmCode, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/src/lib/hlm-h1.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmH1 = 'scroll-m-20 text-4xl font-extrabold tracking-tight lg:text-5xl';

@Directive({
	selector: '[hlmH1]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmH1Directive {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmH1, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/src/lib/hlm-h2.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmH2 =
	'scroll-m-20 border-border border-b pb-2 text-3xl font-semibold tracking-tight transition-colors first:mt-0';

@Directive({
	selector: '[hlmH2]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmH2Directive {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmH2, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/src/lib/hlm-h3.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmH3 = 'scroll-m-20 text-2xl font-semibold tracking-tight';

@Directive({
	selector: '[hlmH3]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmH3Directive {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmH3, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/src/lib/hlm-h4.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmH4 = 'scroll-m-20 text-xl font-semibold tracking-tight';

@Directive({
	selector: '[hlmH4]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmH4Directive {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmH4, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/src/lib/hlm-large.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmLarge = 'text-lg font-semibold';

@Directive({
	selector: '[hlmLarge]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmLargeDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmLarge, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/src/lib/hlm-lead.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmLead = 'text-xl text-muted-foreground';

@Directive({
	selector: '[hlmLead]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmLeadDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmLead, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/src/lib/hlm-muted.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmMuted = 'text-sm text-muted-foreground';

@Directive({
	selector: '[hlmMuted]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmMutedDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmMuted, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/src/lib/hlm-p.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmP = 'leading-7 [&:not(:first-child)]:mt-6';

@Directive({
	selector: '[hlmP]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmPDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmP, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/src/lib/hlm-small.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmSmall = 'text-sm font-medium leading-none';

@Directive({
	selector: '[hlmSmall]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSmallDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmSmall, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/typography/helm/src/lib/hlm-ul.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmUl = 'my-6 ml-6 list-disc [&>li]:mt-2';

@Directive({
	selector: '[hlmUl]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmUlDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmUl, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/aspect-ratio/aspect-ratio.stories.ts
```typescript
import type { Meta, StoryObj } from '@storybook/angular';
import { moduleMetadata } from '@storybook/angular';
import { HlmAspectRatioDirective } from './helm/src';

export type AspectRatio = { ratio: string | number };
const meta: Meta<AspectRatio> = {
	title: 'Aspect Ratio',
	component: HlmAspectRatioDirective,
	tags: ['autodocs'],
	args: { ratio: '16/9' },
	argTypes: {
		ratio: {
			options: ['16/9', '1/1', '5/4', '3/2', 1.234],
			control: {
				type: 'select',
			},
		},
	},
	decorators: [
		moduleMetadata({
			imports: [HlmAspectRatioDirective],
		}),
	],
};

export default meta;
type Story = StoryObj<AspectRatio>;

export const Default: Story = {
	args: {
		ratio: '16/9',
	},
	render: ({ ratio }) => ({
		props: {
			ratio,
		},
		template: `
      <div class='max-w-xl overflow-hidden rounded-xl drop-shadow'>
        <div [hlmAspectRatio]='ratio'>
          <img
            alt='Mountain views'
            src='/mountains.jpg'
          />
        </div>
      </div>
    `,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/aspect-ratio/helm/README.md
```
# ui-aspect-ratio-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-aspect-ratio-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/aspect-ratio/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/aspect-ratio/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-aspect-ratio-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/aspect-ratio/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/aspect-ratio/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/aspect-ratio/helm/package.json
```json
{
	"name": "@spartan-ng/ui-aspectratio-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/cdk": ">=19.0.0",
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/aspect-ratio/helm/project.json
```json
{
	"name": "ui-aspect-ratio-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/aspect-ratio/helm/src",
	"prefix": "hlm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/aspect-ratio/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/aspect-ratio/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/aspect-ratio/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/aspect-ratio/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-aspect-ratio-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/aspect-ratio/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/aspect-ratio/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/aspect-ratio/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/aspect-ratio/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/aspect-ratio/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmAspectRatioDirective } from './lib/helm-aspect-ratio.directive';

export * from './lib/helm-aspect-ratio.directive';

@NgModule({
	imports: [HlmAspectRatioDirective],
	exports: [HlmAspectRatioDirective],
})
export class HlmAspectRatioModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/aspect-ratio/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/aspect-ratio/helm/src/lib/helm-aspect-ratio.directive.spec.ts
```typescript
import { Component } from '@angular/core';
import { type ComponentFixture, TestBed } from '@angular/core/testing';
import { HlmAspectRatioDirective } from './helm-aspect-ratio.directive';

@Component({
	selector: 'hlm-mock',
	standalone: true,
	imports: [HlmAspectRatioDirective],
	template: `
		<div [hlmAspectRatio]="ratio">
			<img
				alt="Sample image"
				src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAANCSURBVEiJtZZPbBtFFMZ/M7ubXdtdb1xSFyeilBapySVU8h8OoFaooFSqiihIVIpQBKci6KEg9Q6H9kovIHoCIVQJJCKE1ENFjnAgcaSGC6rEnxBwA04Tx43t2FnvDAfjkNibxgHxnWb2e/u992bee7tCa00YFsffekFY+nUzFtjW0LrvjRXrCDIAaPLlW0nHL0SsZtVoaF98mLrx3pdhOqLtYPHChahZcYYO7KvPFxvRl5XPp1sN3adWiD1ZAqD6XYK1b/dvE5IWryTt2udLFedwc1+9kLp+vbbpoDh+6TklxBeAi9TL0taeWpdmZzQDry0AcO+jQ12RyohqqoYoo8RDwJrU+qXkjWtfi8Xxt58BdQuwQs9qC/afLwCw8tnQbqYAPsgxE1S6F3EAIXux2oQFKm0ihMsOF71dHYx+f3NND68ghCu1YIoePPQN1pGRABkJ6Bus96CutRZMydTl+TvuiRW1m3n0eDl0vRPcEysqdXn+jsQPsrHMquGeXEaY4Yk4wxWcY5V/9scqOMOVUFthatyTy8QyqwZ+kDURKoMWxNKr2EeqVKcTNOajqKoBgOE28U4tdQl5p5bwCw7BWquaZSzAPlwjlithJtp3pTImSqQRrb2Z8PHGigD4RZuNX6JYj6wj7O4TFLbCO/Mn/m8R+h6rYSUb3ekokRY6f/YukArN979jcW+V/S8g0eT/N3VN3kTqWbQ428m9/8k0P/1aIhF36PccEl6EhOcAUCrXKZXXWS3XKd2vc/TRBG9O5ELC17MmWubD2nKhUKZa26Ba2+D3P+4/MNCFwg59oWVeYhkzgN/JDR8deKBoD7Y+ljEjGZ0sosXVTvbc6RHirr2reNy1OXd6pJsQ+gqjk8VWFYmHrwBzW/n+uMPFiRwHB2I7ih8ciHFxIkd/3Omk5tCDV1t+2nNu5sxxpDFNx+huNhVT3/zMDz8usXC3ddaHBj1GHj/As08fwTS7Kt1HBTmyN29vdwAw+/wbwLVOJ3uAD1wi/dUH7Qei66PfyuRj4Ik9is+hglfbkbfR3cnZm7chlUWLdwmprtCohX4HUtlOcQjLYCu+fzGJH2QRKvP3UNz8bWk1qMxjGTOMThZ3kvgLI5AzFfo379UAAAAASUVORK5CYII="
			/>
		</div>
	`,
})
class MockComponent {
	public ratio: number | undefined = 16 / 9;
}

describe('HelmAspectRatioDirective', () => {
	let component: MockComponent;
	let fixture: ComponentFixture<MockComponent>;

	beforeEach(() => {
		fixture = TestBed.createComponent(MockComponent);
		component = fixture.componentInstance;
	});

	it('should compile', () => {
		expect(component).toBeTruthy();
	});

	it('should show the image', () => {
		fixture.detectChanges();
		const img = fixture.nativeElement.querySelector('img');
		expect(img).toBeTruthy();
	});

	it('should have the correct aspect ratio', () => {
		fixture.detectChanges();
		const div = fixture.nativeElement.querySelector('div');
		expect(div.style.paddingBottom).toEqual(`${100 / (component.ratio || 1)}%`);
	});

	it('should default to an aspect ratio of 1', () => {
		component.ratio = undefined;
		fixture.detectChanges();
		const div = fixture.nativeElement.querySelector('div');
		expect(div.style.paddingBottom).toEqual('100%');
	});

	it('should fallback to an aspect ratio of 1 if the ratio is 0', () => {
		component.ratio = 0;
		fixture.detectChanges();
		const div = fixture.nativeElement.querySelector('div');
		expect(div.style.paddingBottom).toEqual('100%');
	});

	it('should fallback to an aspect ratio of 1 if the ratio is negative', () => {
		component.ratio = -1;
		fixture.detectChanges();
		const div = fixture.nativeElement.querySelector('div');
		expect(div.style.paddingBottom).toEqual('100%');
	});

	it('should add the correct styles to the image', () => {
		fixture.detectChanges();

		const img = fixture.nativeElement.querySelector('img') as HTMLImageElement;
		expect(img.classList.toString()).toBe('absolute w-full h-full object-cover');
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/aspect-ratio/helm/src/lib/helm-aspect-ratio.directive.ts
```typescript
import { type NumberInput, coerceNumberProperty } from '@angular/cdk/coercion';
import { type AfterViewInit, Directive, ElementRef, computed, inject, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

const parseDividedString = (value: NumberInput): NumberInput => {
	if (typeof value !== 'string' || !value.includes('/')) return value;
	return value
		.split('/')
		.map((v) => Number.parseInt(v, 10))
		.reduce((a, b) => a / b);
};

@Directive({
	selector: '[hlmAspectRatio]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		'[style.padding-bottom]': '_computedPaddingBottom()',
	},
})
export class HlmAspectRatioDirective implements AfterViewInit {
	private readonly _el = inject<ElementRef<HTMLElement>>(ElementRef).nativeElement;

	public readonly ratio = input(1, {
		alias: 'hlmAspectRatio',
		transform: (value: NumberInput) => {
			const coerced = coerceNumberProperty(parseDividedString(value));
			return coerced <= 0 ? 1 : coerced;
		},
	});
	protected readonly _computedPaddingBottom = computed(() => `${100 / this.ratio()}%`);

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm('relative w-full', this.userClass()));

	ngAfterViewInit() {
		// support delayed addition of image to dom
		const child = this._el.firstElementChild;
		if (child) {
			child.classList.add('absolute', 'w-full', 'h-full', 'object-cover');
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/switch/switch.stories.ts
```typescript
import type { Meta, StoryObj } from '@storybook/angular';
import { argsToTemplate, moduleMetadata } from '@storybook/angular';

import { FormsModule } from '@angular/forms';
import { BrnSwitchComponent, BrnSwitchImports } from '@spartan-ng/brain/switch';
import { HlmLabelDirective } from '../label/helm/src';
import { HlmSwitchImports } from './helm/src';
import { SwitchFormComponent } from './helm/src/lib/hlm-switch-ng-model.component.ignore.spec';

const meta: Meta<BrnSwitchComponent> = {
	title: 'Switch',
	component: BrnSwitchComponent,
	tags: ['autodocs'],
	decorators: [
		moduleMetadata({
			imports: [BrnSwitchImports, HlmSwitchImports, HlmLabelDirective, SwitchFormComponent, FormsModule],
		}),
	],
};

export default meta;
type Story = StoryObj<BrnSwitchComponent>;

export const Default: Story = {
	render: () => ({
		template: `
       <hlm-switch id='testSwitchDefault' aria-label='test switch' />
    `,
	}),
};

export const InsideLabel: Story = {
	render: () => ({
		template: `
      <label class='flex items-center' hlmLabel> Test Switch
        <hlm-switch class='ml-2' id='testSwitchInsideLabel' />
      </label>
    `,
	}),
};

export const LabeledWithAriaLabeledBy: Story = {
	render: () => ({
		template: `
      <div class='flex items-center'>
        <label id='testSwitchLabel' for='testSwitchLabeledWithAria' hlmLabel> Test Switch </label>
        <hlm-switch class='ml-2' id='testSwitchLabeledWithAria' aria-labelledby='testSwitchLabel' />
      </div>
    `,
	}),
};

export const Disabled: Story = {
	render: () => ({
		template: `
      <div class='flex items-center'>
         <label id='testSwitchLabel' for='testSwitchDisabled' hlmLabel> Disabled Switch </label>
       <hlm-switch  disabled="true" class='ml-2' id='testSwitchDisabled' aria-labelledby='testSwitchLabel' />
      </div>
    `,
	}),
};

type FormStory = StoryObj<SwitchFormComponent>;
export const Form: FormStory = {
	render: () => ({
		template: `
    <hlm-switch-ng-model />
    `,
	}),
};

export const FormTrue: FormStory = {
	args: {
		switchValue: true,
	},
	render: ({ ...args }) => ({
		props: args,
		template: `
    <hlm-switch-ng-model  ${argsToTemplate(args)} />
    `,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/switch/helm/README.md
```
# ui-switch-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-switch-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/switch/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/switch/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-switch-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	coverageDirectory: '../../../../coverage/libs/ui/switch/helm',
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	testPathIgnorePatterns: ['<rootDir>/src/lib/hlm-switch-ng-model.component.ignore.spec.ts'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/switch/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/switch/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/switch/helm/package.json
```json
{
	"name": "@spartan-ng/ui-switch-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/cdk": ">=19.0.0",
		"@angular/core": ">=19.0.0",
		"@angular/forms": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/switch/helm/project.json
```json
{
	"name": "ui-switch-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/switch/helm/src",
	"prefix": "hlm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/switch/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/switch/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/switch/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/switch/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-switch-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/switch/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/switch/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/switch/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/switch/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/switch/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { HlmSwitchThumbDirective } from './lib/hlm-switch-thumb.directive';
import { HlmSwitchComponent } from './lib/hlm-switch.component';

export * from './lib/hlm-switch-thumb.directive';
export * from './lib/hlm-switch.component';

export const HlmSwitchImports = [HlmSwitchComponent, HlmSwitchThumbDirective] as const;
@NgModule({
	imports: [...HlmSwitchImports],
	exports: [...HlmSwitchImports],
})
export class HlmSwitchModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/switch/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/switch/helm/src/lib/hlm-switch-ng-model.component.ignore.spec.ts
```typescript
import { Component, Input } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { HlmSwitchComponent } from './hlm-switch.component';
@Component({
	selector: 'hlm-switch-ng-model',
	template: `
		<!-- eslint-disable-next-line @angular-eslint/template/label-has-associated-control -->
		<label class="flex items-center" hlmLabel>
			test switch
			<hlm-switch [(ngModel)]="switchValue" id="testSwitchForm" (changed)="handleChange($event)" />
		</label>

		<p data-testid="switchValue">{{ switchValue }}</p>
		<p data-testid="changedValue">{{ changedValueTo }}</p>
	`,
	imports: [HlmSwitchComponent, FormsModule],
})
export class SwitchFormComponent {
	@Input()
	public switchValue = false;

	protected changedValueTo: boolean | undefined;

	handleChange(value: boolean) {
		this.changedValueTo = value;
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/switch/helm/src/lib/hlm-switch-thumb.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: 'brn-switch-thumb[hlm],[hlmSwitchThumb]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSwitchThumbDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm(
			'block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform group-data-[state=checked]:translate-x-5 group-data-[state=unchecked]:translate-x-0',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/switch/helm/src/lib/hlm-switch.component.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { Component, booleanAttribute, computed, forwardRef, input, model, output, signal } from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';
import { hlm } from '@spartan-ng/brain/core';
import { ChangeFn, TouchFn } from '@spartan-ng/brain/forms';
import { BrnSwitchComponent, BrnSwitchThumbComponent } from '@spartan-ng/brain/switch';
import type { ClassValue } from 'clsx';
import { HlmSwitchThumbDirective } from './hlm-switch-thumb.directive';
export const HLM_SWITCH_VALUE_ACCESSOR = {
	provide: NG_VALUE_ACCESSOR,
	useExisting: forwardRef(() => HlmSwitchComponent),
	multi: true,
};

@Component({
	selector: 'hlm-switch',
	imports: [BrnSwitchThumbComponent, BrnSwitchComponent, HlmSwitchThumbDirective],
	host: {
		class: 'contents',
		'[attr.id]': 'null',
		'[attr.aria-label]': 'null',
		'[attr.aria-labelledby]': 'null',
		'[attr.aria-describedby]': 'null',
	},
	template: `
		<brn-switch
			[class]="_computedClass()"
			[checked]="checked()"
			(changed)="handleChange($event)"
			(touched)="_onTouched?.()"
			[disabled]="disabled()"
			[id]="id()"
			[aria-label]="ariaLabel()"
			[aria-labelledby]="ariaLabelledby()"
			[aria-describedby]="ariaDescribedby()"
		>
			<brn-switch-thumb hlm />
		</brn-switch>
	`,
	providers: [HLM_SWITCH_VALUE_ACCESSOR],
})
export class HlmSwitchComponent implements ControlValueAccessor {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'group inline-flex h-[24px] w-[44px] shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input',
			this.disabled() ? 'cursor-not-allowed opacity-50' : '',
			this.userClass(),
		),
	);

	/** The checked state of the switch. */
	public readonly checked = model<boolean>(false);

	/** The disabled state of the switch. */
	public readonly disabledInput = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
		alias: 'disabled',
	});

	/** Used to set the id on the underlying brn element. */
	public readonly id = input<string | null>(null);

	/** Used to set the aria-label attribute on the underlying brn element. */
	public readonly ariaLabel = input<string | null>(null, { alias: 'aria-label' });

	/** Used to set the aria-labelledby attribute on the underlying brn element. */
	public readonly ariaLabelledby = input<string | null>(null, { alias: 'aria-labelledby' });

	/** Used to set the aria-describedby attribute on the underlying brn element. */
	public readonly ariaDescribedby = input<string | null>(null, { alias: 'aria-describedby' });

	/** Emits when the checked state of the switch changes. */
	public readonly changed = output<boolean>();

	private readonly _writableDisabled = computed(() => signal(this.disabledInput()));

	public readonly disabled = computed(() => this._writableDisabled()());

	protected _onChange?: ChangeFn<boolean>;
	protected _onTouched?: TouchFn;

	protected handleChange(value: boolean): void {
		this.checked.set(value);
		this._onChange?.(value);
		this.changed.emit(value);
	}

	/** CONROL VALUE ACCESSOR */

	writeValue(value: boolean): void {
		this.checked.set(Boolean(value));
	}

	registerOnChange(fn: ChangeFn<boolean>): void {
		this._onChange = fn;
	}

	registerOnTouched(fn: TouchFn): void {
		this._onTouched = fn;
	}

	setDisabledState(isDisabled: boolean): void {
		this._writableDisabled().set(isDisabled);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/command.stories.ts
```typescript
import { Component, HostListener, signal } from '@angular/core';
import { FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { NgIcon, provideIcons } from '@ng-icons/core';
import * as lucide from '@ng-icons/lucide';
import { BrnCommandDirective, BrnCommandImports } from '@spartan-ng/brain/command';
import { BrnDialogImports } from '@spartan-ng/brain/dialog';
import type { Meta, StoryObj } from '@storybook/angular';
import { moduleMetadata } from '@storybook/angular';
import { HlmButtonDirective } from '../button/helm/src';
import { HlmDialogOverlayDirective } from '../dialog/helm/src';
import { HlmIconDirective } from '../icon/helm/src';
import { HlmCodeDirective } from '../typography/helm/src';
import { HlmCommandImports } from './helm/src';

const meta: Meta<BrnCommandDirective> = {
	title: 'Command',
	component: BrnCommandDirective,
	tags: ['autodocs'],
	decorators: [
		moduleMetadata({
			providers: [provideIcons(lucide)],
			imports: [BrnCommandImports, HlmCommandImports, NgIcon, HlmIconDirective, HlmButtonDirective],
		}),
	],
};

export default meta;
type Story = StoryObj<BrnCommandDirective>;

export const Default: Story = {
	render: () => ({
		template: `
		<hlm-command>
  <hlm-command-search>
    <ng-icon hlm name="lucideSearch" class="inline-flex" />

    <input
      type="text"
      hlm-command-search-input
      placeholder="Type a command or search..."
    />
  </hlm-command-search>

  <hlm-command-list>
    <hlm-command-group>
      <hlm-command-group-label>Suggestions</hlm-command-group-label>

      <button hlm-command-item value="Calendar">
        <ng-icon hlm name="lucideCalendar" hlmCommandIcon />
        Calendar
      </button>
      <button disabled hlm-command-item value="Search Emoji">
        <ng-icon hlm name="lucideSmile" hlmCommandIcon />
        Search Emoji
      </button>
      <button hlm-command-item value="Calculator">
        <ng-icon hlm name="lucidePlus" hlmCommandIcon />
        Calculator
      </button>
    </hlm-command-group>

    <hlm-command-separator />

    <hlm-command-group>
      <hlm-command-group-label>Settings</hlm-command-group-label>

      <button hlm-command-item value="Profile">
        <ng-icon hlm name="lucideUser" hlmCommandIcon />
        Profile
        <hlm-command-shortcut>P</hlm-command-shortcut>
      </button>
      <button hlm-command-item value="Billing">
        <ng-icon hlm name="lucideWallet" hlmCommandIcon />
        Billing
        <hlm-command-shortcut>B</hlm-command-shortcut>
      </button>
      <button hlm-command-item value="Settings">
        <ng-icon hlm name="lucideCog" hlmCommandIcon />
        Settings
        <hlm-command-shortcut>S</hlm-command-shortcut>
      </button>
    </hlm-command-group>
  </hlm-command-list>

  <!-- Empty state -->
  <div *brnCommandEmpty hlmCommandEmpty>No results found.</div>
</hlm-command>

    `,
	}),
};

@Component({
	selector: 'command-dialog-component',
	standalone: true,
	imports: [
		BrnCommandImports,
		HlmCommandImports,
		BrnDialogImports,
		HlmDialogOverlayDirective,
		NgIcon,
		HlmIconDirective,
		HlmButtonDirective,
		HlmCodeDirective,
	],
	template: `
		<div class="mx-auto flex max-w-screen-sm items-center justify-center space-x-4 py-20 text-sm">
			<p>
				Press
				<code hlmCode> + K</code>
			</p>
			<p>
				Last command:
				<code data-testid="lastCommand" hlmCode>{{ command() || 'none' }}</code>
			</p>
		</div>
		<brn-dialog [state]="state()" (stateChanged)="stateChanged($event)">
			<brn-dialog-overlay hlm />

			<hlm-command *brnDialogContent="let ctx" hlmCommandDialog class="relative mx-auto sm:w-[400px]">
				<button hlmCommandDialogCloseBtn>
					<ng-icon hlm name="lucideX" />
				</button>

				<hlm-command-search>
					<ng-icon hlm name="lucideSearch" class="inline-flex" />

					<input type="text" hlm-command-search-input placeholder="Type a command or search..." />
				</hlm-command-search>

				<hlm-command-list>
					<hlm-command-group>
						<hlm-command-group-label>Suggestions</hlm-command-group-label>

						<button hlm-command-item value="Calendar">
							<ng-icon hlm name="lucideCalendar" hlmCommandIcon />
							Calendar
						</button>
						<button hlm-command-item disabled value="Search Emoji">
							<ng-icon hlm name="lucideSmile" hlmCommandIcon />
							Search Emoji
						</button>
						<button hlm-command-item value="Calculator">
							<ng-icon hlm name="lucidePlus" hlmCommandIcon />
							Calculator
						</button>
					</hlm-command-group>

					<hlm-command-separator />

					<hlm-command-group>
						<hlm-command-group-label>Settings</hlm-command-group-label>

						<button hlm-command-item value="Profile">
							<ng-icon hlm name="lucideUser" hlmCommandIcon />
							Profile
							<hlm-command-shortcut>P</hlm-command-shortcut>
						</button>
						<button hlm-command-item value="Billing">
							<ng-icon hlm name="lucideWallet" hlmCommandIcon />
							Billing
							<hlm-command-shortcut>B</hlm-command-shortcut>
						</button>
						<button hlm-command-item value="Settings">
							<ng-icon hlm name="lucideCog" hlmCommandIcon />
							Settings
							<hlm-command-shortcut>S</hlm-command-shortcut>
						</button>
					</hlm-command-group>
				</hlm-command-list>

				<!-- Empty state -->
				<div *brnCommandEmpty hlmCommandEmpty>No results found.</div>
			</hlm-command>
		</brn-dialog>
	`,
})
class CommandDialogComponent {
	public command = signal('');
	public state = signal<'closed' | 'open'>('closed');

	@HostListener('window:keydown', ['$event'])
	onKeyDown(event: KeyboardEvent) {
		if ((event.metaKey || event.ctrlKey) && (event.key === 'k' || event.key === 'K')) {
			this.state.set('open');
		}
	}

	stateChanged(state: 'open' | 'closed') {
		this.state.set(state);
	}

	commandSelected(selected: string) {
		this.state.set('closed');
		this.command.set(selected);
	}
}

export const Dialog: Story = {
	decorators: [
		moduleMetadata({
			imports: [CommandDialogComponent],
		}),
	],
	render: () => ({
		template: '<command-dialog-component/>',
	}),
};

@Component({
	selector: 'command-dynamic-component',
	standalone: true,
	imports: [
		BrnCommandImports,
		HlmCommandImports,
		BrnDialogImports,
		NgIcon,
		HlmIconDirective,
		HlmButtonDirective,
		FormsModule,
	],
	template: `
		<hlm-command>
			<hlm-command-search>
				<ng-icon hlm name="lucideSearch" class="inline-flex" />

				<input type="text" hlm-command-search-input placeholder="Type a command or search..." [ngModel]="search()" />
			</hlm-command-search>

			<hlm-command-list>
				<hlm-command-group>
					<hlm-command-group-label>Suggestions</hlm-command-group-label>
					@for (item of items(); track item.value) {
						<button hlm-command-item [value]="item.value" data-testid="command-item">
							<ng-icon hlm [name]="item.icon" hlmCommandIcon />
							{{ item.label }}
						</button>
					}
				</hlm-command-group>
			</hlm-command-list>

			<!-- Empty state -->
			<div *brnCommandEmpty hlmCommandEmpty>No results found.</div>
		</hlm-command>
	`,
})
class CommandDynamicComponent {
	protected readonly search = signal('P');
	protected readonly items = signal<{ label: string; value: string; icon: string; shortcut: string }[]>([
		{ label: 'Profile', value: 'Profile', icon: 'lucideUser', shortcut: 'P' },
		{ label: 'Billing', value: 'Billing', icon: 'lucideWallet', shortcut: 'B' },
		{ label: 'Search Emoji', value: 'Search Emoji', icon: 'lucideSmile', shortcut: 'E' },
		{ label: 'Settings', value: 'Settings', icon: 'lucideCog', shortcut: 'S' },
	]);
}

export const DynamicOptions: Story = {
	decorators: [
		moduleMetadata({
			imports: [CommandDynamicComponent],
		}),
	],
	render: () => ({
		template: '<command-dynamic-component/>',
	}),
};

@Component({
	selector: 'command-reactive-form-component',
	standalone: true,
	imports: [
		BrnCommandImports,
		HlmCommandImports,
		NgIcon,
		HlmIconDirective,
		HlmButtonDirective,
		FormsModule,
		ReactiveFormsModule,
	],
	template: `
		<hlm-command>
			<hlm-command-search>
				<ng-icon hlm name="lucideSearch" class="inline-flex" />

				<input
					type="text"
					hlm-command-search-input
					placeholder="Type a command or search..."
					[formControl]="searchControl"
				/>
			</hlm-command-search>

			<hlm-command-list>
				<hlm-command-group>
					<hlm-command-group-label>Suggestions</hlm-command-group-label>
					@for (item of items(); track item.value) {
						<button hlm-command-item [value]="item.value" data-testid="command-item">
							<ng-icon hlm [name]="item.icon" hlmCommandIcon />
							{{ item.label }}
						</button>
					}
				</hlm-command-group>
			</hlm-command-list>

			<!-- Empty state -->
			<div *brnCommandEmpty hlmCommandEmpty>No results found.</div>
		</hlm-command>
	`,
})
class CommandReactiveFormComponent {
	searchControl = new FormControl('R');
	protected readonly search = signal('P');
	protected readonly items = signal<{ label: string; value: string; icon: string; shortcut: string }[]>([
		{ label: 'Profile', value: 'Profile', icon: 'lucideUser', shortcut: 'P' },
		{ label: 'Billing', value: 'Billing', icon: 'lucideWallet', shortcut: 'B' },
		{ label: 'Search Emoji', value: 'Search Emoji', icon: 'lucideSmile', shortcut: 'E' },
		{ label: 'Settings', value: 'Settings', icon: 'lucideCog', shortcut: 'S' },
	]);
	public state = signal<'closed' | 'open'>('closed');
}

export const ReactiveForm: Story = {
	decorators: [
		moduleMetadata({
			imports: [CommandReactiveFormComponent],
		}),
	],
	render: () => ({
		template: '<command-reactive-form-component/>',
	}),
};

@Component({
	selector: 'command-bound-value-component',
	standalone: true,
	imports: [BrnCommandImports, HlmCommandImports, NgIcon, HlmIconDirective, HlmButtonDirective],
	template: `
		<hlm-command>
			<hlm-command-search>
				<ng-icon hlm name="lucideSearch" class="inline-flex" />

				<input type="text" hlm-command-search-input placeholder="Type a command or search..." [value]="search()" />
			</hlm-command-search>

			<hlm-command-list>
				<hlm-command-group>
					<hlm-command-group-label>Suggestions</hlm-command-group-label>
					@for (item of items(); track item.value) {
						<button hlm-command-item [value]="item.value" data-testid="command-item">
							<ng-icon hlm [name]="item.icon" hlmCommandIcon />
							{{ item.label }}
						</button>
					}
				</hlm-command-group>
			</hlm-command-list>

			<!-- Empty state -->
			<div *brnCommandEmpty hlmCommandEmpty>No results found.</div>
		</hlm-command>
	`,
})
class CommandBoundValueComponent {
	protected readonly search = signal('S');
	protected readonly items = signal<{ label: string; value: string; icon: string; shortcut: string }[]>([
		{ label: 'Profile', value: 'Profile', icon: 'lucideUser', shortcut: 'P' },
		{ label: 'Billing', value: 'Billing', icon: 'lucideWallet', shortcut: 'B' },
		{ label: 'Search Emoji', value: 'Search Emoji', icon: 'lucideSmile', shortcut: 'E' },
		{ label: 'Settings', value: 'Settings', icon: 'lucideCog', shortcut: 'S' },
	]);
}

export const BoundValue: Story = {
	decorators: [
		moduleMetadata({
			imports: [CommandBoundValueComponent],
		}),
	],
	render: () => ({
		template: '<command-bound-value-component/>',
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/README.md
```
# ui-command-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-command-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: ['element', 'attribute'],
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-command-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	coverageDirectory: '../../../../coverage/libs/ui/command/helm',
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/command/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/package.json
```json
{
	"name": "@spartan-ng/ui-command-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/cdk": ">=19.0.0",
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"@spartan-ng/ui-button-helm": "0.0.1-alpha.381",
		"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/project.json
```json
{
	"name": "ui-command-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/command/helm/src",
	"prefix": "hlm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/command/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/command/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/command/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/command/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-command-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { HlmCommandDialogCloseButtonDirective } from './lib/hlm-command-dialog-close-button.directive';
import { HlmCommandDialogDirective } from './lib/hlm-command-dialog.directive';
import { HlmCommandEmptyDirective } from './lib/hlm-command-empty.directive';
import { HlmCommandGroupLabelComponent } from './lib/hlm-command-group-label.component';
import { HlmCommandGroupComponent } from './lib/hlm-command-group.component';
import { HlmCommandIconDirective } from './lib/hlm-command-icon.directive';
import { HlmCommandItemComponent } from './lib/hlm-command-item.component';
import { HlmCommandListComponent } from './lib/hlm-command-list.component';
import { HlmCommandSearchInputComponent } from './lib/hlm-command-search-input.component';
import { HlmCommandSearchComponent } from './lib/hlm-command-search.component';
import { HlmCommandSeparatorComponent } from './lib/hlm-command-separator.component';
import { HlmCommandShortcutComponent } from './lib/hlm-command-shortcut.component';
import { HlmCommandComponent } from './lib/hlm-command.component';

export * from './lib/hlm-command-dialog-close-button.directive';
export * from './lib/hlm-command-dialog.directive';
export * from './lib/hlm-command-empty.directive';
export * from './lib/hlm-command-group-label.component';
export * from './lib/hlm-command-group.component';
export * from './lib/hlm-command-icon.directive';
export * from './lib/hlm-command-item.component';
export * from './lib/hlm-command-list.component';
export * from './lib/hlm-command-search-input.component';
export * from './lib/hlm-command-search.component';
export * from './lib/hlm-command-separator.component';
export * from './lib/hlm-command-shortcut.component';
export * from './lib/hlm-command.component';

export const HlmCommandImports = [
	HlmCommandComponent,
	HlmCommandItemComponent,
	HlmCommandSeparatorComponent,
	HlmCommandGroupComponent,
	HlmCommandListComponent,
	HlmCommandShortcutComponent,
	HlmCommandIconDirective,
	HlmCommandDialogCloseButtonDirective,
	HlmCommandDialogDirective,
	HlmCommandSearchInputComponent,
	HlmCommandSearchComponent,
	HlmCommandGroupLabelComponent,
	HlmCommandEmptyDirective,
] as const;

@NgModule({
	imports: [...HlmCommandImports],
	exports: [...HlmCommandImports],
})
export class HlmCommandModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/src/lib/hlm-command-dialog-close-button.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnDialogCloseDirective } from '@spartan-ng/brain/dialog';
import { HlmButtonDirective, provideBrnButtonConfig } from '@spartan-ng/ui-button-helm';
import { provideHlmIconConfig } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmCommandDialogCloseBtn]',
	standalone: true,
	hostDirectives: [HlmButtonDirective, BrnDialogCloseDirective],
	providers: [provideBrnButtonConfig({ variant: 'ghost' }), provideHlmIconConfig({ size: 'xs' })],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCommandDialogCloseButtonDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'absolute top-3 right-3 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-ring font-medium h-10 hover:bg-accent hover:text-accent-foreground inline-flex items-center justify-center px-4 py-2 ring-offset-background rounded-md text-sm transition-colors !h-5 !p-1 !w-5',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/src/lib/hlm-command-dialog.directive.ts
```typescript
import { Directive, ElementRef, Renderer2, computed, contentChild, effect, inject, input, signal } from '@angular/core';
import { BrnCommandSearchInputToken } from '@spartan-ng/brain/command';
import { hlm, injectExposesStateProvider } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmCommandDialog]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCommandDialogDirective {
	private readonly _stateProvider = injectExposesStateProvider({ host: true });
	public readonly state = this._stateProvider.state ?? signal('closed').asReadonly();
	private readonly _renderer = inject(Renderer2);
	private readonly _element = inject(ElementRef);

	/** Access the search field */
	private readonly _searchInput = contentChild(BrnCommandSearchInputToken, { read: ElementRef });

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-top-[2%]  data-[state=open]:slide-in-from-top-[2%]',
			this.userClass(),
		),
	);

	constructor() {
		effect(() => {
			this._renderer.setAttribute(this._element.nativeElement, 'data-state', this.state());

			const searchInput = this._searchInput();

			if (this.state() === 'open' && searchInput) {
				searchInput.nativeElement.focus();
			}
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/src/lib/hlm-command-empty.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmCommandEmpty]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCommandEmptyDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm('py-6 text-center text-sm', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/src/lib/hlm-command-group-label.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';

@Component({
	standalone: true,
	selector: 'hlm-command-group-label',
	template: '<ng-content />',
	host: {
		role: 'presentation',
		'[class]': '_computedClass()',
	},
})
export class HlmCommandGroupLabelComponent {
	/*** The user defined class  */
	public readonly userClass = input<string>('', { alias: 'class' });

	/*** The styles to apply  */
	protected readonly _computedClass = computed(() =>
		hlm('font-medium px-2 py-1.5 text-muted-foreground text-xs', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/src/lib/hlm-command-group.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { BrnCommandGroupDirective } from '@spartan-ng/brain/command';
import { hlm } from '@spartan-ng/brain/core';

@Component({
	standalone: true,
	selector: 'hlm-command-group',
	template: '<ng-content />',
	hostDirectives: [
		{
			directive: BrnCommandGroupDirective,
			inputs: ['id'],
		},
	],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCommandGroupComponent {
	/*** The user defined class  */
	public readonly userClass = input<string>('', { alias: 'class' });

	/*** The styles to apply  */
	protected readonly _computedClass = computed(() =>
		hlm('flex flex-col overflow-hidden p-1 text-foreground data-[hidden]:hidden', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/src/lib/hlm-command-icon.directive.ts
```typescript
import { Directive } from '@angular/core';
import { provideHlmIconConfig } from '@spartan-ng/ui-icon-helm';

@Directive({
	standalone: true,
	selector: '[hlmCommandIcon]',
	host: {
		class: 'inline-flex mr-2 w-4 h-4',
	},
	providers: [provideHlmIconConfig({ size: 'sm' })],
})
export class HlmCommandIconDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/src/lib/hlm-command-item.component.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { booleanAttribute, Component, computed, input, output } from '@angular/core';
import { BrnCommandItemDirective } from '@spartan-ng/brain/command';
import { hlm } from '@spartan-ng/brain/core';

@Component({
	standalone: true,
	selector: 'button[hlm-command-item]',
	template: `
		<ng-content />
	`,
	hostDirectives: [
		{
			directive: BrnCommandItemDirective,
			inputs: ['value', 'disabled', 'id'],
			outputs: ['selected'],
		},
	],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCommandItemComponent {
	/** The value this item represents. */
	public readonly value = input<string>();

	/** Whether the item is disabled. */
	public readonly disabled = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** Emits when the item is selected. */
	public readonly selected = output<void>();

	/*** The user defined class  */
	public readonly userClass = input<string>('', { alias: 'class' });

	/*** The styles to apply  */
	protected readonly _computedClass = computed(() =>
		hlm(
			'text-start aria-selected:bg-accent aria-selected:text-accent-foreground cursor-default disabled:opacity-50 disabled:pointer-events-none hover:bg-accent/50 items-center outline-none px-2 py-1.5 relative flex rounded-sm select-none text-sm data-[hidden]:hidden',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/src/lib/hlm-command-list.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { BrnCommandListDirective } from '@spartan-ng/brain/command';
import { hlm } from '@spartan-ng/brain/core';

@Component({
	standalone: true,
	selector: 'hlm-command-list',
	template: '<ng-content />',
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [
		{
			directive: BrnCommandListDirective,
			inputs: ['id'],
		},
	],
})
export class HlmCommandListComponent {
	/** The user defined class  */
	public readonly userClass = input<string>('', { alias: 'class' });

	/** The styles to apply  */
	protected readonly _computedClass = computed(() =>
		hlm('max-h-[300px] overflow-x-hidden overflow-y-auto', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/src/lib/hlm-command-search-input.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { BrnCommandSearchInputDirective } from '@spartan-ng/brain/command';
import { hlm } from '@spartan-ng/brain/core';

@Component({
	standalone: true,
	selector: 'input[hlm-command-search-input]',
	template: '',
	hostDirectives: [{ directive: BrnCommandSearchInputDirective, inputs: ['value'] }],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCommandSearchInputComponent {
	/*** The user defined class  */
	public readonly userClass = input<string>('', { alias: 'class' });

	/*** The styles to apply  */
	protected readonly _computedClass = computed(() =>
		hlm(
			'bg-transparent disabled:cursor-not-allowed disabled:opacity-50 h-11 outline-none placeholder:text-muted-foreground py-3 text-sm w-full',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/src/lib/hlm-command-search.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { provideHlmIconConfig } from '@spartan-ng/ui-icon-helm';

@Component({
	standalone: true,
	selector: 'hlm-command-search',
	template: `
		<ng-content />
	`,
	host: {
		'[class]': '_computedClass()',
	},
	providers: [provideHlmIconConfig({ size: 'sm' })],
})
export class HlmCommandSearchComponent {
	/*** The user defined class  */
	public readonly userClass = input<string>('', { alias: 'class' });

	/*** The styles to apply  */
	protected readonly _computedClass = computed(() =>
		hlm('relative [&_ng-icon]:flex-none border-b border-border flex items-center px-3 space-x-2', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/src/lib/hlm-command-separator.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';

@Component({
	standalone: true,
	selector: 'hlm-command-separator',
	template: '',
	host: {
		role: 'separator',
		'[class]': '_computedClass()',
	},
})
export class HlmCommandSeparatorComponent {
	/*** The user defined class  */
	public readonly userClass = input<string>('', { alias: 'class' });

	/*** The styles to apply  */
	protected readonly _computedClass = computed(() => hlm('h-px block w-full border-b border-border', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/src/lib/hlm-command-shortcut.component.ts
```typescript
import { Component } from '@angular/core';

@Component({
	standalone: true,
	selector: 'hlm-command-shortcut',
	template: '<ng-content />',
	host: {
		class: 'font-light ml-auto opacity-60 text-xs tracking-widest',
	},
})
export class HlmCommandShortcutComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/command/helm/src/lib/hlm-command.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { BrnCommandDirective } from '@spartan-ng/brain/command';
import { hlm } from '@spartan-ng/brain/core';

@Component({
	standalone: true,
	selector: 'hlm-command',
	template: `
		<ng-content />
	`,
	hostDirectives: [
		{
			directive: BrnCommandDirective,
			inputs: ['id', 'filter'],
			outputs: ['valueChange'],
		},
	],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCommandComponent {
	/*** The user defined class */
	public readonly userClass = input<string>('', { alias: 'class' });

	/*** The styles to apply  */
	protected readonly _computedClass = computed(() =>
		hlm(
			'w-96 bg-popover border border-border flex flex-col h-full overflow-hidden rounded-md text-popover-foreground',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/radio-group/radio-group.stories.ts
```typescript
import { Component } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { NgIcon } from '@ng-icons/core';
import { BrnRadioGroupDirective } from '@spartan-ng/brain/radio-group';
import { type Meta, type StoryObj, moduleMetadata } from '@storybook/angular';
import { HlmButtonDirective } from '../button/helm/src';
import { HlmIconDirective } from '../icon/helm/src';
import { HlmCodeDirective, HlmSmallDirective } from '../typography/helm/src';
import { HlmRadioGroupImports } from './helm/src';

@Component({
	selector: 'radio-group-example',
	standalone: true,
	imports: [
		HlmRadioGroupImports,
		FormsModule,
		NgIcon,
		HlmIconDirective,
		HlmButtonDirective,
		HlmCodeDirective,
		HlmSmallDirective,
	],
	template: `
		<small hlmSmall class="font-semibold">Choose a version</small>
		<hlm-radio-group class="font-mono text-sm font-medium" [(ngModel)]="version">
			<hlm-radio value="16.1.4">
				<hlm-radio-indicator indicator />
				v16.1.4
			</hlm-radio>
			<hlm-radio value="16.0.0">
				<hlm-radio-indicator indicator />
				v16.0.0
			</hlm-radio>
			<hlm-radio value="15.8.0">
				<hlm-radio-indicator indicator />
				v15.8.0
			</hlm-radio>
			<hlm-radio disabled value="15.2.0">
				<hlm-radio-indicator indicator />
				v15.2.0
			</hlm-radio>
		</hlm-radio-group>
		<div class="my-2 flex space-x-2">
			<button size="sm" hlmBtn variant="outline" (click)="version = '16.0.0'">Set to v16.0.0</button>
			<button size="sm" hlmBtn variant="outline" (click)="version = null">Reset</button>
		</div>
		<small hlmSmall class="mt-6 block font-semibold">
			Current Version:
			<code data-testid="currentVersion" hlmCode class="text-xs">{{ version ?? 'none' }}</code>
		</small>
	`,
})
class RadioGroupExampleComponent {
	version: string | null = '16.1.4';
}

const meta: Meta<BrnRadioGroupDirective> = {
	title: 'Radio Group',
	component: BrnRadioGroupDirective,
	tags: ['autodocs'],
	decorators: [
		moduleMetadata({
			imports: [RadioGroupExampleComponent],
			providers: [],
		}),
	],
};

export default meta;
type Story = StoryObj<BrnRadioGroupDirective>;

export const Default: Story = {
	render: () => ({
		template: '<radio-group-example/>',
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/radio-group/helm/README.md
```
# ui-radio-group-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-radio-group-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/radio-group/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
			'@angular-eslint/no-output-rename': 'off',
			'@angular-eslint/no-output-native': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/radio-group/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-radio-group-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/radio-group/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/radio-group/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/radio-group/helm/package.json
```json
{
	"name": "@spartan-ng/ui-radiogroup-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/radio-group/helm/project.json
```json
{
	"name": "ui-radio-group-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/radio-group/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/radio-group/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/radio-group/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/radio-group/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/radio-group/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-radio-group-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/radio-group/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/radio-group/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/radio-group/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/radio-group/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/radio-group/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { HlmRadioGroupComponent } from './lib/hlm-radio-group.component';
import { HlmRadioIndicatorComponent } from './lib/hlm-radio-indicator.component';
import { HlmRadioComponent } from './lib/hlm-radio.component';

export * from './lib/hlm-radio-group.component';
export * from './lib/hlm-radio-indicator.component';
export * from './lib/hlm-radio.component';

export const HlmRadioGroupImports = [HlmRadioGroupComponent, HlmRadioComponent, HlmRadioIndicatorComponent];

@NgModule({
	imports: [...HlmRadioGroupImports],
	exports: [...HlmRadioGroupImports],
})
export class HlmRadioGroupModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/radio-group/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/radio-group/helm/src/lib/hlm-radio-group.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnRadioGroupDirective } from '@spartan-ng/brain/radio-group';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-radio-group',
	standalone: true,
	hostDirectives: [
		{
			directive: BrnRadioGroupDirective,
			inputs: ['name', 'value', 'disabled', 'required', 'direction'],
		},
	],
	host: {
		'[class]': '_computedClass()',
	},
	template: '<ng-content />',
})
export class HlmRadioGroupComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('grid gap-2', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/radio-group/helm/src/lib/hlm-radio-indicator.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

const btnLike =
	'aspect-square rounded-full ring-offset-background group-[.cdk-keyboard-focused]:ring-2 group-[.cdk-keyboard-focused]:ring-ring group-[.cdk-keyboard-focused]:ring-offset-2 group-[.brn-radio-disabled]:cursor-not-allowed group-[.brn-radio-disabled]:opacity-50';

@Component({
	selector: 'hlm-radio-indicator',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	template: `
		<div
			class="bg-foreground absolute inset-0 hidden scale-[55%] rounded-full group-[.brn-radio-checked]:inline-block"
		></div>
		<div class="border-primary ${btnLike} rounded-full border"></div>
	`,
})
export class HlmRadioIndicatorComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('relative inline-flex h-4 w-4', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/radio-group/helm/src/lib/hlm-radio.component.ts
```typescript
import { booleanAttribute, Component, computed, input, output } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnRadioChange, BrnRadioComponent } from '@spartan-ng/brain/radio-group';
import { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-radio',
	imports: [BrnRadioComponent],
	template: `
		<brn-radio
			[id]="id()"
			[class]="_computedClass()"
			[value]="value()"
			[required]="required()"
			[disabled]="disabled()"
			[aria-label]="ariaLabel()"
			[aria-labelledby]="ariaLabelledby()"
			[aria-describedby]="ariaDescribedby()"
			(change)="change.emit($event)"
		>
			<ng-content select="[target],[indicator]" indicator />
			<ng-content />
		</brn-radio>
	`,
})
export class HlmRadioComponent<T = unknown> {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'group [&.brn-radio-disabled]:text-muted-foreground flex items-center space-x-2 rtl:space-x-reverse',
			this.userClass(),
		),
	);

	/** Used to set the id on the underlying brn element. */
	public readonly id = input<string | undefined>(undefined);

	/** Used to set the aria-label attribute on the underlying brn element. */
	public readonly ariaLabel = input<string | undefined>(undefined, { alias: 'aria-label' });

	/** Used to set the aria-labelledby attribute on the underlying brn element. */
	public readonly ariaLabelledby = input<string | undefined>(undefined, { alias: 'aria-labelledby' });

	/** Used to set the aria-describedby attribute on the underlying brn element. */
	public readonly ariaDescribedby = input<string | undefined>(undefined, { alias: 'aria-describedby' });

	/**
	 * The value this radio button represents.
	 */
	public readonly value = input.required<T>();

	/** Whether the checkbox is required. */
	public readonly required = input(false, { transform: booleanAttribute });

	/** Whether the checkbox is disabled. */
	public readonly disabled = input(false, { transform: booleanAttribute });

	/**
	 * Event emitted when the checked state of this radio button changes.
	 */
	public readonly change = output<BrnRadioChange<T>>();
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/select.stories.ts
```typescript
import { CommonModule } from '@angular/common';
import {
	ChangeDetectionStrategy,
	Component,
	OnInit,
	ViewEncapsulation,
	computed,
	contentChild,
	input,
	signal,
} from '@angular/core';
import { FormControl, FormGroup, FormsModule, ReactiveFormsModule, Validators } from '@angular/forms';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronDown } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { BrnSelectImports, BrnSelectTriggerDirective } from '@spartan-ng/brain/select';
import { HlmButtonDirective } from '@spartan-ng/ui-button-helm';
import { HlmLabelDirective } from '@spartan-ng/ui-label-helm';
import { type Meta, type StoryObj, argsToTemplate, moduleMetadata } from '@storybook/angular';
import type { ClassValue } from 'clsx';
import { HlmIconDirective } from '../icon/helm/src';
import { HlmSelectImports } from './helm/src';

interface BrnSelectStoryArgs {
	initialValue: string | string[];
	disabled: boolean;
	placeholder: string;
	multiple: boolean;
	dir: 'ltr' | 'rtl';
	selectValueTransformFn: (values: (string | undefined)[]) => string;
}

const meta: Meta<BrnSelectStoryArgs> = {
	title: 'Select',
	args: {
		disabled: false,
		placeholder: 'Select an option',
		multiple: false,
		initialValue: '',
		dir: 'ltr',
	},
	argTypes: {
		dir: { control: 'radio', options: ['ltr', 'rtl'] },
		selectValueTransformFn: { type: 'function', control: false },
	},
	decorators: [
		moduleMetadata({
			imports: [CommonModule, FormsModule, ReactiveFormsModule, BrnSelectImports, HlmSelectImports, HlmLabelDirective],
		}),
	],
};

export default meta;
type Story = StoryObj<BrnSelectStoryArgs>;

export const Default: Story = {
	render: (args) => ({
		props: { ...args },
		template: /* HTML */ `
			<hlm-select class="inline-block" ${argsToTemplate(args, { exclude: ['initialValue', 'selectValueTransformFn'] })}>
				<hlm-select-trigger class="w-56">
					<hlm-select-value />
				</hlm-select-trigger>
				<hlm-select-content>
					<hlm-select-label>Fruits</hlm-select-label>
					<hlm-option value="apple">Apple</hlm-option>
					<hlm-option value="banana">Banana</hlm-option>
					<hlm-option value="blueberry">Blueberry</hlm-option>
					<hlm-option value="grapes">Grapes</hlm-option>
					<hlm-option value="pineapple">Pineapple</hlm-option>
				</hlm-select-content>
			</hlm-select>
		`,
	}),
};

export const ReactiveFormControl: Story = {
	render: (args) => ({
		props: { ...args, fruitGroup: new FormGroup({ fruit: new FormControl(args.initialValue) }) },
		template: /* HTML */ `
			<div class="mb-3">
				<pre>Form Control Value: {{ fruitGroup.controls.fruit.value | json }}</pre>
			</div>
			<form [formGroup]="fruitGroup">
				<brn-select
					class="w-56"
					${argsToTemplate(args, { exclude: ['initialValue', 'selectValueTransformFn'] })}
					formControlName="fruit"
				>
					<hlm-select-trigger>
						<brn-select-value hlm />
					</hlm-select-trigger>
					<hlm-select-content>
						<hlm-select-label>Fruits</hlm-select-label>
						<hlm-option value="apple">Apple</hlm-option>
						<hlm-option value="banana">Banana</hlm-option>
						<hlm-option value="blueberry">Blueberry</hlm-option>
						<hlm-option value="grapes">Grapes</hlm-option>
						<hlm-option value="pineapple">Pineapple</hlm-option>
						<hlm-option>Clear</hlm-option>
					</hlm-select-content>
				</brn-select>
			</form>
		`,
	}),
};

export const DisabledOption: Story = {
	render: (args) => ({
		props: { ...args, fruitGroup: new FormGroup({ fruit: new FormControl(args.initialValue) }) },
		template: /* HTML */ `
			<div class="mb-3">
				<pre>Form Control Value: {{ fruitGroup.controls.fruit.value | json }}</pre>
			</div>
			<form [formGroup]="fruitGroup">
				<brn-select
					class="w-56"
					${argsToTemplate(args, { exclude: ['initialValue', 'selectValueTransformFn'] })}
					formControlName="fruit"
				>
					<hlm-select-trigger>
						<brn-select-value hlm />
					</hlm-select-trigger>
					<hlm-select-content>
						<hlm-select-label>Fruits</hlm-select-label>
						<hlm-option value="apple">Apple</hlm-option>
						<hlm-option data-testid="banana-option" value="banana" disabled>Banana</hlm-option>
						<hlm-option value="blueberry">Blueberry</hlm-option>
						<hlm-option value="grapes">Grapes</hlm-option>
						<hlm-option value="pineapple">Pineapple</hlm-option>
						<hlm-option>Clear</hlm-option>
					</hlm-select-content>
				</brn-select>
			</form>
		`,
	}),
};

export const SelectValueTransformFn: Story = {
	render: (args) => ({
		props: {
			...args,
			fruitGroup: new FormGroup({ fruit: new FormControl(args.initialValue) }),
			selectValueTransformFn: (values: (string | undefined)[]) => {
				return values.join(' | ');
			},
			multiple: true,
		},
		template: /* HTML */ `
			<div class="mb-3" (onClick)="console.log('CLICKED')">
				<pre>Form Control Value: {{ fruitGroup.controls.fruit.value | json }}</pre>
			</div>
			<form [formGroup]="fruitGroup">
				<brn-select
					class="w-56"
					${argsToTemplate(args, { exclude: ['initialValue', 'selectValueTransformFn'] })}
					formControlName="fruit"
				>
					<hlm-select-trigger>
						<brn-select-value hlm [transformFn]="selectValueTransformFn" />
					</hlm-select-trigger>
					<hlm-select-content>
						<hlm-select-label>Fruits</hlm-select-label>
						<hlm-option value="apple">Apple</hlm-option>
						<hlm-option data-testid="banana-option" value="banana" disabled>Banana</hlm-option>
						<hlm-option value="blueberry">Blueberry</hlm-option>
						<hlm-option value="grapes">Grapes</hlm-option>
						<hlm-option value="pineapple">Pineapple</hlm-option>
						<hlm-option>Clear</hlm-option>
					</hlm-select-content>
				</brn-select>
			</form>
		`,
	}),
};

export const ReactiveFormControlWithForAndInitialValue: Story = {
	args: {
		initialValue: 'apple',
	},
	render: (args) => ({
		props: {
			...args,
			fruitGroup: new FormGroup({
				fruit: new FormControl(args.initialValue || null, { validators: Validators.required }),
			}),
			options: [
				{ value: 'apple', label: 'Apple' },
				{ value: 'banana', label: 'Banana' },
				{ value: 'blueberry', label: 'Blueberry' },
				{ value: 'grapes', label: 'Grapes' },
				{ value: 'pineapple', label: 'Pineapple' },
			],
		},
		template: /* HTML */ `
			<div class="mb-3">
				<pre>Form Control Value: {{ fruitGroup.controls.fruit.value | json }}</pre>
			</div>
			<form [formGroup]="fruitGroup">
				<brn-select
					class="w-56"
					${argsToTemplate(args, { exclude: ['initialValue', 'selectValueTransformFn'] })}
					formControlName="fruit"
				>
					<hlm-select-trigger>
						<brn-select-value hlm />
					</hlm-select-trigger>
					<hlm-select-content>
						<hlm-select-label>Fruits</hlm-select-label>
						@for(option of options; track option.value){
						<hlm-option [value]="option.value">{{option.label}}</hlm-option>
						}
					</hlm-select-content>
				</brn-select>
				@if (fruitGroup.controls.fruit.invalid && fruitGroup.controls.fruit.touched){
				<span class="text-destructive">Required</span>
				}
			</form>
		`,
	}),
};

const appleAndBlueberry = new FormGroup({
	fruit: new FormControl(['apple', 'blueberry'], { validators: Validators.required }),
});
export const ReactiveFormControlWithForAndInitialValueAndMultiple: StoryObj<
	BrnSelectStoryArgs & { options: { value: string; label: string }[]; initialFormValue: FormGroup }
> = {
	args: {
		placeholder: 'Select multiple options',
		initialFormValue: appleAndBlueberry,
		options: [
			{ value: 'apple', label: 'Apple' },
			{ value: 'banana', label: 'Banana' },
			{ value: 'blueberry', label: 'Blueberry' },
			{ value: 'grapes', label: 'Grapes' },
			{ value: 'pineapple', label: 'Pineapple' },
		],
		multiple: true,
	},
	argTypes: {
		initialFormValue: {
			options: ['Apple', 'Apple & Blueberry', 'All'],
			mapping: {
				Apple: new FormGroup({
					fruit: new FormControl(['apple'], { validators: Validators.required }),
				}),
				'Apple & Blueberry': new FormGroup({
					fruit: new FormControl(['apple', 'blueberry'], {
						validators: Validators.required,
					}),
				}),
				All: new FormGroup({
					fruit: new FormControl(['apple', 'banana', 'blueberry', 'grapes', 'pineapple'], {
						validators: Validators.required,
					}),
				}),
			},
		},
		options: {
			control: 'inline-check',
			options: ['Apple', 'Banana', 'Blueberry', 'Grapes', 'Pineapple'],
			mapping: {
				Apple: { value: 'apple', label: 'Apple' },
				Banana: { value: 'banana', label: 'Banana' },
				Blueberry: { value: 'blueberry', label: 'Blueberry' },
				Grapes: { value: 'grapes', label: 'Grapes' },
				Pineapple: { value: 'pineapple', label: 'Pineapple' },
			},
		},
	},
	render: (args) => ({
		props: {
			...args,
		},
		template: /* HTML */ `
			<div class="mb-3">
				<pre>Form Control Value: {{ initialFormValue?.controls.fruit.value | json }}</pre>
			</div>
			<form [formGroup]="initialFormValue">
				<brn-select
					class="w-56"
					${argsToTemplate(args, { exclude: ['initialValue', 'options'] })}
					formControlName="fruit"
				>
					<hlm-select-trigger>
						<brn-select-value hlm />
					</hlm-select-trigger>
					<hlm-select-content>
						<hlm-select-label>Fruits</hlm-select-label>
						@for(option of options; track option.value){
						<hlm-option [value]="option.value">{{option.label}}</hlm-option>
						}
					</hlm-select-content>
				</brn-select>
				@if (fruitGroup?.controls.fruit.invalid && fruitGroup.controls.fruit.touched){
				<span class="text-destructive">Required</span>
				}
			</form>
		`,
	}),
};

export const ReactiveFormControlWithValidation: Story = {
	render: (args) => ({
		props: {
			...args,
			fruitGroup: new FormGroup({
				fruit: new FormControl(args.initialValue || null, { validators: Validators.required }),
			}),
		},
		template: /* HTML */ `
			<div class="mb-3">
				<pre>Form Control Value: {{ fruitGroup.controls.fruit.valueChanges | async | json }}</pre>
			</div>
			<form [formGroup]="fruitGroup">
				<brn-select
					class="w-56"
					formControlName="fruit"
					${argsToTemplate(args, { exclude: ['initialValue', 'selectValueTransformFn'] })}
				>
					<hlm-select-trigger>
						<brn-select-value hlm />
					</hlm-select-trigger>
					<hlm-select-content>
						<hlm-select-label>Fruits</hlm-select-label>
						<hlm-option value="apple">Apple</hlm-option>
						<hlm-option value="banana">Banana</hlm-option>
						<hlm-option value="blueberry">Blueberry</hlm-option>
						<hlm-option value="grapes">Grapes</hlm-option>
						<hlm-option value="pineapple">Pineapple</hlm-option>
						<hlm-option>Clear</hlm-option>
					</hlm-select-content>
				</brn-select>
				@if (fruitGroup.controls.fruit.invalid && fruitGroup.controls.fruit.touched){
				<span class="text-destructive">Required</span>
				}
			</form>
		`,
	}),
};

export const ReactiveFormControlWithValidationWithLabel: Story = {
	render: (args) => ({
		props: {
			...args,
			fruitGroup: new FormGroup({
				fruit: new FormControl(args.initialValue || null, { validators: Validators.required }),
			}),
		},
		template: /* HTML */ `
			<div class="mb-3">
				<pre>Form Control Value: {{ fruitGroup.controls.fruit.valueChanges | async | json }}</pre>
			</div>
			<form [formGroup]="fruitGroup">
				<hlm-select
					class="w-56"
					formControlName="fruit"
					${argsToTemplate(args, { exclude: ['initialValue', 'selectValueTransformFn'] })}
				>
					<label hlmLabel>Select a Fruit</label>
					<hlm-select-trigger>
						<brn-select-value hlm />
					</hlm-select-trigger>
					<hlm-select-content>
						<hlm-select-label>Fruits</hlm-select-label>
						<hlm-option value="apple">Apple</hlm-option>
						<hlm-option value="banana">Banana</hlm-option>
						<hlm-option value="blueberry">Blueberry</hlm-option>
						<hlm-option value="grapes">Grapes</hlm-option>
						<hlm-option value="pineapple">Pineapple</hlm-option>
						<hlm-option>Clear</hlm-option>
					</hlm-select-content>
				</hlm-select>
				@if (fruitGroup.controls.fruit.invalid && fruitGroup.controls.fruit.touched){
				<span class="text-destructive">Required</span>
				}
			</form>
		`,
	}),
};

export const NgModelFormControl: Story = {
	render: (args) => ({
		props: {
			...args,
			fruit: signal(args.initialValue),
		},
		template: /* HTML */ `
			<form ngForm>
				<div class="mb-3">
					<pre>Form Control Value: {{fruit() | json }}</pre>
				</div>
				<hlm-select
					class="w-56"
					${argsToTemplate(args, { exclude: ['initialValue', 'selectValueTransformFn'] })}
					[(ngModel)]="fruit"
					name="fruit"
				>
					<label hlmLabel>Select a Fruit</label>
					<hlm-select-trigger>
						<brn-select-value hlm />
					</hlm-select-trigger>
					<hlm-select-content>
						<hlm-select-label>Fruits</hlm-select-label>
						<hlm-option value="apple">Apple</hlm-option>
						<hlm-option value="banana">Banana</hlm-option>
						<hlm-option value="blueberry">Blueberry</hlm-option>
						<hlm-option value="grapes">Grapes</hlm-option>
						<hlm-option value="pineapple">Pineapple</hlm-option>
					</hlm-select-content>
				</hlm-select>
			</form>
		`,
	}),
};

export const NgModelFormControlInitialValue: Story = {
	args: {
		disabled: false,
		placeholder: 'Select an option',
		multiple: false,
		initialValue: 'apple',
		dir: 'ltr',
	},

	render: (args) => ({
		props: {
			...args,
			fruit: signal(args.initialValue),
		},

		template: `
            <form ngForm>
                <div class="mb-3">
                    <pre>Form Control Value: {{fruit() | json }}</pre>
                </div>
                <hlm-select
                    class="w-56"
                    ${argsToTemplate(args, {
											exclude: ['initialValue', 'selectValueTransformFn'],
										})}
                    [(ngModel)]="fruit"
                    name="fruit"
                >
                    <label hlmLabel>Select a Fruit</label>
                    <hlm-select-trigger>
                        <brn-select-value hlm />
                    </hlm-select-trigger>
                    <hlm-select-content>
                        <hlm-select-label>Fruits</hlm-select-label>
                        <hlm-option value="apple">Apple</hlm-option>
                        <hlm-option value="banana">Banana</hlm-option>
                        <hlm-option value="blueberry">Blueberry</hlm-option>
                        <hlm-option value="grapes">Grapes</hlm-option>
                        <hlm-option value="pineapple">Pineapple</hlm-option>
                    </hlm-select-content>
                </hlm-select>
            </form>
        `,
	}),
};

export const SelectWithLabel: Story = {
	render: (args) => ({
		props: { ...args, fruitGroup: new FormGroup({ fruit: new FormControl() }) },
		template: /* HTML */ `
			<form [formGroup]="fruitGroup">
				<hlm-select
					formControlName="fruit"
					${argsToTemplate(args, { exclude: ['initialValue', 'selectValueTransformFn'] })}
				>
					<label hlmLabel>Select a Fruit</label>
					<hlm-select-trigger class="w-56">
						<brn-select-value />
					</hlm-select-trigger>
					<hlm-select-content class="w-56">
						<hlm-select-label>Fruits</hlm-select-label>
						<hlm-option value="apple">Apple</hlm-option>
						<hlm-option value="banana">Banana</hlm-option>
						<hlm-option value="blueberry">Blueberry</hlm-option>
						<hlm-option value="grapes">Grapes</hlm-option>
						<hlm-option value="pineapple">Pineapple</hlm-option>
					</hlm-select-content>
				</hlm-select>
			</form>
		`,
	}),
};

export const Scrollable: Story = {
	render: (args) => ({
		props: { ...args, myform: new FormGroup({ timezone: new FormControl() }) },
		template: /* HTML */ `
			<form [formGroup]="myform">
				<hlm-select
					formControlName="timezone"
					${argsToTemplate(args, { exclude: ['initialValue', 'selectValueTransformFn'] })}
				>
					<hlm-select-trigger class="w-[280px]">
						<hlm-select-value />
					</hlm-select-trigger>
					<hlm-select-content class="min-w-content max-h-96">
						<hlm-select-scroll-up />

						<hlm-select-group>
							<hlm-select-label>North America</hlm-select-label>
							<hlm-option value="est">Eastern Standard Time (EST)</hlm-option>
							<hlm-option value="cst">Central Standard Time (CST)</hlm-option>
							<hlm-option value="mst">Mountain Standard Time (MST)</hlm-option>
							<hlm-option value="pst">Pacific Standard Time (PST)</hlm-option>
							<hlm-option value="akst">Alaska Standard Time (AKST)</hlm-option>
							<hlm-option value="hst">Hawaii Standard Time (HST)</hlm-option>
						</hlm-select-group>

						<hlm-select-group>
							<hlm-select-label>Europe & Africa</hlm-select-label>
							<hlm-option value="gmt">Greenwich Mean Time (GMT)</hlm-option>
							<hlm-option value="cet">Central European Time (CET)</hlm-option>
							<hlm-option value="eet">Eastern European Time (EET)</hlm-option>
							<hlm-option value="west">Western European Summer Time (WEST)</hlm-option>
							<hlm-option value="cat">Central Africa Time (CAT)</hlm-option>
							<hlm-option value="eat">East Africa Time (EAT)</hlm-option>
						</hlm-select-group>

						<hlm-select-group>
							<hlm-select-label>Asia</hlm-select-label>
							<hlm-option value="msk">Moscow Time (MSK)</hlm-option>
							<hlm-option value="ist">India Standard Time (IST)</hlm-option>
							<hlm-option value="cst_china">China Standard Time (CST)</hlm-option>
							<hlm-option value="jst">Japan Standard Time (JST)</hlm-option>
							<hlm-option value="kst">Korea Standard Time (KST)</hlm-option>
							<hlm-option value="ist_indonesia">Indonesia Central Standard Time (WITA)</hlm-option>
						</hlm-select-group>

						<hlm-select-group>
							<hlm-select-label>Australia & Pacific</hlm-select-label>
							<hlm-option value="awst">Australian Western Standard Time (AWST)</hlm-option>
							<hlm-option value="acst">Australian Central Standard Time (ACST)</hlm-option>
							<hlm-option value="aest">Australian Eastern Standard Time (AEST)</hlm-option>
							<hlm-option value="nzst">New Zealand Standard Time (NZST)</hlm-option>
							<hlm-option value="fjt">Fiji Time (FJT)</hlm-option>
						</hlm-select-group>

						<hlm-select-group>
							<hlm-select-label>South America</hlm-select-label>
							<hlm-option value="art">Argentina Time (ART)</hlm-option>
							<hlm-option value="bot">Bolivia Time (BOT)</hlm-option>
							<hlm-option value="brt">Brasilia Time (BRT)</hlm-option>
							<hlm-option value="clt">Chile Standard Time (CLT)</hlm-option>
						</hlm-select-group>

						<hlm-select-scroll-down />
					</hlm-select-content>
				</hlm-select>
			</form>
		`,
	}),
};

export const ScrollableWithStickyLabels: Story = {
	render: (args) => ({
		props: { ...args, myform: new FormGroup({ timezone: new FormControl() }) },
		template: /* HTML */ `
			<form [formGroup]="myform">
				<hlm-select
					formControlName="timezone"
					${argsToTemplate(args, { exclude: ['initialValue', 'selectValueTransformFn'] })}
				>
					<hlm-select-trigger class="w-[280px]">
						<hlm-select-value />
					</hlm-select-trigger>
					<hlm-select-content class="max-h-96" [stickyLabels]="true">
						<hlm-select-scroll-up />

						<hlm-select-group>
							<hlm-select-label>North America</hlm-select-label>
							<hlm-option value="est">Eastern Standard Time (EST)</hlm-option>
							<hlm-option value="cst">Central Standard Time (CST)</hlm-option>
							<hlm-option value="mst">Mountain Standard Time (MST)</hlm-option>
							<hlm-option value="pst">Pacific Standard Time (PST)</hlm-option>
							<hlm-option value="akst">Alaska Standard Time (AKST)</hlm-option>
							<hlm-option value="hst">Hawaii Standard Time (HST)</hlm-option>
						</hlm-select-group>

						<hlm-select-group>
							<hlm-select-label>Europe & Africa</hlm-select-label>
							<hlm-option value="gmt">Greenwich Mean Time (GMT)</hlm-option>
							<hlm-option value="cet">Central European Time (CET)</hlm-option>
							<hlm-option value="eet">Eastern European Time (EET)</hlm-option>
							<hlm-option value="west">Western European Summer Time (WEST)</hlm-option>
							<hlm-option value="cat">Central Africa Time (CAT)</hlm-option>
							<hlm-option value="eat">East Africa Time (EAT)</hlm-option>
						</hlm-select-group>

						<hlm-select-group>
							<hlm-select-label>Asia</hlm-select-label>
							<hlm-option value="msk">Moscow Time (MSK)</hlm-option>
							<hlm-option value="ist">India Standard Time (IST)</hlm-option>
							<hlm-option value="cst_china">China Standard Time (CST)</hlm-option>
							<hlm-option value="jst">Japan Standard Time (JST)</hlm-option>
							<hlm-option value="kst">Korea Standard Time (KST)</hlm-option>
							<hlm-option value="ist_indonesia">Indonesia Central Standard Time (WITA)</hlm-option>
						</hlm-select-group>

						<hlm-select-group>
							<hlm-select-label>Australia & Pacific</hlm-select-label>
							<hlm-option value="awst">Australian Western Standard Time (AWST)</hlm-option>
							<hlm-option value="acst">Australian Central Standard Time (ACST)</hlm-option>
							<hlm-option value="aest">Australian Eastern Standard Time (AEST)</hlm-option>
							<hlm-option value="nzst">New Zealand Standard Time (NZST)</hlm-option>
							<hlm-option value="fjt">Fiji Time (FJT)</hlm-option>
						</hlm-select-group>

						<hlm-select-group>
							<hlm-select-label>South America</hlm-select-label>
							<hlm-option value="art">Argentina Time (ART)</hlm-option>
							<hlm-option value="bot">Bolivia Time (BOT)</hlm-option>
							<hlm-option value="brt">Brasilia Time (BRT)</hlm-option>
							<hlm-option value="clt">Chile Standard Time (CLT)</hlm-option>
						</hlm-select-group>

						<hlm-select-scroll-down />
					</hlm-select-content>
				</hlm-select>
			</form>
		`,
	}),
};

export const CustomTrigger: Story = {
	render: (args) => ({
		props: { ...args },
		moduleMetadata: {
			imports: [CustomSelectTriggerComponent],
		},
		template: /* HTML */ `
			<hlm-select class="inline-block" ${argsToTemplate(args, { exclude: ['initialValue', 'selectValueTransformFn'] })}>
				<custom-select-trigger ngProjectAs="[brnSelectTrigger]" class="w-56">
					<hlm-select-value />
				</custom-select-trigger>
				<hlm-select-content>
					<hlm-select-label>Fruits</hlm-select-label>
					<hlm-option value="apple">Apple</hlm-option>
					<hlm-option value="banana">Banana</hlm-option>
					<hlm-option value="blueberry">Blueberry</hlm-option>
					<hlm-option value="grapes">Grapes</hlm-option>
					<hlm-option value="pineapple">Pineapple</hlm-option>
				</hlm-select-content>
			</hlm-select>
		`,
	}),
};

@Component({
	selector: 'custom-select-trigger',
	standalone: true,
	imports: [BrnSelectTriggerDirective, NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideChevronDown })],
	template: `
		<button [class]="_computedClass()" #button brnSelectTrigger type="button">
			<ng-content />
			@if (icon()) {
				<ng-content select="ng-icon" />
			} @else {
				<ng-icon hlm size="sm" class="ml-2 flex-none" name="lucideChevronDown" />
			}
		</button>
	`,
})
export class CustomSelectTriggerComponent {
	protected readonly icon = contentChild(HlmIconDirective);

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'!bg-sky-500 flex h-10 items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 w-[180px]',
			this.userClass(),
		),
	);
}

export const WithLabelAndForm: Story = {
	render: () => ({
		moduleMetadata: {
			imports: [LabelAndFormComponent],
		},
		template: /* HTML */ '<label-and-form-component/>',
	}),
};
@Component({
	selector: 'label-and-form-component',
	standalone: true,
	encapsulation: ViewEncapsulation.None,
	changeDetection: ChangeDetectionStrategy.OnPush,
	imports: [
		FormsModule,
		ReactiveFormsModule,
		BrnSelectImports,
		HlmSelectImports,
		HlmLabelDirective,
		HlmButtonDirective,
	],
	providers: [],
	host: {
		class: '',
	},
	template: `
		<form class="space-y-5" (ngSubmit)="handleSubmit()">
			<label hlmLabel>
				Select a Fruit*
				<hlm-select class="w-56" [(ngModel)]="fruit" name="fruit" required>
					<hlm-select-trigger>
						<brn-select-value hlm />
					</hlm-select-trigger>
					<hlm-select-content>
						<hlm-select-label>Fruits</hlm-select-label>
						<hlm-option [value]="undefined">No fruit</hlm-option>
						<hlm-option value="apple">Apple</hlm-option>
						<hlm-option value="banana">Banana</hlm-option>
						<hlm-option value="blueberry">Blueberry</hlm-option>
						<hlm-option value="grapes">Grapes</hlm-option>
						<hlm-option value="pineapple">Pineapple</hlm-option>
					</hlm-select-content>
				</hlm-select>
			</label>
			<button hlmBtn>Submit</button>
		</form>
	`,
})
class LabelAndFormComponent {
	public fruit = signal<string | undefined>(undefined);

	public handleSubmit(): void {
		console.log(this.fruit());
	}
}

export const DynamicOptionsMultiSelect: Story = {
	render: () => ({
		moduleMetadata: {
			imports: [DynamicOptionsMultiSelectComponent],
		},
		template: /* HTML */ '<dynamic-options-multi-select-component/>',
	}),
};
@Component({
	selector: 'dynamic-options-multi-select-component',
	standalone: true,
	encapsulation: ViewEncapsulation.None,
	changeDetection: ChangeDetectionStrategy.OnPush,
	imports: [
		FormsModule,
		ReactiveFormsModule,
		BrnSelectImports,
		HlmSelectImports,
		HlmLabelDirective,
		HlmButtonDirective,
	],
	providers: [],
	host: {
		class: '',
	},
	template: `
		<form class="space-y-5">
			<div class="mb-3">
				<pre>Form Control Value: {{ fruit.value | json }}</pre>
			</div>
			<label hlmLabel>
				Select a Fruit*
				<hlm-select class="w-56" [formControl]="fruit" required [multiple]="true" placeholder="Select an option">
					<hlm-select-trigger>
						<hlm-select-value />
					</hlm-select-trigger>
					<hlm-select-content>
						<hlm-select-label>Fruits</hlm-select-label>
						@for (option of options(); track option.value) {
							<hlm-option [value]="option.value">{{ option.label }}</hlm-option>
						}
					</hlm-select-content>
				</hlm-select>
			</label>
		</form>
		<button hlmBtn class="mt-2" (click)="updateOptions()">Update Options</button>

		<button hlmBtn class="mt-2" (click)="updateDiffOptions()">Update Diff Options</button>

		<button hlmBtn class="mt-2" (click)="updatePartialOptions()">Update Partial Options</button>
	`,
})
class DynamicOptionsMultiSelectComponent implements OnInit {
	// Checking if an issue with having options as a signal
	public options = signal<{ value: number; label: string }[]>([]);
	fruit = new FormControl([1, 5]);

	ngOnInit(): void {
		this.options.set([
			{ label: 'Apple', value: 1 },
			{ label: 'Banana', value: 2 },
			{ label: 'Blueberry', value: 3 },
			{ label: 'Grapes', value: 4 },
			{ label: 'Pineapple', value: 5 },
		]);
	}

	public updateOptions() {
		// Reset same options
		this.options.set([
			{ label: 'Apple', value: 1 },
			{ label: 'Banana', value: 2 },
			{ label: 'Blueberry', value: 3 },
			{ label: 'Grapes', value: 4 },
			{ label: 'Pineapple', value: 5 },
		]);
	}

	public updateDiffOptions() {
		// Reset with different option values
		this.options.set([
			{ label: 'Apple', value: 6 },
			{ label: 'Banana', value: 7 },
			{ label: 'Blueberry', value: 8 },
			{ label: 'Grapes', value: 9 },
			{ label: 'Pineapple', value: 10 },
		]);
	}

	public updatePartialOptions() {
		// Reset with different option values
		this.options.set([
			{ label: 'Apple', value: 1 },
			{ label: 'Banana', value: 2 },
			{ label: 'Blueberry', value: 8 },
			{ label: 'Grapes', value: 9 },
			{ label: 'Pineapple', value: 10 },
		]);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/README.md
```
# ui-select-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-select-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-select-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	coverageDirectory: '../../../../coverage/libs/ui/select/helm',
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/select/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/package.json
```json
{
	"name": "@spartan-ng/ui-select-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@ng-icons/core": ">=29.0.0",
		"@ng-icons/lucide": ">=29.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
		"class-variance-authority": "^0.7.0",
		"clsx": "^2.1.1"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/project.json
```json
{
	"name": "ui-select-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/select/helm/src",
	"prefix": "lib",
	"projectType": "library",
	"tags": [],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/select/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/select/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/select/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/select/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmSelectContentDirective } from './lib/hlm-select-content.directive';
import { HlmSelectGroupDirective } from './lib/hlm-select-group.directive';
import { HlmSelectLabelDirective } from './lib/hlm-select-label.directive';
import { HlmSelectOptionComponent } from './lib/hlm-select-option.component';
import { HlmSelectScrollDownComponent } from './lib/hlm-select-scroll-down.component';
import { HlmSelectScrollUpComponent } from './lib/hlm-select-scroll-up.component';
import { HlmSelectTriggerComponent } from './lib/hlm-select-trigger.component';
import { HlmSelectValueDirective } from './lib/hlm-select-value.directive';
import { HlmSelectDirective } from './lib/hlm-select.directive';

export * from './lib/hlm-select-content.directive';
export * from './lib/hlm-select-group.directive';
export * from './lib/hlm-select-label.directive';
export * from './lib/hlm-select-option.component';
export * from './lib/hlm-select-scroll-down.component';
export * from './lib/hlm-select-scroll-up.component';
export * from './lib/hlm-select-trigger.component';
export * from './lib/hlm-select-value.directive';
export * from './lib/hlm-select.directive';

export const HlmSelectImports = [
	HlmSelectContentDirective,
	HlmSelectTriggerComponent,
	HlmSelectOptionComponent,
	HlmSelectValueDirective,
	HlmSelectDirective,
	HlmSelectScrollUpComponent,
	HlmSelectScrollDownComponent,
	HlmSelectLabelDirective,
	HlmSelectGroupDirective,
] as const;

@NgModule({
	imports: [...HlmSelectImports],
	exports: [...HlmSelectImports],
})
export class HlmSelectModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/src/lib/hlm-select-content.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm, injectExposedSideProvider, injectExposesStateProvider } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmSelectContent], hlm-select-content',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		'[attr.data-state]': '_stateProvider?.state() ?? "open"',
		'[attr.data-side]': '_sideProvider?.side() ?? "bottom"',
	},
})
export class HlmSelectContentDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly stickyLabels = input<boolean>(false);
	protected readonly _stateProvider = injectExposesStateProvider({ optional: true });
	protected readonly _sideProvider = injectExposedSideProvider({ optional: true });

	protected readonly _computedClass = computed(() =>
		hlm(
			'w-full relative z-50 min-w-[8rem] overflow-hidden rounded-md border border-border bg-popover text-popover-foreground shadow-md p-1 data-[side=bottom]:top-[2px] data-[side=top]:bottom-[2px] data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/src/lib/hlm-select-group.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnSelectGroupDirective } from '@spartan-ng/brain/select';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmSelectGroup], hlm-select-group',
	hostDirectives: [BrnSelectGroupDirective],
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSelectGroupDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm(this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/src/lib/hlm-select-label.directive.ts
```typescript
import { Directive, computed, inject, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnSelectLabelDirective } from '@spartan-ng/brain/select';
import type { ClassValue } from 'clsx';
import { HlmSelectContentDirective } from './hlm-select-content.directive';

@Directive({
	selector: '[hlmSelectLabel], hlm-select-label',
	hostDirectives: [BrnSelectLabelDirective],
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSelectLabelDirective {
	private readonly _selectContent = inject(HlmSelectContentDirective);
	private readonly _stickyLabels = computed(() => this._selectContent.stickyLabels());
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'pl-8 pr-2 text-sm font-semibold rtl:pl-2 rtl:pr-8',
			this._stickyLabels() ? 'sticky top-0 bg-popover block z-[2]' : '',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/src/lib/hlm-select-option.component.ts
```typescript
import { ChangeDetectionStrategy, Component, computed, inject, input } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideCheck } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { BrnSelectOptionDirective } from '@spartan-ng/brain/select';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-option',
	changeDetection: ChangeDetectionStrategy.OnPush,
	hostDirectives: [{ directive: BrnSelectOptionDirective, inputs: ['disabled', 'value'] }],
	providers: [provideIcons({ lucideCheck })],
	host: {
		'[class]': '_computedClass()',
	},
	template: `
		<ng-content />
		<span
			[attr.dir]="_brnSelectOption.dir()"
			class="absolute left-2 flex h-3.5 w-3.5 items-center justify-center rtl:left-auto rtl:right-2"
			[attr.data-state]="this._brnSelectOption.checkedState()"
		>
			@if (this._brnSelectOption.selected()) {
				<ng-icon hlm size="sm" aria-hidden="true" name="lucideCheck" />
			}
		</span>
	`,
	imports: [NgIcon, HlmIconDirective],
})
export class HlmSelectOptionComponent {
	protected readonly _brnSelectOption = inject(BrnSelectOptionDirective, { host: true });
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 rtl:flex-reverse rtl:pr-8 rtl:pl-2 text-sm outline-none data-[active]:bg-accent data-[active]:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/src/lib/hlm-select-scroll-down.component.ts
```typescript
import { Component } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronDown } from '@ng-icons/lucide';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';

@Component({
	selector: 'hlm-select-scroll-down',
	imports: [NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideChevronDown })],
	host: {
		class: 'flex cursor-default items-center justify-center py-1',
	},
	template: `
		<ng-icon hlm size="sm" class="ml-2" name="lucideChevronDown" />
	`,
})
export class HlmSelectScrollDownComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/src/lib/hlm-select-scroll-up.component.ts
```typescript
import { Component } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronUp } from '@ng-icons/lucide';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';

@Component({
	selector: 'hlm-select-scroll-up',
	imports: [NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideChevronUp })],
	host: {
		class: 'flex cursor-default items-center justify-center py-1',
	},
	template: `
		<ng-icon hlm size="sm" class="ml-2" name="lucideChevronUp" />
	`,
})
export class HlmSelectScrollUpComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/src/lib/hlm-select-trigger.component.ts
```typescript
import { Component, computed, contentChild, inject, input } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronDown } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { BrnSelectComponent, BrnSelectTriggerDirective } from '@spartan-ng/brain/select';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const selectTriggerVariants = cva(
	'flex items-center justify-between rounded-md border border-input bg-background text-sm ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
	{
		variants: {
			size: {
				default: 'h-10 py-2 px-4',
				sm: 'h-9 px-3',
				lg: 'h-11 px-8',
			},
			error: {
				auto: '[&.ng-invalid.ng-touched]:text-destructive [&.ng-invalid.ng-touched]:border-destructive [&.ng-invalid.ng-touched]:focus-visible:ring-destructive',
				true: 'text-destructive border-destructive focus-visible:ring-destructive',
			},
		},
		defaultVariants: {
			size: 'default',
			error: 'auto',
		},
	},
);
type SelectTriggerVariants = VariantProps<typeof selectTriggerVariants>;

@Component({
	selector: 'hlm-select-trigger',
	imports: [BrnSelectTriggerDirective, NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideChevronDown })],
	template: `
		<button [class]="_computedClass()" #button hlmInput brnSelectTrigger type="button">
			<ng-content />
			@if (icon()) {
				<ng-content select="ng-icon" />
			} @else {
				<ng-icon hlm size="sm" class="ml-2 flex-none" name="lucideChevronDown" />
			}
		</button>
	`,
})
export class HlmSelectTriggerComponent {
	protected readonly icon = contentChild(HlmIconDirective);

	protected readonly brnSelect = inject(BrnSelectComponent, { optional: true });

	public readonly _size = input<SelectTriggerVariants['size']>('default');
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected _computedClass = computed(() =>
		hlm(selectTriggerVariants({ size: this._size(), error: this.brnSelect?.errorState() }), this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/src/lib/hlm-select-value.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: 'hlm-select-value,[hlmSelectValue], brn-select-value[hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSelectValueDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'!inline-block ltr:text-left rtl:text-right border-border w-[calc(100%)]] min-w-0 pointer-events-none truncate data-[placeholder]:text-muted-foreground',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/select/helm/src/lib/hlm-select.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: 'hlm-select, brn-select [hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSelectDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm('space-y-2', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/breadcrumb/breadcrumb.stories.ts
```typescript
import { RouterTestingModule } from '@angular/router/testing';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideSlash } from '@ng-icons/lucide';
import { HlmBreadCrumbImports, HlmBreadcrumbDirective } from '@spartan-ng/ui-breadcrumb-helm';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { Meta, StoryObj } from '@storybook/angular';
import { moduleMetadata } from '@storybook/angular';

const meta: Meta<HlmBreadcrumbDirective> = {
	title: 'Breadcrumb',
	component: HlmBreadcrumbDirective,
	tags: ['autodocs'],
	decorators: [
		moduleMetadata({
			imports: [HlmBreadCrumbImports, NgIcon, HlmIconDirective, RouterTestingModule],
			providers: [provideIcons({ lucideSlash })],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmBreadcrumbDirective>;

export const Default: Story = {
	render: () => ({
		template: /* HTML */ `
			<nav hlmBreadcrumb>
				<ol hlmBreadcrumbList>
					<li hlmBreadcrumbItem>
						<a hlmBreadcrumbLink href="/home">Home</a>
					</li>
					<li hlmBreadcrumbSeparator></li>
					<li hlmBreadcrumbItem>
						<hlm-breadcrumb-ellipsis />
					</li>
					<li hlmBreadcrumbSeparator></li>
					<li hlmBreadcrumbItem>
						<a hlmBreadcrumbLink hlmL href="/components">Components</a>
					</li>
					<li hlmBreadcrumbSeparator></li>
					<li hlmBreadcrumbItem>
						<span hlmBreadcrumbPage>Breadcrumb</span>
					</li>
				</ol>
			</nav>
		`,
	}),
};

export const Custom: Story = {
	render: () => ({
		template: /* HTML */ `
			<nav hlmBreadcrumb>
				<ol hlmBreadcrumbList>
					<li hlmBreadcrumbItem>
						<a hlmBreadcrumbLink href="/home">Home</a>
					</li>
					<li hlmBreadcrumbSeparator>
						<ng-icon hlm size="sm" name="lucideSlash" />
					</li>
					<li hlmBreadcrumbItem>
						<a hlmBreadcrumbLink href="/components">Components</a>
					</li>
					<li hlmBreadcrumbSeparator>
						<ng-icon hlm size="sm" name="lucideSlash" />
					</li>
					<li hlmBreadcrumbItem>
						<span hlmBreadcrumbPage>Breadcrumb</span>
					</li>
				</ol>
			</nav>
		`,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/breadcrumb/helm/README.md
```
# ui-breadcrumb-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-breadcrumb-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/breadcrumb/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/breadcrumb/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-breadcrumb-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/breadcrumb/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/breadcrumb/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/breadcrumb/helm/package.json
```json
{
	"name": "@spartan-ng/ui-breadcrumb-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@angular/router": ">=19.0.0",
		"@ng-icons/core": ">=29.0.0",
		"@ng-icons/lucide": ">=29.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/breadcrumb/helm/project.json
```json
{
	"name": "ui-breadcrumb-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/breadcrumb/helm/src",
	"prefix": "hlm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/breadcrumb/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/breadcrumb/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/breadcrumb/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/breadcrumb/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-breadcrumb-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/breadcrumb/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/breadcrumb/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/breadcrumb/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/breadcrumb/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/breadcrumb/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmBreadcrumbEllipsisComponent } from './lib/breadcrumb-ellipsis.component';
import { HlmBreadcrumbItemDirective } from './lib/breadcrumb-item.directive';
import { HlmBreadcrumbLinkDirective } from './lib/breadcrumb-link.directive';
import { HlmBreadcrumbListDirective } from './lib/breadcrumb-list.directive';
import { HlmBreadcrumbPageDirective } from './lib/breadcrumb-page.directive';
import { HlmBreadcrumbSeparatorComponent } from './lib/breadcrumb-separator.component';
import { HlmBreadcrumbDirective } from './lib/breadcrumb.directive';

export * from './lib/breadcrumb-ellipsis.component';
export * from './lib/breadcrumb-item.directive';
export * from './lib/breadcrumb-link.directive';
export * from './lib/breadcrumb-list.directive';
export * from './lib/breadcrumb-page.directive';
export * from './lib/breadcrumb-separator.component';
export * from './lib/breadcrumb.directive';

export const HlmBreadCrumbImports = [
	HlmBreadcrumbDirective,
	HlmBreadcrumbEllipsisComponent,
	HlmBreadcrumbSeparatorComponent,
	HlmBreadcrumbItemDirective,
	HlmBreadcrumbLinkDirective,
	HlmBreadcrumbPageDirective,
	HlmBreadcrumbListDirective,
] as const;

@NgModule({
	imports: [...HlmBreadCrumbImports],
	exports: [...HlmBreadCrumbImports],
})
export class HlmBreadCrumbModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/breadcrumb/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/breadcrumb/helm/src/lib/breadcrumb-ellipsis.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideEllipsis } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-breadcrumb-ellipsis',
	imports: [NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideEllipsis })],
	template: `
		<span role="presentation" aria-hidden="true" [class]="_computedClass()">
			<ng-icon hlm size="sm" name="lucideEllipsis" />
			<span class="sr-only">More</span>
		</span>
	`,
})
export class HlmBreadcrumbEllipsisComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() => hlm('flex h-9 w-9 items-center justify-center', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/breadcrumb/helm/src/lib/breadcrumb-item.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmBreadcrumbItem]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmBreadcrumbItemDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() => hlm('inline-flex items-center gap-1.5', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/breadcrumb/helm/src/lib/breadcrumb-link.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { RouterLink } from '@angular/router';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmBreadcrumbLink]',
	standalone: true,
	hostDirectives: [
		{
			directive: RouterLink,
			inputs: [
				'target',
				'queryParams',
				'fragment',
				'queryParamsHandling',
				'state',
				'info',
				'relativeTo',
				'preserveFragment',
				'skipLocationChange',
				'replaceUrl',
				'routerLink: link',
			],
		},
	],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmBreadcrumbLinkDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly link = input<RouterLink['routerLink']>();

	protected readonly _computedClass = computed(() => hlm('transition-colors hover:text-foreground', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/breadcrumb/helm/src/lib/breadcrumb-list.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmBreadcrumbList]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmBreadcrumbListDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm('flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/breadcrumb/helm/src/lib/breadcrumb-page.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmBreadcrumbPage]',
	standalone: true,
	host: {
		role: 'link',
		'[class]': '_computedClass()',
		'[attr.aria-disabled]': 'disabled',
		'[attr.aria-current]': 'page',
	},
})
export class HlmBreadcrumbPageDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() => hlm('font-normal text-foreground', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/breadcrumb/helm/src/lib/breadcrumb-separator.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronRight } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	// eslint-disable-next-line @angular-eslint/component-selector
	selector: '[hlmBreadcrumbSeparator]',
	imports: [NgIcon],
	providers: [provideIcons({ lucideChevronRight })],
	host: {
		role: 'presentation',
		'[class]': '_computedClass()',
		'[attr.aria-hidden]': 'true',
	},
	template: `
		<ng-content>
			<ng-icon name="lucideChevronRight" />
		</ng-content>
	`,
})
export class HlmBreadcrumbSeparatorComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm('[&>ng-icon]:text-[14px] [&>ng-icon]:flex!', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/breadcrumb/helm/src/lib/breadcrumb.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmBreadcrumb]',
	standalone: true,
	host: {
		role: 'navigation',
		'[class]': '_computedClass()',
		'[attr.aria-label]': 'ariaLabel()',
	},
})
export class HlmBreadcrumbDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly ariaLabel = input<string>('breadcrumb', { alias: 'aria-label' });

	protected readonly _computedClass = computed(() => hlm(this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/icon/icon.stories.ts
```typescript
import { Component, signal } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { NgIcon, provideIcons } from '@ng-icons/core';
import * as lucide from '@ng-icons/lucide';
import { lucideHouse } from '@ng-icons/lucide';
import { type Meta, type StoryObj, argsToTemplate, moduleMetadata } from '@storybook/angular';
import { HlmIconDirective, type IconSize } from './helm/src';

const meta: Meta<HlmIconDirective> = {
	title: 'Icon',
	component: HlmIconDirective,
	tags: ['autodocs'],
	decorators: [
		moduleMetadata({
			imports: [NgIcon, HlmIconDirective],
			providers: [provideIcons(lucide)],
		}),
	],
};

export default meta;
type Story = StoryObj<HlmIconDirective & NgIcon>;

export const Default: Story = {
	args: {
		name: 'lucideCheck',
		size: 'sm',
		color: 'red',
		strokeWidth: 1,
	},
	argTypes: {
		size: { control: 'select', options: ['xs', 'sm', 'base', 'lg', 'xl', 'none', '2rem', '25px', '10'] },
		name: { control: 'select', options: Object.keys(lucide) },
		color: { control: 'color' },
	},
	render: ({ ...args }) => ({
		props: args,
		template: `<ng-icon hlm ${argsToTemplate(args)} />`,
	}),
};

export const Tailwind: Story = {
	args: {
		name: 'lucideCheck',
	},
	argTypes: {
		name: { control: 'select', options: Object.keys(lucide) },
	},
	render: ({ ...args }) => ({
		props: args,
		template: `<ng-icon hlm ${argsToTemplate(args)} class="text-red-600 text-5xl" />`,
	}),
};

@Component({
	selector: 'icon-dynamic-story',
	standalone: true,
	imports: [FormsModule, NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideHouse })],
	template: /* HTML */ `
		<ng-icon hlm name="lucideHouse" [size]="size()" />
		<div>Bound property value: {{size()}}</div>

		<div class="flex flex-row gap-x-2">
			<label>
				<input type="radio" name="iconSize" [ngModel]="size()" (ngModelChange)="size.set($event)" value="xs" />
				<span>XS</span>
			</label>
			<label>
				<input type="radio" name="iconSize" [ngModel]="size()" (ngModelChange)="size.set($event)" value="sm" />
				<span>SM</span>
			</label>
			<label>
				<input type="radio" name="iconSize" [ngModel]="size()" (ngModelChange)="size.set($event)" value="base" />
				<span>Base</span>
			</label>
			<label>
				<input type="radio" name="iconSize" [ngModel]="size()" (ngModelChange)="size.set($event)" value="lg" />
				<span>LG</span>
			</label>
			<label>
				<input type="radio" name="iconSize" [ngModel]="size()" (ngModelChange)="size.set($event)" value="xl" />
				<span>XL</span>
			</label>
			<label>
				<input type="radio" name="iconSize" [ngModel]="size()" (ngModelChange)="size.set($event)" value="none" />
				<span>None</span>
			</label>
		</div>
	`,
})
class IconDynamicStory {
	protected size = signal<IconSize>('base');
}

export const Dynamic: Story = {
	decorators: [
		moduleMetadata({
			imports: [IconDynamicStory],
		}),
	],
	render: () => ({
		template: '<icon-dynamic-story/>',
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/icon/helm/README.md
```
# ui-icon-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-icon-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/icon/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/icon/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-icon-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	coverageDirectory: '../../../../coverage/libs/ui/icon/helm',
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/icon/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/icon/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/icon/helm/package.json
```json
{
	"name": "@spartan-ng/ui-icon-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/icon/helm/project.json
```json
{
	"name": "ui-icon-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/icon/helm/src",
	"prefix": "hlm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/icon/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/icon/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/icon/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/icon/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-icon-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/icon/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/icon/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/icon/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/icon/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/icon/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmIconDirective } from './lib/hlm-icon.directive';

export * from './lib/hlm-icon.directive';
export * from './lib/hlm-icon.token';

@NgModule({
	imports: [HlmIconDirective],
	exports: [HlmIconDirective],
})
export class HlmIconModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/icon/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/icon/helm/src/lib/hlm-icon.directive.spec.ts
```typescript
import { ChangeDetectionStrategy, Component, Input } from '@angular/core';
import { By } from '@angular/platform-browser';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideCheck } from '@ng-icons/lucide';
import { type RenderResult, render } from '@testing-library/angular';
import { HlmIconDirective } from './hlm-icon.directive';

@Component({
	selector: 'hlm-mock',
	standalone: true,
	changeDetection: ChangeDetectionStrategy.OnPush,
	imports: [HlmIconDirective, NgIcon],
	providers: [provideIcons({ lucideCheck })],
	template: `
		<ng-icon hlm class="test" name="lucideCheck" [size]="size" color="red" strokeWidth="2" />
	`,
})
class HlmMockComponent {
	@Input() public size = 'base';
}

describe('HlmIconDirective', () => {
	let r: RenderResult<HlmMockComponent>;
	let icon: HTMLElement;

	beforeEach(async () => {
		r = await render(HlmMockComponent);
		icon = r.container.querySelector('ng-icon')!;
	});

	it('should add the xs size', async () => {
		await r.rerender({ componentInputs: { size: 'xs' } });
		r.fixture.detectChanges();
		expect(icon.getAttribute('style')).toContain('--ng-icon__size: 12px');
	});

	it('should add the sm size', async () => {
		await r.rerender({ componentInputs: { size: 'sm' } });
		r.fixture.detectChanges();
		expect(icon.getAttribute('style')).toContain('--ng-icon__size: 16px');
	});

	it('should add the base size', () => {
		expect(icon.getAttribute('style')).toContain('--ng-icon__size: 24px');
	});

	it('should add the lg size', async () => {
		await r.rerender({ componentInputs: { size: 'lg' } });
		r.fixture.detectChanges();
		expect(icon.getAttribute('style')).toContain('--ng-icon__size: 32px');
	});

	it('should add the xl size', async () => {
		await r.rerender({ componentInputs: { size: 'xl' } });
		r.fixture.detectChanges();
		expect(icon.getAttribute('style')).toContain('--ng-icon__size: 48px');
	});

	it('should forward the size property if the size is not a pre-defined size', async () => {
		await r.rerender({ componentInputs: { size: '2rem' } });
		r.fixture.detectChanges();
		const debugEl = r.fixture.debugElement.query(By.directive(NgIcon));
		expect(debugEl.componentInstance.size()).toBe('2rem');
		expect(icon.getAttribute('style')).toContain('--ng-icon__size: 2rem');
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/icon/helm/src/lib/hlm-icon.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { injectHlmIconConfig } from './hlm-icon.token';

export type IconSize = 'xs' | 'sm' | 'base' | 'lg' | 'xl' | 'none' | (Record<never, never> & string);

@Directive({
	selector: 'ng-icon[hlm]',
	standalone: true,
	host: {
		'[style.--ng-icon__size]': '_computedSize()',
	},
})
export class HlmIconDirective {
	private readonly _config = injectHlmIconConfig();
	public readonly size = input<IconSize>(this._config.size);

	protected readonly _computedSize = computed(() => {
		const size = this.size();

		switch (size) {
			case 'xs':
				return '12px';
			case 'sm':
				return '16px';
			case 'base':
				return '24px';
			case 'lg':
				return '32px';
			case 'xl':
				return '48px';
			default: {
				return size;
			}
		}
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/icon/helm/src/lib/hlm-icon.token.ts
```typescript
import { InjectionToken, ValueProvider, inject } from '@angular/core';
import type { IconSize } from './hlm-icon.directive';

export interface HlmIconConfig {
	size: IconSize;
}

const defaultConfig: HlmIconConfig = {
	size: 'base',
};

const HlmIconConfigToken = new InjectionToken<HlmIconConfig>('HlmIconConfig');

export function provideHlmIconConfig(config: Partial<HlmIconConfig>): ValueProvider {
	return { provide: HlmIconConfigToken, useValue: { ...defaultConfig, ...config } };
}

export function injectHlmIconConfig(): HlmIconConfig {
	return inject(HlmIconConfigToken, { optional: true }) ?? defaultConfig;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/sheet.stories.ts
```typescript
import { BrnSheetComponent, BrnSheetContentDirective, BrnSheetTriggerDirective } from '@spartan-ng/brain/sheet';
import { type Meta, type StoryObj, argsToTemplate, moduleMetadata } from '@storybook/angular';
import { HlmButtonDirective } from '../button/helm/src';
import { HlmInputDirective } from '../input/helm/src';
import { HlmSheetImports } from './helm/src';

export type SheetProps = { side: 'top' | 'bottom' | 'left' | 'right' };
const meta: Meta<SheetProps> = {
	title: 'Sheet',
	component: BrnSheetComponent,
	tags: ['autodocs'],
	args: { side: 'left' },
	argTypes: {
		side: { control: 'select', options: ['top', 'bottom', 'left', 'right'] },
	},
	decorators: [
		moduleMetadata({
			imports: [
				BrnSheetTriggerDirective,
				BrnSheetContentDirective,
				HlmSheetImports,
				HlmButtonDirective,
				HlmInputDirective,
			],
		}),
	],
};

export default meta;
type Story = StoryObj<SheetProps>;

export const Default: Story = {
	render: ({ ...args }) => ({
		props: args,
		template: `
    <hlm-sheet ${argsToTemplate(args)}>
    <button id='edit-profile' variant='outline' brnSheetTrigger hlmBtn>Edit Profile</button>
    <hlm-sheet-content *brnSheetContent='let ctx'>
         <hlm-sheet-header>
          <h3 hlmSheetTitle>Edit Profile</h3>
          <p hlmSheetDescription>
          Make changes to your profile here. Click save when you're done.
          </p>
        </hlm-sheet-header>
                <div class='py-4 grid gap-4'>
          <div class='items-center grid grid-cols-4 gap-4'>
            <label hlmLabel for='name' class='text-right'>
              Name
            </label>
            <input hlmInput id='name' value='Pedro Duarte' class='col-span-3' />
          </div>
          <div class='items-center grid grid-cols-4 gap-4'>
            <label hlmLabel for='username' class='text-right'>
              Username
            </label>
            <input hlmInput id='username' value='@peduarte' class='col-span-3' />
          </div>
        </div>
        <hlm-sheet-footer>
          <button hlmBtn type='submit'>Save Changes</button>
        </hlm-sheet-footer>
    </hlm-sheet-content>
    </hlm-sheet>
    `,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/helm/README.md
```
# ui-sheet-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-sheet-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-sheet-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/sheet/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/helm/package.json
```json
{
	"name": "@spartan-ng/ui-sheet-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/core": ">=19.0.0",
		"@ng-icons/core": ">=29.0.0",
		"@ng-icons/lucide": ">=29.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
		"class-variance-authority": "^0.7.0",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/helm/project.json
```json
{
	"name": "ui-sheet-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/sheet/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/sheet/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/sheet/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/sheet/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/sheet/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-sheet-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { HlmSheetCloseDirective } from './lib/hlm-sheet-close.directive';
import { HlmSheetContentComponent } from './lib/hlm-sheet-content.component';
import { HlmSheetDescriptionDirective } from './lib/hlm-sheet-description.directive';
import { HlmSheetFooterComponent } from './lib/hlm-sheet-footer.component';
import { HlmSheetHeaderComponent } from './lib/hlm-sheet-header.component';
import { HlmSheetOverlayDirective } from './lib/hlm-sheet-overlay.directive';
import { HlmSheetTitleDirective } from './lib/hlm-sheet-title.directive';
import { HlmSheetComponent } from './lib/hlm-sheet.component';

export * from './lib/hlm-sheet-close.directive';
export * from './lib/hlm-sheet-content.component';
export * from './lib/hlm-sheet-description.directive';
export * from './lib/hlm-sheet-footer.component';
export * from './lib/hlm-sheet-header.component';
export * from './lib/hlm-sheet-overlay.directive';
export * from './lib/hlm-sheet-title.directive';
export * from './lib/hlm-sheet.component';

export const HlmSheetImports = [
	HlmSheetComponent,
	HlmSheetCloseDirective,
	HlmSheetContentComponent,
	HlmSheetDescriptionDirective,
	HlmSheetFooterComponent,
	HlmSheetHeaderComponent,
	HlmSheetOverlayDirective,
	HlmSheetTitleDirective,
] as const;

@NgModule({
	imports: [...HlmSheetImports],
	exports: [...HlmSheetImports],
})
export class HlmSheetModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/helm/src/lib/hlm-sheet-close.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmSheetClose],[brnSheetClose][hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSheetCloseDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'absolute flex h-4 w-4 right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/helm/src/lib/hlm-sheet-content.component.ts
```typescript
import { Component, ElementRef, Renderer2, computed, effect, inject, input, signal } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideX } from '@ng-icons/lucide';
import { hlm, injectExposedSideProvider, injectExposesStateProvider } from '@spartan-ng/brain/core';
import { BrnSheetCloseDirective } from '@spartan-ng/brain/sheet';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import { cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';
import { HlmSheetCloseDirective } from './hlm-sheet-close.directive';

export const sheetVariants = cva(
	'fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500',
	{
		variants: {
			side: {
				top: 'border-border inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top',
				bottom:
					'border-border inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom',
				left: 'border-border inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm',
				right:
					'border-border inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm',
			},
		},
		defaultVariants: {
			side: 'right',
		},
	},
);

@Component({
	selector: 'hlm-sheet-content',
	imports: [HlmSheetCloseDirective, BrnSheetCloseDirective, NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideX })],
	host: {
		'[class]': '_computedClass()',
		'[attr.data-state]': 'state()',
	},
	template: `
		<ng-content />
		<button brnSheetClose hlm>
			<span class="sr-only">Close</span>
			<ng-icon hlm size="sm" name="lucideX" />
		</button>
	`,
})
export class HlmSheetContentComponent {
	private readonly _stateProvider = injectExposesStateProvider({ host: true });
	private readonly _sideProvider = injectExposedSideProvider({ host: true });
	public state = this._stateProvider.state ?? signal('closed');
	private readonly _renderer = inject(Renderer2);
	private readonly _element = inject(ElementRef);

	constructor() {
		effect(() => {
			this._renderer.setAttribute(this._element.nativeElement, 'data-state', this.state());
		});
	}

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(sheetVariants({ side: this._sideProvider.side() }), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/helm/src/lib/hlm-sheet-description.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnSheetDescriptionDirective } from '@spartan-ng/brain/sheet';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmSheetDescription]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnSheetDescriptionDirective],
})
export class HlmSheetDescriptionDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('text-sm text-muted-foreground', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/helm/src/lib/hlm-sheet-footer.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-sheet-footer',
	standalone: true,
	template: `
		<ng-content />
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSheetFooterComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm('flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/helm/src/lib/hlm-sheet-header.component.ts
```typescript
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-sheet-header',
	standalone: true,
	template: `
		<ng-content />
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSheetHeaderComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('flex flex-col space-y-2 text-center sm:text-left', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/helm/src/lib/hlm-sheet-overlay.directive.ts
```typescript
import { Directive, computed, effect, input, untracked } from '@angular/core';
import { hlm, injectCustomClassSettable } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmSheetOverlay],brn-sheet-overlay[hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSheetOverlayDirective {
	private readonly _classSettable = injectCustomClassSettable({ optional: true, host: true });
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
			this.userClass(),
		),
	);

	constructor() {
		effect(() => {
			const classValue = this._computedClass();
			untracked(() => this._classSettable?.setClassToCustomElement(classValue));
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/helm/src/lib/hlm-sheet-title.directive.ts
```typescript
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnSheetTitleDirective } from '@spartan-ng/brain/sheet';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmSheetTitle]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnSheetTitleDirective],
})
export class HlmSheetTitleDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('text-lg font-semibold', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/sheet/helm/src/lib/hlm-sheet.component.ts
```typescript
import { ChangeDetectionStrategy, Component, forwardRef, ViewEncapsulation } from '@angular/core';
import { BrnDialogComponent, provideBrnDialogDefaultOptions } from '@spartan-ng/brain/dialog';
import { BrnSheetComponent, BrnSheetOverlayComponent } from '@spartan-ng/brain/sheet';
import { HlmSheetOverlayDirective } from './hlm-sheet-overlay.directive';

@Component({
	selector: 'hlm-sheet',
	imports: [BrnSheetOverlayComponent, HlmSheetOverlayDirective],
	providers: [
		{
			provide: BrnDialogComponent,
			useExisting: forwardRef(() => BrnSheetComponent),
		},
		{
			provide: BrnSheetComponent,
			useExisting: forwardRef(() => HlmSheetComponent),
		},
		provideBrnDialogDefaultOptions({
			// add custom options here
		}),
	],
	template: `
		<brn-sheet-overlay hlm />
		<ng-content />
	`,
	encapsulation: ViewEncapsulation.None,
	changeDetection: ChangeDetectionStrategy.OnPush,
	exportAs: 'hlmSheet',
})
export class HlmSheetComponent extends BrnSheetComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/badge/badge.stories.ts
```typescript
import { type Meta, type StoryObj, argsToTemplate, moduleMetadata } from '@storybook/angular';
import { HlmBadgeDirective } from './helm/src';

const meta: Meta<HlmBadgeDirective> = {
	title: 'Badge',
	component: HlmBadgeDirective,
	tags: ['autodocs'],
	argTypes: {
		variant: {
			options: ['default', 'secondary', 'destructive', 'outline'],
			control: {
				type: 'select',
			},
			table: {
				defaultValue: { summary: 'default' },
			},
		},
		size: {
			options: ['default', 'lg'],
			control: {
				type: 'select',
			},
			table: {
				defaultValue: { summary: 'default' },
			},
		},
		static: {
			control: { type: 'boolean' },
			table: {
				defaultValue: { summary: 'false' },
			},
		},
	},
	args: {
		static: false,
	},
	decorators: [
		moduleMetadata({
			imports: [HlmBadgeDirective],
		}),
	],
	render: ({ ...args }) => ({
		props: args,
		template: `
    <span hlmBadge ${argsToTemplate(args)}>I am a badge</span>
    `,
	}),
};

export default meta;
type Story = StoryObj<HlmBadgeDirective>;

export const Default: Story = {
	args: {
		variant: 'default',
	},
};

export const Destructive: Story = {
	args: {
		variant: 'destructive',
	},
};

export const Outline: Story = {
	args: {
		variant: 'outline',
	},
};

export const Secondary: Story = {
	args: {
		variant: 'secondary',
	},
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/badge/helm/README.md
```
# ui-badge-helm

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test ui-badge-helm` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/badge/helm/eslint.config.js
```javascript
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'hlm',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'hlm',
					style: 'kebab-case',
				},
			],
			'@angular-eslint/no-input-rename': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/badge/helm/jest.config.ts
```typescript
export default {
	displayName: 'ui-badge-helm',
	preset: '../../../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/badge/helm/ng-package.json
```json
{
	"$schema": "../../../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../../../dist/libs/ui/badge/helm",
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/badge/helm/package.json
```json
{
	"name": "@spartan-ng/ui-badge-helm",
	"version": "0.0.1-alpha.381",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@angular/cdk": ">=19.0.0",
		"@angular/core": ">=19.0.0",
		"@spartan-ng/brain": "0.0.1-alpha.451",
		"class-variance-authority": "^0.7.0",
		"clsx": "^2.1.1"
	},
	"publishConfig": {
		"access": "public"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/badge/helm/project.json
```json
{
	"name": "ui-badge-helm",
	"$schema": "../../../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/ui/badge/helm/src",
	"prefix": "helm",
	"projectType": "library",
	"tags": ["scope:helm"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/ui/badge/helm/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/ui/badge/helm/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/ui/badge/helm/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/ui/badge/helm/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "ui-badge-helm"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/badge/helm/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/badge/helm/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["src/**/*.spec.ts", "src/test-setup.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/badge/helm/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/badge/helm/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/badge/helm/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { HlmBadgeDirective } from './lib/hlm-badge.directive';

export * from './lib/hlm-badge.directive';

@NgModule({
	imports: [HlmBadgeDirective],
	exports: [HlmBadgeDirective],
})
export class HlmBadgeModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/badge/helm/src/test-setup.ts
```typescript
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
	testEnvironmentOptions: {
		errorOnUnknownElements: true,
		errorOnUnknownProperties: true,
	},
};
import 'jest-preset-angular/setup-jest';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/ui/badge/helm/src/lib/hlm-badge.directive.ts
```typescript
import type { BooleanInput } from '@angular/cdk/coercion';
import { Directive, booleanAttribute, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const badgeVariants = cva(
	'inline-flex items-center border rounded-full px-2.5 py-0.5 font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2',
	{
		variants: {
			variant: {
				default: 'bg-primary border-transparent text-primary-foreground',
				secondary: 'bg-secondary border-transparent text-secondary-foreground',
				destructive: 'bg-destructive border-transparent text-destructive-foreground',
				outline: 'text-foreground border-border',
			},
			size: {
				default: 'text-xs',
				lg: 'text-sm',
			},
			static: { true: '', false: '' },
		},
		compoundVariants: [
			{
				variant: 'default',
				static: false,
				class: 'hover:bg-primary/80',
			},
			{
				variant: 'secondary',
				static: false,
				class: 'hover:bg-secondary/80',
			},
			{
				variant: 'destructive',
				static: false,
				class: 'hover:bg-destructive/80',
			},
		],
		defaultVariants: {
			variant: 'default',
			size: 'default',
			static: false,
		},
	},
);
export type BadgeVariants = VariantProps<typeof badgeVariants>;

@Directive({
	selector: '[hlmBadge]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmBadgeDirective {
	protected readonly _computedClass = computed(() =>
		hlm(badgeVariants({ variant: this.variant(), size: this.size(), static: this.static() }), this.userClass()),
	);

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly variant = input<BadgeVariants['variant']>('default');
	public readonly static = input<BadgeVariants['static'], BooleanInput>(false, { transform: booleanAttribute });
	public readonly size = input<BadgeVariants['size']>('default');
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/README.md
```
# tools

This library was generated with [Nx](https://nx.dev).

## Building

Run `nx build tools` to build the library.

## Running unit tests

Run `nx test tools` to execute the unit tests via [Jest](https://jestjs.io).

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/eslint.config.cjs
```
const baseConfig = require('../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	{
		files: ['**/*.ts', '**/*.tsx', '**/*.js', '**/*.jsx'],
		rules: {},
	},
	{
		files: ['**/*.ts', '**/*.tsx'],
		rules: {
			'@angular-eslint/prefer-output-readonly': 'off',
		},
	},
	{
		files: ['**/*.js', '**/*.jsx'],
		rules: {},
	},
	{
		files: ['**/*.json'],
		rules: {
			'@nx/nx-plugin-checks': 'error',
			'@nx/dependency-checks': 'off',
		},
		languageOptions: {
			parser: require('jsonc-eslint-parser'),
		},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/executors.json
```json
{
	"executors": {
		"npm-publish": {
			"implementation": "./src/executors/release/npm-publish/executor",
			"schema": "./src/executors/release/npm-publish/schema.json",
			"description": "npm-publish executor"
		},
		"build-update-publish": {
			"implementation": "./src/executors/release/build-update-publish/executor",
			"schema": "./src/executors/release/build-update-publish/schema.json",
			"description": "build-update-publish executor"
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/generators.json
```json
{
	"generators": {
		"replace-cli-version": {
			"factory": "./src/generators/replace-cli-version/generator",
			"schema": "./src/generators/replace-cli-version/schema.json",
			"description": "Updates the CLI's version"
		},
		"replace-ui-version": {
			"factory": "./src/generators/replace-ui-version/generator",
			"schema": "./src/generators/replace-ui-version/schema.json",
			"description": "Replaces version for all UI libs and their references in the CLI"
		},
		"auto-increment-version": {
			"factory": "./src/generators/auto-increment-version/generator",
			"schema": "./src/generators/auto-increment-version/schema.json",
			"description": "During alpha we are using this to automatically increment the version number for nightly releases"
		},
		"hlm-to-cli-generator": {
			"factory": "./src/generators/hlm-to-cli-generator/generator",
			"schema": "./src/generators/hlm-to-cli-generator/schema.json",
			"description": "hlm-to-cli-generator generator"
		},
		"brain-secondary-entrypoint": {
			"factory": "./src/generators/brain-secondary-entrypoint/generator",
			"schema": "./src/generators/brain-secondary-entrypoint/schema.json",
			"description": "Add a secondary entrypoint to the Brain library"
		},
		"helm-library": {
			"factory": "./src/generators/helm-library/generator",
			"schema": "./src/generators/helm-library/schema.json",
			"description": "Create a new Helm library."
		},
		"helm-story": {
			"factory": "./src/generators/helm-story/generator",
			"schema": "./src/generators/helm-story/schema.json",
			"description": "Generate a story for a helm component."
		},
		"helm-component": {
			"factory": "./src/generators/helm-component/generator",
			"schema": "./src/generators/helm-component/schema.json",
			"description": "Generate a helm component."
		},
		"helm-directive": {
			"factory": "./src/generators/helm-directive/generator",
			"schema": "./src/generators/helm-directive/schema.json",
			"description": "Generate a helm directive."
		},
		"helm-documentation": {
			"factory": "./src/generators/helm-documentation/generator",
			"schema": "./src/generators/helm-documentation/schema.json",
			"description": "Generate a documentation page for a Helm component."
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/jest.config.ts
```typescript
export default {
	displayName: 'tools',
	preset: '../../jest.preset.cjs',
	transform: {
		'^.+\\.[tj]s$': ['ts-jest', { tsconfig: '<rootDir>/tsconfig.spec.json' }],
	},
	moduleFileExtensions: ['ts', 'js', 'html'],
	coverageDirectory: '../../coverage/libs/tools',
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/package.json
```json
{
	"name": "@spartan-ng/tools",
	"version": "0.0.1-alpha.380",
	"private": true,
	"type": "commonjs",
	"executors": "./executors.json",
	"generators": "./generators.json"
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/project.json
```json
{
	"name": "tools",
	"$schema": "../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/tools/src",
	"projectType": "library",
	"tags": [],
	"targets": {
		"build": {
			"executor": "@nx/js:tsc",
			"outputs": ["{options.outputPath}"],
			"options": {
				"outputPath": "dist/libs/tools",
				"main": "libs/tools/src/index.ts",
				"tsConfig": "libs/tools/tsconfig.lib.json",
				"assets": [
					"libs/tools/*.md",
					{
						"input": "./libs/tools/src",
						"glob": "**/!(*.ts)",
						"output": "./src"
					},
					{
						"input": "./libs/tools/src",
						"glob": "**/*.d.ts",
						"output": "./src"
					},
					{
						"input": "./libs/tools",
						"glob": "generators.json",
						"output": "."
					},
					{
						"input": "./libs/tools",
						"glob": "executors.json",
						"output": "."
					}
				]
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/tools/jest.config.ts"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/tsconfig.json
```json
{
	"extends": "../../tsconfig.base.json",
	"compilerOptions": {
		"module": "commonjs"
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../dist/out-tsc",
		"declaration": true,
		"types": ["node"]
	},
	"include": ["src/**/*.ts"],
	"exclude": ["jest.config.ts", "src/**/*.spec.ts", "src/**/*.test.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../dist/out-tsc",
		"module": "commonjs",
		"types": ["jest", "node"]
	},
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/index.ts
```typescript
console.log('I should not be blank.');

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/executors/release/npm-publish/executor.spec.ts
```typescript
import { ExecutorContext } from '@nx/devkit';
import * as child_process from 'node:child_process';
import * as process from 'node:process';
import * as projectHelpers from '../helpers/projects.helpers';
import executor from './executor';

// Mock the entire child_process module
jest.mock('node:child_process', () => ({
	execSync: jest.fn(), // Mock execSync function
}));

describe('NpmPublish Executor', () => {
	it('should execSync with a default libPath if no libPath was provided', async () => {
		const mockRoot = 'libs/my-domain/foo';
		const context = {} as unknown as ExecutorContext;

		// Mock the getRoot helper
		jest.spyOn(projectHelpers, 'getRoot').mockReturnValue(mockRoot);

		// Set the environment variable for TAG
		process.env.TAG = 'next';

		// Expected command that should be executed
		const expectedCommand = `cd ./dist/${mockRoot} && npm publish --tag next`;

		// Call the executor
		const output = await executor({}, context);

		// Check if execSync was called with the expected command
		expect(child_process.execSync).toHaveBeenCalledWith(expectedCommand);
		expect(output.success).toBe(true);
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/executors/release/npm-publish/executor.ts
```typescript
import type { ExecutorContext } from '@nx/devkit';
import { execSync } from 'node:child_process';

import { getRoot } from '../helpers/projects.helpers';

import * as process from 'node:process';
import type { NpmPublishExecutorSchema } from './schema';

export default async function runExecutor(_options: NpmPublishExecutorSchema, context: ExecutorContext) {
	const tag = process.env.TAG;

	if (!tag) {
		console.log('no process.env.TAG available. returning early');
		return {
			success: false,
		};
	}

	const sourceRoot = `./dist/${getRoot(context)}`;

	console.log('running npm publish at ' + sourceRoot);

	execSync(`cd ${sourceRoot} && npm publish${tag ? ` --tag ${tag}` : ''}`);
	return {
		success: true,
	};
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/executors/release/npm-publish/schema.d.ts
```typescript
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export type NpmPublishExecutorSchema = {};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/executors/release/npm-publish/schema.json
```json
{
	"$schema": "http://json-schema.org/draft-07/schema",
	"version": 2,
	"title": "NPM publish executor",
	"description": "",
	"type": "object",
	"properties": {}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/executors/release/build-update-publish/executor.spec.ts
```typescript
import * as childProcess from 'node:child_process';
import * as projectHelper from '../helpers/projects.helpers';
import * as npmPublish from '../npm-publish/executor';
import executor from './executor';

// Mock the entire child_process module
jest.mock('node:child_process', () => ({
	execSync: jest.fn(), // Mock execSync function
}));

describe('BuildUpdatePublish Executor', () => {
	it('should call update-version executor and npm publish executor with the options and context', async () => {
		const libName = 'foo';
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		const mockContext = { bar: 'bar' } as any;

		// Mock the project helper, npmPublish, and execSync
		jest.spyOn(projectHelper, 'getProjectName').mockReturnValue(libName);

		// Mock npmPublish to return { success: true }
		jest.spyOn(npmPublish, 'default').mockImplementation(async () => Promise.resolve({ success: true }));

		// execSync is already mocked globally by jest.mock
		const expectedCommand = `nx build --project ${libName}`;
		const execSyncMock = childProcess.execSync as jest.Mock;

		const output = await executor({}, mockContext);

		// Verify that all functions are called as expected
		expect(npmPublish.default).toHaveBeenCalledWith({}, mockContext);
		expect(execSyncMock).toHaveBeenCalledWith(expectedCommand);
		expect(output.success).toBe(true);
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/executors/release/build-update-publish/executor.ts
```typescript
import type { ExecutorContext } from '@nx/devkit';
import { execSync } from 'node:child_process';

import { getProjectName } from '../helpers/projects.helpers';
import npmPublish from '../npm-publish/executor';

import type { BuildUpdatePublishExecutorSchema } from './schema';

export default async function runExecutor(_options: BuildUpdatePublishExecutorSchema, context: ExecutorContext) {
	execSync(`nx build --project ${getProjectName(context)}`);

	await npmPublish({}, context);

	return {
		success: true,
	};
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/executors/release/build-update-publish/schema.d.ts
```typescript
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export type BuildUpdatePublishExecutorSchema = {};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/executors/release/build-update-publish/schema.json
```json
{
	"$schema": "http://json-schema.org/draft-07/schema",
	"version": 2,
	"title": "BuildUpdatePublish executor",
	"description": "",
	"type": "object",
	"properties": {}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/executors/release/helpers/projects.helpers.spec.ts
```typescript
import { ExecutorContext } from '@nx/devkit';
import { getProjectName, getRoot } from './projects.helpers';

describe('executor project helper', () => {
	it('should return the project name', () => {
		const projectName = 'foo';
		expect(getProjectName({ projectName } as unknown as ExecutorContext)).toBe(projectName);
	});

	it('should get the root of the project', () => {
		const expectedRoot = 'libs/foo';
		const context = {
			projectName: 'foo',
			projectsConfigurations: {
				projects: {
					foo: {
						root: expectedRoot,
					},
				},
			},
		} as unknown as ExecutorContext;

		expect(getRoot(context)).toBe(expectedRoot);
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/executors/release/helpers/projects.helpers.ts
```typescript
import type { ExecutorContext } from '@nx/devkit';

export function getProjectName(context: ExecutorContext): string {
	return context.projectName;
}

export function getRoot(context: ExecutorContext): string {
	const projectsConfiguration = context.projectsConfigurations.projects;
	const projectName = getProjectName(context);
	return projectsConfiguration[projectName].root;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/brain-secondary-entrypoint/generator.ts
```typescript
import { librarySecondaryEntryPointGenerator } from '@nx/angular/generators';
import { formatFiles, Tree } from '@nx/devkit';
import { BrainSecondaryEntrypointGeneratorSchema } from './schema';

export async function brainSecondaryEntrypointGenerator(tree: Tree, options: BrainSecondaryEntrypointGeneratorSchema) {
	await librarySecondaryEntryPointGenerator(tree, {
		name: options.name,
		library: 'brain',
		skipFormat: true,
		skipModule: true,
	});

	await formatFiles(tree);
}

export default brainSecondaryEntrypointGenerator;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/brain-secondary-entrypoint/schema.d.ts
```typescript
export interface BrainSecondaryEntrypointGeneratorSchema {
	name: string;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/brain-secondary-entrypoint/schema.json
```json
{
	"$schema": "https://json-schema.org/schema",
	"$id": "BrainSecondaryEntrypoint",
	"title": "",
	"type": "object",
	"properties": {
		"name": {
			"type": "string",
			"description": "The name of the secondary entrypoint to create.",
			"$default": {
				"$source": "argv",
				"index": 0
			},
			"x-prompt": "What name would you like to use?"
		}
	},
	"required": ["name"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/helm-directive/generator.ts
```typescript
import { formatFiles, generateFiles, joinPathFragments, names, readProjectConfiguration, Tree } from '@nx/devkit';
import * as path from 'path';
import { addExportStatement, addImportStatement, addToExportConstArray } from '../utils/ast';
import { HelmDirectiveGeneratorSchema } from './schema';

export async function helmDirectiveGenerator(tree: Tree, options: HelmDirectiveGeneratorSchema) {
	const { root } = readProjectConfiguration(tree, options.project);
	const { fileName, className } = names(options.directiveName);
	const directivePath = joinPathFragments(root, 'src', 'lib');

	generateFiles(tree, path.join(__dirname, 'files'), directivePath, {
		fileName,
		directiveName: `Hlm${className}Directive`,
		selector: `hlm${className}`,
	});

	// the path to the index.ts file
	const indexPath = joinPathFragments(root, 'src', 'index.ts');
	let sourceCode = tree.read(indexPath, 'utf-8');

	sourceCode = addImportStatement(
		sourceCode,
		`import { Hlm${className}Directive } from './lib/hlm-${fileName}.directive';`,
	);
	sourceCode = addExportStatement(sourceCode, `export * from './lib/hlm-${fileName}.directive';`);
	sourceCode = addToExportConstArray(sourceCode, `Hlm${className}Directive`);

	tree.write(indexPath, sourceCode);

	await formatFiles(tree);
}

export default helmDirectiveGenerator;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/helm-directive/schema.d.ts
```typescript
export interface HelmDirectiveGeneratorSchema {
	project: string;
	directiveName: string;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/helm-directive/schema.json
```json
{
	"$schema": "https://json-schema.org/schema",
	"$id": "HelmComponent",
	"title": "",
	"type": "object",
	"properties": {
		"project": {
			"type": "string",
			"description": "The name of the project to add the directive to.",
			"alias": "p",
			"$default": {
				"$source": "argv",
				"index": 0
			},
			"x-dropdown": "projects",
			"x-prompt": "What project would you like to add the directive to?",
			"x-priority": "important"
		},
		"directiveName": {
			"type": "string",
			"description": "The name of the directive.",
			"x-prompt": "The name of the directive?"
		}
	},
	"required": ["project", "directiveName"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/helm-directive/files/hlm-__fileName__.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[<%= selector %>]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class <%= directiveName %> {
	/** The user defined classes */
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	/** The classes to apply merged with the user defined classes */
	protected readonly _computedClass = computed(() => hlm('', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/replace-cli-version/generator.ts
```typescript
import { formatFiles, type Tree, updateJson } from '@nx/devkit';
import process from 'node:process';

export default async function replaceCliVersionGenerator(tree: Tree, options?: { newVersion: string }): Promise<void> {
	const packageJsonPath = 'libs/cli/package.json';
	const newVersion = options?.newVersion ?? process.env.VERSION;

	if (!newVersion) {
		console.error('Must define a VERSION environment variable to use with this script.');
		return;
	}

	updateJson(tree, packageJsonPath, (pkgJson) => {
		pkgJson.version = newVersion;
		return pkgJson;
	});

	await formatFiles(tree);

	console.log(`updated CLI version to ${newVersion}`);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/replace-cli-version/schema.json
```json
{
	"$schema": "http://json-schema.org/schema",
	"$id": "ReplaceCliVersionGenerator",
	"title": "",
	"type": "object",
	"properties": {}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/helm-documentation/generator.ts
```typescript
import { formatFiles, generateFiles, joinPathFragments, names, Tree } from '@nx/devkit';
import * as path from 'path';
import { HelmDocumentationGeneratorSchema } from './schema';

export async function helmDocumentationGenerator(tree: Tree, options: HelmDocumentationGeneratorSchema) {
	const documentationPath = joinPathFragments('apps', 'app', 'src', 'app', 'pages', '(components)', 'components');

	generateFiles(tree, path.join(__dirname, 'files'), documentationPath, {
		name: options.name,
		description: options.description,
		...names(options.name),
		previewComponentName: `${names(options.name).className}PreviewComponent`,
		pageComponentName: `${names(options.name).className}PageComponent`,
	});
	await formatFiles(tree);
}

export default helmDocumentationGenerator;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/helm-documentation/schema.d.ts
```typescript
export interface HelmDocumentationGeneratorSchema {
	name: string;
	description: string;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/helm-documentation/schema.json
```json
{
	"$schema": "https://json-schema.org/schema",
	"$id": "HelmDocumentation",
	"title": "",
	"type": "object",
	"properties": {
		"name": {
			"type": "string",
			"description": "",
			"$default": {
				"$source": "argv",
				"index": 0
			},
			"x-prompt": "What name would you like to use?"
		},
		"description": {
			"type": "string",
			"description": "The description of the library."
		}
	},
	"required": ["name"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/helm-documentation/files/(__fileName__)/__fileName__.page.ts.template
```
import type { RouteMeta } from '@analogjs/router';
import { Component } from '@angular/core';
import { hlmCode, hlmH4 } from '@spartan-ng/ui-typography-helm';
import { CodePreviewDirective } from '../../../../shared/code/code-preview.directive';
import { CodeComponent } from '../../../../shared/code/code.component';
import { MainSectionDirective } from '../../../../shared/layout/main-section.directive';
import { PageBottomNavPlaceholderComponent } from '../../../../shared/layout/page-bottom-nav-placeholder.component';
import { PageBottomNavLinkComponent } from '../../../../shared/layout/page-bottom-nav/page-bottom-nav-link.component';
import { PageBottomNavComponent } from '../../../../shared/layout/page-bottom-nav/page-bottom-nav.component';
import { PageNavComponent } from '../../../../shared/layout/page-nav/page-nav.component';
import { SectionIntroComponent } from '../../../../shared/layout/section-intro.component';
import { SectionSubHeadingComponent } from '../../../../shared/layout/section-sub-heading.component';
import { TabsCliComponent } from '../../../../shared/layout/tabs-cli.component';
import { TabsComponent } from '../../../../shared/layout/tabs.component';
import { metaWith } from '../../../../shared/meta/meta.util';
import { <%= previewComponentName %>, codeImports, codeSkeleton, codeString } from './<%= fileName %>.preview';

export const routeMeta: RouteMeta = {
	data: { breadcrumb: '<%= name %>' },
	meta: metaWith(
		'spartan/ui - <%= name %>',
		'<%= description %>',
	),
	title: 'spartan/ui - <%= name %>',
};

@Component({
	selector: 'spartan-<%= fileName %>',
	standalone: true,
	imports: [
		MainSectionDirective,
		CodeComponent,
		SectionIntroComponent,
		SectionSubHeadingComponent,
		TabsComponent,
		TabsCliComponent,
		<%= previewComponentName %>,
		CodePreviewDirective,
		PageNavComponent,
		PageBottomNavComponent,
		PageBottomNavLinkComponent,
		PageBottomNavPlaceholderComponent,
	],
	template: `
		<section spartanMainSection>
			<spartan-section-intro
				name="<%= name %>"
				lead="<%= description %>"
			/>

			<spartan-tabs firstTab="Preview" secondTab="Code">
				<div spartanCodePreview firstTab>
					<spartan-<%= fileName %>-preview />
				</div>
				<spartan-code secondTab [code]="code" />
			</spartan-tabs>

			<spartan-section-sub-heading id="installation">Installation</spartan-section-sub-heading>
			<spartan-cli-tabs
				class="mt-4"
				nxCode="npx nx g @spartan-ng/cli:ui <%= name %>"
				ngCode="ng g @spartan-ng/cli:ui <%= name %>"
			/>

			<spartan-section-sub-heading id="usage">Usage</spartan-section-sub-heading>
			<div class="space-y-4">
				<spartan-code [code]="imports" />
				<spartan-code [code]="codeSkeleton" />
			</div>

			<spartan-page-bottom-nav>
				<spartan-page-bottom-nav-link href="alert" label="Alert" />
				<spartan-page-bottom-nav-placeholder />
			</spartan-page-bottom-nav>
		</section>
		<spartan-page-nav />
	`,
})
export default class <%= pageComponentName %> {
	public readonly code = codeString;
	public readonly imports = codeImports;
	public readonly skeleton = codeSkeleton;
	protected readonly readonly codeSkeleton = codeSkeleton;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/helm-documentation/files/(__fileName__)/__fileName__.preview.ts.template
```
import { Component } from '@angular/core';

@Component({
	selector: 'spartan-<%= fileName %>-preview',
	standalone: true,
	imports: [

	],
	template: `

	`,
})
export class <%= previewComponentName %> {}

export const codeImports = `
import {

} from '@spartan-ng/ui-<%= fileName %>-helm';
`;

export const codeString = `import { Component } from '@angular/core';${codeImports}

@Component({
	selector: 'spartan-<%= fileName %>-preview',
	standalone: true,
	imports: [

	],
	template: \`

	\`,
})
export class <%= previewComponentName %> {}`;

export const codeSkeleton = `

`;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/utils/ast.ts
```typescript
import { tsquery } from '@phenomnomnominal/tsquery';
import * as ts from 'typescript';

export function addToExportConstArray(sourceCode: string, newEntry: string): string {
	const ast = tsquery.ast(sourceCode);
	const query =
		'VariableStatement:has(ExportKeyword) > VariableDeclarationList VariableDeclaration ArrayLiteralExpression';
	const nodes = tsquery(ast, query) as ts.ArrayLiteralExpression[];

	if (nodes.length === 0) {
		throw new Error('No matching export const array found.');
	}

	const arrayNode = nodes[0];
	const elements = [...arrayNode.elements.map((el) => el.getText()), newEntry];

	return sourceCode.slice(0, arrayNode.getStart()) + `[${elements.join(', ')}]` + sourceCode.slice(arrayNode.getEnd());
}

export function addExportStatement(sourceCode: string, exportStatement: string): string {
	const ast = tsquery.ast(sourceCode);
	const importQuery = 'ImportDeclaration';
	const exportQuery = 'ExportDeclaration';

	const importNodes = tsquery(ast, importQuery) as ts.ImportDeclaration[];
	const exportNodes = tsquery(ast, exportQuery) as ts.ExportDeclaration[];

	let insertPosition = 0;
	if (importNodes.length > 0) {
		// Place after the last import
		insertPosition = importNodes[importNodes.length - 1].getEnd();
	}
	if (exportNodes.length > 0) {
		// If exports exist, place after the last export
		insertPosition = exportNodes[exportNodes.length - 1].getEnd();
	}

	return sourceCode.slice(0, insertPosition) + `\n${exportStatement}` + sourceCode.slice(insertPosition);
}

export function addImportStatement(sourceCode: string, importStatement: string): string {
	const ast = tsquery.ast(sourceCode);
	const query = 'ImportDeclaration';
	const importNodes = tsquery(ast, query) as ts.ImportDeclaration[];

	if (importNodes.length === 0) {
		// No existing imports, insert at the beginning
		return `${importStatement}\n\n${sourceCode}`;
	}

	const lastImport = importNodes[importNodes.length - 1];

	return sourceCode.slice(0, lastImport.getEnd()) + `\n${importStatement}` + sourceCode.slice(lastImport.getEnd());
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/hlm-to-cli-generator/generator.spec.ts
```typescript
import { type Tree, readProjectConfiguration } from '@nx/devkit';
import { createTreeWithEmptyWorkspace } from '@nx/devkit/testing';

import { hlmCliNxGeneratorGenerator } from './generator';
import type { HlmToCliGeneratorGeneratorSchema } from './schema';

describe('hlm-to-nx-generator generator', () => {
	let tree: Tree;
	const options: HlmToCliGeneratorGeneratorSchema = {};

	beforeEach(() => {
		tree = createTreeWithEmptyWorkspace();
	});

	it.skip('should run successfully', async () => {
		await hlmCliNxGeneratorGenerator(tree, options);
		const config = readProjectConfiguration(tree, 'test');
		expect(config).toBeDefined();
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/hlm-to-cli-generator/generator.ts
```typescript
import { type ProjectConfiguration, type Tree, formatFiles, names, readJson, workspaceRoot } from '@nx/devkit';
import * as path from 'node:path';
import { addPrimitiveToSupportedUILibraries } from './lib/add-primitive-to-supported-ui-libraries';
import { copyFilesFromHlmLibToGenerator, createSharedGeneratorFiles, recursivelyDelete } from './lib/file-management';
import { getProjectsAndNames } from './lib/get-project-names';
import type { HlmToCliGeneratorGeneratorSchema } from './schema';

const BASE_PATH = path.join('libs', 'cli', 'src', 'generators', 'ui');

async function createGeneratorFromHlmLibrary(
	projects: Map<string, ProjectConfiguration>,
	generatorName: string,
	internalName: string,
	tree: Tree,
	options: HlmToCliGeneratorGeneratorSchema,
) {
	const srcPath = path.join(workspaceRoot, projects.get(internalName).sourceRoot);
	const projectRoot = path.join(BASE_PATH, 'libs', internalName);
	const supportedUILibsJsonPath = path.join(BASE_PATH, 'supported-ui-libraries.json');
	const filesPath = path.join(projectRoot, 'files');
	const peerDependencies = readJson(tree, path.join(projects.get(internalName).root, 'package.json')).peerDependencies;
	recursivelyDelete(tree, filesPath);
	addPrimitiveToSupportedUILibraries(tree, supportedUILibsJsonPath, generatorName, internalName, peerDependencies);
	copyFilesFromHlmLibToGenerator(tree, srcPath, filesPath, options);
	createSharedGeneratorFiles(tree, projectRoot, options);
}

export async function hlmCliNxGeneratorGenerator(tree: Tree, options: HlmToCliGeneratorGeneratorSchema) {
	const { projects, projectNames } = getProjectsAndNames(tree);
	const projectNamesIgnoringCoreLibs = projectNames.filter((name) => !name.includes('core'));

	for (const internalName of projectNamesIgnoringCoreLibs) {
		const primitiveName = internalName.replace('ui-', '').replace('-helm', '').replace('-', '');
		const cleanNames = names(primitiveName);
		const mergedOptions = { ...options, ...cleanNames };
		mergedOptions['internalName'] = internalName;
		mergedOptions['publicName'] = `ui-${primitiveName}-helm`;
		mergedOptions['primitiveName'] = primitiveName;

		createGeneratorFromHlmLibrary(projects, primitiveName, internalName, tree, mergedOptions);
	}

	await formatFiles(tree);
}

export default hlmCliNxGeneratorGenerator;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/hlm-to-cli-generator/schema.d.ts
```typescript
export interface HlmToCliGeneratorGeneratorSchema {
	additionalDependencies?: string;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/hlm-to-cli-generator/schema.json
```json
{
	"$schema": "http://json-schema.org/draft-07/schema",
	"$id": "HlmToCliGenerator",
	"title": "",
	"type": "object",
	"properties": {}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/hlm-to-cli-generator/lib/add-primitive-to-supported-ui-libraries.ts
```typescript
import type { Tree } from '@nx/devkit';
import { updateJson } from 'nx/src/generators/utils/json';

export const addPrimitiveToSupportedUILibraries = (
	tree: Tree,
	supportedJsonPath: string,
	generatorName: string,
	internalName: string,
	peerDependencies: Record<string, string>,
) => {
	updateJson(tree, supportedJsonPath, (old) => ({
		...old,
		[generatorName]: {
			internalName,
			peerDependencies,
		},
	}));
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/hlm-to-cli-generator/lib/file-management.ts
```typescript
import { type Tree, generateFiles } from '@nx/devkit';
import * as path from 'node:path';
import type { HlmToCliGeneratorGeneratorSchema } from '../schema';

export const copyFilesFromHlmLibToGenerator = (
	tree: Tree,
	srcPath: string,
	filesPath: string,
	options: HlmToCliGeneratorGeneratorSchema,
) => {
	generateFiles(tree, srcPath, filesPath, options);
	tree.delete(path.join(filesPath, 'test-setup.ts'));
	recursivelyRenameToTemplate(tree, filesPath);
};

export const createSharedGeneratorFiles = (
	tree: Tree,
	projectRoot: string,
	options: HlmToCliGeneratorGeneratorSchema,
) => {
	generateFiles(tree, path.join(__dirname, '..', 'files'), projectRoot, options);
};

export const recursivelyRenameToTemplate = (tree: Tree, filePath: string) => {
	tree.children(filePath).forEach((child) => {
		const childPath = path.join(filePath, child);
		if (tree.isFile(childPath)) {
			tree.rename(childPath, `${childPath}.template`);
		} else {
			recursivelyRenameToTemplate(tree, childPath);
		}
	});
};

export const recursivelyDelete = (tree: Tree, filePath: string) => {
	tree.children(filePath).forEach((child) => {
		const childPath = path.join(filePath, child);
		if (tree.isFile(childPath)) {
			tree.delete(childPath);
		} else {
			recursivelyDelete(tree, childPath);
		}
	});
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/hlm-to-cli-generator/lib/get-project-names.ts
```typescript
import { type Tree, getProjects } from '@nx/devkit';

export const getProjectsAndNames = (tree: Tree) => {
	const projectNames: string[] = [];
	const projects = getProjects(tree);

	projects.forEach((projectConfiguration, projectName) => {
		if (projectConfiguration.projectType === 'library' && projectName.includes('helm')) {
			projectNames.push(projectName);
		}
	});
	return { projects, projectNames };
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/hlm-to-cli-generator/files/generator.ts.template
```
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
  return await hlmBaseGenerator(tree, {...options, primitiveName: '<%= primitiveName %>', internalName: '<%= internalName %>', publicName: '<%= publicName %>'});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/auto-increment-version/generator.spec.ts
```typescript
import { type Tree, readProjectConfiguration } from '@nx/devkit';
import { createTreeWithEmptyWorkspace } from '@nx/devkit/testing';

import autoIncrementVersion from './generator';

describe('replace-cli-version generator', () => {
	let tree: Tree;

	beforeEach(() => {
		tree = createTreeWithEmptyWorkspace();
	});

	it.skip('should run successfully', async () => {
		await autoIncrementVersion(tree);
		const config = readProjectConfiguration(tree, 'test');
		expect(config).toBeDefined();
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/auto-increment-version/generator.ts
```typescript
import { type Tree, formatFiles, readJsonFile } from '@nx/devkit';
import replaceCliVersionGenerator from '../replace-cli-version/generator';
import replaceUiVersionGenerator from '../replace-ui-version/generator';

export default async function autoIncrementVersion(tree: Tree): Promise<void> {
	const oldVersion = readJsonFile('libs/brain/package.json').version as string;
	const [prefix, branchAndNumber] = oldVersion.split('-');
	const [branch, versionNumber] = branchAndNumber.split('.');
	const newVersionNumber = +versionNumber + 1;

	const newVersion = `${prefix}-${branch}.${newVersionNumber}`;

	console.log(
		`preparing release with auto-incremented version ${newVersion} which should be 1 more than ${oldVersion}`,
	);

	await replaceUiVersionGenerator(tree, { newVersion });
	await replaceCliVersionGenerator(tree, { newVersion });

	await formatFiles(tree);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/auto-increment-version/schema.json
```json
{
	"$schema": "http://json-schema.org/schema",
	"$id": "AutoIncrementVersionGenerator",
	"title": "",
	"type": "object",
	"properties": {}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/helm-library/generator.ts
```typescript
import { VERSION } from '@angular/core';
import { libraryGenerator, UnitTestRunner } from '@nx/angular/generators';
import {
	formatFiles,
	joinPathFragments,
	names,
	readProjectConfiguration,
	Tree,
	updateJson,
	updateProjectConfiguration,
} from '@nx/devkit';
import helmComponentGenerator from '../helm-component/generator';
import helmDirectiveGenerator from '../helm-directive/generator';
import helmDocumentationGenerator from '../helm-documentation/generator';
import { helmStoryGenerator } from '../helm-story/generator';
import { HelmLibraryGeneratorSchema } from './schema';

export async function helmLibraryGenerator(tree: Tree, options: HelmLibraryGeneratorSchema) {
	const { fileName: normalizedName, className } = names(options.name);
	const projectName = `ui-${normalizedName}-helm`;

	await libraryGenerator(tree, {
		name: projectName,
		directory: joinPathFragments('libs', 'ui', normalizedName, 'helm'),
		importPath: `@spartan-ng/ui-${normalizedName}-helm`,
		prefix: 'hlm',
		linter: 'eslint',
		standalone: true,
		strict: true,
		inlineStyle: true,
		inlineTemplate: true,
		unitTestRunner: UnitTestRunner.Jest,
		publishable: false,
		buildable: true,
		skipModule: true,
		tags: 'scope:helm',
	});

	// add the release target to the project.json
	const configuration = readProjectConfiguration(tree, projectName);

	// add the release target to the project.json
	updateProjectConfiguration(tree, projectName, {
		...configuration,
		targets: {
			...configuration.targets,
			release: {
				executor: '@spartan-ng/tools:build-update-publish',
				options: {
					libName: projectName,
				},
			},
		},
	});

	// remove the default component
	tree.delete(
		joinPathFragments('libs', 'ui', normalizedName, 'helm', 'src', 'lib', projectName, `${projectName}.component.ts`),
	);
	tree.delete(
		joinPathFragments(
			'libs',
			'ui',
			normalizedName,
			'helm',
			'src',
			'lib',
			projectName,
			`${projectName}.component.spec.ts`,
		),
	);

	// empty the index.ts file
	tree.write(
		joinPathFragments('libs', 'ui', normalizedName, 'helm', 'src', 'index.ts'),
		`import { NgModule } from '@angular/core';

export const Hlm${className}Imports = [] as const;

@NgModule({
	imports: [...Hlm${className}Imports],
	exports: [...Hlm${className}Imports],
})
export class Hlm${className}Module {}`,
	);

	// update the supported libraries json
	const supportedLibrariesPath = joinPathFragments(
		'libs',
		'cli',
		'src',
		'generators',
		'ui',
		'supported-ui-libraries.json',
	);

	updateJson(tree, supportedLibrariesPath, (json) => {
		json[normalizedName.replaceAll('-', '')] = {
			internalName: projectName,
			peerDependencies: {
				'@angular/core': `>=${VERSION.major}.0.0`,
				'class-variance-authority': '^0.7.0',
				clsx: '^2.1.1',
			},
		};
		return json;
	});

	// create the generator files
	const generatorPath = joinPathFragments(
		'libs',
		'cli',
		'src',
		'generators',
		'ui',
		'libs',
		projectName,
		'generator.ts',
	);

	tree.write(
		generatorPath,
		`import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: '${normalizedName}',
		internalName: '${projectName}',
		publicName: '${projectName}',
	});
}`,
	);

	if (options.story) {
		await helmStoryGenerator(tree, {
			project: projectName,
			componentName: `Hlm${className}Component`,
		});
	}

	if (options.generate === 'component') {
		await helmComponentGenerator(tree, {
			project: projectName,
			componentName: normalizedName,
		});
	} else if (options.generate === 'directive') {
		await helmDirectiveGenerator(tree, {
			project: projectName,
			directiveName: normalizedName,
		});
	}

	if (options.documentation) {
		await helmDocumentationGenerator(tree, {
			name: options.name,
			description: options.description ?? 'TODO: Add a description',
		});
	}

	await formatFiles(tree);
}

export default helmLibraryGenerator;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/helm-library/schema.d.ts
```typescript
export interface HelmLibraryGeneratorSchema {
	name: string;
	story?: boolean;
	documentation?: boolean;
	generate?: 'component' | 'directive' | 'none';
	description?: string;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/helm-library/schema.json
```json
{
	"$schema": "https://json-schema.org/schema",
	"$id": "HelmLibrary",
	"title": "",
	"type": "object",
	"properties": {
		"name": {
			"type": "string",
			"description": "The name of the library.",
			"$default": {
				"$source": "argv",
				"index": 0
			},
			"x-prompt": "What name would you like to use?"
		},
		"story": {
			"type": "boolean",
			"description": "Generate a story for the library.",
			"default": true
		},
		"generate": {
			"type": "string",
			"description": "Whether to generate a directive or a component when creating the library.",
			"enum": ["directive", "component", "none"],
			"default": "none"
		},
		"documentation": {
			"type": "boolean",
			"description": "Whether to generate a documentation page",
			"default": true
		},
		"description": {
			"type": "string",
			"description": "Provide a description for the documentation page."
		}
	},
	"required": ["name"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/helm-story/generator.ts
```typescript
import { formatFiles, generateFiles, names, readJson, readProjectConfiguration, Tree } from '@nx/devkit';
import * as path from 'path';
import { HelmStoryGeneratorSchema } from './schema';

export async function helmStoryGenerator(tree: Tree, options: HelmStoryGeneratorSchema) {
	const { root, name } = readProjectConfiguration(tree, options.project);

	if (!name) {
		throw new Error(`Could not find project name in workspace: ${options.project}`);
	}

	// names are in the format ui-checkbox-helm, we want to discard ui- and -helm
	const normalizedName = name.replace(/^ui-/, '').replace(/-helm$/, '');

	// derive the story name from the normalizedName - e.g. radio-button => Radio Button
	const storyName = normalizedName
		.split('-')
		.map((part) => part.charAt(0).toUpperCase() + part.slice(1))
		.join(' ');

	// derive the imports name from the normalizedName - e.g. radio-button => HlmRadioButtonImports
	const componentImports = `Hlm${normalizedName
		.split('-')
		.map((part) => part.charAt(0).toUpperCase() + part.slice(1))
		.join('')}Imports`;

	const { name: importPath } = readJson(tree, path.join(root, 'package.json'));

	const projectRoot = path.join(root, '..');

	generateFiles(tree, path.join(__dirname, 'files'), projectRoot, {
		fileName: names(options.componentName).fileName,
		componentName: options.componentName,
		componentImports,
		importPath,
		storyName,
	});

	await formatFiles(tree);
}

export default helmStoryGenerator;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/helm-story/schema.d.ts
```typescript
export interface HelmStoryGeneratorSchema {
	project: string;
	componentName: string;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/helm-story/schema.json
```json
{
	"$schema": "https://json-schema.org/schema",
	"$id": "HelmStory",
	"title": "",
	"type": "object",
	"properties": {
		"project": {
			"type": "string",
			"description": "The name of the project to add the story to.",
			"alias": "p",
			"$default": {
				"$source": "argv",
				"index": 0
			},
			"x-dropdown": "projects",
			"x-prompt": "What project would you like to add the story to?",
			"x-priority": "important"
		},
		"componentName": {
			"type": "string",
			"description": "The name of the component.",
			"x-prompt": "The name of the component?"
		}
	},
	"required": ["project", "componentName"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/helm-story/files/__fileName__.stories.ts.template
```
import type { Meta, StoryObj } from '@storybook/angular';
import { moduleMetadata } from '@storybook/angular';
import { <%= componentName %>, <%= componentImports %>} from '<%= importPath %>';

export default {
	title: '<%= storyName %>',
	component: <%= componentName %>,
	tags: ['autodocs'],
	decorators: [
		moduleMetadata({
			imports: [<%= componentImports %>],
		}),
	],
} as Meta<<%= componentName %>>

type Story = StoryObj<<%= componentName %>>;

export const Default: Story = {
	render: () => ({
		template: `

		`,
	}),
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/helm-component/generator.ts
```typescript
import { formatFiles, generateFiles, joinPathFragments, names, readProjectConfiguration, Tree } from '@nx/devkit';
import * as path from 'path';
import { addExportStatement, addImportStatement, addToExportConstArray } from '../utils/ast';
import { HelmComponentGeneratorSchema } from './schema';

export async function helmComponentGenerator(tree: Tree, options: HelmComponentGeneratorSchema) {
	const { root } = readProjectConfiguration(tree, options.project);
	const { fileName, className } = names(options.componentName);
	const componentPath = joinPathFragments(root, 'src', 'lib');

	generateFiles(tree, path.join(__dirname, 'files'), componentPath, {
		fileName,
		componentName: `Hlm${className}Component`,
		selector: `hlm-${fileName}`,
	});

	// the path to the index.ts file
	const indexPath = joinPathFragments(root, 'src', 'index.ts');
	let sourceCode = tree.read(indexPath, 'utf-8');

	sourceCode = addImportStatement(
		sourceCode,
		`import { Hlm${className}Component } from './lib/hlm-${fileName}.component';`,
	);
	sourceCode = addExportStatement(sourceCode, `export * from './lib/hlm-${fileName}.component';`);
	sourceCode = addToExportConstArray(sourceCode, `Hlm${className}Component`);

	tree.write(indexPath, sourceCode);

	await formatFiles(tree);
}

export default helmComponentGenerator;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/helm-component/schema.d.ts
```typescript
export interface HelmComponentGeneratorSchema {
	project: string;
	componentName: string;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/helm-component/schema.json
```json
{
	"$schema": "https://json-schema.org/schema",
	"$id": "HelmComponent",
	"title": "",
	"type": "object",
	"properties": {
		"project": {
			"type": "string",
			"description": "The name of the project to add the component to.",
			"alias": "p",
			"$default": {
				"$source": "argv",
				"index": 0
			},
			"x-dropdown": "projects",
			"x-prompt": "What project would you like to add the component to?",
			"x-priority": "important"
		},
		"componentName": {
			"type": "string",
			"description": "The name of the component.",
			"x-prompt": "The name of the component?"
		}
	},
	"required": ["project", "componentName"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/helm-component/files/hlm-__fileName__.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: '<%= selector %>',
	standalone: true,
	template: ``,
})
export class <%= componentName %> {
	/** The user defined classes */
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	/** The classes to apply to the component merged with the user defined classes */
	protected readonly _computedClass = computed(() => hlm('', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/replace-ui-version/generator.spec.ts
```typescript
import { replaceSpartanVersion } from './generator';

describe('replaceSpartanVersions', () => {
	it('should replace only SPARTAN-prefixed versions that match oldVersion', () => {
		const input = `
      export const FALLBACK_ANGULAR_VERSION = '^18.0.0';
      export const SPARTAN_VERSION = '3.0.2';
      export const SPARTAN_ALERT_DIALOG_BRAIN_VERSION = '3.0.2';
      export const TAILWINDCSS_VERSION = '3.0.2';
    `;

		const oldVersion = '3.0.2';
		const newVersion = '3.0.3';

		const expectedOutput = `
      export const FALLBACK_ANGULAR_VERSION = '^18.0.0';
      export const SPARTAN_VERSION = '3.0.3';
      export const SPARTAN_ALERT_DIALOG_BRAIN_VERSION = '3.0.2';
      export const TAILWINDCSS_VERSION = '3.0.2';
    `;

		const result = replaceSpartanVersion(input, oldVersion, newVersion);
		expect(result).toBe(expectedOutput);
	});

	it('should not replace versions without the SPARTAN_ prefix', () => {
		const input = `
      export const FALLBACK_ANGULAR_VERSION = '3.0.2';
      export const TAILWINDCSS_VERSION = '3.0.2';
    `;

		const oldVersion = '3.0.2';
		const newVersion = '3.0.3';

		const result = replaceSpartanVersion(input, oldVersion, newVersion);
		expect(result).toBe(input); // No changes expected
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/replace-ui-version/generator.ts
```typescript
import { type Tree, formatFiles, readJsonFile, updateJson } from '@nx/devkit';
import process from 'node:process';

const getSpartanDependencyKeys = (dependencies?: Record<string, string>): string[] =>
	Object.keys(dependencies ?? {}).filter((key) => key.startsWith('@spartan-ng'));

export const replaceSpartanVersion = (content: string, oldVersion: string, newVersion: string): string => {
	/**
	 * Regular expression to match SPARTAN_VERSION constant:
	 * - `(SPARTAN_VERSION\\s*=\\s*['"])`:
	 *   1. `SPARTAN_VERSION`: Ensures the constant is named `SPARTAN_VERSION`.
	 *   4. `\\s*`: Matches zero or more spaces around the `=` sign.
	 *   5. `['"]`: Captures the opening quote (single or double).
	 *   6. Encloses the entire match before the version in group 1 (`$1`).
	 * - `${oldVersion}`: Matches the exact old version string.
	 * - `(['"])`: Captures the closing quote in group 2 (`$2`).
	 * - `g` flag: Ensures the regex replaces all matches globally, not just the first occurrence.
	 */
	const spartanVersionRegex = new RegExp(`(SPARTAN_VERSION\\s*=\\s*['"])${oldVersion}(['"])`, 'g');
	return content.replace(spartanVersionRegex, `$1${newVersion}$2`);
};

const replaceUiVersionInCliVersionsFile = (tree: Tree, oldVersion: string, newVersion: string) => {
	const filePath = `libs/cli/src/generators/base/versions.ts`;
	let contents = tree.read(filePath).toString();
	contents = replaceSpartanVersion(contents, oldVersion, newVersion);
	tree.write(filePath, contents);
};

const replaceUiVersionGenerator = async (tree: Tree, options?: { newVersion: string }): Promise<void> => {
	const brainPackageJsonPath = 'libs/brain/package.json';
	const oldVersion = readJsonFile(brainPackageJsonPath).version;
	const newVersion = options?.newVersion ?? process.env.VERSION;

	if (!oldVersion) {
		console.error(
			"Unable to find old version in our accordion's package.json, which we use as source of truth because its good enough.",
		);
		return;
	}

	if (!newVersion) {
		console.error('Must define a VERSION environment variable to use with this script.');
		return;
	}

	if (oldVersion === newVersion) {
		console.error('Old version cannot be the same as new version');
		return;
	}

	console.log(`Updating UI libs version from ${oldVersion} to ${newVersion}`);

	updateJson(tree, brainPackageJsonPath, (pkgJson) => {
		const peerDependencyKeysToUpdate = getSpartanDependencyKeys(pkgJson.peerDependencies);
		pkgJson.version = newVersion;

		for (const key of peerDependencyKeysToUpdate) {
			pkgJson.peerDependencies[key] = newVersion;
		}

		return pkgJson;
	});

	console.log(`Reflecting those changes in versions.ts file of the CLI`);
	replaceUiVersionInCliVersionsFile(tree, oldVersion, newVersion);

	await formatFiles(tree);
};

export default replaceUiVersionGenerator;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/tools/src/generators/replace-ui-version/schema.json
```json
{
	"$schema": "http://json-schema.org/draft-07/schema",
	"version": 2,
	"title": "Update version executor",
	"description": "",
	"type": "object",
	"properties": {}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/trpc/README.md
```
# tRPC

Spartan tRPC integration

Learn more at [spartan.ng](https://spartan.ng)

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/trpc/eslint.config.cjs
```
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	{
		files: ['**/*.json'],
		rules: {
			'@nx/dependency-checks': [
				'error',
				{
					ignoredFiles: ['{projectRoot}/eslint.config.{js,cjs,mjs}'],
					ignoredDependencies: [
						'@angular/common',
						'@angular/core',
						'@trpc/client',
						'@trpc/server',
						'isomorphic-fetch',
						'superjson',
					],
				},
			],
		},
		languageOptions: {
			parser: require('jsonc-eslint-parser'),
		},
	},
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'spartan-ng',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'spartan-ng',
					style: 'kebab-case',
				},
			],
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/trpc/ng-package.json
```json
{
	"$schema": "../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../dist/libs/trpc",
	"assets": ["*.md", "migrations/migration.json"],
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/trpc/package.json
```json
{
	"name": "@spartan-ng/trpc",
	"version": "0.2.29",
	"description": "Angular/Nitro-based tRPC integration",
	"keywords": [
		"angular",
		"trpc",
		"remote-procedure-call",
		"meta-framework"
	],
	"homepage": "https://spartan.ng",
	"bugs": {
		"url": "https://github.com/goetzrobin/spartan/issues"
	},
	"repository": {
		"type": "git",
		"url": "https://github.com/goetzrobin/spartan.git"
	},
	"license": "MIT",
	"author": "Robin Goetz",
	"sideEffects": false,
	"dependencies": {},
	"peerDependencies": {
		"@analogjs/vite-plugin-angular": ">=1.9.4",
		"@angular/common": ">=19.0.0",
		"@angular/compiler": ">=19.0.0",
		"@angular/core": ">=19.0.0",
		"@angular/platform-browser-dynamic": ">=19.0.0",
		"@trpc/client": "^10.45.2",
		"@trpc/server": "^10.45.2",
		"h3": "^1.12.0",
		"isomorphic-fetch": "^3.0.0",
		"rxjs": "~7.8.1",
		"superjson": "^2.2.1",
		"ufo": "1.5.4",
		"vite": "6.2.1"
	},
	"publishConfig": {
		"access": "public"
	},
	"ng-update": {
		"packageGroup": [],
		"migrations": "./migrations/migration.json"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/trpc/project.json
```json
{
	"name": "trpc",
	"$schema": "../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/trpc/src",
	"prefix": "spartan-ng",
	"projectType": "library",
	"tags": ["trpc"],
	"targets": {
		"build": {
			"executor": "@angular/build:ng-packagr",
			"outputs": ["{workspaceRoot}/dist/libs/trpc"],
			"options": {
				"project": "libs/trpc/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/trpc/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/trpc/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "trpc"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/trpc/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"useDefineForClassFields": false,
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		}
	],
	"extends": "../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/trpc/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": ["node"]
	},
	"exclude": ["src/**/*.spec.ts", "jest.config.ts", "src/**/*.test.ts"],
	"include": ["src/**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/trpc/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/trpc/vite.config.ts
```typescript
/// <reference types="vitest" />

import { defineConfig } from 'vite';

// https://vitejs.dev/config/
export default defineConfig(({ mode }) => {
	return {
		root: 'src',
		test: {
			passWithNoTests: true,
			globals: true,
			environment: 'jsdom',
			setupFiles: ['src/test-setup.ts'],
			include: ['**/*.spec.ts'],
			cache: {
				dir: '../../node_modules/.vitest',
			},
		},
		define: {
			'import.meta.vitest': mode !== 'production',
		},
	};
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/trpc/migrations/migration.json
```json
{
	"$schema": "../../../node_modules/@angular-devkit/schematics/collection-schema.json",
	"schematics": {},
	"packageJsonUpdates": {
		"0.2.30": {
			"version": "0.2.29",
			"description": "Updates the superjson dependency from 1.x to 2.x",
			"packages": {
				"superjson": {
					"version": "^2.2.1",
					"alwaysAddToPackageJson": true
				}
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/trpc/src/index.ts
```typescript
export * from './lib/client/client';
export * from './lib/server/server';
export * from './lib/utils/wait-for';

export { CreateTrpcProxyClient } from './lib/client/trpc-rxjs-proxy';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/trpc/src/test-setup.ts
```typescript
import '@analogjs/vite-plugin-angular/setup-vitest';
import '@angular/compiler';

/**
 * Initialize TestBed for all tests inside of router
 */
import { TestBed } from '@angular/core/testing';
import { BrowserDynamicTestingModule, platformBrowserDynamicTesting } from '@angular/platform-browser-dynamic/testing';

TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/trpc/src/lib/server/server.ts
```typescript
/**
 * ALl credit goes to the awesome trpc-nuxt plugin https://github.com/wobsoriano/trpc-nuxt
 * Since Analog currently uses Nitro as the underlying server we can
 * simply reuse the hard work done by Robert Soriano and friends
 * **/

import type { AnyRouter, ProcedureType, inferRouterContext, inferRouterError } from '@trpc/server';
import { TRPCError } from '@trpc/server';
import type { ResponseMeta } from '@trpc/server/http';
import { resolveHTTPResponse } from '@trpc/server/http';
import type { TRPCResponse } from '@trpc/server/rpc';
import type { H3Event } from 'h3';
import { createError, defineEventHandler, isMethod, readBody } from 'h3';
import { createURL } from 'ufo';

type MaybePromise<T> = T | Promise<T>;

export type CreateContextFn<TRouter extends AnyRouter> = (event: H3Event) => MaybePromise<inferRouterContext<TRouter>>;

export interface ResponseMetaFnPayload<TRouter extends AnyRouter> {
	data: TRPCResponse<unknown, inferRouterError<TRouter>>[];
	ctx?: inferRouterContext<TRouter>;
	paths?: string[];
	type: ProcedureType | 'unknown';
	errors: TRPCError[];
}

export type ResponseMetaFn<TRouter extends AnyRouter> = (opts: ResponseMetaFnPayload<TRouter>) => ResponseMeta;

export interface OnErrorPayload<TRouter extends AnyRouter> {
	error: TRPCError;
	type: ProcedureType | 'unknown';
	path: string | undefined;
	req: H3Event['node']['req'];
	input: unknown;
	ctx: undefined | inferRouterContext<TRouter>;
}

export type OnErrorFn<TRouter extends AnyRouter> = (opts: OnErrorPayload<TRouter>) => void;

export interface ResolveHTTPRequestOptions<TRouter extends AnyRouter> {
	router: TRouter;
	createContext?: CreateContextFn<TRouter>;
	responseMeta?: ResponseMetaFn<TRouter>;
	onError?: OnErrorFn<TRouter>;
	batching?: {
		enabled: boolean;
	};
}

function getPath(event: H3Event): string | null {
	const { params } = event.context;

	if (typeof params?.['trpc'] === 'string') {
		return params['trpc'];
	}

	if (params?.['trpc'] && Array.isArray(params['trpc'])) {
		return (params['trpc'] as string[]).join('/');
	}

	return null;
}

export function createTrpcNitroHandler<TRouter extends AnyRouter>({
	router,
	createContext,
	responseMeta,
	onError,
	batching,
}: ResolveHTTPRequestOptions<TRouter>) {
	return defineEventHandler(async (event) => {
		const { req, res } = event.node;

		const $url = createURL(req.url!);

		const path = getPath(event);

		if (path === null) {
			const error = router.getErrorShape({
				error: new TRPCError({
					message: 'Param "trpc" not found - is the file named `[trpc]`.ts or `[...trpc].ts`?',
					code: 'INTERNAL_SERVER_ERROR',
				}),
				type: 'unknown',
				ctx: undefined,
				path: undefined,
				input: undefined,
			});

			throw createError({
				statusCode: 500,
				statusMessage: JSON.stringify(error),
			});
		}

		const httpResponse = await resolveHTTPResponse({
			batching,
			router,
			req: {
				method: req.method!,
				headers: req.headers,
				body: isMethod(event, 'GET') ? null : await readBody(event),
				query: $url.searchParams,
			},
			path,
			createContext: async () => await createContext?.(event),
			responseMeta,
			onError: (o) => {
				onError?.({
					...o,
					req,
				});
			},
		});

		const { status, headers, body } = httpResponse;

		res.statusCode = status;

		headers &&
			Object.keys(headers).forEach((key) => {
				res.setHeader(key, headers[key]!);
			});

		return body;
	});
}

export default createTrpcNitroHandler;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/trpc/src/lib/utils/wait-for.ts
```typescript
/* eslint-disable @typescript-eslint/no-empty-function */
import { type Observable, firstValueFrom, isObservable } from 'rxjs';

// eslint-disable-next-line @typescript-eslint/no-explicit-any
declare const Zone: any;

export async function waitFor<T>(prom: Promise<T> | Observable<T>): Promise<T> {
	if (isObservable(prom)) {
		prom = firstValueFrom(prom);
	}
	const macroTask = Zone.current.scheduleMacroTask(
		`AnalogContentResolve-${Math.random()}`,
		() => {},
		{},
		() => {},
	);
	return prom.then((p: T) => {
		macroTask.invoke();
		return p;
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/trpc/src/lib/client/cache-state.ts
```typescript
/* eslint-disable @typescript-eslint/naming-convention */
import { APP_BOOTSTRAP_LISTENER, ApplicationRef, InjectionToken, inject } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { first } from 'rxjs/operators';

export const tRPC_CACHE_STATE = new InjectionToken<{
	isCacheActive: BehaviorSubject<boolean>;
}>('TRPC_HTTP_TRANSFER_STATE_CACHE_STATE');

export const provideTrpcCacheState = () => ({
	provide: tRPC_CACHE_STATE,
	useValue: { isCacheActive: new BehaviorSubject(true) },
});

export const provideTrpcCacheStateStatusManager = () => ({
	provide: APP_BOOTSTRAP_LISTENER,
	multi: true,
	useFactory: () => {
		const appRef = inject(ApplicationRef);
		const cacheState = inject(tRPC_CACHE_STATE);

		return () =>
			appRef.isStable.pipe(first((isStable) => isStable)).subscribe(() => cacheState.isCacheActive.next(false));
	},
	deps: [ApplicationRef, tRPC_CACHE_STATE],
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/trpc/src/lib/client/client.ts
```typescript
/* eslint-disable @typescript-eslint/naming-convention */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { InjectionToken, type Provider, TransferState, signal } from '@angular/core';
import { type CreateTRPCClientOptions, type HTTPHeaders, type HttpBatchLinkOptions, httpBatchLink } from '@trpc/client';
import type { FetchEsque } from '@trpc/client/dist/internals/types';
import type { AnyRouter } from '@trpc/server';
import 'isomorphic-fetch';
import { provideTrpcCacheState, provideTrpcCacheStateStatusManager, tRPC_CACHE_STATE } from './cache-state';
import { transferStateLink } from './links/transfer-state-link';
import { createTRPCRxJSProxyClient } from './trpc-rxjs-proxy';

export type TrpcOptions<T extends AnyRouter> = {
	url: string;
	options?: Partial<CreateTRPCClientOptions<T>>;
	batchLinkOptions?: Omit<HttpBatchLinkOptions, 'url' | 'headers'>;
};

export type TrpcClient<AppRouter extends AnyRouter> = ReturnType<typeof createTRPCRxJSProxyClient<AppRouter>>;
const tRPC_INJECTION_TOKEN = new InjectionToken<unknown>('@spartan-ng/trpc proxy client');

function customFetch(input: RequestInfo | URL, init?: RequestInit & { method: 'GET' }) {
	if ((globalThis as any).$fetch) {
		return (globalThis as any).$fetch
			.raw(input.toString(), init)
			.catch((e: any) => {
				throw e;
			})
			.then((response: any) => ({
				...response,
				headers: response.headers,
				json: () => Promise.resolve(response._data),
			}));
	}

	// dev server trpc for analog & nitro
	if (typeof window === 'undefined') {
		const host = process.env['NITRO_HOST'] ?? process.env['ANALOG_HOST'] ?? 'localhost';
		const port = process.env['NITRO_PORT'] ?? process.env['ANALOG_PORT'] ?? 4205;
		const base = `http://${host}:${port}`;
		if (input instanceof Request) {
			input = new Request(base, input);
		} else {
			input = new URL(input, base);
		}
	}

	return fetch(input, init);
}

export const createTrpcClient = <AppRouter extends AnyRouter>({
	url,
	options,
	batchLinkOptions,
}: TrpcOptions<AppRouter>) => {
	const TrpcHeaders = signal<HTTPHeaders>({});
	const provideTrpcClient = (): Provider[] => [
		provideTrpcCacheState(),
		provideTrpcCacheStateStatusManager(),
		{
			provide: tRPC_INJECTION_TOKEN,
			useFactory: () => {
				// eslint-disable-next-line @typescript-eslint/ban-ts-comment
				// @ts-ignore TODO: figure out why TS is complaining
				return createTRPCRxJSProxyClient<AppRouter>({
					transformer: options?.transformer,
					links: [
						...(options?.links ?? []),
						transferStateLink(),
						httpBatchLink({
							...(batchLinkOptions ?? {}),
							headers() {
								return TrpcHeaders();
							},
							fetch: customFetch as FetchEsque,
							url: url ?? '',
						}),
					],
				});
			},
			deps: [tRPC_CACHE_STATE, TransferState],
		},
	];
	const TrpcClient = tRPC_INJECTION_TOKEN as InjectionToken<TrpcClient<AppRouter>>;
	return {
		TrpcClient,
		provideTrpcClient,
		TrpcHeaders,
		/** @deprecated use TrpcClient instead */
		tRPCClient: TrpcClient,
		/** @deprecated use provideTrpcClient instead */
		provideTRPCClient: provideTrpcClient,
		/** @deprecated use TrpcHeaders instead */
		tRPCHeaders: TrpcHeaders,
	};
};

export default createTrpcClient;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/trpc/src/lib/client/shared-internal.ts
```typescript
import type { Operation, OperationContext, OperationLink, OperationResultObservable, TRPCLink } from '@trpc/client';
import type {
	AnyRouter,
	ClientDataTransformerOptions,
	CombinedDataTransformer,
	DataTransformerOptions,
	DefaultDataTransformer,
} from '@trpc/server';
import { observable } from '@trpc/server/observable';

// Removed subscription
export type TRPCType = 'query' | 'mutation';

// Removed subscription and requestAsPromise
export type UntypedClientProperties = 'links' | 'runtime' | 'requestId' | '$request' | 'query' | 'mutation';

/*
 * One to one copy of the trpc client internal code
 * Nothing was changed, but we can not import these methods because
 * they are not exported
 */
export type IntersectionError<TKey extends string> =
	`The property '${TKey}' in your router collides with a built-in method, rename this router or procedure on your backend.`;

export interface TRPCRequestOptions {
	/**
	 * Pass additional context to links
	 */
	context?: OperationContext;
}

export function createChain<TRouter extends AnyRouter, TInput = unknown, TOutput = unknown>(opts: {
	links: OperationLink<TRouter, TInput, TOutput>[];
	op: Operation<TInput>;
}): OperationResultObservable<TRouter, TOutput> {
	return observable((observer) => {
		function execute(index = 0, op = opts.op) {
			const next = opts.links[index];
			if (!next) {
				throw new Error('No more links to execute - did you forget to add an ending link?');
			}
			const subscription = next({
				op,
				next(nextOp) {
					const nextObserver = execute(index + 1, nextOp);

					return nextObserver;
				},
			});
			return subscription;
		}

		const obs$ = execute();
		return obs$.subscribe(observer);
	});
}

export type CreateTRPCClientOptions<TRouter extends AnyRouter> = CreateTRPCClientBaseOptions<TRouter> & {
	links: TRPCLink<TRouter>[];
};

export type CreateTRPCClientBaseOptions<TRouter extends AnyRouter> =
	TRouter['_def']['_config']['transformer'] extends DefaultDataTransformer
		? {
				/**
				 * Data transformer
				 *
				 * You must use the same transformer on the backend and frontend
				 * @link https://trpc.io/docs/data-transformers
				 **/
				transformer?: 'You must set a transformer on the backend router';
			}
		: TRouter['_def']['_config']['transformer'] extends DataTransformerOptions
			? {
					/**
					 * Data transformer
					 *
					 * You must use the same transformer on the backend and frontend
					 * @link https://trpc.io/docs/data-transformers
					 **/
					transformer: TRouter['_def']['_config']['transformer'] extends CombinedDataTransformer
						? DataTransformerOptions
						: TRouter['_def']['_config']['transformer'];
				}
			: {
					/**
					 * Data transformer
					 *
					 * You must use the same transformer on the backend and frontend
					 * @link https://trpc.io/docs/data-transformers
					 **/
					transformer?: /** @deprecated **/ ClientDataTransformerOptions | CombinedDataTransformer;
				};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/trpc/src/lib/client/trpc-rxjs-proxy.ts
```typescript
/* eslint-disable @typescript-eslint/no-explicit-any */
import { type OperationContext, type OperationLink, TRPCClientError, type TRPCClientRuntime } from '@trpc/client';
import type {
	AnyMutationProcedure,
	AnyProcedure,
	AnyQueryProcedure,
	AnyRouter,
	CombinedDataTransformer,
	DataTransformerOptions,
	IntersectionError,
	ProcedureArgs,
	ProcedureRouterRecord,
	ProcedureType,
	inferProcedureInput,
	inferProcedureOutput,
} from '@trpc/server';
import { type Observable as TrpcObservable, type inferObservableValue, share } from '@trpc/server/observable';
import { createFlatProxy, createRecursiveProxy, type inferTransformedProcedureOutput } from '@trpc/server/shared';
import { Observable as RxJSObservable } from 'rxjs';
import { type CreateTRPCClientOptions, type TRPCRequestOptions, type TRPCType, createChain } from './shared-internal';

// Changed to rxjs observable
type Resolver<TProcedure extends AnyProcedure> = (
	...args: ProcedureArgs<TProcedure['_def']>
) => RxJSObservable<inferTransformedProcedureOutput<TProcedure>>;

// Removed subscription and using new type
type DecorateProcedure<
	TProcedure extends AnyProcedure,
	_TRouter extends AnyRouter,
> = TProcedure extends AnyQueryProcedure
	? {
			query: Resolver<TProcedure>;
		}
	: TProcedure extends AnyMutationProcedure
		? {
				mutate: Resolver<TProcedure>;
			}
		: never;

// Removed subscription and using new type
type DecoratedProcedureRecord<TProcedures extends ProcedureRouterRecord, TRouter extends AnyRouter> = {
	[TKey in keyof TProcedures]: TProcedures[TKey] extends AnyRouter
		? DecoratedProcedureRecord<TProcedures[TKey]['_def']['record'], TProcedures[TKey]>
		: TProcedures[TKey] extends AnyProcedure
			? DecorateProcedure<TProcedures[TKey], TRouter>
			: never;
};

// Removed subscription and using new type
const clientCallTypeMap: Record<keyof DecorateProcedure<any, any>, ProcedureType> = {
	query: 'query',
	mutate: 'mutation',
};

// Removed subscription and requestAsPromise
type UntypedClientProperties = 'links' | 'runtime' | 'requestId' | '$request' | 'query' | 'mutation';

// Nothing changed, only using new types
// prettier-ignore
export type CreateTrpcProxyClient<TRouter extends AnyRouter> = DecoratedProcedureRecord<
	TRouter['_def']['record'],
	TRouter
> extends infer TProcedureRecord
	? UntypedClientProperties & keyof TProcedureRecord extends never
		? TProcedureRecord
		: IntersectionError<UntypedClientProperties & keyof TProcedureRecord>
	: never;

// Nothing changed, only using new types
function createTRPCRxJSClientProxy<TRouter extends AnyRouter>(client: TRPCClient<TRouter>) {
	return createFlatProxy<CreateTrpcProxyClient<TRouter>>((key) => {
		// eslint-disable-next-line no-prototype-builtins
		if (client.hasOwnProperty(key)) {
			return (client as any)[key as any];
		}
		return createRecursiveProxy(({ path, args }) => {
			const pathCopy = [key, ...path];

			const clientCallType = pathCopy.pop()! as keyof DecorateProcedure<any, any>;

			const procedureType = clientCallTypeMap[clientCallType];

			const fullPath = pathCopy.join('.');

			return (client as any)[procedureType](fullPath, ...args);
		});
	});
}

export function createTRPCRxJSProxyClient<TRouter extends AnyRouter>(opts: CreateTRPCClientOptions<TRouter>) {
	const client = new TRPCClient<TRouter>(opts);
	const proxy = createTRPCRxJSClientProxy(client as TRPCClient<TRouter>);
	return proxy;
}

/**
 * Removed subscription method;
 * Remove converting trpc observables to promises and therefore also the AbortController
 * Add converting to rxjs observable
 */
class TRPCClient<TRouter extends AnyRouter> {
	private readonly _links: OperationLink<TRouter>[];
	public readonly runtime: TRPCClientRuntime;
	private _requestId: number;

	constructor(opts: CreateTRPCClientOptions<TRouter>) {
		this._requestId = 0;

		const combinedTransformer: CombinedDataTransformer = (() => {
			const transformer = opts.transformer as DataTransformerOptions | undefined;

			if (!transformer) {
				return {
					input: {
						serialize: (data) => data,
						deserialize: (data) => data,
					},
					output: {
						serialize: (data) => data,
						deserialize: (data) => data,
					},
				};
			}
			if ('input' in transformer) {
				return opts.transformer as CombinedDataTransformer;
			}
			return {
				input: transformer,
				output: transformer,
			};
		})();

		this.runtime = {
			transformer: {
				serialize: (data) => combinedTransformer.input.serialize(data),
				deserialize: (data) => combinedTransformer.output.deserialize(data),
			},
			combinedTransformer,
		};

		// Initialize the links
		this._links = opts.links.map((link) => link(this.runtime));
	}

	private $request<TInput = unknown, TOutput = unknown>({
		type,
		input,
		path,
		context = {},
	}: {
		type: TRPCType;
		input: TInput;
		path: string;
		context?: OperationContext;
	}) {
		const chain$ = createChain<AnyRouter, TInput, TOutput>({
			links: this._links as OperationLink<any, any, any>[],
			op: {
				id: ++this._requestId,
				type,
				path,
				input,
				context,
			},
		});
		type TValue = inferObservableValue<typeof chain$>;
		return trpcObservableToRxJsObservable<TValue>(chain$.pipe(share()));
	}

	public query<
		TQueries extends TRouter['_def']['queries'],
		TPath extends string & keyof TQueries,
		TInput extends inferProcedureInput<TQueries[TPath]>,
	>(path: TPath, input?: TInput, opts?: TRPCRequestOptions) {
		type TOutput = inferProcedureOutput<TQueries[TPath]>;
		return this.$request<TInput, TOutput>({
			type: 'query',
			path,
			input: input as TInput,
			context: opts?.context,
		});
	}

	public mutation<
		TMutations extends TRouter['_def']['mutations'],
		TPath extends string & keyof TMutations,
		TInput extends inferProcedureInput<TMutations[TPath]>,
	>(path: TPath, input?: TInput, opts?: TRPCRequestOptions) {
		type TOutput = inferTransformedProcedureOutput<TMutations[TPath]>;
		return this.$request<TInput, TOutput>({
			type: 'mutation',
			path,
			input: input as TInput,
			context: opts?.context,
		});
	}
}

function trpcObservableToRxJsObservable<TValue>(observable: TrpcObservable<TValue, unknown>) {
	return new RxJSObservable<TValue>((subscriber) => {
		const sub = observable.subscribe({
			// eslint-disable-next-line @typescript-eslint/ban-ts-comment
			// @ts-ignore
			next: (value) => subscriber.next((value.result as any).data),
			// eslint-disable-next-line @typescript-eslint/ban-ts-comment
			// @ts-ignore
			error: (err) => subscriber.error(TRPCClientError.from(err)),
			complete: () => subscriber.complete(),
		});
		return () => {
			sub.unsubscribe();
		};
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/trpc/src/lib/client/links/transfer-state-link.ts
```typescript
import { type StateKey, TransferState, inject, makeStateKey } from '@angular/core';
import type { Operation, TRPCLink } from '@trpc/client';
import type { AnyRouter } from '@trpc/server';
import { observable } from '@trpc/server/observable';
import superjson from 'superjson';
import { tRPC_CACHE_STATE } from '../cache-state';

function makeCacheKey(request: Operation<unknown>): StateKey<string> {
	const { type, path, input } = request;
	const encodedParams = Object.entries(input ?? {}).reduce(
		(prev, [key, value]) => `${prev}${key}=${JSON.stringify(value)}`,
		'',
	);
	const key = `${type}.${path}?${encodedParams}`;
	const hash = generateHash(key);
	return makeStateKey(hash);
}

/**
 * A method that returns a hash representation of a string using a variant of DJB2 hash
 * algorithm.
 *
 * This is the same hashing logic that is used to generate component ids.
 */
function generateHash(value: string): string {
	let hash = 0;

	for (const char of value) {
		hash = (Math.imul(31, hash) + char.charCodeAt(0)) << 0;
	}

	// Force positive number hash.
	// 2147483647 = equivalent of Integer.MAX_VALUE.
	hash += 2147483647 + 1;

	return hash.toString();
}

export const transferStateLink =
	<AppRouter extends AnyRouter>(): TRPCLink<AppRouter> =>
	() => {
		const { isCacheActive } = inject(tRPC_CACHE_STATE);
		const transferState = inject(TransferState);
		const isBrowser = typeof window === 'object';
		// here we just got initialized in the app - this happens once per app
		// useful for storing cache for instance
		return ({ next, op }) => {
			const shouldUseCache =
				(op.type === 'query' && !isBrowser) || // always fetch new values on the server
				isCacheActive.getValue(); // or when initializing the client app --> same behavior as HttpClient

			if (!shouldUseCache) {
				return next(op);
			}

			const storeKey = makeCacheKey(op);
			const storeValue = transferState.get(storeKey, null);

			if (storeValue && isBrowser) {
				// on the server we don't care about the value we will always fetch a new one
				// use superjson to parse our superjson string and retrieve our
				// data return it instead of calling next trpc link
				return observable((observer) => observer.next(superjson.parse(storeValue)));
			}

			return observable((observer) => {
				return next(op).subscribe({
					next(value) {
						// store returned value from trpc call stringified with superjson in TransferState
						transferState.set(storeKey, superjson.stringify(value));
						observer.next(value);
					},
					error(err) {
						transferState.remove(storeKey);
						observer.error(err);
					},
					complete() {
						observer.complete();
					},
				});
			});
		};
	};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/README.md
```
# cli

This library was generated with [Nx](https://nx.dev).

## Building

Run `nx build cli` to build the library.

## Running unit tests

Run `nx test cli` to execute the unit tests via [Jest](https://jestjs.io).

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/eslint.config.cjs
```
const baseConfig = require('../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	{
		files: ['**/*.ts', '**/*.tsx', '**/*.js', '**/*.jsx'],
		rules: {},
	},
	{
		files: ['**/*.ts', '**/*.tsx'],
		rules: {
			'@angular-eslint/prefer-output-readonly': 'off',
		},
	},
	{
		files: ['**/*.js', '**/*.jsx'],
		rules: {},
	},
	{
		files: ['**/*.json'],
		rules: {
			'@nx/nx-plugin-checks': 'error',
			'@nx/dependency-checks': [
				'error',
				{
					ignoredDependencies: ['@nx/js', '@nx/devkit', '@nx/angular', 'enquirer', 'semver', 'tslib'],
				},
			],
		},
		languageOptions: {
			parser: require('jsonc-eslint-parser'),
		},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/executors.json
```json
{
	"executors": {}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/generators.json
```json
{
	"generators": {
		"ui": {
			"factory": "./src/generators/ui/generator",
			"schema": "./src/generators/ui/schema.json",
			"description": "spartan-ng ui generator"
		},
		"ui-theme": {
			"factory": "./src/generators/theme/generator",
			"schema": "./src/generators/theme/schema.json",
			"description": "spartan-ng theme generator"
		},
		"migrate-brain-imports": {
			"factory": "./src/generators/migrate-brain-imports/generator",
			"schema": "./src/generators/migrate-brain-imports/schema.json",
			"description": "Migrate Brain imports to use secondary entrypoints."
		},
		"migrate-scroll-area": {
			"factory": "./src/generators/migrate-scroll-area/generator",
			"schema": "./src/generators/migrate-scroll-area/schema.json",
			"description": "Migrate hlm-scroll-area to ngx-scrollbar"
		},
		"migrate-icon": {
			"factory": "./src/generators/migrate-icon/generator",
			"schema": "./src/generators/migrate-icon/schema.json",
			"description": "Migrate hlm-icon to ng-icon"
		},
		"migrate-radio": {
			"factory": "./src/generators/migrate-radio/generator",
			"schema": "./src/generators/migrate-radio/schema.json",
			"description": "Migrate brn-radio to hlm-radio"
		},
		"migrate-toggle-group": {
			"factory": "./src/generators/migrate-toggle-group/generator",
			"schema": "./src/generators/migrate-toggle-group/schema.json",
			"description": "Migrate brn-toggle-group from @spartan-ng/brain/toggle to @spartan-ng/brain/toggle-group"
		},
		"migrate-select": {
			"factory": "./src/generators/migrate-select/generator",
			"schema": "./src/generators/migrate-select/schema.json",
			"description": "Migrate brn-select and hlm-select to use openChange and active descendants"
		},
		"migrate-core": {
			"factory": "./src/generators/migrate-core/generator",
			"schema": "./src/generators/migrate-core/schema.json",
			"description": "Migrate core library to brain core entrypoing"
		},
		"healthcheck": {
			"factory": "./src/generators/healthcheck/generator",
			"schema": "./src/generators/healthcheck/schema.json",
			"description": "Run a healthcheck on the project to identify any potential issues or outdated code."
		},
		"migrate-helm-libraries": {
			"factory": "./src/generators/migrate-helm-libraries/generator",
			"schema": "./src/generators/migrate-helm-libraries/schema.json",
			"description": "Migrate Helm libraries to their latest versions"
		}
	},
	"schematics": {
		"ui": {
			"factory": "./src/generators/ui/compat",
			"schema": "./src/generators/ui/schema.json",
			"description": "spartan-ng ui generator"
		},
		"ui-theme": {
			"factory": "./src/generators/theme/compat",
			"schema": "./src/generators/theme/schema.json",
			"description": "spartan-ng theme generator"
		},
		"migrate-brain-imports": {
			"factory": "./src/generators/migrate-brain-imports/compat",
			"schema": "./src/generators/migrate-brain-imports/schema.json",
			"description": "Migrate Brain imports to use secondary entrypoints."
		},
		"migrate-scroll-area": {
			"factory": "./src/generators/migrate-scroll-area/compat",
			"schema": "./src/generators/migrate-scroll-area/schema.json",
			"description": "Migrate hlm-scroll-area to ngx-scrollbar"
		},
		"migrate-icon": {
			"factory": "./src/generators/migrate-icon/compat",
			"schema": "./src/generators/migrate-icon/schema.json",
			"description": "Migrate hlm-icon to ng-icon"
		},
		"migrate-radio": {
			"factory": "./src/generators/migrate-radio/compat",
			"schema": "./src/generators/migrate-radio/schema.json",
			"description": "Migrate brn-radio to hlm-radio"
		},
		"migrate-select": {
			"factory": "./src/generators/migrate-select/compat",
			"schema": "./src/generators/migrate-select/schema.json",
			"description": "Migrate brn-select and hlm-select to use openChange and active descendants"
		},
		"migrate-core": {
			"factory": "./src/generators/migrate-scroll-area/compat",
			"schema": "./src/generators/migrate-core/schema.json",
			"description": "Migrate core library to brain core entrypoing"
		},
		"healthcheck": {
			"factory": "./src/generators/healthcheck/compat",
			"schema": "./src/generators/healthcheck/schema.json",
			"description": "Run a healthcheck on the project to identify any potential issues or outdated code."
		},
		"migrate-helm-libraries": {
			"factory": "./src/generators/migrate-helm-libraries/compat",
			"schema": "./src/generators/migrate-helm-libraries/schema.json",
			"description": "Migrate Helm libraries to their latest versions"
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/jest.config.ts
```typescript
export default {
	displayName: 'cli',
	preset: '../../jest.preset.cjs',
	testEnvironment: 'node',
	transform: {
		'^.+\\.[tj]s$': ['ts-jest', { tsconfig: '<rootDir>/tsconfig.spec.json' }],
	},
	moduleFileExtensions: ['ts', 'js', 'html'],
	coverageDirectory: '../../coverage/libs/cli',
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/package.json
```json
{
	"name": "@spartan-ng/cli",
	"version": "0.0.1-alpha.451",
	"type": "commonjs",
	"dependencies": {
		"@nx/angular": ">=20.0.0",
		"@nx/devkit": ">=20.0.0",
		"@nx/js": ">=20.0.0",
		"@nx/workspace": ">=20.0.0",
		"@phenomnomnominal/tsquery": "^6.1.3",
		"@schematics/angular": ">=19.0.0",
		"enquirer": "2.3.6",
		"jsonc-eslint-parser": "^2.1.0",
		"nx": ">=20.0.0",
		"picocolors": "^1.1.1",
		"semver": "7.5.4",
		"typescript": ">=5.0.0"
	},
	"peerDependencies": {
		"tslib": "^2.3.0"
	},
	"publishConfig": {
		"access": "public"
	},
	"executors": "./executors.json",
	"generators": "./generators.json",
	"schematics": "./generators.json"
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/project.json
```json
{
	"name": "cli",
	"$schema": "../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/cli/src",
	"projectType": "library",
	"tags": ["scope:cli"],
	"targets": {
		"build": {
			"executor": "@nx/js:tsc",
			"outputs": ["{options.outputPath}"],
			"options": {
				"outputPath": "dist/libs/cli",
				"main": "libs/cli/src/index.ts",
				"tsConfig": "libs/cli/tsconfig.lib.json",
				"assets": [
					"libs/cli/*.md",
					{
						"input": "./libs/cli/src",
						"glob": "**/!(*.ts)",
						"output": "./src"
					},
					{
						"input": "./libs/cli/src",
						"glob": "**/*.d.ts",
						"output": "./src"
					},
					{
						"input": "./libs/cli",
						"glob": "generators.json",
						"output": "."
					},
					{
						"input": "./libs/cli",
						"glob": "executors.json",
						"output": "."
					}
				]
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint",
			"outputs": ["{options.outputFile}"]
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/cli/jest.config.ts"
			}
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "cli"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/tsconfig.json
```json
{
	"extends": "../../tsconfig.base.json",
	"compilerOptions": {
		"module": "commonjs"
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../dist/out-tsc",
		"declaration": true,
		"types": ["node"],
		"resolveJsonModule": true
	},
	"include": ["src/**/*.ts"],
	"exclude": ["jest.config.ts", "src/**/*.spec.ts", "src/**/*.test.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../dist/out-tsc",
		"module": "commonjs",
		"types": ["jest", "node"],
		"resolveJsonModule": true
	},
	"include": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts", "src/**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/index.ts
```typescript
export * from './generators/migrate-brain-imports/generator';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/utils/config.ts
```typescript
import { type Tree, readJson } from '@nx/devkit';
import { prompt } from 'enquirer';

const configPath = 'components.json';

export type Config = {
	componentsPath: string;
};

export async function getOrCreateConfig(tree: Tree, defaults?: Partial<Config>): Promise<Config> {
	if (tree.exists(configPath)) {
		return readJson(tree, configPath) as Promise<Config>; // TODO: Parse with zod and handle errors
	}

	console.log('Configuration file not found, creating a new one...');

	const { componentsPath } = (await prompt([
		{
			type: 'input',
			required: true,
			name: 'componentsPath',
			message: 'Choose a directory to place your spartan libraries, e.g. libs/ui',
			initial: defaults?.componentsPath ?? 'libs/ui',
			skip: !!defaults?.componentsPath,
		},
	])) as { componentsPath: string };

	const config = { componentsPath };

	tree.write(configPath, JSON.stringify(config, null, 2));

	return config;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/utils/get-project-names.ts
```typescript
import { type Tree, getProjects } from '@nx/devkit';

export const getProjectsAndNames = (tree: Tree) => {
	const projectNames: string[] = [];
	const projects = getProjects(tree);

	projects.forEach((projectConfiguration, projectName) => {
		if (projectConfiguration.projectType === 'application') {
			projectNames.push(projectName);
		}
	});
	return { projects, projectNames };
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/utils/hlm-class.ts
```typescript
import { Tree } from '@nx/devkit';
import { tsquery } from '@phenomnomnominal/tsquery';

export function hasHelmClasses(tree: Tree, path: string, { component, classes }: HasHelmClassesSchema): boolean {
	const content = tree.read(path, 'utf-8');

	if (!content) {
		return false;
	}

	const ast = tsquery.ast(content);

	// find the component class if it exists
	const componentClass = tsquery.query(ast, `ClassDeclaration:has(Identifier[name="${component}"])`);

	if (componentClass.length === 0) {
		return false;
	}

	// try and find the _computedClass property string
	const computedClass = tsquery.query(
		componentClass[0],
		`PropertyDeclaration:has(Identifier[name="_computedClass"]) CallExpression CallExpression:has(Identifier[name="hlm"]) StringLiteral`,
	);

	if (computedClass.length === 0) {
		return false;
	}

	// get the computed class value
	const classesString = computedClass[0].getText();
	const classesArray = classesString.split(' ');

	// check if the classes exist
	return classes.some((c) => classesArray.includes(c));
}

interface HasHelmClassesSchema {
	/**
	 * The name of the components that need to be checked.
	 */
	component: string;
	/**
	 * The classes that need to be checked for.
	 */
	classes: string[];
}

export function updateHelmClasses(
	tree: Tree,
	path: string,
	{ component, classesToAdd, classesToRemove }: UpdateHelmClassesSchema,
): string {
	const content = tree.read(path, 'utf-8');

	if (!content) {
		return;
	}

	const ast = tsquery.ast(content);

	// find the component class if it exists
	const componentClass = tsquery.query(ast, `ClassDeclaration:has(Identifier[name="${component}"])`);

	if (componentClass.length === 0) {
		return;
	}

	// try and find the _computedClass property string
	const computedClass = tsquery.query(
		componentClass[0],
		`PropertyDeclaration:has(Identifier[name="_computedClass"]) CallExpression CallExpression:has(Identifier[name="hlm"]) StringLiteral`,
	);

	if (computedClass.length === 0) {
		return;
	}

	// get the computed class value
	const classes = computedClass[0].getText();
	let modifiedClasses = classes.split(' ');

	// remove the classes that need to be removed
	modifiedClasses = modifiedClasses.filter((c) => !classesToRemove.includes(c));

	// add the classes that need to be added
	modifiedClasses = modifiedClasses.concat(classesToAdd);

	// update the classes
	const updatedClasses = modifiedClasses.join(' ');

	// replace the original classes with the updated classes
	const updatedContent = content.replace(classes, updatedClasses);

	tree.write(path, updatedContent);
}

interface UpdateHelmClassesSchema {
	/**
	 * The name of the components that need to be updated.
	 */
	component: string;
	/**
	 * The classes that need to be removed from the components.
	 */
	classesToRemove: string[];
	/**
	 * The classes that need to be added to the components.
	 */
	classesToAdd: string[];
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/utils/tsconfig.ts
```typescript
import { readJson, Tree } from '@nx/devkit';
import { getRootTsConfigPathInTree } from '@nx/js';
import type { CompilerOptions } from 'typescript';

interface TsConfig {
	compilerOptions?: CompilerOptions;
	include?: string[];
	exclude?: string[];
	references?: { path: string }[];
}

export function readTsConfigPathsFromTree(tree: Tree, tsConfig?: string) {
	tsConfig ??= getRootTsConfigPathInTree(tree);

	try {
		const { compilerOptions } = readJson(tree, tsConfig) as TsConfig;
		return compilerOptions?.paths ?? {};
	} catch {
		return {};
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/utils/version-utils.ts
```typescript
import { type Tree, readJson } from '@nx/devkit';
import { clean, coerce } from 'semver';

export function getInstalledPackageVersion(
	tree: Tree,
	packageName: string,
	defaultVersion?: string,
	raw = false,
): string | null {
	const pkgJson = readJson(tree, 'package.json');
	const installedPackageVersion = pkgJson.dependencies?.[packageName] || pkgJson.devDependencies?.[packageName];
	if (!installedPackageVersion && !defaultVersion) {
		return null;
	}

	if (!installedPackageVersion || installedPackageVersion === 'latest' || installedPackageVersion === 'next') {
		return clean(defaultVersion) ?? coerce(defaultVersion).version;
	}

	return (raw ? installedPackageVersion : clean(installedPackageVersion)) ?? coerce(installedPackageVersion).version;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/utils/visit-files.ts
```typescript
import { Tree, visitNotIgnoredFiles } from '@nx/devkit';

export function visitFiles(tree: Tree, dirPath: string, visitor: (path: string) => void): void {
	visitNotIgnoredFiles(tree, dirPath, (path) => {
		// if the file is part of the generators we want to skip as we don't want it updating the code that is performing the updates
		if (path.includes('libs/cli/src/generators')) {
			return;
		}
		visitor(path);
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/add-dependent-primitive.ts
```typescript
import { prompt } from 'enquirer';
import { getDependentPrimitives } from './primivite-deps';
import type { Primitive } from './primivites';

export const addDependentPrimitives = async (primitivesToCreate: string[], shouldPrompt?: boolean) => {
	const dependentPrimitives = getDependentPrimitives(primitivesToCreate as Primitive[]);

	for await (const primitive of dependentPrimitives) {
		const promptName = `install${primitive.charAt(0).toUpperCase() + primitive.slice(1)}`;
		const installPrimitive = shouldPrompt
			? (
					await prompt({
						type: 'confirm',
						name: promptName,
						initial: true,
						message: `Some of the primitives you are trying to install depend on the ${primitive} primitive. Do you want to add it to your project?`,
					})
				)[promptName]
			: true;
		if (installPrimitive) {
			primitivesToCreate.push(primitive);
		}
	}
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/compat.ts
```typescript
import { convertNxGenerator } from '@nx/devkit';
import hlmUIGenerator from './generator';
import type { HlmUIGeneratorSchema } from './schema';

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export default convertNxGenerator((tree: any, schema: HlmUIGeneratorSchema & { angularCli?: boolean }) =>
	hlmUIGenerator(tree, { ...schema, angularCli: true }),
);

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/generator.ts
```typescript
import { type GeneratorCallback, type Tree, runTasksInSerial } from '@nx/devkit';
import { prompt } from 'enquirer';
import { Config, getOrCreateConfig } from '../../utils/config';
import { addDependentPrimitives } from './add-dependent-primitive';
import type { HlmUIGeneratorSchema } from './schema';

export default async function hlmUIGenerator(tree: Tree, options: HlmUIGeneratorSchema & { angularCli?: boolean }) {
	const tasks: GeneratorCallback[] = [];
	const config = await getOrCreateConfig(tree, {
		componentsPath: options.directory,
	});
	const availablePrimitives: PrimitiveDefinitions = await import('./supported-ui-libraries.json').then(
		(m) => m.default,
	);
	const availablePrimitiveNames = [...Object.keys(availablePrimitives), 'collapsible', 'menubar', 'contextmenu'];
	let response: { primitives: string[] } = { primitives: [] };
	if (options.name && availablePrimitiveNames.includes(options.name)) {
		response.primitives.push(options.name);
	} else {
		response = await prompt({
			type: 'multiselect',
			required: true,
			name: 'primitives',
			message: 'Choose which primitives you want to copy',
			choices: ['all', ...availablePrimitiveNames.sort()],
		});
	}
	tasks.push(
		...(await createPrimitiveLibraries(response, availablePrimitiveNames, availablePrimitives, tree, options, config)),
	);

	return runTasksInSerial(...tasks);
}

export async function createPrimitiveLibraries(
	response: {
		primitives: string[];
	},
	availablePrimitiveNames: string[],
	availablePrimitives: PrimitiveDefinitions,
	tree: Tree,
	options: HlmUIGeneratorSchema & { angularCli?: boolean; installPeerDependencies?: boolean },
	config: Config,
) {
	const allPrimitivesSelected = response.primitives.includes('all');
	const primitivesToCreate = allPrimitivesSelected ? availablePrimitiveNames : response.primitives;
	const tasks: GeneratorCallback[] = [];

	if (!response.primitives.includes('all') || options.installPeerDependencies) {
		await addDependentPrimitives(primitivesToCreate, false);
	}
	await replaceContextAndMenuBar(primitivesToCreate, allPrimitivesSelected);

	if (primitivesToCreate.length === 1 && primitivesToCreate[0] === 'collapsible') {
		return tasks;
	}

	// Use Promise.all() to handle parallel execution of primitive library creation tasks
	const installTasks = await Promise.all(
		primitivesToCreate.map(async (primitiveName) => {
			if (primitiveName === 'collapsible') return;

			const internalName = availablePrimitives[primitiveName].internalName;
			const peerDependencies = removeHelmKeys(availablePrimitives[primitiveName].peerDependencies);
			const { generator } = await import(
				// eslint-disable-next-line @typescript-eslint/ban-ts-comment
				// @ts-ignore
				`./libs/${internalName}/generator`
			);
			return generator(tree, {
				internalName: '',
				publicName: '',
				primitiveName: '',
				peerDependencies,
				directory: options.directory ?? config.componentsPath,
				tags: options.tags,
				rootProject: options.rootProject,
				angularCli: options.angularCli,
			});
		}),
	);

	tasks.push(...installTasks.filter(Boolean));

	return tasks;
}

const replaceContextAndMenuBar = async (primtivesToCreate: string[], silent = false) => {
	const contextIndex = primtivesToCreate.indexOf('contextmenu');
	if (contextIndex >= 0) {
		if (!silent) {
			await prompt({
				type: 'confirm',
				name: 'contextMenu',
				message: 'The context menu is implemented as part of the menu-helm primitive. Adding menu primitive.',
			});
		}
		primtivesToCreate.splice(contextIndex, 1);
	}
	const menubarIndex = primtivesToCreate.indexOf('menubar');
	if (menubarIndex >= 0) {
		if (!silent) {
			await prompt({
				type: 'confirm',
				name: 'menubar',
				message: 'The menubar is implemented as part of the menu-helm primitive. Adding menu primitive.',
			});
		}
		primtivesToCreate.splice(menubarIndex, 1);
	}
};

const removeHelmKeys = (obj: Record<string, string>) =>
	Object.fromEntries(Object.entries(obj).filter(([key]) => !key.toLowerCase().includes('helm')));

interface PrimitiveDefinitions {
	[componentName: string]: {
		internalName: string;
		peerDependencies: Record<string, string>;
	};
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/primivite-deps.ts
```typescript
import type { Primitive } from './primivites';

export const primitiveDependencies: Record<Primitive, Primitive[]> = {
	accordion: ['icon'],
	alert: ['icon'],
	alertdialog: ['button'],
	aspectratio: [],
	avatar: [],
	badge: [],
	breadcrumb: ['icon'],
	button: [],
	calendar: ['button', 'icon'],
	card: [],
	carousel: [],
	checkbox: ['icon'],
	collapsible: [],
	command: ['button', 'icon'],
	contextmenu: [],
	datepicker: ['calendar', 'icon', 'popover'],
	dialog: [],
	formfield: [],
	hovercard: [],
	icon: [],
	input: ['formfield'],
	label: [],
	menu: ['icon'],
	menubar: [],
	pagination: ['button', 'icon'],
	popover: [],
	progress: [],
	radiogroup: [],
	scrollarea: [],
	select: ['icon', 'formfield'],
	separator: [],
	sheet: [],
	skeleton: [],
	sonner: ['icon'],
	spinner: [],
	switch: [],
	table: [],
	tabs: [],
	toggle: [],
	tooltip: [],
};

export const getDependentPrimitives = (primitives: Primitive[]): Primitive[] => {
	const dependentPrimitives = new Set<Primitive>();

	for (const primitive of primitives) {
		const deps = primitiveDependencies[primitive] ?? [];
		for (const dep of deps) {
			if (!primitives.includes(dep)) {
				// only add the dependent primitive if it's not already in the list of primitives to create
				dependentPrimitives.add(dep);
			}
		}
	}

	return Array.from(dependentPrimitives);
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/primivites.ts
```typescript
export type Primitive =
	| 'accordion'
	| 'alert'
	| 'alertdialog'
	| 'aspectratio'
	| 'avatar'
	| 'badge'
	| 'breadcrumb'
	| 'button'
	| 'calendar'
	| 'card'
	| 'carousel'
	| 'checkbox'
	| 'collapsible'
	| 'command'
	| 'contextmenu'
	| 'datepicker'
	| 'dialog'
	| 'formfield'
	| 'hovercard'
	| 'icon'
	| 'input'
	| 'label'
	| 'menu'
	| 'menubar'
	| 'pagination'
	| 'popover'
	| 'progress'
	| 'radiogroup'
	| 'scrollarea'
	| 'select'
	| 'separator'
	| 'sheet'
	| 'skeleton'
	| 'sonner'
	| 'spinner'
	| 'switch'
	| 'table'
	| 'tabs'
	| 'toggle'
	| 'tooltip';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/schema.d.ts
```typescript
export interface HlmUIGeneratorSchema {
	name?: string;
	directory?: string;
	rootProject?: boolean;
	tags?: string;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/schema.json
```json
{
	"$schema": "http://json-schema.org/draft-07/schema",
	"$id": "HlmUIGeneratorSchema",
	"title": "",
	"type": "object",
	"properties": {
		"name": {
			"type": "string",
			"description": "Primitive name",
			"$default": {
				"$source": "argv",
				"index": 0
			}
		},
		"directory": {
			"type": "string",
			"description": "A directory where the libraries are placed.",
			"x-priority": "important"
		},
		"tags": {
			"type": "string",
			"description": "Add tags to the library (used for linting)."
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/supported-ui-libraries.json
```json
{
	"accordion": {
		"internalName": "ui-accordion-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@ng-icons/core": ">=29.0.0",
			"@ng-icons/lucide": ">=29.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
			"clsx": "^2.1.1"
		}
	},
	"alert": {
		"internalName": "ui-alert-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
			"class-variance-authority": "^0.7.0",
			"clsx": "^2.1.1"
		}
	},
	"alertdialog": {
		"internalName": "ui-alert-dialog-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"@spartan-ng/ui-button-helm": "0.0.1-alpha.381",
			"clsx": "^2.1.1"
		}
	},
	"aspectratio": {
		"internalName": "ui-aspect-ratio-helm",
		"peerDependencies": {
			"@angular/cdk": ">=19.0.0",
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"clsx": "^2.1.1"
		}
	},
	"avatar": {
		"internalName": "ui-avatar-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"class-variance-authority": "^0.7.0",
			"clsx": "^2.1.1"
		}
	},
	"badge": {
		"internalName": "ui-badge-helm",
		"peerDependencies": {
			"@angular/cdk": ">=19.0.0",
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"class-variance-authority": "^0.7.0",
			"clsx": "^2.1.1"
		}
	},
	"breadcrumb": {
		"internalName": "ui-breadcrumb-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@angular/router": ">=19.0.0",
			"@ng-icons/core": ">=29.0.0",
			"@ng-icons/lucide": ">=29.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
			"clsx": "^2.1.1"
		}
	},
	"button": {
		"internalName": "ui-button-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"class-variance-authority": "^0.7.0",
			"clsx": "^2.1.1"
		}
	},
	"calendar": {
		"internalName": "ui-calendar-helm",
		"peerDependencies": {
			"@angular/cdk": ">=19.0.0",
			"@angular/core": ">=19.0.0",
			"@ng-icons/core": ">=29.0.0",
			"@ng-icons/lucide": ">=29.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"@spartan-ng/ui-button-helm": "0.0.1-alpha.381",
			"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
			"clsx": "^2.1.1"
		}
	},
	"card": {
		"internalName": "ui-card-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"class-variance-authority": "^0.7.0",
			"clsx": "^2.1.1"
		}
	},
	"command": {
		"internalName": "ui-command-helm",
		"peerDependencies": {
			"@angular/cdk": ">=19.0.0",
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"@spartan-ng/ui-button-helm": "0.0.1-alpha.381",
			"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
			"clsx": "^2.1.1"
		}
	},
	"datepicker": {
		"internalName": "ui-date-picker-helm",
		"peerDependencies": {
			"@angular/cdk": ">=19.0.0",
			"@angular/core": ">=19.0.0",
			"@angular/forms": ">=19.0.0",
			"@ng-icons/core": ">=29.0.0",
			"@ng-icons/lucide": ">=29.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"@spartan-ng/ui-calendar-helm": "0.0.1-alpha.381",
			"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
			"@spartan-ng/ui-popover-helm": "0.0.1-alpha.381",
			"clsx": "^2.1.1"
		}
	},
	"dialog": {
		"internalName": "ui-dialog-helm",
		"peerDependencies": {
			"@angular/cdk": ">=19.0.0",
			"@angular/common": ">=19.0.0",
			"@angular/core": ">=19.0.0",
			"@ng-icons/core": ">=29.0.0",
			"@ng-icons/lucide": ">=29.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
			"clsx": "^2.1.1"
		}
	},
	"icon": {
		"internalName": "ui-icon-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0"
		}
	},
	"input": {
		"internalName": "ui-input-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@angular/forms": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"class-variance-authority": "^0.7.0",
			"clsx": "^2.1.1"
		}
	},
	"label": {
		"internalName": "ui-label-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"class-variance-authority": "^0.7.0",
			"clsx": "^2.1.1"
		}
	},
	"menu": {
		"internalName": "ui-menu-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@ng-icons/core": ">=29.0.0",
			"@ng-icons/lucide": ">=29.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
			"class-variance-authority": "^0.7.0",
			"clsx": "^2.1.1"
		}
	},
	"popover": {
		"internalName": "ui-popover-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"clsx": "^2.1.1"
		}
	},
	"progress": {
		"internalName": "ui-progress-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"clsx": "^2.1.1"
		}
	},
	"radiogroup": {
		"internalName": "ui-radio-group-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"clsx": "^2.1.1"
		}
	},
	"scrollarea": {
		"internalName": "ui-scroll-area-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"clsx": "^2.1.1",
			"ngx-scrollbar": ">=16.0.0"
		}
	},
	"separator": {
		"internalName": "ui-separator-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"clsx": "^2.1.1"
		}
	},
	"sheet": {
		"internalName": "ui-sheet-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@ng-icons/core": ">=29.0.0",
			"@ng-icons/lucide": ">=29.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
			"class-variance-authority": "^0.7.0",
			"clsx": "^2.1.1"
		}
	},
	"skeleton": {
		"internalName": "ui-skeleton-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"clsx": "^2.1.1"
		}
	},
	"spinner": {
		"internalName": "ui-spinner-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"class-variance-authority": "^0.7.0",
			"clsx": "^2.1.1"
		}
	},
	"switch": {
		"internalName": "ui-switch-helm",
		"peerDependencies": {
			"@angular/cdk": ">=19.0.0",
			"@angular/core": ">=19.0.0",
			"@angular/forms": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"clsx": "^2.1.1"
		}
	},
	"tabs": {
		"internalName": "ui-tabs-helm",
		"peerDependencies": {
			"@angular/cdk": ">=19.0.0",
			"@angular/core": ">=19.0.0",
			"@ng-icons/core": ">=29.0.0",
			"@ng-icons/lucide": ">=29.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"@spartan-ng/ui-button-helm": "0.0.1-alpha.381",
			"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
			"class-variance-authority": "^0.7.0",
			"clsx": "^2.1.1"
		}
	},
	"toggle": {
		"internalName": "ui-toggle-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"class-variance-authority": "^0.7.0",
			"clsx": "^2.1.1"
		}
	},
	"toggle-group": {
		"internalName": "ui-toggle-group-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.436",
			"class-variance-authority": "^0.7.0",
			"clsx": "^2.1.1"
		}
	},
	"typography": {
		"internalName": "ui-typography-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"clsx": "^2.1.1"
		}
	},
	"table": {
		"internalName": "ui-table-helm",
		"peerDependencies": {
			"@angular/common": ">=19.0.0",
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"clsx": "^2.1.1"
		}
	},
	"hovercard": {
		"internalName": "ui-hover-card-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"clsx": "^2.1.1"
		}
	},
	"checkbox": {
		"internalName": "ui-checkbox-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@angular/forms": ">=19.0.0",
			"@ng-icons/core": ">=29.0.0",
			"@ng-icons/lucide": ">=29.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
			"clsx": "^2.1.1"
		}
	},
	"tooltip": {
		"internalName": "ui-tooltip-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451"
		}
	},
	"pagination": {
		"internalName": "ui-pagination-helm",
		"peerDependencies": {
			"@angular/cdk": ">=19.0.0",
			"@angular/core": ">=19.0.0",
			"@angular/forms": ">=19.0.0",
			"@angular/router": ">=19.0.0",
			"@ng-icons/core": ">=29.0.0",
			"@ng-icons/lucide": ">=29.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"@spartan-ng/ui-button-helm": "0.0.1-alpha.381",
			"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
			"@spartan-ng/ui-select-helm": "0.0.1-alpha.381",
			"class-variance-authority": "^0.7.0",
			"clsx": "^2.1.1"
		}
	},
	"carousel": {
		"internalName": "ui-carousel-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@ng-icons/core": ">=29.0.0",
			"@ng-icons/lucide": ">=29.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"@spartan-ng/ui-button-helm": "0.0.1-alpha.381",
			"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
			"clsx": "^2.1.1",
			"embla-carousel-angular": "19.0.0"
		}
	},
	"select": {
		"internalName": "ui-select-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@ng-icons/core": ">=29.0.0",
			"@ng-icons/lucide": ">=29.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
			"class-variance-authority": "^0.7.0",
			"clsx": "^2.1.1"
		}
	},
	"sonner": {
		"internalName": "ui-sonner-helm",
		"peerDependencies": {
			"@angular/common": "^18.1.0",
			"@angular/core": "^18.1.0",
			"@ng-icons/lucide": "^26.3.0",
			"@spartan-ng/brain": "0.0.1-alpha.381",
			"clsx": "^2.1.1",
			"ngx-sonner": "^3.0.0"
		}
	},
	"formfield": {
		"internalName": "ui-form-field-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451"
		}
	},
	"slider": {
		"internalName": "ui-slider-helm",
		"peerDependencies": {
			"@angular/core": ">=19.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"clsx": "^2.1.1"
		}
	},
	"togglegroup": {
		"internalName": "ui-toggle-group-helm",
		"peerDependencies": {
			"@angular/core": ">=18.0.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"class-variance-authority": "^0.7.0",
			"clsx": "^2.1.1"
		}
	},
	"inputotp": {
		"internalName": "ui-input-otp-helm",
		"peerDependencies": {
			"@angular/cdk": "19.2.2",
			"@angular/core": ">=19.0.0",
			"@ng-icons/core": "29.10.0",
			"@ng-icons/lucide": "30.3.0",
			"@spartan-ng/brain": "0.0.1-alpha.451",
			"@spartan-ng/ui-icon-helm": "0.0.1-alpha.381",
			"clsx": "^2.1.1"
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-pagination-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'pagination',
		internalName: 'ui-pagination-helm',
		publicName: 'ui-pagination-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-pagination-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';

import { HlmNumberedPaginationComponent } from './lib/hlm-numbered-pagination.component';
import { HlmPaginationContentDirective } from './lib/hlm-pagination-content.directive';
import { HlmPaginationEllipsisComponent } from './lib/hlm-pagination-ellipsis.component';
import { HlmPaginationItemDirective } from './lib/hlm-pagination-item.directive';
import { HlmPaginationLinkDirective } from './lib/hlm-pagination-link.directive';
import { HlmPaginationNextComponent } from './lib/hlm-pagination-next.component';
import { HlmPaginationPreviousComponent } from './lib/hlm-pagination-previous.component';
import { HlmPaginationDirective } from './lib/hlm-pagination.directive';

export * from './lib/hlm-numbered-pagination.component';
export * from './lib/hlm-pagination-content.directive';
export * from './lib/hlm-pagination-ellipsis.component';
export * from './lib/hlm-pagination-item.directive';
export * from './lib/hlm-pagination-link.directive';
export * from './lib/hlm-pagination-next.component';
export * from './lib/hlm-pagination-previous.component';
export * from './lib/hlm-pagination.directive';

export const HlmPaginationImports = [
	HlmPaginationDirective,
	HlmPaginationContentDirective,
	HlmPaginationItemDirective,
	HlmPaginationLinkDirective,
	HlmPaginationPreviousComponent,
	HlmPaginationNextComponent,
	HlmPaginationEllipsisComponent,
	HlmNumberedPaginationComponent,
] as const;

@NgModule({
	imports: [...HlmPaginationImports],
	exports: [...HlmPaginationImports],
})
export class HlmPaginationModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-pagination-helm/files/lib/hlm-numbered-pagination.component.ts.template
```
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import {
	ChangeDetectionStrategy,
	Component,
	booleanAttribute,
	computed,
	input,
	model,
	numberAttribute,
	untracked,
} from '@angular/core';
import { FormsModule } from '@angular/forms';
import { BrnSelectImports } from '@spartan-ng/brain/select';
import { HlmSelectImports } from '@spartan-ng/ui-select-helm';
import { HlmPaginationContentDirective } from './hlm-pagination-content.directive';
import { HlmPaginationEllipsisComponent } from './hlm-pagination-ellipsis.component';
import { HlmPaginationItemDirective } from './hlm-pagination-item.directive';
import { HlmPaginationLinkDirective } from './hlm-pagination-link.directive';
import { HlmPaginationNextComponent } from './hlm-pagination-next.component';
import { HlmPaginationPreviousComponent } from './hlm-pagination-previous.component';
import { HlmPaginationDirective } from './hlm-pagination.directive';

@Component({
	selector: 'hlm-numbered-pagination',
	template: `
		<div class="flex items-center justify-between gap-2 px-4 py-2">
			<div class="flex items-center gap-1 text-nowrap text-sm text-gray-600">
				<b>{{ totalItems() }}</b>
				total items |
				<b>{{ pages().length }}</b>
				pages
			</div>

			<nav hlmPagination>
				<ul hlmPaginationContent>
					@if (showEdges() && !isFirstPageActive()) {
						<li hlmPaginationItem (click)="goToPrevious()">
							<hlm-pagination-previous />
						</li>
					}

					@for (page of pages(); track page) {
						<li hlmPaginationItem>
							@if (page === '...') {
								<hlm-pagination-ellipsis />
							} @else {
								<a hlmPaginationLink [isActive]="currentPage() === page" (click)="currentPage.set(page)">
									{{ page }}
								</a>
							}
						</li>
					}

					@if (showEdges() && !isLastPageActive()) {
						<li hlmPaginationItem (click)="goToNext()">
							<hlm-pagination-next />
						</li>
					}
				</ul>
			</nav>

			<!-- Show Page Size selector -->
			<brn-select [(ngModel)]="itemsPerPage" class="ml-auto" placeholder="Page size">
				<hlm-select-trigger class="w-fit">
					<hlm-select-value />
				</hlm-select-trigger>
				<hlm-select-content>
					@for (pageSize of pageSizesWithCurrent(); track pageSize) {
						<hlm-option [value]="pageSize">{{ pageSize }} / page</hlm-option>
					}
				</hlm-select-content>
			</brn-select>
		</div>
	`,
	imports: [
		FormsModule,
		HlmPaginationDirective,
		HlmPaginationContentDirective,
		HlmPaginationItemDirective,
		HlmPaginationPreviousComponent,
		HlmPaginationNextComponent,
		HlmPaginationLinkDirective,
		HlmPaginationEllipsisComponent,
		BrnSelectImports,
		HlmSelectImports,
	],
	changeDetection: ChangeDetectionStrategy.OnPush,
})
export class HlmNumberedPaginationComponent {
	/**
	 * The current (active) page.
	 */
	public readonly currentPage = model.required<number>();

	/**
	 * The number of items per paginated page.
	 */
	public readonly itemsPerPage = model.required<number>();

	/**
	 * The total number of items in the collection. Only useful when
	 * doing server-side paging, where the collection size is limited
	 * to a single page returned by the server API.
	 */
	public readonly totalItems = input.required<number, NumberInput>({
		transform: numberAttribute,
	});

	/**
	 * The number of page links to show.
	 */
	public readonly maxSize = input<number, NumberInput>(7, {
		transform: numberAttribute,
	});

	/**
	 * Show the first and last page buttons.
	 */
	public readonly showEdges = input<boolean, BooleanInput>(true, {
		transform: booleanAttribute,
	});

	/**
	 * The page sizes to show.
	 * Defaults to [10, 20, 50, 100]
	 */
	public readonly pageSizes = input<number[]>([10, 20, 50, 100]);

	protected readonly pageSizesWithCurrent = computed(() => {
		const pageSizes = this.pageSizes();
		return pageSizes.includes(this.itemsPerPage())
			? pageSizes // if current page size is included, return the same array
			: [...pageSizes, this.itemsPerPage()].sort((a, b) => a - b); // otherwise, add current page size and sort the array
	});

	protected readonly isFirstPageActive = computed(() => this.currentPage() === 1);
	protected readonly isLastPageActive = computed(() => this.currentPage() === this.lastPageNumber());

	protected readonly lastPageNumber = computed(() => {
		if (this.totalItems() < 1) {
			// when there are 0 or fewer (an error case) items, there are no "pages" as such,
			// but it makes sense to consider a single, empty page as the last page.
			return 1;
		}
		return Math.ceil(this.totalItems() / this.itemsPerPage());
	});

	protected readonly pages = computed(() => {
		const correctedCurrentPage = outOfBoundCorrection(this.totalItems(), this.itemsPerPage(), this.currentPage());

		if (correctedCurrentPage !== this.currentPage()) {
			// update the current page
			untracked(() => this.currentPage.set(correctedCurrentPage));
		}

		return createPageArray(correctedCurrentPage, this.itemsPerPage(), this.totalItems(), this.maxSize());
	});

	protected goToPrevious(): void {
		this.currentPage.set(this.currentPage() - 1);
	}

	protected goToNext(): void {
		this.currentPage.set(this.currentPage() + 1);
	}

	protected goToFirst(): void {
		this.currentPage.set(1);
	}

	protected goToLast(): void {
		this.currentPage.set(this.lastPageNumber());
	}
}

type Page = number | '...';

/**
 * Checks that the instance.currentPage property is within bounds for the current page range.
 * If not, return a correct value for currentPage, or the current value if OK.
 *
 * Copied from 'ngx-pagination' package
 */
function outOfBoundCorrection(totalItems: number, itemsPerPage: number, currentPage: number): number {
	const totalPages = Math.ceil(totalItems / itemsPerPage);
	if (totalPages < currentPage && 0 < totalPages) {
		return totalPages;
	}

	if (currentPage < 1) {
		return 1;
	}

	return currentPage;
}

/**
 * Returns an array of Page objects to use in the pagination controls.
 *
 * Copied from 'ngx-pagination' package
 */
function createPageArray(
	currentPage: number,
	itemsPerPage: number,
	totalItems: number,
	paginationRange: number,
): Page[] {
	// paginationRange could be a string if passed from attribute, so cast to number.
	paginationRange = +paginationRange;
	const pages: Page[] = [];

	// Return 1 as default page number
	// Make sense to show 1 instead of empty when there are no items
	const totalPages = Math.max(Math.ceil(totalItems / itemsPerPage), 1);
	const halfWay = Math.ceil(paginationRange / 2);

	const isStart = currentPage <= halfWay;
	const isEnd = totalPages - halfWay < currentPage;
	const isMiddle = !isStart && !isEnd;

	const ellipsesNeeded = paginationRange < totalPages;
	let i = 1;

	while (i <= totalPages && i <= paginationRange) {
		let label: number | '...';
		const pageNumber = calculatePageNumber(i, currentPage, paginationRange, totalPages);
		const openingEllipsesNeeded = i === 2 && (isMiddle || isEnd);
		const closingEllipsesNeeded = i === paginationRange - 1 && (isMiddle || isStart);
		if (ellipsesNeeded && (openingEllipsesNeeded || closingEllipsesNeeded)) {
			label = '...';
		} else {
			label = pageNumber;
		}
		pages.push(label);
		i++;
	}

	return pages;
}

/**
 * Given the position in the sequence of pagination links [i],
 * figure out what page number corresponds to that position.
 *
 * Copied from 'ngx-pagination' package
 */
function calculatePageNumber(i: number, currentPage: number, paginationRange: number, totalPages: number) {
	const halfWay = Math.ceil(paginationRange / 2);
	if (i === paginationRange) {
		return totalPages;
	}

	if (i === 1) {
		return i;
	}

	if (paginationRange < totalPages) {
		if (totalPages - halfWay < currentPage) {
			return totalPages - paginationRange + i;
		}
		if (halfWay < currentPage) {
			return currentPage - halfWay + i;
		}
		return i;
	}

	return i;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-pagination-helm/files/lib/hlm-pagination-content.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import { ClassValue } from 'clsx';

export const paginationContentVariants = cva('flex flex-row items-center gap-1', {
	variants: {},
	defaultVariants: {},
});
export type PaginationContentVariants = VariantProps<typeof paginationContentVariants>;

@Directive({
	selector: '[hlmPaginationContent]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmPaginationContentDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm(paginationContentVariants(), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-pagination-helm/files/lib/hlm-pagination-ellipsis.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideEllipsis } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-pagination-ellipsis',
	imports: [NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideEllipsis })],
	template: `
		<span [class]="_computedClass()">
			<ng-icon hlm size="sm" name="lucideEllipsis" />
			<span class="sr-only">More pages</span>
		</span>
	`,
})
export class HlmPaginationEllipsisComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() => hlm('flex h-9 w-9 items-center justify-center', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-pagination-helm/files/lib/hlm-pagination-item.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import { ClassValue } from 'clsx';

export const paginationItemVariants = cva('', {
	variants: {},
	defaultVariants: {},
});

export type PaginationItemVariants = VariantProps<typeof paginationItemVariants>;

@Directive({
	selector: '[hlmPaginationItem]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmPaginationItemDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() => hlm(paginationItemVariants(), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-pagination-helm/files/lib/hlm-pagination-link.directive.ts.template
```
import { BooleanInput } from '@angular/cdk/coercion';
import { Directive, booleanAttribute, computed, input } from '@angular/core';
import { RouterLink } from '@angular/router';
import { hlm } from '@spartan-ng/brain/core';
import { type ButtonVariants, buttonVariants } from '@spartan-ng/ui-button-helm';
import { type VariantProps, cva } from 'class-variance-authority';
import { ClassValue } from 'clsx';

export const paginationLinkVariants = cva('', {
	variants: {},
	defaultVariants: {},
});
export type PaginationLinkVariants = VariantProps<typeof paginationLinkVariants>;

@Directive({
	selector: '[hlmPaginationLink]',
	standalone: true,
	hostDirectives: [
		{
			directive: RouterLink,
			inputs: [
				'target',
				'queryParams',
				'fragment',
				'queryParamsHandling',
				'state',
				'info',
				'relativeTo',
				'preserveFragment',
				'skipLocationChange',
				'replaceUrl',
				'routerLink: link',
			],
		},
	],
	host: {
		'[class]': '_computedClass()',
		'[attr.aria-current]': 'isActive() ? "page" : null',
	},
})
export class HlmPaginationLinkDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly isActive = input<boolean, BooleanInput>(false, { transform: booleanAttribute });
	public readonly size = input<ButtonVariants['size']>('icon');
	public readonly link = input<RouterLink['routerLink']>();

	protected readonly _computedClass = computed(() =>
		hlm(
			paginationLinkVariants(),
			this.link() === undefined ? 'cursor-pointer' : '',
			buttonVariants({
				variant: this.isActive() ? 'outline' : 'ghost',
				size: this.size(),
			}),
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-pagination-helm/files/lib/hlm-pagination-next.component.ts.template
```
import { BooleanInput } from '@angular/cdk/coercion';
import { booleanAttribute, Component, computed, input } from '@angular/core';
import { RouterLink } from '@angular/router';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronRight } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { ButtonVariants } from '@spartan-ng/ui-button-helm';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import { ClassValue } from 'clsx';
import { HlmPaginationLinkDirective } from './hlm-pagination-link.directive';

@Component({
	selector: 'hlm-pagination-next',
	imports: [HlmPaginationLinkDirective, NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideChevronRight })],
	template: `
		<a
			[class]="_computedClass()"
			hlmPaginationLink
			[link]="link()"
			[queryParams]="queryParams()"
			[queryParamsHandling]="queryParamsHandling()"
			[size]="size()"
			[attr.aria-label]="ariaLabel()"
		>
			<span [class.sr-only]="iconOnly()">{{ text() }}</span>
			<ng-icon hlm size="sm" name="lucideChevronRight" />
		</a>
	`,
})
export class HlmPaginationNextComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly link = input<RouterLink['routerLink']>();
	public readonly queryParams = input<RouterLink['queryParams']>();
	public readonly queryParamsHandling = input<RouterLink['queryParamsHandling']>();

	public readonly ariaLabel = input<string>('Go to next page', { alias: 'aria-label' });
	public readonly text = input<string>('Next');
	public readonly iconOnly = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	protected readonly size = computed<ButtonVariants['size']>(() => (this.iconOnly() ? 'icon' : 'default'));

	protected readonly _computedClass = computed(() => hlm('gap-1', !this.iconOnly() ? 'pr-2.5' : '', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-pagination-helm/files/lib/hlm-pagination-previous.component.ts.template
```
import { BooleanInput } from '@angular/cdk/coercion';
import { booleanAttribute, Component, computed, input } from '@angular/core';
import { RouterLink } from '@angular/router';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronLeft } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { ButtonVariants } from '@spartan-ng/ui-button-helm';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import { ClassValue } from 'clsx';
import { HlmPaginationLinkDirective } from './hlm-pagination-link.directive';

@Component({
	selector: 'hlm-pagination-previous',
	imports: [HlmPaginationLinkDirective, NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideChevronLeft })],
	template: `
		<a
			[class]="_computedClass()"
			hlmPaginationLink
			[link]="link()"
			[queryParams]="queryParams()"
			[queryParamsHandling]="queryParamsHandling()"
			[size]="size()"
			[attr.aria-label]="ariaLabel()"
		>
			<ng-icon hlm size="sm" name="lucideChevronLeft" />
			<span [class.sr-only]="iconOnly()">{{ text() }}</span>
		</a>
	`,
})
export class HlmPaginationPreviousComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly link = input<RouterLink['routerLink']>();
	public readonly queryParams = input<RouterLink['queryParams']>();
	public readonly queryParamsHandling = input<RouterLink['queryParamsHandling']>();

	public readonly ariaLabel = input<string>('Go to previous page', { alias: 'aria-label' });
	public readonly text = input<string>('Previous');
	public readonly iconOnly = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	protected readonly size = computed<ButtonVariants['size']>(() => (this.iconOnly() ? 'icon' : 'default'));

	protected readonly _computedClass = computed(() => hlm('gap-1', !this.iconOnly() ? 'pl-2.5' : '', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-pagination-helm/files/lib/hlm-pagination.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const paginationVariants = cva('mx-auto flex w-full justify-center', {
	variants: {},
	defaultVariants: {},
});
export type PaginationVariants = VariantProps<typeof paginationVariants>;

@Directive({
	selector: '[hlmPagination]',
	standalone: true,
	host: {
		role: 'navigation',
		'[class]': '_computedClass()',
		'[attr.aria-label]': 'ariaLabel()',
	},
})
export class HlmPaginationDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	public readonly ariaLabel = input<string>('pagination', { alias: 'aria-label' });

	protected readonly _computedClass = computed(() => hlm(paginationVariants(), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-table-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'table',
		internalName: 'ui-table-helm',
		publicName: 'ui-table-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-table-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';

import { HlmCaptionComponent } from './lib/hlm-caption.component';
import { HlmTableComponent } from './lib/hlm-table.component';
import { HlmTableDirective } from './lib/hlm-table.directive';
import { HlmTdComponent } from './lib/hlm-td.component';
import { HlmThComponent } from './lib/hlm-th.component';
import { HlmTrowComponent } from './lib/hlm-trow.component';

export { HlmCaptionComponent } from './lib/hlm-caption.component';
export { HlmTableComponent } from './lib/hlm-table.component';
export { HlmTableDirective } from './lib/hlm-table.directive';
export { HlmTdComponent } from './lib/hlm-td.component';
export { HlmThComponent } from './lib/hlm-th.component';
export { HlmTrowComponent } from './lib/hlm-trow.component';

export const HlmTableImports = [
	HlmTableComponent,
	HlmTableDirective,
	HlmCaptionComponent,
	HlmThComponent,
	HlmTdComponent,
	HlmTrowComponent,
] as const;

@NgModule({
	imports: [...HlmTableImports],
	exports: [...HlmTableImports],
})
export class HlmTableModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-table-helm/files/lib/hlm-caption.component.ts.template
```
import {
	ChangeDetectionStrategy,
	Component,
	ViewEncapsulation,
	booleanAttribute,
	computed,
	effect,
	inject,
	input,
	untracked,
} from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';
import { HlmTableComponent } from './hlm-table.component';

let captionIdSequence = 0;

@Component({
	selector: 'hlm-caption',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		'[id]': 'id()',
	},
	template: `
		<ng-content />
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class HlmCaptionComponent {
	private readonly _table = inject(HlmTableComponent, { optional: true });

	protected readonly id = input<string | null | undefined>(`${captionIdSequence++}`);

	public readonly hidden = input(false, { transform: booleanAttribute });
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'text-center block mt-4 text-sm text-muted-foreground',
			this.hidden() ? 'sr-only' : 'order-last',
			this.userClass(),
		),
	);

	constructor() {
		effect(() => {
			const id = this.id();
			untracked(() => {
				if (!this._table) return;
				this._table.labeledBy.set(id);
			});
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-table-helm/files/lib/hlm-table.component.ts.template
```
import {
	ChangeDetectionStrategy,
	Component,
	ViewEncapsulation,
	computed,
	effect,
	input,
	signal,
	untracked,
} from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-table',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		role: 'table',
		'[attr.aria-labelledby]': 'labeledBy()',
	},
	template: `
		<ng-content />
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class HlmTableComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm('flex flex-col text-sm [&_hlm-trow:last-child]:border-0', this.userClass()),
	);

	// we aria-labelledby to be settable from outside but use the input by default.
	public readonly _labeledByInput = input<string | null | undefined>(undefined, { alias: 'aria-labelledby' });
	public readonly labeledBy = signal<string | null | undefined>(undefined);

	constructor() {
		effect(() => {
			const labeledBy = this._labeledByInput();
			untracked(() => {
				this.labeledBy.set(labeledBy);
			});
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-table-helm/files/lib/hlm-table.directive.ts.template
```
import { Directive } from '@angular/core';
import { injectTableClassesSettable } from '@spartan-ng/brain/core';

@Directive({ standalone: true, selector: '[hlmTable],brn-table[hlm]' })
export class HlmTableDirective {
	private readonly _tableClassesSettable = injectTableClassesSettable({ host: true, optional: true });

	constructor() {
		this._tableClassesSettable?.setTableClasses({
			table: 'flex flex-col text-sm [&_cdk-row:last-child]:border-0',
			headerRow:
				'flex min-w-[100%] w-fit border-b border-border [&.cdk-table-sticky]:bg-background ' +
				'[&.cdk-table-sticky>*]:z-[101] [&.cdk-table-sticky]:before:z-0 [&.cdk-table-sticky]:before:block [&.cdk-table-sticky]:hover:before:bg-muted/50 [&.cdk-table-sticky]:before:absolute [&.cdk-table-sticky]:before:inset-0',
			bodyRow:
				'flex min-w-[100%] w-fit border-b border-border transition-[background-color] hover:bg-muted/50 [&:has([role=checkbox][aria-checked=true])]:bg-muted',
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-table-helm/files/lib/hlm-td.component.ts.template
```
import { NgTemplateOutlet } from '@angular/common';
import {
	ChangeDetectionStrategy,
	Component,
	ViewEncapsulation,
	booleanAttribute,
	computed,
	inject,
	input,
} from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnColumnDefComponent } from '@spartan-ng/brain/table';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-td',
	imports: [NgTemplateOutlet],
	host: {
		'[class]': '_computedClass()',
	},
	template: `
		<ng-template #content>
			<ng-content />
		</ng-template>
		@if (truncate()) {
			<span class="flex-1 truncate">
				<ng-container [ngTemplateOutlet]="content" />
			</span>
		} @else {
			<ng-container [ngTemplateOutlet]="content" />
		}
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class HlmTdComponent {
	private readonly _columnDef? = inject(BrnColumnDefComponent, { optional: true });
	public readonly truncate = input(false, { transform: booleanAttribute });

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm('flex flex-none p-4 items-center [&:has([role=checkbox])]:pr-0', this._columnDef?.class(), this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-table-helm/files/lib/hlm-th.component.ts.template
```
import { NgTemplateOutlet } from '@angular/common';
import {
	ChangeDetectionStrategy,
	Component,
	ViewEncapsulation,
	booleanAttribute,
	computed,
	inject,
	input,
} from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnColumnDefComponent } from '@spartan-ng/brain/table';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-th',
	imports: [NgTemplateOutlet],
	host: {
		'[class]': '_computedClass()',
	},
	template: `
		<ng-template #content>
			<ng-content />
		</ng-template>
		@if (truncate()) {
			<span class="flex-1 truncate">
				<ng-container [ngTemplateOutlet]="content" />
			</span>
		} @else {
			<ng-container [ngTemplateOutlet]="content" />
		}
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class HlmThComponent {
	private readonly _columnDef? = inject(BrnColumnDefComponent, { optional: true });
	public readonly truncate = input(false, { transform: booleanAttribute });

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'flex flex-none h-12 px-4 text-sm items-center font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0',
			this._columnDef?.class(),
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-table-helm/files/lib/hlm-trow.component.ts.template
```
import { ChangeDetectionStrategy, Component, ViewEncapsulation, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-trow',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		role: 'row',
	},
	template: `
		<ng-content />
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class HlmTrowComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'flex flex border-b border-border transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-tabs-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'tabs',
		internalName: 'ui-tabs-helm',
		publicName: 'ui-tabs-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-tabs-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';

import { HlmTabsContentDirective } from './lib/hlm-tabs-content.directive';
import { HlmTabsListComponent } from './lib/hlm-tabs-list.component';
import { HlmTabsPaginatedListComponent } from './lib/hlm-tabs-paginated-list.component';
import { HlmTabsTriggerDirective } from './lib/hlm-tabs-trigger.directive';
import { HlmTabsComponent } from './lib/hlm-tabs.component';

export * from './lib/hlm-tabs-content.directive';
export * from './lib/hlm-tabs-list.component';
export * from './lib/hlm-tabs-paginated-list.component';
export * from './lib/hlm-tabs-trigger.directive';
export * from './lib/hlm-tabs.component';

export const HlmTabsImports = [
	HlmTabsComponent,
	HlmTabsListComponent,
	HlmTabsTriggerDirective,
	HlmTabsContentDirective,
	HlmTabsPaginatedListComponent,
] as const;

@NgModule({
	imports: [...HlmTabsImports],
	exports: [...HlmTabsImports],
})
export class HlmTabsModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-tabs-helm/files/lib/hlm-tabs-content.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnTabsContentDirective } from '@spartan-ng/brain/tabs';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmTabsContent]',
	standalone: true,
	hostDirectives: [{ directive: BrnTabsContentDirective, inputs: ['brnTabsContent: hlmTabsContent'] }],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmTabsContentDirective {
	public readonly contentFor = input.required<string>({ alias: 'hlmTabsContent' });

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-tabs-helm/files/lib/hlm-tabs-list.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnTabsListDirective } from '@spartan-ng/brain/tabs';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const listVariants = cva(
	'inline-flex items-center justify-center rounded-md bg-muted p-1 text-muted-foreground',
	{
		variants: {
			orientation: {
				horizontal: 'h-10 space-x-1',
				vertical: 'mt-2 flex-col h-fit space-y-1',
			},
		},
		defaultVariants: {
			orientation: 'horizontal',
		},
	},
);
type ListVariants = VariantProps<typeof listVariants>;

@Component({
	selector: 'hlm-tabs-list',
	standalone: true,
	hostDirectives: [BrnTabsListDirective],
	template: '<ng-content/>',
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmTabsListComponent {
	public readonly orientation = input<ListVariants['orientation']>('horizontal');

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(listVariants({ orientation: this.orientation() }), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-tabs-helm/files/lib/hlm-tabs-paginated-list.component.ts.template
```
import { CdkObserveContent } from '@angular/cdk/observers';
import { Component, type ElementRef, computed, contentChildren, input, viewChild } from '@angular/core';
import { toObservable } from '@angular/core/rxjs-interop';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronLeft, lucideChevronRight } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { BrnTabsPaginatedListDirective, BrnTabsTriggerDirective } from '@spartan-ng/brain/tabs';
import { buttonVariants } from '@spartan-ng/ui-button-helm';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';
import { listVariants } from './hlm-tabs-list.component';

@Component({
	selector: 'hlm-paginated-tabs-list',
	imports: [CdkObserveContent, NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideChevronRight, lucideChevronLeft })],
	template: `
		<button
			#previousPaginator
			data-pagination="previous"
			type="button"
			aria-hidden="true"
			tabindex="-1"
			[class.flex]="_showPaginationControls()"
			[class.hidden]="!_showPaginationControls()"
			[class]="_paginationButtonClass()"
			[disabled]="_disableScrollBefore || null"
			(click)="_handlePaginatorClick('before')"
			(mousedown)="_handlePaginatorPress('before', $event)"
			(touchend)="_stopInterval()"
		>
			<ng-icon hlm size="base" name="lucideChevronLeft" />
		</button>

		<div #tabListContainer class="z-[1] flex grow overflow-hidden" (keydown)="_handleKeydown($event)">
			<div class="relative grow transition-transform" #tabList role="tablist" (cdkObserveContent)="_onContentChanges()">
				<div #tabListInner [class]="_tabListClass()">
					<ng-content></ng-content>
				</div>
			</div>
		</div>

		<button
			#nextPaginator
			data-pagination="next"
			type="button"
			aria-hidden="true"
			tabindex="-1"
			[class.flex]="_showPaginationControls()"
			[class.hidden]="!_showPaginationControls()"
			[class]="_paginationButtonClass()"
			[disabled]="_disableScrollAfter || null"
			(click)="_handlePaginatorClick('after')"
			(mousedown)="_handlePaginatorPress('after', $event)"
			(touchend)="_stopInterval()"
		>
			<ng-icon hlm size="base" name="lucideChevronRight" />
		</button>
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmTabsPaginatedListComponent extends BrnTabsPaginatedListDirective {
	public readonly _items = contentChildren(BrnTabsTriggerDirective, { descendants: false });
	public readonly _itemsChanges = toObservable(this._items);

	public readonly _tabListContainer = viewChild.required<ElementRef<HTMLElement>>('tabListContainer');
	public readonly _tabList = viewChild.required<ElementRef<HTMLElement>>('tabList');
	public readonly _tabListInner = viewChild.required<ElementRef<HTMLElement>>('tabListInner');
	public readonly _nextPaginator = viewChild.required<ElementRef<HTMLElement>>('nextPaginator');
	public readonly _previousPaginator = viewChild.required<ElementRef<HTMLElement>>('previousPaginator');

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm('flex overflow-hidden relative gap-1 flex-shrink-0', this.userClass()),
	);

	public readonly tabLisClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _tabListClass = computed(() => hlm(listVariants(), this.tabLisClass()));

	public readonly paginationButtonClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _paginationButtonClass = computed(() =>
		hlm(
			'relative z-[2] select-none disabled:cursor-default',
			buttonVariants({ variant: 'ghost', size: 'icon' }),
			this.paginationButtonClass(),
		),
	);

	protected _itemSelected(event: KeyboardEvent) {
		event.preventDefault();
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-tabs-helm/files/lib/hlm-tabs-trigger.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnTabsTriggerDirective } from '@spartan-ng/brain/tabs';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmTabsTrigger]',
	standalone: true,
	hostDirectives: [{ directive: BrnTabsTriggerDirective, inputs: ['brnTabsTrigger: hlmTabsTrigger', 'disabled'] }],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmTabsTriggerDirective {
	public readonly triggerFor = input.required<string>({ alias: 'hlmTabsTrigger' });

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-tabs-helm/files/lib/hlm-tabs.component.ts.template
```
import { Component, input } from '@angular/core';
import { BrnTabsDirective } from '@spartan-ng/brain/tabs';

@Component({
	selector: 'hlm-tabs',
	standalone: true,
	hostDirectives: [
		{
			directive: BrnTabsDirective,
			inputs: ['orientation', 'direction', 'activationMode', 'brnTabs: tab'],
			outputs: ['tabActivated'],
		},
	],
	template: '<ng-content/>',
})
export class HlmTabsComponent {
	public readonly tab = input.required<string>();
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-separator-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'separator',
		internalName: 'ui-separator-helm',
		publicName: 'ui-separator-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-separator-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmSeparatorDirective } from './lib/hlm-separator.directive';

export * from './lib/hlm-separator.directive';

@NgModule({
	imports: [HlmSeparatorDirective],
	exports: [HlmSeparatorDirective],
})
export class HlmSeparatorModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-separator-helm/files/lib/hlm-separator.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export type HlmSeparatorOrientation = 'horizontal' | 'vertical';
@Directive({
	selector: '[hlmSeparator],brn-separator[hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSeparatorDirective {
	public readonly orientation = input<HlmSeparatorOrientation>('horizontal');
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'inline-flex shrink-0 border-0 bg-border',
			this.orientation() === 'horizontal' ? 'h-[1px] w-full' : 'h-full w-[1px]',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-toggle-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'toggle',
		internalName: 'ui-toggle-helm',
		publicName: 'ui-toggle-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-toggle-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmToggleDirective } from './lib/hlm-toggle.directive';

export * from './lib/hlm-toggle.directive';
@NgModule({
	imports: [HlmToggleDirective],
	exports: [HlmToggleDirective],
})
export class HlmToggleModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-toggle-helm/files/lib/hlm-toggle.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { cva, type VariantProps } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const toggleVariants = cva(
	'inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground',
	{
		variants: {
			variant: {
				default: 'bg-transparent',
				outline: 'border border-input bg-transparent hover:bg-accent hover:text-accent-foreground',
			},
			size: {
				default: 'h-9 px-3',
				sm: 'h-8 px-2',
				lg: 'h-10 px-3',
			},
		},
		defaultVariants: {
			variant: 'default',
			size: 'default',
		},
	},
);
export type ToggleVariants = VariantProps<typeof toggleVariants>;

@Directive({
	selector: '[hlmToggle],[brnToggle][hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmToggleDirective {
	public readonly variant = input<ToggleVariants['variant']>('default');
	public readonly size = input<ToggleVariants['size']>('default');
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() => {
		const variantToUse = this.variant();
		const sizeToUse = this.size();
		const userClass = this.userClass();

		return hlm(
			toggleVariants({
				variant: variantToUse,
				size: sizeToUse,
			}),
			userClass,
		);
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-select-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'select',
		internalName: 'ui-select-helm',
		publicName: 'ui-select-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-select-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmSelectContentDirective } from './lib/hlm-select-content.directive';
import { HlmSelectGroupDirective } from './lib/hlm-select-group.directive';
import { HlmSelectLabelDirective } from './lib/hlm-select-label.directive';
import { HlmSelectOptionComponent } from './lib/hlm-select-option.component';
import { HlmSelectScrollDownComponent } from './lib/hlm-select-scroll-down.component';
import { HlmSelectScrollUpComponent } from './lib/hlm-select-scroll-up.component';
import { HlmSelectTriggerComponent } from './lib/hlm-select-trigger.component';
import { HlmSelectValueDirective } from './lib/hlm-select-value.directive';
import { HlmSelectDirective } from './lib/hlm-select.directive';

export * from './lib/hlm-select-content.directive';
export * from './lib/hlm-select-group.directive';
export * from './lib/hlm-select-label.directive';
export * from './lib/hlm-select-option.component';
export * from './lib/hlm-select-scroll-down.component';
export * from './lib/hlm-select-scroll-up.component';
export * from './lib/hlm-select-trigger.component';
export * from './lib/hlm-select-value.directive';
export * from './lib/hlm-select.directive';

export const HlmSelectImports = [
	HlmSelectContentDirective,
	HlmSelectTriggerComponent,
	HlmSelectOptionComponent,
	HlmSelectValueDirective,
	HlmSelectDirective,
	HlmSelectScrollUpComponent,
	HlmSelectScrollDownComponent,
	HlmSelectLabelDirective,
	HlmSelectGroupDirective,
] as const;

@NgModule({
	imports: [...HlmSelectImports],
	exports: [...HlmSelectImports],
})
export class HlmSelectModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-select-helm/files/lib/hlm-select-content.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm, injectExposedSideProvider, injectExposesStateProvider } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmSelectContent], hlm-select-content',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		'[attr.data-state]': '_stateProvider?.state() ?? "open"',
		'[attr.data-side]': '_sideProvider?.side() ?? "bottom"',
	},
})
export class HlmSelectContentDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly stickyLabels = input<boolean>(false);
	protected readonly _stateProvider = injectExposesStateProvider({ optional: true });
	protected readonly _sideProvider = injectExposedSideProvider({ optional: true });

	protected readonly _computedClass = computed(() =>
		hlm(
			'w-full relative z-50 min-w-[8rem] overflow-hidden rounded-md border border-border bg-popover text-popover-foreground shadow-md p-1 data-[side=bottom]:top-[2px] data-[side=top]:bottom-[2px] data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-select-helm/files/lib/hlm-select-group.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnSelectGroupDirective } from '@spartan-ng/brain/select';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmSelectGroup], hlm-select-group',
	hostDirectives: [BrnSelectGroupDirective],
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSelectGroupDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm(this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-select-helm/files/lib/hlm-select-label.directive.ts.template
```
import { Directive, computed, inject, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnSelectLabelDirective } from '@spartan-ng/brain/select';
import type { ClassValue } from 'clsx';
import { HlmSelectContentDirective } from './hlm-select-content.directive';

@Directive({
	selector: '[hlmSelectLabel], hlm-select-label',
	hostDirectives: [BrnSelectLabelDirective],
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSelectLabelDirective {
	private readonly _selectContent = inject(HlmSelectContentDirective);
	private readonly _stickyLabels = computed(() => this._selectContent.stickyLabels());
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'pl-8 pr-2 text-sm font-semibold rtl:pl-2 rtl:pr-8',
			this._stickyLabels() ? 'sticky top-0 bg-popover block z-[2]' : '',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-select-helm/files/lib/hlm-select-option.component.ts.template
```
import { ChangeDetectionStrategy, Component, computed, inject, input } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideCheck } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { BrnSelectOptionDirective } from '@spartan-ng/brain/select';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-option',
	changeDetection: ChangeDetectionStrategy.OnPush,
	hostDirectives: [{ directive: BrnSelectOptionDirective, inputs: ['disabled', 'value'] }],
	providers: [provideIcons({ lucideCheck })],
	host: {
		'[class]': '_computedClass()',
	},
	template: `
		<ng-content />
		<span
			[attr.dir]="_brnSelectOption.dir()"
			class="absolute left-2 flex h-3.5 w-3.5 items-center justify-center rtl:left-auto rtl:right-2"
			[attr.data-state]="this._brnSelectOption.checkedState()"
		>
			@if (this._brnSelectOption.selected()) {
				<ng-icon hlm size="sm" aria-hidden="true" name="lucideCheck" />
			}
		</span>
	`,
	imports: [NgIcon, HlmIconDirective],
})
export class HlmSelectOptionComponent {
	protected readonly _brnSelectOption = inject(BrnSelectOptionDirective, { host: true });
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 rtl:flex-reverse rtl:pr-8 rtl:pl-2 text-sm outline-none data-[active]:bg-accent data-[active]:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-select-helm/files/lib/hlm-select-scroll-down.component.ts.template
```
import { Component } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronDown } from '@ng-icons/lucide';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';

@Component({
	selector: 'hlm-select-scroll-down',
	imports: [NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideChevronDown })],
	host: {
		class: 'flex cursor-default items-center justify-center py-1',
	},
	template: `
		<ng-icon hlm size="sm" class="ml-2" name="lucideChevronDown" />
	`,
})
export class HlmSelectScrollDownComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-select-helm/files/lib/hlm-select-scroll-up.component.ts.template
```
import { Component } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronUp } from '@ng-icons/lucide';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';

@Component({
	selector: 'hlm-select-scroll-up',
	imports: [NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideChevronUp })],
	host: {
		class: 'flex cursor-default items-center justify-center py-1',
	},
	template: `
		<ng-icon hlm size="sm" class="ml-2" name="lucideChevronUp" />
	`,
})
export class HlmSelectScrollUpComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-select-helm/files/lib/hlm-select-trigger.component.ts.template
```
import { Component, computed, contentChild, inject, input } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronDown } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { BrnSelectComponent, BrnSelectTriggerDirective } from '@spartan-ng/brain/select';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const selectTriggerVariants = cva(
	'flex items-center justify-between rounded-md border border-input bg-background text-sm ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
	{
		variants: {
			size: {
				default: 'h-10 py-2 px-4',
				sm: 'h-9 px-3',
				lg: 'h-11 px-8',
			},
			error: {
				auto: '[&.ng-invalid.ng-touched]:text-destructive [&.ng-invalid.ng-touched]:border-destructive [&.ng-invalid.ng-touched]:focus-visible:ring-destructive',
				true: 'text-destructive border-destructive focus-visible:ring-destructive',
			},
		},
		defaultVariants: {
			size: 'default',
			error: 'auto',
		},
	},
);
type SelectTriggerVariants = VariantProps<typeof selectTriggerVariants>;

@Component({
	selector: 'hlm-select-trigger',
	imports: [BrnSelectTriggerDirective, NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideChevronDown })],
	template: `
		<button [class]="_computedClass()" #button hlmInput brnSelectTrigger type="button">
			<ng-content />
			@if (icon()) {
				<ng-content select="ng-icon" />
			} @else {
				<ng-icon hlm size="sm" class="ml-2 flex-none" name="lucideChevronDown" />
			}
		</button>
	`,
})
export class HlmSelectTriggerComponent {
	protected readonly icon = contentChild(HlmIconDirective);

	protected readonly brnSelect = inject(BrnSelectComponent, { optional: true });

	public readonly _size = input<SelectTriggerVariants['size']>('default');
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected _computedClass = computed(() =>
		hlm(selectTriggerVariants({ size: this._size(), error: this.brnSelect?.errorState() }), this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-select-helm/files/lib/hlm-select-value.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: 'hlm-select-value,[hlmSelectValue], brn-select-value[hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSelectValueDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'!inline-block ltr:text-left rtl:text-right border-border w-[calc(100%)]] min-w-0 pointer-events-none truncate data-[placeholder]:text-muted-foreground',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-select-helm/files/lib/hlm-select.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: 'hlm-select, brn-select [hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSelectDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm('space-y-2', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-toggle-group-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'togglegroup',
		internalName: 'ui-toggle-group-helm',
		publicName: 'ui-togglegroup-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-toggle-group-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmToggleGroupDirective } from './lib/hlm-toggle-group.directive';
import { HlmToggleGroupItemDirective } from './lib/hlm-toggle-item.directive';

export * from './lib/hlm-toggle-group.directive';
export * from './lib/hlm-toggle-item.directive';

@NgModule({
	imports: [HlmToggleGroupItemDirective, HlmToggleGroupDirective],
	exports: [HlmToggleGroupItemDirective, HlmToggleGroupDirective],
})
export class HlmToggleGroupModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-toggle-group-helm/files/lib/hlm-toggle-group.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { VariantProps } from 'class-variance-authority';
import type { ClassValue } from 'clsx';
import { provideHlmToggleGroup } from './hlm-toggle-group.token';
import { toggleGroupItemVariants } from './hlm-toggle-item.directive';

type ToggleGroupItemVariants = VariantProps<typeof toggleGroupItemVariants>;
@Directive({
	selector: 'brn-toggle-group[hlm],[hlmToggleGroup]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	providers: [provideHlmToggleGroup(HlmToggleGroupDirective)],
})
export class HlmToggleGroupDirective {
	public readonly variant = input<ToggleGroupItemVariants['variant']>('default');
	public readonly size = input<ToggleGroupItemVariants['size']>('default');
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm('inline-flex items-center gap-x-2 focus:[&>[hlm][brnToggle]]:z-10', {
			'gap-x-0 rounded-md first-of-type:[&>[hlmToggleGroupItem]]:rounded-l-md last-of-type:[&>[hlmToggleGroupItem]]:rounded-r-md [&>[hlmToggleGroupItem][variant="outline"]]:-mx-[0.5px] [&>[hlmToggleGroupItem]]:rounded-none':
				this.variant() === 'merged',
			[String(this.userClass())]: !!this.userClass(),
		}),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-toggle-group-helm/files/lib/hlm-toggle-group.token.ts.template
```
import { ExistingProvider, InjectionToken, Type, inject } from '@angular/core';
import type { HlmToggleGroupDirective } from './hlm-toggle-group.directive';

const HlmToggleGroupToken = new InjectionToken<HlmToggleGroupDirective>('HlmToggleGroupToken');

export function provideHlmToggleGroup(config: Type<HlmToggleGroupDirective>): ExistingProvider {
	return { provide: HlmToggleGroupToken, useExisting: config };
}

export function injectHlmToggleGroup(): HlmToggleGroupDirective {
	return inject(HlmToggleGroupToken, { optional: true }) as HlmToggleGroupDirective;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-toggle-group-helm/files/lib/hlm-toggle-item.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';
import { injectHlmToggleGroup } from './hlm-toggle-group.token';

export const toggleGroupItemVariants = cva(
	'inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground',
	{
		variants: {
			variant: {
				default: 'bg-transparent',
				outline: 'border border-input bg-transparent hover:bg-accent hover:text-accent-foreground',
				merged:
					'border border-l-0 first-of-type:border-l border-input bg-transparent hover:bg-accent hover:text-accent-foreground',
			},
			size: {
				default: 'h-9 px-3',
				sm: 'h-8 px-2',
				lg: 'h-10 px-3',
			},
		},
		defaultVariants: {
			variant: 'default',
			size: 'default',
		},
	},
);
type ToggleGroupItemVariants = VariantProps<typeof toggleGroupItemVariants>;

@Directive({
	selector: '[hlmToggleGroupItem],[brnToggleGroupItem][hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmToggleGroupItemDirective {
	private readonly _parentGroup = injectHlmToggleGroup();
	public readonly variant = input<ToggleGroupItemVariants['variant']>('default');
	public readonly size = input<ToggleGroupItemVariants['size']>('default');
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => {
		const variantToUse = this._parentGroup?.variant() ?? this.variant();
		const sizeToUse = this._parentGroup?.size() ?? this.size();
		const userClass = this._parentGroup?.userClass() ?? this.userClass();
		return hlm(
			toggleGroupItemVariants({
				variant: variantToUse,
				size: sizeToUse,
			}),
			userClass,
		);
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-card-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'card',
		internalName: 'ui-card-helm',
		publicName: 'ui-card-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-card-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';

import { HlmCardContentDirective } from './lib/hlm-card-content.directive';
import { HlmCardDescriptionDirective } from './lib/hlm-card-description.directive';
import { HlmCardFooterDirective } from './lib/hlm-card-footer.directive';
import { HlmCardHeaderDirective } from './lib/hlm-card-header.directive';
import { HlmCardTitleDirective } from './lib/hlm-card-title.directive';
import { HlmCardDirective } from './lib/hlm-card.directive';

export * from './lib/hlm-card-content.directive';
export * from './lib/hlm-card-description.directive';
export * from './lib/hlm-card-footer.directive';
export * from './lib/hlm-card-header.directive';
export * from './lib/hlm-card-title.directive';
export * from './lib/hlm-card.directive';

export const HlmCardImports = [
	HlmCardDirective,
	HlmCardHeaderDirective,
	HlmCardFooterDirective,
	HlmCardTitleDirective,
	HlmCardDescriptionDirective,
	HlmCardContentDirective,
] as const;

@NgModule({
	imports: [...HlmCardImports],
	exports: [...HlmCardImports],
})
export class HlmCardModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-card-helm/files/lib/hlm-card-content.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const cardContentVariants = cva('p-6 pt-0', {
	variants: {},
	defaultVariants: {},
});
export type CardContentVariants = VariantProps<typeof cardContentVariants>;

@Directive({
	selector: '[hlmCardContent]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCardContentDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(cardContentVariants(), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-card-helm/files/lib/hlm-card-description.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const cardDescriptionVariants = cva('text-sm text-muted-foreground', {
	variants: {},
	defaultVariants: {},
});
export type CardDescriptionVariants = VariantProps<typeof cardDescriptionVariants>;

@Directive({
	selector: '[hlmCardDescription]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCardDescriptionDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(cardDescriptionVariants(), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-card-helm/files/lib/hlm-card-footer.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const cardFooterVariants = cva('flex p-6 pt-0', {
	variants: {
		direction: {
			row: 'flex-row items-center space-x-1.5',
			column: 'flex-col space-y-1.5',
		},
	},
	defaultVariants: {
		direction: 'row',
	},
});
export type CardFooterVariants = VariantProps<typeof cardFooterVariants>;

@Directive({
	selector: '[hlmCardFooter]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCardFooterDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(cardFooterVariants({ direction: this.direction() }), this.userClass()));

	public readonly direction = input<CardFooterVariants['direction']>('row');
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-card-helm/files/lib/hlm-card-header.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const cardHeaderVariants = cva('flex p-6', {
	variants: {
		direction: {
			row: 'flex-row items-center space-x-1.5',
			column: 'flex-col space-y-1.5',
		},
	},
	defaultVariants: {
		direction: 'column',
	},
});
export type CardHeaderVariants = VariantProps<typeof cardHeaderVariants>;

@Directive({
	selector: '[hlmCardHeader]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCardHeaderDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(cardHeaderVariants({ direction: this.direction() }), this.userClass()));

	public readonly direction = input<CardHeaderVariants['direction']>('column');
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-card-helm/files/lib/hlm-card-title.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const cardTitleVariants = cva('text-lg font-semibold leading-none tracking-tight', {
	variants: {},
	defaultVariants: {},
});
export type CardTitleVariants = VariantProps<typeof cardTitleVariants>;

@Directive({
	selector: '[hlmCardTitle]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCardTitleDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(cardTitleVariants(), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-card-helm/files/lib/hlm-card.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const cardVariants = cva(
	'rounded-lg border border-border bg-card focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 text-card-foreground shadow-sm',
	{
		variants: {},
		defaultVariants: {},
	},
);
export type CardVariants = VariantProps<typeof cardVariants>;

@Directive({
	selector: '[hlmCard]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCardDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(cardVariants(), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-menu-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'menu',
		internalName: 'ui-menu-helm',
		publicName: 'ui-menu-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-menu-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';

import { HlmMenuBarItemDirective } from './lib/hlm-menu-bar-item.directive';
import { HlmMenuBarComponent } from './lib/hlm-menu-bar.component';
import { HlmMenuGroupComponent } from './lib/hlm-menu-group.component';
import { HlmMenuItemCheckComponent } from './lib/hlm-menu-item-check.component';
import { HlmMenuItemCheckboxDirective } from './lib/hlm-menu-item-checkbox.directive';
import { HlmMenuItemIconDirective } from './lib/hlm-menu-item-icon.directive';
import { HlmMenuItemRadioComponent } from './lib/hlm-menu-item-radio.component';
import { HlmMenuItemRadioDirective } from './lib/hlm-menu-item-radio.directive';
import { HlmMenuItemSubIndicatorComponent } from './lib/hlm-menu-item-sub-indicator.component';
import { HlmMenuItemDirective } from './lib/hlm-menu-item.directive';
import { HlmMenuLabelComponent } from './lib/hlm-menu-label.component';
import { HlmMenuSeparatorComponent } from './lib/hlm-menu-separator.component';
import { HlmMenuShortcutComponent } from './lib/hlm-menu-shortcut.component';
import { HlmMenuComponent } from './lib/hlm-menu.component';
import { HlmSubMenuComponent } from './lib/hlm-sub-menu.component';

export * from './lib/hlm-menu-bar-item.directive';
export * from './lib/hlm-menu-bar.component';
export * from './lib/hlm-menu-group.component';
export * from './lib/hlm-menu-item-check.component';
export * from './lib/hlm-menu-item-checkbox.directive';
export * from './lib/hlm-menu-item-icon.directive';
export * from './lib/hlm-menu-item-radio.component';
export * from './lib/hlm-menu-item-radio.directive';
export * from './lib/hlm-menu-item-sub-indicator.component';
export * from './lib/hlm-menu-item.directive';
export * from './lib/hlm-menu-label.component';
export * from './lib/hlm-menu-separator.component';
export * from './lib/hlm-menu-shortcut.component';
export * from './lib/hlm-menu.component';
export * from './lib/hlm-sub-menu.component';

export const HlmMenuItemImports = [
	HlmMenuItemDirective,
	HlmMenuItemIconDirective,
	HlmMenuGroupComponent,
	HlmMenuItemSubIndicatorComponent,
	HlmMenuItemRadioComponent,
	HlmMenuItemCheckComponent,
	HlmMenuShortcutComponent,
	HlmMenuItemCheckboxDirective,
	HlmMenuItemRadioDirective,
];
export const HlmMenuStructureImports = [HlmMenuLabelComponent, HlmMenuSeparatorComponent] as const;
export const HlmMenuImports = [
	...HlmMenuItemImports,
	...HlmMenuStructureImports,
	HlmMenuComponent,
	HlmSubMenuComponent,
] as const;
export const HlmMenuBarImports = [...HlmMenuImports, HlmMenuBarComponent, HlmMenuBarItemDirective] as const;

@NgModule({
	imports: [...HlmMenuItemImports],
	exports: [...HlmMenuItemImports],
})
export class HlmMenuItemModule {}

@NgModule({
	imports: [...HlmMenuImports],
	exports: [...HlmMenuImports],
})
export class HlmMenuModule {}

@NgModule({
	imports: [...HlmMenuBarImports],
	exports: [...HlmMenuBarImports],
})
export class HlmMenuBarModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-menu-helm/files/lib/hlm-menu-bar-item.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnMenuItemDirective } from '@spartan-ng/brain/menu';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmMenuBarItem]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnMenuItemDirective],
})
export class HlmMenuBarItemDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground aria-expanded:bg-accent aria-expanded:text-accent-foreground',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-menu-helm/files/lib/hlm-menu-bar.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnMenuBarDirective } from '@spartan-ng/brain/menu';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-menu-bar',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnMenuBarDirective],
	template: '<ng-content/>',
})
export class HlmMenuBarComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm('border-border flex h-10 items-center space-x-1 rounded-md border bg-background p-1', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-menu-helm/files/lib/hlm-menu-group.component.ts.template
```
import { Component } from '@angular/core';
import { BrnMenuGroupDirective } from '@spartan-ng/brain/menu';

@Component({
	selector: 'hlm-menu-group',
	standalone: true,
	host: {
		class: 'block',
	},
	hostDirectives: [BrnMenuGroupDirective],
	template: `
		<ng-content />
	`,
})
export class HlmMenuGroupComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-menu-helm/files/lib/hlm-menu-item-check.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideCheck } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-menu-item-check',
	providers: [provideIcons({ lucideCheck })],
	imports: [NgIcon, HlmIconDirective],
	template: `
		<!-- Using 1rem for size to mimick h-4 w-4 -->
		<ng-icon hlm size="1rem" name="lucideCheck" />
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmMenuItemCheckComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'group-[.checked]:opacity-100 opacity-0 absolute left-2 flex h-3.5 w-3.5 items-center justify-center',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-menu-helm/files/lib/hlm-menu-item-checkbox.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnMenuItemCheckboxDirective } from '@spartan-ng/brain/menu';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmMenuItemCheckbox]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [
		{
			directive: BrnMenuItemCheckboxDirective,
			inputs: ['disabled: disabled', 'checked: checked'],
			outputs: ['triggered: triggered'],
		},
	],
})
export class HlmMenuItemCheckboxDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'group w-full relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:bg-accent focus-visible:text-accent-foreground disabled:pointer-events-none disabled:opacity-50',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-menu-helm/files/lib/hlm-menu-item-icon.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { provideHlmIconConfig } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmMenuIcon]',
	standalone: true,
	providers: [provideHlmIconConfig({ size: 'sm' })],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmMenuItemIconDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('mr-2', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-menu-helm/files/lib/hlm-menu-item-radio.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideCircle } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-menu-item-radio',
	providers: [provideIcons({ lucideCircle })],
	imports: [NgIcon, HlmIconDirective],
	template: `
		<!-- Using 0.5rem for size to mimick h-2 w-2 -->
		<ng-icon hlm size="0.5rem" class="*:*:fill-current" name="lucideCircle" />
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmMenuItemRadioComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'group-[.checked]:opacity-100 opacity-0 absolute left-2 flex h-3.5 w-3.5 items-center justify-center',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-menu-helm/files/lib/hlm-menu-item-radio.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnMenuItemRadioDirective } from '@spartan-ng/brain/menu';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmMenuItemRadio]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [
		{
			directive: BrnMenuItemRadioDirective,
			inputs: ['disabled: disabled', 'checked: checked'],
			outputs: ['triggered: triggered'],
		},
	],
})
export class HlmMenuItemRadioDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'group w-full relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:bg-accent focus-visible:text-accent-foreground disabled:pointer-events-none disabled:opacity-50',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-menu-helm/files/lib/hlm-menu-item-sub-indicator.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronRight } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-menu-item-sub-indicator',
	providers: [provideIcons({ lucideChevronRight })],
	imports: [NgIcon, HlmIconDirective],
	template: `
		<ng-icon hlm size="none" class="h-full w-full" name="lucideChevronRight" />
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmMenuItemSubIndicatorComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('inline-block ml-auto h-4 w-4', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-menu-helm/files/lib/hlm-menu-item.directive.ts.template
```
import { Directive, Input, booleanAttribute, computed, input, signal } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnMenuItemDirective } from '@spartan-ng/brain/menu';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const hlmMenuItemVariants = cva(
	'group w-full relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:bg-accent focus-visible:text-accent-foreground disabled:pointer-events-none disabled:opacity-50',
	{
		variants: { inset: { true: 'pl-8', false: '' } },
		defaultVariants: { inset: false },
	},
);
export type HlmMenuItemVariants = VariantProps<typeof hlmMenuItemVariants>;

@Directive({
	selector: '[hlmMenuItem]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [
		{
			directive: BrnMenuItemDirective,
			inputs: ['disabled: disabled'],
			outputs: ['triggered: triggered'],
		},
	],
})
export class HlmMenuItemDirective {
	private readonly _inset = signal<boolean>(false);

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmMenuItemVariants({ inset: this._inset() }), this.userClass()));

	@Input({ transform: booleanAttribute })
	public set inset(value: boolean) {
		this._inset.set(value);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-menu-helm/files/lib/hlm-menu-label.component.ts.template
```
import { Component, Input, booleanAttribute, computed, input, signal } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-menu-label',
	standalone: true,
	template: `
		<ng-content />
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmMenuLabelComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm('block px-2 py-1.5 text-sm font-semibold', this._inset() && 'pl-8', this.userClass()),
	);

	private readonly _inset = signal<ClassValue>(false);
	@Input({ transform: booleanAttribute })
	public set inset(value: boolean) {
		this._inset.set(value);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-menu-helm/files/lib/hlm-menu-separator.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-menu-separator',
	standalone: true,
	template: '',
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmMenuSeparatorComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('block -mx-1 my-1 h-px bg-muted', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-menu-helm/files/lib/hlm-menu-shortcut.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-menu-shortcut',
	standalone: true,
	template: `
		<ng-content />
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmMenuShortcutComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm('ml-auto font-light text-xs tracking-widest opacity-60', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-menu-helm/files/lib/hlm-menu.component.ts.template
```
import { Component, Input, computed, input, signal } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnMenuDirective } from '@spartan-ng/brain/menu';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const menuVariants = cva(
	'block border-border min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
	{
		variants: {
			variant: {
				default: 'my-0.5',
				menubar: 'my-2',
			},
		},
		defaultVariants: {
			variant: 'default',
		},
	},
);
type MenuVariants = VariantProps<typeof menuVariants>;

@Component({
	selector: 'hlm-menu',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnMenuDirective],
	template: `
		<ng-content />
	`,
})
export class HlmMenuComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(menuVariants({ variant: this._variant() }), this.userClass()));

	private readonly _variant = signal<MenuVariants['variant']>('default');
	@Input()
	public set variant(value: MenuVariants['variant']) {
		this._variant.set(value);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-menu-helm/files/lib/hlm-sub-menu.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnMenuDirective } from '@spartan-ng/brain/menu';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-sub-menu',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnMenuDirective],
	template: `
		<ng-content />
	`,
})
export class HlmSubMenuComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'border-border min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-hover-card-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'hovercard',
		internalName: 'ui-hover-card-helm',
		publicName: 'ui-hovercard-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-hover-card-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmHoverCardContentComponent } from './lib/hlm-hover-card-content.component';

export { HlmHoverCardContentComponent } from './lib/hlm-hover-card-content.component';

export const HlmHoverCardImports = [HlmHoverCardContentComponent] as const;

@NgModule({
	imports: [...HlmHoverCardImports],
	exports: [...HlmHoverCardImports],
})
export class HlmHoverCardModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-hover-card-helm/files/lib/hlm-hover-card-content.component.ts.template
```
import { Component, ElementRef, Renderer2, computed, effect, inject, input, signal } from '@angular/core';
import { hlm, injectExposedSideProvider, injectExposesStateProvider } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-hover-card-content',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	template: `
		<ng-content />
	`,
})
export class HlmHoverCardContentComponent {
	private readonly _renderer = inject(Renderer2);
	private readonly _element = inject(ElementRef);

	public readonly state = injectExposesStateProvider({ host: true }).state ?? signal('closed').asReadonly();
	public readonly side = injectExposedSideProvider({ host: true }).side ?? signal('bottom').asReadonly();

	constructor() {
		effect(() => {
			this._renderer.setAttribute(this._element.nativeElement, 'data-state', this.state());
			this._renderer.setAttribute(this._element.nativeElement, 'data-side', this.side());
		});
	}

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'z-50 w-64 rounded-md border border-border bg-popover p-4 text-popover-foreground shadow-md outline-none',
			'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-icon-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'icon',
		internalName: 'ui-icon-helm',
		publicName: 'ui-icon-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-icon-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmIconDirective } from './lib/hlm-icon.directive';

export * from './lib/hlm-icon.directive';
export * from './lib/hlm-icon.token';

@NgModule({
	imports: [HlmIconDirective],
	exports: [HlmIconDirective],
})
export class HlmIconModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-icon-helm/files/lib/hlm-icon.directive.spec.ts.template
```
import { ChangeDetectionStrategy, Component, Input } from '@angular/core';
import { By } from '@angular/platform-browser';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideCheck } from '@ng-icons/lucide';
import { type RenderResult, render } from '@testing-library/angular';
import { HlmIconDirective } from './hlm-icon.directive';

@Component({
	selector: 'hlm-mock',
	standalone: true,
	changeDetection: ChangeDetectionStrategy.OnPush,
	imports: [HlmIconDirective, NgIcon],
	providers: [provideIcons({ lucideCheck })],
	template: `
		<ng-icon hlm class="test" name="lucideCheck" [size]="size" color="red" strokeWidth="2" />
	`,
})
class HlmMockComponent {
	@Input() public size = 'base';
}

describe('HlmIconDirective', () => {
	let r: RenderResult<HlmMockComponent>;
	let icon: HTMLElement;

	beforeEach(async () => {
		r = await render(HlmMockComponent);
		icon = r.container.querySelector('ng-icon')!;
	});

	it('should add the xs size', async () => {
		await r.rerender({ componentInputs: { size: 'xs' } });
		r.fixture.detectChanges();
		expect(icon.getAttribute('style')).toContain('--ng-icon__size: 12px');
	});

	it('should add the sm size', async () => {
		await r.rerender({ componentInputs: { size: 'sm' } });
		r.fixture.detectChanges();
		expect(icon.getAttribute('style')).toContain('--ng-icon__size: 16px');
	});

	it('should add the base size', () => {
		expect(icon.getAttribute('style')).toContain('--ng-icon__size: 24px');
	});

	it('should add the lg size', async () => {
		await r.rerender({ componentInputs: { size: 'lg' } });
		r.fixture.detectChanges();
		expect(icon.getAttribute('style')).toContain('--ng-icon__size: 32px');
	});

	it('should add the xl size', async () => {
		await r.rerender({ componentInputs: { size: 'xl' } });
		r.fixture.detectChanges();
		expect(icon.getAttribute('style')).toContain('--ng-icon__size: 48px');
	});

	it('should forward the size property if the size is not a pre-defined size', async () => {
		await r.rerender({ componentInputs: { size: '2rem' } });
		r.fixture.detectChanges();
		const debugEl = r.fixture.debugElement.query(By.directive(NgIcon));
		expect(debugEl.componentInstance.size()).toBe('2rem');
		expect(icon.getAttribute('style')).toContain('--ng-icon__size: 2rem');
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-icon-helm/files/lib/hlm-icon.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { injectHlmIconConfig } from './hlm-icon.token';

export type IconSize = 'xs' | 'sm' | 'base' | 'lg' | 'xl' | 'none' | (Record<never, never> & string);

@Directive({
	selector: 'ng-icon[hlm]',
	standalone: true,
	host: {
		'[style.--ng-icon__size]': '_computedSize()',
	},
})
export class HlmIconDirective {
	private readonly _config = injectHlmIconConfig();
	public readonly size = input<IconSize>(this._config.size);

	protected readonly _computedSize = computed(() => {
		const size = this.size();

		switch (size) {
			case 'xs':
				return '12px';
			case 'sm':
				return '16px';
			case 'base':
				return '24px';
			case 'lg':
				return '32px';
			case 'xl':
				return '48px';
			default: {
				return size;
			}
		}
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-icon-helm/files/lib/hlm-icon.token.ts.template
```
import { InjectionToken, ValueProvider, inject } from '@angular/core';
import type { IconSize } from './hlm-icon.directive';

export interface HlmIconConfig {
	size: IconSize;
}

const defaultConfig: HlmIconConfig = {
	size: 'base',
};

const HlmIconConfigToken = new InjectionToken<HlmIconConfig>('HlmIconConfig');

export function provideHlmIconConfig(config: Partial<HlmIconConfig>): ValueProvider {
	return { provide: HlmIconConfigToken, useValue: { ...defaultConfig, ...config } };
}

export function injectHlmIconConfig(): HlmIconConfig {
	return inject(HlmIconConfigToken, { optional: true }) ?? defaultConfig;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-spinner-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'spinner',
		internalName: 'ui-spinner-helm',
		publicName: 'ui-spinner-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-spinner-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmSpinnerComponent } from './lib/hlm-spinner.component';

export * from './lib/hlm-spinner.component';

@NgModule({
	imports: [HlmSpinnerComponent],
	exports: [HlmSpinnerComponent],
})
export class HlmSpinnerModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-spinner-helm/files/lib/hlm-spinner.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const spinnerVariants = cva('inline-block', {
	variants: {
		variant: {
			default: 'animate-spin [&>svg]:text-foreground/30 [&>svg]:fill-accent',
		},
		size: {
			xs: 'h-4 w-4',
			sm: 'h-6 w-6',
			default: 'w-8 h-8 ',
			lg: 'w-12 h-12',
			xl: 'w-16 h-16',
		},
	},
	defaultVariants: {
		variant: 'default',
		size: 'default',
	},
});
export type SpinnerVariants = VariantProps<typeof spinnerVariants>;

@Component({
	selector: 'hlm-spinner',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		role: 'status',
	},
	template: `
		<svg aria-hidden="true" class="animate-spin" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg">
			<path
				d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z"
				fill="currentColor"
			/>
			<path
				d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z"
				fill="currentFill"
			/>
		</svg>
		<span class="sr-only"><ng-content /></span>
	`,
})
export class HlmSpinnerComponent {
	public readonly size = input<SpinnerVariants['size']>('default');
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(spinnerVariants({ size: this.size() }), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-badge-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'badge',
		internalName: 'ui-badge-helm',
		publicName: 'ui-badge-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-badge-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmBadgeDirective } from './lib/hlm-badge.directive';

export * from './lib/hlm-badge.directive';

@NgModule({
	imports: [HlmBadgeDirective],
	exports: [HlmBadgeDirective],
})
export class HlmBadgeModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-badge-helm/files/lib/hlm-badge.directive.ts.template
```
import type { BooleanInput } from '@angular/cdk/coercion';
import { Directive, booleanAttribute, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const badgeVariants = cva(
	'inline-flex items-center border rounded-full px-2.5 py-0.5 font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2',
	{
		variants: {
			variant: {
				default: 'bg-primary border-transparent text-primary-foreground',
				secondary: 'bg-secondary border-transparent text-secondary-foreground',
				destructive: 'bg-destructive border-transparent text-destructive-foreground',
				outline: 'text-foreground border-border',
			},
			size: {
				default: 'text-xs',
				lg: 'text-sm',
			},
			static: { true: '', false: '' },
		},
		compoundVariants: [
			{
				variant: 'default',
				static: false,
				class: 'hover:bg-primary/80',
			},
			{
				variant: 'secondary',
				static: false,
				class: 'hover:bg-secondary/80',
			},
			{
				variant: 'destructive',
				static: false,
				class: 'hover:bg-destructive/80',
			},
		],
		defaultVariants: {
			variant: 'default',
			size: 'default',
			static: false,
		},
	},
);
export type BadgeVariants = VariantProps<typeof badgeVariants>;

@Directive({
	selector: '[hlmBadge]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmBadgeDirective {
	protected readonly _computedClass = computed(() =>
		hlm(badgeVariants({ variant: this.variant(), size: this.size(), static: this.static() }), this.userClass()),
	);

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly variant = input<BadgeVariants['variant']>('default');
	public readonly static = input<BadgeVariants['static'], BooleanInput>(false, { transform: booleanAttribute });
	public readonly size = input<BadgeVariants['size']>('default');
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-tooltip-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'tooltip',
		internalName: 'ui-tooltip-helm',
		publicName: 'ui-tooltip-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-tooltip-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmTooltipTriggerDirective } from './lib/hlm-tooltip-trigger.directive';
import { HlmTooltipComponent } from './lib/hlm-tooltip.component';

export * from './lib/hlm-tooltip-trigger.directive';
export * from './lib/hlm-tooltip.component';

export const HlmTooltipImports = [HlmTooltipComponent, HlmTooltipTriggerDirective] as const;

@NgModule({
	imports: [...HlmTooltipImports],
	exports: [...HlmTooltipImports],
})
export class HlmTooltipModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-tooltip-helm/files/lib/hlm-tooltip-trigger.directive.ts.template
```
import { Directive } from '@angular/core';
import { BrnTooltipTriggerDirective, provideBrnTooltipDefaultOptions } from '@spartan-ng/brain/tooltip';

const DEFAULT_TOOLTIP_CONTENT_CLASSES =
	'overflow-hidden rounded-md border border-border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md fade-in-0 zoom-in-95 ' +
	'data-[state=open]:animate-in ' +
	'data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 ' +
	'data-[side=below]:slide-in-from-top-2 data-[side=above]:slide-in-from-bottom-2 ' +
	'data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 ';

@Directive({
	selector: '[hlmTooltipTrigger]',
	standalone: true,
	providers: [
		provideBrnTooltipDefaultOptions({
			showDelay: 150,
			hideDelay: 300,
			exitAnimationDuration: 150,
			tooltipContentClasses: DEFAULT_TOOLTIP_CONTENT_CLASSES,
		}),
	],
	hostDirectives: [
		{
			directive: BrnTooltipTriggerDirective,
			inputs: [
				'brnTooltipDisabled: hlmTooltipDisabled',
				'brnTooltipTrigger: hlmTooltipTrigger',
				'aria-describedby',
				'position',
				'positionAtOrigin',
				'hideDelay',
				'showDelay',
				'exitAnimationDuration',
				'touchGestures',
			],
		},
	],
})
export class HlmTooltipTriggerDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-tooltip-helm/files/lib/hlm-tooltip.component.ts.template
```
import { ChangeDetectionStrategy, Component, ViewEncapsulation } from '@angular/core';
import { BrnTooltipDirective } from '@spartan-ng/brain/tooltip';

@Component({
	selector: 'hlm-tooltip',
	encapsulation: ViewEncapsulation.None,
	changeDetection: ChangeDetectionStrategy.OnPush,
	host: {
		'[style]': '{display: "contents"}',
	},
	hostDirectives: [BrnTooltipDirective],
	template: `
		<ng-content />
	`,
})
export class HlmTooltipComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-avatar-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'avatar',
		internalName: 'ui-avatar-helm',
		publicName: 'ui-avatar-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-avatar-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';

import { HlmAvatarFallbackDirective } from './lib/fallback';
import { HlmAvatarComponent } from './lib/hlm-avatar.component';
import { HlmAvatarImageDirective } from './lib/image';

export * from './lib/fallback';
export * from './lib/hlm-avatar.component';
export * from './lib/image';

export const HlmAvatarImports = [HlmAvatarFallbackDirective, HlmAvatarImageDirective, HlmAvatarComponent] as const;

@NgModule({
	imports: [...HlmAvatarImports],
	exports: [...HlmAvatarImports],
})
export class HlmAvatarModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-avatar-helm/files/lib/hlm-avatar.component.spec.ts.template
```
import { Component, Input } from '@angular/core';
import { type ComponentFixture, TestBed } from '@angular/core/testing';
import { BrnAvatarFallbackDirective, BrnAvatarImageDirective } from '@spartan-ng/brain/avatar';
import { HlmAvatarComponent } from './hlm-avatar.component';

@Component({
	selector: 'hlm-mock',
	imports: [BrnAvatarImageDirective, BrnAvatarFallbackDirective, HlmAvatarComponent],
	template: `
		<hlm-avatar [class]="class" id="fallbackOnly">
			<span brnAvatarFallback>fallback</span>
		</hlm-avatar>
	`,
	standalone: true,
})
class MockComponent {
	@Input() public class = '';
}

describe('HlmAvatarComponent', () => {
	let component: HlmAvatarComponent;
	let fixture: ComponentFixture<HlmAvatarComponent>;

	beforeEach(() => {
		fixture = TestBed.createComponent(HlmAvatarComponent);
		component = fixture.componentInstance;
	});

	it('should compile', () => {
		expect(component).toBeTruthy();
	});

	it('should add the default classes if no inputs are provided', () => {
		fixture.detectChanges();
		expect(fixture.nativeElement.className).toBe('flex h-10 overflow-hidden relative rounded-full shrink-0 w-10');
	});

	it('should add any user defined classes', () => {
		const mockFixture = TestBed.createComponent(MockComponent);
		mockFixture.componentRef.setInput('class', 'test-class');
		mockFixture.detectChanges();
		const avatar = mockFixture.nativeElement.querySelector('hlm-avatar');
		expect(avatar.className).toContain('test-class');
	});

	it('should change the size when the variant is changed', () => {
		fixture.componentRef.setInput('variant', 'small');
		fixture.detectChanges();
		expect(fixture.nativeElement.className).toContain('h-6');
		expect(fixture.nativeElement.className).toContain('w-6');
		expect(fixture.nativeElement.className).toContain('text-xs');

		fixture.componentRef.setInput('variant', 'large');
		fixture.detectChanges();
		expect(fixture.nativeElement.className).toContain('h-14');
		expect(fixture.nativeElement.className).toContain('w-14');
		expect(fixture.nativeElement.className).toContain('text-lg');
	});

	it('should support brn directives', () => {
		const mockFixture = TestBed.createComponent(MockComponent);
		mockFixture.detectChanges();
		expect(mockFixture.nativeElement.querySelector('span').textContent).toBe('fallback');
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-avatar-helm/files/lib/hlm-avatar.component.ts.template
```
import { ChangeDetectionStrategy, Component, ViewEncapsulation, computed, input } from '@angular/core';
import { BrnAvatarComponent } from '@spartan-ng/brain/avatar';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const avatarVariants = cva('relative flex shrink-0 overflow-hidden rounded-full', {
	variants: {
		variant: {
			small: 'h-6 w-6 text-xs',
			medium: 'h-10 w-10',
			large: 'h-14 w-14 text-lg',
		},
	},
	defaultVariants: {
		variant: 'medium',
	},
});

export type AvatarVariants = VariantProps<typeof avatarVariants>;

@Component({
	selector: 'hlm-avatar',
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	template: `
		@if (image()?.canShow()) {
			<ng-content select="[hlmAvatarImage],[brnAvatarImage]" />
		} @else {
			<ng-content select="[hlmAvatarFallback],[brnAvatarFallback]" />
		}
	`,
})
export class HlmAvatarComponent extends BrnAvatarComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly variant = input<AvatarVariants['variant']>('medium');

	protected readonly _computedClass = computed(() =>
		hlm(avatarVariants({ variant: this.variant() }), this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-avatar-helm/files/lib/fallback/hlm-avatar-fallback.directive.spec.ts.template
```
import { Component, PLATFORM_ID } from '@angular/core';
import { type ComponentFixture, TestBed, fakeAsync } from '@angular/core/testing';
import { hexColorFor, isBright } from '@spartan-ng/brain/avatar';
import { HlmAvatarFallbackDirective } from './hlm-avatar-fallback.directive';

@Component({
	selector: 'hlm-mock',
	standalone: true,
	imports: [HlmAvatarFallbackDirective],
	template: `
		<span hlmAvatarFallback [class]="userCls" [autoColor]="autoColor">fallback2</span>
	`,
})
class HlmMockComponent {
	public userCls = '';
	public autoColor = false;
}

describe('HlmAvatarFallbackDirective', () => {
	let component: HlmMockComponent;
	let fixture: ComponentFixture<HlmMockComponent>;

	beforeEach(() => {
		fixture = TestBed.overrideProvider(PLATFORM_ID, { useValue: 'browser' }).createComponent(HlmMockComponent);
		component = fixture.componentInstance;
	});

	it('should compile', () => {
		expect(component).toBeTruthy();
	});

	it('should contain the default classes if no inputs are provided', () => {
		fixture.detectChanges();
		expect(fixture.nativeElement.querySelector('span').className).toBe(
			'bg-muted flex h-full items-center justify-center rounded-full w-full',
		);
	});

	it('should add any user defined classes', async () => {
		component.userCls = 'test-class';

		fixture.detectChanges();
		expect(fixture.nativeElement.querySelector('span').className).toContain('test-class');
	});
	it('should merge bg-destructive correctly when set as user defined class, therefore removing bg-muted', async () => {
		component.userCls = 'bg-destructive ';

		fixture.detectChanges();
		expect(fixture.nativeElement.querySelector('span').className).toContain('bg-destructive');
	});

	describe('autoColor', () => {
		beforeEach(() => {
			component.autoColor = true;
			fixture.detectChanges();
		});

		it('should remove the bg-muted class from the component', fakeAsync(() => {
			fixture.detectChanges();
			expect(fixture.nativeElement.querySelector('span').className).not.toContain('bg-muted');
		}));

		it('should remove add a text color class and hex backgroundColor style depending on its content', () => {
			const hex = hexColorFor('fallback2');
			const textCls = isBright(hex) ? 'text-black' : 'text-white';
			expect(fixture.nativeElement.querySelector('span').className).toContain(textCls);
			expect(fixture.nativeElement.querySelector('span').style.backgroundColor).toBe('rgb(144, 53, 149)');
		});
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-avatar-helm/files/lib/fallback/hlm-avatar-fallback.directive.ts.template
```
import { Directive, computed, inject } from '@angular/core';
import { BrnAvatarFallbackDirective, hexColorFor, isBright } from '@spartan-ng/brain/avatar';
import { hlm } from '@spartan-ng/brain/core';

@Directive({
	selector: '[hlmAvatarFallback]',
	standalone: true,
	exportAs: 'avatarFallback',
	hostDirectives: [
		{
			directive: BrnAvatarFallbackDirective,
			inputs: ['class:class', 'autoColor:autoColor'],
		},
	],
	host: {
		'[class]': '_computedClass()',
		'[style.backgroundColor]': "_hex() || ''",
	},
})
export class HlmAvatarFallbackDirective {
	private readonly _brn = inject(BrnAvatarFallbackDirective);
	private readonly _hex = computed(() => {
		if (!this._brn.autoColor() || !this._brn.getTextContent()) return;
		return hexColorFor(this._brn.getTextContent());
	});

	private readonly _autoColorTextCls = computed(() => {
		const hex = this._hex();
		if (!hex) return;
		return `${isBright(hex) ? 'text-black' : 'text-white'}`;
	});

	protected readonly _computedClass = computed(() => {
		return hlm(
			'flex h-full w-full items-center justify-center rounded-full',
			this._autoColorTextCls() ?? 'bg-muted',
			this._brn?.userClass(),
		);
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-avatar-helm/files/lib/fallback/index.ts.template
```
export * from './hlm-avatar-fallback.directive';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-avatar-helm/files/lib/image/hlm-avatar-image.directive.spec.ts.template
```
import { Component } from '@angular/core';
import { type ComponentFixture, TestBed } from '@angular/core/testing';
import { HlmAvatarImageDirective } from './hlm-avatar-image.directive';

@Component({
	selector: 'hlm-mock',
	standalone: true,
	imports: [HlmAvatarImageDirective],
	template: `
		<img hlmAvatarImage alt="Avatar image" [class]="userCls" />
	`,
})
class HlmMockComponent {
	public userCls = '';
}

describe('HlmAvatarImageDirective', () => {
	let component: HlmMockComponent;
	let fixture: ComponentFixture<HlmMockComponent>;

	beforeEach(() => {
		fixture = TestBed.createComponent(HlmMockComponent);
		component = fixture.componentInstance;
	});

	it('should compile', () => {
		expect(component).toBeTruthy();
	});

	it('should add the default classes if no inputs are provided', () => {
		fixture.detectChanges();
		expect(fixture.nativeElement.querySelector('img').className).toBe('aspect-square h-full object-cover w-full');
	});

	it('should add any user defined classes', async () => {
		component.userCls = 'test-class';
		fixture.detectChanges();

		// fallback uses Promise.resolve().then() so we need to wait for the next tick
		setTimeout(() => {
			expect(fixture.nativeElement.querySelector('img').className).toContain('test-class');
		});
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-avatar-helm/files/lib/image/hlm-avatar-image.directive.ts.template
```
import { Directive, computed, inject, input } from '@angular/core';
import { BrnAvatarImageDirective } from '@spartan-ng/brain/avatar';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: 'img[hlmAvatarImage]',
	standalone: true,
	exportAs: 'avatarImage',
	hostDirectives: [BrnAvatarImageDirective],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmAvatarImageDirective {
	public canShow = inject(BrnAvatarImageDirective).canShow;

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('aspect-square object-cover h-full w-full', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-avatar-helm/files/lib/image/index.ts.template
```
export * from './hlm-avatar-image.directive';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-accordion-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'accordion',
		internalName: 'ui-accordion-helm',
		publicName: 'ui-accordion-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-accordion-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';

import { HlmAccordionContentComponent } from './lib/hlm-accordion-content.component';
import { HlmAccordionIconDirective } from './lib/hlm-accordion-icon.directive';
import { HlmAccordionItemDirective } from './lib/hlm-accordion-item.directive';
import { HlmAccordionTriggerDirective } from './lib/hlm-accordion-trigger.directive';
import { HlmAccordionDirective } from './lib/hlm-accordion.directive';

export * from './lib/hlm-accordion-content.component';
export * from './lib/hlm-accordion-icon.directive';
export * from './lib/hlm-accordion-item.directive';
export * from './lib/hlm-accordion-trigger.directive';
export * from './lib/hlm-accordion.directive';

export const HlmAccordionImports = [
	HlmAccordionDirective,
	HlmAccordionItemDirective,
	HlmAccordionTriggerDirective,
	HlmAccordionIconDirective,
	HlmAccordionContentComponent,
] as const;

@NgModule({
	imports: [...HlmAccordionImports],
	exports: [...HlmAccordionImports],
})
export class HlmAccordionModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-accordion-helm/files/lib/hlm-accordion-content.component.ts.template
```
import { ChangeDetectionStrategy, Component, ViewEncapsulation, computed, input } from '@angular/core';
import { BrnAccordionContentComponent } from '@spartan-ng/brain/accordion';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-accordion-content',
	template: `
		<div [attr.inert]="_addInert()" style="overflow: hidden">
			<p [class]="_contentClass()">
				<ng-content />
			</p>
		</div>
	`,
	standalone: true,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmAccordionContentComponent extends BrnAccordionContentComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => {
		const gridRows = this.state() === 'open' ? 'grid-rows-[1fr]' : 'grid-rows-[0fr]';
		return hlm('text-sm transition-all grid', gridRows, this.userClass());
	});

	constructor() {
		super();
		this.setClassToCustomElement('pt-1 pb-4');
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-accordion-helm/files/lib/hlm-accordion-icon.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { provideIcons } from '@ng-icons/core';
import { lucideChevronDown } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { provideHlmIconConfig } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

@Directive({
	selector: 'ng-icon[hlmAccordionIcon], ng-icon[hlmAccIcon]',
	standalone: true,
	providers: [provideIcons({ lucideChevronDown }), provideHlmIconConfig({ size: 'sm' })],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmAccordionIconDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm('inline-block h-4 w-4 transition-transform [animation-duration:200]', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-accordion-helm/files/lib/hlm-accordion-item.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { BrnAccordionItemDirective } from '@spartan-ng/brain/accordion';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmAccordionItem],brn-accordion-item[hlm],hlm-accordion-item',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [
		{
			directive: BrnAccordionItemDirective,
			inputs: ['isOpened'],
		},
	],
})
export class HlmAccordionItemDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm('flex flex-1 flex-col border-b border-border', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-accordion-helm/files/lib/hlm-accordion-trigger.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { BrnAccordionTriggerDirective } from '@spartan-ng/brain/accordion';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmAccordionTrigger]',
	standalone: true,
	host: {
		'[style.--tw-ring-offset-shadow]': '"0 0 #000"',
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnAccordionTriggerDirective],
})
export class HlmAccordionTriggerDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'w-full focus-visible:outline-none text-sm focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-2 flex flex-1 items-center justify-between py-4 px-0.5 font-medium underline-offset-4 hover:underline [&[data-state=open]>[hlmAccordionIcon]]:rotate-180 [&[data-state=open]>[hlmAccIcon]]:rotate-180',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-accordion-helm/files/lib/hlm-accordion.directive.ts.template
```
import { Directive, computed, inject, input } from '@angular/core';
import { BrnAccordionDirective } from '@spartan-ng/brain/accordion';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmAccordion], hlm-accordion',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [{ directive: BrnAccordionDirective, inputs: ['type', 'dir', 'orientation'] }],
})
export class HlmAccordionDirective {
	private readonly _brn = inject(BrnAccordionDirective);

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm('flex', this._brn.orientation() === 'horizontal' ? 'flex-row' : 'flex-col', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-form-field-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'formfield',
		internalName: 'ui-form-field-helm',
		publicName: 'ui-formfield-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-form-field-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmErrorDirective } from './lib/hlm-error.directive';
import { HlmFormFieldComponent } from './lib/hlm-form-field.component';
import { HlmHintDirective } from './lib/hlm-hint.directive';

export * from './lib/hlm-error.directive';
export * from './lib/hlm-form-field.component';
export * from './lib/hlm-hint.directive';

@NgModule({
	imports: [HlmFormFieldComponent, HlmErrorDirective, HlmHintDirective],
	exports: [HlmFormFieldComponent, HlmErrorDirective, HlmHintDirective],
})
export class HlmFormFieldModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-form-field-helm/files/lib/form-field.spec.ts.template
```
/* eslint-disable @angular-eslint/component-class-suffix */
/* eslint-disable @angular-eslint/component-selector */
import { Component } from '@angular/core';
import { FormControl, ReactiveFormsModule, Validators } from '@angular/forms';
import { render, screen } from '@testing-library/angular';
import userEvent from '@testing-library/user-event';

import { HlmInputDirective } from '@spartan-ng/ui-input-helm';

import { ErrorStateMatcher, ShowOnDirtyErrorStateMatcher } from '@spartan-ng/brain/forms';
import { HlmErrorDirective } from './hlm-error.directive';
import { HlmFormFieldComponent } from './hlm-form-field.component';
import { HlmHintDirective } from './hlm-hint.directive';

const DIRECTIVES = [HlmFormFieldComponent, HlmErrorDirective, HlmHintDirective, HlmInputDirective];

@Component({
	standalone: true,
	selector: 'single-form-field-example',
	imports: [ReactiveFormsModule, ...DIRECTIVES],
	template: `
		<hlm-form-field>
			<input
				data-testid="hlm-input"
				aria-label="Your Name"
				[formControl]="name"
				class="w-80"
				hlmInput
				type="text"
				placeholder="Your Name"
			/>
			<hlm-error data-testid="hlm-error">Your name is required</hlm-error>
			<hlm-hint data-testid="hlm-hint">This is your public display name.</hlm-hint>
		</hlm-form-field>
	`,
})
class SingleFormFieldMock {
	public name = new FormControl('', Validators.required);
}

@Component({
	standalone: true,
	selector: 'single-form-field-dirty-example',
	imports: [ReactiveFormsModule, ...DIRECTIVES],
	template: `
		<hlm-form-field>
			<input
				data-testid="hlm-input"
				aria-label="Your Name"
				[formControl]="name"
				class="w-80"
				hlmInput
				type="text"
				placeholder="Your Name"
			/>
			<hlm-error data-testid="hlm-error">Your name is required</hlm-error>
			<hlm-hint data-testid="hlm-hint">This is your public display name.</hlm-hint>
		</hlm-form-field>
	`,
	providers: [{ provide: ErrorStateMatcher, useClass: ShowOnDirtyErrorStateMatcher }],
})
class SingleFormFieldDirtyMock {
	public name = new FormControl('', Validators.required);
}

describe('Hlm Form Field Component', () => {
	const TEXT_HINT = 'This is your public display name.';
	const TEXT_ERROR = 'Your name is required';

	const setupFormField = async () => {
		const { fixture } = await render(SingleFormFieldMock);
		return {
			user: userEvent.setup(),
			fixture,
			hint: screen.getByTestId('hlm-hint'),
			error: () => screen.queryByTestId('hlm-error'),
			trigger: screen.getByTestId('hlm-input'),
		};
	};

	const setupFormFieldWithErrorStateDirty = async () => {
		const { fixture } = await render(SingleFormFieldDirtyMock);
		return {
			user: userEvent.setup(),
			fixture,
			hint: screen.getByTestId('hlm-hint'),
			error: () => screen.queryByTestId('hlm-error'),
			trigger: screen.getByTestId('hlm-input'),
		};
	};

	describe('SingleFormField', () => {
		it('should show the hint if the errorState is false', async () => {
			const { hint } = await setupFormField();

			expect(hint.textContent).toBe(TEXT_HINT);
		});

		it('should show the error if the errorState is true', async () => {
			const { user, error, trigger } = await setupFormField();

			expect(error()).toBeNull();

			await user.click(trigger);

			await user.click(document.body);

			expect(screen.queryByTestId('hlm-hint')).toBeNull();
			expect(error()?.textContent?.trim()).toBe(TEXT_ERROR);
		});
	});

	describe('SingleFormFieldDirty', () => {
		it('should not display the error if the input does not have the dirty state due to the ErrorStateMatcher', async () => {
			const { error, user, trigger } = await setupFormFieldWithErrorStateDirty();

			await user.click(trigger);

			await user.click(document.body);

			expect(error()).toBeNull();
		});

		it('should display the error if the input has the dirty state due to the ErrorStateMatcher', async () => {
			const { error, user, trigger } = await setupFormFieldWithErrorStateDirty();

			await user.click(trigger);
			await user.type(trigger, 'a');
			await user.clear(trigger);

			await user.click(document.body);

			expect(error()?.textContent?.trim()).toBe(TEXT_ERROR);
		});
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-form-field-helm/files/lib/hlm-error.directive.ts.template
```
import { Directive } from '@angular/core';

@Directive({
	standalone: true,
	// eslint-disable-next-line @angular-eslint/directive-selector
	selector: 'hlm-error',
	host: {
		class: 'block text-destructive text-sm font-medium',
	},
})
export class HlmErrorDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-form-field-helm/files/lib/hlm-form-field.component.ts.template
```
import { Component, computed, contentChild, contentChildren, effect } from '@angular/core';
import { BrnFormFieldControl } from '@spartan-ng/brain/form-field';
import { HlmErrorDirective } from './hlm-error.directive';

@Component({
	selector: 'hlm-form-field',
	template: `
		<ng-content />

		@switch (hasDisplayedMessage()) {
			@case ('error') {
				<ng-content select="hlm-error" />
			}
			@default {
				<ng-content select="hlm-hint" />
			}
		}
	`,
	standalone: true,
	host: {
		class: 'space-y-2 block',
	},
})
export class HlmFormFieldComponent {
	public readonly control = contentChild(BrnFormFieldControl);

	public readonly errorChildren = contentChildren(HlmErrorDirective);

	protected readonly hasDisplayedMessage = computed<'error' | 'hint'>(() =>
		this.errorChildren() && this.errorChildren().length > 0 && this.control()?.errorState() ? 'error' : 'hint',
	);

	constructor() {
		effect(() => {
			if (!this.control()) {
				throw new Error('hlm-form-field must contain a BrnFormFieldControl.');
			}
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-form-field-helm/files/lib/hlm-hint.directive.ts.template
```
import { Directive } from '@angular/core';

@Directive({
	// eslint-disable-next-line @angular-eslint/directive-selector
	selector: 'hlm-hint',
	standalone: true,
	host: {
		class: 'block text-sm text-muted-foreground',
	},
})
export class HlmHintDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-alert-dialog-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'alertdialog',
		internalName: 'ui-alert-dialog-helm',
		publicName: 'ui-alertdialog-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-alert-dialog-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';

import { HlmAlertDialogActionButtonDirective } from './lib/hlm-alert-dialog-action-button.directive';
import { HlmAlertDialogCancelButtonDirective } from './lib/hlm-alert-dialog-cancel-button.directive';
import { HlmAlertDialogContentComponent } from './lib/hlm-alert-dialog-content.component';
import { HlmAlertDialogDescriptionDirective } from './lib/hlm-alert-dialog-description.directive';
import { HlmAlertDialogFooterComponent } from './lib/hlm-alert-dialog-footer.component';
import { HlmAlertDialogHeaderComponent } from './lib/hlm-alert-dialog-header.component';
import { HlmAlertDialogOverlayDirective } from './lib/hlm-alert-dialog-overlay.directive';
import { HlmAlertDialogTitleDirective } from './lib/hlm-alert-dialog-title.directive';
import { HlmAlertDialogComponent } from './lib/hlm-alert-dialog.component';

export * from './lib/hlm-alert-dialog-action-button.directive';
export * from './lib/hlm-alert-dialog-cancel-button.directive';
export * from './lib/hlm-alert-dialog-content.component';
export * from './lib/hlm-alert-dialog-description.directive';
export * from './lib/hlm-alert-dialog-footer.component';
export * from './lib/hlm-alert-dialog-header.component';
export * from './lib/hlm-alert-dialog-overlay.directive';
export * from './lib/hlm-alert-dialog-title.directive';
export * from './lib/hlm-alert-dialog.component';

export const HlmAlertDialogImports = [
	HlmAlertDialogContentComponent,
	HlmAlertDialogDescriptionDirective,
	HlmAlertDialogFooterComponent,
	HlmAlertDialogHeaderComponent,
	HlmAlertDialogOverlayDirective,
	HlmAlertDialogTitleDirective,
	HlmAlertDialogActionButtonDirective,
	HlmAlertDialogCancelButtonDirective,
	HlmAlertDialogComponent,
] as const;

@NgModule({
	imports: [...HlmAlertDialogImports],
	exports: [...HlmAlertDialogImports],
})
export class HlmAlertDialogModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-alert-dialog-helm/files/lib/hlm-alert-dialog-action-button.directive.ts.template
```
import { Directive } from '@angular/core';
import { HlmButtonDirective } from '@spartan-ng/ui-button-helm';

@Directive({
	selector: 'button[hlmAlertDialogAction]',
	standalone: true,
	hostDirectives: [HlmButtonDirective],
})
export class HlmAlertDialogActionButtonDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-alert-dialog-helm/files/lib/hlm-alert-dialog-cancel-button.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { HlmButtonDirective, provideBrnButtonConfig } from '@spartan-ng/ui-button-helm';
import type { ClassValue } from 'clsx';

@Directive({
	selector: 'button[hlmAlertDialogCancel]',
	standalone: true,
	hostDirectives: [HlmButtonDirective],
	providers: [provideBrnButtonConfig({ variant: 'outline' })],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmAlertDialogCancelButtonDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm('mt-2 sm:mt-0', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-alert-dialog-helm/files/lib/hlm-alert-dialog-content.component.ts.template
```
import { ChangeDetectionStrategy, Component, ViewEncapsulation, computed, input, signal } from '@angular/core';
import { hlm, injectExposesStateProvider } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-alert-dialog-content',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		'[attr.data-state]': 'state()',
	},
	template: `
		<ng-content />
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class HlmAlertDialogContentComponent {
	private readonly _stateProvider = injectExposesStateProvider({ optional: true, host: true });
	public readonly state = this._stateProvider?.state ?? signal('closed');

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'relative grid w-full max-w-lg gap-4 border-border border bg-background p-6 shadow-lg [animation-duration:200] data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-top-[2%]  data-[state=open]:slide-in-from-top-[2%] sm:rounded-lg md:w-full',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-alert-dialog-helm/files/lib/hlm-alert-dialog-description.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { BrnAlertDialogDescriptionDirective } from '@spartan-ng/brain/alert-dialog';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmAlertDialogDescription]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnAlertDialogDescriptionDirective],
})
export class HlmAlertDialogDescriptionDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm('text-sm text-muted-foreground', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-alert-dialog-helm/files/lib/hlm-alert-dialog-footer.component.ts.template
```
import { ChangeDetectionStrategy, Component, ViewEncapsulation, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-alert-dialog-footer',
	standalone: true,
	template: `
		<ng-content />
	`,
	host: {
		'[class]': '_computedClass()',
	},
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class HlmAlertDialogFooterComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm('flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-alert-dialog-helm/files/lib/hlm-alert-dialog-header.component.ts.template
```
import { ChangeDetectionStrategy, Component, ViewEncapsulation, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-alert-dialog-header',
	standalone: true,
	template: `
		<ng-content />
	`,
	host: {
		'[class]': '_computedClass()',
	},
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class HlmAlertDialogHeaderComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm('flex flex-col space-y-2 text-center sm:text-left', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-alert-dialog-helm/files/lib/hlm-alert-dialog-overlay.directive.ts.template
```
import { Directive, computed, effect, input, untracked } from '@angular/core';
import { hlm, injectCustomClassSettable } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmAlertDialogOverlay],brn-alert-dialog-overlay[hlm]',
	standalone: true,
})
export class HlmAlertDialogOverlayDirective {
	private readonly _classSettable = injectCustomClassSettable({ optional: true, host: true });

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
			this.userClass(),
		),
	);

	constructor() {
		effect(() => {
			const classValue = this._computedClass();
			untracked(() => this._classSettable?.setClassToCustomElement(classValue));
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-alert-dialog-helm/files/lib/hlm-alert-dialog-title.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { BrnAlertDialogTitleDirective } from '@spartan-ng/brain/alert-dialog';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmAlertDialogTitle]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnAlertDialogTitleDirective],
})
export class HlmAlertDialogTitleDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm('text-lg font-semibold', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-alert-dialog-helm/files/lib/hlm-alert-dialog.component.ts.template
```
import { ChangeDetectionStrategy, Component, forwardRef, ViewEncapsulation } from '@angular/core';
import {
	BRN_ALERT_DIALOG_DEFAULT_OPTIONS,
	BrnAlertDialogComponent,
	BrnAlertDialogOverlayComponent,
} from '@spartan-ng/brain/alert-dialog';
import { BrnDialogComponent, provideBrnDialogDefaultOptions } from '@spartan-ng/brain/dialog';
import { HlmAlertDialogOverlayDirective } from './hlm-alert-dialog-overlay.directive';

@Component({
	selector: 'hlm-alert-dialog',
	template: `
		<brn-alert-dialog-overlay hlm />
		<ng-content />
	`,
	providers: [
		{
			provide: BrnDialogComponent,
			useExisting: forwardRef(() => HlmAlertDialogComponent),
		},
		provideBrnDialogDefaultOptions({
			...BRN_ALERT_DIALOG_DEFAULT_OPTIONS,
		}),
	],
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	exportAs: 'hlmAlertDialog',
	imports: [BrnAlertDialogOverlayComponent, HlmAlertDialogOverlayDirective],
})
export class HlmAlertDialogComponent extends BrnAlertDialogComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-dialog-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'dialog',
		internalName: 'ui-dialog-helm',
		publicName: 'ui-dialog-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-dialog-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';

import { HlmDialogCloseDirective } from './lib/hlm-dialog-close.directive';
import { HlmDialogContentComponent } from './lib/hlm-dialog-content.component';
import { HlmDialogDescriptionDirective } from './lib/hlm-dialog-description.directive';
import { HlmDialogFooterComponent } from './lib/hlm-dialog-footer.component';
import { HlmDialogHeaderComponent } from './lib/hlm-dialog-header.component';
import { HlmDialogOverlayDirective } from './lib/hlm-dialog-overlay.directive';
import { HlmDialogTitleDirective } from './lib/hlm-dialog-title.directive';
import { HlmDialogComponent } from './lib/hlm-dialog.component';

export * from './lib/hlm-dialog-close.directive';
export * from './lib/hlm-dialog-content.component';
export * from './lib/hlm-dialog-description.directive';
export * from './lib/hlm-dialog-footer.component';
export * from './lib/hlm-dialog-header.component';
export * from './lib/hlm-dialog-overlay.directive';
export * from './lib/hlm-dialog-title.directive';
export * from './lib/hlm-dialog.component';
export * from './lib/hlm-dialog.service';

export const HlmDialogImports = [
	HlmDialogComponent,
	HlmDialogCloseDirective,
	HlmDialogContentComponent,
	HlmDialogDescriptionDirective,
	HlmDialogFooterComponent,
	HlmDialogHeaderComponent,
	HlmDialogOverlayDirective,
	HlmDialogTitleDirective,
] as const;

@NgModule({
	imports: [...HlmDialogImports],
	exports: [...HlmDialogImports],
})
export class HlmDialogModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-dialog-helm/files/lib/hlm-dialog-close.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmDialogClose],[brnDialogClose][hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmDialogCloseDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm(
			'absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-dialog-helm/files/lib/hlm-dialog-content.component.ts.template
```
import { NgComponentOutlet } from '@angular/common';
import { ChangeDetectionStrategy, Component, ViewEncapsulation, computed, inject, input } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideX } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { BrnDialogCloseDirective, BrnDialogRef, injectBrnDialogContext } from '@spartan-ng/brain/dialog';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';
import { HlmDialogCloseDirective } from './hlm-dialog-close.directive';

@Component({
	selector: 'hlm-dialog-content',
	imports: [NgComponentOutlet, BrnDialogCloseDirective, HlmDialogCloseDirective, NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideX })],
	host: {
		'[class]': '_computedClass()',
		'[attr.data-state]': 'state()',
	},
	template: `
		@if (component) {
			<ng-container [ngComponentOutlet]="component" />
		} @else {
			<ng-content />
		}

		<button brnDialogClose hlm>
			<span class="sr-only">Close</span>
			<ng-icon hlm size="sm" name="lucideX" />
		</button>
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class HlmDialogContentComponent {
	private readonly _dialogRef = inject(BrnDialogRef);
	private readonly _dialogContext = injectBrnDialogContext({ optional: true });

	public readonly state = computed(() => this._dialogRef?.state() ?? 'closed');

	public readonly component = this._dialogContext?.$component;
	private readonly _dynamicComponentClass = this._dialogContext?.$dynamicComponentClass;

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'border-border grid w-full max-w-lg relative gap-4 border bg-background p-6 shadow-lg [animation-duration:200] data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-top-[2%]  data-[state=open]:slide-in-from-top-[2%] sm:rounded-lg md:w-full',
			this.userClass(),
			this._dynamicComponentClass,
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-dialog-helm/files/lib/hlm-dialog-description.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnDialogDescriptionDirective } from '@spartan-ng/brain/dialog';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmDialogDescription]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnDialogDescriptionDirective],
})
export class HlmDialogDescriptionDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('text-sm text-muted-foreground', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-dialog-helm/files/lib/hlm-dialog-footer.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-dialog-footer',
	standalone: true,
	template: `
		<ng-content />
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmDialogFooterComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm('flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-dialog-helm/files/lib/hlm-dialog-header.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-dialog-header',
	standalone: true,
	template: `
		<ng-content />
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmDialogHeaderComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm('flex flex-col space-y-1.5 text-center sm:text-left', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-dialog-helm/files/lib/hlm-dialog-overlay.directive.ts.template
```
import { Directive, computed, effect, input, untracked } from '@angular/core';
import { hlm, injectCustomClassSettable } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmDialogOverlayClass =
	'bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0';

@Directive({
	selector: '[hlmDialogOverlay],brn-dialog-overlay[hlm]',
	standalone: true,
})
export class HlmDialogOverlayDirective {
	private readonly _classSettable = injectCustomClassSettable({ optional: true, host: true });

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm(hlmDialogOverlayClass, this.userClass()));

	constructor() {
		effect(() => {
			const newClass = this._computedClass();
			untracked(() => this._classSettable?.setClassToCustomElement(newClass));
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-dialog-helm/files/lib/hlm-dialog-title.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnDialogTitleDirective } from '@spartan-ng/brain/dialog';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmDialogTitle]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnDialogTitleDirective],
})
export class HlmDialogTitleDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('text-lg font-semibold leading-none tracking-tight', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-dialog-helm/files/lib/hlm-dialog.component.ts.template
```
import { ChangeDetectionStrategy, Component, forwardRef, ViewEncapsulation } from '@angular/core';
import {
	BrnDialogComponent,
	BrnDialogOverlayComponent,
	provideBrnDialogDefaultOptions,
} from '@spartan-ng/brain/dialog';
import { HlmDialogOverlayDirective } from './hlm-dialog-overlay.directive';

@Component({
	selector: 'hlm-dialog',
	imports: [BrnDialogOverlayComponent, HlmDialogOverlayDirective],
	providers: [
		{
			provide: BrnDialogComponent,
			useExisting: forwardRef(() => HlmDialogComponent),
		},
		provideBrnDialogDefaultOptions({
			// add custom options here
		}),
	],
	template: `
		<brn-dialog-overlay hlm />
		<ng-content />
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	exportAs: 'hlmDialog',
})
export class HlmDialogComponent extends BrnDialogComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-dialog-helm/files/lib/hlm-dialog.service.ts.template
```
import type { ComponentType } from '@angular/cdk/portal';
import { Injectable, type TemplateRef, inject } from '@angular/core';
import {
	type BrnDialogOptions,
	BrnDialogService,
	DEFAULT_BRN_DIALOG_OPTIONS,
	cssClassesToArray,
} from '@spartan-ng/brain/dialog';
import { HlmDialogContentComponent } from './hlm-dialog-content.component';
import { hlmDialogOverlayClass } from './hlm-dialog-overlay.directive';

export type HlmDialogOptions<DialogContext = unknown> = BrnDialogOptions & {
	contentClass?: string;
	context?: DialogContext;
};

@Injectable({
	providedIn: 'root',
})
export class HlmDialogService {
	private readonly _brnDialogService = inject(BrnDialogService);

	public open(component: ComponentType<unknown> | TemplateRef<unknown>, options?: Partial<HlmDialogOptions>) {
		const mergedOptions = {
			...DEFAULT_BRN_DIALOG_OPTIONS,

			...(options ?? {}),
			backdropClass: cssClassesToArray(`${hlmDialogOverlayClass} ${options?.backdropClass ?? ''}`),
			context: { ...(options?.context ?? {}), $component: component, $dynamicComponentClass: options?.contentClass },
		};

		return this._brnDialogService.open(HlmDialogContentComponent, undefined, mergedOptions.context, mergedOptions);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-input-otp-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'inputotp',
		internalName: 'ui-input-otp-helm',
		publicName: 'ui-inputotp-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-input-otp-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmInputOtpFakeCaretComponent } from './lib/hlm-input-otp-fake-caret.component';
import { HlmInputOtpGroupDirective } from './lib/hlm-input-otp-group.directive';
import { HlmInputOtpSeparatorComponent } from './lib/hlm-input-otp-separator.component';
import { HlmInputOtpSlotComponent } from './lib/hlm-input-otp-slot.component';
import { HlmInputOtpDirective } from './lib/hlm-input-otp.directive';

export * from './lib/hlm-input-otp-fake-caret.component';
export * from './lib/hlm-input-otp-group.directive';
export * from './lib/hlm-input-otp-separator.component';
export * from './lib/hlm-input-otp-slot.component';
export * from './lib/hlm-input-otp.directive';

@NgModule({
	imports: [
		HlmInputOtpDirective,
		HlmInputOtpGroupDirective,
		HlmInputOtpSeparatorComponent,
		HlmInputOtpSlotComponent,
		HlmInputOtpFakeCaretComponent,
	],
	exports: [
		HlmInputOtpDirective,
		HlmInputOtpGroupDirective,
		HlmInputOtpSeparatorComponent,
		HlmInputOtpSlotComponent,
		HlmInputOtpFakeCaretComponent,
	],
})
export class HlmInputOtpModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-input-otp-helm/files/lib/hlm-input-otp-fake-caret.component.ts.template
```
import { Component } from '@angular/core';

@Component({
	selector: 'hlm-input-otp-fake-caret',
	standalone: true,
	template: `
		<div class="pointer-events-none absolute inset-0 flex items-center justify-center">
			<div class="animate-caret-blink bg-foreground h-4 w-px duration-1000"></div>
		</div>
	`,
})
export class HlmInputOtpFakeCaretComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-input-otp-helm/files/lib/hlm-input-otp-group.directive.ts.template
```
import { computed, Directive, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type ClassValue } from 'clsx';

@Directive({
	selector: '[hlmInputOtpGroup]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmInputOtpGroupDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() => hlm('flex items-center', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-input-otp-helm/files/lib/hlm-input-otp-separator.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideDot } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import { type ClassValue } from 'clsx';

@Component({
	selector: 'hlm-input-otp-separator',
	imports: [HlmIconDirective, NgIcon],
	providers: [provideIcons({ lucideDot })],
	template: `
		<ng-icon hlm name="lucideDot" />
	`,
	host: {
		role: 'separator',
		'[class]': '_computedClass()',
	},
})
export class HlmInputOtpSeparatorComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() => hlm(this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-input-otp-helm/files/lib/hlm-input-otp-slot.component.ts.template
```
import { NumberInput } from '@angular/cdk/coercion';
import { Component, computed, input, numberAttribute } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnInputOtpSlotComponent } from '@spartan-ng/brain/input-otp';
import { type ClassValue } from 'clsx';
import { HlmInputOtpFakeCaretComponent } from './hlm-input-otp-fake-caret.component';

@Component({
	selector: 'hlm-input-otp-slot',
	imports: [BrnInputOtpSlotComponent, HlmInputOtpFakeCaretComponent],
	template: `
		<brn-input-otp-slot [index]="index()">
			<hlm-input-otp-fake-caret />
		</brn-input-otp-slot>
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmInputOtpSlotComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	public readonly index = input.required<number, NumberInput>({ transform: numberAttribute });

	protected readonly _computedClass = computed(() =>
		hlm(
			'relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md',
			'has-[brn-input-otp-slot[data-active="true"]]:z-10 has-[brn-input-otp-slot[data-active="true"]]:ring-2 has-[brn-input-otp-slot[data-active="true"]]:ring-ring has-[brn-input-otp-slot[data-active="true"]]:ring-offset-background',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-input-otp-helm/files/lib/hlm-input-otp.directive.ts.template
```
import { computed, Directive, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type ClassValue } from 'clsx';

@Directive({
	selector: 'brn-input-otp [hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmInputOtpDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm('flex items-center gap-2 has-[:disabled]:opacity-50', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-button-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'button',
		internalName: 'ui-button-helm',
		publicName: 'ui-button-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-button-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmButtonDirective } from './lib/hlm-button.directive';
export * from './lib/hlm-button.token';

export * from './lib/hlm-button.directive';

@NgModule({
	imports: [HlmButtonDirective],
	exports: [HlmButtonDirective],
})
export class HlmButtonModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-button-helm/files/lib/hlm-button.directive.ts.template
```
import { Directive, computed, input, signal } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';
import { injectBrnButtonConfig } from './hlm-button.token';

export const buttonVariants = cva(
	'inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background',
	{
		variants: {
			variant: {
				default: 'bg-primary text-primary-foreground hover:bg-primary/90',
				destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
				outline: 'border border-input hover:bg-accent hover:text-accent-foreground',
				secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
				ghost: 'hover:bg-accent hover:text-accent-foreground',
				link: 'underline-offset-4 hover:underline text-primary',
			},
			size: {
				default: 'h-10 py-2 px-4',
				sm: 'h-9 px-3 rounded-md',
				lg: 'h-11 px-8 rounded-md',
				icon: 'h-10 w-10',
			},
		},
		defaultVariants: {
			variant: 'default',
			size: 'default',
		},
	},
);
export type ButtonVariants = VariantProps<typeof buttonVariants>;

@Directive({
	selector: '[hlmBtn]',
	standalone: true,
	exportAs: 'hlmBtn',
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmButtonDirective {
	private readonly _config = injectBrnButtonConfig();

	private readonly _additionalClasses = signal<ClassValue>('');

	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm(buttonVariants({ variant: this.variant(), size: this.size() }), this.userClass(), this._additionalClasses()),
	);

	public readonly variant = input<ButtonVariants['variant']>(this._config.variant);

	public readonly size = input<ButtonVariants['size']>(this._config.size);

	setClass(classes: string): void {
		this._additionalClasses.set(classes);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-button-helm/files/lib/hlm-button.token.ts.template
```
import { InjectionToken, ValueProvider, inject } from '@angular/core';
import type { ButtonVariants } from './hlm-button.directive';

export interface BrnButtonConfig {
	variant: ButtonVariants['variant'];
	size: ButtonVariants['size'];
}

const defaultConfig: BrnButtonConfig = {
	variant: 'default',
	size: 'default',
};

const BrnButtonConfigToken = new InjectionToken<BrnButtonConfig>('BrnButtonConfig');

export function provideBrnButtonConfig(config: Partial<BrnButtonConfig>): ValueProvider {
	return { provide: BrnButtonConfigToken, useValue: { ...defaultConfig, ...config } };
}

export function injectBrnButtonConfig(): BrnButtonConfig {
	return inject(BrnButtonConfigToken, { optional: true }) ?? defaultConfig;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-label-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'label',
		internalName: 'ui-label-helm',
		publicName: 'ui-label-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-label-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmLabelDirective } from './lib/hlm-label.directive';

export * from './lib/hlm-label.directive';

@NgModule({
	imports: [HlmLabelDirective],
	exports: [HlmLabelDirective],
})
export class HlmLabelModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-label-helm/files/lib/hlm-label.directive.ts.template
```
import { Directive, computed, inject, input, signal } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnLabelDirective } from '@spartan-ng/brain/label';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const labelVariants = cva(
	'text-sm font-medium leading-none [&>[hlmInput]]:my-1 [&:has([hlmInput]:disabled)]:cursor-not-allowed [&:has([hlmInput]:disabled)]:opacity-70',
	{
		variants: {
			variant: {
				default: '',
			},
			error: {
				auto: '[&:has([hlmInput].ng-invalid.ng-touched)]:text-destructive',
				true: 'text-destructive',
			},
			disabled: {
				auto: '[&:has([hlmInput]:disabled)]:opacity-70',
				true: 'opacity-70',
				false: '',
			},
		},
		defaultVariants: {
			variant: 'default',
			error: 'auto',
		},
	},
);
export type LabelVariants = VariantProps<typeof labelVariants>;

@Directive({
	selector: '[hlmLabel]',
	standalone: true,
	hostDirectives: [
		{
			directive: BrnLabelDirective,
			inputs: ['id'],
		},
	],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmLabelDirective {
	private readonly _brn = inject(BrnLabelDirective, { host: true });

	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	public readonly variant = input<LabelVariants['variant']>('default');

	public readonly error = input<LabelVariants['error']>('auto');

	protected readonly state = computed(() => ({
		error: signal(this.error()),
	}));

	protected readonly _computedClass = computed(() =>
		hlm(
			labelVariants({
				variant: this.variant(),
				error: this.state().error(),
				disabled: this._brn?.dataDisabled() ?? 'auto',
			}),
			'[&.ng-invalid.ng-touched]:text-destructive',
			this.userClass(),
		),
	);

	setError(error: LabelVariants['error']): void {
		this.state().error.set(error);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-breadcrumb-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'breadcrumb',
		internalName: 'ui-breadcrumb-helm',
		publicName: 'ui-breadcrumb-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-breadcrumb-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmBreadcrumbEllipsisComponent } from './lib/breadcrumb-ellipsis.component';
import { HlmBreadcrumbItemDirective } from './lib/breadcrumb-item.directive';
import { HlmBreadcrumbLinkDirective } from './lib/breadcrumb-link.directive';
import { HlmBreadcrumbListDirective } from './lib/breadcrumb-list.directive';
import { HlmBreadcrumbPageDirective } from './lib/breadcrumb-page.directive';
import { HlmBreadcrumbSeparatorComponent } from './lib/breadcrumb-separator.component';
import { HlmBreadcrumbDirective } from './lib/breadcrumb.directive';

export * from './lib/breadcrumb-ellipsis.component';
export * from './lib/breadcrumb-item.directive';
export * from './lib/breadcrumb-link.directive';
export * from './lib/breadcrumb-list.directive';
export * from './lib/breadcrumb-page.directive';
export * from './lib/breadcrumb-separator.component';
export * from './lib/breadcrumb.directive';

export const HlmBreadCrumbImports = [
	HlmBreadcrumbDirective,
	HlmBreadcrumbEllipsisComponent,
	HlmBreadcrumbSeparatorComponent,
	HlmBreadcrumbItemDirective,
	HlmBreadcrumbLinkDirective,
	HlmBreadcrumbPageDirective,
	HlmBreadcrumbListDirective,
] as const;

@NgModule({
	imports: [...HlmBreadCrumbImports],
	exports: [...HlmBreadCrumbImports],
})
export class HlmBreadCrumbModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-breadcrumb-helm/files/lib/breadcrumb-ellipsis.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideEllipsis } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-breadcrumb-ellipsis',
	imports: [NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideEllipsis })],
	template: `
		<span role="presentation" aria-hidden="true" [class]="_computedClass()">
			<ng-icon hlm size="sm" name="lucideEllipsis" />
			<span class="sr-only">More</span>
		</span>
	`,
})
export class HlmBreadcrumbEllipsisComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() => hlm('flex h-9 w-9 items-center justify-center', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-breadcrumb-helm/files/lib/breadcrumb-item.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmBreadcrumbItem]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmBreadcrumbItemDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() => hlm('inline-flex items-center gap-1.5', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-breadcrumb-helm/files/lib/breadcrumb-link.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { RouterLink } from '@angular/router';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmBreadcrumbLink]',
	standalone: true,
	hostDirectives: [
		{
			directive: RouterLink,
			inputs: [
				'target',
				'queryParams',
				'fragment',
				'queryParamsHandling',
				'state',
				'info',
				'relativeTo',
				'preserveFragment',
				'skipLocationChange',
				'replaceUrl',
				'routerLink: link',
			],
		},
	],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmBreadcrumbLinkDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly link = input<RouterLink['routerLink']>();

	protected readonly _computedClass = computed(() => hlm('transition-colors hover:text-foreground', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-breadcrumb-helm/files/lib/breadcrumb-list.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmBreadcrumbList]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmBreadcrumbListDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm('flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-breadcrumb-helm/files/lib/breadcrumb-page.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmBreadcrumbPage]',
	standalone: true,
	host: {
		role: 'link',
		'[class]': '_computedClass()',
		'[attr.aria-disabled]': 'disabled',
		'[attr.aria-current]': 'page',
	},
})
export class HlmBreadcrumbPageDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() => hlm('font-normal text-foreground', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-breadcrumb-helm/files/lib/breadcrumb-separator.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronRight } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	// eslint-disable-next-line @angular-eslint/component-selector
	selector: '[hlmBreadcrumbSeparator]',
	imports: [NgIcon],
	providers: [provideIcons({ lucideChevronRight })],
	host: {
		role: 'presentation',
		'[class]': '_computedClass()',
		'[attr.aria-hidden]': 'true',
	},
	template: `
		<ng-content>
			<ng-icon name="lucideChevronRight" />
		</ng-content>
	`,
})
export class HlmBreadcrumbSeparatorComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm('[&>ng-icon]:text-[14px] [&>ng-icon]:flex!', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-breadcrumb-helm/files/lib/breadcrumb.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmBreadcrumb]',
	standalone: true,
	host: {
		role: 'navigation',
		'[class]': '_computedClass()',
		'[attr.aria-label]': 'ariaLabel()',
	},
})
export class HlmBreadcrumbDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly ariaLabel = input<string>('breadcrumb', { alias: 'aria-label' });

	protected readonly _computedClass = computed(() => hlm(this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-command-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'command',
		internalName: 'ui-command-helm',
		publicName: 'ui-command-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-command-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';

import { HlmCommandDialogCloseButtonDirective } from './lib/hlm-command-dialog-close-button.directive';
import { HlmCommandDialogDirective } from './lib/hlm-command-dialog.directive';
import { HlmCommandEmptyDirective } from './lib/hlm-command-empty.directive';
import { HlmCommandGroupLabelComponent } from './lib/hlm-command-group-label.component';
import { HlmCommandGroupComponent } from './lib/hlm-command-group.component';
import { HlmCommandIconDirective } from './lib/hlm-command-icon.directive';
import { HlmCommandItemComponent } from './lib/hlm-command-item.component';
import { HlmCommandListComponent } from './lib/hlm-command-list.component';
import { HlmCommandSearchInputComponent } from './lib/hlm-command-search-input.component';
import { HlmCommandSearchComponent } from './lib/hlm-command-search.component';
import { HlmCommandSeparatorComponent } from './lib/hlm-command-separator.component';
import { HlmCommandShortcutComponent } from './lib/hlm-command-shortcut.component';
import { HlmCommandComponent } from './lib/hlm-command.component';

export * from './lib/hlm-command-dialog-close-button.directive';
export * from './lib/hlm-command-dialog.directive';
export * from './lib/hlm-command-empty.directive';
export * from './lib/hlm-command-group-label.component';
export * from './lib/hlm-command-group.component';
export * from './lib/hlm-command-icon.directive';
export * from './lib/hlm-command-item.component';
export * from './lib/hlm-command-list.component';
export * from './lib/hlm-command-search-input.component';
export * from './lib/hlm-command-search.component';
export * from './lib/hlm-command-separator.component';
export * from './lib/hlm-command-shortcut.component';
export * from './lib/hlm-command.component';

export const HlmCommandImports = [
	HlmCommandComponent,
	HlmCommandItemComponent,
	HlmCommandSeparatorComponent,
	HlmCommandGroupComponent,
	HlmCommandListComponent,
	HlmCommandShortcutComponent,
	HlmCommandIconDirective,
	HlmCommandDialogCloseButtonDirective,
	HlmCommandDialogDirective,
	HlmCommandSearchInputComponent,
	HlmCommandSearchComponent,
	HlmCommandGroupLabelComponent,
	HlmCommandEmptyDirective,
] as const;

@NgModule({
	imports: [...HlmCommandImports],
	exports: [...HlmCommandImports],
})
export class HlmCommandModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-command-helm/files/lib/hlm-command-dialog-close-button.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnDialogCloseDirective } from '@spartan-ng/brain/dialog';
import { HlmButtonDirective, provideBrnButtonConfig } from '@spartan-ng/ui-button-helm';
import { provideHlmIconConfig } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmCommandDialogCloseBtn]',
	standalone: true,
	hostDirectives: [HlmButtonDirective, BrnDialogCloseDirective],
	providers: [provideBrnButtonConfig({ variant: 'ghost' }), provideHlmIconConfig({ size: 'xs' })],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCommandDialogCloseButtonDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'absolute top-3 right-3 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-ring font-medium h-10 hover:bg-accent hover:text-accent-foreground inline-flex items-center justify-center px-4 py-2 ring-offset-background rounded-md text-sm transition-colors !h-5 !p-1 !w-5',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-command-helm/files/lib/hlm-command-dialog.directive.ts.template
```
import { Directive, ElementRef, Renderer2, computed, contentChild, effect, inject, input, signal } from '@angular/core';
import { BrnCommandSearchInputToken } from '@spartan-ng/brain/command';
import { hlm, injectExposesStateProvider } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmCommandDialog]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCommandDialogDirective {
	private readonly _stateProvider = injectExposesStateProvider({ host: true });
	public readonly state = this._stateProvider.state ?? signal('closed').asReadonly();
	private readonly _renderer = inject(Renderer2);
	private readonly _element = inject(ElementRef);

	/** Access the search field */
	private readonly _searchInput = contentChild(BrnCommandSearchInputToken, { read: ElementRef });

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-top-[2%]  data-[state=open]:slide-in-from-top-[2%]',
			this.userClass(),
		),
	);

	constructor() {
		effect(() => {
			this._renderer.setAttribute(this._element.nativeElement, 'data-state', this.state());

			const searchInput = this._searchInput();

			if (this.state() === 'open' && searchInput) {
				searchInput.nativeElement.focus();
			}
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-command-helm/files/lib/hlm-command-empty.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmCommandEmpty]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCommandEmptyDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm('py-6 text-center text-sm', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-command-helm/files/lib/hlm-command-group-label.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';

@Component({
	standalone: true,
	selector: 'hlm-command-group-label',
	template: '<ng-content />',
	host: {
		role: 'presentation',
		'[class]': '_computedClass()',
	},
})
export class HlmCommandGroupLabelComponent {
	/*** The user defined class  */
	public readonly userClass = input<string>('', { alias: 'class' });

	/*** The styles to apply  */
	protected readonly _computedClass = computed(() =>
		hlm('font-medium px-2 py-1.5 text-muted-foreground text-xs', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-command-helm/files/lib/hlm-command-group.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { BrnCommandGroupDirective } from '@spartan-ng/brain/command';
import { hlm } from '@spartan-ng/brain/core';

@Component({
	standalone: true,
	selector: 'hlm-command-group',
	template: '<ng-content />',
	hostDirectives: [
		{
			directive: BrnCommandGroupDirective,
			inputs: ['id'],
		},
	],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCommandGroupComponent {
	/*** The user defined class  */
	public readonly userClass = input<string>('', { alias: 'class' });

	/*** The styles to apply  */
	protected readonly _computedClass = computed(() =>
		hlm('flex flex-col overflow-hidden p-1 text-foreground data-[hidden]:hidden', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-command-helm/files/lib/hlm-command-icon.directive.ts.template
```
import { Directive } from '@angular/core';
import { provideHlmIconConfig } from '@spartan-ng/ui-icon-helm';

@Directive({
	standalone: true,
	selector: '[hlmCommandIcon]',
	host: {
		class: 'inline-flex mr-2 w-4 h-4',
	},
	providers: [provideHlmIconConfig({ size: 'sm' })],
})
export class HlmCommandIconDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-command-helm/files/lib/hlm-command-item.component.ts.template
```
import { BooleanInput } from '@angular/cdk/coercion';
import { booleanAttribute, Component, computed, input, output } from '@angular/core';
import { BrnCommandItemDirective } from '@spartan-ng/brain/command';
import { hlm } from '@spartan-ng/brain/core';

@Component({
	standalone: true,
	selector: 'button[hlm-command-item]',
	template: `
		<ng-content />
	`,
	hostDirectives: [
		{
			directive: BrnCommandItemDirective,
			inputs: ['value', 'disabled', 'id'],
			outputs: ['selected'],
		},
	],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCommandItemComponent {
	/** The value this item represents. */
	public readonly value = input<string>();

	/** Whether the item is disabled. */
	public readonly disabled = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** Emits when the item is selected. */
	public readonly selected = output<void>();

	/*** The user defined class  */
	public readonly userClass = input<string>('', { alias: 'class' });

	/*** The styles to apply  */
	protected readonly _computedClass = computed(() =>
		hlm(
			'text-start aria-selected:bg-accent aria-selected:text-accent-foreground cursor-default disabled:opacity-50 disabled:pointer-events-none hover:bg-accent/50 items-center outline-none px-2 py-1.5 relative flex rounded-sm select-none text-sm data-[hidden]:hidden',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-command-helm/files/lib/hlm-command-list.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { BrnCommandListDirective } from '@spartan-ng/brain/command';
import { hlm } from '@spartan-ng/brain/core';

@Component({
	standalone: true,
	selector: 'hlm-command-list',
	template: '<ng-content />',
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [
		{
			directive: BrnCommandListDirective,
			inputs: ['id'],
		},
	],
})
export class HlmCommandListComponent {
	/** The user defined class  */
	public readonly userClass = input<string>('', { alias: 'class' });

	/** The styles to apply  */
	protected readonly _computedClass = computed(() =>
		hlm('max-h-[300px] overflow-x-hidden overflow-y-auto', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-command-helm/files/lib/hlm-command-search-input.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { BrnCommandSearchInputDirective } from '@spartan-ng/brain/command';
import { hlm } from '@spartan-ng/brain/core';

@Component({
	standalone: true,
	selector: 'input[hlm-command-search-input]',
	template: '',
	hostDirectives: [{ directive: BrnCommandSearchInputDirective, inputs: ['value'] }],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCommandSearchInputComponent {
	/*** The user defined class  */
	public readonly userClass = input<string>('', { alias: 'class' });

	/*** The styles to apply  */
	protected readonly _computedClass = computed(() =>
		hlm(
			'bg-transparent disabled:cursor-not-allowed disabled:opacity-50 h-11 outline-none placeholder:text-muted-foreground py-3 text-sm w-full',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-command-helm/files/lib/hlm-command-search.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { provideHlmIconConfig } from '@spartan-ng/ui-icon-helm';

@Component({
	standalone: true,
	selector: 'hlm-command-search',
	template: `
		<ng-content />
	`,
	host: {
		'[class]': '_computedClass()',
	},
	providers: [provideHlmIconConfig({ size: 'sm' })],
})
export class HlmCommandSearchComponent {
	/*** The user defined class  */
	public readonly userClass = input<string>('', { alias: 'class' });

	/*** The styles to apply  */
	protected readonly _computedClass = computed(() =>
		hlm('relative [&_ng-icon]:flex-none border-b border-border flex items-center px-3 space-x-2', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-command-helm/files/lib/hlm-command-separator.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';

@Component({
	standalone: true,
	selector: 'hlm-command-separator',
	template: '',
	host: {
		role: 'separator',
		'[class]': '_computedClass()',
	},
})
export class HlmCommandSeparatorComponent {
	/*** The user defined class  */
	public readonly userClass = input<string>('', { alias: 'class' });

	/*** The styles to apply  */
	protected readonly _computedClass = computed(() => hlm('h-px block w-full border-b border-border', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-command-helm/files/lib/hlm-command-shortcut.component.ts.template
```
import { Component } from '@angular/core';

@Component({
	standalone: true,
	selector: 'hlm-command-shortcut',
	template: '<ng-content />',
	host: {
		class: 'font-light ml-auto opacity-60 text-xs tracking-widest',
	},
})
export class HlmCommandShortcutComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-command-helm/files/lib/hlm-command.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { BrnCommandDirective } from '@spartan-ng/brain/command';
import { hlm } from '@spartan-ng/brain/core';

@Component({
	standalone: true,
	selector: 'hlm-command',
	template: `
		<ng-content />
	`,
	hostDirectives: [
		{
			directive: BrnCommandDirective,
			inputs: ['id', 'filter'],
			outputs: ['valueChange'],
		},
	],
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCommandComponent {
	/*** The user defined class */
	public readonly userClass = input<string>('', { alias: 'class' });

	/*** The styles to apply  */
	protected readonly _computedClass = computed(() =>
		hlm(
			'w-96 bg-popover border border-border flex flex-col h-full overflow-hidden rounded-md text-popover-foreground',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-slider-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'slider',
		internalName: 'ui-slider-helm',
		publicName: 'ui-slider-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-slider-helm/files/index.ts.template
```
export * from './lib/hlm-slider.component';
import { HlmSliderComponent } from './lib/hlm-slider.component';

export const HlmSliderImports = [HlmSliderComponent] as const;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-slider-helm/files/lib/hlm-slider.component.ts.template
```
import { ChangeDetectionStrategy, Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import {
	BrnSliderDirective,
	BrnSliderRangeDirective,
	BrnSliderThumbDirective,
	BrnSliderTickDirective,
	BrnSliderTrackDirective,
	injectBrnSlider,
} from '@spartan-ng/brain/slider';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-slider, brn-slider [hlm]',
	changeDetection: ChangeDetectionStrategy.OnPush,
	hostDirectives: [
		{
			directive: BrnSliderDirective,
			inputs: ['value', 'disabled', 'min', 'max', 'step', 'showTicks'],
			outputs: ['valueChange'],
		},
	],
	template: `
		<div brnSliderTrack class="bg-secondary relative h-2 w-full grow overflow-hidden rounded-full">
			<div class="bg-primary absolute h-full" brnSliderRange></div>
		</div>

		@if (slider.showTicks()) {
			<div class="pointer-events-none absolute -inset-x-px top-2 h-1 w-full cursor-pointer transition-all">
				<div
					*brnSliderTick="let tick; let position = position"
					class="absolute size-1 rounded-full"
					[class.bg-secondary]="tick"
					[class.bg-primary]="!tick"
					[style.inset-inline-start.%]="position"
				></div>
			</div>
		}

		<span
			class="border-primary bg-background ring-offset-background focus-visible:ring-ring absolute block h-5 w-5 -translate-x-1/2 rounded-full border-2 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50"
			brnSliderThumb
		></span>
	`,
	host: {
		'[class]': '_computedClass()',
	},
	imports: [BrnSliderThumbDirective, BrnSliderTrackDirective, BrnSliderRangeDirective, BrnSliderTickDirective],
})
export class HlmSliderComponent {
	protected readonly slider = injectBrnSlider();
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'w-full h-5 flex relative select-none items-center touch-none',
			this.slider.disabled() ? 'opacity-40' : '',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-date-picker-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'datepicker',
		internalName: 'ui-date-picker-helm',
		publicName: 'ui-datepicker-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-date-picker-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmDatePickerMultiComponent } from './lib/hlm-date-picker-multi.component';
import { HlmDatePickerComponent } from './lib/hlm-date-picker.component';

export * from './lib/hlm-date-picker.token';

export * from './lib/hlm-date-picker-multi.component';
export * from './lib/hlm-date-picker.component';

export const HlmDatePickerImports = [HlmDatePickerComponent, HlmDatePickerMultiComponent] as const;

@NgModule({
	imports: [...HlmDatePickerImports],
	exports: [...HlmDatePickerImports],
})
export class HlmDatePickerModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-date-picker-helm/files/lib/hlm-date-picker-multi.component.ts.template
```
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import {
	booleanAttribute,
	Component,
	computed,
	forwardRef,
	input,
	model,
	numberAttribute,
	output,
	signal,
} from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideCalendar } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { BrnDialogState } from '@spartan-ng/brain/dialog';
import { type ChangeFn, type TouchFn } from '@spartan-ng/brain/forms';
import { BrnPopoverComponent, BrnPopoverContentDirective, BrnPopoverTriggerDirective } from '@spartan-ng/brain/popover';
import { HlmCalendarMultiComponent } from '@spartan-ng/ui-calendar-helm';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import { HlmPopoverContentDirective } from '@spartan-ng/ui-popover-helm';
import type { ClassValue } from 'clsx';
import { injectHlmDatePickerMultiConfig } from './hlm-date-picker-multi.token';

export const HLM_DATE_PICKER_MUTLI_VALUE_ACCESSOR = {
	provide: NG_VALUE_ACCESSOR,
	useExisting: forwardRef(() => HlmDatePickerMultiComponent),
	multi: true,
};

@Component({
	selector: 'hlm-date-picker-multi',
	imports: [
		NgIcon,
		HlmIconDirective,
		BrnPopoverComponent,
		BrnPopoverTriggerDirective,
		BrnPopoverContentDirective,
		HlmPopoverContentDirective,
		HlmCalendarMultiComponent,
	],
	providers: [HLM_DATE_PICKER_MUTLI_VALUE_ACCESSOR, provideIcons({ lucideCalendar })],
	template: `
		<brn-popover sideOffset="5" [state]="popoverState()" (stateChanged)="popoverState.set($event)">
			<button type="button" [class]="_computedClass()" [disabled]="state().disabled()" brnPopoverTrigger>
				<ng-icon hlm size="sm" name="lucideCalendar" />

				<span class="truncate">
					@if (formattedDate(); as formattedDate) {
						{{ formattedDate }}
					} @else {
						<ng-content />
					}
				</span>
			</button>

			<div hlmPopoverContent class="w-auto p-0" *brnPopoverContent="let ctx">
				<hlm-calendar-multi
					calendarClass="border-0 rounded-none"
					[date]="date()"
					[min]="min()"
					[max]="max()"
					[minSelection]="minSelection()"
					[maxSelection]="maxSelection()"
					[disabled]="state().disabled()"
					(dateChange)="_handleChange($event)"
				/>
			</div>
		</brn-popover>
	`,
	host: {
		class: 'block',
	},
})
export class HlmDatePickerMultiComponent<T> {
	private readonly _config = injectHlmDatePickerMultiConfig<T>();

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'inline-flex items-center gap-2 whitespace-nowrap rounded-md text-sm ring-offset-background transition-colors border border-input bg-background hover:bg-accent hover:text-accent-foreground h-10 px-4 py-2 w-[280px] justify-start text-left font-normal',
			'focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2',
			'disabled:pointer-events-none disabled:opacity-50',
			'[&_ng-icon]:pointer-events-none [&_ng-icon]:shrink-0',
			!this.date() ? 'text-muted-foreground' : '',
			this.userClass(),
		),
	);

	/** The minimum date that can be selected.*/
	public readonly min = input<T>();

	/** The maximum date that can be selected. */
	public readonly max = input<T>();

	/** The minimum selectable dates.  */
	public readonly minSelection = input<number, NumberInput>(undefined, {
		transform: numberAttribute,
	});

	/** The maximum selectable dates.  */
	public readonly maxSelection = input<number, NumberInput>(undefined, {
		transform: numberAttribute,
	});

	/** Determine if the date picker is disabled. */
	public readonly disabled = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** The selected value. */
	public readonly date = model<T[]>();

	/** If true, the date picker will close when the max selection of dates is reached.. */
	public readonly autoCloseOnMaxSelection = input<boolean, BooleanInput>(this._config.autoCloseOnMaxSelection, {
		transform: booleanAttribute,
	});

	/** Defines how the date should be displayed in the UI.  */
	public readonly formatDates = input<(date: T[]) => string>(this._config.formatDates);

	/** Defines how the date should be transformed before saving to model/form. */
	public readonly transformDates = input<(date: T[]) => T[]>(this._config.transformDates);

	protected readonly popoverState = signal<BrnDialogState | null>(null);

	protected readonly state = computed(() => ({
		disabled: signal(this.disabled()),
	}));

	protected readonly formattedDate = computed(() => {
		const dates = this.date();
		return dates ? this.formatDates()(dates) : undefined;
	});

	public readonly changed = output<T[]>();

	protected _onChange?: ChangeFn<T[]>;
	protected _onTouched?: TouchFn;

	protected _handleChange(value: T[] | undefined) {
		if (value === undefined) return;

		if (this.state().disabled()) return;
		const transformedDate = this.transformDates()(value);

		this.date.set(transformedDate);
		this._onChange?.(transformedDate);
		this.changed.emit(transformedDate);

		if (this.autoCloseOnMaxSelection() && this.date()?.length === this.maxSelection()) {
			this.popoverState.set('closed');
		}
	}

	/** CONROL VALUE ACCESSOR */
	writeValue(value: T[] | null): void {
		// optional FormControl is initialized with null value
		if (value === null) return;

		this.date.set(this.transformDates()(value));
	}

	registerOnChange(fn: ChangeFn<T[]>): void {
		this._onChange = fn;
	}

	registerOnTouched(fn: TouchFn): void {
		this._onTouched = fn;
	}

	setDisabledState(isDisabled: boolean): void {
		this.state().disabled.set(isDisabled);
	}

	open() {
		this.popoverState.set('open');
	}

	close() {
		this.popoverState.set('closed');
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-date-picker-helm/files/lib/hlm-date-picker-multi.token.ts.template
```
import { inject, InjectionToken, ValueProvider } from '@angular/core';

export interface HlmDatePickerMultiConfig<T> {
	/**
	 * If true, the date picker will close when the max selection of dates is reached.
	 */
	autoCloseOnMaxSelection: boolean;

	/**
	 * Defines how the date should be displayed in the UI.
	 *
	 * @param dates
	 * @returns formatted date
	 */
	formatDates: (dates: T[]) => string;

	/**
	 * Defines how the date should be transformed before saving to model/form.
	 *
	 * @param dates
	 * @returns transformed date
	 */
	transformDates: (dates: T[]) => T[];
}

function getDefaultConfig<T>(): HlmDatePickerMultiConfig<T> {
	return {
		formatDates: (dates) => dates.map((date) => (date instanceof Date ? date.toDateString() : `${date}`)).join(', '),
		transformDates: (dates) => dates,
		autoCloseOnMaxSelection: false,
	};
}

const HlmDatePickerMultiConfigToken = new InjectionToken<HlmDatePickerMultiConfig<unknown>>('HlmDatePickerMultiConfig');

export function provideHlmDatePickerConfig<T>(config: Partial<HlmDatePickerMultiConfig<T>>): ValueProvider {
	return { provide: HlmDatePickerMultiConfigToken, useValue: { ...getDefaultConfig(), ...config } };
}

export function injectHlmDatePickerMultiConfig<T>(): HlmDatePickerMultiConfig<T> {
	const injectedConfig = inject(HlmDatePickerMultiConfigToken, { optional: true });
	return injectedConfig ? (injectedConfig as HlmDatePickerMultiConfig<T>) : getDefaultConfig();
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-date-picker-helm/files/lib/hlm-date-picker.component.ts.template
```
import { BooleanInput } from '@angular/cdk/coercion';
import { booleanAttribute, Component, computed, forwardRef, input, model, output, signal } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideCalendar } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { BrnDialogState } from '@spartan-ng/brain/dialog';
import { type ChangeFn, type TouchFn } from '@spartan-ng/brain/forms';
import { BrnPopoverComponent, BrnPopoverContentDirective, BrnPopoverTriggerDirective } from '@spartan-ng/brain/popover';
import { HlmCalendarComponent } from '@spartan-ng/ui-calendar-helm';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import { HlmPopoverContentDirective } from '@spartan-ng/ui-popover-helm';
import type { ClassValue } from 'clsx';
import { injectHlmDatePickerConfig } from './hlm-date-picker.token';

export const HLM_DATE_PICKER_VALUE_ACCESSOR = {
	provide: NG_VALUE_ACCESSOR,
	useExisting: forwardRef(() => HlmDatePickerComponent),
	multi: true,
};

@Component({
	selector: 'hlm-date-picker',
	imports: [
		NgIcon,
		HlmIconDirective,
		BrnPopoverComponent,
		BrnPopoverTriggerDirective,
		BrnPopoverContentDirective,
		HlmPopoverContentDirective,
		HlmCalendarComponent,
	],
	providers: [HLM_DATE_PICKER_VALUE_ACCESSOR, provideIcons({ lucideCalendar })],
	template: `
		<brn-popover sideOffset="5" [state]="popoverState()" (stateChanged)="popoverState.set($event)">
			<button type="button" [class]="_computedClass()" [disabled]="state().disabled()" brnPopoverTrigger>
				<ng-icon hlm size="sm" name="lucideCalendar" />

				<span class="truncate">
					@if (formattedDate(); as formattedDate) {
						{{ formattedDate }}
					} @else {
						<ng-content />
					}
				</span>
			</button>

			<div hlmPopoverContent class="w-auto p-0" *brnPopoverContent="let ctx">
				<hlm-calendar
					calendarClass="border-0 rounded-none"
					[date]="date()"
					[min]="min()"
					[max]="max()"
					[disabled]="state().disabled()"
					(dateChange)="_handleChange($event)"
				/>
			</div>
		</brn-popover>
	`,
	host: {
		class: 'block',
	},
})
export class HlmDatePickerComponent<T> {
	private readonly _config = injectHlmDatePickerConfig<T>();

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'inline-flex items-center gap-2 whitespace-nowrap rounded-md text-sm ring-offset-background transition-colors border border-input bg-background hover:bg-accent hover:text-accent-foreground h-10 px-4 py-2 w-[280px] justify-start text-left font-normal',
			'focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2',
			'disabled:pointer-events-none disabled:opacity-50',
			'[&_ng-icon]:pointer-events-none [&_ng-icon]:shrink-0',
			!this.date() ? 'text-muted-foreground' : '',
			this.userClass(),
		),
	);

	/** The minimum date that can be selected.*/
	public readonly min = input<T>();

	/** The maximum date that can be selected. */
	public readonly max = input<T>();

	/** Determine if the date picker is disabled. */
	public readonly disabled = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** The selected value. */
	public readonly date = model<T>();

	/** If true, the date picker will close when a date is selected. */
	public readonly autoCloseOnSelect = input<boolean, BooleanInput>(this._config.autoCloseOnSelect, {
		transform: booleanAttribute,
	});

	/** Defines how the date should be displayed in the UI.  */
	public readonly formatDate = input<(date: T) => string>(this._config.formatDate);

	/** Defines how the date should be transformed before saving to model/form. */
	public readonly transformDate = input<(date: T) => T>(this._config.transformDate);

	protected readonly popoverState = signal<BrnDialogState | null>(null);

	protected readonly state = computed(() => ({
		disabled: signal(this.disabled()),
	}));

	protected readonly formattedDate = computed(() => {
		const date = this.date();
		return date ? this.formatDate()(date) : undefined;
	});

	public readonly changed = output<T>();

	protected _onChange?: ChangeFn<T>;
	protected _onTouched?: TouchFn;

	protected _handleChange(value: T) {
		if (this.state().disabled()) return;
		const transformedDate = this.transformDate()(value);

		this.date.set(transformedDate);
		this._onChange?.(transformedDate);
		this.changed.emit(transformedDate);

		if (this.autoCloseOnSelect()) {
			this.popoverState.set('closed');
		}
	}

	/** CONROL VALUE ACCESSOR */
	writeValue(value: T | null): void {
		// optional FormControl is initialized with null value
		if (value === null) return;

		this.date.set(this.transformDate()(value));
	}

	registerOnChange(fn: ChangeFn<T>): void {
		this._onChange = fn;
	}

	registerOnTouched(fn: TouchFn): void {
		this._onTouched = fn;
	}

	setDisabledState(isDisabled: boolean): void {
		this.state().disabled.set(isDisabled);
	}

	open() {
		this.popoverState.set('open');
	}

	close() {
		this.popoverState.set('closed');
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-date-picker-helm/files/lib/hlm-date-picker.token.ts.template
```
import { inject, InjectionToken, ValueProvider } from '@angular/core';

export interface HlmDatePickerConfig<T> {
	/**
	 * If true, the date picker will close when a date is selected.
	 */
	autoCloseOnSelect: boolean;

	/**
	 * Defines how the date should be displayed in the UI.
	 *
	 * @param date
	 * @returns formatted date
	 */
	formatDate: (date: T) => string;

	/**
	 * Defines how the date should be transformed before saving to model/form.
	 *
	 * @param date
	 * @returns transformed date
	 */
	transformDate: (date: T) => T;
}

function getDefaultConfig<T>(): HlmDatePickerConfig<T> {
	return {
		formatDate: (date) => (date instanceof Date ? date.toDateString() : `${date}`),
		transformDate: (date) => date,
		autoCloseOnSelect: false,
	};
}

const HlmDatePickerConfigToken = new InjectionToken<HlmDatePickerConfig<unknown>>('HlmDatePickerConfig');

export function provideHlmDatePickerConfig<T>(config: Partial<HlmDatePickerConfig<T>>): ValueProvider {
	return { provide: HlmDatePickerConfigToken, useValue: { ...getDefaultConfig(), ...config } };
}

export function injectHlmDatePickerConfig<T>(): HlmDatePickerConfig<T> {
	const injectedConfig = inject(HlmDatePickerConfigToken, { optional: true });
	return injectedConfig ? (injectedConfig as HlmDatePickerConfig<T>) : getDefaultConfig();
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-radio-group-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'radiogroup',
		internalName: 'ui-radio-group-helm',
		publicName: 'ui-radiogroup-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-radio-group-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';

import { HlmRadioGroupComponent } from './lib/hlm-radio-group.component';
import { HlmRadioIndicatorComponent } from './lib/hlm-radio-indicator.component';
import { HlmRadioComponent } from './lib/hlm-radio.component';

export * from './lib/hlm-radio-group.component';
export * from './lib/hlm-radio-indicator.component';
export * from './lib/hlm-radio.component';

export const HlmRadioGroupImports = [HlmRadioGroupComponent, HlmRadioComponent, HlmRadioIndicatorComponent];

@NgModule({
	imports: [...HlmRadioGroupImports],
	exports: [...HlmRadioGroupImports],
})
export class HlmRadioGroupModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-radio-group-helm/files/lib/hlm-radio-group.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnRadioGroupDirective } from '@spartan-ng/brain/radio-group';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-radio-group',
	standalone: true,
	hostDirectives: [
		{
			directive: BrnRadioGroupDirective,
			inputs: ['name', 'value', 'disabled', 'required', 'direction'],
		},
	],
	host: {
		'[class]': '_computedClass()',
	},
	template: '<ng-content />',
})
export class HlmRadioGroupComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('grid gap-2', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-radio-group-helm/files/lib/hlm-radio-indicator.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

const btnLike =
	'aspect-square rounded-full ring-offset-background group-[.cdk-keyboard-focused]:ring-2 group-[.cdk-keyboard-focused]:ring-ring group-[.cdk-keyboard-focused]:ring-offset-2 group-[.brn-radio-disabled]:cursor-not-allowed group-[.brn-radio-disabled]:opacity-50';

@Component({
	selector: 'hlm-radio-indicator',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	template: `
		<div
			class="bg-foreground absolute inset-0 hidden scale-[55%] rounded-full group-[.brn-radio-checked]:inline-block"
		></div>
		<div class="border-primary ${btnLike} rounded-full border"></div>
	`,
})
export class HlmRadioIndicatorComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('relative inline-flex h-4 w-4', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-radio-group-helm/files/lib/hlm-radio.component.ts.template
```
import { booleanAttribute, Component, computed, input, output } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnRadioChange, BrnRadioComponent } from '@spartan-ng/brain/radio-group';
import { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-radio',
	imports: [BrnRadioComponent],
	template: `
		<brn-radio
			[id]="id()"
			[class]="_computedClass()"
			[value]="value()"
			[required]="required()"
			[disabled]="disabled()"
			[aria-label]="ariaLabel()"
			[aria-labelledby]="ariaLabelledby()"
			[aria-describedby]="ariaDescribedby()"
			(change)="change.emit($event)"
		>
			<ng-content select="[target],[indicator]" indicator />
			<ng-content />
		</brn-radio>
	`,
})
export class HlmRadioComponent<T = unknown> {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'group [&.brn-radio-disabled]:text-muted-foreground flex items-center space-x-2 rtl:space-x-reverse',
			this.userClass(),
		),
	);

	/** Used to set the id on the underlying brn element. */
	public readonly id = input<string | undefined>(undefined);

	/** Used to set the aria-label attribute on the underlying brn element. */
	public readonly ariaLabel = input<string | undefined>(undefined, { alias: 'aria-label' });

	/** Used to set the aria-labelledby attribute on the underlying brn element. */
	public readonly ariaLabelledby = input<string | undefined>(undefined, { alias: 'aria-labelledby' });

	/** Used to set the aria-describedby attribute on the underlying brn element. */
	public readonly ariaDescribedby = input<string | undefined>(undefined, { alias: 'aria-describedby' });

	/**
	 * The value this radio button represents.
	 */
	public readonly value = input.required<T>();

	/** Whether the checkbox is required. */
	public readonly required = input(false, { transform: booleanAttribute });

	/** Whether the checkbox is disabled. */
	public readonly disabled = input(false, { transform: booleanAttribute });

	/**
	 * Event emitted when the checked state of this radio button changes.
	 */
	public readonly change = output<BrnRadioChange<T>>();
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-calendar-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'calendar',
		internalName: 'ui-calendar-helm',
		publicName: 'ui-calendar-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-calendar-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmCalendarMultiComponent } from './lib/hlm-calendar-multi.component';
import { HlmCalendarComponent } from './lib/hlm-calendar.component';

export * from './lib/hlm-calendar-multi.component';
export * from './lib/hlm-calendar.component';

export const HlmCalendarImports = [HlmCalendarComponent, HlmCalendarMultiComponent] as const;

@NgModule({
	imports: [...HlmCalendarImports],
	exports: [...HlmCalendarImports],
})
export class HlmCalendarModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-calendar-helm/files/lib/hlm-calendar-multi.component.ts.template
```
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import { Component, booleanAttribute, computed, input, model, numberAttribute, viewChild } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronLeft, lucideChevronRight } from '@ng-icons/lucide';
import {
	BrnCalendarCellButtonDirective,
	BrnCalendarCellDirective,
	BrnCalendarGridDirective,
	BrnCalendarHeaderDirective,
	BrnCalendarMultiDirective,
	BrnCalendarNextButtonDirective,
	BrnCalendarPreviousButtonDirective,
	BrnCalendarWeekDirective,
	BrnCalendarWeekdayDirective,
	Weekday,
	injectBrnCalendarI18n,
} from '@spartan-ng/brain/calendar';
import { hlm } from '@spartan-ng/brain/core';
import { injectDateAdapter } from '@spartan-ng/brain/date-time';
import { buttonVariants } from '@spartan-ng/ui-button-helm';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-calendar-multi',
	imports: [
		BrnCalendarMultiDirective,
		BrnCalendarHeaderDirective,
		BrnCalendarNextButtonDirective,
		BrnCalendarPreviousButtonDirective,
		BrnCalendarWeekdayDirective,
		BrnCalendarWeekDirective,
		BrnCalendarCellButtonDirective,
		BrnCalendarCellDirective,
		BrnCalendarGridDirective,
		NgIcon,
		HlmIconDirective,
	],
	viewProviders: [provideIcons({ lucideChevronLeft, lucideChevronRight })],
	template: `
		<div
			brnCalendarMulti
			[min]="min()"
			[max]="max()"
			[minSelection]="minSelection()"
			[maxSelection]="maxSelection()"
			[disabled]="disabled()"
			[(date)]="date"
			[dateDisabled]="dateDisabled()"
			[weekStartsOn]="weekStartsOn()"
			[defaultFocusedDate]="defaultFocusedDate()"
			[class]="_computedCalenderClass()"
		>
			<div class="inline-flex flex-col space-y-4">
				<!-- Header -->
				<div class="space-y-4">
					<div class="relative flex items-center justify-center pt-1">
						<div brnCalendarHeader class="text-sm font-medium">
							{{ heading() }}
						</div>

						<div class="flex items-center space-x-1">
							<button
								brnCalendarPreviousButton
								class="ring-offset-background focus-visible:ring-ring border-input hover:bg-accent hover:text-accent-foreground absolute left-1 inline-flex h-7 w-7 items-center justify-center whitespace-nowrap rounded-md border bg-transparent p-0 text-sm font-medium opacity-50 transition-colors hover:opacity-100 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50"
							>
								<ng-icon hlm name="lucideChevronLeft" size="sm" />
							</button>

							<button
								brnCalendarNextButton
								class="ring-offset-background focus-visible:ring-ring border-input hover:bg-accent hover:text-accent-foreground absolute right-1 inline-flex h-7 w-7 items-center justify-center whitespace-nowrap rounded-md border bg-transparent p-0 text-sm font-medium opacity-50 transition-colors hover:opacity-100 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50"
							>
								<ng-icon hlm name="lucideChevronRight" size="sm" />
							</button>
						</div>
					</div>
				</div>

				<table class="w-full border-collapse space-y-1" brnCalendarGrid>
					<thead>
						<tr class="flex">
							<th
								*brnCalendarWeekday="let weekday"
								scope="col"
								class="text-muted-foreground w-9 rounded-md text-[0.8rem] font-normal"
								[attr.aria-label]="i18n.labelWeekday(weekday)"
							>
								{{ i18n.formatWeekdayName(weekday) }}
							</th>
						</tr>
					</thead>

					<tbody role="rowgroup">
						<tr *brnCalendarWeek="let week" class="mt-2 flex w-full">
							@for (date of week; track dateAdapter.getTime(date)) {
								<td
									brnCalendarCell
									class="data-[selected]:data-[outside]:bg-accent/50 data-[selected]:bg-accent relative h-9 w-9 p-0 text-center text-sm focus-within:relative focus-within:z-20 first:data-[selected]:rounded-l-md last:data-[selected]:rounded-r-md [&:has([aria-selected].day-range-end)]:rounded-r-md"
								>
									<button brnCalendarCellButton [date]="date" [class]="btnClass">
										{{ dateAdapter.getDate(date) }}
									</button>
								</td>
							}
						</tr>
					</tbody>
				</table>
			</div>
		</div>
	`,
})
export class HlmCalendarMultiComponent<T> {
	public readonly calendarClass = input<ClassValue>('');

	protected readonly _computedCalenderClass = computed(() => hlm('rounded-md border p-3', this.calendarClass()));

	/** Access the calendar i18n */
	protected readonly i18n = injectBrnCalendarI18n();

	/** Access the date time adapter */
	protected readonly dateAdapter = injectDateAdapter<T>();

	/** The minimum date that can be selected.*/
	public readonly min = input<T>();

	/** The maximum date that can be selected. */
	public readonly max = input<T>();

	/** The minimum selectable dates.  */
	public readonly minSelection = input<number, NumberInput>(undefined, {
		transform: numberAttribute,
	});

	/** The maximum selectable dates.  */
	public readonly maxSelection = input<number, NumberInput>(undefined, {
		transform: numberAttribute,
	});

	/** Determine if the date picker is disabled. */
	public readonly disabled = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** The selected value. */
	public readonly date = model<T[]>();

	/** Whether a specific date is disabled. */
	public readonly dateDisabled = input<(date: T) => boolean>(() => false);

	/** The day the week starts on */
	public readonly weekStartsOn = input<Weekday, NumberInput>(0, {
		transform: (v: unknown) => numberAttribute(v) as Weekday,
	});

	/** The default focused date. */
	public readonly defaultFocusedDate = input<T>();

	/** Access the calendar directive */
	private readonly _calendar = viewChild.required(BrnCalendarMultiDirective);

	/** Get the heading for the current month and year */
	protected heading = computed(() =>
		this.i18n.formatHeader(
			this.dateAdapter.getMonth(this._calendar().focusedDate()),
			this.dateAdapter.getYear(this._calendar().focusedDate()),
		),
	);

	protected readonly btnClass = hlm(
		buttonVariants({ variant: 'ghost' }),
		'h-9 w-9 p-0 font-normal aria-selected:opacity-100',
		'data-[outside]:text-muted-foreground data-[outside]:opacity-50 data-[outside]:aria-selected:bg-accent/50 data-[outside]:aria-selected:text-muted-foreground data-[outside]:aria-selected:opacity-30',
		'data-[today]:bg-accent data-[today]:text-accent-foreground',
		'data-[selected]:bg-primary data-[selected]:text-primary-foreground data-[selected]:hover:bg-primary data-[selected]:hover:text-primary-foreground data-[selected]:focus:bg-primary data-[selected]:focus:text-primary-foreground',
		'data-[disabled]:text-muted-foreground data-[disabled]:opacity-50',
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-calendar-helm/files/lib/hlm-calendar.component.ts.template
```
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import { Component, booleanAttribute, computed, input, model, numberAttribute, viewChild } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideChevronLeft, lucideChevronRight } from '@ng-icons/lucide';
import {
	BrnCalendarCellButtonDirective,
	BrnCalendarCellDirective,
	BrnCalendarDirective,
	BrnCalendarGridDirective,
	BrnCalendarHeaderDirective,
	BrnCalendarNextButtonDirective,
	BrnCalendarPreviousButtonDirective,
	BrnCalendarWeekDirective,
	BrnCalendarWeekdayDirective,
	Weekday,
	injectBrnCalendarI18n,
} from '@spartan-ng/brain/calendar';
import { hlm } from '@spartan-ng/brain/core';
import { injectDateAdapter } from '@spartan-ng/brain/date-time';
import { buttonVariants } from '@spartan-ng/ui-button-helm';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-calendar',
	imports: [
		BrnCalendarDirective,
		BrnCalendarHeaderDirective,
		BrnCalendarNextButtonDirective,
		BrnCalendarPreviousButtonDirective,
		BrnCalendarWeekdayDirective,
		BrnCalendarWeekDirective,
		BrnCalendarCellButtonDirective,
		BrnCalendarCellDirective,
		BrnCalendarGridDirective,
		NgIcon,
		HlmIconDirective,
	],
	viewProviders: [provideIcons({ lucideChevronLeft, lucideChevronRight })],
	template: `
		<div
			brnCalendar
			[min]="min()"
			[max]="max()"
			[disabled]="disabled()"
			[(date)]="date"
			[dateDisabled]="dateDisabled()"
			[weekStartsOn]="weekStartsOn()"
			[defaultFocusedDate]="defaultFocusedDate()"
			[class]="_computedCalenderClass()"
		>
			<div class="inline-flex flex-col space-y-4">
				<!-- Header -->
				<div class="space-y-4">
					<div class="relative flex items-center justify-center pt-1">
						<div brnCalendarHeader class="text-sm font-medium">
							{{ heading() }}
						</div>

						<div class="flex items-center space-x-1">
							<button
								brnCalendarPreviousButton
								class="ring-offset-background focus-visible:ring-ring border-input hover:bg-accent hover:text-accent-foreground absolute left-1 inline-flex h-7 w-7 items-center justify-center whitespace-nowrap rounded-md border bg-transparent p-0 text-sm font-medium opacity-50 transition-colors hover:opacity-100 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50"
							>
								<ng-icon hlm name="lucideChevronLeft" size="sm" />
							</button>

							<button
								brnCalendarNextButton
								class="ring-offset-background focus-visible:ring-ring border-input hover:bg-accent hover:text-accent-foreground absolute right-1 inline-flex h-7 w-7 items-center justify-center whitespace-nowrap rounded-md border bg-transparent p-0 text-sm font-medium opacity-50 transition-colors hover:opacity-100 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50"
							>
								<ng-icon hlm name="lucideChevronRight" size="sm" />
							</button>
						</div>
					</div>
				</div>

				<table class="w-full border-collapse space-y-1" brnCalendarGrid>
					<thead>
						<tr class="flex">
							<th
								*brnCalendarWeekday="let weekday"
								scope="col"
								class="text-muted-foreground w-9 rounded-md text-[0.8rem] font-normal"
								[attr.aria-label]="i18n.labelWeekday(weekday)"
							>
								{{ i18n.formatWeekdayName(weekday) }}
							</th>
						</tr>
					</thead>

					<tbody role="rowgroup">
						<tr *brnCalendarWeek="let week" class="mt-2 flex w-full">
							@for (date of week; track dateAdapter.getTime(date)) {
								<td
									brnCalendarCell
									class="data-[selected]:data-[outside]:bg-accent/50 data-[selected]:bg-accent relative h-9 w-9 p-0 text-center text-sm focus-within:relative focus-within:z-20 first:data-[selected]:rounded-l-md last:data-[selected]:rounded-r-md [&:has([aria-selected].day-range-end)]:rounded-r-md"
								>
									<button brnCalendarCellButton [date]="date" [class]="btnClass">
										{{ dateAdapter.getDate(date) }}
									</button>
								</td>
							}
						</tr>
					</tbody>
				</table>
			</div>
		</div>
	`,
})
export class HlmCalendarComponent<T> {
	public readonly calendarClass = input<ClassValue>('');

	protected readonly _computedCalenderClass = computed(() => hlm('rounded-md border p-3', this.calendarClass()));

	/** Access the calendar i18n */
	protected readonly i18n = injectBrnCalendarI18n();

	/** Access the date time adapter */
	protected readonly dateAdapter = injectDateAdapter<T>();

	/** The minimum date that can be selected.*/
	public readonly min = input<T>();

	/** The maximum date that can be selected. */
	public readonly max = input<T>();

	/** Determine if the date picker is disabled. */
	public readonly disabled = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** The selected value. */
	public readonly date = model<T>();

	/** Whether a specific date is disabled. */
	public readonly dateDisabled = input<(date: T) => boolean>(() => false);

	/** The day the week starts on */
	public readonly weekStartsOn = input<Weekday, NumberInput>(0, {
		transform: (v: unknown) => numberAttribute(v) as Weekday,
	});

	/** The default focused date. */
	public readonly defaultFocusedDate = input<T>();

	/** Access the calendar directive */
	private readonly _calendar = viewChild.required(BrnCalendarDirective);

	/** Get the heading for the current month and year */
	protected heading = computed(() =>
		this.i18n.formatHeader(
			this.dateAdapter.getMonth(this._calendar().focusedDate()),
			this.dateAdapter.getYear(this._calendar().focusedDate()),
		),
	);

	protected readonly btnClass = hlm(
		buttonVariants({ variant: 'ghost' }),
		'h-9 w-9 p-0 font-normal aria-selected:opacity-100',
		'data-[outside]:text-muted-foreground data-[outside]:opacity-50 data-[outside]:aria-selected:bg-accent/50 data-[outside]:aria-selected:text-muted-foreground data-[outside]:aria-selected:opacity-30',
		'data-[today]:bg-accent data-[today]:text-accent-foreground',
		'data-[selected]:bg-primary data-[selected]:text-primary-foreground data-[selected]:hover:bg-primary data-[selected]:hover:text-primary-foreground data-[selected]:focus:bg-primary data-[selected]:focus:text-primary-foreground',
		'data-[disabled]:text-muted-foreground data-[disabled]:opacity-50',
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-popover-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'popover',
		internalName: 'ui-popover-helm',
		publicName: 'ui-popover-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-popover-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';

import { HlmPopoverCloseDirective } from './lib/hlm-popover-close.directive';
import { HlmPopoverContentDirective } from './lib/hlm-popover-content.directive';

export * from './lib/hlm-popover-close.directive';
export * from './lib/hlm-popover-content.directive';

export const HlmPopoverImports = [HlmPopoverContentDirective, HlmPopoverCloseDirective] as const;

@NgModule({
	imports: [...HlmPopoverImports],
	exports: [...HlmPopoverImports],
})
export class HlmPopoverModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-popover-helm/files/lib/hlm-popover-close.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmPopoverClose],[brnPopoverClose][hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmPopoverCloseDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-popover-helm/files/lib/hlm-popover-content.directive.ts.template
```
import { Directive, ElementRef, Renderer2, computed, effect, inject, input, signal } from '@angular/core';
import { hlm, injectExposesStateProvider } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmPopoverContent],[brnPopoverContent][hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmPopoverContentDirective {
	private readonly _stateProvider = injectExposesStateProvider({ host: true });
	public state = this._stateProvider.state ?? signal('closed');
	private readonly _renderer = inject(Renderer2);
	private readonly _element = inject(ElementRef);

	constructor() {
		effect(() => {
			this._renderer.setAttribute(this._element.nativeElement, 'data-state', this.state());
		});
	}

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'relative border-border w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-sheet-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'sheet',
		internalName: 'ui-sheet-helm',
		publicName: 'ui-sheet-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-sheet-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';

import { HlmSheetCloseDirective } from './lib/hlm-sheet-close.directive';
import { HlmSheetContentComponent } from './lib/hlm-sheet-content.component';
import { HlmSheetDescriptionDirective } from './lib/hlm-sheet-description.directive';
import { HlmSheetFooterComponent } from './lib/hlm-sheet-footer.component';
import { HlmSheetHeaderComponent } from './lib/hlm-sheet-header.component';
import { HlmSheetOverlayDirective } from './lib/hlm-sheet-overlay.directive';
import { HlmSheetTitleDirective } from './lib/hlm-sheet-title.directive';
import { HlmSheetComponent } from './lib/hlm-sheet.component';

export * from './lib/hlm-sheet-close.directive';
export * from './lib/hlm-sheet-content.component';
export * from './lib/hlm-sheet-description.directive';
export * from './lib/hlm-sheet-footer.component';
export * from './lib/hlm-sheet-header.component';
export * from './lib/hlm-sheet-overlay.directive';
export * from './lib/hlm-sheet-title.directive';
export * from './lib/hlm-sheet.component';

export const HlmSheetImports = [
	HlmSheetComponent,
	HlmSheetCloseDirective,
	HlmSheetContentComponent,
	HlmSheetDescriptionDirective,
	HlmSheetFooterComponent,
	HlmSheetHeaderComponent,
	HlmSheetOverlayDirective,
	HlmSheetTitleDirective,
] as const;

@NgModule({
	imports: [...HlmSheetImports],
	exports: [...HlmSheetImports],
})
export class HlmSheetModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-sheet-helm/files/lib/hlm-sheet-close.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmSheetClose],[brnSheetClose][hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSheetCloseDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'absolute flex h-4 w-4 right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-sheet-helm/files/lib/hlm-sheet-content.component.ts.template
```
import { Component, ElementRef, Renderer2, computed, effect, inject, input, signal } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideX } from '@ng-icons/lucide';
import { hlm, injectExposedSideProvider, injectExposesStateProvider } from '@spartan-ng/brain/core';
import { BrnSheetCloseDirective } from '@spartan-ng/brain/sheet';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import { cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';
import { HlmSheetCloseDirective } from './hlm-sheet-close.directive';

export const sheetVariants = cva(
	'fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500',
	{
		variants: {
			side: {
				top: 'border-border inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top',
				bottom:
					'border-border inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom',
				left: 'border-border inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm',
				right:
					'border-border inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm',
			},
		},
		defaultVariants: {
			side: 'right',
		},
	},
);

@Component({
	selector: 'hlm-sheet-content',
	imports: [HlmSheetCloseDirective, BrnSheetCloseDirective, NgIcon, HlmIconDirective],
	providers: [provideIcons({ lucideX })],
	host: {
		'[class]': '_computedClass()',
		'[attr.data-state]': 'state()',
	},
	template: `
		<ng-content />
		<button brnSheetClose hlm>
			<span class="sr-only">Close</span>
			<ng-icon hlm size="sm" name="lucideX" />
		</button>
	`,
})
export class HlmSheetContentComponent {
	private readonly _stateProvider = injectExposesStateProvider({ host: true });
	private readonly _sideProvider = injectExposedSideProvider({ host: true });
	public state = this._stateProvider.state ?? signal('closed');
	private readonly _renderer = inject(Renderer2);
	private readonly _element = inject(ElementRef);

	constructor() {
		effect(() => {
			this._renderer.setAttribute(this._element.nativeElement, 'data-state', this.state());
		});
	}

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(sheetVariants({ side: this._sideProvider.side() }), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-sheet-helm/files/lib/hlm-sheet-description.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnSheetDescriptionDirective } from '@spartan-ng/brain/sheet';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmSheetDescription]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnSheetDescriptionDirective],
})
export class HlmSheetDescriptionDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('text-sm text-muted-foreground', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-sheet-helm/files/lib/hlm-sheet-footer.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-sheet-footer',
	standalone: true,
	template: `
		<ng-content />
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSheetFooterComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm('flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-sheet-helm/files/lib/hlm-sheet-header.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-sheet-header',
	standalone: true,
	template: `
		<ng-content />
	`,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSheetHeaderComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('flex flex-col space-y-2 text-center sm:text-left', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-sheet-helm/files/lib/hlm-sheet-overlay.directive.ts.template
```
import { Directive, computed, effect, input, untracked } from '@angular/core';
import { hlm, injectCustomClassSettable } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmSheetOverlay],brn-sheet-overlay[hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSheetOverlayDirective {
	private readonly _classSettable = injectCustomClassSettable({ optional: true, host: true });
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm(
			'bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
			this.userClass(),
		),
	);

	constructor() {
		effect(() => {
			const classValue = this._computedClass();
			untracked(() => this._classSettable?.setClassToCustomElement(classValue));
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-sheet-helm/files/lib/hlm-sheet-title.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { BrnSheetTitleDirective } from '@spartan-ng/brain/sheet';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmSheetTitle]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	hostDirectives: [BrnSheetTitleDirective],
})
export class HlmSheetTitleDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('text-lg font-semibold', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-sheet-helm/files/lib/hlm-sheet.component.ts.template
```
import { ChangeDetectionStrategy, Component, forwardRef, ViewEncapsulation } from '@angular/core';
import { BrnDialogComponent, provideBrnDialogDefaultOptions } from '@spartan-ng/brain/dialog';
import { BrnSheetComponent, BrnSheetOverlayComponent } from '@spartan-ng/brain/sheet';
import { HlmSheetOverlayDirective } from './hlm-sheet-overlay.directive';

@Component({
	selector: 'hlm-sheet',
	imports: [BrnSheetOverlayComponent, HlmSheetOverlayDirective],
	providers: [
		{
			provide: BrnDialogComponent,
			useExisting: forwardRef(() => BrnSheetComponent),
		},
		{
			provide: BrnSheetComponent,
			useExisting: forwardRef(() => HlmSheetComponent),
		},
		provideBrnDialogDefaultOptions({
			// add custom options here
		}),
	],
	template: `
		<brn-sheet-overlay hlm />
		<ng-content />
	`,
	encapsulation: ViewEncapsulation.None,
	changeDetection: ChangeDetectionStrategy.OnPush,
	exportAs: 'hlmSheet',
})
export class HlmSheetComponent extends BrnSheetComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-typography-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'typography',
		internalName: 'ui-typography-helm',
		publicName: 'ui-typography-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-typography-helm/files/index.ts.template
```
export * from './lib/hlm-blockquote.directive';
export * from './lib/hlm-code.directive';
export * from './lib/hlm-h1.directive';
export * from './lib/hlm-h2.directive';
export * from './lib/hlm-h3.directive';
export * from './lib/hlm-h4.directive';
export * from './lib/hlm-large.directive';
export * from './lib/hlm-lead.directive';
export * from './lib/hlm-muted.directive';
export * from './lib/hlm-p.directive';
export * from './lib/hlm-small.directive';
export * from './lib/hlm-ul.directive';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-typography-helm/files/lib/hlm-blockquote.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmBlockquote = 'mt-6 border-border border-l-2 pl-6 italic';

@Directive({
	selector: '[hlmBlockquote]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmBlockquoteDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmBlockquote, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-typography-helm/files/lib/hlm-code.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmCode = 'relative rounded bg-muted px-[0.3rem] py-[0.2rem] font-mono text-sm font-semibold';

@Directive({
	selector: '[hlmCode]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmCodeDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmCode, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-typography-helm/files/lib/hlm-h1.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmH1 = 'scroll-m-20 text-4xl font-extrabold tracking-tight lg:text-5xl';

@Directive({
	selector: '[hlmH1]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmH1Directive {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmH1, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-typography-helm/files/lib/hlm-h2.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmH2 =
	'scroll-m-20 border-border border-b pb-2 text-3xl font-semibold tracking-tight transition-colors first:mt-0';

@Directive({
	selector: '[hlmH2]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmH2Directive {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmH2, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-typography-helm/files/lib/hlm-h3.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmH3 = 'scroll-m-20 text-2xl font-semibold tracking-tight';

@Directive({
	selector: '[hlmH3]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmH3Directive {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmH3, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-typography-helm/files/lib/hlm-h4.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmH4 = 'scroll-m-20 text-xl font-semibold tracking-tight';

@Directive({
	selector: '[hlmH4]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmH4Directive {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmH4, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-typography-helm/files/lib/hlm-large.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmLarge = 'text-lg font-semibold';

@Directive({
	selector: '[hlmLarge]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmLargeDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmLarge, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-typography-helm/files/lib/hlm-lead.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmLead = 'text-xl text-muted-foreground';

@Directive({
	selector: '[hlmLead]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmLeadDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmLead, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-typography-helm/files/lib/hlm-muted.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmMuted = 'text-sm text-muted-foreground';

@Directive({
	selector: '[hlmMuted]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmMutedDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmMuted, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-typography-helm/files/lib/hlm-p.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmP = 'leading-7 [&:not(:first-child)]:mt-6';

@Directive({
	selector: '[hlmP]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmPDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmP, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-typography-helm/files/lib/hlm-small.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmSmall = 'text-sm font-medium leading-none';

@Directive({
	selector: '[hlmSmall]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSmallDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmSmall, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-typography-helm/files/lib/hlm-ul.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

export const hlmUl = 'my-6 ml-6 list-disc [&>li]:mt-2';

@Directive({
	selector: '[hlmUl]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmUlDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(hlmUl, this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-scroll-area-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'scrollarea',
		internalName: 'ui-scroll-area-helm',
		publicName: 'ui-scrollarea-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-scroll-area-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmScrollAreaDirective } from './lib/hlm-scroll-area.directive';

export * from './lib/hlm-scroll-area.directive';

@NgModule({
	imports: [HlmScrollAreaDirective],
	exports: [HlmScrollAreaDirective],
})
export class HlmScrollAreaModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-scroll-area-helm/files/lib/hlm-scroll-area.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: 'ng-scrollbar[hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		'[style.--scrollbar-border-radius.px]': '100',
		'[style.--scrollbar-offset]': '3',
		'[style.--scrollbar-thumb-color]': '"hsl(var(--border))"',
		'[style.--scrollbar-thumb-hover-color]': '"hsl(var(--border))"',
		'[style.--scrollbar-thickness]': '7',
	},
})
export class HlmScrollAreaDirective {
	protected readonly _computedClass = computed(() => hlm('block', this.userClass()));
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-alert-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'alert',
		internalName: 'ui-alert-helm',
		publicName: 'ui-alert-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-alert-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';

import { HlmAlertDescriptionDirective } from './lib/hlm-alert-description.directive';
import { HlmAlertIconDirective } from './lib/hlm-alert-icon.directive';
import { HlmAlertTitleDirective } from './lib/hlm-alert-title.directive';
import { HlmAlertDirective } from './lib/hlm-alert.directive';

export * from './lib/hlm-alert-description.directive';
export * from './lib/hlm-alert-icon.directive';
export * from './lib/hlm-alert-title.directive';
export * from './lib/hlm-alert.directive';

export const HlmAlertImports = [
	HlmAlertDirective,
	HlmAlertTitleDirective,
	HlmAlertDescriptionDirective,
	HlmAlertIconDirective,
] as const;

@NgModule({
	imports: [...HlmAlertImports],
	exports: [...HlmAlertImports],
})
export class HlmAlertModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-alert-helm/files/lib/hlm-alert-description.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const alertDescriptionVariants = cva('text-sm [&_p]:leading-relaxed', {
	variants: {},
});
export type AlertDescriptionVariants = VariantProps<typeof alertDescriptionVariants>;

@Directive({
	selector: '[hlmAlertDesc],[hlmAlertDescription]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmAlertDescriptionDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm(alertDescriptionVariants(), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-alert-helm/files/lib/hlm-alert-icon.directive.ts.template
```
import { Directive } from '@angular/core';
import { provideHlmIconConfig } from '@spartan-ng/ui-icon-helm';

@Directive({
	selector: '[hlmAlertIcon]',
	standalone: true,
	providers: [provideHlmIconConfig({ size: 'sm' })],
})
export class HlmAlertIconDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-alert-helm/files/lib/hlm-alert-title.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const alertTitleVariants = cva('mb-1 font-medium leading-none tracking-tight', {
	variants: {},
});
export type AlertTitleVariants = VariantProps<typeof alertTitleVariants>;

@Directive({
	selector: '[hlmAlertTitle]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmAlertTitleDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm(alertTitleVariants(), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-alert-helm/files/lib/hlm-alert.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const alertVariants = cva(
	'relative w-full rounded-lg border border-border p-4 [&>[hlmAlertIcon]]:absolute [&>[hlmAlertIcon]]:text-foreground [&>[hlmAlertIcon]]:left-4 [&>[hlmAlertIcon]]:top-4 [&>[hlmAlertIcon]+div]:translate-y-[-3px] [&>[hlmAlertIcon]~*]:pl-7',
	{
		variants: {
			variant: {
				default: 'bg-background text-foreground',
				destructive:
					'text-destructive border-destructive/50 dark:border-destructive [&>[hlmAlertIcon]]:text-destructive',
			},
		},
		defaultVariants: {
			variant: 'default',
		},
	},
);
export type AlertVariants = VariantProps<typeof alertVariants>;

@Directive({
	selector: '[hlmAlert]',
	standalone: true,
	host: {
		role: 'alert',
		'[class]': '_computedClass()',
	},
})
export class HlmAlertDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm(alertVariants({ variant: this.variant() }), this.userClass()));

	public readonly variant = input<AlertVariants['variant']>('default');
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-skeleton-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'skeleton',
		internalName: 'ui-skeleton-helm',
		publicName: 'ui-skeleton-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-skeleton-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmSkeletonComponent } from './lib/hlm-skeleton.component';

export * from './lib/hlm-skeleton.component';

@NgModule({
	imports: [HlmSkeletonComponent],
	exports: [HlmSkeletonComponent],
})
export class HlmSkeletonModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-skeleton-helm/files/lib/hlm-skeleton.component.ts.template
```
import { Component, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Component({
	selector: 'hlm-skeleton',
	standalone: true,
	template: '',
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSkeletonComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('block animate-pulse rounded-md bg-muted', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-sonner-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'sonner',
		internalName: 'ui-sonner-helm',
		publicName: 'ui-sonner-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-sonner-helm/files/index.ts.template
```
export * from './lib/hlm-toaster.component';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-sonner-helm/files/lib/hlm-toaster.component.ts.template
```
import { ChangeDetectionStrategy, Component, booleanAttribute, computed, input, numberAttribute } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';
import { NgxSonnerToaster, type ToasterProps } from 'ngx-sonner';

@Component({
	selector: 'hlm-toaster',
	imports: [NgxSonnerToaster],
	template: `
		<ngx-sonner-toaster
			[class]="_computedClass()"
			[invert]="invert()"
			[theme]="theme()"
			[position]="position()"
			[hotKey]="hotKey()"
			[richColors]="richColors()"
			[expand]="expand()"
			[duration]="duration()"
			[visibleToasts]="visibleToasts()"
			[closeButton]="closeButton()"
			[toastOptions]="toastOptions()"
			[offset]="offset()"
			[dir]="dir()"
			[style]="userStyle()"
		/>
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
})
export class HlmToasterComponent {
	public readonly invert = input<ToasterProps['invert'], boolean | string>(false, {
		transform: booleanAttribute,
	});
	public readonly theme = input<ToasterProps['theme']>('light');
	public readonly position = input<ToasterProps['position']>('bottom-right');
	public readonly hotKey = input<ToasterProps['hotkey']>(['altKey', 'KeyT']);
	public readonly richColors = input<ToasterProps['richColors'], boolean | string>(false, {
		transform: booleanAttribute,
	});
	public readonly expand = input<ToasterProps['expand'], boolean | string>(false, {
		transform: booleanAttribute,
	});
	public readonly duration = input<ToasterProps['duration'], number | string>(4000, {
		transform: numberAttribute,
	});
	public readonly visibleToasts = input<ToasterProps['visibleToasts'], number | string>(3, {
		transform: numberAttribute,
	});
	public readonly closeButton = input<ToasterProps['closeButton'], boolean | string>(false, {
		transform: booleanAttribute,
	});
	public readonly toastOptions = input<ToasterProps['toastOptions']>({
		classes: {
			toast:
				'group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg',
			description: 'group-[.toast]:text-muted-foreground',
			actionButton: 'group-[.toast]:bg-primary group-[.toast]:text-primary-foreground',
			cancelButton: 'group-[.toast]:bg-muted group-[.toast]:text-muted-foreground',
		},
	});
	public readonly offset = input<ToasterProps['offset']>(null);
	public readonly dir = input<ToasterProps['dir']>('auto');
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly userStyle = input<Record<string, string>>({}, { alias: 'style' });

	protected readonly _computedClass = computed(() => hlm('toaster group', this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-aspect-ratio-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'aspectratio',
		internalName: 'ui-aspect-ratio-helm',
		publicName: 'ui-aspectratio-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-aspect-ratio-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmAspectRatioDirective } from './lib/helm-aspect-ratio.directive';

export * from './lib/helm-aspect-ratio.directive';

@NgModule({
	imports: [HlmAspectRatioDirective],
	exports: [HlmAspectRatioDirective],
})
export class HlmAspectRatioModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-aspect-ratio-helm/files/lib/helm-aspect-ratio.directive.spec.ts.template
```
import { Component } from '@angular/core';
import { type ComponentFixture, TestBed } from '@angular/core/testing';
import { HlmAspectRatioDirective } from './helm-aspect-ratio.directive';

@Component({
	selector: 'hlm-mock',
	standalone: true,
	imports: [HlmAspectRatioDirective],
	template: `
		<div [hlmAspectRatio]="ratio">
			<img
				alt="Sample image"
				src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAANCSURBVEiJtZZPbBtFFMZ/M7ubXdtdb1xSFyeilBapySVU8h8OoFaooFSqiihIVIpQBKci6KEg9Q6H9kovIHoCIVQJJCKE1ENFjnAgcaSGC6rEnxBwA04Tx43t2FnvDAfjkNibxgHxnWb2e/u992bee7tCa00YFsffekFY+nUzFtjW0LrvjRXrCDIAaPLlW0nHL0SsZtVoaF98mLrx3pdhOqLtYPHChahZcYYO7KvPFxvRl5XPp1sN3adWiD1ZAqD6XYK1b/dvE5IWryTt2udLFedwc1+9kLp+vbbpoDh+6TklxBeAi9TL0taeWpdmZzQDry0AcO+jQ12RyohqqoYoo8RDwJrU+qXkjWtfi8Xxt58BdQuwQs9qC/afLwCw8tnQbqYAPsgxE1S6F3EAIXux2oQFKm0ihMsOF71dHYx+f3NND68ghCu1YIoePPQN1pGRABkJ6Bus96CutRZMydTl+TvuiRW1m3n0eDl0vRPcEysqdXn+jsQPsrHMquGeXEaY4Yk4wxWcY5V/9scqOMOVUFthatyTy8QyqwZ+kDURKoMWxNKr2EeqVKcTNOajqKoBgOE28U4tdQl5p5bwCw7BWquaZSzAPlwjlithJtp3pTImSqQRrb2Z8PHGigD4RZuNX6JYj6wj7O4TFLbCO/Mn/m8R+h6rYSUb3ekokRY6f/YukArN979jcW+V/S8g0eT/N3VN3kTqWbQ428m9/8k0P/1aIhF36PccEl6EhOcAUCrXKZXXWS3XKd2vc/TRBG9O5ELC17MmWubD2nKhUKZa26Ba2+D3P+4/MNCFwg59oWVeYhkzgN/JDR8deKBoD7Y+ljEjGZ0sosXVTvbc6RHirr2reNy1OXd6pJsQ+gqjk8VWFYmHrwBzW/n+uMPFiRwHB2I7ih8ciHFxIkd/3Omk5tCDV1t+2nNu5sxxpDFNx+huNhVT3/zMDz8usXC3ddaHBj1GHj/As08fwTS7Kt1HBTmyN29vdwAw+/wbwLVOJ3uAD1wi/dUH7Qei66PfyuRj4Ik9is+hglfbkbfR3cnZm7chlUWLdwmprtCohX4HUtlOcQjLYCu+fzGJH2QRKvP3UNz8bWk1qMxjGTOMThZ3kvgLI5AzFfo379UAAAAASUVORK5CYII="
			/>
		</div>
	`,
})
class MockComponent {
	public ratio: number | undefined = 16 / 9;
}

describe('HelmAspectRatioDirective', () => {
	let component: MockComponent;
	let fixture: ComponentFixture<MockComponent>;

	beforeEach(() => {
		fixture = TestBed.createComponent(MockComponent);
		component = fixture.componentInstance;
	});

	it('should compile', () => {
		expect(component).toBeTruthy();
	});

	it('should show the image', () => {
		fixture.detectChanges();
		const img = fixture.nativeElement.querySelector('img');
		expect(img).toBeTruthy();
	});

	it('should have the correct aspect ratio', () => {
		fixture.detectChanges();
		const div = fixture.nativeElement.querySelector('div');
		expect(div.style.paddingBottom).toEqual(`${100 / (component.ratio || 1)}%`);
	});

	it('should default to an aspect ratio of 1', () => {
		component.ratio = undefined;
		fixture.detectChanges();
		const div = fixture.nativeElement.querySelector('div');
		expect(div.style.paddingBottom).toEqual('100%');
	});

	it('should fallback to an aspect ratio of 1 if the ratio is 0', () => {
		component.ratio = 0;
		fixture.detectChanges();
		const div = fixture.nativeElement.querySelector('div');
		expect(div.style.paddingBottom).toEqual('100%');
	});

	it('should fallback to an aspect ratio of 1 if the ratio is negative', () => {
		component.ratio = -1;
		fixture.detectChanges();
		const div = fixture.nativeElement.querySelector('div');
		expect(div.style.paddingBottom).toEqual('100%');
	});

	it('should add the correct styles to the image', () => {
		fixture.detectChanges();

		const img = fixture.nativeElement.querySelector('img') as HTMLImageElement;
		expect(img.classList.toString()).toBe('absolute w-full h-full object-cover');
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-aspect-ratio-helm/files/lib/helm-aspect-ratio.directive.ts.template
```
import { type NumberInput, coerceNumberProperty } from '@angular/cdk/coercion';
import { type AfterViewInit, Directive, ElementRef, computed, inject, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

const parseDividedString = (value: NumberInput): NumberInput => {
	if (typeof value !== 'string' || !value.includes('/')) return value;
	return value
		.split('/')
		.map((v) => Number.parseInt(v, 10))
		.reduce((a, b) => a / b);
};

@Directive({
	selector: '[hlmAspectRatio]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		'[style.padding-bottom]': '_computedPaddingBottom()',
	},
})
export class HlmAspectRatioDirective implements AfterViewInit {
	private readonly _el = inject<ElementRef<HTMLElement>>(ElementRef).nativeElement;

	public readonly ratio = input(1, {
		alias: 'hlmAspectRatio',
		transform: (value: NumberInput) => {
			const coerced = coerceNumberProperty(parseDividedString(value));
			return coerced <= 0 ? 1 : coerced;
		},
	});
	protected readonly _computedPaddingBottom = computed(() => `${100 / this.ratio()}%`);

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() => hlm('relative w-full', this.userClass()));

	ngAfterViewInit() {
		// support delayed addition of image to dom
		const child = this._el.firstElementChild;
		if (child) {
			child.classList.add('absolute', 'w-full', 'h-full', 'object-cover');
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-progress-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'progress',
		internalName: 'ui-progress-helm',
		publicName: 'ui-progress-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-progress-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';

import { HlmProgressIndicatorDirective } from './lib/hlm-progress-indicator.directive';
import { HlmProgressDirective } from './lib/hlm-progress.directive';

export * from './lib/hlm-progress-indicator.directive';
export * from './lib/hlm-progress.directive';

export const HlmProgressImports = [HlmProgressDirective, HlmProgressIndicatorDirective] as const;

@NgModule({
	imports: [...HlmProgressImports],
	exports: [...HlmProgressImports],
})
export class HlmProgressModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-progress-helm/files/lib/hlm-progress-indicator.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { injectBrnProgress } from '@spartan-ng/brain/progress';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmProgressIndicator],brn-progress-indicator[hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		'[class.animate-indeterminate]': 'indeterminate()',
		'[style.transform]': 'transform()',
	},
})
export class HlmProgressIndicatorDirective {
	private readonly _progress = injectBrnProgress();
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm('inline-flex transform-gpu h-full w-full flex-1 bg-primary transition-all', this.userClass()),
	);

	protected readonly transform = computed(() => `translateX(-${100 - (this._progress.value() ?? 100)}%)`);

	protected readonly indeterminate = computed(
		() => this._progress.value() === null || this._progress.value() === undefined,
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-progress-helm/files/lib/hlm-progress.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[hlmProgress],brn-progress[hlm]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmProgressDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm('inline-flex relative h-4 w-full overflow-hidden rounded-full bg-secondary', this.userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-switch-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'switch',
		internalName: 'ui-switch-helm',
		publicName: 'ui-switch-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-switch-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';

import { HlmSwitchThumbDirective } from './lib/hlm-switch-thumb.directive';
import { HlmSwitchComponent } from './lib/hlm-switch.component';

export * from './lib/hlm-switch-thumb.directive';
export * from './lib/hlm-switch.component';

export const HlmSwitchImports = [HlmSwitchComponent, HlmSwitchThumbDirective] as const;
@NgModule({
	imports: [...HlmSwitchImports],
	exports: [...HlmSwitchImports],
})
export class HlmSwitchModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-switch-helm/files/lib/hlm-switch-ng-model.component.ignore.spec.ts.template
```
import { Component, Input } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { HlmSwitchComponent } from './hlm-switch.component';
@Component({
	selector: 'hlm-switch-ng-model',
	template: `
		<!-- eslint-disable-next-line @angular-eslint/template/label-has-associated-control -->
		<label class="flex items-center" hlmLabel>
			test switch
			<hlm-switch [(ngModel)]="switchValue" id="testSwitchForm" (changed)="handleChange($event)" />
		</label>

		<p data-testid="switchValue">{{ switchValue }}</p>
		<p data-testid="changedValue">{{ changedValueTo }}</p>
	`,
	imports: [HlmSwitchComponent, FormsModule],
})
export class SwitchFormComponent {
	@Input()
	public switchValue = false;

	protected changedValueTo: boolean | undefined;

	handleChange(value: boolean) {
		this.changedValueTo = value;
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-switch-helm/files/lib/hlm-switch-thumb.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: 'brn-switch-thumb[hlm],[hlmSwitchThumb]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmSwitchThumbDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm(
			'block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform group-data-[state=checked]:translate-x-5 group-data-[state=unchecked]:translate-x-0',
			this.userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-switch-helm/files/lib/hlm-switch.component.ts.template
```
import { BooleanInput } from '@angular/cdk/coercion';
import { Component, booleanAttribute, computed, forwardRef, input, model, output, signal } from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';
import { hlm } from '@spartan-ng/brain/core';
import { ChangeFn, TouchFn } from '@spartan-ng/brain/forms';
import { BrnSwitchComponent, BrnSwitchThumbComponent } from '@spartan-ng/brain/switch';
import type { ClassValue } from 'clsx';
import { HlmSwitchThumbDirective } from './hlm-switch-thumb.directive';
export const HLM_SWITCH_VALUE_ACCESSOR = {
	provide: NG_VALUE_ACCESSOR,
	useExisting: forwardRef(() => HlmSwitchComponent),
	multi: true,
};

@Component({
	selector: 'hlm-switch',
	imports: [BrnSwitchThumbComponent, BrnSwitchComponent, HlmSwitchThumbDirective],
	host: {
		class: 'contents',
		'[attr.id]': 'null',
		'[attr.aria-label]': 'null',
		'[attr.aria-labelledby]': 'null',
		'[attr.aria-describedby]': 'null',
	},
	template: `
		<brn-switch
			[class]="_computedClass()"
			[checked]="checked()"
			(changed)="handleChange($event)"
			(touched)="_onTouched?.()"
			[disabled]="disabled()"
			[id]="id()"
			[aria-label]="ariaLabel()"
			[aria-labelledby]="ariaLabelledby()"
			[aria-describedby]="ariaDescribedby()"
		>
			<brn-switch-thumb hlm />
		</brn-switch>
	`,
	providers: [HLM_SWITCH_VALUE_ACCESSOR],
})
export class HlmSwitchComponent implements ControlValueAccessor {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(
			'group inline-flex h-[24px] w-[44px] shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input',
			this.disabled() ? 'cursor-not-allowed opacity-50' : '',
			this.userClass(),
		),
	);

	/** The checked state of the switch. */
	public readonly checked = model<boolean>(false);

	/** The disabled state of the switch. */
	public readonly disabledInput = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
		alias: 'disabled',
	});

	/** Used to set the id on the underlying brn element. */
	public readonly id = input<string | null>(null);

	/** Used to set the aria-label attribute on the underlying brn element. */
	public readonly ariaLabel = input<string | null>(null, { alias: 'aria-label' });

	/** Used to set the aria-labelledby attribute on the underlying brn element. */
	public readonly ariaLabelledby = input<string | null>(null, { alias: 'aria-labelledby' });

	/** Used to set the aria-describedby attribute on the underlying brn element. */
	public readonly ariaDescribedby = input<string | null>(null, { alias: 'aria-describedby' });

	/** Emits when the checked state of the switch changes. */
	public readonly changed = output<boolean>();

	private readonly _writableDisabled = computed(() => signal(this.disabledInput()));

	public readonly disabled = computed(() => this._writableDisabled()());

	protected _onChange?: ChangeFn<boolean>;
	protected _onTouched?: TouchFn;

	protected handleChange(value: boolean): void {
		this.checked.set(value);
		this._onChange?.(value);
		this.changed.emit(value);
	}

	/** CONROL VALUE ACCESSOR */

	writeValue(value: boolean): void {
		this.checked.set(Boolean(value));
	}

	registerOnChange(fn: ChangeFn<boolean>): void {
		this._onChange = fn;
	}

	registerOnTouched(fn: TouchFn): void {
		this._onTouched = fn;
	}

	setDisabledState(isDisabled: boolean): void {
		this._writableDisabled().set(isDisabled);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-checkbox-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'checkbox',
		internalName: 'ui-checkbox-helm',
		publicName: 'ui-checkbox-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-checkbox-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';

import { HlmCheckboxComponent } from './lib/hlm-checkbox.component';

export * from './lib/hlm-checkbox.component';

export const HlmCheckboxImports = [HlmCheckboxComponent] as const;
@NgModule({
	imports: [...HlmCheckboxImports],
	exports: [...HlmCheckboxImports],
})
export class HlmCheckboxModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-checkbox-helm/files/lib/hlm-checkbox.component.ts.template
```
import { Component, booleanAttribute, computed, forwardRef, input, model, output, signal } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideCheck } from '@ng-icons/lucide';
import { BrnCheckboxComponent } from '@spartan-ng/brain/checkbox';
import { hlm } from '@spartan-ng/brain/core';
import type { ChangeFn, TouchFn } from '@spartan-ng/brain/forms';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';

export const HLM_CHECKBOX_VALUE_ACCESSOR = {
	provide: NG_VALUE_ACCESSOR,
	useExisting: forwardRef(() => HlmCheckboxComponent),
	multi: true,
};

@Component({
	selector: 'hlm-checkbox',
	imports: [BrnCheckboxComponent, NgIcon, HlmIconDirective],
	template: `
		<brn-checkbox
			[id]="id()"
			[name]="name()"
			[class]="_computedClass()"
			[checked]="checked()"
			[disabled]="state().disabled()"
			[required]="required()"
			[aria-label]="ariaLabel()"
			[aria-labelledby]="ariaLabelledby()"
			[aria-describedby]="ariaDescribedby()"
			(changed)="_handleChange()"
			(touched)="_onTouched?.()"
		>
			<ng-icon [class]="_computedIconClass()" hlm size="sm" name="lucideCheck" />
		</brn-checkbox>
	`,
	host: {
		class: 'contents',
		'[attr.id]': 'null',
		'[attr.aria-label]': 'null',
		'[attr.aria-labelledby]': 'null',
		'[attr.aria-describedby]': 'null',
	},
	providers: [HLM_CHECKBOX_VALUE_ACCESSOR],
	viewProviders: [provideIcons({ lucideCheck })],
})
export class HlmCheckboxComponent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm(
			'group inline-flex border border-foreground shrink-0 cursor-pointer items-center rounded-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring' +
				' focus-visible:ring-offset-2 focus-visible:ring-offset-background data-[state=checked]:text-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-background',
			this.userClass(),
			this.state().disabled() ? 'cursor-not-allowed opacity-50' : '',
		),
	);

	protected readonly _computedIconClass = computed(() =>
		hlm('leading-none group-data-[state=unchecked]:opacity-0', this.checked() === 'indeterminate' ? 'opacity-50' : ''),
	);

	/** Used to set the id on the underlying brn element. */
	public readonly id = input<string | null>(null);

	/** Used to set the aria-label attribute on the underlying brn element. */
	public readonly ariaLabel = input<string | null>(null, { alias: 'aria-label' });

	/** Used to set the aria-labelledby attribute on the underlying brn element. */
	public readonly ariaLabelledby = input<string | null>(null, { alias: 'aria-labelledby' });

	/** Used to set the aria-describedby attribute on the underlying brn element. */
	public readonly ariaDescribedby = input<string | null>(null, { alias: 'aria-describedby' });

	/** The checked state of the checkbox. */
	public readonly checked = model<CheckboxValue>(false);

	/** The name attribute of the checkbox. */
	public readonly name = input<string | null>(null);

	/** Whether the checkbox is required. */
	public readonly required = input(false, { transform: booleanAttribute });

	/** Whether the checkbox is disabled. */
	public readonly disabled = input(false, { transform: booleanAttribute });

	protected readonly state = computed(() => ({
		disabled: signal(this.disabled()),
	}));

	public readonly changed = output<boolean>();

	protected _onChange?: ChangeFn<CheckboxValue>;
	protected _onTouched?: TouchFn;

	protected _handleChange(): void {
		if (this.state().disabled()) return;

		const previousChecked = this.checked();
		this.checked.set(previousChecked === 'indeterminate' ? true : !previousChecked);
		this._onChange?.(!previousChecked);
		this.changed.emit(!previousChecked);
	}

	/** CONROL VALUE ACCESSOR */
	writeValue(value: CheckboxValue): void {
		this.checked.set(!!value);
	}

	registerOnChange(fn: ChangeFn<CheckboxValue>): void {
		this._onChange = fn;
	}

	registerOnTouched(fn: TouchFn): void {
		this._onTouched = fn;
	}

	setDisabledState(isDisabled: boolean): void {
		this.state().disabled.set(isDisabled);
	}
}

type CheckboxValue = boolean | 'indeterminate';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-input-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'input',
		internalName: 'ui-input-helm',
		publicName: 'ui-input-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-input-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmInputErrorDirective } from './lib/hlm-input-error.directive';
import { HlmInputDirective } from './lib/hlm-input.directive';

export * from './lib/hlm-input-error.directive';
export * from './lib/hlm-input.directive';

@NgModule({
	imports: [HlmInputDirective, HlmInputErrorDirective],
	exports: [HlmInputDirective, HlmInputErrorDirective],
})
export class HlmInputModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-input-helm/files/lib/hlm-input-error.directive.ts.template
```
import { Directive, computed, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const inputErrorVariants = cva('text-destructive text-sm font-medium', {
	variants: {},
	defaultVariants: {},
});
export type InputErrorVariants = VariantProps<typeof inputErrorVariants>;

@Directive({
	selector: '[hlmInputError]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class HlmInputErrorDirective {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm(inputErrorVariants(), this.userClass()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-input-helm/files/lib/hlm-input.directive.ts.template
```
import { Directive, type DoCheck, Injector, computed, effect, inject, input, signal, untracked } from '@angular/core';
import { FormGroupDirective, NgControl, NgForm } from '@angular/forms';
import { hlm } from '@spartan-ng/brain/core';
import { BrnFormFieldControl } from '@spartan-ng/brain/form-field';
import { ErrorStateMatcher, ErrorStateTracker } from '@spartan-ng/brain/forms';

import { type VariantProps, cva } from 'class-variance-authority';
import type { ClassValue } from 'clsx';

export const inputVariants = cva(
	'flex rounded-md border font-normal border-input bg-transparent text-base md:text-sm ring-offset-background file:border-0 file:text-foreground file:bg-transparent file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
	{
		variants: {
			size: {
				default: 'h-10 py-2 px-4 file:max-md:py-0',
				sm: 'h-9 px-3 file:md:py-2 file:max-md:py-1.5',
				lg: 'h-11 px-8 file:md:py-3 file:max-md:py-2.5',
			},
			error: {
				auto: '[&.ng-invalid.ng-touched]:text-destructive [&.ng-invalid.ng-touched]:border-destructive [&.ng-invalid.ng-touched]:focus-visible:ring-destructive',
				true: 'text-destructive border-destructive focus-visible:ring-destructive',
			},
		},
		defaultVariants: {
			size: 'default',
			error: 'auto',
		},
	},
);
type InputVariants = VariantProps<typeof inputVariants>;

@Directive({
	selector: '[hlmInput]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	providers: [
		{
			provide: BrnFormFieldControl,
			useExisting: HlmInputDirective,
		},
	],
})
export class HlmInputDirective implements BrnFormFieldControl, DoCheck {
	public readonly size = input<InputVariants['size']>('default');

	public readonly error = input<InputVariants['error']>('auto');

	protected readonly state = computed(() => ({
		error: signal(this.error()),
	}));

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	protected readonly _computedClass = computed(() =>
		hlm(inputVariants({ size: this.size(), error: this.state().error() }), this.userClass()),
	);

	private readonly _injector = inject(Injector);

	public readonly ngControl: NgControl | null = this._injector.get(NgControl, null);

	private readonly _errorStateTracker: ErrorStateTracker;

	private readonly _defaultErrorStateMatcher = inject(ErrorStateMatcher);
	private readonly _parentForm = inject(NgForm, { optional: true });
	private readonly _parentFormGroup = inject(FormGroupDirective, { optional: true });

	public readonly errorState = computed(() => this._errorStateTracker.errorState());

	constructor() {
		this._errorStateTracker = new ErrorStateTracker(
			this._defaultErrorStateMatcher,
			this.ngControl,
			this._parentFormGroup,
			this._parentForm,
		);

		effect(() => {
			const error = this._errorStateTracker.errorState();
			untracked(() => {
				if (this.ngControl) {
					this.setError(error);
				}
			});
		});
	}

	ngDoCheck() {
		this._errorStateTracker.updateErrorState();
	}

	setError(error: InputVariants['error']) {
		this.state().error.set(error);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-carousel-helm/generator.ts
```typescript
import { Tree } from '@nx/devkit';
import hlmBaseGenerator from '../../../base/generator';
import type { HlmBaseGeneratorSchema } from '../../../base/schema';

export async function generator(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await hlmBaseGenerator(tree, {
		...options,
		primitiveName: 'carousel',
		internalName: 'ui-carousel-helm',
		publicName: 'ui-carousel-helm',
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-carousel-helm/files/index.ts.template
```
import { NgModule } from '@angular/core';
import { HlmCarouselContentComponent } from './lib/hlm-carousel-content.component';
import { HlmCarouselItemComponent } from './lib/hlm-carousel-item.component';
import { HlmCarouselNextComponent } from './lib/hlm-carousel-next.component';
import { HlmCarouselPreviousComponent } from './lib/hlm-carousel-previous.component';
import { HlmCarouselComponent } from './lib/hlm-carousel.component';

export * from './lib/hlm-carousel-content.component';
export * from './lib/hlm-carousel-item.component';
export * from './lib/hlm-carousel-next.component';
export * from './lib/hlm-carousel-previous.component';
export * from './lib/hlm-carousel.component';

export const HlmCarouselImports = [
	HlmCarouselComponent,
	HlmCarouselContentComponent,
	HlmCarouselItemComponent,
	HlmCarouselPreviousComponent,
	HlmCarouselNextComponent,
] as const;

@NgModule({
	imports: [...HlmCarouselImports],
	exports: [...HlmCarouselImports],
})
export class HlmCarouselModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-carousel-helm/files/lib/hlm-carousel-content.component.ts.template
```
import { ChangeDetectionStrategy, Component, ViewEncapsulation, computed, inject, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';
import { HlmCarouselComponent } from './hlm-carousel.component';

@Component({
	selector: 'hlm-carousel-content',
	standalone: true,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	host: {
		'[class]': '_computedClass()',
	},
	template: `
		<ng-content />
	`,
})
export class HlmCarouselContentComponent {
	private readonly _orientation = inject(HlmCarouselComponent).orientation;

	public _userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() =>
		hlm('flex', this._orientation() === 'horizontal' ? '-ml-4' : '-mt-4 flex-col', this._userClass()),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-carousel-helm/files/lib/hlm-carousel-item.component.ts.template
```
import { ChangeDetectionStrategy, Component, ViewEncapsulation, computed, inject, input } from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';
import { HlmCarouselComponent } from './hlm-carousel.component';

@Component({
	selector: 'hlm-carousel-item',
	standalone: true,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	host: {
		'[class]': '_computedClass()',
		role: 'group',
		'aria-roledescription': 'slide',
	},
	template: `
		<ng-content />
	`,
})
export class HlmCarouselItemComponent {
	public _userClass = input<ClassValue>('', { alias: 'class' });
	private readonly _orientation = inject(HlmCarouselComponent).orientation;
	protected _computedClass = computed(() =>
		hlm(
			'min-w-0 shrink-0 grow-0 basis-full',
			this._orientation() === 'horizontal' ? 'pl-4' : 'pt-4',
			this._userClass(),
		),
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-carousel-helm/files/lib/hlm-carousel-next.component.ts.template
```
import {
	ChangeDetectionStrategy,
	Component,
	ViewEncapsulation,
	computed,
	effect,
	inject,
	input,
	untracked,
} from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideArrowRight } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { HlmButtonDirective, provideBrnButtonConfig } from '@spartan-ng/ui-button-helm';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';
import { HlmCarouselComponent } from './hlm-carousel.component';

@Component({
	selector: 'button[hlm-carousel-next], button[hlmCarouselNext]',
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	host: {
		'[disabled]': 'isDisabled()',
		'(click)': '_carousel.scrollNext()',
	},
	hostDirectives: [{ directive: HlmButtonDirective, inputs: ['variant', 'size'] }],
	providers: [provideIcons({ lucideArrowRight }), provideBrnButtonConfig({ variant: 'outline', size: 'icon' })],
	imports: [NgIcon, HlmIconDirective],
	template: `
		<ng-icon hlm size="sm" name="lucideArrowRight" />
		<span class="sr-only">Next slide</span>
	`,
})
export class HlmCarouselNextComponent {
	private readonly _button = inject(HlmButtonDirective);
	private readonly _carousel = inject(HlmCarouselComponent);
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	private readonly _computedClass = computed(() =>
		hlm(
			'absolute h-8 w-8 rounded-full',
			this._carousel.orientation() === 'horizontal'
				? '-right-12 top-1/2 -translate-y-1/2'
				: '-bottom-12 left-1/2 -translate-x-1/2 rotate-90',
			this.userClass(),
		),
	);
	protected readonly isDisabled = () => !this._carousel.canScrollNext();

	constructor() {
		effect(() => {
			const computedClass = this._computedClass();

			untracked(() => this._button.setClass(computedClass));
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-carousel-helm/files/lib/hlm-carousel-previous.component.ts.template
```
import {
	ChangeDetectionStrategy,
	Component,
	ViewEncapsulation,
	computed,
	effect,
	inject,
	input,
	untracked,
} from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideArrowLeft } from '@ng-icons/lucide';
import { hlm } from '@spartan-ng/brain/core';
import { HlmButtonDirective, provideBrnButtonConfig } from '@spartan-ng/ui-button-helm';
import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
import type { ClassValue } from 'clsx';
import { HlmCarouselComponent } from './hlm-carousel.component';

@Component({
	selector: 'button[hlm-carousel-previous], button[hlmCarouselPrevious]',
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	host: {
		'[disabled]': 'isDisabled()',
		'(click)': '_carousel.scrollPrev()',
	},
	hostDirectives: [{ directive: HlmButtonDirective, inputs: ['variant', 'size'] }],
	providers: [provideIcons({ lucideArrowLeft }), provideBrnButtonConfig({ variant: 'outline', size: 'icon' })],
	imports: [NgIcon, HlmIconDirective],
	template: `
		<ng-icon hlm size="sm" name="lucideArrowLeft" />
		<span class="sr-only">Previous slide</span>
	`,
})
export class HlmCarouselPreviousComponent {
	private readonly _button = inject(HlmButtonDirective);

	protected readonly _carousel = inject(HlmCarouselComponent);

	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	private readonly _computedClass = computed(() =>
		hlm(
			'absolute h-8 w-8 rounded-full',
			this._carousel.orientation() === 'horizontal'
				? '-left-12 top-1/2 -translate-y-1/2'
				: '-top-12 left-1/2 -translate-x-1/2 rotate-90',
			this.userClass(),
		),
	);
	protected readonly isDisabled = () => !this._carousel.canScrollPrev();

	constructor() {
		effect(() => {
			const computedClass = this._computedClass();

			untracked(() => this._button.setClass(computedClass));
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/ui/libs/ui-carousel-helm/files/lib/hlm-carousel.component.ts.template
```
import {
	ChangeDetectionStrategy,
	Component,
	HostListener,
	type InputSignal,
	type Signal,
	ViewChild,
	ViewEncapsulation,
	computed,
	input,
	signal,
} from '@angular/core';
import { hlm } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';
import {
	EmblaCarouselDirective,
	type EmblaEventType,
	type EmblaOptionsType,
	type EmblaPluginType,
} from 'embla-carousel-angular';

@Component({
	selector: 'hlm-carousel',
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	host: {
		'[class]': '_computedClass()',
		role: 'region',
		'aria-roledescription': 'carousel',
	},
	imports: [EmblaCarouselDirective],
	template: `
		<div
			emblaCarousel
			class="overflow-hidden"
			[plugins]="plugins()"
			[options]="emblaOptions()"
			[subscribeToEvents]="['init', 'select', 'reInit']"
			(emblaChange)="onEmblaEvent($event)"
		>
			<ng-content select="hlm-carousel-content" />
		</div>
		<ng-content />
	`,
})
export class HlmCarouselComponent {
	@ViewChild(EmblaCarouselDirective) protected emblaCarousel?: EmblaCarouselDirective;

	public _userClass = input<ClassValue>('', { alias: 'class' });
	protected _computedClass = computed(() => hlm('relative', this._userClass()));

	public orientation = input<'horizontal' | 'vertical'>('horizontal');
	public options: InputSignal<Omit<EmblaOptionsType, 'axis'> | undefined> = input();
	public plugins: InputSignal<EmblaPluginType[]> = input([] as EmblaPluginType[]);

	protected emblaOptions: Signal<EmblaOptionsType> = computed(() => ({
		...this.options(),
		axis: this.orientation() === 'horizontal' ? 'x' : 'y',
	}));

	private readonly _canScrollPrev = signal(false);
	public canScrollPrev = this._canScrollPrev.asReadonly();
	private readonly _canScrollNext = signal(false);
	public canScrollNext = this._canScrollNext.asReadonly();

	protected onEmblaEvent(event: EmblaEventType) {
		const emblaApi = this.emblaCarousel?.emblaApi;

		if (!emblaApi) {
			return;
		}

		if (event === 'select' || event === 'init' || event === 'reInit') {
			this._canScrollPrev.set(emblaApi.canScrollPrev());
			this._canScrollNext.set(emblaApi.canScrollNext());
		}
	}

	@HostListener('keydown', ['$event'])
	protected onKeydown(event: KeyboardEvent) {
		if (event.key === 'ArrowLeft') {
			event.preventDefault();
			this.emblaCarousel?.scrollPrev();
		} else if (event.key === 'ArrowRight') {
			event.preventDefault();
			this.emblaCarousel?.scrollNext();
		}
	}

	scrollPrev() {
		this.emblaCarousel?.scrollPrev();
	}

	scrollNext() {
		this.emblaCarousel?.scrollNext();
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-radio/compat.ts
```typescript
import { convertNxGenerator } from '@nx/devkit';
import migrateRadioGenerator from './generator';

export default convertNxGenerator(migrateRadioGenerator);

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-radio/generator.spec.ts
```typescript
import { applicationGenerator, E2eTestRunner, UnitTestRunner } from '@nx/angular/generators';
import { Tree } from '@nx/devkit';
import { createTreeWithEmptyWorkspace } from '@nx/devkit/testing';
import { migrateRadioGenerator } from './generator';

// patch some imports to avoid running the actual code
jest.mock('enquirer');
jest.mock('@nx/devkit', () => {
	const original = jest.requireActual('@nx/devkit');
	return {
		...original,
		ensurePackage: (pkg: string) => jest.requireActual(pkg),
		createProjectGraphAsync: jest.fn().mockResolvedValue({
			nodes: {},
			dependencies: {},
		}),
	};
});

describe('migrate-radio generator', () => {
	let tree: Tree;

	beforeEach(async () => {
		tree = createTreeWithEmptyWorkspace();

		await applicationGenerator(tree, {
			name: 'app',
			directory: 'app',
			skipFormat: true,
			e2eTestRunner: E2eTestRunner.None,
			unitTestRunner: UnitTestRunner.None,
			skipPackageJson: true,
			skipTests: true,
		});
	});

	it('should remove BrnRadioComponent and replace HlmRadioDirective with HlmRadioComponent (NgModule)', async () => {
		tree.write(
			'app/src/app/app.module.ts',
			`
			import { NgModule } from '@angular/core';
			import { BrowserModule } from '@angular/platform-browser';
			import { BrnRadioComponent } from '@spartan-ng/brain/radio-group';
			import { HlmRadioDirective, HlmRadioGroupComponent } from '@spartan-ng/ui-radiogroup-helm';

			@NgModule({
				imports: [BrowserModule, BrnRadioComponent, HlmRadioDirective, HlmRadioGroupComponent],
			})
			export class AppModule {}
			`,
		);

		await migrateRadioGenerator(tree, { skipFormat: true });

		const content = tree.read('app/src/app/app.module.ts', 'utf-8');
		expect(content).not.toContain(`import { BrnRadioComponent } from '@spartan-ng/brain/radio-group';`);
		expect(content).toContain(
			`import { HlmRadioComponent, HlmRadioGroupComponent } from '@spartan-ng/ui-radiogroup-helm';`,
		);
		expect(content).toContain(`imports: [BrowserModule, HlmRadioComponent, HlmRadioGroupComponent],`);
	});

	it('should replace BrnRadioComponent template (Standalone)', async () => {
		tree.write(
			'app/src/app/app.component.ts',
			`
				import { Component } from '@angular/core';
				import { BrnRadioComponent } from '@spartan-ng/brain/radio-group';
				import { HlmRadioDirective, HlmRadioGroupComponent } from '@spartan-ng/ui-radiogroup-helm';
				@Component({
					imports: [BrnRadioComponent, HlmRadioDirective, HlmRadioGroupComponent],
					template: \`
						<hlm-radio-group class="font-mono text-sm font-medium" [(ngModel)]="version">
							<brn-radio hlm value="16.1.4">
								v16.1.4
							</brn-radio>
						</hlm-radio-group>
					\`
				})
				export class AppModule {}
				`,
		);

		await migrateRadioGenerator(tree, { skipFormat: true });

		const content = tree.read('app/src/app/app.component.ts', 'utf-8');
		expect(content).not.toContain(`import { BrnRadioComponent } from '@spartan-ng/brain/radio-group';`);
		expect(content).toContain(
			`import { HlmRadioComponent, HlmRadioGroupComponent } from '@spartan-ng/ui-radiogroup-helm';`,
		);
		expect(content).toContain(`imports: [HlmRadioComponent, HlmRadioGroupComponent],`);
		expect(content).toContain(`<hlm-radio value="16.1.4">`);
	});
	it('should replace BrnRadioComponent also if the hlm is not directly after the brn-radio tag (Standalone)', async () => {
		tree.write(
			'app/src/app/app.component.ts',
			`
				import { Component } from '@angular/core';
				import { BrnRadioComponent } from '@spartan-ng/brain/radio-group';
				import { HlmRadioDirective, HlmRadioGroupComponent } from '@spartan-ng/ui-radiogroup-helm';

				@Component({
					imports: [BrnRadioComponent, HlmRadioDirective, HlmRadioGroupComponent],
					template: \`
						<hlm-radio-group class="font-mono text-sm font-medium" [(ngModel)]="version">
							<brn-radio
			hlm
value="16.1.5">
								should be replaced 1
							</brn-radio>
							<brn-radio class="hlm" value="16.1.4">
								should not be replaced
							</brn-radio>
							<brn-radio class="hlm replace-me" value="hlm" hlm>
								should be replaced 2
							</brn-radio>

						</hlm-radio-group>
					\`
				})
				export class AppModule {}
				`,
		);

		await migrateRadioGenerator(tree, { skipFormat: true });

		const content = tree.read('app/src/app/app.component.ts', 'utf-8');
		expect(content).toContain(`<brn-radio class="hlm" value="16.1.4">`);
		expect(content).toContain(`<hlm-radio class="hlm replace-me" value="hlm">`);
		expect(content).toContain(`<hlm-radio value="16.1.5">`);
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-radio/generator.ts
```typescript
import { formatFiles, Tree } from '@nx/devkit';
import { visitFiles } from '../../utils/visit-files';
import { MigrateRadioGeneratorSchema } from './schema';

export async function migrateRadioGenerator(tree: Tree, { skipFormat }: MigrateRadioGeneratorSchema) {
	updateImports(tree);
	replaceSelector(tree);

	if (!skipFormat) {
		await formatFiles(tree);
	}
}

function replaceSelector(tree: Tree) {
	// if the element is `<brn-radio hlm` then we need to replace it with `<hlm-radio`
	// we also need to replace the closing tag `</brn-radio>` with `</hlm-radio>`
	visitFiles(tree, '.', (path) => {
		// if this is not an html file or typescript file (inline templates) then skip
		if (!path.endsWith('.html') && !path.endsWith('.ts')) {
			return;
		}

		let content = tree.read(path, 'utf-8');

		if (!content) {
			return;
		}

		// <brn-radio hlm but between
		content = replaceBrnRadioHlm(content);
		content = content.replace(/<\/brn-radio>/g, '</hlm-radio>');

		tree.write(path, content);
	});
}

function replaceBrnRadioHlm(input) {
	// Split input to handle multiple tags separately
	return input
		.split(/(?=<)/)
		.map((tag) => {
			// Skip if not a brn-radio tag
			if (!tag.startsWith('<brn-radio')) {
				return tag;
			}

			// Remove line breaks, tabs, and other whitespace within the tag
			// Replace with a single space
			tag = tag.replace(/\s+/g, ' ');

			// Check if standalone hlm attribute exists
			const hasHlm = / hlm(?=[\s>])/.test(tag);

			if (hasHlm) {
				// Remove the hlm attribute and convert to hlm-radio
				return tag
					.replace(/<brn-radio/, '<hlm-radio')
					.replace(/ hlm(?=[\s>])/, '')
					.replace(/\s+>/g, '>')
					.replace(/\s+/g, ' ');
			}

			return tag;
		})
		.join('');
}
/**
 * Update imports remove BrnRadioComponent import and replace HlmRadioDirective with HlmRadioComponent
 */
function updateImports(tree: Tree) {
	visitFiles(tree, '/', (path) => {
		const content = tree.read(path).toString('utf-8');

		if (content.includes('@spartan-ng/brain/radio-group') || content.includes('@spartan-ng/ui-radiogroup-helm')) {
			const updatedContent = content
				// Handle `import { BrnRadioComponent } from '@spartan-ng/brain/radio-group';`
				.replace("import { BrnRadioComponent } from '@spartan-ng/brain/radio-group';", '')
				// Remove `BrnRadioComponent` with optional comma and whitespace
				.replace(/BrnRadioComponent,?\s?/, '')
				// Replace all `HlmRadioDirective` with `HlmRadioComponent`
				.replaceAll('HlmRadioDirective', 'HlmRadioComponent');

			tree.write(path, updatedContent);
		}
	});
}

export default migrateRadioGenerator;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-radio/schema.d.ts
```typescript
export interface MigrateRadioGeneratorSchema {
	skipFormat?: boolean;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-radio/schema.json
```json
{
	"$schema": "https://json-schema.org/schema",
	"$id": "MigrateRadio",
	"title": "",
	"type": "object",
	"properties": {
		"skipFormat": {
			"type": "boolean",
			"default": false,
			"description": "Skip formatting files"
		}
	},
	"required": []
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-icon/compat.ts
```typescript
import { convertNxGenerator } from '@nx/devkit';
import { migrateIconGenerator } from './generator';

export default convertNxGenerator(migrateIconGenerator);

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-icon/generator.spec.ts
```typescript
import { applicationGenerator, E2eTestRunner, UnitTestRunner } from '@nx/angular/generators';
import { Tree } from '@nx/devkit';
import { createTreeWithEmptyWorkspace } from '@nx/devkit/testing';
import { migrateIconGenerator } from './generator';

// patch some imports to avoid running the actual code
jest.mock('enquirer');
jest.mock('@nx/devkit', () => {
	const original = jest.requireActual('@nx/devkit');
	return {
		...original,
		ensurePackage: (pkg: string) => jest.requireActual(pkg),
		createProjectGraphAsync: jest.fn().mockResolvedValue({
			nodes: {},
			dependencies: {},
		}),
	};
});

describe('migrate-icon generator', () => {
	let tree: Tree;

	beforeEach(async () => {
		tree = createTreeWithEmptyWorkspace();

		await applicationGenerator(tree, {
			name: 'app',
			directory: 'app',
			skipFormat: true,
			e2eTestRunner: E2eTestRunner.None,
			unitTestRunner: UnitTestRunner.None,
			skipPackageJson: true,
			skipTests: true,
		});
	});

	it('should add NgIcon import (NgModule)', async () => {
		tree.write(
			'app/src/app/app.module.ts',
			`
			import { NgModule } from '@angular/core';
			import { BrowserModule } from '@angular/platform-browser';
			import { HlmIconModule } from '@spartan-ng/ui-icon-helm';

			@NgModule({
				imports: [BrowserModule, HlmIconModule],
			})
			export class AppModule {}
			`,
		);

		await migrateIconGenerator(tree, { skipFormat: true });

		const content = tree.read('app/src/app/app.module.ts', 'utf-8');
		expect(content).toContain(`import { NgIcon } from '@ng-icons/core';`);
		expect(content).toContain(`imports: [BrowserModule, NgIcon, HlmIconModule],`);
	});

	it('should replace HlmIconComponent (NgModule)', async () => {
		tree.write(
			'app/src/app/app.module.ts',
			`
			import { NgModule } from '@angular/core';
			import { BrowserModule } from '@angular/platform-browser';
			import { HlmIconComponent } from '@spartan-ng/ui-icon-helm';

			@NgModule({
				imports: [BrowserModule, HlmIconComponent],
			})
			export class AppModule {}
			`,
		);

		await migrateIconGenerator(tree, { skipFormat: true });

		const content = tree.read('app/src/app/app.module.ts', 'utf-8');
		expect(content).toContain(`import { NgIcon } from '@ng-icons/core';`);
		expect(content).toContain(`imports: [BrowserModule, NgIcon, HlmIconDirective],`);
	});

	it('should add NgIcon import (Standalone)', async () => {
		tree.write(
			'app/src/app/app.component.ts',
			`
			import { Component } from '@angular/core';
			import { HlmIconModule } from '@spartan-ng/ui-icon-helm';

			@Component({
				imports: [HlmIconModule],
				template: \`
					<hlm-icon size='xl' name="lucideChevronRight" />
				\`
			})
			export class AppModule {}

			`,
		);

		await migrateIconGenerator(tree, { skipFormat: true });

		const content = tree.read('app/src/app/app.component.ts', 'utf-8');
		expect(content).toContain(`import { NgIcon } from '@ng-icons/core';`);
		expect(content).toContain(`imports: [NgIcon, HlmIconModule],`);
		expect(content).toContain(`<ng-icon hlm size='xl' name="lucideChevronRight" />`);
	});

	it('should replace HlmIconComponent (Standalone)', async () => {
		tree.write(
			'app/src/app/app.component.ts',
			`
			import { Component } from '@angular/core';
			import { HlmIconComponent } from '@spartan-ng/ui-icon-helm';

			@Component({
				imports: [HlmIconComponent],
				template: \`
					<hlm-icon size='xl' name="lucideChevronRight" />
				\`
			})
			export class AppModule {}

			`,
		);

		await migrateIconGenerator(tree, { skipFormat: true });

		const content = tree.read('app/src/app/app.component.ts', 'utf-8');
		expect(content).toContain(`import { NgIcon } from '@ng-icons/core';`);
		expect(content).toContain(`import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';`);
		expect(content).toContain(`imports: [NgIcon, HlmIconDirective],`);
		expect(content).toContain(`<ng-icon hlm size='xl' name="lucideChevronRight" />`);
	});

	it('should re-write the provideIcons import', async () => {
		tree.write(
			'app/src/app/app.component.ts',
			`
			import { Component } from '@angular/core';
			import { provideIcons } from '@spartan-ng/ui-icon-helm';
			import { lucideChevronRight } from '@ng-icons/lucide';

			@Component({
				providers: [provideIcons({ lucideChevronRight })],
			})
			export class AppComponent {}
			`,
		);

		await migrateIconGenerator(tree, { skipFormat: true });

		const content = tree.read('app/src/app/app.component.ts', 'utf-8');
		expect(content).toContain(`import { provideIcons } from '@ng-icons/core';`);
		expect(content).toContain(`providers: [provideIcons({ lucideChevronRight })],`);
	});

	it('should add the name attribute for accordion icons', async () => {
		tree.write(
			'app/src/app/app.component.ts',
			`
			import { Component } from '@angular/core';

			@Component({
				template: \`
					<hlm-icon hlmAccIcon name="lucideChevronDown" />
				\`
			})
			export class AppComponent {}

			`,
		);

		await migrateIconGenerator(tree, { skipFormat: true });

		const content = tree.read('app/src/app/app.component.ts', 'utf-8');
		expect(content).toContain(`<ng-icon hlm hlmAccIcon name="lucideChevronDown" />`);
	});

	it('should convert tailwind width, height and size classes', async () => {
		tree.write(
			'app/src/app/app.component.ts',
			`
			import { Component } from '@angular/core';

			@Component({
				template: \`
					<hlm-icon size="sm" name="lucideChevronRight" />
					<hlm-icon size="base" name="lucideChevronRight" />
					<hlm-icon size="lg" name="lucideChevronRight" />
					<hlm-icon size="6px" name="lucideChevronRight" />
					<hlm-icon size="8px" class="text-red-500" name="lucideChevronRight" />
					<hlm-icon size="sm" class="ml-2" name="lucideChevronUp" />
				\`
			})
			export class AppComponent {}

			`,
		);

		await migrateIconGenerator(tree, { skipFormat: true });

		const content = tree.read('app/src/app/app.component.ts', 'utf-8');
		expect(content).toContain(`<ng-icon hlm size="sm" name="lucideChevronRight" />`);
		expect(content).toContain(`<ng-icon hlm size="base" name="lucideChevronRight" />`);
		expect(content).toContain(`<ng-icon hlm size="lg" name="lucideChevronRight" />`);
		expect(content).toContain(`<ng-icon hlm size="6px" name="lucideChevronRight" />`);
		expect(content).toContain(`<ng-icon hlm size="8px" class="text-red-500" name="lucideChevronRight" />`);
		expect(content).toContain(`<ng-icon hlm size="sm" class="ml-2" name="lucideChevronUp" />`);
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-icon/generator.ts
```typescript
import { formatFiles, Tree } from '@nx/devkit';
import { applyChangesToString, ChangeType, StringChange } from '@nx/devkit/src/utils/string-change';
import { isImported } from '@schematics/angular/utility/ast-utils';
import ts from 'typescript';
import { visitFiles } from '../../utils/visit-files';
import { MigrateIconGeneratorSchema } from './schema';

export async function migrateIconGenerator(tree: Tree, { skipFormat }: MigrateIconGeneratorSchema) {
	replaceImports(tree);
	replaceSelector(tree);
	replaceProvideIcons(tree);
	addAccordionIcon(tree);
	replaceTailwindClasses(tree);

	if (!skipFormat) {
		await formatFiles(tree);
	}
}

function replaceTailwindClasses(tree: Tree) {
	visitFiles(tree, '.', (path) => {
		// if this is not a html or typescript file then skip
		if (!path.endsWith('.ts') && !path.endsWith('.html')) {
			return;
		}

		let content = tree.read(path, 'utf-8');

		// if there are no icons then skip
		if (!content || !content.includes('ng-icon')) {
			return;
		}

		const changes: StringChange[] = [];

		const regex = /<ng-icon\b[^>]*>/g;

		let match;

		while ((match = regex.exec(content)) !== null) {
			const startIndex = match.index;

			// if there already is a size attribute then skip
			if (match[0].includes('size=')) {
				continue;
			}

			// get the class attribute
			const classMatch = match[0].match(/class="([^"]*)"/);

			if (!classMatch) {
				continue;
			}

			const className = classMatch[1];

			// get each class in the class attribute
			const classes = className.split(' ');

			// find any known size
			const size = classes.find((c: string) => tailwindToSize(c) !== null);

			if (!size) {
				continue;
			}

			const sizeValue = tailwindToSize(size);

			// remove the size class
			let output = match[0]
				.replace(/\b(w|h|size)-\S+\b/g, '')
				.replace(/class=(["'])(\s*)(.+?)(\s*)\1/g, 'class=$1$3$1')
				.replace(/\s*class="\s*"\s*/g, ' ');

			// add the size attribute
			output = output.replace(' hlm ', ` hlm size="${sizeValue}" `);

			// delete the original line
			changes.push({
				type: ChangeType.Delete,
				start: startIndex,
				length: match[0].length,
			});

			// insert the new line
			changes.push({
				type: ChangeType.Insert,
				index: startIndex,
				text: output,
			});
		}

		content = applyChangesToString(content, changes);

		tree.write(path, content);
	});
}

function tailwindToSize(className: string): string | null {
	// if this is not a width, height or size class then skip
	if (/\b(w|h|size)-\S+\b/.test(className) === false) {
		return null;
	}

	const [, value] = className.split('-');

	// Handle specific Tailwind keywords
	const keywordMapping = {
		full: '100%',
		screen: '100vw',
		auto: 'auto',
		min: 'min-content',
		max: 'max-content',
		fit: 'fit-content',
	};

	// Check if value is a keyword
	if (keywordMapping[value]) {
		return `${keywordMapping[value]};`;
	}

	// Convert numeric values to a number
	const numericValue = parseFloat(value);

	if (!isNaN(numericValue)) {
		const px = numericValue * 4;

		switch (px) {
			case 12:
				return 'xs';
			case 16:
				return 'sm';
			case 24:
				return 'base';
			case 32:
				return 'lg';
			case 48:
				return 'xl';
		}

		return `${px}px`;
	}

	// Handle other cases
	return null;
}

function addAccordionIcon(tree: Tree) {
	visitFiles(tree, '.', (path) => {
		// if this is not a html or typescript file then skip
		if (!path.endsWith('.ts') && !path.endsWith('.html')) {
			return;
		}

		let content = tree.read(path, 'utf-8');

		if (!content) {
			return;
		}

		// if there is no hlmAccIcon or hlmAccordionIcon then skip
		if (!content.includes('hlmAccIcon') && !content.includes('hlmAccordionIcon')) {
			return;
		}

		const changes: StringChange[] = [];

		// if an element is using hlmAccIcon or hlmAccordionIcon and has no name attribute then add the name attribute
		const regex = /<ng-icon\b[^>]*(\bhlmAccIcon\b|\bhlmAccordionIcon\b)[^>]*>/g;

		let match;
		const results: { match: string; index: number }[] = [];

		while ((match = regex.exec(content)) !== null) {
			results.push({ match: match[0], index: match.index });
		}

		if (!results.length) {
			return;
		}

		for (const { match, index } of results) {
			if (!match.includes('name=')) {
				const directive = match.includes('hlmAccIcon') ? 'hlmAccIcon' : 'hlmAccordionIcon';

				const startIndex = index + match.indexOf(directive);

				changes.push({
					type: ChangeType.Insert,
					index: startIndex + directive.length,
					text: ` name="lucideChevronDown"`,
				});
			}
		}

		content = applyChangesToString(content, changes);

		tree.write(path, content);
	});
}

function replaceProvideIcons(tree: Tree) {
	visitFiles(tree, '.', (path) => {
		// if this is not a typescript file then skip
		if (!path.endsWith('.ts')) {
			return;
		}

		let content = tree.read(path, 'utf-8');

		// if the user is importing `provideIcons` from '@spartan-ng/ui-icon-helm' then we need to replace it with `provideIcons` from '@ng-icons/core'
		if (!content || !content?.includes('provideIcons')) {
			return;
		}

		const sourceFile = ts.createSourceFile(path, content, ts.ScriptTarget.Latest, true);

		if (!isImported(sourceFile, 'provideIcons', '@spartan-ng/ui-icon-helm')) {
			return;
		}

		const changes: StringChange[] = [];

		// remove the import of provideIcons from '@spartan-ng/ui-icon-helm'
		// add the import of provideIcons from '@ng-icons/core'
		changes.push({
			type: ChangeType.Delete,
			start: content.indexOf('provideIcons'),
			length: 'provideIcons'.length,
		});

		changes.push({
			type: ChangeType.Insert,
			index: 0,
			text: `import { provideIcons } from '@ng-icons/core';\n`,
		});

		content = applyChangesToString(content, changes);

		tree.write(path, content);
	});
}

function replaceSelector(tree: Tree) {
	// if the element is `<ng-icon hlm` then we need to replace it with `<ng-icon hlm`
	// we also need to replace the closing tag `</ng-icon>` with `</ng-icon>`
	visitFiles(tree, '.', (path) => {
		// if this is not an html file or typescript file (inline templates) then skip
		if (!path.endsWith('.html') && !path.endsWith('.ts')) {
			return;
		}

		let content = tree.read(path, 'utf-8');

		if (!content) {
			return;
		}

		content = content.replace(/<hlm-icon/g, '<ng-icon hlm');
		content = content.replace(/<\/hlm-icon>/g, '</ng-icon>');

		tree.write(path, content);
	});
}

function replaceImports(tree: Tree) {
	// ng modules or standalone components will have import arrays that may need updated.
	// if the import is `HlmIconModule` then we need to also import `NgIcon`,
	// if the import is `HlmIconComponent` we need to rename it to `HlmIconDirective` and add the `NgIcon` import.
	visitFiles(tree, '.', (path) => {
		// if the file is not a typescript file then skip
		if (!path.endsWith('.ts')) {
			return;
		}

		let content = tree.read(path, 'utf-8');

		if (!content) {
			return;
		}

		// convert the content to an ast
		const sourceFile = ts.createSourceFile(path, content, ts.ScriptTarget.Latest, true);

		// find all imports of HlmIconModule or HlmIconComponent
		const imports = findHlmIconImports(sourceFile);

		// if no imports are found then skip
		if (imports.length === 0) {
			return;
		}

		const changes: StringChange[] = [];

		for (const identifier of imports) {
			// if the identifier is HlmIconModule then we need to add NgIcon to the imports
			if (identifier.getText() === 'HlmIconModule') {
				changes.push({
					type: ChangeType.Insert,
					index: identifier.getStart(),
					text: 'NgIcon, ',
				});
			}

			// if the identifier is HlmIconComponent then we need to rename it to HlmIconDirective and add NgIcon to the imports
			if (identifier.getText() === 'HlmIconComponent') {
				changes.push({
					type: ChangeType.Insert,
					index: identifier.getStart(),
					text: 'NgIcon, ',
				});
			}

			// check if the NgIcon import is already present
			if (!hasImport(content, 'NgIcon', '@ng-icons/core')) {
				changes.push({
					type: ChangeType.Insert,
					index: 0,
					text: `import { NgIcon } from '@ng-icons/core';\n`,
				});
			}
		}

		content = applyChangesToString(content, changes);

		// if there are any remaining uses of HlmIconComponent then replace them with HlmIconDirective
		content = content.replace(/HlmIconComponent/g, 'HlmIconDirective');

		tree.write(path, content);
	});
}

function findHlmIconImports(node: ts.SourceFile): ts.Node[] {
	const matches: ts.Identifier[] = [];

	const visit = (node: ts.Node) => {
		if (
			ts.isPropertyAssignment(node) &&
			node.name.getText() === 'imports' &&
			ts.isArrayLiteralExpression(node.initializer)
		) {
			// check if the array literal contains the HlmIconModule or HlmIconComponent
			node.initializer.elements.forEach((element) => {
				if (ts.isIdentifier(element)) {
					if (element.getText() === 'HlmIconModule' || element.getText() === 'HlmIconComponent') {
						matches.push(element);
					}
				}
			});
		}

		ts.forEachChild(node, visit);
	};

	visit(node);

	return matches;
}

function hasImport(contents: string, importName: string, importPath: string): boolean {
	const sourceFile = ts.createSourceFile('temp.ts', contents, ts.ScriptTarget.Latest, true);
	return isImported(sourceFile, importName, importPath);
}

export default migrateIconGenerator;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-icon/schema.d.ts
```typescript
export interface MigrateIconGeneratorSchema {
	skipFormat?: boolean;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-icon/schema.json
```json
{
	"$schema": "https://json-schema.org/schema",
	"$id": "MigrateIcon",
	"title": "",
	"type": "object",
	"properties": {
		"skipFormat": {
			"type": "boolean",
			"default": false,
			"description": "Skip formatting files"
		}
	},
	"required": []
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-select/compat.ts
```typescript
import { convertNxGenerator } from '@nx/devkit';
import migrateSelectGenerator from './generator';

export default convertNxGenerator(migrateSelectGenerator);

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-select/generator.spec.ts
```typescript
import { applicationGenerator, E2eTestRunner, UnitTestRunner } from '@nx/angular/generators';
import { Tree } from '@nx/devkit';
import { createTreeWithEmptyWorkspace } from '@nx/devkit/testing';
import { migrateSelectGenerator } from './generator';

// patch some imports to avoid running the actual code
jest.mock('enquirer');
jest.mock('@nx/devkit', () => {
	const original = jest.requireActual('@nx/devkit');
	return {
		...original,
		ensurePackage: (pkg: string) => jest.requireActual(pkg),
		createProjectGraphAsync: jest.fn().mockResolvedValue({
			nodes: {},
			dependencies: {},
		}),
	};
});

describe('migrate-select generator', () => {
	let tree: Tree;

	beforeEach(async () => {
		tree = createTreeWithEmptyWorkspace();

		await applicationGenerator(tree, {
			name: 'app',
			directory: 'app',
			skipFormat: true,
			e2eTestRunner: E2eTestRunner.None,
			unitTestRunner: UnitTestRunner.None,
			skipPackageJson: true,
			skipTests: true,
		});
	});

	it('should rename (openedChange) to (openChange) on select elements', async () => {
		tree.write(
			'app/src/app/app.component.html',
			`
				<brn-select (openedChange)="onOpenedChange($event)"></brn-select>
				<brn-select (openedChange)="onOpenedChange($event)" />
				<brn-select hlm (openedChange)="onOpenedChange($event)"></brn-select>
				<brn-select hlm (openedChange)="onOpenedChange($event)" />
				<hlm-select (openedChange)="onOpenedChange($event)"></hlm-select>
				<hlm-select (openedChange)="onOpenedChange($event)" />

				<!-- This is not a select, so it should not be changed -->
				<div (openedChange)="onOpenedChange($event)"></div>
			`,
		);

		await migrateSelectGenerator(tree, { skipFormat: true });

		const content = tree.read('app/src/app/app.component.html', 'utf-8');
		expect(content).toBe(`
				<brn-select (openChange)="onOpenedChange($event)"></brn-select>
				<brn-select (openChange)="onOpenedChange($event)" />
				<brn-select hlm (openChange)="onOpenedChange($event)"></brn-select>
				<brn-select hlm (openChange)="onOpenedChange($event)" />
				<hlm-select (openChange)="onOpenedChange($event)"></hlm-select>
				<hlm-select (openChange)="onOpenedChange($event)" />

				<!-- This is not a select, so it should not be changed -->
				<div (openedChange)="onOpenedChange($event)"></div>
			`);
	});

	it('should migrate the hlm-select-option classes', () => {
		tree.write(
			'app/src/app/hlm-select-option.component.ts',
			`import { ChangeDetectionStrategy, Component, computed, inject, input } from '@angular/core';
			import { NgIcon, provideIcons } from '@ng-icons/core';
			import { lucideCheck } from '@ng-icons/lucide';
			import { hlm } from '@spartan-ng/brain/core';
			import { BrnSelectOptionDirective } from '@spartan-ng/brain/select';
			import { HlmIconDirective } from '@spartan-ng/ui-icon-helm';
			import type { ClassValue } from 'clsx';

			@Component({
				selector: 'hlm-option',
				standalone: true,
				changeDetection: ChangeDetectionStrategy.OnPush,
				hostDirectives: [{ directive: BrnSelectOptionDirective, inputs: ['disabled', 'value'] }],
				providers: [provideIcons({ lucideCheck })],
				host: {
					'[class]': '_computedClass()',
				},
				template: \`
					<ng-content />
					<span
						[attr.dir]="_brnSelectOption.dir()"
						class="absolute left-2 flex h-3.5 w-3.5 items-center justify-center rtl:left-auto rtl:right-2"
						[attr.data-state]="this._brnSelectOption.checkedState()"
					>
						@if (this._brnSelectOption.selected()) {
							<ng-icon hlm size="sm" aria-hidden="true" name="lucideCheck" />
						}
					</span>
				\`,
				imports: [NgIcon, HlmIconDirective],
			})
			export class HlmSelectOptionComponent {
				protected readonly _brnSelectOption = inject(BrnSelectOptionDirective, { host: true });
				public readonly userClass = input<ClassValue>('', { alias: 'class' });
				protected readonly _computedClass = computed(() =>
					hlm(
						'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 rtl:flex-reverse rtl:pr-8 rtl:pl-2 text-sm outline-none data-[active]:bg-accent data-[active]:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
						this.userClass(),
					),
				);
			}
			`,
		);

		migrateSelectGenerator(tree, { skipFormat: true });

		const content = tree.read('app/src/app/hlm-select-option.component.ts', 'utf-8');

		// extract the string literal from the hlm function
		const matches = content.match(/hlm\(\s*(['"])(.*?)\1/s);
		const classes = matches[2];

		expect(classes).toBe(
			'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 rtl:flex-reverse rtl:pr-8 rtl:pl-2 text-sm outline-none data-[active]:bg-accent data-[active]:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
		);
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-select/generator.ts
```typescript
import { formatFiles, Tree } from '@nx/devkit';
import { updateHelmClasses } from '../../utils/hlm-class';
import { visitFiles } from '../../utils/visit-files';
import { MigrateSelectGeneratorSchema } from './schema';

export async function migrateSelectGenerator(tree: Tree, { skipFormat }: MigrateSelectGeneratorSchema) {
	replaceOpenChangeEvent(tree);
	replaceFocusClasses(tree);

	if (!skipFormat) {
		await formatFiles(tree);
	}
}

function replaceOpenChangeEvent(tree: Tree) {
	// if the element is `<brn-select`, '<hlm-select' and it has an `(openedChange)` event, we need to replace it with `(openChange)`
	visitFiles(tree, '.', (path) => {
		// if this is not an html file or typescript file (inline templates) then skip
		if (!path.endsWith('.html') && !path.endsWith('.ts')) {
			return;
		}

		let content = tree.read(path, 'utf-8');

		if (!content) {
			return;
		}

		// find all the brn-select or hlm-select elements that have an `(openedChange)` event
		content = content.replace(/<(brn-select|hlm-select)[^>]*\(\s*openedChange\s*\)=/g, (match) =>
			match.replace(/\(\s*openedChange\s*\)/, '(openChange)'),
		);

		tree.write(path, content);
	});
}

function replaceFocusClasses(tree: Tree) {
	// update the hlm classes
	visitFiles(tree, '.', (path) => {
		// if this is not a typescript file then skip
		if (!path.endsWith('.ts')) {
			return;
		}

		updateHelmClasses(tree, path, {
			component: 'HlmSelectOptionComponent',
			classesToRemove: ['focus:bg-accent', 'focus:text-accent-foreground'],
			classesToAdd: ['data-[active]:bg-accent', 'data-[active]:text-accent-foreground'],
		});
	});
}

export default migrateSelectGenerator;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-select/schema.d.ts
```typescript
export interface MigrateSelectGeneratorSchema {
	skipFormat?: boolean;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-select/schema.json
```json
{
	"$schema": "https://json-schema.org/schema",
	"$id": "MigrateSelect",
	"title": "",
	"type": "object",
	"properties": {
		"skipFormat": {
			"type": "boolean",
			"default": false,
			"description": "Skip formatting files"
		}
	},
	"required": []
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/healthcheck/compat.ts
```typescript
import { convertNxGenerator } from '@nx/devkit';
import { healthcheckGenerator } from './generator';
import { HealthcheckGeneratorSchema } from './schema';

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export default convertNxGenerator((tree: any, schema: HealthcheckGeneratorSchema & { angularCli?: boolean }) =>
	healthcheckGenerator(tree, { ...schema, angularCli: true }),
);

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/healthcheck/generator.spec.ts
```typescript
import { readJson, Tree, writeJson } from '@nx/devkit';
import { createTreeWithEmptyWorkspace } from '@nx/devkit/testing';
import { healthcheckGenerator } from './generator';

describe('healthcheck generator', () => {
	let tree: Tree;

	beforeEach(async () => {
		tree = createTreeWithEmptyWorkspace();

		writeJson(tree, 'package.json', {
			dependencies: {
				'@spartan-ng/brain': '0.0.1-alpha.300',
				'@spartan-ng/ui-checkbox-brain': '0.0.1-alpha.300',
			},
			devDependencies: {
				'@spartan-ng/cli': '0.0.1-alpha.300',
			},
		});

		// add a file with legacy imports
		tree.write(
			'libs/my-lib/src/index.ts',
			`
			import { BrnCheckbox } from '@spartan-ng/ui-checkbox-brain';
			import { hlm } from '@spartan-ng/ui-core';
		`,
		);

		// add a file with a helm icon
		tree.write(
			'libs/my-lib/src/app.component.html',
			`
			<hlm-icon />
			<hlm-scroll-area />
		`,
		);

		await healthcheckGenerator(tree, { skipFormat: true, autoFix: true });
	});

	it('should update to latest dependencies', () => {
		const packageJson = readJson(tree, 'package.json');

		expect(packageJson.dependencies['@spartan-ng/brain']).not.toEqual('0.0.1-alpha.300');
		expect(packageJson.devDependencies['@spartan-ng/cli']).not.toEqual('0.0.1-alpha.300');
	});

	it('should update brain imports', () => {
		const contents = tree.read('libs/my-lib/src/index.ts', 'utf-8');

		expect(contents).not.toContain('@spartan-ng/ui-checkbox-brain');
		expect(contents).toContain('@spartan-ng/brain/checkbox');

		// check if package.json was updated
		const packageJson = readJson(tree, 'package.json');
		expect(packageJson.dependencies['@spartan-ng/ui-checkbox-brain']).toBeUndefined();
	});

	it('should update core imports', () => {
		const contents = tree.read('libs/my-lib/src/index.ts', 'utf-8');

		expect(contents).not.toContain('@spartan-ng/ui-core');
		expect(contents).toContain('@spartan-ng/brain/core');
	});

	it('should update helm icons', () => {
		const contents = tree.read('libs/my-lib/src/app.component.html', 'utf-8');

		expect(contents).not.toContain('<hlm-icon');
		expect(contents).toContain('<ng-icon hlm');
	});

	it('should update helm scroll areas', () => {
		const contents = tree.read('libs/my-lib/src/app.component.html', 'utf-8');

		expect(contents).not.toContain('<hlm-scroll-area');
		expect(contents).toContain('<ng-scrollbar hlm');
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/healthcheck/generator.ts
```typescript
import { formatFiles, logger, Tree } from '@nx/devkit';
import { Healthcheck, HealthcheckReport, HealthcheckStatus, isHealthcheckFixable } from './healthchecks';
import { brainImportsHealthcheck } from './healthchecks/brain-imports';
import { brainRadioHealthcheck } from './healthchecks/brn-radio';
import { brainToggleHealthcheck } from './healthchecks/brn-toggle-group';
import { coreImportsHealthcheck } from './healthchecks/core-imports';
import { helmIconHealthcheck } from './healthchecks/hlm-icon';
import { scrollAreaHealthcheck } from './healthchecks/hlm-scroll-area';
import { selectHealthcheck } from './healthchecks/hlm-select';
import { versionHealthcheck } from './healthchecks/version';
import { HealthcheckGeneratorSchema } from './schema';
import { promptUser } from './utils/prompt';
import { printReport } from './utils/reporter';
import { runHealthcheck } from './utils/runner';

export async function healthcheckGenerator(tree: Tree, options: HealthcheckGeneratorSchema & { angularCli?: boolean }) {
	logger.info('Running healthchecks...');

	const healthchecks: Healthcheck[] = [
		versionHealthcheck,
		brainImportsHealthcheck,
		coreImportsHealthcheck,
		helmIconHealthcheck,
		scrollAreaHealthcheck,
		brainRadioHealthcheck,
		selectHealthcheck,
		brainToggleHealthcheck,
	];

	const failedReports: HealthcheckReport[] = [];

	for (const healthcheck of healthchecks) {
		const report = await runHealthcheck(tree, healthcheck);
		printReport(report);

		if (report.status === HealthcheckStatus.Failure) {
			failedReports.push(report);
		}
	}

	for (const report of failedReports) {
		if (report.fixable && isHealthcheckFixable(report.healthcheck)) {
			const fix = options.autoFix || (await promptUser(report.healthcheck.prompt));

			if (fix) {
				await report.healthcheck.fix(tree, { angularCli: options.angularCli });
			}
		}
	}

	if (!options.skipFormat) {
		await formatFiles(tree);
	}
}

export default healthcheckGenerator;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/healthcheck/healthchecks.ts
```typescript
import { Tree } from '@nx/devkit';

export type Healthcheck = StandardHealthcheck | FixableHealthcheck;

interface StandardHealthcheck {
	/**
	 * The name of the healthcheck.
	 */
	name: string;

	/**
	 * Determine whether or not anything in the project needs to be fixed.
	 */
	detect(tree: Tree, failure: HealthcheckFailureFn, skip: HealthcheckSkippedFn): void | Promise<void>;
}

interface FixableHealthcheck extends StandardHealthcheck {
	/**
	 * Fix any issues found by the check method. Return true if the issue was fixed, false if it was not.
	 */
	fix(tree: Tree, context: HealthcheckContext): boolean | Promise<boolean>;
	/**
	 * The auto fix prompt message.
	 */
	prompt: string;
}

export enum HealthcheckStatus {
	Success,
	Failure,
	Skipped,
}

export enum HealthcheckSeverity {
	Error,
	Warning,
}

export type HealthcheckFailureFn = (issue: string, severity: HealthcheckSeverity, fixable: boolean) => void;
export type HealthcheckSkippedFn = (reason: string) => void;

/**
 * Determine if a healthcheck is fixable.
 */
export function isHealthcheckFixable(healthcheck: Healthcheck): healthcheck is FixableHealthcheck {
	return 'fix' in healthcheck;
}

export interface HealthcheckReport {
	/**
	 * The name of the healthcheck.
	 */
	name: string;

	/**
	 * The healthcheck.
	 */
	healthcheck: Healthcheck;

	/**
	 * The status of the healthcheck.
	 */
	status: HealthcheckStatus;

	/**
	 * The list of issues that were found by the healthcheck.
	 */
	issues?: HealthcheckIssue[];

	/**
	 * If the healthcheck was skipped, this message will be displayed to the user.
	 */
	reason?: string;

	/**
	 * Whether or not the healthcheck can be fixed.
	 */
	fixable: boolean;
}

export interface HealthcheckIssue {
	/**
	 * The details of the issue that was found by the healthcheck.
	 */
	details: string;

	/**
	 * The severity of the issue.
	 */
	severity: HealthcheckSeverity;
}

interface HealthcheckContext {
	angularCli?: boolean;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/healthcheck/schema.d.ts
```typescript
export interface HealthcheckGeneratorSchema {
	autoFix?: boolean;
	skipFormat?: boolean;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/healthcheck/schema.json
```json
{
	"$schema": "http://json-schema.org/draft-07/schema",
	"$id": "Healthcheck",
	"title": "",
	"type": "object",
	"properties": {
		"autoFix": {
			"type": "boolean",
			"default": false,
			"description": "Automatically fix any issues"
		},
		"skipFormat": {
			"type": "boolean",
			"default": false,
			"description": "Skip formatting files"
		}
	},
	"required": []
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/healthcheck/healthchecks/brain-imports.ts
```typescript
import { visitNotIgnoredFiles } from '@nx/devkit';
import { migrateBrainImportsGenerator } from '../../migrate-brain-imports/generator';
import importMap from '../../migrate-brain-imports/import-map';
import { Healthcheck, HealthcheckSeverity } from '../healthchecks';

export const brainImportsHealthcheck: Healthcheck = {
	name: 'Brain imports',
	async detect(tree, failure) {
		visitNotIgnoredFiles(tree, '/', (file) => {
			// if the file is a .ts or .json file, check for brain imports/packages
			if (!file.endsWith('.ts') || file.endsWith('.json')) {
				return;
			}

			const contents = tree.read(file, 'utf-8');

			if (!contents) {
				return;
			}

			for (const [importPath, brainPackage] of Object.entries(importMap)) {
				if (contents.includes(importPath)) {
					failure(
						`The import ${importPath} is deprecated. Please use the ${brainPackage} package instead.`,
						HealthcheckSeverity.Error,
						true,
					);
				}
			}
		});
	},
	fix: async (tree) => {
		await migrateBrainImportsGenerator(tree, { skipFormat: true });
		return true;
	},
	prompt: 'Would you like to migrate brain imports?',
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/healthcheck/healthchecks/brn-radio.ts
```typescript
import { visitNotIgnoredFiles } from '@nx/devkit';
import { migrateRadioGenerator } from '../../migrate-radio/generator';
import { Healthcheck, HealthcheckSeverity } from '../healthchecks';

export const brainRadioHealthcheck: Healthcheck = {
	name: 'Brain Radio',
	async detect(tree, failure) {
		visitNotIgnoredFiles(tree, '/', (file) => {
			// if the file is a .ts or .htlm file, check for brain radio
			if (!file.endsWith('.ts') && !file.endsWith('.html')) {
				return;
			}

			const contents = tree.read(file, 'utf-8');

			if (!contents) {
				return;
			}

			if (contents.includes('<brn-radio')) {
				failure(
					`The <brn-radio> component is deprecated. Please use the <hlm-radio> instead.`,
					HealthcheckSeverity.Error,
					true,
				);
			}
		});
	},
	fix: async (tree) => {
		await migrateRadioGenerator(tree, { skipFormat: true });
		return true;
	},
	prompt: 'Would you like to migrate brain radio?',
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/healthcheck/healthchecks/brn-toggle-group.ts
```typescript
import { visitNotIgnoredFiles } from '@nx/devkit';
import { migrateToggleGroupGenerator } from '../../migrate-toggle-group/generator';
import { Healthcheck, HealthcheckSeverity } from '../healthchecks';

export const brainToggleHealthcheck: Healthcheck = {
	name: 'Brain Toggle Group',
	async detect(tree, failure) {
		visitNotIgnoredFiles(tree, '/', (file) => {
			// if the file is a .ts or .htlm file, check for helm icons
			if (!file.endsWith('.ts') && !file.endsWith('.html')) {
				return;
			}

			const contents = tree.read(file, 'utf-8');

			if (!contents) {
				return;
			}

			if (
				contents.includes("BrnToggleGroupModule } from '@spartan-ng/brain/toggle'") ||
				contents.includes("import { BrnToggleGroupModule } from '@spartan-ng/brain/toggle'") ||
				(contents.includes('BrnToggleGroupModule') && contents.includes('@spartan-ng/brain/toggle')) ||
				contents.includes("HlmToggleGroupModule } from '@spartan-ng/ui-toggle-helm'") ||
				(contents.includes('HlmToggleGroupModule') && contents.includes('@spartan-ng/ui-toggle-helm'))
			) {
				failure(
					'The <brn-toggle-group> component from the toggle brain package is deprecated. Please use the <brn-toggle-group> from the toggle-group package instead.',
					HealthcheckSeverity.Error,
					true,
				);
			}
		});
	},
	fix: async (tree) => {
		await migrateToggleGroupGenerator(tree, { skipFormat: true });
		return true;
	},
	prompt: 'Would you like to migrate toggle-group?',
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/healthcheck/healthchecks/core-imports.ts
```typescript
import { visitNotIgnoredFiles } from '@nx/devkit';
import { migrateCoreGenerator } from '../../migrate-core/generator';
import { Healthcheck, HealthcheckSeverity } from '../healthchecks';

export const coreImportsHealthcheck: Healthcheck = {
	name: 'Core imports',
	async detect(tree, failure) {
		visitNotIgnoredFiles(tree, '/', (file) => {
			// if the file is a .ts file, check for core imports
			if (!file.endsWith('.ts')) {
				return;
			}

			const contents = tree.read(file, 'utf-8');

			if (!contents) {
				return;
			}

			if (contents.includes('@spartan-ng/ui-core')) {
				failure(
					`The import @spartan-ng/ui-core is deprecated. Please use the @spartan-ng/brain/core package instead.`,
					HealthcheckSeverity.Error,
					true,
				);
			}
		});
	},
	fix: async (tree) => {
		await migrateCoreGenerator(tree, { skipFormat: true });
		return true;
	},
	prompt: 'Would you like to migrate core imports?',
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/healthcheck/healthchecks/hlm-icon.ts
```typescript
import { visitNotIgnoredFiles } from '@nx/devkit';
import { migrateIconGenerator } from '../../migrate-icon/generator';
import { Healthcheck, HealthcheckSeverity } from '../healthchecks';

export const helmIconHealthcheck: Healthcheck = {
	name: 'Helm Icons',
	async detect(tree, failure) {
		visitNotIgnoredFiles(tree, '/', (file) => {
			// if the file is a .ts or .htlm file, check for helm icons
			if (!file.endsWith('.ts') && !file.endsWith('.html')) {
				return;
			}

			const contents = tree.read(file, 'utf-8');

			if (!contents) {
				return;
			}

			if (contents.includes('<hlm-icon')) {
				failure(
					`The <hlm-icon> component is deprecated. Please use the <ng-icon hlm> instead.`,
					HealthcheckSeverity.Error,
					true,
				);
			}
		});
	},
	fix: async (tree) => {
		await migrateIconGenerator(tree, { skipFormat: true });
		return true;
	},
	prompt: 'Would you like to migrate helm icons?',
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/healthcheck/healthchecks/hlm-scroll-area.ts
```typescript
import { visitNotIgnoredFiles } from '@nx/devkit';
import { migrateScrollAreaGenerator } from '../../migrate-scroll-area/generator';
import { Healthcheck, HealthcheckSeverity } from '../healthchecks';

export const scrollAreaHealthcheck: Healthcheck = {
	name: 'Helm Scroll Area',
	async detect(tree, failure) {
		visitNotIgnoredFiles(tree, '/', (file) => {
			// if the file is a .ts or .htlm file, check for helm icons
			if (!file.endsWith('.ts') && !file.endsWith('.html')) {
				return;
			}

			const contents = tree.read(file, 'utf-8');

			if (!contents) {
				return;
			}

			if (contents.includes('<hlm-scroll-area')) {
				failure(
					`The <hlm-scroll-area> component is deprecated. Please use the <ng-scrollbar hlm> instead.`,
					HealthcheckSeverity.Error,
					true,
				);
			}
		});
	},
	fix: async (tree) => {
		await migrateScrollAreaGenerator(tree, { skipFormat: true });
		return true;
	},
	prompt: 'Would you like to migrate helm scroll areas?',
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/healthcheck/healthchecks/hlm-select.ts
```typescript
import { visitNotIgnoredFiles } from '@nx/devkit';
import { hasHelmClasses } from '../../../utils/hlm-class';
import migrateSelectGenerator from '../../migrate-select/generator';
import { Healthcheck, HealthcheckSeverity } from '../healthchecks';

export const selectHealthcheck: Healthcheck = {
	name: 'Helm Select',
	async detect(tree, failure) {
		visitNotIgnoredFiles(tree, '/', (file) => {
			// if the file is a .ts or .htlm file, check for helm icons
			if (!file.endsWith('.ts') && !file.endsWith('.html')) {
				return;
			}

			const contents = tree.read(file, 'utf-8');

			if (!contents) {
				return;
			}

			// check if the legacy openedChange event is being used
			if (/<(brn-select|hlm-select)[^>]*\(\s*openedChange\s*\)=/g.test(contents)) {
				failure('Select is using the renamed openedChange event.', HealthcheckSeverity.Error, true);
			}

			// check if the legacy focus classes are being used
			if (
				hasHelmClasses(tree, file, {
					component: 'HlmSelectOptionComponent',
					classes: ['focus:bg-accent', 'focus:text-accent-foreground'],
				})
			) {
				failure('Select option is using the legacy focus classes.', HealthcheckSeverity.Error, true);
			}
		});
	},
	fix: async (tree) => {
		await migrateSelectGenerator(tree, { skipFormat: true });
		return true;
	},
	prompt: 'Would you like to migrate selects?',
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/healthcheck/healthchecks/version.ts
```typescript
import { readJson } from '@nx/devkit';
import { PackageJson } from 'nx/src/utils/package-json';
import * as semver from 'semver';
import { Healthcheck, HealthcheckSeverity } from '../healthchecks';

export const versionHealthcheck: Healthcheck = {
	name: 'Spartan - Dependency Check',
	async detect(tree, failure, skip) {
		// If there is no package.json, skip this healthcheck
		if (!tree.exists('package.json')) {
			skip('No package.json found.');
			return;
		}

		// read the package.json
		const packageJson = readJson(tree, 'package.json');

		// merge the dependencies and devDependencies
		const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };

		const dependenciesToCheck = ['@spartan-ng/brain', '@spartan-ng/cli'];

		for (const dep of dependenciesToCheck) {
			if (!dependencies[dep]) {
				failure(`The dependency ${dep} is not installed.`, HealthcheckSeverity.Error, true);
				continue;
			}

			const installedVersion = dependencies[dep];

			// check if the installed version is the latest version
			const request = await fetch(`https://registry.npmjs.org/${dep}/latest`);

			if (!request.ok) {
				failure(`Failed to fetch metadata for ${dep}.`, HealthcheckSeverity.Error, false);
				continue;
			}

			const metadata = (await request.json()) as PackageJson;

			if (!semver.satisfies(metadata.version, installedVersion)) {
				failure(
					`The installed version of ${dep} is not the latest version. The latest version is ${metadata.version}.`,
					HealthcheckSeverity.Warning,
					true,
				);
				continue;
			}
		}
	},
	fix: async (tree) => {
		const packageJson = readJson(tree, 'package.json');
		const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };
		const dependenciesToCheck = ['@spartan-ng/brain', '@spartan-ng/cli'];

		for (const dep of dependenciesToCheck) {
			if (!dependencies[dep]) {
				return false;
			}

			const request = await fetch(`https://registry.npmjs.org/${dep}/latest`);

			if (!request.ok) {
				return false;
			}

			const metadata = (await request.json()) as PackageJson;

			// update the dependency to the latest version in the respective section
			if (packageJson.dependencies[dep]) {
				packageJson.dependencies[dep] = `^${metadata.version}`;
			} else {
				packageJson.devDependencies[dep] = `^${metadata.version}`;
			}
		}

		tree.write('package.json', JSON.stringify(packageJson, null, 2));

		return true;
	},
	prompt: 'Would you like to update to the latest versions of the dependencies?',
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/healthcheck/utils/prompt.ts
```typescript
export function promptUser(question: string): Promise<boolean> {
	return new Promise((resolve) => {
		process.stdout.write(`${question} (y/n): `);

		process.stdin.setEncoding('utf8');
		process.stdin.once('data', (data) => {
			const answer = data.toString().trim().toLowerCase();
			if (['yes', 'y'].includes(answer)) {
				resolve(true);
			} else if (['no', 'n'].includes(answer)) {
				resolve(false);
			} else {
				console.log('Invalid response. Please answer with "yes" or "no".');
				resolve(promptUser(question));
			}
		});
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/healthcheck/utils/reporter.ts
```typescript
import { logger } from '@nx/devkit';
import pc from 'picocolors';
import { HealthcheckReport, HealthcheckSeverity, HealthcheckStatus } from '../healthchecks';

export function printReport(report: HealthcheckReport): void {
	logger.log(`${getStatus(report.status)} ${report.name}`);

	// if this was a failure log the instructions
	if (report.status === HealthcheckStatus.Failure) {
		for (const issue of report.issues) {
			logger.log(`\t\t ${getSeverity(issue.severity)} ${issue.details}`);
		}
	}

	// if the healthcheck was skipped, log the reason
	if (report.status === HealthcheckStatus.Skipped) {
		logger.log(`\t\t ${pc.yellow(report.reason)}`);
	}
}

function getStatus(result: HealthcheckStatus) {
	switch (result) {
		case HealthcheckStatus.Success:
			return pc.green('[  ]');
		case HealthcheckStatus.Failure:
			return pc.red('[  ]');
		case HealthcheckStatus.Skipped:
			return pc.yellow('[ ! ]');
	}
}

function getSeverity(severity: HealthcheckSeverity) {
	switch (severity) {
		case HealthcheckSeverity.Error:
			return pc.red('');
		case HealthcheckSeverity.Warning:
			return pc.yellow('!');
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/healthcheck/utils/runner.ts
```typescript
import { Tree } from '@nx/devkit';
import {
	Healthcheck,
	HealthcheckFailureFn,
	HealthcheckReport,
	HealthcheckSeverity,
	HealthcheckStatus,
	isHealthcheckFixable,
} from '../healthchecks';

export async function runHealthcheck(tree: Tree, healthcheck: Healthcheck): Promise<HealthcheckReport> {
	const report: HealthcheckReport = {
		name: healthcheck.name,
		status: HealthcheckStatus.Success,
		fixable: false,
		healthcheck,
	};

	const failure: HealthcheckFailureFn = (details: string, severity: HealthcheckSeverity, fixable: boolean) => {
		// check if this issue already exists
		if (report.issues?.some((issue) => issue.details === details)) {
			return;
		}

		report.status = HealthcheckStatus.Failure;
		report.issues ??= [];
		report.issues.push({ details, severity });
		report.fixable = report.fixable || (fixable && isHealthcheckFixable(healthcheck));
	};

	const skip = (reason: string) => {
		report.status = HealthcheckStatus.Skipped;
		report.reason = reason;
	};

	await coercePromise(healthcheck.detect(tree, failure, skip));

	return report;
}

function coercePromise<T>(value: T | Promise<T>): Promise<T> {
	return value instanceof Promise ? value : Promise.resolve(value);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/theme/compat.ts
```typescript
import { convertNxGenerator } from '@nx/devkit';
import addThemeToApplicationGenerator from './generator';

export default convertNxGenerator(addThemeToApplicationGenerator);

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/theme/generator.spec.ts
```typescript
import { applicationGenerator, E2eTestRunner, setupTailwindGenerator, UnitTestRunner } from '@nx/angular/generators';
import { readProjectConfiguration, Tree, updateJson } from '@nx/devkit';
import { createTreeWithEmptyWorkspace } from 'nx/src/devkit-testing-exports';
import { addThemeToApplicationStyles } from './libs/add-theme-to-application-styles';

jest.mock('@nx/devkit', () => {
	const original = jest.requireActual('@nx/devkit');
	return {
		...original,
		// eslint-disable-next-line @typescript-eslint/no-empty-function
		ensurePackage: () => {},
		createProjectGraphAsync: jest.fn().mockResolvedValue({
			nodes: {},
			dependencies: {},
		}),
	};
});

describe('Theme generator', () => {
	let tree: Tree;

	beforeEach(async () => {
		tree = createTreeWithEmptyWorkspace();
		await applicationGenerator(tree, {
			directory: 'website',
			e2eTestRunner: E2eTestRunner.None,
			linter: 'none',
			name: 'website',
			skipFormat: true,
			unitTestRunner: UnitTestRunner.None,
			standalone: true,
			skipTests: true,
		});
	});

	describe('Tailwind v3', () => {
		beforeEach(async () => {
			await setupTailwindGenerator(tree, {
				project: 'website',
				skipFormat: true,
			});
		});

		it('should not add the Tailwind 4 preset global stylesheet', async () => {
			const project = readProjectConfiguration(tree, 'website');

			addThemeToApplicationStyles(
				tree,
				{
					theme: 'zinc',
					project: 'website',
					radius: 2,
					addCdkStyles: true,
				},
				project,
			);

			const styles = tree.read('website/src/styles.css', 'utf8');

			expect(styles).not.toContain('@import "@spartan-ng/brain/hlm-tailwind-preset.css";');
		});
	});

	describe('Tailwind v4', () => {
		beforeEach(async () => {
			updateJson(tree, 'package.json', (json) => {
				json.devDependencies = {
					...json.devDependencies,
					tailwindcss: '^4.0.0',
				};
				return json;
			});

			tree.write('website/src/styles.css', '@import "tailwindcss";');
		});

		it('should add the Tailwind 4 preset global stylesheet', async () => {
			const project = readProjectConfiguration(tree, 'website');

			addThemeToApplicationStyles(
				tree,
				{
					theme: 'zinc',
					project: 'website',
					radius: 2,
					addCdkStyles: true,
				},
				project,
			);

			const styles = tree.read('website/src/styles.css', 'utf8');

			expect(styles).toContain('@import "@spartan-ng/brain/hlm-tailwind-preset.css";');
		});
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/theme/generator.ts
```typescript
import type { ProjectConfiguration, Tree } from '@nx/devkit';
import { prompt } from 'enquirer';
import { getProjectsAndNames } from '../../utils/get-project-names';
import { addThemeToApplicationStyles } from './libs/add-theme-to-application-styles';
import { SupportedRadii, type SupportedTheme, SupportedThemes } from './libs/supported-theme-generator-map';

export default async function addThemeToApplicationGenerator(tree: Tree) {
	const { projects, projectNames } = getProjectsAndNames(tree);

	const response: { app: string } = await prompt({
		type: 'select',
		required: true,
		name: 'app',
		message: 'Choose which application you want to add the theme to:',
		choices: projectNames,
	});
	const project: ProjectConfiguration | undefined = projects.get(response.app);

	if (!project) return;

	const themeOptions: {
		theme: SupportedTheme;
		radius: string;
		addCdkStyles: boolean;
		stylesEntryPoint?: string;
		prefix?: string;
	} = await prompt([
		{
			type: 'select',
			required: true,
			name: 'theme',
			message:
				'Choose which theme to apply. You can always re-run this generator and add a custom prefix to add other themes.',
			choices: SupportedThemes,
		},
		{
			type: 'select',
			required: true,
			name: 'radius',
			initial: 2,
			message: 'Which corner radius do you want to use with your theme:',
			choices: [...SupportedRadii],
		},
		{
			type: 'input',
			name: 'stylesEntryPoint',
			message:
				"Path to the styles entry point relative to the workspace root. If not provided the generator will do its best to find it and it will error if it can't.",
		},
		{
			type: 'input',
			name: 'prefix',
			message:
				"Prefix class name applied to your theme's style definitions: e.g., theme-rose, theme-zinc. Leave empty for global theme.",
		},
	]);

	addThemeToApplicationStyles(
		tree,
		{
			project: project.name,
			radius: Number.parseFloat(themeOptions.radius),
			theme: themeOptions.theme,
			addCdkStyles: themeOptions.addCdkStyles,
			stylesEntryPoint: themeOptions.stylesEntryPoint,
			prefix: themeOptions.prefix,
		},
		project,
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/theme/schema.json
```json
{
	"$schema": "http://json-schema.org/draft-07/schema",
	"$id": "HlmThemeGeneratorSchema",
	"title": "",
	"type": "object",
	"properties": {}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/theme/libs/add-theme-to-application-styles.ts
```typescript
// All credit goes to the incredible folks at Nx who use this code to update the app styles when adding tailwind
// Check out the code here: https://github.com/nrwl/nx/blob/master/packages/angular/src/generators/setup-tailwind/lib/update-application-styles.ts

import { type ProjectConfiguration, type Tree, joinPathFragments, readJson, stripIndents } from '@nx/devkit';
import { type PackageJson } from 'nx/src/utils/package-json';
import * as semver from 'semver';
import { type SupportedTheme, SupportedThemeGeneratorMap } from './supported-theme-generator-map';

export interface AddThemeToApplicationStylesOptions {
	project: string;
	theme: SupportedTheme;
	radius: number;
	addCdkStyles: boolean;
	stylesEntryPoint?: string;
	prefix?: string;
}

export function addThemeToApplicationStyles(
	tree: Tree,
	options: AddThemeToApplicationStylesOptions,
	project: ProjectConfiguration,
): void {
	const packageJson = readJson<PackageJson>(tree, 'package.json');

	let tailwindVersion = 3;

	if ('tailwindcss' in packageJson.devDependencies) {
		const version = packageJson.devDependencies['tailwindcss'];
		tailwindVersion = semver.coerce(version)?.major ?? 3;
	}

	const tailwindImport = tailwindVersion === 4 ? '@import "@spartan-ng/brain/hlm-tailwind-preset.css";' : '';

	const prefix = options.prefix ? ` .${options.prefix}` : '';
	let stylesEntryPoint = options.stylesEntryPoint;

	if (stylesEntryPoint && !tree.exists(stylesEntryPoint)) {
		throw new Error(`The provided styles entry point "${stylesEntryPoint}" could not be found.`);
	}

	if (!stylesEntryPoint) {
		stylesEntryPoint = findStylesEntryPoint(tree, project);

		if (!stylesEntryPoint) {
			throw new Error(
				stripIndents`Could not find a styles entry point for project "${options.project}".
        Please specify a styles entry point using the "stylesEntryPoint" option.`,
			);
		}
	}

	const stylesEntryPointContent = tree.read(stylesEntryPoint, 'utf-8');

	const CDK_IMPORT = `@import '@angular/cdk/overlay-prebuilt.css';`;
	const ckdOverlayImport = stylesEntryPointContent.includes(CDK_IMPORT) ? '' : CDK_IMPORT;

	const rootFontSans = stylesEntryPointContent.includes('--font-sans')
		? ''
		: `:root {
     --font-sans: ''
     }`;

	tree.write(
		stylesEntryPoint,
		stripIndents`
    ${ckdOverlayImport}

    ${stylesEntryPointContent}
    ${tailwindImport}

    ${rootFontSans}
    ${SupportedThemeGeneratorMap[options.theme](options.radius, prefix)}

    @layer base {
      * {
        @apply border-border;
      }
    }`,
	);
}

function findStylesEntryPoint(tree: Tree, project: ProjectConfiguration): string | undefined {
	// first check for common names
	const possibleStylesEntryPoints = [
		joinPathFragments(project.sourceRoot ?? project.root, 'styles.css'),
		joinPathFragments(project.sourceRoot ?? project.root, 'styles.scss'),
		joinPathFragments(project.sourceRoot ?? project.root, 'styles.sass'),
		joinPathFragments(project.sourceRoot ?? project.root, 'styles.less'),
	];

	const stylesEntryPoint = possibleStylesEntryPoints.find((s) => tree.exists(s));
	if (stylesEntryPoint) {
		return stylesEntryPoint;
	}

	// then check for the specified styles in the build configuration if it exists
	const styles: Array<string | { input: string; inject: boolean }> = project.targets?.build.options?.styles;

	if (!styles) {
		return undefined;
	}

	// find the first style that belongs to the project source
	const style = styles.find((s) =>
		typeof s === 'string'
			? s.startsWith(project.root) && tree.exists(s)
			: s.input.startsWith(project.root) && s.inject !== false && tree.exists(s.input),
	);

	if (!style) {
		return undefined;
	}

	return typeof style === 'string' ? style : style.input;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/theme/libs/supported-theme-generator-map.ts
```typescript
export const SupportedThemeGeneratorMap = {
	zinc: (radius: number, prefix = '') => `
:root${prefix} {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    --popover: 0 0% 100%;;
    --popover-foreground: 240 10% 3.9%;
    --primary: 240 5.9% 10%;
    --primary-foreground: 0 0% 98%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 240 5.9% 10%;
    --radius: ${radius}rem;
    color-scheme: light;
  }

  .dark${prefix} {
    --background: 240 10% 3.9%;
    --foreground: 0 0% 98%;
    --card: 240 10% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 240 10% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 240 5.9% 10%;
    --secondary: 240 3.7% 15.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 240 3.7% 15.9%;
    --muted-foreground: 240 5% 64.9%;
    --accent: 240 3.7% 15.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 240 4.9% 83.9%;
    color-scheme: dark;
  }
`,
	slate: (radius: number, prefix = '') => `
:root${prefix} {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --ring: 222.2 84% 4.9%;
    --radius: ${radius}rem;
    color-scheme: light;
  }

  .dark${prefix} {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --ring: 212.7 26.8% 83.9;
    color-scheme: dark;
  }
`,
	stone: (radius: number, prefix = '') => `
:root${prefix} {
   --background: 0 0% 100%;
    --foreground: 20 14.3% 4.1%;
    --muted: 60 4.8% 95.9%;
    --muted-foreground: 25 5.3% 44.7%;
    --popover: 0 0% 100%;
    --popover-foreground: 20 14.3% 4.1%;
    --card: 0 0% 100%;
    --card-foreground: 20 14.3% 4.1%;
    --border: 20 5.9% 90%;
    --input: 20 5.9% 90%;
    --primary: 24 9.8% 10%;
    --primary-foreground: 60 9.1% 97.8%;
    --secondary: 60 4.8% 95.9%;
    --secondary-foreground: 24 9.8% 10%;
    --accent: 60 4.8% 95.9%;
    --accent-foreground: 24 9.8% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 60 9.1% 97.8%;
    --ring: 20 14.3% 4.1%;
    --radius: ${radius}rem;
    color-scheme: light;
  }

  .dark${prefix} {
    --background: 20 14.3% 4.1%;
    --foreground: 60 9.1% 97.8%;
    --muted: 12 6.5% 15.1%;
    --muted-foreground: 24 5.4% 63.9%;
    --popover: 20 14.3% 4.1%;
    --popover-foreground: 60 9.1% 97.8%;
    --card: 20 14.3% 4.1%;
    --card-foreground: 60 9.1% 97.8%;
    --border: 12 6.5% 15.1%;
    --input: 12 6.5% 15.1%;
    --primary: 60 9.1% 97.8%;
    --primary-foreground: 24 9.8% 10%;
    --secondary: 12 6.5% 15.1%;
    --secondary-foreground: 60 9.1% 97.8%;
    --accent: 12 6.5% 15.1%;
    --accent-foreground: 60 9.1% 97.8%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 60 9.1% 97.8%;
    --ring: 24 5.7% 82.9%;
    color-scheme: dark;
  }
`,
	gray: (radius: number, prefix = '') => `
:root${prefix} {
    --background: 0 0% 100%;
    --foreground: 224 71.4% 4.1%;
    --muted: 220 14.3% 95.9%;
    --muted-foreground: 220 8.9% 46.1%;
    --popover: 0 0% 100%;
    --popover-foreground: 224 71.4% 4.1%;
    --card: 0 0% 100%;
    --card-foreground: 224 71.4% 4.1%;
    --border: 220 13% 91%;
    --input: 220 13% 91%;
    --primary: 220.9 39.3% 11%;
    --primary-foreground: 210 20% 98%;
    --secondary: 220 14.3% 95.9%;
    --secondary-foreground: 220.9 39.3% 11%;
    --accent: 220 14.3% 95.9%;
    --accent-foreground: 220.9 39.3% 11%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 20% 98%;
    --ring: 224 71.4% 4.1%;
    --radius: ${radius}rem;
    color-scheme: light;
  }

  .dark${prefix} {
    --background: 224 71.4% 4.1%;
    --foreground: 210 20% 98%;
    --muted: 215 27.9% 16.9%;
    --muted-foreground: 217.9 10.6% 64.9%;
    --popover: 224 71.4% 4.1%;
    --popover-foreground: 210 20% 98%;
    --card: 224 71.4% 4.1%;
    --card-foreground: 210 20% 98%;
    --border: 215 27.9% 16.9%;
    --input: 215 27.9% 16.9%;
    --primary: 210 20% 98%;
    --primary-foreground: 220.9 39.3% 11%;
    --secondary: 215 27.9% 16.9%;
    --secondary-foreground: 210 20% 98%;
    --accent: 215 27.9% 16.9%;
    --accent-foreground: 210 20% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 20% 98%;
    --ring: 216 12.2% 83.9%;
    color-scheme: dark;
  }
`,
	neutral: (radius: number, prefix = '') => `
:root${prefix} {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --ring: 0 0% 3.9%;
    --radius: ${radius}rem;
    color-scheme: light;
  }

  .dark${prefix} {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --ring: 0 0% 83.1%;
    color-scheme: dark;
  }
`,
	red: (radius: number, prefix = '') => `
:root${prefix} {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --primary: 0 72.2% 50.6%;
    --primary-foreground: 0 85.7% 97.3%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --ring: 0 72.2% 50.6%;
    --radius: ${radius}rem;
    color-scheme: light;
  }

  .dark${prefix} {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --primary: 0 72.2% 50.6%;
    --primary-foreground: 0 85.7% 97.3%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --ring: 0 72.2% 50.6%;
    color-scheme: dark;
  }
`,
	rose: (radius: number, prefix = '') => `
:root${prefix} {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
    --primary: 346.8 77.2% 49.8%;
    --primary-foreground: 355.7 100% 97.3%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 346.8 77.2% 49.8%;
    --radius: ${radius}rem;
    color-scheme: light;
  }

  .dark${prefix} {
    --background: 20 14.3% 4.1%;
    --foreground: 0 0% 95%;
    --card: 24 9.8% 10%;
    --card-foreground: 0 0% 95%;
    --popover: 0 0% 9%;
    --popover-foreground: 0 0% 95%;
    --primary: 346.8 77.2% 49.8%;
    --primary-foreground: 355.7 100% 97.3%;
    --secondary: 240 3.7% 15.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 15%;
    --muted-foreground: 240 5% 64.9%;
    --accent: 12 6.5% 15.1%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 85.7% 97.3%;
    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 346.8 77.2% 49.8%;
    color-scheme: dark;
  }
`,
	blue: (radius: number, prefix = '') => `
:root${prefix} {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
    --primary: 346.8 77.2% 49.8%;
    --primary-foreground: 355.7 100% 97.3%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 346.8 77.2% 49.8%;
    --radius: ${radius}rem;
    color-scheme: light;
  }

  .dark${prefix} {
    --background: 20 14.3% 4.1%;
    --foreground: 0 0% 95%;
    --card: 24 9.8% 10%;
    --card-foreground: 0 0% 95%;
    --popover: 0 0% 9%;
    --popover-foreground: 0 0% 95%;
    --primary: 346.8 77.2% 49.8%;
    --primary-foreground: 355.7 100% 97.3%;
    --secondary: 240 3.7% 15.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 15%;
    --muted-foreground: 240 5% 64.9%;
    --accent: 12 6.5% 15.1%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 85.7% 97.3%;
    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 346.8 77.2% 49.8%;
    color-scheme: dark;
  }
`,
	green: (radius: number, prefix = '') => `
:root${prefix} {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
    --primary: 142.1 76.2% 36.3%;
    --primary-foreground: 355.7 100% 97.3%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 142.1 76.2% 36.3%;
    --radius: ${radius}rem;
    color-scheme: light;
  }

  .dark${prefix} {
    --background: 20 14.3% 4.1%;
    --foreground: 0 0% 95%;
    --card: 24 9.8% 10%;
    --card-foreground: 0 0% 95%;
    --popover: 0 0% 9%;
    --popover-foreground: 0 0% 95%;
    --primary: 142.1 70.6% 45.3%;
    --primary-foreground: 144.9 80.4% 10%;
    --secondary: 240 3.7% 15.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 15%;
    --muted-foreground: 240 5% 64.9%;
    --accent: 12 6.5% 15.1%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 85.7% 97.3%;
    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 142.4 71.8% 29.2%;
    color-scheme: dark;
  }
`,
	orange: (radius: number, prefix = '') => `
:root${prefix} {
    --background: 0 0% 100%;
    --foreground: 20 14.3% 4.1%;
    --card: 0 0% 100%;
    --card-foreground: 20 14.3% 4.1%;
    --popover: 0 0% 100%;
    --popover-foreground: 20 14.3% 4.1%;
    --primary: 24.6 95% 53.1%;
    --primary-foreground: 60 9.1% 97.8%;
    --secondary: 60 4.8% 95.9%;
    --secondary-foreground: 24 9.8% 10%;
    --muted: 60 4.8% 95.9%;
    --muted-foreground: 25 5.3% 44.7%;
    --accent: 60 4.8% 95.9%;
    --accent-foreground: 24 9.8% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 60 9.1% 97.8%;
    --border: 20 5.9% 90%;
    --input: 20 5.9% 90%;
    --ring: 24.6 95% 53.1%;
    --radius: ${radius}rem;
    color-scheme: light;
  }

  .dark${prefix} {
    --background: 20 14.3% 4.1%;
    --foreground: 60 9.1% 97.8%;
    --card: 20 14.3% 4.1%;
    --card-foreground: 60 9.1% 97.8%;
    --popover: 20 14.3% 4.1%;
    --popover-foreground: 60 9.1% 97.8%;
    --primary: 20.5 90.2% 48.2%;
    --primary-foreground: 60 9.1% 97.8%;
    --secondary: 12 6.5% 15.1%;
    --secondary-foreground: 60 9.1% 97.8%;
    --muted: 12 6.5% 15.1%;
    --muted-foreground: 24 5.4% 63.9%;
    --accent: 12 6.5% 15.1%;
    --accent-foreground: 60 9.1% 97.8%;
    --destructive: 0 72.2% 50.6%;
    --destructive-foreground: 60 9.1% 97.8%;
    --border: 12 6.5% 15.1%;
    --input: 12 6.5% 15.1%;
    --ring: 20.5 90.2% 48.2%;
    color-scheme: dark;
  }
`,
	yellow: (radius: number, prefix = '') => `
:root${prefix} {
    --background: 0 0% 100%;
    --foreground: 20 14.3% 4.1%;
    --muted: 60 4.8% 95.9%;
    --muted-foreground: 25 5.3% 44.7%;
    --popover: 0 0% 100%;
    --popover-foreground: 20 14.3% 4.1%;
    --card: 0 0% 100%;
    --card-foreground: 20 14.3% 4.1%;
    --border: 20 5.9% 90%;
    --input: 20 5.9% 90%;
    --primary: 47.9 95.8% 53.1%;
    --primary-foreground: 26 83.3% 14.1%;
    --secondary: 60 4.8% 95.9%;
    --secondary-foreground: 24 9.8% 10%;
    --accent: 60 4.8% 95.9%;
    --accent-foreground: 24 9.8% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 60 9.1% 97.8%;
    --ring: 20 14.3% 4.1%;
    --radius: ${radius}rem;
    color-scheme: light;
  }

  .dark${prefix} {
    --background: 20 14.3% 4.1%;
    --foreground: 60 9.1% 97.8%;
    --muted: 12 6.5% 15.1%;
    --muted-foreground: 24 5.4% 63.9%;
    --popover: 20 14.3% 4.1%;
    --popover-foreground: 60 9.1% 97.8%;
    --card: 20 14.3% 4.1%;
    --card-foreground: 60 9.1% 97.8%;
    --border: 12 6.5% 15.1%;
    --input: 12 6.5% 15.1%;
    --primary: 47.9 95.8% 53.1%;
    --primary-foreground: 26 83.3% 14.1%;
    --secondary: 12 6.5% 15.1%;
    --secondary-foreground: 60 9.1% 97.8%;
    --accent: 12 6.5% 15.1%;
    --accent-foreground: 60 9.1% 97.8%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 60 9.1% 97.8%;
    --ring: 35.5 91.7% 32.9%;
    color-scheme: dark;
  }
`,
	violet: (radius: number, prefix = '') => `
:root${prefix} {
    --background: 0 0% 100%;
    --foreground: 224 71.4% 4.1%;
    --muted: 220 14.3% 95.9%;
    --muted-foreground: 220 8.9% 46.1%;
    --popover: 0 0% 100%;
    --popover-foreground: 224 71.4% 4.1%;
    --card: 0 0% 100%;
    --card-foreground: 224 71.4% 4.1%;
    --border: 220 13% 91%;
    --input: 220 13% 91%;
    --primary: 262.1 83.3% 57.8%;
    --primary-foreground: 210 20% 98%;
    --secondary: 220 14.3% 95.9%;
    --secondary-foreground: 220.9 39.3% 11%;
    --accent: 220 14.3% 95.9%;
    --accent-foreground: 220.9 39.3% 11%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 20% 98%;
    --ring: 262.1 83.3% 57.8%;
    --radius: ${radius}rem;
    color-scheme: light;
  }

  .dark${prefix} {
    --background: 224 71.4% 4.1%;
    --foreground: 210 20% 98%;
    --muted: 215 27.9% 16.9%;
    --muted-foreground: 217.9 10.6% 64.9%;
    --popover: 224 71.4% 4.1%;
    --popover-foreground: 210 20% 98%;
    --card: 224 71.4% 4.1%;
    --card-foreground: 210 20% 98%;
    --border: 215 27.9% 16.9%;
    --input: 215 27.9% 16.9%;
    --primary: 263.4 70% 50.4%;
    --primary-foreground: 210 20% 98%;
    --secondary: 215 27.9% 16.9%;
    --secondary-foreground: 210 20% 98%;
    --accent: 215 27.9% 16.9%;
    --accent-foreground: 210 20% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 20% 98%;
    --ring: 263.4 70% 50.4%;
    color-scheme: dark;
  }
`,
};

export const SupportedThemes = Object.keys(SupportedThemeGeneratorMap);

export type SupportedTheme = keyof typeof SupportedThemeGeneratorMap;

export const SupportedRadii = ['0', '0.3', '0.5', '0.75', '1.0'] as const;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-helm-libraries/compat.ts
```typescript
import { convertNxGenerator } from '@nx/devkit';
import migrateHelmLibrariesGenerator from './generator';
import { MigrateHelmLibrariesGeneratorSchema } from './schema';

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export default convertNxGenerator((tree: any, schema: MigrateHelmLibrariesGeneratorSchema & { angularCli?: boolean }) =>
	migrateHelmLibrariesGenerator(tree, { ...schema, angularCli: true }),
);

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-helm-libraries/generator.ts
```typescript
import { formatFiles, logger, Tree, updateJson } from '@nx/devkit';
import { getRootTsConfigPathInTree } from '@nx/js';
import { removeGenerator } from '@nx/workspace';
import { prompt } from 'enquirer';
import { dirname, join } from 'path';
import { getOrCreateConfig } from '../../utils/config';
import { readTsConfigPathsFromTree } from '../../utils/tsconfig';
import { createPrimitiveLibraries } from '../ui/generator';
import { MigrateHelmLibrariesGeneratorSchema } from './schema';

export async function migrateHelmLibrariesGenerator(tree: Tree, options: MigrateHelmLibrariesGeneratorSchema) {
	// Detect the libraries that are already installed
	const existingLibraries = await detectLibraries(tree);

	if (existingLibraries.length === 0) {
		logger.info('No libraries to migrate');
		return;
	}

	// if we are running in Jest we can't use the enquirer prompt
	if (process.env.JEST_WORKER_ID) {
		return;
	}

	// allow the user to select which libraries to migrate
	const selectedLibraries = await prompt({
		type: 'multiselect',
		name: 'libraries',
		message: 'The following libraries are installed. Select the ones you want to replace with the latest version:',
		choices: ['all', ...existingLibraries],
	});

	// prompt the user to confirm their actions as this will overwrite the existing libraries and remove any customizations
	const confirmation = (await prompt({
		type: 'confirm',
		name: 'confirm',
		message:
			'Are you sure you want to update the selected libraries? This will overwrite the existing libraries and remove any customizations.',
	})) as { confirm: boolean };

	if (!confirmation.confirm) {
		logger.info('Aborting migration.');
		return;
	}

	let { libraries } = selectedLibraries as { libraries: string[] };

	if (libraries.length === 0) {
		logger.info('No libraries will be updated.');
		return;
	}

	// if the user selected all libraries then we will update all libraries
	if (libraries.includes('all')) {
		libraries = existingLibraries;
	}

	await removeExistingLibraries(tree, options, libraries);
	await regenerateLibraries(tree, options, libraries);

	await formatFiles(tree);
}

export default migrateHelmLibrariesGenerator;

async function detectLibraries(tree: Tree) {
	const supportedLibraries = (await import('../ui/supported-ui-libraries.json').then(
		(m) => m.default,
	)) as SupportedLibraries;
	const tsconfigPaths = readTsConfigPathsFromTree(tree);

	// store the list of libraries in the tsconfig
	const existingLibraries: string[] = [];

	for (const libraryName in supportedLibraries) {
		const library = supportedLibraries[libraryName];
		if (tsconfigPaths[`@spartan-ng/${library.internalName}`]) {
			existingLibraries.push(libraryName);
		}
	}

	return existingLibraries;
}

async function removeExistingLibraries(tree: Tree, options: MigrateHelmLibrariesGeneratorSchema, libraries: string[]) {
	const tsconfigPaths = readTsConfigPathsFromTree(tree);

	for (const library of libraries) {
		// get the tsconfig path for the library
		const tsconfigPath = tsconfigPaths[`@spartan-ng/ui-${library}-helm`];

		if (!tsconfigPath) {
			throw new Error(`Could not find tsconfig path for library ${library}`);
		}

		// if there is more than one path then we assume we should use the first one
		const path = tsconfigPath[0];

		// if we are in the Nx CLI we can use the nx generator to remove a library
		if (!options.angularCli) {
			await removeGenerator(tree, {
				projectName: `ui-${library}-helm`,
				forceRemove: true,
				skipFormat: true,
				importPath: `@spartan-ng/ui-${library}-helm`,
			});
		} else {
			// get the directory of the path e.g. ./libs/ui/ui-aspectratio-helm/src/index.ts
			// we want to remove the directory ./libs/ui/ui-aspectratio-helm so we need to remove the last part of the path
			// and the src directory
			const directory = dirname(path).replace(/\/src$/, '');

			// recursively remove all files in the directory
			deleteFiles(tree, directory);

			// remove the path from the tsconfig
			updateJson(tree, getRootTsConfigPathInTree(tree), (json) => {
				delete json.compilerOptions.paths[`@spartan-ng/ui-${library}-helm`];
				return json;
			});
		}
	}
}

async function regenerateLibraries(tree: Tree, options: MigrateHelmLibrariesGeneratorSchema, libraries: string[]) {
	const supportedLibraries = (await import('../ui/supported-ui-libraries.json').then(
		(m) => m.default,
	)) as SupportedLibraries;
	const config = await getOrCreateConfig(tree);

	await createPrimitiveLibraries(
		{
			primitives: libraries,
		},
		Object.keys(supportedLibraries),
		supportedLibraries,
		tree,
		{ ...options, installPeerDependencies: true },
		config,
	);
}

function deleteFiles(tree: Tree, path: string) {
	if (tree.isFile(path)) {
		tree.delete(path);
		return;
	}

	const files = tree.children(path);

	for (const file of files) {
		deleteFiles(tree, join(path, file));
	}
}

type SupportedLibraries = Record<string, SupportedLibrary>;

interface SupportedLibrary {
	internalName: string;
	peerDependencies: Record<string, string>;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-helm-libraries/schema.d.ts
```typescript
export interface MigrateHelmLibrariesGeneratorSchema {
	directory?: string;
	rootProject?: boolean;
	tags?: string;
	angularCli?: boolean;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-helm-libraries/schema.json
```json
{
	"$schema": "https://json-schema.org/schema",
	"$id": "MigrateHelmLibraries",
	"title": "",
	"type": "object",
	"properties": {
		"directory": {
			"type": "string",
			"description": "A directory where the libraries are placed. If not specified, the default directory will be used."
		},
		"tags": {
			"type": "string",
			"description": "Add tags to the library (used for linting)."
		}
	},
	"required": []
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-scroll-area/compat.ts
```typescript
import { convertNxGenerator } from '@nx/devkit';
import { migrateScrollAreaGenerator } from './generator';

export default convertNxGenerator(migrateScrollAreaGenerator);

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-scroll-area/generator.spec.ts
```typescript
import { applicationGenerator, E2eTestRunner, UnitTestRunner } from '@nx/angular/generators';
import { Tree } from '@nx/devkit';
import { createTreeWithEmptyWorkspace } from '@nx/devkit/testing';
import { migrateScrollAreaGenerator } from './generator';

// patch some imports to avoid running the actual code
jest.mock('enquirer');
jest.mock('@nx/devkit', () => {
	const original = jest.requireActual('@nx/devkit');
	return {
		...original,
		ensurePackage: (pkg: string) => jest.requireActual(pkg),
		createProjectGraphAsync: jest.fn().mockResolvedValue({
			nodes: {},
			dependencies: {},
		}),
	};
});

describe('migrate-scroll-area generator', () => {
	let tree: Tree;

	beforeEach(async () => {
		tree = createTreeWithEmptyWorkspace();

		await applicationGenerator(tree, {
			name: 'app',
			directory: 'app',
			skipFormat: true,
			e2eTestRunner: E2eTestRunner.None,
			unitTestRunner: UnitTestRunner.None,
			skipPackageJson: true,
			skipTests: true,
		});
	});

	it('should add NgScrollbarImport (NgModule)', async () => {
		tree.write(
			'app/src/app/app.module.ts',
			`
			import { NgModule } from '@angular/core';
			import { BrowserModule } from '@angular/platform-browser';
			import { HlmScrollAreaModule } from '@spartan-ng/hlm-scroll-area';

			@NgModule({
				imports: [BrowserModule, HlmScrollAreaModule],
			})
			export class AppModule {}

			`,
		);

		await migrateScrollAreaGenerator(tree, { skipFormat: true });

		const content = tree.read('app/src/app/app.module.ts', 'utf-8');
		expect(content).toContain(`import { NgScrollbarModule } from 'ngx-scrollbar';`);
		expect(content).toContain(`imports: [BrowserModule, NgScrollbarModule, HlmScrollAreaModule],`);
	});

	it('should replace HlmScrollAreaComponent (NgModule)', async () => {
		tree.write(
			'app/src/app/app.module.ts',
			`
			import { NgModule } from '@angular/core';
			import { BrowserModule } from '@angular/platform-browser';
			import { HlmScrollAreaComponent } from '@spartan-ng/hlm-scroll-area';

			@NgModule({
				imports: [BrowserModule, HlmScrollAreaComponent],
			})
			export class AppModule {}

			`,
		);

		await migrateScrollAreaGenerator(tree, { skipFormat: true });

		const content = tree.read('app/src/app/app.module.ts', 'utf-8');
		expect(content).toContain(`import { NgScrollbarModule } from 'ngx-scrollbar';`);
		expect(content).toContain(`imports: [BrowserModule, NgScrollbarModule, HlmScrollAreaDirective],`);
	});

	it('should add NgScrollbarImport (Standalone)', async () => {
		tree.write(
			'app/src/app/app.component.ts',
			`
			import { Component } from '@angular/core';
			import { HlmScrollAreaModule } from '@spartan-ng/hlm-scroll-area';

			@Component({
				imports: [HlmScrollAreaModule],
				template: \`
					<hlm-scroll-area class="w-48 border h-72 rounded-md border-border">Content</hlm-scroll-area>
				\`
			})
			export class AppModule {}

			`,
		);

		await migrateScrollAreaGenerator(tree, { skipFormat: true });

		const content = tree.read('app/src/app/app.component.ts', 'utf-8');
		expect(content).toContain(`import { NgScrollbarModule } from 'ngx-scrollbar';`);
		expect(content).toContain(`imports: [NgScrollbarModule, HlmScrollAreaModule],`);
		expect(content).toContain(
			`<ng-scrollbar hlm class="w-48 border h-72 rounded-md border-border">Content</ng-scrollbar>`,
		);
	});

	it('should replace HlmScrollAreaComponent (Standalone)', async () => {
		tree.write(
			'app/src/app/app.component.ts',
			`
			import { Component } from '@angular/core';
			import { HlmScrollAreaComponent } from '@spartan-ng/hlm-scroll-area';

			@Component({
				imports: [HlmScrollAreaComponent],
				template: \`
					<hlm-scroll-area class="w-48 border h-72 rounded-md border-border">Content</hlm-scroll-area>
				\`
			})
			export class AppModule {}

			`,
		);

		await migrateScrollAreaGenerator(tree, { skipFormat: true });

		const content = tree.read('app/src/app/app.component.ts', 'utf-8');
		expect(content).toContain(`import { NgScrollbarModule } from 'ngx-scrollbar';`);
		expect(content).toContain(`import { HlmScrollAreaDirective } from '@spartan-ng/hlm-scroll-area';`);
		expect(content).toContain(`imports: [NgScrollbarModule, HlmScrollAreaDirective],`);
		expect(content).toContain(
			`<ng-scrollbar hlm class="w-48 border h-72 rounded-md border-border">Content</ng-scrollbar>`,
		);
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-scroll-area/generator.ts
```typescript
import { formatFiles, Tree, visitNotIgnoredFiles } from '@nx/devkit';
import { applyChangesToString, ChangeType, StringChange } from '@nx/devkit/src/utils/string-change';
import { isImported } from '@schematics/angular/utility/ast-utils';
import ts from 'typescript';
import { MigrateScrollAreaGeneratorSchema } from './schema';

export async function migrateScrollAreaGenerator(tree: Tree, { skipFormat }: MigrateScrollAreaGeneratorSchema) {
	replaceImports(tree);
	replaceSelector(tree);

	if (!skipFormat) {
		await formatFiles(tree);
	}
}

function replaceSelector(tree: Tree) {
	// if the element is `<hlm-scroll-area` then we need to replace it with `<ng-scrollbar hlm`
	// we also need to replace the closing tag `</hlm-scroll-area>` with `</ng-scrollbar>`
	visitNotIgnoredFiles(tree, '.', (path) => {
		// if this is not an html file or typescript file (inline templates) then skip
		if (!path.endsWith('.html') && !path.endsWith('.ts')) {
			return;
		}

		let content = tree.read(path, 'utf-8');

		if (!content) {
			return;
		}

		content = content.replace(/<hlm-scroll-area/g, '<ng-scrollbar hlm');
		content = content.replace(/<\/hlm-scroll-area>/g, '</ng-scrollbar>');

		tree.write(path, content);
	});
}

function replaceImports(tree: Tree) {
	// ng modules or standalone components will have import arrays that may need updated.
	// if the import is `HlmScrollAreaModule` then we need to also import `NgScrollbarModule`,
	// if the import is `HlmScrollAreaComponent` we need to rename it to `HlmScrollAreaDirective` and add the `NgScrollbarModule` import.
	visitNotIgnoredFiles(tree, '.', (path) => {
		// if the file is not a typescript file then skip
		if (!path.endsWith('.ts')) {
			return;
		}

		let content = tree.read(path, 'utf-8');

		if (!content) {
			return;
		}

		// convert the content to an ast
		const sourceFile = ts.createSourceFile(path, content, ts.ScriptTarget.Latest, true);

		// find all imports of HlmScrollAreaModule or HlmScrollAreaComponent
		const imports = findHlmScrollAreaImports(sourceFile);

		// if no imports are found then skip
		if (imports.length === 0) {
			return;
		}

		const changes: StringChange[] = [];

		for (const identifier of imports) {
			// if the identifier is HlmScrollAreaModule then we need to add NgScrollbarModule to the imports
			if (identifier.getText() === 'HlmScrollAreaModule') {
				changes.push({
					type: ChangeType.Insert,
					index: identifier.getStart(),
					text: 'NgScrollbarModule, ',
				});
			}

			// if the identifier is HlmScrollAreaComponent then we need to rename it to HlmScrollAreaDirective and add NgScrollbarModule to the imports
			if (identifier.getText() === 'HlmScrollAreaComponent') {
				changes.push({
					type: ChangeType.Insert,
					index: identifier.getStart(),
					text: 'NgScrollbarModule, ',
				});
			}

			// check if the NgScrollbarModule import is already present
			if (!hasImport(content, 'NgScrollbarModule', 'ngx-scrollbar')) {
				changes.push({
					type: ChangeType.Insert,
					index: 0,
					text: `import { NgScrollbarModule } from 'ngx-scrollbar';\n`,
				});
			}
		}

		content = applyChangesToString(content, changes);

		// if there are any remaining uses of HlmScrollAreaComponent then replace them with HlmScrollAreaDirective
		content = content.replace(/HlmScrollAreaComponent/g, 'HlmScrollAreaDirective');

		tree.write(path, content);
	});
}

function findHlmScrollAreaImports(node: ts.SourceFile): ts.Node[] {
	const matches: ts.Identifier[] = [];

	const visit = (node: ts.Node) => {
		if (
			ts.isPropertyAssignment(node) &&
			node.name.getText() === 'imports' &&
			ts.isArrayLiteralExpression(node.initializer)
		) {
			// check if the array literal contains the HlmScrollAreaModule or HlmScrollAreaComponent
			node.initializer.elements.forEach((element) => {
				if (ts.isIdentifier(element)) {
					if (element.getText() === 'HlmScrollAreaModule' || element.getText() === 'HlmScrollAreaComponent') {
						matches.push(element);
					}
				}
			});
		}

		ts.forEachChild(node, visit);
	};

	visit(node);

	return matches;
}

function hasImport(contents: string, importName: string, importPath: string): boolean {
	const sourceFile = ts.createSourceFile('temp.ts', contents, ts.ScriptTarget.Latest, true);
	return isImported(sourceFile, importName, importPath);
}

export default migrateScrollAreaGenerator;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-scroll-area/schema.d.ts
```typescript
export interface MigrateScrollAreaGeneratorSchema {
	skipFormat?: boolean;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-scroll-area/schema.json
```json
{
	"$schema": "http://json-schema.org/draft-07/schema",
	"$id": "MigrateScrollArea",
	"title": "",
	"type": "object",
	"properties": {
		"skipFormat": {
			"type": "boolean",
			"default": false,
			"description": "Skip formatting files"
		}
	},
	"required": []
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-toggle-group/compat.ts
```typescript
import { convertNxGenerator } from '@nx/devkit';
import migrateRadioGenerator from './generator';

export default convertNxGenerator(migrateRadioGenerator);

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-toggle-group/generator.spec.ts
```typescript
import { applicationGenerator, E2eTestRunner, UnitTestRunner } from '@nx/angular/generators';
import { Tree } from '@nx/devkit';
import { createTreeWithEmptyWorkspace } from '@nx/devkit/testing';
import { migrateToggleGroupGenerator } from './generator';

// patch some imports to avoid running the actual code
jest.mock('enquirer');
jest.mock('@nx/devkit', () => {
	const original = jest.requireActual('@nx/devkit');
	return {
		...original,
		ensurePackage: (pkg: string) => jest.requireActual(pkg),
		createProjectGraphAsync: jest.fn().mockResolvedValue({
			nodes: {},
			dependencies: {},
		}),
	};
});

describe('migrate-toggle-group generator', () => {
	let tree: Tree;

	beforeEach(async () => {
		tree = await createTreeWithEmptyWorkspace();

		await applicationGenerator(tree, {
			name: 'app',
			directory: 'app',
			skipFormat: true,
			e2eTestRunner: E2eTestRunner.None,
			unitTestRunner: UnitTestRunner.None,
			skipPackageJson: true,
			skipTests: true,
		});
	});

	it('should replace BrnToggleGroupModule with BrnToggleGroupModule, BrnToggleGroupItemDirective', async () => {
		tree.write(
			'app/src/app/app.component.ts',
			`
				import { Component } from '@angular/core';
				import { BrnToggleGroupModule, BrnToggleDirective } from '@spartan-ng/brain/toggle';
				import { HlmToggleDirective, HlmToggleGroupModule } from '@spartan-ng/ui-toggle-helm';

				@Component({
					imports: [BrnToggleGroupModule, HlmToggleGroupModule, HlmButtonDirective, FormsModule, NgForOf, NgIf],
					],
					template: \`
     	<div class="flex space-x-4">
				<brn-toggle-group hlm [disabled]="disabled" [nullable]="nullable" [multiple]="multiple" [(ngModel)]="selected">
				<button variant="outline" *ngFor="let city of cities; let last = last" [value]="city" hlm brnToggle>
					{{ city.name }}
				</button>
				</brn-toggle-group>
				<button hlmBtn size="sm" (click)="setToSyracuse()">Set to Syracuse</button>
				<button hlmBtn size="sm" (click)="addCity()">Add Piraeus</button>
			</div>
					\`
				})
				export class AppModule {}
				`,
		);

		await migrateToggleGroupGenerator(tree, { skipFormat: true });

		const content = tree.read('app/src/app/app.component.ts', 'utf-8');
		expect(content).not.toContain("import { BrnToggleGroupModule } from '@spartan-ng/brain/toggle'");
		expect(content).toContain(
			"import { BrnToggleGroupComponent, BrnToggleGroupItemDirective } from '@spartan-ng/brain/toggle-group'",
		);
		expect(content).toContain(
			"import { HlmToggleGroupDirective, HlmToggleGroupItemDirective } from '@spartan-ng/ui-toggle-group-helm'",
		);
		expect(content).toContain(
			'imports: [BrnToggleGroupComponent, BrnToggleGroupItemDirective, HlmToggleGroupDirective, HlmToggleGroupItemDirective, HlmButtonDirective, FormsModule, NgForOf, NgIf],',
		);
	});

	it('should replace brnToggle with hlmToggleGroupItem', async () => {
		tree.write(
			'app/src/app/app.component.ts',
			`
				import { Component } from '@angular/core';
				import { BrnToggleGroupModule } from '@spartan-ng/brain/toggle';
				import { HlmButtonDirective, FormsModule, NgForOf, NgIf } from '@spartan-ng/ui-toggle-group-helm';
				@Component({
					imports: [BrnToggleGroupModule, HlmToggleGroupModule, HlmButtonDirective, FormsModule, NgForOf, NgIf],
					template: \`
     	<div class="flex space-x-4">
				<brn-toggle-group hlm [disabled]="disabled" [nullable]="nullable" [multiple]="multiple" [(ngModel)]="selected">
				<button variant="outline" *ngFor="let city of cities; let last = last" [value]="city" hlm brnToggle>
					{{ city.name }}
				</button>
				</brn-toggle-group>
				<button hlmBtn size="sm" (click)="setToSyracuse()">Set to Syracuse</button>
				<button hlmBtn size="sm" (click)="addCity()">Add Piraeus</button>
			</div>
					\`
				})
				export class AppModule {}
				`,
		);

		await migrateToggleGroupGenerator(tree, { skipFormat: true });

		const content = tree.read('app/src/app/app.component.ts', 'utf-8');
		expect(content).not.toContain('brnToggle');
		expect(content).toContain('hlmToggleGroupItem');
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-toggle-group/generator.ts
```typescript
import { formatFiles, Tree } from '@nx/devkit';
import { visitFiles } from '../../utils/visit-files';
import { MigrateToggleGroupGeneratorSchema } from './schema';

export async function migrateToggleGroupGenerator(tree: Tree, { skipFormat }: MigrateToggleGroupGeneratorSchema) {
	updateBrainImports(tree);
	updateHlmImports(tree);
	replaceSelector(tree);

	if (!skipFormat) {
		await formatFiles(tree);
	}
}

/**
 * Update brain imports to migrate from toggle to toggle-group
 */
function updateBrainImports(tree: Tree) {
	visitFiles(tree, '/', (path) => {
		// Filter for TypeScript files that might contain the imports we're interested in
		if (!path.endsWith('.ts')) return;

		let content = tree.read(path)?.toString();
		if (!content) return;

		// Only proceed if file has BrnToggleGroupModule from toggle but not from toggle-group
		if (
			content.includes('BrnToggleGroupModule') &&
			content.includes("from '@spartan-ng/brain/toggle'") &&
			!content.includes("from '@spartan-ng/brain/toggle-group'")
		) {
			// Remove BrnToggleGroupModule from the toggle import
			content = content.replace(
				/import\s+\{\s*([^{}]*BrnToggleGroupModule[^{}]*)\s*\}\s+from\s+['"]@spartan-ng\/brain\/toggle['"];/g,
				(_match, importList) => {
					// Remove BrnToggleGroupModule from the import list
					const newImportList = importList
						.split(',')
						.map((item) => item.trim())
						.filter((item) => item !== 'BrnToggleGroupModule')
						.join(', ');

					// If there are still imports remaining, return the modified import statement
					if (newImportList.length > 0) {
						return `import { ${newImportList} } from '@spartan-ng/brain/toggle';`;
					} else {
						// If no imports remain, remove the entire import statement
						return '';
					}
				},
			);

			// Add the new toggle-group import with BrnToggleGroupComponent and BrnToggleGroupItemDirective
			const importRegex = /import\s+.*?;/g;
			let match;
			let lastImportEndIndex = 0;

			while ((match = importRegex.exec(content)) !== null) {
				lastImportEndIndex = match.index + match[0].length;
			}

			// If we found imports, add after the last one
			if (lastImportEndIndex > 0) {
				const newImport = `\nimport { BrnToggleGroupComponent, BrnToggleGroupItemDirective } from '@spartan-ng/brain/toggle-group';`;
				content = content.substring(0, lastImportEndIndex) + newImport + content.substring(lastImportEndIndex);
			} else {
				// If no imports found, add at the beginning
				const newImport = `import { BrnToggleGroupComponent, BrnToggleGroupItemDirective } from '@spartan-ng/brain/toggle-group';\n\n`;
				content = newImport + content;
			}

			// Update component imports to include BrnToggleGroupItemDirective
			content = content.replace(
				/imports:\s*\[\s*BrnToggleGroupModule\s*,/g,
				'imports: [BrnToggleGroupComponent, BrnToggleGroupItemDirective,',
			);

			// Also handle the case where BrnToggleGroupModule is the only import
			content = content.replace(
				/imports:\s*\[\s*BrnToggleGroupModule\s*\]/g,
				'imports: [BrnToggleGroupComponent, BrnToggleGroupItemDirective]',
			);

			tree.write(path, content);
		}
	});

	return tree;
}

/**
 * Update hlm imports to migrate from toggle to toggle-group
 */
function updateHlmImports(tree: Tree) {
	visitFiles(tree, '/', (path) => {
		// Filter for TypeScript files that might contain the imports we're interested in
		if (!path.endsWith('.ts')) return;

		let content = tree.read(path)?.toString();
		if (!content) return;

		// Only proceed if file has imports from ui-toggle-helm but not from ui-toggle-group-helm
		if (
			content.includes("from '@spartan-ng/ui-toggle-helm'") &&
			!content.includes("from '@spartan-ng/ui-toggle-group-helm'")
		) {
			// Replace HlmToggleDirective and HlmToggleGroupModule with the directives
			// Handle case with HlmToggleDirective
			content = content.replace(
				/import\s+\{\s*HlmToggleDirective\s*,\s*HlmToggleGroupModule\s*\}\s+from\s+['"]@spartan-ng\/ui-toggle-helm['"];/g,
				"import { HlmToggleGroupDirective, HlmToggleGroupItemDirective } from '@spartan-ng/ui-toggle-group-helm';",
			);

			// Also handle case with just HlmToggleGroupModule
			content = content.replace(
				/import\s+\{\s*HlmToggleGroupModule\s*\}\s+from\s+['"]@spartan-ng\/ui-toggle-helm['"];/g,
				"import { HlmToggleGroupDirective, HlmToggleGroupItemDirective } from '@spartan-ng/ui-toggle-group-helm';",
			);

			// Update the imports array to replace HlmToggleGroupModule with the directives
			// For the case where HlmToggleGroupModule is in the middle of other imports
			content = content.replace('HlmToggleGroupModule', 'HlmToggleGroupDirective, HlmToggleGroupItemDirective');

			tree.write(path, content);
		}
	});

	return tree;
}

/**
 * Replace brnToggle with hlmToggleGroupItem inside the brn-toggle-group
 */
function replaceSelector(_tree: Tree) {
	visitFiles(_tree, '/', (path) => {
		if (!path.endsWith('.html') && !path.endsWith('.ts')) {
			return;
		}

		let content = _tree.read(path)?.toString();

		if (!content) return;

		// if file contains @spartan-ng/ui-toggle-group-helm
		if (content.includes('@spartan-ng/ui-toggle-group-helm')) {
			content = content.replace(/brnToggle/g, 'hlmToggleGroupItem');
		}

		_tree.write(path, content);
	});

	return true;
}

export default migrateToggleGroupGenerator;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-toggle-group/schema.d.ts
```typescript
export interface MigrateToggleGroupGeneratorSchema {
	skipFormat?: boolean;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-toggle-group/schema.json
```json
{
	"$schema": "https://json-schema.org/schema",
	"$id": "MigrateRadio",
	"title": "",
	"type": "object",
	"properties": {
		"skipFormat": {
			"type": "boolean",
			"default": false,
			"description": "Skip formatting files"
		}
	},
	"required": []
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-brain-imports/compat.ts
```typescript
import { convertNxGenerator } from '@nx/devkit';
import { migrateBrainImportsGenerator } from './generator';

export default convertNxGenerator(migrateBrainImportsGenerator);

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-brain-imports/generator.ts
```typescript
import { formatFiles, Tree, visitNotIgnoredFiles } from '@nx/devkit';
import { getPackageManagerCommand, logger, readJson, updateJson } from 'nx/src/devkit-exports';
import type { PackageJson } from 'nx/src/utils/package-json';
import { basename } from 'path';
import imports from './import-map';
import { MigrateBrainImportsGeneratorSchema } from './schema';
import { isBinaryPath } from './utils/binary-extensions';

export async function migrateBrainImportsGenerator(tree: Tree, options: MigrateBrainImportsGeneratorSchema) {
	if (!options.skipInstall) {
		ensureBrainPackageIsInstalled(tree);
	}

	for (const [from, to] of Object.entries(imports)) {
		replaceBrainPackageWithSecondaryEntrypoint(tree, options, from, to as string);
	}

	if (!options.skipFormat) {
		await formatFiles(tree);
	}
}

function ensureBrainPackageIsInstalled(tree: Tree) {
	// read the root package.json
	const packageJson = readJson<PackageJson>(tree, 'package.json');

	// merge all dependencies so we easily search for the cli package
	const deps = { ...packageJson.dependencies, ...packageJson.devDependencies };

	// check if the brain package is installed
	if (deps['@spartan-ng/brain']) {
		return;
	}

	// the brain package version should be the same as the cli package
	updateJson<PackageJson>(tree, 'package.json', (packageJson) => {
		packageJson.dependencies['@spartan-ng/brain'] = deps['@spartan-ng/cli'];
		return packageJson;
	});

	const { install } = getPackageManagerCommand();

	logger.warn(
		`The @spartan-ng/brain package has been added to your dependencies. Please run '${install}' to install the package.`,
	);
}

export function replaceBrainPackageWithSecondaryEntrypoint(
	tree: Tree,
	options: MigrateBrainImportsGeneratorSchema,
	oldImport: string,
	newImport: string,
): void {
	if (!options.skipInstall) {
		removePackageInDependencies(tree, oldImport);
	}

	replaceUsages(tree, oldImport, newImport);
}

function removePackageInDependencies(tree: Tree, oldPackageName: string) {
	visitNotIgnoredFiles(tree, '.', (path) => {
		if (basename(path) !== 'package.json') {
			return;
		}

		try {
			updateJson<PackageJson>(tree, path, (packageJson) => {
				for (const deps of [
					packageJson.dependencies ?? {},
					packageJson.devDependencies ?? {},
					packageJson.peerDependencies ?? {},
					packageJson.optionalDependencies ?? {},
				]) {
					if (oldPackageName in deps) {
						delete deps[oldPackageName];
					}
				}
				return packageJson;
			});
		} catch (e) {
			console.warn(`Could not remove ${oldPackageName} in ${path}.`);
		}
	});
}

// based on https://github.com/nrwl/nx/blob/master/packages/devkit/src/utils/replace-package.ts
function replaceUsages(tree: Tree, oldPackageName: string, newPackageName: string) {
	visitNotIgnoredFiles(tree, '.', (path) => {
		if (isBinaryPath(path)) {
			return;
		}

		const ignoredFiles = [
			'yarn.lock',
			'package-lock.json',
			'pnpm-lock.yaml',
			'bun.lockb',
			'CHANGELOG.md',
			// this is relevant for this repo only - and this file is auto-generated
			'supported-ui-libraries.json',
			// we don't want to replace usages in the import map as these are used to detect the usages
			'import-map.ts',
		];
		if (ignoredFiles.includes(basename(path))) {
			return;
		}

		try {
			const contents = tree.read(path).toString();

			if (!contents.includes(oldPackageName)) {
				return;
			}

			tree.write(path, contents.replace(new RegExp(oldPackageName, 'g'), newPackageName));
		} catch {
			logger.warn(`Could not replace ${oldPackageName} with ${newPackageName} in ${path}.`);
		}
	});
}

export default migrateBrainImportsGenerator;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-brain-imports/import-map.ts
```typescript
export default {
	'@spartan-ng/ui-checkbox-brain': '@spartan-ng/brain/checkbox',
	'@spartan-ng/ui-avatar-brain': '@spartan-ng/brain/avatar',
	'@spartan-ng/ui-accordion-brain': '@spartan-ng/brain/accordion',
	'@spartan-ng/ui-label-brain': '@spartan-ng/brain/label',
	'@spartan-ng/ui-slider-brain': '@spartan-ng/brain/slider',
	'@spartan-ng/ui-alert-dialog-brain': '@spartan-ng/brain/alert-dialog',
	'@spartan-ng/ui-calendar-brain': '@spartan-ng/brain/calendar',
	'@spartan-ng/ui-collapsible-brain': '@spartan-ng/brain/collapsible',
	'@spartan-ng/ui-command-brain': '@spartan-ng/brain/command',
	'@spartan-ng/ui-dialog-brain': '@spartan-ng/brain/dialog',
	'@spartan-ng/ui-form-field-brain': '@spartan-ng/brain/form-field',
	'@spartan-ng/ui-forms-brain': '@spartan-ng/brain/forms',
	'@spartan-ng/ui-hover-card-brain': '@spartan-ng/brain/hover-card',
	'@spartan-ng/ui-menu-brain': '@spartan-ng/brain/menu',
	'@spartan-ng/ui-popover-brain': '@spartan-ng/brain/popover',
	'@spartan-ng/ui-progress-brain': '@spartan-ng/brain/progress',
	'@spartan-ng/ui-radio-group-brain': '@spartan-ng/brain/radio-group',
	'@spartan-ng/ui-select-brain': '@spartan-ng/brain/select',
	'@spartan-ng/ui-separator-brain': '@spartan-ng/brain/separator',
	'@spartan-ng/ui-sheet-brain': '@spartan-ng/brain/sheet',
	'@spartan-ng/ui-switch-brain': '@spartan-ng/brain/switch',
	'@spartan-ng/ui-table-brain': '@spartan-ng/brain/table',
	'@spartan-ng/ui-tabs-brain': '@spartan-ng/brain/tabs',
	'@spartan-ng/ui-toggle-brain': '@spartan-ng/brain/toggle',
	'@spartan-ng/ui-toggle-group-brain': '@spartan-ng/brain/toggle-group',
	'@spartan-ng/ui-tooltip-brain': '@spartan-ng/brain/tooltip',
	'@spartan-ng/ui-date-time-brain': '@spartan-ng/brain/date-time',
	'@spartan-ng/ui-date-time-luxon-brain': '@spartan-ng/brain/date-time-luxon',
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-brain-imports/schema.d.ts
```typescript
export interface MigrateBrainImportsGeneratorSchema {
	skipInstall?: boolean;
	skipFormat?: boolean;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-brain-imports/schema.json
```json
{
	"$schema": "http://json-schema.org/draft-07/schema",
	"$id": "MigrateBrainImports",
	"title": "",
	"type": "object",
	"properties": {
		"skipFormat": {
			"type": "boolean",
			"description": "Skip formatting the code after migration."
		},
		"skipInstall": {
			"type": "boolean",
			"description": "Whether to verify the brain package is installed."
		}
	},
	"required": []
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-brain-imports/utils/binary-extensions.ts
```typescript
import { extname } from 'path';

// based on https://github.com/nrwl/nx/blob/master/packages/devkit/src/utils/binary-extensions.ts
const binaryExtensions = new Set([
	'.3dm',
	'.3ds',
	'.3g2',
	'.3gp',
	'.7z',
	'.a',
	'.aac',
	'.adp',
	'.ai',
	'.aif',
	'.aiff',
	'.als',
	'.alz',
	'.ape',
	'.apk',
	'.appimage',
	'.ar',
	'.arj',
	'.asf',
	'.au',
	'.avi',
	'.bak',
	'.baml',
	'.bh',
	'.bin',
	'.bk',
	'.bmp',
	'.btif',
	'.bz2',
	'.bzip2',
	'.cab',
	'.caf',
	'.cgm',
	'.class',
	'.cmx',
	'.cpio',
	'.cr2',
	'.cur',
	'.dat',
	'.dcm',
	'.deb',
	'.dex',
	'.djvu',
	'.dll',
	'.dmg',
	'.dng',
	'.doc',
	'.docm',
	'.docx',
	'.dot',
	'.dotm',
	'.dra',
	'.DS_Store',
	'.dsk',
	'.dts',
	'.dtshd',
	'.dvb',
	'.dwg',
	'.dxf',
	'.ecelp4800',
	'.ecelp7470',
	'.ecelp9600',
	'.egg',
	'.eol',
	'.eot',
	'.epub',
	'.exe',
	'.f4v',
	'.fbs',
	'.fh',
	'.fla',
	'.flac',
	'.flatpak',
	'.fli',
	'.flv',
	'.fpx',
	'.fst',
	'.fvt',
	'.g3',
	'.gh',
	'.gif',
	'.glb',
	'.graffle',
	'.gz',
	'.gzip',
	'.h261',
	'.h263',
	'.h264',
	'.icns',
	'.ico',
	'.ief',
	'.img',
	'.ipa',
	'.iso',
	'.jar',
	'.jpeg',
	'.jpg',
	'.jpgv',
	'.jpm',
	'.jxr',
	'.key',
	'.keystore',
	'.ktx',
	'.lha',
	'.lib',
	'.lvp',
	'.lz',
	'.lzh',
	'.lzma',
	'.lzo',
	'.m3u',
	'.m4a',
	'.m4v',
	'.mar',
	'.mdi',
	'.mht',
	'.mid',
	'.midi',
	'.mj2',
	'.mka',
	'.mkv',
	'.mmr',
	'.mng',
	'.mobi',
	'.mov',
	'.movie',
	'.mp3',
	'.mp4',
	'.mp4a',
	'.mpeg',
	'.mpg',
	'.mpga',
	'.msi',
	'.mxu',
	'.nef',
	'.npx',
	'.npy',
	'.numbers',
	'.nupkg',
	'.o',
	'.odp',
	'.ods',
	'.odt',
	'.oga',
	'.ogg',
	'.ogv',
	'.otf',
	'.ott',
	'.pages',
	'.pbm',
	'.pbf',
	'.pcx',
	'.pdb',
	'.pdf',
	'.pea',
	'.pgm',
	'.pic',
	'.pkg',
	'.plist',
	'.png',
	'.pnm',
	'.pot',
	'.potm',
	'.potx',
	'.ppa',
	'.ppam',
	'.ppm',
	'.pps',
	'.ppsm',
	'.ppsx',
	'.ppt',
	'.pptm',
	'.pptx',
	'.psd',
	'.pxd',
	'.pxz',
	'.pya',
	'.pyc',
	'.pyo',
	'.pyv',
	'.qt',
	'.rar',
	'.ras',
	'.raw',
	'.resources',
	'.rgb',
	'.rip',
	'.rlc',
	'.rmf',
	'.rmvb',
	'.rpm',
	'.rtf',
	'.rz',
	'.s3m',
	'.s7z',
	'.scpt',
	'.sgi',
	'.shar',
	'.snap',
	'.sil',
	'.sketch',
	'.slk',
	'.smv',
	'.snk',
	'.so',
	'.stl',
	'.suo',
	'.sub',
	'.swf',
	'.tar',
	'.tbz',
	'.tbz2',
	'.tga',
	'.tgz',
	'.thmx',
	'.tif',
	'.tiff',
	'.tlz',
	'.ttc',
	'.ttf',
	'.txz',
	'.udf',
	'.uvh',
	'.uvi',
	'.uvm',
	'.uvp',
	'.uvs',
	'.uvu',
	'.viv',
	'.vob',
	'.war',
	'.wav',
	'.wax',
	'.wbmp',
	'.wdp',
	'.weba',
	'.webm',
	'.webp',
	'.whl',
	'.wim',
	'.wm',
	'.wma',
	'.wmv',
	'.wmx',
	'.woff',
	'.woff2',
	'.wrm',
	'.wvx',
	'.xbm',
	'.xif',
	'.xla',
	'.xlam',
	'.xls',
	'.xlsb',
	'.xlsm',
	'.xlsx',
	'.xlt',
	'.xltm',
	'.xltx',
	'.xm',
	'.xmind',
	'.xpi',
	'.xpm',
	'.xwd',
	'.xz',
	'.z',
	'.zip',
	'.zipx',
]);

export function isBinaryPath(path: string): boolean {
	return binaryExtensions.has(extname(path).toLowerCase());
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-core/compat.ts
```typescript
import { convertNxGenerator } from '@nx/devkit';
import { migrateCoreGenerator } from './generator';

export default convertNxGenerator(migrateCoreGenerator);

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-core/generator.spec.ts
```typescript
import { applicationGenerator, E2eTestRunner, UnitTestRunner } from '@nx/angular/generators';
import { Tree } from '@nx/devkit';
import { createTreeWithEmptyWorkspace } from '@nx/devkit/testing';
import { migrateCoreGenerator } from './generator';
import { MigrateCoreGeneratorSchema } from './schema';

// patch some imports to avoid running the actual code
jest.mock('enquirer');
jest.mock('@nx/devkit', () => {
	const original = jest.requireActual('@nx/devkit');
	return {
		...original,
		ensurePackage: (pkg: string) => jest.requireActual(pkg),
		createProjectGraphAsync: jest.fn().mockResolvedValue({
			nodes: {},
			dependencies: {},
		}),
	};
});

describe('migrate-core generator', () => {
	let tree: Tree;
	const options: MigrateCoreGeneratorSchema = { skipFormat: true };

	beforeEach(async () => {
		tree = createTreeWithEmptyWorkspace();

		await applicationGenerator(tree, {
			name: 'app',
			directory: 'app',
			skipFormat: true,
			e2eTestRunner: E2eTestRunner.None,
			unitTestRunner: UnitTestRunner.None,
			skipPackageJson: true,
			skipTests: true,
		});
	});

	it('should update the import statements', async () => {
		tree.write(
			'app/src/app/app.component.ts',
			`
			import { Component } from '@angular/core';
			import { hlm } from '@spartan-ng/ui-core';

			@Component({
				template: \`
				\`
			})
			export class AppComponent {}
			`,
		);

		await migrateCoreGenerator(tree, options);

		const content = tree.read('app/src/app/app.component.ts', 'utf-8');
		expect(content).toContain(`import { hlm } from '@spartan-ng/brain/core';`);
	});

	it('should update the import statements with multiple imports', async () => {
		tree.write(
			'app/src/app/app.component.ts',
			`
			import { Component } from '@angular/core';
			import { hlm, brnZoneFull, createInjectionToken, ExposesState } from '@spartan-ng/ui-core';

			@Component({
				template: \`
				\`
			})
			export class AppComponent {}
			`,
		);

		await migrateCoreGenerator(tree, options);

		const content = tree.read('app/src/app/app.component.ts', 'utf-8');
		expect(content).toContain(
			`import { hlm, brnZoneFull, createInjectionToken, ExposesState } from '@spartan-ng/brain/core';`,
		);
	});

	it('should import type only imports', async () => {
		tree.write(
			'app/src/app/app.component.ts',
			`
			import { Component } from '@angular/core';
			import type { hlm } from '@spartan-ng/ui-core';

			@Component({
				template: \`
				\`
			})
			export class AppComponent {}
			`,
		);

		await migrateCoreGenerator(tree, options);

		const content = tree.read('app/src/app/app.component.ts', 'utf-8');
		expect(content).toContain(`import type { hlm } from '@spartan-ng/brain/core';`);
	});

	it('should update default imports', async () => {
		tree.write(
			'app/src/app/app.component.ts',
			`
			import { Component } from '@angular/core';
			import hlm from '@spartan-ng/ui-core';

			@Component({
				template: \`
				\`
			})
			export class AppComponent {}
			`,
		);

		await migrateCoreGenerator(tree, options);

		const content = tree.read('app/src/app/app.component.ts', 'utf-8');
		expect(content).toContain(`import hlm from '@spartan-ng/brain/core';`);
	});

	it('should update star imports', async () => {
		tree.write(
			'app/src/app/app.component.ts',
			`
			import { Component } from '@angular/core';
			import * as hlm from '@spartan-ng/ui-core';

			@Component({
				template: \`
				\`
			})
			export class AppComponent {}
			`,
		);

		await migrateCoreGenerator(tree, options);

		const content = tree.read('app/src/app/app.component.ts', 'utf-8');
		expect(content).toContain(`import * as hlm from '@spartan-ng/brain/core';`);
	});

	it('should update exports', async () => {
		tree.write(
			'app/src/app/app.component.ts',
			`
			export { hlm } from '@spartan-ng/ui-core';
			`,
		);
		await migrateCoreGenerator(tree, options);

		const content = tree.read('app/src/app/app.component.ts', 'utf-8');
		expect(content).toContain(`export { hlm } from '@spartan-ng/brain/core';`);
	});

	it('should update star exports', async () => {
		tree.write(
			'app/src/app/app.component.ts',
			`
			export * from '@spartan-ng/ui-core';
			`,
		);
		await migrateCoreGenerator(tree, options);

		const content = tree.read('app/src/app/app.component.ts', 'utf-8');
		expect(content).toContain(`export * from '@spartan-ng/brain/core';`);
	});

	it('should update the tailwind config file', async () => {
		tree.write(
			'app/tailwind.config.js',
			`
/** @type {import('tailwindcss').Config} */
module.exports = {
	presets: [require('@spartan-ng/ui-core/hlm-tailwind-preset')],
	content: [
		'./src/**/*.{html,ts}',
	],
	theme: {
		extend: {},
	},
	plugins: [],
};
			`,
		);

		await migrateCoreGenerator(tree, options);

		const content = tree.read('app/tailwind.config.js', 'utf-8');
		expect(content).toContain(`/** @type {import('tailwindcss').Config} */
module.exports = {
	presets: [require('@spartan-ng/brain/hlm-tailwind-preset')],
	content: [
		'./src/**/*.{html,ts}',
	],
	theme: {
		extend: {},
	},
	plugins: [],
};`);
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-core/generator.ts
```typescript
import { formatFiles, Tree } from '@nx/devkit';
import { visitFiles } from '../../utils/visit-files';
import { MigrateCoreGeneratorSchema } from './schema';

export async function migrateCoreGenerator(tree: Tree, options: MigrateCoreGeneratorSchema) {
	updateImports(tree);
	updateTailwindConfig(tree);

	if (!options.skipFormat) {
		await formatFiles(tree);
	}
}

/**
 * Update imports from @spartan-ng/ui-core to @spartan-ng/brain/core
 */
function updateImports(tree: Tree) {
	visitFiles(tree, '/', (path) => {
		const content = tree.read(path).toString('utf-8');

		if (content.includes('@spartan-ng/ui-core')) {
			const updatedCode = content
				// Handle `import { ... } from '@spartan-ng/ui-core';`
				.replace(/import\s+\{[^}]*\}\s+from\s+['"]@spartan-ng\/ui-core['"];/g, (match) =>
					match.replace('@spartan-ng/ui-core', '@spartan-ng/brain/core'),
				)
				// Handle `import type { ... } from '@spartan-ng/ui-core';`
				.replace(/import\s+type\s+\{[^}]*\}\s+from\s+['"]@spartan-ng\/ui-core['"];/g, (match) =>
					match.replace('@spartan-ng/ui-core', '@spartan-ng/brain/core'),
				)
				// Handle `export { ... } from '@spartan-ng/ui-core';`
				.replace(/export\s+\{[^}]*\}\s+from\s+['"]@spartan-ng\/ui-core['"];/g, (match) =>
					match.replace('@spartan-ng/ui-core', '@spartan-ng/brain/core'),
				)
				// Handle `import * as name from '@spartan-ng/ui-core';`
				.replace(/import\s+\*\s+as\s+\w+\s+from\s+['"]@spartan-ng\/ui-core['"];/g, (match) =>
					match.replace('@spartan-ng/ui-core', '@spartan-ng/brain/core'),
				)
				// Handle `import defaultExport from '@spartan-ng/ui-core';`
				.replace(/import\s+\w+\s+from\s+['"]@spartan-ng\/ui-core['"];/g, (match) =>
					match.replace('@spartan-ng/ui-core', '@spartan-ng/brain/core'),
				)
				// Handle `export * from '@spartan-ng/ui-core';`
				.replace(/export\s+\*\s+from\s+['"]@spartan-ng\/ui-core['"];/g, (match) =>
					match.replace('@spartan-ng/ui-core', '@spartan-ng/brain/core'),
				);

			tree.write(path, updatedCode);
		}
	});
}

/**
 * Update the tailwind config file
 */
function updateTailwindConfig(tree: Tree) {
	visitFiles(tree, '/', (path) => {
		// technically the tailwind config file could be anywhere and named anything
		// but all we need to do is a simple string replace '@spartan-ng/ui-core/hlm-tailwind-preset' with '@spartan-ng/brain/hlm-tailwind-preset'
		const content = tree.read(path).toString('utf-8');

		if (content.includes('@spartan-ng/ui-core/hlm-tailwind-preset')) {
			const updatedCode = content.replace(
				/@spartan-ng\/ui-core\/hlm-tailwind-preset/g,
				'@spartan-ng/brain/hlm-tailwind-preset',
			);

			tree.write(path, updatedCode);
		}
	});
}

export default migrateCoreGenerator;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-core/schema.d.ts
```typescript
export interface MigrateCoreGeneratorSchema {
	skipFormat?: boolean;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/migrate-core/schema.json
```json
{
	"$schema": "http://json-schema.org/draft-07/schema",
	"$id": "MigrateCore",
	"title": "",
	"type": "object",
	"properties": {
		"skipFormat": {
			"type": "boolean",
			"default": false,
			"description": "Skip formatting files"
		}
	},
	"required": []
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/base/generator.ts
```typescript
import {
	type GeneratorCallback,
	type Tree,
	addDependenciesToPackageJson,
	generateFiles,
	joinPathFragments,
	runTasksInSerial,
} from '@nx/devkit';
import { addTsConfigPath } from '@nx/js';
import * as path from 'node:path';
import { readTsConfigPathsFromTree } from '../../utils/tsconfig';
import { getInstalledPackageVersion } from '../../utils/version-utils';
import { buildDependencyArray, buildDevDependencyArray } from './lib/build-dependency-array';
import { getTargetLibraryDirectory } from './lib/get-target-library-directory';
import { initializeAngularLibrary } from './lib/initialize-angular-library';
import type { HlmBaseGeneratorSchema } from './schema';
import { FALLBACK_ANGULAR_VERSION } from './versions';

export async function hlmBaseGenerator(tree: Tree, options: HlmBaseGeneratorSchema) {
	const tasks: GeneratorCallback[] = [];
	const targetLibDir = getTargetLibraryDirectory(options, tree);

	const existingPathsByAlias = readTsConfigPathsFromTree(tree);
	const tsConfigAliasToUse = `@spartan-ng/${options.publicName}`;

	if (Object.keys(existingPathsByAlias).includes(tsConfigAliasToUse)) {
		console.log(`Skipping ${tsConfigAliasToUse}. It's already installed!`);
		return runTasksInSerial(...tasks);
	}

	if (options.angularCli) {
		addTsConfigPath(tree, tsConfigAliasToUse, [`.${path.sep}${joinPathFragments(targetLibDir, 'src', 'index.ts')}`]);
	} else {
		tasks.push(await initializeAngularLibrary(tree, options));
	}

	generateFiles(
		tree,
		path.join(__dirname, '..', 'ui', 'libs', options.internalName, 'files'),
		path.join(targetLibDir, 'src'),
		options,
	);

	const angularVersion = getInstalledPackageVersion(tree, '@angular/core', FALLBACK_ANGULAR_VERSION, true);
	const existingCdkVersion = getInstalledPackageVersion(tree, '@angular/cdk', FALLBACK_ANGULAR_VERSION, true);
	const dependencies = buildDependencyArray(options, angularVersion, existingCdkVersion);
	const devDependencies = buildDevDependencyArray();

	tasks.push(addDependenciesToPackageJson(tree, dependencies, devDependencies));
	return runTasksInSerial(...tasks);
}

export default hlmBaseGenerator;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/base/schema.d.ts
```typescript
export interface HlmBaseGeneratorSchema {
	primitiveName: string;
	internalName: string;
	publicName: string;
	directory?: string;
	rootProject?: boolean;
	tags?: string;
	peerDependencies?: Record<string, string>;
	angularCli?: boolean;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/base/schema.json
```json
{
	"$schema": "http://json-schema.org/draft-07/schema",
	"$id": "HlmBaseGeneratorSchema",
	"title": "",
	"type": "object",
	"properties": {
		"directory": {
			"type": "string",
			"description": "A directory where the lib is placed.",
			"x-priority": "important"
		},
		"tags": {
			"type": "string",
			"description": "Add tags to the library (used for linting)."
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/base/versions.ts
```typescript
// angular dependency
export const FALLBACK_ANGULAR_VERSION = '^18.0.0';
// ng-icon dependency
export const NG_ICONS_VERSION = '^29.10.0';
// spartan dependencies
export const SPARTAN_BRAIN_VERSION = '0.0.1-alpha.381';
// dev dependencies
export const TAILWIND_MERGE_VERSION = '^2.2.0';
export const TAILWINDCSS_VERSION = '^3.0.2';
export const TAILWIND_ANIMATE_VERSION = '^1.0.6';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/base/lib/build-dependency-array.ts
```typescript
import type { HlmBaseGeneratorSchema } from '../schema';
import {
	NG_ICONS_VERSION,
	SPARTAN_BRAIN_VERSION,
	TAILWINDCSS_VERSION,
	TAILWIND_ANIMATE_VERSION,
	TAILWIND_MERGE_VERSION,
} from '../versions';

export function buildDependencyArray(
	options: HlmBaseGeneratorSchema,
	angularVersion: string,
	existingCdkVersion: string,
) {
	let dependencies: Record<string, string> = {
		'@angular/cdk': existingCdkVersion ?? angularVersion,
		'@spartan-ng/brain': SPARTAN_BRAIN_VERSION,
	};

	if (options.peerDependencies) {
		dependencies = { ...dependencies, ...options.peerDependencies };
	}

	if (options.primitiveName === 'icon') {
		dependencies = { ...dependencies, '@ng-icons/core': NG_ICONS_VERSION };
	}
	return dependencies;
}

export function buildDevDependencyArray() {
	return {
		'tailwind-merge': TAILWIND_MERGE_VERSION,
		tailwindcss: TAILWINDCSS_VERSION,
		'tailwindcss-animate': TAILWIND_ANIMATE_VERSION,
	};
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/base/lib/get-target-library-directory.ts
```typescript
import { type Tree, extractLayoutDirectory, getWorkspaceLayout } from '@nx/devkit';
import * as path from 'node:path';
import type { HlmBaseGeneratorSchema } from '../schema';

export function getTargetLibraryDirectory(options: HlmBaseGeneratorSchema, tree: Tree) {
	const { layoutDirectory, projectDirectory } = extractLayoutDirectory(options.directory);
	const workspaceLayout = getWorkspaceLayout(tree);
	const baseLibsDir = layoutDirectory ?? workspaceLayout.libsDir;
	const libsDir = options.rootProject ? '.' : baseLibsDir;
	return path.join(libsDir, projectDirectory, options.publicName);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/cli/src/generators/base/lib/initialize-angular-library.ts
```typescript
import { type Tree, joinPathFragments } from '@nx/devkit';
import type { HlmBaseGeneratorSchema } from '../schema';

export async function initializeAngularLibrary(tree: Tree, options: HlmBaseGeneratorSchema) {
	return await (
		await import(
			// eslint-disable-next-line @typescript-eslint/ban-ts-comment
			// @ts-ignore
			'@nx/angular/generators'
		)
	).libraryGenerator(tree, {
		name: options.publicName,
		skipFormat: true,
		simpleName: true,
		buildable: true,
		importPath: `@spartan-ng/${options.publicName}`,
		prefix: 'hlm',
		skipModule: true,
		directory: joinPathFragments(options.directory, options.publicName),
		tags: options.tags,
	});
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/README.md
```
# brain

This library was generated with [Nx](https://nx.dev).

## Running unit tests

Run `nx test brain` to execute the unit tests.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/eslint.config.cjs
```
const nx = require('@nx/eslint-plugin');
const baseConfig = require('../../eslint.config.cjs');

module.exports = [
	...baseConfig,
	...nx.configs['flat/angular'],
	...nx.configs['flat/angular-template'],
	{
		files: ['**/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': [
				'error',
				{
					type: 'attribute',
					prefix: 'brn',
					style: 'camelCase',
				},
			],
			'@angular-eslint/component-selector': [
				'error',
				{
					type: 'element',
					prefix: 'brn',
					style: 'kebab-case',
				},
			],
			// we may want to enable these at some point
			'@angular-eslint/template/click-events-have-key-events': 'off',
			'@angular-eslint/template/interactive-supports-focus': 'off',
			'@angular-eslint/template/label-has-associated-control': 'off',
			'@angular-eslint/no-input-rename': 'off',
			'@angular-eslint/no-output-rename': 'off',
			'@angular-eslint/no-output-native': 'off',
		},
	},
	{
		files: ['**/tests/*.ts'],
		rules: {
			'@angular-eslint/directive-selector': 'off',
			'@angular-eslint/component-selector': 'off',
		},
	},
	{
		files: ['**/*.html'],
		// Override or add rules here
		rules: {
			// we may want to enable these at some point
			'@angular-eslint/template/click-events-have-key-events': 'off',
			'@angular-eslint/template/interactive-supports-focus': 'off',
			'@angular-eslint/template/label-has-associated-control': 'off',
		},
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/hlm-tailwind-preset.css
```css
@plugin "tailwindcss-animate";

@theme {
	--color-border: hsl(var(--border));
	--color-input: hsl(var(--input));
	--color-ring: hsl(var(--ring));
	--color-background: hsl(var(--background));
	--color-foreground: hsl(var(--foreground));
	--color-primary: hsl(var(--primary));
	--color-primary-foreground: hsl(var(--primary-foreground));
	--color-secondary: hsl(var(--secondary));
	--color-secondary-foreground: hsl(var(--secondary-foreground));
	--color-destructive: hsl(var(--destructive));
	--color-destructive-foreground: hsl(var(--destructive-foreground));
	--color-muted: hsl(var(--muted));
	--color-muted-foreground: hsl(var(--muted-foreground));
	--color-accent: hsl(var(--accent));
	--color-accent-foreground: hsl(var(--accent-foreground));
	--color-popover: hsl(var(--popover));
	--color-popover-foreground: hsl(var(--popover-foreground));
	--color-card: hsl(var(--card));
	--color-card-foreground: hsl(var(--card-foreground));

	--radius-lg: var(--radius);
	--radius-md: calc(var(--radius) - 2px);
	--radius-sm: calc(var(--radius) - 4px);

	--animate-indeterminate: indeterminate 4s ease-in-out;
}

@keyframes indeterminate {
	0% {
		transform: translateX(-100%) scaleX(0.5);
	}
	100% {
		transform: translateX(100%) scaleX(0.5);
	}
}

@utility container {
  margin-inline: auto;
  padding-inline: 2rem;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/hlm-tailwind-preset.js
```javascript
const { fontFamily } = require('tailwindcss/defaultTheme');

/** @type {import('tailwindcss').Config} */
module.exports = {
	theme: {
		container: {
			center: true,
			padding: '2rem',
			screens: {
				'2xl': '1400px',
			},
		},
		extend: {
			colors: {
				border: 'hsl(var(--border))',
				input: 'hsl(var(--input))',
				ring: 'hsl(var(--ring))',
				background: 'hsl(var(--background))',
				foreground: 'hsl(var(--foreground))',
				primary: {
					DEFAULT: 'hsl(var(--primary))',
					foreground: 'hsl(var(--primary-foreground))',
				},
				secondary: {
					DEFAULT: 'hsl(var(--secondary))',
					foreground: 'hsl(var(--secondary-foreground))',
				},
				destructive: {
					DEFAULT: 'hsl(var(--destructive))',
					foreground: 'hsl(var(--destructive-foreground))',
				},
				muted: {
					DEFAULT: 'hsl(var(--muted))',
					foreground: 'hsl(var(--muted-foreground))',
				},
				accent: {
					DEFAULT: 'hsl(var(--accent))',
					foreground: 'hsl(var(--accent-foreground))',
				},
				popover: {
					DEFAULT: 'hsl(var(--popover))',
					foreground: 'hsl(var(--popover-foreground))',
				},
				card: {
					DEFAULT: 'hsl(var(--card))',
					foreground: 'hsl(var(--card-foreground))',
				},
			},
			borderRadius: {
				lg: 'var(--radius)',
				md: 'calc(var(--radius) - 2px)',
				sm: 'calc(var(--radius) - 4px)',
			},
			fontFamily: {
				sans: ['var(--font-sans)', ...fontFamily.sans],
			},
			keyframes: {
				indeterminate: {
					'0%': {
						transform: 'translateX(-100%) scaleX(0.5)',
					},
					'100%': {
						transform: 'translateX(100%) scaleX(0.5)',
					},
				},
				'caret-blink': {
					'0%,70%,100%': { opacity: '1' },
					'20%,50%': { opacity: '0' },
				},
			},
			animation: {
				indeterminate: 'indeterminate 4s infinite ease-in-out',
				'caret-blink': 'caret-blink 1.25s ease-out infinite',
			},
		},
	},
	plugins: [require('tailwindcss-animate')],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/jest.config.ts
```typescript
export default {
	displayName: 'brain',
	preset: '../../jest.preset.cjs',
	setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
	coverageDirectory: '../../coverage/libs/brain',
	transform: {
		'^.+\\.(ts|mjs|js|html)$': [
			'jest-preset-angular',
			{
				tsconfig: '<rootDir>/tsconfig.spec.json',
				stringifyContentPathRegex: '\\.(html|svg)$',
			},
		],
	},
	transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
	snapshotSerializers: [
		'jest-preset-angular/build/serializers/no-ng-attributes',
		'jest-preset-angular/build/serializers/ng-snapshot',
		'jest-preset-angular/build/serializers/html-comment',
	],
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/ng-package.json
```json
{
	"$schema": "../../node_modules/ng-packagr/ng-package.schema.json",
	"dest": "../../dist/libs/brain",
	"lib": {
		"entryFile": "src/index.ts"
	},
	"assets": ["hlm-tailwind-preset.js", "hlm-tailwind-preset.css"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/package.json
```json
{
	"name": "@spartan-ng/brain",
	"version": "0.0.1-alpha.451",
	"sideEffects": false,
	"exports": {
		"./hlm-tailwind-preset": {
			"default": "./hlm-tailwind-preset.js"
		},
		"./hlm-tailwind-preset.css": "./hlm-tailwind-preset.css"
	},
	"peerDependencies": {
		"@angular/cdk": ">=19.0.0",
		"@angular/common": ">=19.0.0",
		"@angular/core": ">=19.0.0",
		"@angular/forms": ">=19.0.0",
		"clsx": ">=2.0.0",
		"luxon": ">=3.0.0",
		"rxjs": ">=6.6.0",
		"tailwind-merge": ">=2.5.0",
		"tailwindcss": ">=3.3.0",
		"tailwindcss-animate": ">=1.0.7"
	},
	"peerDependenciesMeta": {
		"luxon": {
			"optional": true
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/project.json
```json
{
	"name": "brain",
	"$schema": "../../node_modules/nx/schemas/project-schema.json",
	"sourceRoot": "libs/brain/src",
	"prefix": "brn",
	"projectType": "library",
	"tags": ["scope:brain"],
	"targets": {
		"build": {
			"executor": "@nx/angular:package",
			"outputs": ["{workspaceRoot}/dist/{projectRoot}"],
			"options": {
				"project": "libs/brain/ng-package.json"
			},
			"configurations": {
				"production": {
					"tsConfig": "libs/brain/tsconfig.lib.prod.json"
				},
				"development": {
					"tsConfig": "libs/brain/tsconfig.lib.json"
				}
			},
			"defaultConfiguration": "production"
		},
		"test": {
			"executor": "@nx/jest:jest",
			"outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
			"options": {
				"jestConfig": "libs/brain/jest.config.ts"
			}
		},
		"lint": {
			"executor": "@nx/eslint:lint"
		},
		"release": {
			"executor": "@spartan-ng/tools:build-update-publish",
			"options": {
				"libName": "brain"
			}
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/tsconfig.json
```json
{
	"compilerOptions": {
		"target": "es2022",
		"forceConsistentCasingInFileNames": true,
		"strict": true,
		"noImplicitOverride": true,
		"noPropertyAccessFromIndexSignature": true,
		"noImplicitReturns": true,
		"noFallthroughCasesInSwitch": true
	},
	"files": [],
	"include": [],
	"references": [
		{
			"path": "./tsconfig.lib.json"
		},
		{
			"path": "./tsconfig.spec.json"
		}
	],
	"extends": "../../tsconfig.base.json",
	"angularCompilerOptions": {
		"enableI18nLegacyMessageIdFormat": false,
		"strictInjectionParameters": true,
		"strictInputAccessModifiers": true,
		"strictTemplates": true
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/tsconfig.lib.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../dist/out-tsc",
		"declaration": true,
		"declarationMap": true,
		"inlineSources": true,
		"types": []
	},
	"exclude": ["**/*.spec.ts", "test-setup.ts", "jest.config.ts", "**/*.test.ts"],
	"include": ["**/*.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/tsconfig.lib.prod.json
```json
{
	"extends": "./tsconfig.lib.json",
	"compilerOptions": {
		"declarationMap": false
	},
	"angularCompilerOptions": {
		"compilationMode": "partial"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/tsconfig.spec.json
```json
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"outDir": "../../dist/out-tsc",
		"module": "commonjs",
		"target": "es2016",
		"types": ["jest", "node"]
	},
	"files": ["src/test-setup.ts"],
	"include": ["jest.config.ts", "**/*.test.ts", "**/*.spec.ts", "**/*.d.ts"]
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/tabs/README.md
```
# @spartan-ng/brain/tabs

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/tabs`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/tabs/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/tabs/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { BrnTabsListDirective } from './lib/brn-tabs-list.directive';
import { BrnTabsContentDirective, BrnTabsDirective, BrnTabsTriggerDirective } from './lib/brn-tabs-trigger.directive';

export * from './lib/brn-tabs-list.directive';
export * from './lib/brn-tabs-paginated-list.directive';
export * from './lib/brn-tabs-trigger.directive';

export const BrnTabsImports = [
	BrnTabsDirective,
	BrnTabsListDirective,
	BrnTabsTriggerDirective,
	BrnTabsContentDirective,
] as const;

@NgModule({
	imports: [...BrnTabsImports],
	exports: [...BrnTabsImports],
})
export class BrnTabsModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/tabs/src/lib/brn-tabs-list.directive.ts
```typescript
import { FocusKeyManager } from '@angular/cdk/a11y';
import { type AfterContentInit, Directive, ElementRef, contentChildren, inject } from '@angular/core';
import { fromEvent } from 'rxjs';
import { take } from 'rxjs/operators';
import { BrnTabsDirective, BrnTabsTriggerDirective } from './brn-tabs-trigger.directive';

@Directive({
	selector: '[brnTabsList]',
	standalone: true,
	host: {
		role: 'tablist',
		'[attr.aria-orientation]': '_orientation()',
		'[attr.data-orientation]': '_orientation()',
	},
	exportAs: 'brnTabsList',
})
export class BrnTabsListDirective implements AfterContentInit {
	private readonly _root = inject(BrnTabsDirective);

	protected readonly _orientation = this._root.$orientation;
	private readonly _direction = this._root.$direction;
	private readonly _activeTab = this._root.$activeTab;
	private readonly _tabs = this._root.$tabs;
	private readonly _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);
	private readonly _keyDownListener = fromEvent(this._elementRef.nativeElement, 'keydown');

	private _keyManager?: FocusKeyManager<BrnTabsTriggerDirective>;

	public triggers = contentChildren(BrnTabsTriggerDirective, { descendants: true });

	public ngAfterContentInit() {
		this._keyManager = new FocusKeyManager<BrnTabsTriggerDirective>(this.triggers())
			.withHorizontalOrientation(this._direction())
			.withHomeAndEnd()
			.withPageUpDown()
			.withWrap();

		// needed because by default the index is set to -1, which means first interaction is skipped
		this._keyDownListener.pipe(take(1)).subscribe(() => {
			const currentTabKey = this._activeTab();
			const tabs = this._tabs();
			let activeIndex = 0;
			if (currentTabKey) {
				const currentTab = tabs[currentTabKey];
				if (currentTab) {
					activeIndex = this.triggers().indexOf(currentTab.trigger);
				}
			}
			this._keyManager?.setActiveItem(activeIndex);
		});

		this._keyDownListener.subscribe((event) => {
			if ('key' in event) {
				if (this._orientation() === 'horizontal') {
					if (event.key === 'ArrowUp' || event.key === 'ArrowDown') return;
				}
				if (this._orientation() === 'vertical') {
					if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') return;
				}
			}
			this._keyManager?.onKeydown(event as KeyboardEvent);
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/tabs/src/lib/brn-tabs-paginated-list.directive.ts
```typescript
/**
 * We are building on shoulders of giants here and adapt the implementation provided by the incredible Angular
 * team: https://github.com/angular/components/blob/main/src/material/tabs/paginated-tab-header.ts
 * Check them out! Give them a try! Leave a star! Their work is incredible!
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

import { FocusKeyManager, type FocusableOption } from '@angular/cdk/a11y';
import { type Direction, Directionality } from '@angular/cdk/bidi';
import { ENTER, SPACE, hasModifierKey } from '@angular/cdk/keycodes';
import { SharedResizeObserver } from '@angular/cdk/observers/private';
import { Platform, normalizePassiveListenerOptions } from '@angular/cdk/platform';
import { ViewportRuler } from '@angular/cdk/scrolling';
import {
	ANIMATION_MODULE_TYPE,
	type AfterContentChecked,
	type AfterContentInit,
	type AfterViewInit,
	ChangeDetectorRef,
	Directive,
	ElementRef,
	Injector,
	NgZone,
	type OnDestroy,
	Signal,
	afterNextRender,
	booleanAttribute,
	computed,
	effect,
	inject,
	input,
	output,
	signal,
} from '@angular/core';
import { EMPTY, Observable, type Observer, Subject, fromEvent, merge, of as observableOf, timer } from 'rxjs';
import { debounceTime, filter, skip, startWith, switchMap, takeUntil } from 'rxjs/operators';
import { BrnTabsDirective } from './brn-tabs-trigger.directive';

/** Config used to bind passive event listeners */
const passiveEventListenerOptions = normalizePassiveListenerOptions({
	passive: true,
}) as EventListenerOptions;

/**
 * The directions that scrolling can go in when the header's tabs exceed the header width. 'After'
 * will scroll the header towards the end of the tabs list and 'before' will scroll towards the
 * beginning of the list.
 */
export type ScrollDirection = 'after' | 'before';

/**
 * Amount of milliseconds to wait before starting to scroll the header automatically.
 * Set a little conservatively in order to handle fake events dispatched on touch devices.
 */
const HEADER_SCROLL_DELAY = 650;

/**
 * Interval in milliseconds at which to scroll the header
 * while the user is holding their pointer.
 */
const HEADER_SCROLL_INTERVAL = 100;

/** Item inside a paginated tab header. */
export type BrnPaginatedTabHeaderItem = FocusableOption & { elementRef: ElementRef };

/**
 * Base class for a tab header that supported pagination.
 * @docs-private
 */
@Directive()
export abstract class BrnTabsPaginatedListDirective
	implements AfterContentChecked, AfterContentInit, AfterViewInit, OnDestroy
{
	public abstract _items: Signal<ReadonlyArray<BrnPaginatedTabHeaderItem>>;
	public abstract _itemsChanges: Observable<ReadonlyArray<BrnPaginatedTabHeaderItem>>;
	public abstract _tabListContainer: Signal<ElementRef<HTMLElement>>;
	public abstract _tabList: Signal<ElementRef<HTMLElement>>;
	public abstract _tabListInner: Signal<ElementRef<HTMLElement>>;
	public abstract _nextPaginator: Signal<ElementRef<HTMLElement>>;
	public abstract _previousPaginator: Signal<ElementRef<HTMLElement>>;

	/** The distance in pixels that the tab labels should be translated to the left. */
	private _scrollDistance = 0;

	/** Whether the header should scroll to the selected index after the view has been checked. */
	private _selectedIndexChanged = false;

	private readonly _root = inject(BrnTabsDirective);
	private readonly _activeTab = this._root.$activeTab;
	private readonly _tabs = this._root.$tabs;

	/** Emits when the component is destroyed. */
	protected readonly _destroyed = new Subject<void>();

	/** Whether the controls for pagination should be displayed */
	public _showPaginationControls = signal(false);

	/** Whether the tab list can be scrolled more towards the end of the tab label list. */
	public _disableScrollAfter = true;

	/** Whether the tab list can be scrolled more towards the beginning of the tab label list. */
	public _disableScrollBefore = true;

	/**
	 * The number of tab labels that are displayed on the header. When this changes, the header
	 * should re-evaluate the scroll position.
	 */
	private _tabLabelCount!: number;

	/** Whether the scroll distance has changed and should be applied after the view is checked. */
	private _scrollDistanceChanged!: boolean;

	/** Used to manage focus between the tabs. */
	private _keyManager!: FocusKeyManager<BrnPaginatedTabHeaderItem>;

	/** Cached text content of the header. */
	private _currentTextContent!: string;

	/** Stream that will stop the automated scrolling. */
	private readonly _stopScrolling = new Subject<void>();

	/**
	 * Whether pagination should be disabled. This can be used to avoid unnecessary
	 * layout recalculations if it's known that pagination won't be required.
	 */
	public disablePagination = input(false, { transform: booleanAttribute });

	/** The index of the active tab. */
	private readonly _selectedIndex = computed(() => {
		const currentTabKey = this._activeTab();
		const tabs = this._tabs();

		let activeIndex = 0;
		if (currentTabKey && this._items()) {
			const currentTab = tabs[currentTabKey];
			if (currentTab) {
				activeIndex = this._items().indexOf(currentTab.trigger);
			}
		}

		return activeIndex;
	});

	/** Event emitted when the option is selected. */
	public readonly selectFocusedIndex = output<number>();

	/** Event emitted when a label is focused. */
	public readonly indexFocused = output<number>();

	private readonly _sharedResizeObserver = inject(SharedResizeObserver);

	private readonly _injector = inject(Injector);

	protected _elementRef: ElementRef<HTMLElement> = inject(ElementRef);
	protected _changeDetectorRef: ChangeDetectorRef = inject(ChangeDetectorRef);
	private readonly _viewportRuler: ViewportRuler = inject(ViewportRuler);
	private readonly _dir = inject(Directionality, { optional: true });
	private readonly _ngZone: NgZone = inject(NgZone);
	private readonly _platform: Platform = inject(Platform);
	public _animationMode = inject(ANIMATION_MODULE_TYPE, { optional: true });

	constructor() {
		// Bind the `mouseleave` event on the outside since it doesn't change anything in the view.
		this._ngZone.runOutsideAngular(() => {
			fromEvent(this._elementRef.nativeElement, 'mouseleave')
				.pipe(takeUntil(this._destroyed))
				.subscribe(() => {
					this._stopInterval();
				});
		});

		effect(() => {
			const selectedIndex = this._selectedIndex();

			if (selectedIndex !== 0) {
				this._selectedIndexChanged = true;
				if (this._keyManager) {
					this._keyManager.updateActiveItem(selectedIndex);
				}
			}
		});
	}

	/** Called when the user has selected an item via the keyboard. */
	protected abstract _itemSelected(event: KeyboardEvent): void;

	ngAfterViewInit() {
		// We need to handle these events manually, because we want to bind passive event listeners.
		fromEvent(this._previousPaginator().nativeElement, 'touchstart', passiveEventListenerOptions)
			.pipe(takeUntil(this._destroyed))
			.subscribe(() => {
				this._handlePaginatorPress('before');
			});

		fromEvent(this._nextPaginator().nativeElement, 'touchstart', passiveEventListenerOptions)
			.pipe(takeUntil(this._destroyed))
			.subscribe(() => {
				this._handlePaginatorPress('after');
			});
	}

	ngAfterContentInit() {
		const dirChange = this._dir ? this._dir.change : observableOf('ltr');
		// We need to debounce resize events because the alignment logic is expensive.
		// If someone animates the width of tabs, we don't want to realign on every animation frame.
		// Once we haven't seen any more resize events in the last 32ms (~2 animaion frames) we can
		// re-align.
		const resize = this._sharedResizeObserver
			.observe(this._elementRef.nativeElement)
			.pipe(debounceTime(32), takeUntil(this._destroyed));
		// Note: We do not actually need to watch these events for proper functioning of the tabs,
		// the resize events above should capture any viewport resize that we care about. However,
		// removing this is fairly breaking for screenshot tests, so we're leaving it here for now.
		const viewportResize = this._viewportRuler.change(150).pipe(takeUntil(this._destroyed));

		const realign = () => {
			this.updatePagination();
		};

		this._keyManager = new FocusKeyManager<BrnPaginatedTabHeaderItem>(this._items())
			.withHorizontalOrientation(this._getLayoutDirection())
			.withHomeAndEnd()
			.withWrap()
			// Allow focus to land on disabled tabs, as per https://w3c.github.io/aria-practices/#kbd_disabled_controls
			.skipPredicate(() => false);

		this._keyManager.updateActiveItem(this._selectedIndex());

		// Note: We do not need to realign after the first render for proper functioning of the tabs
		// the resize events above should fire when we first start observing the element. However,
		// removing this is fairly breaking for screenshot tests, so we're leaving it here for now.
		afterNextRender(realign, { injector: this._injector });

		// On dir change or resize, realign the ink bar and update the orientation of
		// the key manager if the direction has changed.
		merge(dirChange, viewportResize, resize, this._itemsChanges, this._itemsResized())
			.pipe(takeUntil(this._destroyed))
			.subscribe(() => {
				// We need to defer this to give the browser some time to recalculate
				// the element dimensions. The call has to be wrapped in `NgZone.run`,
				// because the viewport change handler runs outside of Angular.
				this._ngZone.run(() => {
					Promise.resolve().then(() => {
						// Clamp the scroll distance, because it can change with the number of tabs.
						this._scrollDistance = Math.max(0, Math.min(this._getMaxScrollDistance(), this._scrollDistance));
						realign();
					});
				});
				this._keyManager.withHorizontalOrientation(this._getLayoutDirection());
			});

		// If there is a change in the focus key manager we need to emit the `indexFocused`
		// event in order to provide a public event that notifies about focus changes. Also we realign
		// the tabs container by scrolling the new focused tab into the visible section.
		this._keyManager.change.subscribe((newFocusIndex) => {
			this.indexFocused.emit(newFocusIndex);
			this._setTabFocus(newFocusIndex);
		});
	}

	/** Sends any changes that could affect the layout of the items. */
	private _itemsResized(): Observable<ResizeObserverEntry[]> {
		if (typeof ResizeObserver !== 'function') {
			return EMPTY;
		}

		return this._itemsChanges.pipe(
			startWith(this._items()),
			switchMap(
				(tabItems: ReadonlyArray<BrnPaginatedTabHeaderItem>) =>
					new Observable((observer: Observer<ResizeObserverEntry[]>) =>
						this._ngZone.runOutsideAngular(() => {
							const resizeObserver = new ResizeObserver((entries) => observer.next(entries));
							for (const tabItem of tabItems) {
								resizeObserver.observe(tabItem.elementRef.nativeElement);
							}
							return () => {
								resizeObserver.disconnect();
							};
						}),
					),
			),
			// Skip the first emit since the resize observer emits when an item
			// is observed for new items when the tab is already inserted
			skip(1),
			// Skip emissions where all the elements are invisible since we don't want
			// the header to try and re-render with invalid measurements. See #25574.
			filter((entries) => entries.some((e) => e.contentRect.width > 0 && e.contentRect.height > 0)),
		);
	}

	ngAfterContentChecked(): void {
		// If the number of tab labels have changed, check if scrolling should be enabled
		if (this._tabLabelCount !== this._items().length) {
			this.updatePagination();
			this._tabLabelCount = this._items().length;
			this._changeDetectorRef.markForCheck();
		}

		// If the selected index has changed, scroll to the label and check if the scrolling controls
		// should be disabled.
		if (this._selectedIndexChanged) {
			this._scrollToLabel(this._selectedIndex());
			this._checkScrollingControls();
			this._selectedIndexChanged = false;
			this._changeDetectorRef.markForCheck();
		}

		// If the scroll distance has been changed (tab selected, focused, scroll controls activated),
		// then translate the header to reflect this.
		if (this._scrollDistanceChanged) {
			this._updateTabScrollPosition();
			this._scrollDistanceChanged = false;
			this._changeDetectorRef.markForCheck();
		}
	}

	ngOnDestroy() {
		this._keyManager?.destroy();
		this._destroyed.next();
		this._destroyed.complete();
		this._stopScrolling.complete();
	}

	/** Handles keyboard events on the header. */
	_handleKeydown(event: KeyboardEvent) {
		// We don't handle any key bindings with a modifier key.
		if (hasModifierKey(event)) {
			return;
		}

		switch (event.keyCode) {
			case ENTER:
			case SPACE:
				if (this.focusIndex !== this._selectedIndex()) {
					const item = this._items()[this.focusIndex];

					if (item && !item.disabled) {
						this.selectFocusedIndex.emit(this.focusIndex);
						this._itemSelected(event);
					}
				}
				break;
			default:
				this._keyManager.onKeydown(event);
		}
	}

	/**
	 * Callback for when the MutationObserver detects that the content has changed.
	 */
	_onContentChanges() {
		const textContent = this._elementRef.nativeElement.textContent;

		// We need to diff the text content of the header, because the MutationObserver callback
		// will fire even if the text content didn't change which is inefficient and is prone
		// to infinite loops if a poorly constructed expression is passed in (see #14249).
		if (textContent !== this._currentTextContent) {
			this._currentTextContent = textContent || '';

			// The content observer runs outside the `NgZone` by default, which
			// means that we need to bring the callback back in ourselves.
			this._ngZone.run(() => {
				this.updatePagination();
				this._changeDetectorRef.markForCheck();
			});
		}
	}

	/**
	 * Updates the view whether pagination should be enabled or not.
	 *
	 * WARNING: Calling this method can be very costly in terms of performance. It should be called
	 * as infrequently as possible from outside of the Tabs component as it causes a reflow of the
	 * page.
	 */
	updatePagination() {
		this._checkPaginationEnabled();
		this._checkScrollingControls();
		this._updateTabScrollPosition();
	}

	/** Tracks which element has focus; used for keyboard navigation */
	public get focusIndex(): number {
		return this._keyManager ? (this._keyManager.activeItemIndex ?? 0) : 0;
	}

	/** When the focus index is set, we must manually send focus to the correct label */
	public set focusIndex(value: number) {
		if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {
			return;
		}

		this._keyManager.setActiveItem(value);
	}

	/**
	 * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is
	 * providing a valid index and return true.
	 */
	_isValidIndex(index: number): boolean {
		return this._items() ? !!this._items()[index] : true;
	}

	/**
	 * Sets focus on the HTML element for the label wrapper and scrolls it into the view if
	 * scrolling is enabled.
	 */
	_setTabFocus(tabIndex: number) {
		if (this._showPaginationControls()) {
			this._scrollToLabel(tabIndex);
		}

		if (this._items()?.length) {
			this._items()[tabIndex].focus();

			// Do not let the browser manage scrolling to focus the element, this will be handled
			// by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width
			// should be the full width minus the offset width.
			const containerEl = this._tabListContainer().nativeElement;
			const dir = this._getLayoutDirection();

			if (dir === 'ltr') {
				containerEl.scrollLeft = 0;
			} else {
				containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;
			}
		}
	}

	/** The layout direction of the containing app. */
	_getLayoutDirection(): Direction {
		return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
	}

	/** Performs the CSS transformation on the tab list that will cause the list to scroll. */
	_updateTabScrollPosition() {
		if (this.disablePagination()) {
			return;
		}

		const scrollDistance = this.scrollDistance;
		const translateX = this._getLayoutDirection() === 'ltr' ? -scrollDistance : scrollDistance;

		// Don't use `translate3d` here because we don't want to create a new layer. A new layer
		// seems to cause flickering and overflow in Internet Explorer. For example, the ink bar
		// and ripples will exceed the boundaries of the visible tab bar.
		// See: https://github.com/angular/components/issues/10276
		// We round the `transform` here, because transforms with sub-pixel precision cause some
		// browsers to blur the content of the element.
		this._tabList().nativeElement.style.transform = `translateX(${Math.round(translateX)}px)`;

		// Setting the `transform` on IE will change the scroll offset of the parent, causing the
		// position to be thrown off in some cases. We have to reset it ourselves to ensure that
		// it doesn't get thrown off. Note that we scope it only to IE and Edge, because messing
		// with the scroll position throws off Chrome 71+ in RTL mode (see #14689).
		if (this._platform.TRIDENT || this._platform.EDGE) {
			this._tabListContainer().nativeElement.scrollLeft = 0;
		}
	}

	/** Sets the distance in pixels that the tab header should be transformed in the X-axis. */
	public get scrollDistance(): number {
		return this._scrollDistance;
	}
	public set scrollDistance(value: number) {
		this._scrollTo(value);
	}

	/**
	 * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or
	 * the end of the list, respectively). The distance to scroll is computed to be a third of the
	 * length of the tab list view window.
	 *
	 * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
	 * should be called sparingly.
	 */
	_scrollHeader(direction: ScrollDirection) {
		const viewLength = this._tabListContainer().nativeElement.offsetWidth;

		// Move the scroll distance one-third the length of the tab list's viewport.
		const scrollAmount = ((direction === 'before' ? -1 : 1) * viewLength) / 3;

		return this._scrollTo(this._scrollDistance + scrollAmount);
	}

	/** Handles click events on the pagination arrows. */
	_handlePaginatorClick(direction: ScrollDirection) {
		this._stopInterval();
		this._scrollHeader(direction);
	}

	/**
	 * Moves the tab list such that the desired tab label (marked by index) is moved into view.
	 *
	 * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
	 * should be called sparingly.
	 */
	_scrollToLabel(labelIndex: number) {
		if (this.disablePagination()) {
			return;
		}

		const selectedLabel = this._items() ? this._items()[labelIndex] : null;

		if (!selectedLabel) {
			return;
		}

		// The view length is the visible width of the tab labels.
		const viewLength = this._tabListContainer().nativeElement.offsetWidth;
		const { offsetLeft, offsetWidth } = selectedLabel.elementRef.nativeElement;

		let labelBeforePos: number;
		let labelAfterPos: number;
		if (this._getLayoutDirection() === 'ltr') {
			labelBeforePos = offsetLeft;
			labelAfterPos = labelBeforePos + offsetWidth;
		} else {
			labelAfterPos = this._tabListInner().nativeElement.offsetWidth - offsetLeft;
			labelBeforePos = labelAfterPos - offsetWidth;
		}

		const beforeVisiblePos = this.scrollDistance;
		const afterVisiblePos = this.scrollDistance + viewLength;

		if (labelBeforePos < beforeVisiblePos) {
			// Scroll header to move label to the before direction
			this.scrollDistance -= beforeVisiblePos - labelBeforePos;
		} else if (labelAfterPos > afterVisiblePos) {
			// Scroll header to move label to the after direction
			this.scrollDistance += Math.min(labelAfterPos - afterVisiblePos, labelBeforePos - beforeVisiblePos);
		}
	}

	/**
	 * Evaluate whether the pagination controls should be displayed. If the scroll width of the
	 * tab list is wider than the size of the header container, then the pagination controls should
	 * be shown.
	 *
	 * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
	 * should be called sparingly.
	 */
	_checkPaginationEnabled() {
		if (this.disablePagination()) {
			this._showPaginationControls.set(false);
		} else {
			const isEnabled = this._tabListInner().nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;

			if (!isEnabled) {
				this.scrollDistance = 0;
			}

			if (isEnabled !== this._showPaginationControls()) {
				this._changeDetectorRef.markForCheck();
			}

			this._showPaginationControls.set(isEnabled);
		}
	}

	/**
	 * Evaluate whether the before and after controls should be enabled or disabled.
	 * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the
	 * before button. If the header is at the end of the list (scroll distance is equal to the
	 * maximum distance we can scroll), then disable the after button.
	 *
	 * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
	 * should be called sparingly.
	 */
	_checkScrollingControls() {
		if (this.disablePagination()) {
			this._disableScrollAfter = this._disableScrollBefore = true;
		} else {
			// Check if the pagination arrows should be activated.
			this._disableScrollBefore = this.scrollDistance === 0;
			this._disableScrollAfter = this.scrollDistance === this._getMaxScrollDistance();
			this._changeDetectorRef.markForCheck();
		}
	}

	/**
	 * Determines what is the maximum length in pixels that can be set for the scroll distance. This
	 * is equal to the difference in width between the tab list container and tab header container.
	 *
	 * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
	 * should be called sparingly.
	 */
	_getMaxScrollDistance(): number {
		const lengthOfTabList = this._tabListInner().nativeElement.scrollWidth;
		const viewLength = this._tabListContainer().nativeElement.offsetWidth;
		return lengthOfTabList - viewLength || 0;
	}

	/** Stops the currently-running paginator interval.  */
	_stopInterval() {
		this._stopScrolling.next();
	}

	/**
	 * Handles the user pressing down on one of the paginators.
	 * Starts scrolling the header after a certain amount of time.
	 * @param direction In which direction the paginator should be scrolled.
	 */
	_handlePaginatorPress(direction: ScrollDirection, mouseEvent?: MouseEvent) {
		// Don't start auto scrolling for right mouse button clicks. Note that we shouldn't have to
		// null check the `button`, but we do it so we don't break tests that use fake events.
		if (mouseEvent && mouseEvent.button !== null && mouseEvent.button !== 0) {
			return;
		}

		// Avoid overlapping timers.
		this._stopInterval();

		// Start a timer after the delay and keep firing based on the interval.
		timer(HEADER_SCROLL_DELAY, HEADER_SCROLL_INTERVAL)
			// Keep the timer going until something tells it to stop or the component is destroyed.
			.pipe(takeUntil(merge(this._stopScrolling, this._destroyed)))
			.subscribe(() => {
				const { maxScrollDistance, distance } = this._scrollHeader(direction);

				// Stop the timer if we've reached the start or the end.
				if (distance === 0 || distance >= maxScrollDistance) {
					this._stopInterval();
				}
			});
	}

	/**
	 * Scrolls the header to a given position.
	 * @param position Position to which to scroll.
	 * @returns Information on the current scroll distance and the maximum.
	 */
	private _scrollTo(position: number) {
		if (this.disablePagination()) {
			return { maxScrollDistance: 0, distance: 0 };
		}

		const maxScrollDistance = this._getMaxScrollDistance();
		this._scrollDistance = Math.max(0, Math.min(maxScrollDistance, position));

		// Mark that the scroll distance has changed so that after the view is checked, the CSS
		// transformation can move the header.
		this._scrollDistanceChanged = true;
		this._checkScrollingControls();

		return { maxScrollDistance, distance: this._scrollDistance };
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/tabs/src/lib/brn-tabs-trigger.directive.ts
```typescript
import {
	Directive,
	ElementRef,
	Input,
	computed,
	effect,
	inject,
	input,
	model,
	output,
	signal,
	untracked,
} from '@angular/core';

@Directive({
	selector: '[brnTabsContent]',
	standalone: true,
	host: {
		role: 'tabpanel',
		tabindex: '0',
		'[id]': 'contentId()',
		'[attr.aria-labelledby]': 'labelId()',
		'[hidden]': '_isSelected() === false',
	},
	exportAs: 'brnTabsContent',
})
export class BrnTabsContentDirective {
	private readonly _root = inject(BrnTabsDirective);
	private readonly _elementRef = inject(ElementRef);

	public readonly contentFor = input.required<string>({ alias: 'brnTabsContent' });
	protected readonly _isSelected = computed(() => this._root.$activeTab() === this.contentFor());
	protected contentId = computed(() => `brn-tabs-content-${this.contentFor()}`);
	protected labelId = computed(() => `brn-tabs-label-${this.contentFor()}`);

	constructor() {
		effect(() => {
			const contentFor = this.contentFor();
			untracked(() => this._root.registerContent(contentFor, this));
		});
	}

	public focus() {
		this._elementRef.nativeElement.focus();
	}
}

export type BrnTabsOrientation = 'horizontal' | 'vertical';
export type BrnTabsDirection = 'ltr' | 'rtl';
export type BrnActivationMode = 'automatic' | 'manual';

@Directive({
	selector: '[brnTabs]',
	standalone: true,
	host: {
		'[attr.data-orientation]': 'orientation()',
		'[attr.dir]': 'direction()',
	},
	exportAs: 'brnTabs',
})
export class BrnTabsDirective {
	public readonly orientation = input<BrnTabsOrientation>('horizontal');
	/** internal **/
	public $orientation = this.orientation;

	public readonly direction = input<BrnTabsDirection>('ltr');
	/** internal **/
	public $direction = this.direction;

	public readonly _activeTab = model<string | undefined>(undefined, { alias: 'brnTabs' });
	/** internal **/
	public $activeTab = this._activeTab.asReadonly();

	public readonly activationMode = input<BrnActivationMode>('automatic');
	/** internal **/
	public $activationMode = this.activationMode;

	public readonly tabActivated = output<string>();

	private readonly _tabs = signal<{
		[key: string]: { trigger: BrnTabsTriggerDirective; content: BrnTabsContentDirective };
	}>({});
	public readonly $tabs = this._tabs.asReadonly();

	public registerTrigger(key: string, trigger: BrnTabsTriggerDirective) {
		this._tabs.update((tabs) => ({ ...tabs, [key]: { trigger, content: tabs[key]?.content } }));
	}

	public registerContent(key: string, content: BrnTabsContentDirective) {
		this._tabs.update((tabs) => ({ ...tabs, [key]: { trigger: tabs[key]?.trigger, content } }));
	}

	emitTabActivated(key: string) {
		this.tabActivated.emit(key);
	}

	setActiveTab(key: string) {
		this._activeTab.set(key);
	}
}

@Directive({
	selector: 'button[brnTabsTrigger]',
	standalone: true,
	host: {
		'[id]': 'labelId()',
		type: 'button',
		role: 'tab',
		'[tabindex]': 'selected() ? "0": "-1"',
		'[attr.aria-selected]': 'selected()',
		'[attr.aria-controls]': 'contentId()',
		'[attr.data-state]': "selected() ? 'active' : 'inactive'",
		'[attr.data-orientation]': '_orientation()',
		'[attr.data-disabled]': "disabled ? '' : undefined",
		'(click)': 'activate()',
	},
	exportAs: 'brnTabsTrigger',
})
export class BrnTabsTriggerDirective {
	public readonly elementRef = inject(ElementRef);

	private readonly _root = inject(BrnTabsDirective);

	protected readonly _orientation = this._root.$orientation;

	public readonly triggerFor = input.required<string>({ alias: 'brnTabsTrigger' });
	public readonly selected = computed(() => this._root.$activeTab() === this.triggerFor());
	protected readonly contentId = computed(() => `brn-tabs-content-${this.triggerFor()}`);
	protected readonly labelId = computed(() => `brn-tabs-label-${this.triggerFor()}`);

	// leaving this as an @input to be compatible with the `FocusKeyManager` used in the `BrnTabsListDirective`
	@Input()
	public disabled = false;

	constructor() {
		effect(() => {
			const triggerFor = this.triggerFor();
			untracked(() => this._root.registerTrigger(triggerFor, this));
		});
	}

	public focus() {
		this.elementRef.nativeElement.focus();
		if (this._root.$activationMode() === 'automatic') {
			this.activate();
		}
	}

	public activate() {
		if (!this.triggerFor()) return;
		this._root.setActiveTab(this.triggerFor());
		this._root.emitTabActivated(this.triggerFor());
	}

	public get key(): string | undefined {
		return this.triggerFor();
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/date-time/README.md
```
# @spartan-ng/brain/date-time

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/date-time`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/date-time/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/date-time/src/index.ts
```typescript
export * from './lib/date-adapter';
export * from './lib/native-date-adapter';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/date-time/src/lib/date-adapter.ts
```typescript
import { ClassProvider, InjectionToken, Type, inject } from '@angular/core';
import { BrnNativeDateAdapter } from './native-date-adapter';

/**
 * An abstraction that can be used to create and modify date time objects
 * immutably regardless of the underlying implementation.
 */
export interface BrnDateAdapter<T> {
	/**
	 * Create a new date time object.
	 */
	create(values: BrnDateUnits): T;

	/**
	 * Create a new date with the current date and time.
	 */
	now(): T;

	/**
	 * Set the year of the date time object based on a duration.
	 */
	set(date: T, values: BrnDateUnits): T;

	/**
	 * Add a duration to the date time object.
	 */
	add(date: T, duration: BrnDuration): T;

	/**
	 * Subtract a duration from the date time object.
	 */
	subtract(date: T, duration: BrnDuration): T;

	/**
	 * Compare two date time objects.
	 */
	compare(a: T, b: T): number;

	/**
	 * Determine if two date time objects are equal.
	 */
	isEqual(a: T, b: T): boolean;

	/**
	 * Determine if a date time object is before another.
	 */
	isBefore(a: T, b: T): boolean;

	/**
	 * Determine if a date time object is after another.
	 */
	isAfter(a: T, b: T): boolean;

	/**
	 * Determine if two date objects are on the same day.
	 */
	isSameDay(a: T, b: T): boolean;

	/**
	 * Determine if two date objects are on the same month.
	 */
	isSameMonth(a: T, b: T): boolean;

	/**
	 * Determine if two date objects are on the same year.
	 */
	isSameYear(a: T, b: T): boolean;

	/**
	 * Get the year.
	 */
	getYear(date: T): number;

	/**
	 * Get the month.
	 */
	getMonth(date: T): number;

	/**
	 * Get the date.
	 */
	getDate(date: T): number;

	/**
	 * Get the day.
	 */
	getDay(date: T): number;

	/**
	 * Get the hours.
	 */
	getHours(date: T): number;

	/**
	 * Get the minutes.
	 */
	getMinutes(date: T): number;

	/**
	 * Get the seconds.
	 */
	getSeconds(date: T): number;

	/**
	 * Get the milliseconds.
	 */
	getMilliseconds(date: T): number;

	/**
	 * Get the time.
	 */
	getTime(date: T): number;

	/**
	 * Get the first day of the month.
	 */
	startOfMonth(date: T): T;

	/**
	 * Get the last day of the month.
	 */
	endOfMonth(date: T): T;

	/**
	 * Get the start of the day.
	 */
	startOfDay(date: T): T;

	/**
	 * Get the end of the day.
	 */
	endOfDay(date: T): T;
}

export interface BrnDateUnits {
	/**
	 * The year.
	 */
	year?: number;

	/**
	 * The month.
	 */
	month?: number;

	/**
	 * The day.
	 */
	day?: number;

	/**
	 * The hour.
	 */
	hour?: number;

	/**
	 * The minute.
	 */
	minute?: number;

	/**
	 * The second.
	 */
	second?: number;

	/**
	 * The millisecond.
	 */
	millisecond?: number;
}

export interface BrnDuration {
	/**
	 * The years.
	 */
	years?: number;

	/**
	 * The months.
	 */
	months?: number;

	/**
	 * The days.
	 */
	days?: number;

	/**
	 * The hours.
	 */
	hours?: number;

	/**
	 * The minutes.
	 */
	minutes?: number;

	/**
	 * The seconds.
	 */
	seconds?: number;

	/**
	 * The milliseconds.
	 */
	milliseconds?: number;
}

export const BrnDateAdapterToken = new InjectionToken<BrnDateAdapter<unknown>>('BrnDateAdapterToken');

/**
 * Inject the DateAdapter instance
 */
export function injectDateAdapter<T>(): BrnDateAdapter<T> {
	return (inject(BrnDateAdapterToken, { optional: true }) as BrnDateAdapter<T>) ?? new BrnNativeDateAdapter();
}

/**
 * Provide the DateAdapter instance
 */
export function provideDateAdapter<T>(adapter: Type<BrnDateAdapter<T>>): ClassProvider {
	return { provide: BrnDateAdapterToken, useClass: adapter };
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/date-time/src/lib/native-date-adapter.ts
```typescript
import type { BrnDateAdapter, BrnDateUnits, BrnDuration } from './date-adapter';

export class BrnNativeDateAdapter implements BrnDateAdapter<Date> {
	/**
	 * Create a new date time object.
	 */
	create({ day, hour, minute, month, second, year, millisecond }: BrnDateUnits): Date {
		const now = new Date();

		return new Date(
			year ?? now.getFullYear(),
			month ?? now.getMonth(),
			day ?? now.getDate(),
			hour ?? now.getHours(),
			minute ?? now.getMinutes(),
			second ?? now.getSeconds(),
			millisecond ?? now.getMilliseconds(),
		);
	}

	/**
	 * Create a new date with the current date and time.
	 */
	now(): Date {
		return new Date();
	}

	/**
	 * Set the year of the date time object based on a duration.
	 */
	set(date: Date, values: BrnDateUnits): Date {
		return new Date(
			values.year ?? date.getFullYear(),
			values.month ?? date.getMonth(),
			values.day ?? date.getDate(),
			values.hour ?? date.getHours(),
			values.minute ?? date.getMinutes(),
			values.second ?? date.getSeconds(),
			values.millisecond ?? date.getMilliseconds(),
		);
	}

	/**
	 * Add a duration to the date time object.
	 */
	add(date: Date, duration: BrnDuration): Date {
		return new Date(
			date.getFullYear() + (duration.years ?? 0),
			date.getMonth() + (duration.months ?? 0),
			date.getDate() + (duration.days ?? 0),
			date.getHours() + (duration.hours ?? 0),
			date.getMinutes() + (duration.minutes ?? 0),
			date.getSeconds() + (duration.seconds ?? 0),
			date.getMilliseconds() + (duration.milliseconds ?? 0),
		);
	}

	/**
	 * Subtract a duration from the date time object
	 */
	subtract(date: Date, duration: BrnDuration): Date {
		return new Date(
			date.getFullYear() - (duration.years ?? 0),
			date.getMonth() - (duration.months ?? 0),
			date.getDate() - (duration.days ?? 0),
			date.getHours() - (duration.hours ?? 0),
			date.getMinutes() - (duration.minutes ?? 0),
			date.getSeconds() - (duration.seconds ?? 0),
			date.getMilliseconds() - (duration.milliseconds ?? 0),
		);
	}

	/**
	 * Compare two date time objects
	 */
	compare(a: Date, b: Date): number {
		const diff = a.getTime() - b.getTime();
		return diff === 0 ? 0 : diff > 0 ? 1 : -1;
	}

	/**
	 * Determine if two date time objects are equal.
	 */
	isEqual(a: Date, b: Date): boolean {
		return a.getTime() === b.getTime();
	}

	/**
	 * Determine if a date time object is before another.
	 */
	isBefore(a: Date, b: Date): boolean {
		return a.getTime() < b.getTime();
	}

	/**
	 * Determine if a date time object is after another.
	 */
	isAfter(a: Date, b: Date): boolean {
		return a.getTime() > b.getTime();
	}

	/**
	 * Determine if two date objects are on the same day.
	 */
	isSameDay(a: Date, b: Date): boolean {
		return this.isSameYear(a, b) && this.isSameMonth(a, b) && a.getDate() === b.getDate();
	}

	/**
	 * Determine if two date objects are on the same month.
	 */
	isSameMonth(a: Date, b: Date): boolean {
		return this.isSameYear(a, b) && a.getMonth() === b.getMonth();
	}

	/**
	 * Determine if two date objects are on the same year.
	 */
	isSameYear(a: Date, b: Date): boolean {
		return a.getFullYear() === b.getFullYear();
	}

	/**
	 * Get the year.
	 */
	getYear(date: Date): number {
		return date.getFullYear();
	}

	/**
	 * Get the month.
	 */
	getMonth(date: Date): number {
		return date.getMonth();
	}

	/**
	 * Get the day.
	 */
	getDay(date: Date): number {
		return date.getDay();
	}

	/**
	 * Get the date.
	 */
	getDate(date: Date): number {
		return date.getDate();
	}

	/**
	 * Get the hours.
	 */
	getHours(date: Date): number {
		return date.getHours();
	}

	/**
	 * Get the minutes.
	 */
	getMinutes(date: Date): number {
		return date.getMinutes();
	}

	/**
	 * Get the seconds.
	 */
	getSeconds(date: Date): number {
		return date.getSeconds();
	}

	/**
	 * Get the milliseconds.
	 */
	getMilliseconds(date: Date): number {
		return date.getMilliseconds();
	}

	/**
	 * Get the first day of the month.
	 */
	startOfMonth(date: Date): Date {
		return new Date(date.getFullYear(), date.getMonth(), 1);
	}

	/**
	 * Get the last day of the month.
	 */
	endOfMonth(date: Date): Date {
		return new Date(date.getFullYear(), date.getMonth() + 1, 0);
	}

	/**
	 * Get the start of the day.
	 */
	startOfDay(date: Date): Date {
		return new Date(date.getFullYear(), date.getMonth(), date.getDate());
	}

	/**
	 * Get the end of the day.
	 */
	endOfDay(date: Date): Date {
		return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 23, 59, 59, 999);
	}

	/**
	 * Get the time.
	 */
	getTime(date: Date): number {
		return date.getTime();
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/tooltip/README.md
```
# @spartan-ng/brain/tooltip

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/tooltip`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/tooltip/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/tooltip/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { BrnTooltipContentComponent } from './lib/brn-tooltip-content.component';
import { BrnTooltipContentDirective } from './lib/brn-tooltip-content.directive';
import { BrnTooltipTriggerDirective } from './lib/brn-tooltip-trigger.directive';
import { BrnTooltipDirective } from './lib/brn-tooltip.directive';

export * from './lib/brn-tooltip-content.component';
export * from './lib/brn-tooltip-content.directive';
export * from './lib/brn-tooltip-trigger.directive';
export * from './lib/brn-tooltip.directive';
export * from './lib/brn-tooltip.token';

export const BrnTooltipImports = [
	BrnTooltipDirective,
	BrnTooltipContentDirective,
	BrnTooltipTriggerDirective,
	BrnTooltipContentComponent,
] as const;

@NgModule({
	imports: [...BrnTooltipImports],
	exports: [...BrnTooltipImports],
})
export class BrnTooltipModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/tooltip/src/lib/brn-tooltip-content.component.ts
```typescript
/**
 * We are building on shoulders of giants here and adapt the implementation provided by the incredible Angular
 * team: https://github.com/angular/components/blob/main/src/material/tooltip/tooltip.ts
 * Check them out! Give them a try! Leave a star! Their work is incredible!
 */

import { isPlatformBrowser, NgTemplateOutlet } from '@angular/common';
import {
	ChangeDetectionStrategy,
	ChangeDetectorRef,
	Component,
	ElementRef,
	inject,
	type OnDestroy,
	PLATFORM_ID,
	Renderer2,
	signal,
	type TemplateRef,
	viewChild,
	ViewEncapsulation,
} from '@angular/core';
import { Subject } from 'rxjs';

/**
 * Internal component that wraps the tooltip's content.
 * @docs-private
 */
@Component({
	selector: 'brn-tooltip-content',
	template: `
		<div
			(mouseenter)="_contentHovered.set(true)"
			(mouseleave)="_contentHovered.set(false)"
			[class]="_tooltipClasses()"
			[style.visibility]="'hidden'"
			#tooltip
		>
			@if (_isTypeOfString(content)) {
				{{ content }}
			} @else {
				<ng-container [ngTemplateOutlet]="content" />
			}
		</div>
	`,
	encapsulation: ViewEncapsulation.None,
	changeDetection: ChangeDetectionStrategy.OnPush,
	host: {
		// Forces the element to have a layout in IE and Edge. This fixes issues where the element
		// won't be rendered if the animations are disabled or there is no web animations polyfill.
		'[style.zoom]': 'isVisible() ? 1 : null',
		'(mouseleave)': '_handleMouseLeave($event)',
		'aria-hidden': 'true',
	},
	imports: [NgTemplateOutlet],
})
export class BrnTooltipContentComponent implements OnDestroy {
	private readonly _cdr = inject(ChangeDetectorRef);
	private readonly _isBrowser = isPlatformBrowser(inject(PLATFORM_ID));
	private readonly _renderer2 = inject(Renderer2);

	protected readonly _contentHovered = signal(false);

	public readonly _tooltipClasses = signal('');
	public readonly side = signal('above');
	/** Message to display in the tooltip */
	public content: string | TemplateRef<unknown> | null = null;

	/** The timeout ID of any current timer set to show the tooltip */
	private _showTimeoutId: ReturnType<typeof setTimeout> | undefined;
	/** The timeout ID of any current timer set to hide the tooltip */
	private _hideTimeoutId: ReturnType<typeof setTimeout> | undefined;
	/** The timeout ID of any current timer set to animate the tooltip */
	private _animateTimeoutId: ReturnType<typeof setTimeout> | undefined;

	/** Element that caused the tooltip to open. */
	public _triggerElement?: HTMLElement;

	/** Amount of milliseconds to delay the closing sequence. */
	public _mouseLeaveHideDelay = 0;
	/** Amount of milliseconds of closing animation. */
	public _exitAnimationDuration = 0;

	/** Reference to the internal tooltip element. */
	public _tooltip = viewChild('tooltip', { read: ElementRef<HTMLElement> });

	/** Whether interactions on the page should close the tooltip */
	private _closeOnInteraction = false;

	/** Whether the tooltip is currently visible. */
	private _isVisible = false;

	/** Subject for notifying that the tooltip has been hidden from the view */
	private readonly _onHide: Subject<void> = new Subject();
	public readonly afterHidden = this._onHide.asObservable();

	/**
	 * Shows the tooltip with originating from the provided origin
	 * @param delay Amount of milliseconds to the delay showing the tooltip.
	 */
	show(delay: number): void {
		// Cancel the delayed hide if it is scheduled
		if (this._hideTimeoutId !== null) {
			clearTimeout(this._hideTimeoutId);
		}
		if (this._animateTimeoutId !== null) {
			clearTimeout(this._animateTimeoutId);
		}
		this._showTimeoutId = setTimeout(() => {
			this._toggleDataAttributes(true, this.side());
			this._toggleVisibility(true);
			this._showTimeoutId = undefined;
		}, delay);
	}

	/**
	 * Begins to hide the tooltip after the provided delay in ms.
	 * @param delay Amount of milliseconds to delay hiding the tooltip.
	 * @param exitAnimationDuration Time before hiding to finish animation
	 * */
	hide(delay: number, exitAnimationDuration: number): void {
		// Cancel the delayed show if it is scheduled
		if (this._showTimeoutId !== null) {
			clearTimeout(this._showTimeoutId);
		}
		// start out animation at delay minus animation delay or immediately if possible
		this._animateTimeoutId = setTimeout(
			() => {
				this._animateTimeoutId = undefined;
				if (this._contentHovered()) return;
				this._toggleDataAttributes(false, this.side());
			},
			Math.max(delay, 0),
		);
		this._hideTimeoutId = setTimeout(() => {
			this._hideTimeoutId = undefined;
			if (this._contentHovered()) return;
			this._toggleVisibility(false);
		}, delay + exitAnimationDuration);
	}

	/** Whether the tooltip is being displayed. */
	isVisible(): boolean {
		return this._isVisible;
	}

	ngOnDestroy() {
		this._cancelPendingAnimations();
		this._onHide.complete();
		this._triggerElement = undefined;
	}

	_isTypeOfString(content: unknown): content is string {
		return typeof content === 'string';
	}

	/**
	 * Interactions on the HTML body should close the tooltip immediately as defined in the
	 * material design spec.
	 * https://material.io/design/components/tooltips.html#behavior
	 */
	_handleBodyInteraction(): void {
		if (this._closeOnInteraction) {
			this.hide(0, 0);
		}
	}

	/**
	 * Marks that the tooltip needs to be checked in the next change detection run.
	 * Mainly used for rendering the initial text before positioning a tooltip, which
	 * can be problematic in components with OnPush change detection.
	 */
	_markForCheck(): void {
		this._cdr.markForCheck();
	}

	_handleMouseLeave({ relatedTarget }: MouseEvent) {
		if (!relatedTarget || !this._triggerElement?.contains(relatedTarget as Node)) {
			if (this.isVisible()) {
				this.hide(this._mouseLeaveHideDelay, this._exitAnimationDuration);
			} else {
				this._finalize(false);
			}
		}
		this._contentHovered.set(false);
	}

	/** Cancels any pending animation sequences. */
	_cancelPendingAnimations() {
		if (this._showTimeoutId !== null) {
			clearTimeout(this._showTimeoutId);
		}

		if (this._hideTimeoutId !== null) {
			clearTimeout(this._hideTimeoutId);
		}

		this._showTimeoutId = this._hideTimeoutId = undefined;
	}

	private _finalize(toVisible: boolean) {
		if (toVisible) {
			this._closeOnInteraction = true;
		} else if (!this.isVisible()) {
			this._onHide.next();
		}
	}

	/** Toggles the visibility of the tooltip element. */
	private _toggleVisibility(isVisible: boolean) {
		// We set the classes directly here ourselves so that toggling the tooltip state
		// isn't bound by change detection. This allows us to hide it even if the
		// view ref has been detached from the CD tree.
		const tooltip = this._tooltip()?.nativeElement;
		if (!tooltip || !this._isBrowser) return;
		this._renderer2.setStyle(tooltip, 'visibility', isVisible ? 'visible' : 'hidden');
		if (isVisible) {
			this._renderer2.removeStyle(tooltip, 'display');
		} else {
			this._renderer2.setStyle(tooltip, 'display', 'none');
		}
		this._isVisible = isVisible;
	}

	private _toggleDataAttributes(isVisible: boolean, side: string) {
		// We set the classes directly here ourselves so that toggling the tooltip state
		// isn't bound by change detection. This allows us to hide it even if the
		// view ref has been detached from the CD tree.
		const tooltip = this._tooltip()?.nativeElement;
		if (!tooltip || !this._isBrowser) return;
		this._renderer2.setAttribute(tooltip, 'data-side', side);
		this._renderer2.setAttribute(tooltip, 'data-state', isVisible ? 'open' : 'closed');
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/tooltip/src/lib/brn-tooltip-content.directive.ts
```typescript
import { Directive, TemplateRef, inject } from '@angular/core';
import { BrnTooltipDirective } from './brn-tooltip.directive';

@Directive({
	selector: '[brnTooltipContent]',
	standalone: true,
})
export class BrnTooltipContentDirective {
	private readonly _brnTooltipDirective = inject(BrnTooltipDirective, { optional: true });
	private readonly _tpl = inject(TemplateRef);

	constructor() {
		if (!this._brnTooltipDirective || !this._tpl) return;
		this._brnTooltipDirective.tooltipTemplate.set(this._tpl);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/tooltip/src/lib/brn-tooltip-trigger.directive.ts
```typescript
/**
 * We are building on shoulders of giants here and adapt the implementation provided by the incredible Angular
 * team: https://github.com/angular/components/blob/main/src/material/tooltip/tooltip.ts
 * Check them out! Give them a try! Leave a star! Their work is incredible!
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { AriaDescriber, FocusMonitor } from '@angular/cdk/a11y';
import { Directionality } from '@angular/cdk/bidi';
import { hasModifierKey } from '@angular/cdk/keycodes';
import {
	type ConnectedPosition,
	type ConnectionPositionPair,
	type FlexibleConnectedPositionStrategy,
	type HorizontalConnectionPos,
	type OriginConnectionPosition,
	Overlay,
	type OverlayConnectionPosition,
	type OverlayRef,
	ScrollDispatcher,
	type ScrollStrategy,
	type VerticalConnectionPos,
} from '@angular/cdk/overlay';
import { normalizePassiveListenerOptions, Platform } from '@angular/cdk/platform';
import { ComponentPortal } from '@angular/cdk/portal';
import { DOCUMENT } from '@angular/common';
import {
	type AfterViewInit,
	booleanAttribute,
	computed,
	Directive,
	effect,
	ElementRef,
	inject,
	InjectionToken,
	input,
	isDevMode,
	NgZone,
	numberAttribute,
	type OnDestroy,
	type Provider,
	signal,
	type TemplateRef,
	untracked,
	ViewContainerRef,
} from '@angular/core';
import { brnDevMode } from '@spartan-ng/brain/core';
import { Subject } from 'rxjs';
import { take, takeUntil } from 'rxjs/operators';
import { BrnTooltipContentComponent } from './brn-tooltip-content.component';
import { BrnTooltipDirective } from './brn-tooltip.directive';
import { injectBrnTooltipDefaultOptions } from './brn-tooltip.token';
import { computedPrevious } from './computed-previous';

export type TooltipPosition = 'left' | 'right' | 'above' | 'below' | 'before' | 'after';
export type TooltipTouchGestures = 'auto' | 'on' | 'off';

/** Time in ms to throttle repositioning after scroll events. */
export const SCROLL_THROTTLE_MS = 20;

export function getBrnTooltipInvalidPositionError(position: string) {
	return Error(`Tooltip position "${position}" is invalid.`);
}

/** Injection token that determines the scroll handling while a tooltip is visible. */
export const BRN_TOOLTIP_SCROLL_STRATEGY = new InjectionToken<() => ScrollStrategy>('brn-tooltip-scroll-strategy');
export const BRN_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER: Provider = {
	provide: BRN_TOOLTIP_SCROLL_STRATEGY,
	deps: [Overlay],
	useFactory:
		(overlay: Overlay): (() => ScrollStrategy) =>
		() =>
			overlay.scrollStrategies.reposition({ scrollThrottle: SCROLL_THROTTLE_MS }),
};

const PANEL_CLASS = 'tooltip-panel';

/** Options used to bind passive event listeners. */
const passiveListenerOptions = normalizePassiveListenerOptions({ passive: true });

/**
 * Time between the user putting the pointer on a tooltip
 * trigger and the long press event being fired.
 */
const LONGPRESS_DELAY = 500;

// These constants were taken from MDC's `numbers` object.
const MIN_VIEWPORT_TOOLTIP_THRESHOLD = 8;
const UNBOUNDED_ANCHOR_GAP = 8;

@Directive({
	selector: '[brnTooltipTrigger]',
	standalone: true,
	exportAs: 'brnTooltipTrigger',
	providers: [BRN_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER],
	host: {
		class: 'brn-tooltip-trigger',
		'[class.brn-tooltip-disabled]': 'brnTooltipDisabled()',
	},
})
export class BrnTooltipTriggerDirective implements OnDestroy, AfterViewInit {
	private readonly _tooltipDirective = inject(BrnTooltipDirective, { optional: true });
	private readonly _tooltipComponent = BrnTooltipContentComponent;
	private readonly _cssClassPrefix: string = 'brn';
	private readonly _destroyed = new Subject<void>();
	private readonly _passiveListeners: (readonly [string, EventListenerOrEventListenerObject])[] = [];
	private readonly _defaultOptions = injectBrnTooltipDefaultOptions();

	private readonly _overlay = inject(Overlay);
	private readonly _elementRef = inject(ElementRef<HTMLElement>);
	private readonly _scrollDispatcher = inject(ScrollDispatcher);
	private readonly _viewContainerRef = inject(ViewContainerRef);
	private readonly _ngZone = inject(NgZone);
	private readonly _platform = inject(Platform);
	private readonly _ariaDescriber = inject(AriaDescriber);
	private readonly _focusMonitor = inject(FocusMonitor);
	private readonly _dir = inject(Directionality);
	private readonly _scrollStrategy = inject(BRN_TOOLTIP_SCROLL_STRATEGY);
	private readonly _document = inject(DOCUMENT);

	private _portal?: ComponentPortal<BrnTooltipContentComponent>;
	private _viewInitialized = false;
	private _pointerExitEventsInitialized = false;
	private readonly _viewportMargin = 8;
	private _currentPosition?: TooltipPosition;
	private _touchstartTimeout?: ReturnType<typeof setTimeout>;

	private _overlayRef: OverlayRef | null = null;
	private _tooltipInstance: BrnTooltipContentComponent | null = null;

	/** Allows the user to define the position of the tooltip relative to the parent element */

	public readonly position = input<TooltipPosition>(this._defaultOptions?.position ?? 'above');

	/**
	 * Whether tooltip should be relative to the click or touch origin
	 * instead of outside the element bounding box.
	 */

	public readonly positionAtOrigin = input(this._defaultOptions?.positionAtOrigin ?? false, {
		transform: booleanAttribute,
	});

	/** Disables the display of the tooltip. */

	public readonly brnTooltipDisabled = input(false, { transform: booleanAttribute });

	/** The default delay in ms before showing the tooltip after show is called */

	public readonly showDelay = input(this._defaultOptions?.showDelay ?? 0, { transform: numberAttribute });

	/** The default delay in ms before hiding the tooltip after hide is called */

	public readonly hideDelay = input(this._defaultOptions?.hideDelay ?? 0, { transform: numberAttribute });

	/** The default duration in ms that exit animation takes before hiding */

	public readonly exitAnimationDuration = input(this._defaultOptions?.exitAnimationDuration ?? 0, {
		transform: numberAttribute,
	});

	/** The default delay in ms before hiding the tooltip after hide is called */

	public readonly _tooltipContentClasses = input<string>(this._defaultOptions?.tooltipContentClasses ?? '', {
		alias: 'tooltipContentClasses',
	});
	public readonly tooltipContentClasses = computed(() => signal(this._tooltipContentClasses()));

	/**
	 * How touch gestures should be handled by the tooltip. On touch devices the tooltip directive
	 * uses a long press gesture to show and hide, however it can conflict with the native browser
	 * gestures. To work around the conflict, Angular Material disables native gestures on the
	 * trigger, but that might not be desirable on particular elements (e.g. inputs and draggable
	 * elements). The different values for this option configure the touch event handling as follows:
	 * - `auto` - Enables touch gestures for all elements, but tries to avoid conflicts with native
	 *   browser gestures on particular elements. In particular, it allows text selection on inputs
	 *   and textareas, and preserves the native browser dragging on elements marked as `draggable`.
	 * - `on` - Enables touch gestures for all elements and disables native
	 *   browser gestures with no exceptions.
	 * - `off` - Disables touch gestures. Note that this will prevent the tooltip from
	 *   showing on touch devices.
	 */

	public readonly touchGestures = input<TooltipTouchGestures>(this._defaultOptions?.touchGestures ?? 'auto');

	/** The message to be used to describe the aria in the tooltip */

	public readonly _ariaDescribedBy = input('', { alias: 'aria-describedby' });
	public readonly ariaDescribedBy = computed(() => signal(this._ariaDescribedBy()));
	public readonly ariaDescribedByPrevious = computedPrevious(this.ariaDescribedBy);

	/** The content to be displayed in the tooltip */

	public readonly brnTooltipTrigger = input<string | TemplateRef<unknown> | null>(null);
	public readonly brnTooltipTriggerState = computed(() => {
		if (this._tooltipDirective) {
			return this._tooltipDirective.tooltipTemplate();
		}
		return this.brnTooltipTrigger();
	});

	constructor() {
		this._dir.change.pipe(takeUntil(this._destroyed)).subscribe(() => {
			if (this._overlayRef) {
				this._updatePosition(this._overlayRef);
			}
		});

		this._viewportMargin = MIN_VIEWPORT_TOOLTIP_THRESHOLD;

		this._initBrnTooltipTriggerEffect();
		this._initAriaDescribedByPreviousEffect();
		this._initTooltipContentClassesEffect();
		this._initPositionEffect();
		this._initPositionAtOriginEffect();
		this._initBrnTooltipDisabledEffect();
		this._initExitAnimationDurationEffect();
		this._initHideDelayEffect();
	}
	setTooltipContentClasses(tooltipContentClasses: string) {
		this.tooltipContentClasses().set(tooltipContentClasses);
	}
	setAriaDescribedBy(ariaDescribedBy: string) {
		this.ariaDescribedBy().set(ariaDescribedBy);
	}

	private _initPositionEffect(): void {
		effect(() => {
			if (this._overlayRef) {
				this._updatePosition(this._overlayRef);
				this._tooltipInstance?.show(0);
				this._overlayRef.updatePosition();
			}
		});
	}

	private _initBrnTooltipDisabledEffect(): void {
		effect(() => {
			if (this.brnTooltipDisabled()) {
				this.hide(0);
			} else {
				this._setupPointerEnterEventsIfNeeded();
			}
		});
	}

	private _initPositionAtOriginEffect(): void {
		effect(() => {
			// Needed that the effect got triggered
			// eslint-disable-next-line @typescript-eslint/naming-convention
			const _ = this.positionAtOrigin();
			this._detach();
			this._overlayRef = null;
		});
	}

	private _initTooltipContentClassesEffect(): void {
		effect(() => {
			if (this._tooltipInstance) {
				this._tooltipInstance._tooltipClasses.set(this.tooltipContentClasses()() ?? '');
			}
		});
	}

	private _initAriaDescribedByPreviousEffect(): void {
		effect(() => {
			const ariaDescribedBy = this.ariaDescribedBy()();
			this._ariaDescriber.removeDescription(
				this._elementRef.nativeElement,
				untracked(() => this.ariaDescribedByPrevious()()),
				'tooltip',
			);

			if (ariaDescribedBy && !this._isTooltipVisible()) {
				this._ngZone.runOutsideAngular(() => {
					// The `AriaDescriber` has some functionality that avoids adding a description if it's the
					// same as the `aria-label` of an element, however we can't know whether the tooltip trigger
					// has a data-bound `aria-label` or when it'll be set for the first time. We can avoid the
					// issue by deferring the description by a tick so Angular has time to set the `aria-label`.
					Promise.resolve().then(() => {
						this._ariaDescriber.describe(this._elementRef.nativeElement, ariaDescribedBy, 'tooltip');
					});
				});
			}
		});
	}

	private _initBrnTooltipTriggerEffect(): void {
		effect(() => {
			const brnTooltipTriggerState = this.brnTooltipTriggerState();
			const isTooltipVisible = this._isTooltipVisible();
			untracked(() => {
				if (!brnTooltipTriggerState && isTooltipVisible) {
					this.hide(0);
				} else {
					this._setupPointerEnterEventsIfNeeded();
					this._updateTooltipContent();
				}
			});
		});
	}

	private _initExitAnimationDurationEffect(): void {
		effect(() => {
			if (this._tooltipInstance) {
				this._tooltipInstance._exitAnimationDuration = this.exitAnimationDuration();
			}
		});
	}

	private _initHideDelayEffect(): void {
		effect(() => {
			if (this._tooltipInstance) {
				this._tooltipInstance._mouseLeaveHideDelay = this.hideDelay();
			}
		});
	}

	ngAfterViewInit(): void {
		// This needs to happen after view init so the initial values for all inputs have been set.
		this._viewInitialized = true;
		this._setupPointerEnterEventsIfNeeded();

		this._focusMonitor
			.monitor(this._elementRef)
			.pipe(takeUntil(this._destroyed))
			.subscribe((origin) => {
				// Note that the focus monitor runs outside the Angular zone.
				if (!origin) {
					this._ngZone.run(() => this.hide(0));
				} else if (origin === 'keyboard') {
					this._ngZone.run(() => this.show());
				}
			});

		if (brnDevMode && !this.ariaDescribedBy()) {
			console.warn('BrnTooltip: "aria-describedby" attribute is required for accessibility');
		}
	}

	/**
	 * Dispose the tooltip when destroyed.
	 */
	ngOnDestroy(): void {
		const nativeElement = this._elementRef.nativeElement;

		clearTimeout(this._touchstartTimeout);

		if (this._overlayRef) {
			this._overlayRef.dispose();
			this._tooltipInstance = null;
		}

		// Clean up the event listeners set in the constructor
		this._passiveListeners.forEach(([event, listener]) =>
			nativeElement.removeEventListener(event, listener, passiveListenerOptions),
		);
		this._passiveListeners.length = 0;

		this._destroyed.next();
		this._destroyed.complete();

		this._ariaDescriber.removeDescription(nativeElement, this.ariaDescribedBy()(), 'tooltip');
		this._focusMonitor.stopMonitoring(nativeElement);
	}

	/** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */
	show(delay: number = this.showDelay(), origin?: { x: number; y: number }): void {
		if (this.brnTooltipDisabled() || this._isTooltipVisible()) {
			this._tooltipInstance?._cancelPendingAnimations();
			return;
		}

		const overlayRef = this._createOverlay(origin);
		this._detach();
		this._portal = this._portal || new ComponentPortal(this._tooltipComponent, this._viewContainerRef);
		const instance = (this._tooltipInstance = overlayRef.attach(this._portal).instance);
		instance._triggerElement = this._elementRef.nativeElement;
		instance._mouseLeaveHideDelay = this.hideDelay();
		instance._tooltipClasses.set(this.tooltipContentClasses()());
		instance._exitAnimationDuration = this.exitAnimationDuration();
		instance.side.set(this._currentPosition ?? 'above');
		instance.afterHidden.pipe(takeUntil(this._destroyed)).subscribe(() => this._detach());
		this._updateTooltipContent();
		instance.show(delay);
	}

	/** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */
	hide(delay: number = this.hideDelay(), exitAnimationDuration: number = this.exitAnimationDuration()): void {
		const instance = this._tooltipInstance;
		if (instance) {
			if (instance.isVisible()) {
				instance.hide(delay, exitAnimationDuration);
			} else {
				instance._cancelPendingAnimations();
				this._detach();
			}
		}
	}

	toggle(origin?: { x: number; y: number }): void {
		this._isTooltipVisible() ? this.hide() : this.show(undefined, origin);
	}

	_isTooltipVisible(): boolean {
		return !!this._tooltipInstance && this._tooltipInstance.isVisible();
	}

	private _createOverlay(origin?: { x: number; y: number }): OverlayRef {
		if (this._overlayRef) {
			const existingStrategy = this._overlayRef.getConfig().positionStrategy as FlexibleConnectedPositionStrategy;

			if ((!this.positionAtOrigin() || !origin) && existingStrategy._origin instanceof ElementRef) {
				return this._overlayRef;
			}

			this._detach();
		}

		const scrollableAncestors = this._scrollDispatcher.getAncestorScrollContainers(this._elementRef);

		// Create connected position strategy that listens for scroll events to reposition.
		const strategy = this._overlay
			.position()
			.flexibleConnectedTo(this.positionAtOrigin() ? origin || this._elementRef : this._elementRef)
			.withTransformOriginOn(`.${this._cssClassPrefix}-tooltip`)
			.withFlexibleDimensions(false)
			.withViewportMargin(this._viewportMargin)
			.withScrollableContainers(scrollableAncestors);

		strategy.positionChanges.pipe(takeUntil(this._destroyed)).subscribe((change) => {
			this._updateCurrentPositionClass(change.connectionPair);

			if (this._tooltipInstance) {
				if (change.scrollableViewProperties.isOverlayClipped && this._tooltipInstance.isVisible()) {
					// After position changes occur and the overlay is clipped by
					// a parent scrollable then close the tooltip.
					this._ngZone.run(() => this.hide(0));
				}
			}
		});

		this._overlayRef = this._overlay.create({
			direction: this._dir,
			positionStrategy: strategy,
			panelClass: `${this._cssClassPrefix}-${PANEL_CLASS}`,
			scrollStrategy: this._scrollStrategy(),
		});

		this._updatePosition(this._overlayRef);

		this._overlayRef
			.detachments()
			.pipe(takeUntil(this._destroyed))
			.subscribe(() => this._detach());

		this._overlayRef
			.outsidePointerEvents()
			.pipe(takeUntil(this._destroyed))
			.subscribe(() => this._tooltipInstance?._handleBodyInteraction());

		this._overlayRef
			.keydownEvents()
			.pipe(takeUntil(this._destroyed))
			.subscribe((event) => {
				if (this._isTooltipVisible() && event.key === 'Escape' && !hasModifierKey(event)) {
					event.preventDefault();
					event.stopPropagation();
					this._ngZone.run(() => this.hide(0));
				}
			});

		if (this._defaultOptions?.disableTooltipInteractivity) {
			this._overlayRef.addPanelClass(`${this._cssClassPrefix}-tooltip-panel-non-interactive`);
		}

		return this._overlayRef;
	}

	private _detach(): void {
		if (this._overlayRef?.hasAttached()) {
			this._overlayRef.detach();
		}

		this._tooltipInstance = null;
	}

	private _updatePosition(overlayRef: OverlayRef) {
		const position = overlayRef.getConfig().positionStrategy as FlexibleConnectedPositionStrategy;
		const origin = this._getOrigin();
		const overlay = this._getOverlayPosition();

		position.withPositions([
			this._addOffset({ ...origin.main, ...overlay.main }),
			this._addOffset({ ...origin.fallback, ...overlay.fallback }),
		]);
	}

	/** Adds the configured offset to a position. Used as a hook for child classes. */
	protected _addOffset(position: ConnectedPosition): ConnectedPosition {
		const offset = UNBOUNDED_ANCHOR_GAP;
		const isLtr = !this._dir || this._dir.value === 'ltr';

		if (position.originY === 'top') {
			position.offsetY = -offset;
		} else if (position.originY === 'bottom') {
			position.offsetY = offset;
		} else if (position.originX === 'start') {
			position.offsetX = isLtr ? -offset : offset;
		} else if (position.originX === 'end') {
			position.offsetX = isLtr ? offset : -offset;
		}

		return position;
	}

	/**
	 * Returns the origin position and a fallback position based on the user's position preference.
	 * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).
	 */
	_getOrigin(): { main: OriginConnectionPosition; fallback: OriginConnectionPosition } {
		const isLtr = !this._dir || this._dir.value === 'ltr';
		const position = this.position();
		let originPosition: OriginConnectionPosition;

		if (position === 'above' || position === 'below') {
			originPosition = { originX: 'center', originY: position === 'above' ? 'top' : 'bottom' };
		} else if (position === 'before' || (position === 'left' && isLtr) || (position === 'right' && !isLtr)) {
			originPosition = { originX: 'start', originY: 'center' };
		} else if (position === 'after' || (position === 'right' && isLtr) || (position === 'left' && !isLtr)) {
			originPosition = { originX: 'end', originY: 'center' };
		} else if (typeof isDevMode() === 'undefined' || isDevMode()) {
			throw getBrnTooltipInvalidPositionError(position);
		}

		const { x, y } = this._invertPosition(originPosition!.originX, originPosition!.originY);

		return {
			main: originPosition!,
			fallback: { originX: x, originY: y },
		};
	}

	/** Returns the overlay position and a fallback position based on the user's preference */
	_getOverlayPosition(): { main: OverlayConnectionPosition; fallback: OverlayConnectionPosition } {
		const isLtr = !this._dir || this._dir.value === 'ltr';
		const position = this.position();
		let overlayPosition: OverlayConnectionPosition;

		if (position === 'above') {
			overlayPosition = { overlayX: 'center', overlayY: 'bottom' };
		} else if (position === 'below') {
			overlayPosition = { overlayX: 'center', overlayY: 'top' };
		} else if (position === 'before' || (position === 'left' && isLtr) || (position === 'right' && !isLtr)) {
			overlayPosition = { overlayX: 'end', overlayY: 'center' };
		} else if (position === 'after' || (position === 'right' && isLtr) || (position === 'left' && !isLtr)) {
			overlayPosition = { overlayX: 'start', overlayY: 'center' };
		} else if (typeof isDevMode() === 'undefined' || isDevMode()) {
			throw getBrnTooltipInvalidPositionError(position);
		}

		const { x, y } = this._invertPosition(overlayPosition!.overlayX, overlayPosition!.overlayY);

		return {
			main: overlayPosition!,
			fallback: { overlayX: x, overlayY: y },
		};
	}

	/** Updates the tooltip message and repositions the overlay according to the new message length */
	private _updateTooltipContent(): void {
		// Must wait for the template to be painted to the tooltip so that the overlay can properly
		// calculate the correct positioning based on the size of the tek-pate.
		if (this._tooltipInstance) {
			this._tooltipInstance.content = this.brnTooltipTriggerState();
			this._tooltipInstance._markForCheck();

			this._ngZone.onMicrotaskEmpty.pipe(take(1), takeUntil(this._destroyed)).subscribe(() => {
				if (this._tooltipInstance) {
					this._overlayRef?.updatePosition();
				}
			});
		}
	}

	/** Inverts an overlay position. */
	private _invertPosition(x: HorizontalConnectionPos, y: VerticalConnectionPos) {
		if (this.position() === 'above' || this.position() === 'below') {
			if (y === 'top') {
				y = 'bottom';
			} else if (y === 'bottom') {
				y = 'top';
			}
		} else {
			if (x === 'end') {
				x = 'start';
			} else if (x === 'start') {
				x = 'end';
			}
		}

		return { x, y };
	}

	/** Updates the class on the overlay panel based on the current position of the tooltip. */
	private _updateCurrentPositionClass(connectionPair: ConnectionPositionPair): void {
		const { overlayY, originX, originY } = connectionPair;
		let newPosition: TooltipPosition;

		// If the overlay is in the middle along the Y axis,
		// it means that it's either before or after.
		if (overlayY === 'center') {
			// Note that since this information is used for styling, we want to
			// resolve `start` and `end` to their real values, otherwise consumers
			// would have to remember to do it themselves on each consumption.
			if (this._dir && this._dir.value === 'rtl') {
				newPosition = originX === 'end' ? 'left' : 'right';
			} else {
				newPosition = originX === 'start' ? 'left' : 'right';
			}
		} else {
			newPosition = overlayY === 'bottom' && originY === 'top' ? 'above' : 'below';
		}

		if (newPosition !== this._currentPosition) {
			this._tooltipInstance?.side.set(newPosition);
			this._currentPosition = newPosition;
		}
	}

	/** Binds the pointer events to the tooltip trigger. */
	private _setupPointerEnterEventsIfNeeded(): void {
		// Optimization: Defer hooking up events if there's no content or the tooltip is disabled.
		if (
			this.brnTooltipDisabled() ||
			!this.brnTooltipTriggerState() ||
			!this._viewInitialized ||
			this._passiveListeners.length
		) {
			return;
		}

		// The mouse events shouldn't be bound on mobile devices, because they can prevent the
		// first tap from firing its click event or can cause the tooltip to open for clicks.
		if (this._platformSupportsMouseEvents()) {
			this._passiveListeners.push([
				'mouseenter',
				(event) => {
					this._setupPointerExitEventsIfNeeded();
					let point = undefined;
					if ((event as MouseEvent).x !== undefined && (event as MouseEvent).y !== undefined) {
						point = event as MouseEvent;
					}
					this.show(undefined, point);
				},
			]);
		} else if (this.touchGestures() !== 'off') {
			this._disableNativeGesturesIfNecessary();

			this._passiveListeners.push([
				'touchstart',
				(event) => {
					const touch = (event as TouchEvent).targetTouches?.[0];
					const origin = touch ? { x: touch.clientX, y: touch.clientY } : undefined;
					// Note that it's important that we don't `preventDefault` here,
					// because it can prevent click events from firing on the element.
					this._setupPointerExitEventsIfNeeded();
					clearTimeout(this._touchstartTimeout);
					this._touchstartTimeout = setTimeout(() => this.show(undefined, origin), LONGPRESS_DELAY);
				},
			]);
		}

		this._addListeners(this._passiveListeners);
	}

	private _setupPointerExitEventsIfNeeded(): void {
		if (this._pointerExitEventsInitialized) {
			return;
		}
		this._pointerExitEventsInitialized = true;

		const exitListeners: (readonly [string, EventListenerOrEventListenerObject])[] = [];
		if (this._platformSupportsMouseEvents()) {
			exitListeners.push(
				[
					'mouseleave',
					(event) => {
						const newTarget = (event as MouseEvent).relatedTarget as Node | null;
						if (!newTarget || !this._overlayRef?.overlayElement.contains(newTarget)) {
							this.hide();
						}
					},
				],
				['wheel', (event) => this._wheelListener(event as WheelEvent)],
			);
		} else if (this.touchGestures() !== 'off') {
			this._disableNativeGesturesIfNecessary();
			const touchendListener = () => {
				clearTimeout(this._touchstartTimeout);
				this.hide(this._defaultOptions?.touchendHideDelay);
			};

			exitListeners.push(['touchend', touchendListener], ['touchcancel', touchendListener]);
		}

		this._addListeners(exitListeners);
		this._passiveListeners.push(...exitListeners);
	}

	private _addListeners(listeners: (readonly [string, EventListenerOrEventListenerObject])[]) {
		listeners.forEach(([event, listener]) => {
			this._elementRef.nativeElement.addEventListener(event, listener, passiveListenerOptions);
		});
	}

	private _platformSupportsMouseEvents(): boolean {
		return !this._platform.IOS && !this._platform.ANDROID;
	}

	/** Listener for the `wheel` event on the element. */
	private _wheelListener(event: WheelEvent) {
		if (this._isTooltipVisible()) {
			const elementUnderPointer = this._document.elementFromPoint(event.clientX, event.clientY);
			const element = this._elementRef.nativeElement;

			// On non-touch devices we depend on the `mouseleave` event to close the tooltip, but it
			// won't fire if the user scrolls away using the wheel without moving their cursor. We
			// work around it by finding the element under the user's cursor and closing the tooltip
			// if it's not the trigger.
			if (elementUnderPointer !== element && !element.contains(elementUnderPointer)) {
				this.hide();
			}
		}
	}

	/** Disables the native browser gestures, based on how the tooltip has been configured. */
	private _disableNativeGesturesIfNecessary(): void {
		const gestures = this.touchGestures();

		if (gestures !== 'off') {
			const element = this._elementRef.nativeElement;
			const style = element.style;

			// If gestures are set to `auto`, we don't disable text selection on inputs and
			// textareas, because it prevents the user from typing into them on iOS Safari.
			if (gestures === 'on' || (element.nodeName !== 'INPUT' && element.nodeName !== 'TEXTAREA')) {
				// eslint-disable-next-line @typescript-eslint/no-explicit-any
				style.userSelect = (style as any).msUserSelect = style.webkitUserSelect = (style as any).MozUserSelect = 'none';
			}

			// If we have `auto` gestures and the element uses native HTML dragging,
			// we don't set `-webkit-user-drag` because it prevents the native behavior.
			if (gestures === 'on' || !element.draggable) {
				// eslint-disable-next-line @typescript-eslint/no-explicit-any
				(style as any).webkitUserDrag = 'none';
			}

			style.touchAction = 'none';
			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			(style as any).webkitTapHighlightColor = 'transparent';
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/tooltip/src/lib/brn-tooltip.directive.ts
```typescript
import { Directive, type TemplateRef, signal } from '@angular/core';

@Directive({
	selector: '[brnTooltip]',
	standalone: true,
})
export class BrnTooltipDirective {
	public readonly tooltipTemplate = signal<TemplateRef<unknown> | null>(null);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/tooltip/src/lib/brn-tooltip.token.ts
```typescript
import { inject, InjectionToken, ValueProvider } from '@angular/core';
import { TooltipPosition, TooltipTouchGestures } from './brn-tooltip-trigger.directive';

export interface BrnTooltipOptions {
	/** Default delay when the tooltip is shown. */
	showDelay: number;
	/** Default delay when the tooltip is hidden. */
	hideDelay: number;
	/** Default delay when hiding the tooltip on a touch device. */
	touchendHideDelay: number;
	/** Default exit animation duration for the tooltip. */
	exitAnimationDuration: number;
	/** Default touch gesture handling for tooltips. */
	touchGestures?: TooltipTouchGestures;
	/** Default position for tooltips. */
	position?: TooltipPosition;
	/**
	 * Default value for whether tooltips should be positioned near the click or touch origin
	 * instead of outside the element bounding box.
	 */
	positionAtOrigin?: boolean;
	/** Disables the ability for the user to interact with the tooltip element. */
	disableTooltipInteractivity?: boolean;
	/** Default classes for the tooltip content. */
	tooltipContentClasses?: string;
}

export const defaultOptions: BrnTooltipOptions = {
	showDelay: 0,
	hideDelay: 0,
	exitAnimationDuration: 0,
	touchendHideDelay: 1500,
};

const BRN_TOOLTIP_DEFAULT_OPTIONS = new InjectionToken<BrnTooltipOptions>('brn-tooltip-default-options', {
	providedIn: 'root',
	factory: () => defaultOptions,
});

export function provideBrnTooltipDefaultOptions(options: Partial<BrnTooltipOptions>): ValueProvider {
	return { provide: BRN_TOOLTIP_DEFAULT_OPTIONS, useValue: { ...defaultOptions, ...options } };
}

export function injectBrnTooltipDefaultOptions(): BrnTooltipOptions {
	return inject(BRN_TOOLTIP_DEFAULT_OPTIONS, { optional: true }) ?? defaultOptions;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/tooltip/src/lib/computed-previous.spec.ts
```typescript
import { signal } from '@angular/core';
import { computedPrevious } from './computed-previous';

describe(computedPrevious.name, () => {
	it('should work properly', () => {
		const value = signal(0);
		const previous = computedPrevious(value);

		expect(value()).toEqual(0);
		expect(previous()).toEqual(0);

		value.set(1);

		expect(value()).toEqual(1);
		expect(previous()).toEqual(0);

		value.set(2);

		expect(value()).toEqual(2);
		expect(previous()).toEqual(1);

		value.set(2);

		expect(value()).toEqual(2);
		expect(previous()).toEqual(1);

		value.set(3);

		expect(value()).toEqual(3);
		expect(previous()).toEqual(2);
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/tooltip/src/lib/computed-previous.ts
````typescript
import { computed, type Signal, untracked } from '@angular/core';

/**
 * Returns a signal that emits the previous value of the given signal.
 * The first time the signal is emitted, the previous value will be the same as the current value.
 *
 * @example
 * ```ts
 * const value = signal(0);
 * const previous = computedPrevious(value);
 *
 * effect(() => {
 *  console.log('Current value:', value());
 *  console.log('Previous value:', previous());
 * });
 *
 * Logs:
 * // Current value: 0
 * // Previous value: 0
 *
 * value.set(1);
 *
 * Logs:
 * // Current value: 1
 * // Previous value: 0
 *
 * value.set(2);
 *
 * Logs:
 * // Current value: 2
 * // Previous value: 1
 *```
 *
 * @param computation Signal to compute previous value for
 * @returns Signal that emits previous value of `s`
 */
export function computedPrevious<T>(computation: Signal<T>): Signal<T> {
	let current = null as T;
	let previous = untracked(() => computation()); // initial value is the current value

	return computed(() => {
		current = computation();
		const result = previous;
		previous = current;
		return result;
	});
}

````
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/input-otp/README.md
```
# @spartan-ng/brain/input-otp

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/input-otp`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/input-otp/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/input-otp/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { BrnInputOtpSlotComponent } from './lib/brn-input-otp-slot.component';
import { BrnInputOtpComponent } from './lib/brn-input-otp.component';

export * from './lib/brn-input-otp-slot.component';
export * from './lib/brn-input-otp.component';

@NgModule({
	imports: [BrnInputOtpComponent, BrnInputOtpSlotComponent],
	exports: [BrnInputOtpComponent, BrnInputOtpSlotComponent],
})
export class BrnInputOtpModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/input-otp/src/lib/brn-input-otp-slot.component.ts
```typescript
import { NumberInput } from '@angular/cdk/coercion';
import { Component, computed, input, numberAttribute } from '@angular/core';
import { injectBrnInputOtp } from './brn-input-otp.token';

@Component({
	selector: 'brn-input-otp-slot',
	standalone: true,
	template: `
		{{ slot().char }}

		@if (slot().hasFakeCaret) {
			<ng-content />
		}
	`,
	host: {
		'[attr.data-active]': 'slot().isActive',
	},
})
export class BrnInputOtpSlotComponent {
	/** Access the input-otp component */
	protected readonly inputOtp = injectBrnInputOtp();

	public readonly index = input.required<number, NumberInput>({ transform: numberAttribute });

	public readonly slot = computed(() => this.inputOtp.context()[this.index()]);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/input-otp/src/lib/brn-input-otp.component.ts
```typescript
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import {
	booleanAttribute,
	Component,
	computed,
	forwardRef,
	input,
	model,
	numberAttribute,
	output,
	signal,
} from '@angular/core';
import { ControlValueAccessor, FormsModule, NG_VALUE_ACCESSOR } from '@angular/forms';
import { ChangeFn, TouchFn } from '@spartan-ng/brain/forms';
import { provideBrnInputOtp } from './brn-input-otp.token';

export const BRN_INPUT_OTP_VALUE_ACCESSOR = {
	provide: NG_VALUE_ACCESSOR,
	useExisting: forwardRef(() => BrnInputOtpComponent),
	multi: true,
};

export type InputMode = 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';

@Component({
	selector: 'brn-input-otp',
	imports: [FormsModule],
	template: `
		<ng-content />
		<div [style]="containerStyles()">
			<input
				[class]="inputClass()"
				autocomplete="one-time-code"
				data-slot="input-otp"
				[style]="inputStyles()"
				[disabled]="state().disabled()"
				[inputMode]="inputMode()"
				[ngModel]="value()"
				(input)="onInputChange($event)"
				(paste)="onPaste($event)"
				(focus)="focused.set(true)"
				(blur)="focused.set(false)"
			/>
		</div>
	`,
	host: {
		'[style]': 'hostStyles()',
		'data-input-otp-container': 'true',
	},
	providers: [BRN_INPUT_OTP_VALUE_ACCESSOR, provideBrnInputOtp(BrnInputOtpComponent)],
})
export class BrnInputOtpComponent implements ControlValueAccessor {
	/** Whether the input has focus. */
	protected readonly focused = signal<boolean>(false);

	public readonly hostStyles = input<string>(
		'position: relative; cursor: text; user-select: none; pointer-events: none;',
	);

	public readonly inputStyles = input<string>(
		'position: absolute; inset: 0; width: 100%; height: 100%; display: flex; textAlign: left; opacity: 1; color: transparent; pointerEvents: all; background: transparent; caret-color: transparent; border: 0px solid transparent; outline: transparent solid 0px; box-shadow: none; line-height: 1; letter-spacing: -0.5em; font-family: monospace; font-variant-numeric: tabular-nums;',
	);

	public readonly containerStyles = input<string>('position: absolute; inset: 0; pointer-events: none;');

	/** Determine if the date picker is disabled. */
	public readonly disabled = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** The number of slots. */
	public readonly maxLength = input.required<number, NumberInput>({ transform: numberAttribute });

	/** Virtual keyboard appearance on mobile */
	public readonly inputMode = input<InputMode>('numeric');

	public readonly inputClass = input<string>('');

	/**
	 * Defines how the pasted text should be transformed before saving to model/form.
	 * Allows pasting text which contains extra characters like spaces, dashes, etc. and are longer than the maxLength.
	 *
	 * "XXX-XXX": (pastedText) => pastedText.replaceAll('-', '')
	 * "XXX XXX": (pastedText) => pastedText.replaceAll(/\s+/g, '')
	 */
	public readonly transformPaste = input<(pastedText: string, maxLength: number) => string>((text) => text);

	/** The value controlling the input */
	public readonly value = model('');

	public readonly context = computed(() => {
		const value = this.value();
		const focused = this.focused();
		const maxLength = this.maxLength();
		const slots = Array.from({ length: this.maxLength() }).map((_, slotIndex) => {
			const char = value[slotIndex] !== undefined ? value[slotIndex] : null;

			const isActive =
				focused && (value.length === slotIndex || (value.length === maxLength && slotIndex === maxLength - 1));

			return {
				char,
				isActive,
				hasFakeCaret: isActive && value.length === slotIndex,
			};
		});

		return slots;
	});

	/** Emitted when the input is complete, triggered through input or paste.  */
	public readonly completed = output<string>();

	protected readonly state = computed(() => ({
		disabled: signal(this.disabled()),
	}));

	protected _onChange?: ChangeFn<string>;
	protected _onTouched?: TouchFn;

	protected onInputChange(event: Event) {
		let newValue = (event.target as HTMLInputElement).value;
		const maxLength = this.maxLength();

		if (newValue.length > maxLength) {
			// Replace the last character when max length is exceeded
			newValue = newValue.slice(0, maxLength - 1) + newValue.slice(-1);
		}

		this.updateValue(newValue, maxLength);
	}

	protected onPaste(event: ClipboardEvent) {
		event.preventDefault();
		const clipboardData = event.clipboardData?.getData('text/plain') || '';

		const maxLength = this.maxLength();

		const content = this.transformPaste()(clipboardData, maxLength);
		const newValue = content.slice(0, maxLength);

		this.updateValue(newValue, maxLength);
	}

	/** CONTROL VALUE ACCESSOR */
	writeValue(value: string | null): void {
		// optional FormControl is initialized with null value
		if (value === null) return;

		this.updateValue(value, this.maxLength());
	}

	registerOnChange(fn: ChangeFn<string>): void {
		this._onChange = fn;
	}

	registerOnTouched(fn: TouchFn): void {
		this._onTouched = fn;
	}

	setDisabledState(isDisabled: boolean): void {
		this.state().disabled.set(isDisabled);
	}

	private isCompleted(newValue: string, previousValue: string, maxLength: number) {
		return newValue !== previousValue && previousValue.length < maxLength && newValue.length === maxLength;
	}

	private updateValue(newValue: string, maxLength: number) {
		const previousValue = this.value();

		this.value.set(newValue);
		this._onChange?.(newValue);

		if (this.isCompleted(newValue, previousValue, maxLength)) {
			this.completed.emit(newValue);
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/input-otp/src/lib/brn-input-otp.token.ts
```typescript
import { ExistingProvider, inject, InjectionToken, Type } from '@angular/core';
import { BrnInputOtpComponent } from './brn-input-otp.component';

export const BrnInputOtpToken = new InjectionToken<BrnInputOtpComponent>('BrnInputOtpToken');

export function injectBrnInputOtp(): BrnInputOtpComponent {
	return inject(BrnInputOtpToken) as BrnInputOtpComponent;
}

export function provideBrnInputOtp(inputOtp: Type<BrnInputOtpComponent>): ExistingProvider {
	return { provide: BrnInputOtpToken, useExisting: inputOtp };
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/calendar/README.md
```
# @spartan-ng/brain/calendar

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/calendar`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/calendar/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/calendar/src/index.ts
```typescript
export * from './lib/brn-calendar-cell-button.directive';
export * from './lib/brn-calendar-cell.directive';
export * from './lib/brn-calendar-grid.directive';
export * from './lib/brn-calendar-header.directive';
export * from './lib/brn-calendar-next-button.directive';
export * from './lib/brn-calendar-previous-button.directive';
export * from './lib/brn-calendar-week.directive';
export * from './lib/brn-calendar-weekday.directive';
export * from './lib/brn-calendar.directive';
export * from './lib/brn-calendar.token';
export * from './lib/i18n/calendar-i18n';
export * from './lib/mode/brn-calendar-multiple.directive';

import { NgModule } from '@angular/core';
import { BrnCalendarCellButtonDirective } from './lib/brn-calendar-cell-button.directive';
import { BrnCalendarCellDirective } from './lib/brn-calendar-cell.directive';
import { BrnCalendarGridDirective } from './lib/brn-calendar-grid.directive';
import { BrnCalendarHeaderDirective } from './lib/brn-calendar-header.directive';
import { BrnCalendarNextButtonDirective } from './lib/brn-calendar-next-button.directive';
import { BrnCalendarPreviousButtonDirective } from './lib/brn-calendar-previous-button.directive';
import { BrnCalendarWeekDirective } from './lib/brn-calendar-week.directive';
import { BrnCalendarWeekdayDirective } from './lib/brn-calendar-weekday.directive';
import { BrnCalendarDirective } from './lib/brn-calendar.directive';
import { BrnCalendarMultiDirective } from './lib/mode/brn-calendar-multiple.directive';

export const BrnCalendarImports = [
	BrnCalendarCellButtonDirective,
	BrnCalendarGridDirective,
	BrnCalendarHeaderDirective,
	BrnCalendarNextButtonDirective,
	BrnCalendarPreviousButtonDirective,
	BrnCalendarWeekDirective,
	BrnCalendarWeekdayDirective,
	BrnCalendarDirective,
	BrnCalendarCellDirective,
	BrnCalendarMultiDirective,
] as const;

@NgModule({
	imports: [...BrnCalendarImports],
	exports: [...BrnCalendarImports],
})
export class BrnCalendarModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/calendar/src/lib/brn-calendar-cell-button.directive.ts
```typescript
import { Directive, ElementRef, computed, inject, input } from '@angular/core';
import { injectDateAdapter } from '@spartan-ng/brain/date-time';
import { injectBrnCalendar } from './brn-calendar.token';

@Directive({
	selector: 'button[brnCalendarCellButton]',
	standalone: true,
	host: {
		role: 'gridcell',
		'[tabindex]': 'focusable() ? 0 : -1',
		type: 'button',
		'[attr.data-outside]': "outside() ? '' : null",
		'[attr.data-today]': "today() && !selected() ? '' : null",
		'[attr.data-selected]': "selected() ? '' : null",
		'[attr.data-disabled]': "disabled() ? '' : null",
		'[attr.aria-selected]': "selected() ? 'true' : null",
		'[attr.aria-disabled]': "disabled() ? 'true' : null",
		'[disabled]': 'disabled()',
		'(click)': 'calendar.selectDate(date())',
		'(keydown.arrowLeft)': 'focusPrevious($event)',
		'(keydown.arrowRight)': 'focusNext($event)',
		'(keydown.arrowUp)': 'focusAbove($event)',
		'(keydown.arrowDown)': 'focusBelow($event)',
		'(keydown.home)': 'focusFirst($event)',
		'(keydown.end)': 'focusLast($event)',
		'(keydown.pageUp)': 'focusPreviousMonth($event)',
		'(keydown.pageDown)': 'focusNextMonth($event)',
	},
})
export class BrnCalendarCellButtonDirective<T> {
	/** Access the date adapter */
	protected readonly dateAdapter = injectDateAdapter<T>();

	/** Access the calendar component */
	protected readonly calendar = injectBrnCalendar<T>();

	/** Access the element ref */
	private readonly _elementRef = inject<ElementRef<HTMLButtonElement>>(ElementRef);

	/** The date this cell represents */
	public readonly date = input.required<T>();

	/** Whether this date is currently selected */
	public readonly selected = computed(() => this.calendar.isSelected(this.date()));

	/** Whether this date is focusable */
	public readonly focusable = computed(() => this.dateAdapter.isSameDay(this.calendar.focusedDate(), this.date()));

	public readonly outside = computed(() => {
		const focusedDate = this.calendar.focusedDate();
		return !this.dateAdapter.isSameMonth(this.date(), focusedDate);
	});

	/** Whether this date is today */
	public readonly today = computed(() => this.dateAdapter.isSameDay(this.date(), this.dateAdapter.now()));

	/** Whether this date is disabled */
	public readonly disabled = computed(() => this.calendar.isDateDisabled(this.date()) || this.calendar.disabled());

	/**
	 * Focus the previous cell.
	 */
	protected focusPrevious(event: Event): void {
		event.preventDefault();
		event.stopPropagation();

		// in rtl, the arrow keys are reversed.
		const targetDate = this.dateAdapter.add(this.calendar.focusedDate(), {
			days: this.getDirection() === 'rtl' ? 1 : -1,
		});

		this.calendar.setFocusedDate(targetDate);
	}

	/**
	 * Focus the next cell.
	 */
	protected focusNext(event: Event): void {
		event.preventDefault();
		event.stopPropagation();

		const targetDate = this.dateAdapter.add(this.calendar.focusedDate(), {
			days: this.getDirection() === 'rtl' ? -1 : 1,
		});

		this.calendar.setFocusedDate(targetDate);
	}

	/**
	 * Focus the above cell.
	 */
	protected focusAbove(event: Event): void {
		event.preventDefault();
		event.stopPropagation();
		this.calendar.setFocusedDate(this.dateAdapter.subtract(this.calendar.focusedDate(), { days: 7 }));
	}

	/**
	 * Focus the below cell.
	 */
	protected focusBelow(event: Event): void {
		event.preventDefault();
		event.stopPropagation();
		this.calendar.setFocusedDate(this.dateAdapter.add(this.calendar.focusedDate(), { days: 7 }));
	}

	/**
	 * Focus the first date of the month.
	 */
	protected focusFirst(event: Event): void {
		event.preventDefault();
		event.stopPropagation();
		this.calendar.setFocusedDate(this.dateAdapter.startOfMonth(this.calendar.focusedDate()));
	}

	/**
	 * Focus the last date of the month.
	 */
	protected focusLast(event: Event): void {
		event.preventDefault();
		event.stopPropagation();
		this.calendar.setFocusedDate(this.dateAdapter.endOfMonth(this.calendar.focusedDate()));
	}

	/**
	 * Focus the same date in the previous month.
	 */
	protected focusPreviousMonth(event: Event): void {
		event.preventDefault();
		event.stopPropagation();

		const date = this.dateAdapter.getDate(this.calendar.focusedDate());

		let previousMonthTarget = this.dateAdapter.startOfMonth(this.calendar.focusedDate());
		previousMonthTarget = this.dateAdapter.subtract(previousMonthTarget, { months: 1 });

		const lastDay = this.dateAdapter.endOfMonth(previousMonthTarget);

		// if we are on a date that does not exist in the previous month, we should focus the last day of the month.
		if (date > this.dateAdapter.getDate(lastDay)) {
			this.calendar.setFocusedDate(lastDay);
		} else {
			this.calendar.setFocusedDate(this.dateAdapter.set(previousMonthTarget, { day: date }));
		}
	}

	/**
	 * Focus the same date in the next month.
	 */
	protected focusNextMonth(event: Event): void {
		event.preventDefault();
		event.stopPropagation();

		const date = this.dateAdapter.getDate(this.calendar.focusedDate());

		let nextMonthTarget = this.dateAdapter.startOfMonth(this.calendar.focusedDate());
		nextMonthTarget = this.dateAdapter.add(nextMonthTarget, { months: 1 });

		const lastDay = this.dateAdapter.endOfMonth(nextMonthTarget);

		// if we are on a date that does not exist in the next month, we should focus the last day of the month.
		if (date > this.dateAdapter.getDate(lastDay)) {
			this.calendar.setFocusedDate(lastDay);
		} else {
			this.calendar.setFocusedDate(this.dateAdapter.set(nextMonthTarget, { day: date }));
		}
	}

	/**
	 * Get the direction of the element.
	 */
	private getDirection(): 'ltr' | 'rtl' {
		return getComputedStyle(this._elementRef.nativeElement).direction === 'rtl' ? 'rtl' : 'ltr';
	}

	focus(): void {
		this._elementRef.nativeElement.focus();
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/calendar/src/lib/brn-calendar-cell.directive.ts
```typescript
import { Directive } from '@angular/core';

@Directive({
	selector: '[brnCalendarCell]',
	standalone: true,
	host: {
		role: 'presentation',
	},
})
export class BrnCalendarCellDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/calendar/src/lib/brn-calendar-grid.directive.ts
```typescript
import { Directive } from '@angular/core';
import { injectBrnCalendar } from './brn-calendar.token';

@Directive({
	selector: '[brnCalendarGrid]',
	standalone: true,
	host: {
		role: 'grid',
		'[attr.aria-labelledby]': 'calendar.header()?.id()',
	},
})
export class BrnCalendarGridDirective<T> {
	/** Access the calendar component */
	protected readonly calendar = injectBrnCalendar<T>();
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/calendar/src/lib/brn-calendar-header.directive.ts
```typescript
import { Directive, input } from '@angular/core';

let uniqueId = 0;

@Directive({
	selector: '[brnCalendarHeader]',
	standalone: true,
	host: {
		'[id]': 'id()',
		'aria-live': 'polite',
		role: 'presentation',
	},
})
export class BrnCalendarHeaderDirective {
	/** The unique id for the header */
	public readonly id = input(`brn-calendar-header-${uniqueId++}`);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/calendar/src/lib/brn-calendar-next-button.directive.ts
```typescript
import { Directive, HostListener } from '@angular/core';
import { injectDateAdapter } from '@spartan-ng/brain/date-time';
import { injectBrnCalendar } from './brn-calendar.token';
import { injectBrnCalendarI18n } from './i18n/calendar-i18n';

@Directive({
	selector: '[brnCalendarNextButton]',
	standalone: true,
	host: {
		type: 'button',
		'[attr.aria-label]': 'i18n.labelNext()',
	},
})
export class BrnCalendarNextButtonDirective {
	/** Access the calendar */
	private readonly _calendar = injectBrnCalendar();

	/** Access the date adapter */
	private readonly _dateAdapter = injectDateAdapter();

	/** Access the calendar i18n */
	protected readonly i18n = injectBrnCalendarI18n();

	/** Focus the previous month */
	@HostListener('click')
	protected focusPreviousMonth(): void {
		const targetDate = this._dateAdapter.add(this._calendar.state().focusedDate(), { months: 1 });

		// if the date is disabled, but there are available dates in the month, focus the last day of the month.
		const possibleDate = this._calendar.constrainDate(targetDate);

		if (this._dateAdapter.isSameMonth(possibleDate, targetDate)) {
			// if this date is within the same month, then focus it
			this._calendar.state().focusedDate.set(possibleDate);
			return;
		}

		this._calendar.state().focusedDate.set(targetDate);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/calendar/src/lib/brn-calendar-previous-button.directive.ts
```typescript
import { Directive, HostListener } from '@angular/core';
import { injectDateAdapter } from '@spartan-ng/brain/date-time';
import { injectBrnCalendar } from './brn-calendar.token';
import { injectBrnCalendarI18n } from './i18n/calendar-i18n';

@Directive({
	selector: '[brnCalendarPreviousButton]',
	standalone: true,
	host: {
		type: 'button',
		'[attr.aria-label]': 'i18n.labelPrevious()',
	},
})
export class BrnCalendarPreviousButtonDirective {
	/** Access the calendar */
	private readonly _calendar = injectBrnCalendar();

	/** Access the date adapter */
	private readonly _dateAdapter = injectDateAdapter();

	/** Access the calendar i18n */
	protected readonly i18n = injectBrnCalendarI18n();

	/** Focus the previous month */
	@HostListener('click')
	protected focusPreviousMonth(): void {
		const targetDate = this._dateAdapter.subtract(this._calendar.state().focusedDate(), { months: 1 });

		// if the date is disabled, but there are available dates in the month, focus the last day of the month.
		const possibleDate = this._calendar.constrainDate(targetDate);

		if (this._dateAdapter.isSameMonth(possibleDate, targetDate)) {
			// if this date is within the same month, then focus it
			this._calendar.state().focusedDate.set(possibleDate);
			return;
		}

		this._calendar.state().focusedDate.set(targetDate);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/calendar/src/lib/brn-calendar-week.directive.ts
```typescript
import {
	ChangeDetectorRef,
	Directive,
	EmbeddedViewRef,
	OnDestroy,
	TemplateRef,
	ViewContainerRef,
	computed,
	effect,
	inject,
	untracked,
} from '@angular/core';
import { injectBrnCalendar } from './brn-calendar.token';

@Directive({
	standalone: true,
	selector: '[brnCalendarWeek]',
})
export class BrnCalendarWeekDirective<T> implements OnDestroy {
	/** Access the calendar */
	private readonly _calendar = injectBrnCalendar<T>();

	/** Access the view container ref */
	private readonly _viewContainerRef = inject(ViewContainerRef);

	/** Access the change detector */
	private readonly _changeDetector = inject(ChangeDetectorRef);

	/** Access the template ref */
	private readonly _templateRef = inject<TemplateRef<BrnWeekContext<T>>>(TemplateRef);

	// get the weeks to display.
	protected readonly weeks = computed(() => {
		const days = this._calendar.days();
		const weeks = [];

		for (let i = 0; i < days.length; i += 7) {
			weeks.push(days.slice(i, i + 7));
		}

		return weeks;
	});

	/** Store the view refs */
	private readonly _viewRefs: EmbeddedViewRef<BrnWeekContext<T>>[] = [];

	// Make sure the template checker knows the type of the context with which the
	// template of this directive will be rendered
	static ngTemplateContextGuard<T>(_: BrnCalendarWeekDirective<T>, ctx: unknown): ctx is BrnWeekContext<T> {
		return true;
	}

	constructor() {
		// this should use `afterRenderEffect` but it's not available in the current version
		effect(() => {
			const weeks = this.weeks();
			untracked(() => this._renderWeeks(weeks));
		});
	}

	private _renderWeeks(weeks: T[][]): void {
		// Destroy all the views when the directive is destroyed
		for (const viewRef of this._viewRefs) {
			viewRef.destroy();
		}

		this._viewRefs.length = 0;

		// Create a new view for each week
		for (const week of weeks) {
			const viewRef = this._viewContainerRef.createEmbeddedView(this._templateRef, {
				$implicit: week,
			});
			this._viewRefs.push(viewRef);
		}

		this._changeDetector.detectChanges();
	}

	ngOnDestroy(): void {
		// Destroy all the views when the directive is destroyed
		for (const viewRef of this._viewRefs) {
			viewRef.destroy();
		}
	}
}

interface BrnWeekContext<T> {
	$implicit: T[];
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/calendar/src/lib/brn-calendar-weekday.directive.ts
```typescript
import { Directive, EmbeddedViewRef, OnDestroy, TemplateRef, ViewContainerRef, computed, inject } from '@angular/core';
import { injectDateAdapter } from '@spartan-ng/brain/date-time';
import { injectBrnCalendar } from './brn-calendar.token';

@Directive({
	standalone: true,
	selector: '[brnCalendarWeekday]',
})
export class BrnCalendarWeekdayDirective<T> implements OnDestroy {
	/** Access the calendar */
	private readonly _calendar = injectBrnCalendar<T>();

	/** Access the date time adapter */
	private readonly _dateAdapter = injectDateAdapter<T>();

	/** Access the view container ref */
	private readonly _viewContainerRef = inject(ViewContainerRef);

	/** Access the template ref */
	private readonly _templateRef = inject<TemplateRef<BrnWeekdayContext>>(TemplateRef);

	/** Get the days of the week to display in the header. */
	protected readonly weekdays = computed(() => this._calendar.days().slice(0, 7));

	/** Store the view refs */
	private readonly _viewRefs: EmbeddedViewRef<BrnWeekdayContext>[] = [];

	// Make sure the template checker knows the type of the context with which the
	// template of this directive will be rendered
	static ngTemplateContextGuard<T>(_: BrnCalendarWeekdayDirective<T>, ctx: unknown): ctx is BrnWeekdayContext {
		return true;
	}

	constructor() {
		// Create a new view for each day
		for (const day of this.weekdays()) {
			const viewRef = this._viewContainerRef.createEmbeddedView(this._templateRef, {
				$implicit: this._dateAdapter.getDay(day),
			});
			this._viewRefs.push(viewRef);
		}
	}

	ngOnDestroy(): void {
		// Destroy all the views when the directive is destroyed
		for (const viewRef of this._viewRefs) {
			viewRef.destroy();
		}
	}
}

interface BrnWeekdayContext {
	$implicit: number;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/calendar/src/lib/brn-calendar.directive.ts
```typescript
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import {
	ChangeDetectorRef,
	Directive,
	Injector,
	afterNextRender,
	booleanAttribute,
	computed,
	contentChild,
	contentChildren,
	inject,
	input,
	model,
	numberAttribute,
	signal,
} from '@angular/core';
import { injectDateAdapter } from '@spartan-ng/brain/date-time';
import { BrnCalendarCellButtonDirective } from './brn-calendar-cell-button.directive';
import { BrnCalendarHeaderDirective } from './brn-calendar-header.directive';
import { BrnCalendar, provideBrnCalendar } from './brn-calendar.token';

@Directive({
	selector: '[brnCalendar]',
	standalone: true,
	providers: [provideBrnCalendar(BrnCalendarDirective)],
})
export class BrnCalendarDirective<T> implements BrnCalendar<T> {
	/** Access the date adapter */
	protected readonly dateAdapter = injectDateAdapter<T>();

	/** Access the change detector */
	private readonly _changeDetector = inject(ChangeDetectorRef);

	/** Access the injector */
	private readonly _injector = inject(Injector);

	/** The minimum date that can be selected.*/
	public readonly min = input<T>();

	/** The maximum date that can be selected. */
	public readonly max = input<T>();

	/** Determine if the date picker is disabled. */
	public readonly disabled = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** The selected value. */
	public readonly date = model<T>();

	/** Whether a specific date is disabled. */
	public readonly dateDisabled = input<(date: T) => boolean>(() => false);

	/** The day the week starts on */
	public readonly weekStartsOn = input<Weekday, NumberInput>(0, {
		transform: (v: unknown) => numberAttribute(v) as Weekday,
	});

	/** The default focused date. */
	public readonly defaultFocusedDate = input<T>();

	/** @internal Access the header */
	public readonly header = contentChild(BrnCalendarHeaderDirective);

	/** Store the cells */
	protected readonly cells = contentChildren<BrnCalendarCellButtonDirective<T>>(BrnCalendarCellButtonDirective, {
		descendants: true,
	});

	/**
	 * @internal
	 * The internal state of the component.
	 */
	public readonly state = computed(() => ({
		focusedDate: signal(this.constrainDate(this.defaultFocusedDate() ?? this.date() ?? this.dateAdapter.now())),
	}));

	/**
	 * The focused date.
	 */
	public readonly focusedDate = computed(() => this.state().focusedDate());

	/**
	 * Get all the days to display, this is the days of the current month
	 * and the days of the previous and next month to fill the grid.
	 */
	public readonly days = computed(() => {
		const weekStartsOn = this.weekStartsOn();
		const month = this.state().focusedDate();
		const days: T[] = [];

		// Get the first and last day of the month.
		let firstDay = this.dateAdapter.startOfMonth(month);
		let lastDay = this.dateAdapter.endOfMonth(month);

		// we need to subtract until we get the to starting day before or on the start of the month.
		while (this.dateAdapter.getDay(firstDay) !== weekStartsOn) {
			firstDay = this.dateAdapter.subtract(firstDay, { days: 1 });
		}

		const weekEndsOn = (weekStartsOn + 6) % 7;

		// we need to add until we get to the ending day after or on the end of the month.
		while (this.dateAdapter.getDay(lastDay) !== weekEndsOn) {
			lastDay = this.dateAdapter.add(lastDay, { days: 1 });
		}

		// collect all the days to display.
		while (firstDay <= lastDay) {
			days.push(firstDay);
			firstDay = this.dateAdapter.add(firstDay, { days: 1 });
		}

		return days;
	});

	/** @internal Constrain a date to the min and max boundaries */
	constrainDate(date: T): T {
		const min = this.min();
		const max = this.max();

		// If there is no min or max, return the date.
		if (!min && !max) {
			return date;
		}

		// If there is a min and the date is before the min, return the min.
		if (min && this.dateAdapter.isBefore(date, this.dateAdapter.startOfDay(min))) {
			return min;
		}

		// If there is a max and the date is after the max, return the max.
		if (max && this.dateAdapter.isAfter(date, this.dateAdapter.endOfDay(max))) {
			return max;
		}

		// Return the date.
		return date;
	}

	/** @internal Determine if a date is disabled */
	isDateDisabled(date: T): boolean {
		// if the calendar is disabled we can't select this date
		if (this.disabled()) {
			return true;
		}

		// if the date is outside the min and max range
		const min = this.min();
		const max = this.max();

		if (min && this.dateAdapter.isBefore(date, this.dateAdapter.startOfDay(min))) {
			return true;
		}

		if (max && this.dateAdapter.isAfter(date, this.dateAdapter.endOfDay(max))) {
			return true;
		}

		// if this specific date is disabled
		const disabledFn = this.dateDisabled();

		if (disabledFn(date)) {
			return true;
		}

		return false;
	}

	isSelected(date: T): boolean {
		const selected = this.date() as T | undefined;
		return selected !== undefined && this.dateAdapter.isSameDay(date, selected);
	}

	selectDate(date: T): void {
		if (this.isSelected(date)) {
			this.date.set(undefined);
		} else {
			this.date.set(date);
		}
		this.state().focusedDate.set(date);
	}

	/** @internal Set the focused date */
	setFocusedDate(date: T): void {
		// check if the date is disabled.
		if (this.isDateDisabled(date)) {
			return;
		}

		this.state().focusedDate.set(date);

		// wait until the cells have all updated
		afterNextRender(
			{
				write: () => {
					// focus the cell with the target date.
					const cell = this.cells().find((c) => this.dateAdapter.isSameDay(c.date(), date));

					if (cell) {
						cell.focus();
					}
				},
			},
			{
				injector: this._injector,
			},
		);

		// we must update the view to ensure the focused cell is visible.
		this._changeDetector.detectChanges();
	}
}

export type Weekday = 0 | 1 | 2 | 3 | 4 | 5 | 6;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/calendar/src/lib/brn-calendar.token.ts
```typescript
import { ExistingProvider, InjectionToken, Signal, Type, WritableSignal, inject } from '@angular/core';
import { BrnCalendarHeaderDirective } from './brn-calendar-header.directive';

export interface BrnCalendar<T> {
	isSelected: (date: T) => boolean;
	selectDate: (date: T) => void;

	constrainDate: (date: T) => T;
	isDateDisabled: (date: T) => boolean;
	setFocusedDate: (date: T) => void;

	disabled: Signal<boolean>;
	focusedDate: Signal<T>;
	header: Signal<BrnCalendarHeaderDirective | undefined>;
	state: Signal<{
		focusedDate: WritableSignal<T>;
	}>;
	days: Signal<T[]>;
}

export const BrnCalendarToken = new InjectionToken<BrnCalendar<unknown>>('BrnCalendarToken');

export function provideBrnCalendar<T>(instance: Type<BrnCalendar<T>>): ExistingProvider {
	return { provide: BrnCalendarToken, useExisting: instance };
}

/**
 * Inject the calendar component.
 */
export function injectBrnCalendar<T>(): BrnCalendar<T> {
	return inject(BrnCalendarToken) as BrnCalendar<T>;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/calendar/src/lib/mode/brn-calendar-multiple.directive.ts
```typescript
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import {
	afterNextRender,
	booleanAttribute,
	ChangeDetectorRef,
	computed,
	contentChild,
	contentChildren,
	Directive,
	inject,
	Injector,
	input,
	model,
	numberAttribute,
	signal,
} from '@angular/core';
import { injectDateAdapter } from '@spartan-ng/brain/date-time';
import { BrnCalendarCellButtonDirective } from '../brn-calendar-cell-button.directive';
import { BrnCalendarHeaderDirective } from '../brn-calendar-header.directive';
import { Weekday } from '../brn-calendar.directive';
import { BrnCalendar, provideBrnCalendar } from '../brn-calendar.token';

@Directive({
	selector: '[brnCalendarMulti]',
	standalone: true,
	providers: [provideBrnCalendar(BrnCalendarMultiDirective)],
})
export class BrnCalendarMultiDirective<T> implements BrnCalendar<T> {
	// /** Access the date adapter */
	protected readonly dateAdapter = injectDateAdapter<T>();

	/** Access the change detector */
	private readonly _changeDetector = inject(ChangeDetectorRef);

	/** Access the injector */
	private readonly _injector = inject(Injector);

	/** The minimum date that can be selected.*/
	public readonly min = input<T>();

	/** The maximum date that can be selected. */
	public readonly max = input<T>();

	/** The minimum selectable dates.  */
	public readonly minSelection = input<number, NumberInput>(undefined, {
		transform: numberAttribute,
	});

	/** The maximum selectable dates.  */
	public readonly maxSelection = input<number, NumberInput>(undefined, {
		transform: numberAttribute,
	});

	/** Determine if the date picker is disabled. */
	public readonly disabled = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** The selected value. */
	public readonly date = model<T[]>();

	/** Whether a specific date is disabled. */
	public readonly dateDisabled = input<(date: T) => boolean>(() => false);

	/** The day the week starts on */
	public readonly weekStartsOn = input<Weekday, NumberInput>(0, {
		transform: (v: unknown) => numberAttribute(v) as Weekday,
	});

	/** The default focused date. */
	public readonly defaultFocusedDate = input<T>();

	/** @internal Access the header */
	public readonly header = contentChild(BrnCalendarHeaderDirective);

	/** Store the cells */
	protected readonly cells = contentChildren<BrnCalendarCellButtonDirective<T>>(BrnCalendarCellButtonDirective, {
		descendants: true,
	});

	/**
	 * @internal
	 * The internal state of the component.
	 */
	public readonly state = computed(() => ({
		focusedDate: signal(this.constrainDate(this.defaultFocusedDate() ?? this.dateAdapter.now())),
	}));

	/**
	 * The focused date.
	 */
	public readonly focusedDate = computed(() => this.state().focusedDate());

	/**
	 * Get all the days to display, this is the days of the current month
	 * and the days of the previous and next month to fill the grid.
	 */
	public readonly days = computed(() => {
		const weekStartsOn = this.weekStartsOn();
		const month = this.state().focusedDate();
		const days: T[] = [];

		// Get the first and last day of the month.
		let firstDay = this.dateAdapter.startOfMonth(month);
		let lastDay = this.dateAdapter.endOfMonth(month);

		// we need to subtract until we get the to starting day before or on the start of the month.
		while (this.dateAdapter.getDay(firstDay) !== weekStartsOn) {
			firstDay = this.dateAdapter.subtract(firstDay, { days: 1 });
		}

		const weekEndsOn = (weekStartsOn + 6) % 7;

		// we need to add until we get to the ending day after or on the end of the month.
		while (this.dateAdapter.getDay(lastDay) !== weekEndsOn) {
			lastDay = this.dateAdapter.add(lastDay, { days: 1 });
		}

		// collect all the days to display.
		while (firstDay <= lastDay) {
			days.push(firstDay);
			firstDay = this.dateAdapter.add(firstDay, { days: 1 });
		}

		return days;
	});

	isSelected(date: T): boolean {
		return this.date()?.some((d) => this.dateAdapter.isSameDay(d, date)) ?? false;
	}

	selectDate(date: T): void {
		const selected = this.date() as T[] | undefined;
		if (this.isSelected(date)) {
			const minSelection = this.minSelection();
			if (selected?.length === minSelection) {
				// min selection reached, do not allow to deselect
				return;
			}

			this.date.set(selected?.filter((d) => !this.dateAdapter.isSameDay(d, date)));
		} else {
			const maxSelection = this.maxSelection();
			if (selected?.length === maxSelection) {
				// max selection reached, reset the selection to date
				this.date.set([date]);
			} else {
				// add the date to the selection
				this.date.set([...(selected ?? []), date]);
			}
		}
	}

	// same as in brn-calendar.directive.ts
	/** @internal Constrain a date to the min and max boundaries */
	constrainDate(date: T): T {
		const min = this.min();
		const max = this.max();

		// If there is no min or max, return the date.
		if (!min && !max) {
			return date;
		}

		// If there is a min and the date is before the min, return the min.
		if (min && this.dateAdapter.isBefore(date, this.dateAdapter.startOfDay(min))) {
			return min;
		}

		// If there is a max and the date is after the max, return the max.
		if (max && this.dateAdapter.isAfter(date, this.dateAdapter.endOfDay(max))) {
			return max;
		}

		// Return the date.
		return date;
	}

	/** @internal Determine if a date is disabled */
	isDateDisabled(date: T): boolean {
		// if the calendar is disabled we can't select this date
		if (this.disabled()) {
			return true;
		}

		// if the date is outside the min and max range
		const min = this.min();
		const max = this.max();

		if (min && this.dateAdapter.isBefore(date, this.dateAdapter.startOfDay(min))) {
			return true;
		}

		if (max && this.dateAdapter.isAfter(date, this.dateAdapter.endOfDay(max))) {
			return true;
		}

		// if this specific date is disabled
		const disabledFn = this.dateDisabled();

		if (disabledFn(date)) {
			return true;
		}

		return false;
	}

	/** @internal Set the focused date */
	setFocusedDate(date: T): void {
		// check if the date is disabled.
		if (this.isDateDisabled(date)) {
			return;
		}

		this.state().focusedDate.set(date);

		// wait until the cells have all updated
		afterNextRender(
			{
				write: () => {
					// focus the cell with the target date.
					const cell = this.cells().find((c) => this.dateAdapter.isSameDay(c.date(), date));

					if (cell) {
						cell.focus();
					}
				},
			},
			{
				injector: this._injector,
			},
		);

		// we must update the view to ensure the focused cell is visible.
		this._changeDetector.detectChanges();
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/calendar/src/lib/i18n/calendar-i18n.ts
```typescript
import { InjectionToken, ValueProvider, inject } from '@angular/core';

export interface BrnCalendarI18n {
	formatWeekdayName: (index: number) => string;
	formatHeader: (month: number, year: number) => string;
	labelPrevious: () => string;
	labelNext: () => string;
	labelWeekday: (index: number) => string;
}

export const BrnCalendarI18nToken = new InjectionToken<BrnCalendarI18n>('BrnCalendarI18nToken');

/**
 * Provide the calendar i18n configuration.
 */
export function provideBrnCalendarI18n(configuration: BrnCalendarI18n): ValueProvider {
	return { provide: BrnCalendarI18nToken, useValue: configuration };
}

const defaultCalendarI18n: BrnCalendarI18n = {
	formatWeekdayName: (index: number) => {
		const weekdays = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'];
		return weekdays[index];
	},
	formatHeader: (month: number, year: number) => {
		return new Date(year, month).toLocaleDateString(undefined, {
			month: 'long',
			year: 'numeric',
		});
	},
	labelPrevious: () => 'Go to the previous month',
	labelNext: () => 'Go to the next month',
	labelWeekday: (index: number) => {
		const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
		return weekdays[index];
	},
};

/**
 * Inject the calendar i18n configuration.
 */
export function injectBrnCalendarI18n(): BrnCalendarI18n {
	return inject(BrnCalendarI18nToken, { optional: true }) ?? defaultCalendarI18n;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/forms/README.md
```
# @spartan-ng/brain/forms

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/forms`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/forms/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/forms/src/index.ts
```typescript
export * from './lib/control-value-accessor';
export * from './lib/error-options';
export * from './lib/error-state-tracker';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/forms/src/lib/control-value-accessor.ts
```typescript
export type ChangeFn<T> = (value: T) => void;
export type TouchFn = () => void;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/forms/src/lib/error-options.ts
```typescript
import { Injectable } from '@angular/core';
import type { AbstractControl, FormGroupDirective, NgForm } from '@angular/forms';

/** Error state matcher that matches when a control is invalid and dirty. */
@Injectable()
export class ShowOnDirtyErrorStateMatcher implements ErrorStateMatcher {
	isInvalid(control: AbstractControl | null, form: FormGroupDirective | NgForm | null): boolean {
		return !!(control && control.invalid && (control.dirty || (form && form.submitted)));
	}
}

/** Provider that defines how form controls behave with regards to displaying error messages. */
@Injectable({ providedIn: 'root' })
export class ErrorStateMatcher {
	isInvalid(control: AbstractControl | null, form: FormGroupDirective | NgForm | null): boolean {
		return !!(control && control.invalid && (control.touched || (form && form.submitted)));
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/forms/src/lib/error-state-tracker.ts
```typescript
import { signal } from '@angular/core';
import type { AbstractControl, FormGroupDirective, NgControl, NgForm } from '@angular/forms';
import type { ErrorStateMatcher } from './error-options';

export class ErrorStateTracker {
	/** Whether the tracker is currently in an error state. */
	public readonly errorState = signal(false);

	/** User-defined matcher for the error state. */
	public matcher: ErrorStateMatcher | null = null;

	constructor(
		private readonly _defaultMatcher: ErrorStateMatcher | null,
		public ngControl: NgControl | null,
		private readonly _parentFormGroup: FormGroupDirective | null,
		private readonly _parentForm: NgForm | null,
	) {}

	/** Updates the error state based on the provided error state matcher. */
	updateErrorState() {
		const oldState = this.errorState();
		const parent = this._parentFormGroup || this._parentForm;
		const matcher = this.matcher || this._defaultMatcher;
		const control = this.ngControl ? (this.ngControl.control as AbstractControl) : null;
		const newState = matcher?.isInvalid(control, parent) ?? false;

		if (newState !== oldState) {
			this.errorState.set(newState);
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/core/README.md
```
# @spartan-ng/brain/core

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/core`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/core/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/core/src/index.ts
```typescript
export * from './helpers/custom-element-class-settable';
export * from './helpers/dev-mode';
export * from './helpers/exposes-side';
export * from './helpers/exposes-state';
export * from './helpers/hlm';
export * from './helpers/table-classes-settable';
export * from './helpers/zone-free';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/core/src/helpers/create-injection-token.ts
```typescript
import { type InjectOptions, InjectionToken, type Provider, type Type, forwardRef, inject } from '@angular/core';

type InjectFn<TTokenValue> = {
	(): TTokenValue;
	(injectOptions: InjectOptions & { optional?: false }): TTokenValue;
	(injectOptions: InjectOptions & { optional: true }): TTokenValue | null;
};

type ProvideFn<TTokenValue> = (value: TTokenValue) => Provider;

type ProvideExistingFn<TTokenValue> = (valueFactory: () => Type<TTokenValue>) => Provider;

export type CreateInjectionTokenReturn<TTokenValue> = [
	InjectFn<TTokenValue>,
	ProvideFn<TTokenValue>,
	ProvideExistingFn<TTokenValue>,
	InjectionToken<TTokenValue>,
];

export function createInjectionToken<TTokenValue>(description: string): CreateInjectionTokenReturn<TTokenValue> {
	const token = new InjectionToken<TTokenValue>(description);

	const provideFn = (value: TTokenValue) => {
		return { provide: token, useValue: value };
	};

	const provideExistingFn = (value: () => TTokenValue) => {
		return { provide: token, useExisting: forwardRef(value) };
	};

	const injectFn = (options: InjectOptions = {}) => {
		return inject(token, options);
	};

	return [injectFn, provideFn, provideExistingFn, token] as CreateInjectionTokenReturn<TTokenValue>;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/core/src/helpers/custom-element-class-settable.ts
```typescript
import { createInjectionToken } from './create-injection-token';

export interface CustomElementClassSettable {
	setClassToCustomElement: (newClass: string) => void;
}

export const [
	injectCustomClassSettable,
	provideCustomClassSettable,
	provideCustomClassSettableExisting,
	SET_CLASS_TO_CUSTOM_ELEMENT_TOKEN,
] = createInjectionToken<CustomElementClassSettable>('@spartan-ng SET_CLASS_TO_CUSTOM_ELEMENT_TOKEN');

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/core/src/helpers/dev-mode.ts
```typescript
declare const ngDevMode: boolean;
/**
 * Set by Angular to true when in development mode.
 * Allows for tree-shaking code that is only used in development.
 */
export const brnDevMode = ngDevMode;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/core/src/helpers/exposes-side.ts
```typescript
import type { Signal } from '@angular/core';
import { createInjectionToken } from './create-injection-token';

export interface ExposesSide {
	side: Signal<'top' | 'bottom' | 'left' | 'right'>;
}

export const [
	injectExposedSideProvider,
	provideExposedSideProvider,
	provideExposedSideProviderExisting,
	EXPOSES_SIDE_TOKEN,
] = createInjectionToken<ExposesSide>('@spartan-ng EXPOSES_SIDE_TOKEN');

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/core/src/helpers/exposes-state.ts
```typescript
import type { Signal } from '@angular/core';
import { createInjectionToken } from './create-injection-token';

export interface ExposesState {
	state: Signal<'open' | 'closed'>;
}

export const [
	injectExposesStateProvider,
	provideExposesStateProvider,
	provideExposesStateProviderExisting,
	EXPOSES_STATE_TOKEN,
] = createInjectionToken<ExposesState>('@spartan-ng EXPOSES_STATE_TOKEN');

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/core/src/helpers/hlm.ts
```typescript
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function hlm(...inputs: ClassValue[]) {
	return twMerge(clsx(inputs));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/core/src/helpers/table-classes-settable.ts
```typescript
import { createInjectionToken } from './create-injection-token';

export interface TableClassesSettable {
	setTableClasses: (classes: Partial<{ table: string; headerRow: string; bodyRow: string }>) => void;
}

export const [
	injectTableClassesSettable,
	provideTableClassesSettable,
	provideTableClassesSettableExisting,
	SET_TABLE_CLASSES_TOKEN,
] = createInjectionToken<TableClassesSettable>('@spartan-ng SET_TABLE_CLASSES_TOKEN');

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/core/src/helpers/zone-free.ts
```typescript
/**
 * We are building on shoulders of giants here and use the implementation provided by the incredible TaigaUI
 * team: https://github.com/taiga-family/taiga-ui/blob/main/projects/cdk/observables/zone-free.ts#L22
 * Check them out! Give them a try! Leave a star! Their work is incredible!
 */
import type { NgZone } from '@angular/core';
import { type MonoTypeOperatorFunction, Observable, pipe } from 'rxjs';

export function brnZoneFull<T>(zone: NgZone): MonoTypeOperatorFunction<T> {
	return (source) =>
		new Observable((subscriber) =>
			source.subscribe({
				next: (value) => zone.run(() => subscriber.next(value)),
				error: (error: unknown) => zone.run(() => subscriber.error(error)),
				complete: () => zone.run(() => subscriber.complete()),
			}),
		);
}

export function brnZoneFree<T>(zone: NgZone): MonoTypeOperatorFunction<T> {
	return (source) => new Observable((subscriber) => zone.runOutsideAngular(() => source.subscribe(subscriber)));
}

export function brnZoneOptimized<T>(zone: NgZone): MonoTypeOperatorFunction<T> {
	return pipe(brnZoneFree(zone), brnZoneFull(zone));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/progress/README.md
```
# @spartan-ng/brain/progress

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/progress`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/progress/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/progress/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { BrnProgressIndicatorComponent } from './lib/brn-progress-indicator.component';
import { BrnProgressComponent } from './lib/brn-progress.component';
export { injectBrnProgress } from './lib/brn-progress.token';

export * from './lib/brn-progress-indicator.component';
export * from './lib/brn-progress.component';

export const BrnProgressImports = [BrnProgressComponent, BrnProgressIndicatorComponent] as const;

@NgModule({
	imports: [...BrnProgressImports],
	exports: [...BrnProgressImports],
})
export class BrnProgressModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/progress/src/lib/brn-progress-indicator.component.ts
```typescript
import { Component } from '@angular/core';
import { injectBrnProgress } from './brn-progress.token';

@Component({
	selector: 'brn-progress-indicator',
	standalone: true,
	template: '',
	host: {
		'[attr.data-state]': 'progress.state()',
		'[attr.data-value]': 'progress.value()',
		'[attr.data-max]': 'progress.max()',
	},
})
export class BrnProgressIndicatorComponent {
	protected readonly progress = injectBrnProgress();
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/progress/src/lib/brn-progress.component.spec.ts
```typescript
import { Component } from '@angular/core';
import { render } from '@testing-library/angular';
import { BrnProgressModule } from '../index';
import { BrnProgressIndicatorComponent } from './brn-progress-indicator.component';
import { BrnProgressComponent, BrnProgressLabelFn } from './brn-progress.component';

@Component({
	imports: [BrnProgressModule],
	template: `
		<brn-progress [value]="value" [max]="max" [getValueLabel]="getValueLabel">
			<brn-progress-indicator />
		</brn-progress>
	`,
})
class TestHostComponent {
	public value: number | null | undefined = 0;
	public max = 100;
	public getValueLabel: BrnProgressLabelFn = (value, max) => `${Math.round((value / max) * 100)}%`;
}

describe('BrnProgressComponent', () => {
	it('should initialize with default values and set aria attributes', async () => {
		const { container } = await render(TestHostComponent, {
			imports: [BrnProgressComponent, BrnProgressIndicatorComponent],
		});
		const progressBar = container.querySelector('brn-progress');

		expect(progressBar?.getAttribute('aria-valuemax')).toBe('100');
		expect(progressBar?.getAttribute('aria-valuemin')).toBe('0');
		expect(progressBar?.getAttribute('aria-valuenow')).toBe('0');
		expect(progressBar?.getAttribute('aria-valuetext')).toBe('0%');
	});

	it('should display "indeterminate" state when value is null or undefined', async () => {
		const { fixture, container } = await render(TestHostComponent, {
			imports: [BrnProgressComponent, BrnProgressIndicatorComponent],
			componentProperties: { value: null },
		});
		fixture.detectChanges();

		const progressBar = container.querySelector('brn-progress');
		expect(progressBar?.getAttribute('data-state')).toBe('indeterminate');
		expect(progressBar?.getAttribute('aria-valuetext')).toBe(null);
	});

	it('should set aria attributes based on provided value and max', async () => {
		const { fixture, container } = await render(TestHostComponent, {
			imports: [BrnProgressComponent, BrnProgressIndicatorComponent],
			componentProperties: { value: 50, max: 200 },
		});
		fixture.detectChanges();

		const progressBar = container.querySelector('brn-progress');
		expect(progressBar?.getAttribute('aria-valuenow')).toBe('50');
		expect(progressBar?.getAttribute('aria-valuemax')).toBe('200');
		expect(progressBar?.getAttribute('aria-valuetext')).toBe('25%');
	});

	it('should set state to "complete" when value equals max', async () => {
		const { fixture, container } = await render(TestHostComponent, {
			imports: [BrnProgressComponent, BrnProgressIndicatorComponent],
			componentProperties: { value: 100, max: 100 },
		});
		fixture.detectChanges();

		const progressBar = container.querySelector('brn-progress');
		expect(progressBar?.getAttribute('data-state')).toBe('complete');
	});

	it('should set state to "loading" when value is within bounds and not equal to max', async () => {
		const { fixture, container } = await render(TestHostComponent, {
			imports: [BrnProgressComponent, BrnProgressIndicatorComponent],
			componentProperties: { value: 50, max: 100 },
		});
		fixture.detectChanges();

		const progressBar = container.querySelector('brn-progress');
		expect(progressBar?.getAttribute('data-state')).toBe('loading');
	});

	it('should throw an error if value is out of bounds', async () => {
		const { fixture } = await render(TestHostComponent, {
			imports: [BrnProgressComponent, BrnProgressIndicatorComponent],
		});

		expect(() => {
			fixture.componentInstance.value = 150;
			fixture.detectChanges();
		}).toThrow('Value must be 0 or greater and less or equal to max');

		expect(() => {
			fixture.componentInstance.value = -10;
			fixture.detectChanges();
		}).toThrow('Value must be 0 or greater and less or equal to max');
	});

	it('should throw an error if max is set to a negative number', async () => {
		const { fixture } = await render(TestHostComponent, {
			imports: [BrnProgressComponent, BrnProgressIndicatorComponent],
		});

		expect(() => {
			fixture.componentInstance.max = -50;
			fixture.detectChanges();
		}).toThrow('Value must be 0 or greater and less or equal to max');
	});

	it('should reflect state, value, and max in BrnProgressIndicatorComponent', async () => {
		const { fixture, container } = await render(TestHostComponent, {
			imports: [BrnProgressComponent, BrnProgressIndicatorComponent],
			componentProperties: { value: 30, max: 100 },
		});
		fixture.detectChanges();

		const indicator = container.querySelector('brn-progress-indicator');
		expect(indicator?.getAttribute('data-state')).toBe('loading');
		expect(indicator?.getAttribute('data-value')).toBe('30');
		expect(indicator?.getAttribute('data-max')).toBe('100');
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/progress/src/lib/brn-progress.component.ts
```typescript
import { type NumberInput } from '@angular/cdk/coercion';
import { Component, OnChanges, SimpleChanges, computed, input, numberAttribute } from '@angular/core';
import { provideBrnProgress } from './brn-progress.token';

@Component({
	selector: 'brn-progress',
	standalone: true,
	template: '<ng-content/>',
	exportAs: 'brnProgress',
	providers: [provideBrnProgress(BrnProgressComponent)],
	host: {
		role: 'progressbar',
		'[attr.aria-valuemax]': 'max()',
		'[attr.aria-valuemin]': '0',
		'[attr.aria-valuenow]': 'value()',
		'[attr.aria-valuetext]': 'label()',
		'[attr.data-state]': 'state()',
		'[attr.data-value]': 'value()',
		'[attr.data-max]': 'max()',
	},
})
export class BrnProgressComponent implements OnChanges {
	public readonly value = input<number | null | undefined, NumberInput>(undefined, {
		transform: (value) => (value === undefined || value === null ? undefined : Number(value)),
	});
	public readonly max = input<number, NumberInput>(100, { transform: numberAttribute });
	public readonly getValueLabel = input<BrnProgressLabelFn>((value, max) => `${Math.round((value / max) * 100)}%`);
	protected readonly label = computed(() => {
		const value = this.value();
		return value === null || value === undefined ? undefined : this.getValueLabel()(value, this.max());
	});

	protected readonly state = computed(() => {
		const value = this.value();
		const max = this.max();

		return value === null || value === undefined ? 'indeterminate' : value === max ? 'complete' : 'loading';
	});

	ngOnChanges(changes: SimpleChanges): void {
		if ('value' in changes || 'max' in changes) {
			this.validate();
		}
	}

	private validate(): void {
		// validate that the value is within the bounds of the max
		const value = this.value();
		const max = this.max();

		if (value === null || value === undefined) {
			return;
		}

		if (value > max || value < 0) {
			throw Error('Value must be 0 or greater and less or equal to max');
		}

		if (max < 0) {
			throw Error('max must be greater than 0');
		}
	}
}

export type BrnProgressLabelFn = (value: number, max: number) => string;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/progress/src/lib/brn-progress.token.ts
```typescript
import { ExistingProvider, InjectionToken, Type, inject } from '@angular/core';
import type { BrnProgressComponent } from './brn-progress.component';

const BrnProgressToken = new InjectionToken<BrnProgressComponent>('BrnProgressComponent');

export function provideBrnProgress(progress: Type<BrnProgressComponent>): ExistingProvider {
	return { provide: BrnProgressToken, useExisting: progress };
}

export function injectBrnProgress(): BrnProgressComponent {
	return inject(BrnProgressToken);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/alert-dialog/README.md
```
# @spartan-ng/brain/alert-dialog

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/alert-dialog`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/alert-dialog/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/alert-dialog/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { BrnAlertDialogContentDirective } from './lib/brn-alert-dialog-content.directive';
import { BrnAlertDialogDescriptionDirective } from './lib/brn-alert-dialog-description.directive';
import { BrnAlertDialogOverlayComponent } from './lib/brn-alert-dialog-overlay.component';
import { BrnAlertDialogTitleDirective } from './lib/brn-alert-dialog-title.directive';
import { BrnAlertDialogTriggerDirective } from './lib/brn-alert-dialog-trigger.directive';
import { BrnAlertDialogComponent } from './lib/brn-alert-dialog.component';

export * from './lib/brn-alert-dialog-content.directive';
export * from './lib/brn-alert-dialog-description.directive';
export * from './lib/brn-alert-dialog-overlay.component';
export * from './lib/brn-alert-dialog-title.directive';
export * from './lib/brn-alert-dialog-trigger.directive';
export * from './lib/brn-alert-dialog.component';

export const BrnAlertDialogImports = [
	BrnAlertDialogComponent,
	BrnAlertDialogOverlayComponent,
	BrnAlertDialogTriggerDirective,
	BrnAlertDialogContentDirective,
	BrnAlertDialogTitleDirective,
	BrnAlertDialogDescriptionDirective,
] as const;

@NgModule({
	imports: [...BrnAlertDialogImports],
	exports: [...BrnAlertDialogImports],
})
export class BrnAlertDialogModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/alert-dialog/src/lib/brn-alert-dialog-content.directive.ts
```typescript
import { Directive } from '@angular/core';
import { provideExposesStateProviderExisting } from '@spartan-ng/brain/core';
import { BrnDialogContentDirective } from '@spartan-ng/brain/dialog';

@Directive({
	selector: '[brnAlertDialogContent]',
	standalone: true,
	providers: [provideExposesStateProviderExisting(() => BrnAlertDialogContentDirective)],
})
export class BrnAlertDialogContentDirective<T> extends BrnDialogContentDirective<T> {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/alert-dialog/src/lib/brn-alert-dialog-description.directive.ts
```typescript
import { Directive } from '@angular/core';
import { BrnDialogDescriptionDirective } from '@spartan-ng/brain/dialog';

@Directive({
	selector: '[brnAlertDialogDescription]',
	standalone: true,
	host: {
		'[id]': '_id()',
	},
})
export class BrnAlertDialogDescriptionDirective extends BrnDialogDescriptionDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/alert-dialog/src/lib/brn-alert-dialog-overlay.component.ts
```typescript
import { ChangeDetectionStrategy, Component, ViewEncapsulation } from '@angular/core';
import { provideCustomClassSettableExisting } from '@spartan-ng/brain/core';
import { BrnDialogOverlayComponent } from '@spartan-ng/brain/dialog';

@Component({
	selector: 'brn-alert-dialog-overlay',
	standalone: true,
	providers: [provideCustomClassSettableExisting(() => BrnAlertDialogOverlayComponent)],
	template: '',
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class BrnAlertDialogOverlayComponent extends BrnDialogOverlayComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/alert-dialog/src/lib/brn-alert-dialog-title.directive.ts
```typescript
import { Directive } from '@angular/core';
import { BrnDialogTitleDirective } from '@spartan-ng/brain/dialog';

@Directive({
	selector: '[brnAlertDialogTitle]',
	standalone: true,
	host: {
		'[id]': '_id()',
	},
})
export class BrnAlertDialogTitleDirective extends BrnDialogTitleDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/alert-dialog/src/lib/brn-alert-dialog-trigger.directive.ts
```typescript
import { Directive, effect, input, untracked } from '@angular/core';
import { BrnDialogTriggerDirective } from '@spartan-ng/brain/dialog';
import type { BrnAlertDialogComponent } from './brn-alert-dialog.component';

@Directive({
	selector: 'button[brnAlertDialogTrigger],button[brnAlertDialogTriggerFor]',
	standalone: true,
	host: {
		'[id]': 'id()',
		'aria-haspopup': 'dialog',
		'[attr.aria-expanded]': "state() === 'open' ? 'true': 'false'",
		'[attr.data-state]': 'state()',
		'[attr.aria-controls]': 'dialogId',
	},
})
export class BrnAlertDialogTriggerDirective extends BrnDialogTriggerDirective {
	public readonly brnAlertDialogTriggerFor = input<BrnAlertDialogComponent | undefined>();

	constructor() {
		super();
		effect(() => {
			const brnDialog = this.brnAlertDialogTriggerFor();
			untracked(() => {
				if (brnDialog) {
					this.mutableBrnDialogTriggerFor().set(brnDialog);
				}
			});
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/alert-dialog/src/lib/brn-alert-dialog.component.ts
```typescript
import { ChangeDetectionStrategy, Component, forwardRef, ViewEncapsulation } from '@angular/core';
import { BrnDialogComponent, BrnDialogDefaultOptions, provideBrnDialogDefaultOptions } from '@spartan-ng/brain/dialog';

export const BRN_ALERT_DIALOG_DEFAULT_OPTIONS: Partial<BrnDialogDefaultOptions> = {
	closeOnBackdropClick: false,
	closeOnOutsidePointerEvents: false,
	role: 'alertdialog',
};

@Component({
	selector: 'brn-alert-dialog',
	standalone: true,
	template: `
		<ng-content />
	`,
	providers: [
		{
			provide: BrnDialogComponent,
			useExisting: forwardRef(() => BrnAlertDialogComponent),
		},
		provideBrnDialogDefaultOptions(BRN_ALERT_DIALOG_DEFAULT_OPTIONS),
	],
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	exportAs: 'brnAlertDialog',
})
export class BrnAlertDialogComponent extends BrnDialogComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/accordion/README.md
```
# @spartan-ng/brain/accordion

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/accordion`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/accordion/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/accordion/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { BrnAccordionContentComponent } from './lib/brn-accordion-content.component';
import {
	BrnAccordionDirective,
	BrnAccordionItemDirective,
	BrnAccordionTriggerDirective,
} from './lib/brn-accordion.directive';

export * from './lib/brn-accordion-content.component';
export * from './lib/brn-accordion.directive';

export const BrnAccordionImports = [
	BrnAccordionDirective,
	BrnAccordionContentComponent,
	BrnAccordionItemDirective,
	BrnAccordionTriggerDirective,
] as const;

@NgModule({
	imports: [...BrnAccordionImports],
	exports: [...BrnAccordionImports],
})
export class BrnAccordionModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/accordion/src/lib/brn-accordion-content.component.ts
```typescript
import { ChangeDetectionStrategy, Component, ViewEncapsulation, computed, inject, signal } from '@angular/core';
import type { CustomElementClassSettable } from '@spartan-ng/brain/core';
import type { ClassValue } from 'clsx';
import { BrnAccordionItemDirective } from './brn-accordion.directive';

@Component({
	selector: 'brn-accordion-content',
	standalone: true,
	host: {
		'[attr.data-state]': 'state()',
		'[attr.aria-labelledby]': 'ariaLabeledBy',
		role: 'region',
		'[id]': 'id',
	},
	template: `
		<div [attr.inert]="_addInert()" style="overflow: hidden">
			<p [class]="_contentClass()">
				<ng-content />
			</p>
		</div>
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class BrnAccordionContentComponent implements CustomElementClassSettable {
	private readonly _item = inject(BrnAccordionItemDirective);

	public readonly state = this._item.state;
	public readonly id = `brn-accordion-content-${this._item.id}`;
	public readonly ariaLabeledBy = `brn-accordion-trigger-${this._item.id}`;

	protected readonly _addInert = computed(() => (this.state() === 'closed' ? true : undefined));
	protected readonly _contentClass = signal<ClassValue>('');

	constructor() {
		if (!this._item) {
			throw Error('Accordion Content can only be used inside an AccordionItem. Add brnAccordionItem to parent.');
		}
	}

	public setClassToCustomElement(classes: ClassValue) {
		this._contentClass.set(classes);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/accordion/src/lib/brn-accordion.directive.spec.ts
```typescript
import { createEvent, fireEvent, render, screen, waitFor } from '@testing-library/angular';
import userEvent from '@testing-library/user-event';
import {
	BrnAccordionDirective,
	BrnAccordionItemDirective,
	BrnAccordionTriggerDirective,
} from './brn-accordion.directive';

describe('BrnAccordionDirective', () => {
	const setup = async () => {
		const container = await render(
			`
      <div brnAccordion aria-label="acco">
        <div brnAccordionItem>
          <button brnAccordionTrigger aria-label="trigger">
            Is it accessible?
          </button>
          asdf
        </div>
        <div brnAccordionItem>
          <button brnAccordionTrigger aria-label="trigger">
            Is it styled?
          </button>
            Yes. It comes with default styles that match the other components' aesthetics.
        </div>
        <div brnAccordionItem>
          <button brnAccordionTrigger aria-label="trigger">
            Is it animated?
          </button>
            Yes. It's animated by default, but you can disable it if you prefer.
        </div>
      </div>
    `,
			{
				imports: [BrnAccordionDirective, BrnAccordionItemDirective, BrnAccordionTriggerDirective],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			triggers: screen.getAllByLabelText('trigger'),
			accordion: screen.getByLabelText('acco'),
		};
	};
	const setupMulti = async () => {
		const container = await render(
			`
      <div brnAccordion type="multiple" orientation="horizontal" aria-label="acco">
        <div brnAccordionItem>
          <button brnAccordionTrigger aria-label="trigger">
            Is it accessible?
          </button>
          asdf
        </div>
        <div brnAccordionItem>
          <button brnAccordionTrigger aria-label="trigger">
            Is it styled?
          </button>
            Yes. It comes with default styles that match the other components' aesthetics.
        </div>
        <div brnAccordionItem>
          <button brnAccordionTrigger aria-label="trigger">
            Is it animated?
          </button>
            Yes. It's animated by default, but you can disable it if you prefer.
        </div>
      </div>
    `,
			{
				imports: [BrnAccordionDirective, BrnAccordionItemDirective, BrnAccordionTriggerDirective],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			triggers: screen.getAllByLabelText('trigger'),
			accordion: screen.getByLabelText('acco'),
		};
	};
	const setupWithInput = async () => {
		const container = await render(
			`
      <div brnAccordion aria-label="acco">
        <div brnAccordionItem>
          <button brnAccordionTrigger aria-label="trigger">
           	Enter your name
          </button>

          <input data-testid="accordion-input" />
        </div>
      </div>
    `,
			{
				imports: [BrnAccordionDirective, BrnAccordionItemDirective, BrnAccordionTriggerDirective],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			trigger: screen.getByLabelText('trigger'),
			accordion: screen.getByLabelText('acco'),
			input: screen.getByTestId('accordion-input'),
		};
	};
	const validateOpenClosed = async (triggers: HTMLElement[], accordion: HTMLElement, openedTriggers: boolean[]) => {
		await waitFor(() => {
			expect(triggers[0]).toHaveAttribute('data-state', openedTriggers[0] ? 'open' : 'closed');
			expect(triggers[1]).toHaveAttribute('data-state', openedTriggers[1] ? 'open' : 'closed');
			expect(triggers[2]).toHaveAttribute('data-state', openedTriggers[2] ? 'open' : 'closed');
			const anyOpen = openedTriggers.some((t) => t);
			expect(accordion).toHaveAttribute('data-state', anyOpen ? 'open' : 'closed');
		});
	};

	describe('single accordion', () => {
		it('initial state all datastate closed', async () => {
			const { triggers, accordion } = await setup();
			await validateOpenClosed(triggers, accordion, [false, false, false]);
			expect(accordion).toHaveAttribute('data-orientation', 'vertical');
		});
		it('should open the trigger on click ', async () => {
			const { user, triggers, accordion } = await setup();
			await user.click(triggers[0]);
			await validateOpenClosed(triggers, accordion, [true, false, false]);
			await user.click(triggers[1]);
			await validateOpenClosed(triggers, accordion, [false, true, false]);
			await user.click(triggers[1]);
			await validateOpenClosed(triggers, accordion, [false, false, false]);
			await user.click(triggers[2]);
			await validateOpenClosed(triggers, accordion, [false, false, true]);
			await user.click(triggers[1]);
			await validateOpenClosed(triggers, accordion, [false, true, false]);
		});
		it('should open the trigger on enter and space ', async () => {
			const { user, triggers, accordion } = await setup();
			await user.keyboard('[Tab][Enter]');
			await validateOpenClosed(triggers, accordion, [true, false, false]);
			await user.keyboard('[Tab][Enter]');
			await validateOpenClosed(triggers, accordion, [false, true, false]);
			await user.keyboard('[Space]');
			await validateOpenClosed(triggers, accordion, [false, false, false]);
			await user.keyboard('[Tab][Enter]');
			await validateOpenClosed(triggers, accordion, [false, false, true]);
			await user.keyboard('{Shift>}[Tab]{/Shift}[Space]');
			await validateOpenClosed(triggers, accordion, [false, true, false]);
		});
		it('should open the trigger on enter and space and prevent default for enter also on second entry', async () => {
			const { user, accordion } = await setup();
			const keyboardEventEnter = createEvent.keyDown(accordion, {
				key: 'Enter',
				code: 'Enter',
				which: 13,
				keyCode: 13,
			});
			await user.keyboard('[Tab][Tab]');
			fireEvent(accordion, keyboardEventEnter);
			expect(keyboardEventEnter.defaultPrevented).toBe(true);
		});
	});
	describe('multi accordion', () => {
		it('initial state all datastate closed', async () => {
			const { triggers, accordion } = await setupMulti();
			await validateOpenClosed(triggers, accordion, [false, false, false]);
			expect(accordion).toHaveAttribute('data-orientation', 'horizontal');
		});
		it('should open the trigger on click ', async () => {
			const { user, triggers, accordion } = await setupMulti();

			await user.click(triggers[0]);
			await validateOpenClosed(triggers, accordion, [true, false, false]);
			await user.click(triggers[1]);
			await validateOpenClosed(triggers, accordion, [true, true, false]);
			await user.click(triggers[1]);
			await validateOpenClosed(triggers, accordion, [true, false, false]);
			await user.click(triggers[2]);
			await validateOpenClosed(triggers, accordion, [true, false, true]);
			await user.click(triggers[1]);
			await validateOpenClosed(triggers, accordion, [true, true, true]);
		});
	});
	describe('accordion with input', () => {
		it('should allow typing space', async () => {
			const { user, trigger, input } = await setupWithInput();

			// Open the accordion and tab to the input
			await user.click(trigger);
			await user.tab();

			expect(trigger).toHaveAttribute('data-state', 'open');
			expect(input).toHaveFocus();

			// Type a name with a space
			await user.type(input, 'John Doe');
			expect(input).toHaveValue('John Doe');

			// Go back to the trigger and hit space
			await user.tab({ shift: true });
			await user.keyboard('[Space]');

			// Trigger should be closed
			expect(trigger).toHaveAttribute('data-state', 'closed');
			expect(trigger).toHaveFocus();
		});
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/accordion/src/lib/brn-accordion.directive.ts
```typescript
import { FocusKeyManager, FocusMonitor } from '@angular/cdk/a11y';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import {
	type AfterContentInit,
	Directive,
	ElementRef,
	HostListener,
	type OnDestroy,
	computed,
	contentChildren,
	effect,
	inject,
	input,
	signal,
	untracked,
} from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { fromEvent } from 'rxjs';

@Directive({
	selector: '[brnAccordionItem]',
	standalone: true,
	host: {
		'[attr.data-state]': 'state()',
	},
	exportAs: 'brnAccordionItem',
})
export class BrnAccordionItemDirective {
	private static _itemIdGenerator = 0;
	private readonly _accordion = inject(BrnAccordionDirective);
	public readonly isOpened = input(false, { transform: coerceBooleanProperty });

	public readonly id = BrnAccordionItemDirective._itemIdGenerator++;
	public readonly state = computed(() => (this._accordion.openItemIds().includes(this.id) ? 'open' : 'closed'));

	constructor() {
		if (!this._accordion) {
			throw Error('Accordion trigger can only be used inside an Accordion. Add brnAccordion to ancestor.');
		}
		effect(() => {
			const isOpened = this.isOpened();
			untracked(() => {
				if (isOpened) {
					this._accordion.openItem(this.id);
				} else {
					this._accordion.closeItem(this.id);
				}
			});
		});
	}
}

@Directive({
	selector: '[brnAccordionTrigger]',
	standalone: true,
	host: {
		'[attr.data-state]': 'state()',
		'[attr.aria-expanded]': 'state() === "open"',
		'[attr.aria-controls]': 'ariaControls',
		role: 'heading',
		'aria-level': '3',
		'[id]': 'id',
	},
})
export class BrnAccordionTriggerDirective {
	private readonly _accordion = inject(BrnAccordionDirective);
	private readonly _item = inject(BrnAccordionItemDirective);
	private readonly _elementRef = inject(ElementRef);

	public readonly state = this._item.state;
	public readonly id = `brn-accordion-trigger-${this._item.id}`;
	public readonly ariaControls = `brn-accordion-content-${this._item.id}`;

	constructor() {
		if (!this._accordion) {
			throw Error('Accordion trigger can only be used inside an Accordion. Add brnAccordion to ancestor.');
		}

		if (!this._item) {
			throw Error('Accordion trigger can only be used inside an AccordionItem. Add brnAccordionItem to parent.');
		}

		fromEvent(this._elementRef.nativeElement, 'focus')
			.pipe(takeUntilDestroyed())
			.subscribe(() => {
				this._accordion.setActiveItem(this);
			});
	}

	@HostListener('click', ['$event'])
	@HostListener('keyup.space', ['$event'])
	@HostListener('keyup.enter', ['$event'])
	protected toggle(event: Event): void {
		event.preventDefault();
		this._accordion.toggleItem(this._item.id);
	}

	public focus() {
		this._elementRef.nativeElement.focus();
	}
}

const HORIZONTAL_KEYS_TO_PREVENT_DEFAULT = [
	'ArrowLeft',
	'ArrowRight',
	'PageDown',
	'PageUp',
	'Home',
	'End',
	' ',
	'Enter',
];
const VERTICAL_KEYS_TO_PREVENT_DEFAULT = ['ArrowUp', 'ArrowDown', 'PageDown', 'PageUp', 'Home', 'End', ' ', 'Enter'];

@Directive({
	selector: '[brnAccordion]',
	standalone: true,
	host: {
		'[attr.data-state]': 'state()',
		'[attr.data-orientation]': 'orientation()',
	},
	exportAs: 'brnAccordion',
})
export class BrnAccordionDirective implements AfterContentInit, OnDestroy {
	private readonly _el = inject(ElementRef);
	private _keyManager?: FocusKeyManager<BrnAccordionTriggerDirective>;
	private readonly _focusMonitor = inject(FocusMonitor);

	private readonly _focused = signal<boolean>(false);
	private readonly _openItemIds = signal<number[]>([]);
	public readonly openItemIds = this._openItemIds.asReadonly();
	public readonly state = computed(() => (this._openItemIds().length > 0 ? 'open' : 'closed'));

	public triggers = contentChildren(BrnAccordionTriggerDirective, { descendants: true });

	public readonly type = input<'single' | 'multiple'>('single');
	public readonly dir = input<'ltr' | 'rtl' | null>(null);
	public readonly orientation = input<'horizontal' | 'vertical'>('vertical');

	public ngAfterContentInit() {
		this._keyManager = new FocusKeyManager<BrnAccordionTriggerDirective>(this.triggers())
			.withHomeAndEnd()
			.withPageUpDown()
			.withWrap();

		if (this.orientation() === 'horizontal') {
			this._keyManager.withHorizontalOrientation(this.dir() ?? 'ltr').withVerticalOrientation(false);
		}

		this._el.nativeElement.addEventListener('keydown', (event: KeyboardEvent) => {
			const target = event.target as HTMLElement;

			if (target.tagName === 'INPUT') return;

			this._keyManager?.onKeydown(event);
			this.preventDefaultEvents(event);
		});
		this._focusMonitor.monitor(this._el, true).subscribe((origin) => this._focused.set(origin !== null));
	}

	ngOnDestroy(): void {
		this._focusMonitor.stopMonitoring(this._el);
	}

	public setActiveItem(item: BrnAccordionTriggerDirective) {
		this._keyManager?.setActiveItem(item);
	}

	public toggleItem(id: number) {
		if (this._openItemIds().includes(id)) {
			this.closeItem(id);
			return;
		}
		this.openItem(id);
	}

	public openItem(id: number) {
		if (this.type() === 'single') {
			this._openItemIds.set([id]);
			return;
		}
		this._openItemIds.update((ids) => [...ids, id]);
	}
	public closeItem(id: number) {
		this._openItemIds.update((ids) => ids.filter((openId) => id !== openId));
	}

	private preventDefaultEvents(event: KeyboardEvent) {
		if (!this._focused()) return;
		if (!('key' in event)) return;

		const keys =
			this.orientation() === 'horizontal' ? HORIZONTAL_KEYS_TO_PREVENT_DEFAULT : VERTICAL_KEYS_TO_PREVENT_DEFAULT;
		if (keys.includes(event.key) && event.code !== 'NumpadEnter') {
			event.preventDefault();
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/separator/README.md
```
# @spartan-ng/brain/separator

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/separator`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/separator/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/separator/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { BrnSeparatorComponent } from './lib/brn-separator.component';

export * from './lib/brn-separator.component';

@NgModule({
	imports: [BrnSeparatorComponent],
	exports: [BrnSeparatorComponent],
})
export class BrnSeparatorModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/separator/src/lib/brn-separator.component.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { Component, booleanAttribute, computed, input } from '@angular/core';

export type BrnSeparatorOrientation = 'horizontal' | 'vertical';

@Component({
	selector: 'brn-separator',
	standalone: true,
	template: '',
	host: {
		'[role]': 'role()',
		'[attr.aria-orientation]': 'ariaOrientation()',
		'[attr.data-orientation]': 'orientation()',
	},
})
export class BrnSeparatorComponent {
	public readonly orientation = input<BrnSeparatorOrientation>('horizontal');
	public readonly decorative = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

	protected readonly role = computed(() => (this.decorative() ? 'none' : 'separator'));
	protected readonly ariaOrientation = computed(() =>
		this.decorative() ? undefined : this.orientation() === 'vertical' ? 'vertical' : undefined,
	);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/hover-card/README.md
```
# @spartan-ng/brain/hover-card

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/hover-card`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/hover-card/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/hover-card/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { BrnHoverCardContentDirective, BrnHoverCardTriggerDirective } from './lib/brn-hover-card-content.service';
import { BrnHoverCardComponent } from './lib/brn-hover-card.component';

export * from './lib/brn-hover-card-content.service';
export * from './lib/brn-hover-card.component';
export * from './lib/createHoverObservable';

export const BrnHoverCardImports = [
	BrnHoverCardComponent,
	BrnHoverCardContentDirective,
	BrnHoverCardTriggerDirective,
] as const;

@NgModule({
	imports: [...BrnHoverCardImports],
	exports: [...BrnHoverCardImports],
})
export class BrnHoverCardModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/hover-card/src/lib/brn-hover-card-content.service.ts
```typescript
import { FocusMonitor } from '@angular/cdk/a11y';
import {
	type ConnectedOverlayPositionChange,
	type ConnectedPosition,
	type FlexibleConnectedPositionStrategy,
	Overlay,
	type OverlayConfig,
	OverlayPositionBuilder,
	type OverlayRef,
} from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import {
	computed,
	Directive,
	effect,
	ElementRef,
	inject,
	Injectable,
	input,
	NgZone,
	type OnDestroy,
	type OnInit,
	type Signal,
	signal,
	TemplateRef,
	untracked,
	ViewContainerRef,
} from '@angular/core';
import { toSignal } from '@angular/core/rxjs-interop';
import {
	type ExposesSide,
	type ExposesState,
	provideExposedSideProviderExisting,
	provideExposesStateProviderExisting,
} from '@spartan-ng/brain/core';
import { BehaviorSubject, fromEvent, merge, Observable, of, Subject } from 'rxjs';
import { delay, distinctUntilChanged, filter, map, share, switchMap, takeUntil, tap } from 'rxjs/operators';
import { createHoverObservable } from './createHoverObservable';

@Directive({
	selector: '[brnHoverCardContent]',
	standalone: true,
	exportAs: 'brnHoverCardContent',
	providers: [
		provideExposedSideProviderExisting(() => BrnHoverCardContentDirective),
		provideExposesStateProviderExisting(() => BrnHoverCardContentDirective),
	],
})
export class BrnHoverCardContentDirective implements ExposesState, ExposesSide {
	private readonly _contentService = inject(BrnHoverCardContentService);
	public readonly state = this._contentService.state;
	public readonly side = this._contentService.side;
	public readonly template = inject(TemplateRef);
}

/**
 * We are building on shoulders of giants here and use the implementation provided by the incredible TaigaUI
 * team: https://github.com/taiga-family/taiga-ui/blob/main/projects/core/directives/dropdown/dropdown-hover.directive.ts
 * Check them out! Give them a try! Leave a star! Their work is incredible!
 */

export type BrnHoverCardOptions = Partial<
	{
		attachTo: ElementRef;
		attachPositions: ConnectedPosition[];
		align: 'top' | 'bottom';
		sideOffset: number;
	} & OverlayConfig
>;

const topFirstPositions: ConnectedPosition[] = [
	{
		originX: 'center',
		originY: 'top',
		overlayX: 'center',
		overlayY: 'bottom',
	},
	{
		originX: 'center',
		originY: 'bottom',
		overlayX: 'center',
		overlayY: 'top',
	},
];
const bottomFirstPositions: ConnectedPosition[] = [
	{
		originX: 'center',
		originY: 'bottom',
		overlayX: 'center',
		overlayY: 'top',
	},
	{
		originX: 'center',
		originY: 'top',
		overlayX: 'center',
		overlayY: 'bottom',
	},
];

@Injectable()
export class BrnHoverCardContentService {
	private readonly _overlay = inject(Overlay);
	private readonly _zone = inject(NgZone);
	private readonly _psBuilder = inject(OverlayPositionBuilder);

	private readonly _content = signal<TemplatePortal<unknown> | null>(null);
	private readonly _state = signal<'open' | 'closed'>('closed');

	private _config: BrnHoverCardOptions = {};
	private _overlayRef?: OverlayRef;
	private _positionStrategy?: FlexibleConnectedPositionStrategy;
	private _destroyed$ = new Subject<void>();

	private readonly _positionChangesObservables$ = new BehaviorSubject<
		Observable<ConnectedOverlayPositionChange> | undefined
	>(undefined);
	private readonly _overlayHoveredObservables$ = new BehaviorSubject<Observable<boolean> | undefined>(undefined);

	public readonly positionChanges$: Observable<ConnectedOverlayPositionChange> = this._positionChangesObservables$.pipe(
		switchMap((positionChangeObservable) => (positionChangeObservable ? positionChangeObservable : of(undefined))),
		filter((change): change is NonNullable<ConnectedOverlayPositionChange> => change !== undefined && change !== null),
	);
	public readonly hovered$: Observable<boolean> = this._overlayHoveredObservables$.pipe(
		switchMap((overlayHoveredObservable) => (overlayHoveredObservable ? overlayHoveredObservable : of(false))),
	);

	public readonly state = this._state.asReadonly();
	public readonly side: Signal<'top' | 'bottom' | 'left' | 'right'> = toSignal(
		this.positionChanges$.pipe(
			map<ConnectedOverlayPositionChange, 'top' | 'bottom' | 'left' | 'right'>((change) =>
				// todo: better translation or adjusting hlm to take that into account
				change.connectionPair.originY === 'center'
					? change.connectionPair.originX === 'start'
						? 'left'
						: 'right'
					: change.connectionPair.originY,
			),
		),
		{ initialValue: 'bottom' },
	);

	public setConfig(config: BrnHoverCardOptions) {
		this._config = config;
		if (config.attachTo) {
			this._positionStrategy = this._psBuilder
				.flexibleConnectedTo(config.attachTo)
				.withPositions((config.attachPositions ?? config.align === 'top') ? topFirstPositions : bottomFirstPositions)
				.withDefaultOffsetY(config.sideOffset ?? 0);
			this._config = {
				...this._config,
				positionStrategy: this._positionStrategy,
				scrollStrategy: this._overlay.scrollStrategies.reposition(),
			};
			this._positionChangesObservables$.next(this._positionStrategy.positionChanges);
		}
		this._overlayRef = this._overlay.create(this._config);
	}

	public setContent(value: TemplateRef<unknown> | BrnHoverCardContentDirective, vcr: ViewContainerRef) {
		this._content.set(new TemplatePortal<unknown>(value instanceof TemplateRef ? value : value.template, vcr));

		if (!this._overlayRef) {
			this._overlayRef = this._overlay.create(this._config);
		}
	}

	public setState(newState: 'open' | 'closed') {
		this._state.set(newState);
	}

	public show() {
		const content = this._content();
		if (!content || !this._overlayRef) return;

		this._overlayRef?.detach();
		this._overlayRef?.attach(content);

		this._destroyed$ = new Subject<void>();

		this._overlayHoveredObservables$.next(
			createHoverObservable(this._overlayRef.hostElement, this._zone, this._destroyed$),
		);
	}

	public hide() {
		this._overlayRef?.detach();
		this._destroyed$.next();
		this._destroyed$.complete();
		this._destroyed$ = new Subject<void>();
	}
}

@Directive({
	selector: '[brnHoverCardTrigger]:not(ng-container),[brnHoverCardTriggerFor]:not(ng-container)',
	standalone: true,
	exportAs: 'brnHoverCardTrigger',
})
export class BrnHoverCardTriggerDirective implements OnInit, OnDestroy {
	private readonly _destroy$ = new Subject<void>();
	private readonly _vcr = inject(ViewContainerRef);
	private readonly _zone = inject(NgZone);
	private readonly _el = inject(ElementRef);
	private readonly _contentService = inject(BrnHoverCardContentService);
	private readonly _focusMonitor = inject(FocusMonitor);

	public readonly focused$: Observable<boolean> = this._focusMonitor.monitor(this._el).pipe(map((e) => e !== null));

	public readonly hovered$: Observable<boolean> = merge(
		fromEvent(this._el.nativeElement, 'click').pipe(map(() => false)),
		createHoverObservable(this._el.nativeElement, this._zone, this._destroy$),
		this._contentService.hovered$,
		this.focused$,
	).pipe(distinctUntilChanged());
	public readonly showing$: Observable<boolean> = this.hovered$.pipe(
		// we set the state to open here because we are about to open show the content
		tap((visible) => visible && this._contentService.setState('open')),
		switchMap((visible) => {
			// we are delaying based on the configure-able input
			return of(visible).pipe(delay(visible ? this.showDelay() : this.hideDelay()));
		}),
		switchMap((visible) => {
			// don't do anything when we are in the process of showing the content
			if (visible) return of(visible);
			// we set the state to closed here to trigger any animations for the element leaving
			this._contentService.setState('closed');
			// then delay to wait for the leaving animation to finish
			return of(visible).pipe(delay(this.animationDelay()));
		}),
		distinctUntilChanged(),
		share(),
		takeUntil(this._destroy$),
	);

	public showDelay = input(300);
	public hideDelay = input(500);
	public animationDelay = input(100);
	public sideOffset = input(5);
	public align = input<'top' | 'bottom'>('bottom');

	public readonly brnHoverCardTriggerFor = input<TemplateRef<unknown> | BrnHoverCardContentDirective | undefined>(
		undefined,
	);
	public readonly mutableBrnHoverCardTriggerFor = computed(() => signal(this.brnHoverCardTriggerFor()));
	private readonly _brnHoverCardTriggerForState = computed(() => this.mutableBrnHoverCardTriggerFor()());

	constructor() {
		effect(() => {
			const value = this._brnHoverCardTriggerForState();
			untracked(() => {
				if (value) {
					this._contentService.setContent(value, this._vcr);
				}
			});
		});
	}

	public ngOnInit() {
		this._contentService.setConfig({ attachTo: this._el, align: this.align(), sideOffset: this.sideOffset() });
		this.showing$.subscribe((isHovered) => {
			if (isHovered) {
				this._contentService.show();
			} else {
				this._contentService.hide();
			}
		});
	}

	public ngOnDestroy() {
		this._destroy$.next();
		this._destroy$.complete();
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/hover-card/src/lib/brn-hover-card.component.ts
```typescript
import { type AfterContentInit, Component, contentChild } from '@angular/core';
import {
	BrnHoverCardContentDirective,
	BrnHoverCardContentService,
	BrnHoverCardTriggerDirective,
} from './brn-hover-card-content.service';

@Component({
	selector: 'brn-hover-card',
	standalone: true,
	providers: [BrnHoverCardContentService],
	template: `
		<ng-content />
	`,
})
export class BrnHoverCardComponent implements AfterContentInit {
	private readonly _trigger = contentChild(BrnHoverCardTriggerDirective);
	private readonly _content = contentChild(BrnHoverCardContentDirective);

	public ngAfterContentInit() {
		if (!this._trigger() || !this._content()) return;
		this._trigger()?.mutableBrnHoverCardTriggerFor().set(this._content());
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/hover-card/src/lib/createHoverObservable.ts
```typescript
import type { NgZone } from '@angular/core';
import { brnZoneOptimized } from '@spartan-ng/brain/core';
import { Observable, Subject, fromEvent, merge } from 'rxjs';
import { distinctUntilChanged, filter, map, takeUntil } from 'rxjs/operators';

function movedOut({ currentTarget, relatedTarget }: MouseEvent): boolean {
	return !isElement(relatedTarget) || !isElement(currentTarget) || !currentTarget.contains(relatedTarget);
}

export function isElement(node?: Element | EventTarget | Node | null): node is Element {
	return !!node && 'nodeType' in node && node.nodeType === Node.ELEMENT_NODE;
}

export const createHoverObservable = (
	nativeElement: HTMLElement,
	zone: NgZone,
	destroyed$: Subject<void>,
): Observable<boolean> => {
	return merge(
		fromEvent(nativeElement, 'mouseenter').pipe(map(() => true)),
		fromEvent(nativeElement, 'mouseleave').pipe(map(() => false)),
		// Hello, Safari
		fromEvent<MouseEvent>(nativeElement, 'mouseout').pipe(
			filter(movedOut),
			map(() => false),
		),
		/**
		 * NOTE: onmouseout events don't trigger when objects move under mouse in Safari
		 * https://bugs.webkit.org/show_bug.cgi?id=4117
		 */
		fromEvent(nativeElement, 'transitionend').pipe(map(() => nativeElement.matches(':hover'))),
	).pipe(distinctUntilChanged(), brnZoneOptimized(zone), takeUntil(destroyed$));
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/checkbox/README.md
```
# @spartan-ng/brain/checkbox

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/checkbox`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/checkbox/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/checkbox/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { BrnCheckboxComponent } from './lib/brn-checkbox.component';

export * from './lib/brn-checkbox.component';

export const BrnCheckboxImports = [BrnCheckboxComponent] as const;

@NgModule({
	imports: [...BrnCheckboxImports],
	exports: [...BrnCheckboxImports],
})
export class BrnCheckboxModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/checkbox/src/lib/brn-checkbox-ng-model.spec.ts
```typescript
import { render, screen } from '@testing-library/angular';
import userEvent from '@testing-library/user-event';

import { Component, input, model } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { BrnCheckboxComponent } from './brn-checkbox.component';

@Component({
	selector: 'brn-checkbox-ng-model',
	standalone: true,
	template: `
		<label>
			Airplane mode is: {{ airplaneMode() ? 'on' : 'off' }}
			<brn-checkbox [disabled]="disabled()" [(ngModel)]="airplaneMode"></brn-checkbox>
		</label>
	`,
	imports: [BrnCheckboxComponent, FormsModule],
})
export class BrnCheckboxNgModelSpecComponent {
	public readonly disabled = input(false);

	public readonly airplaneMode = model(false);
}

describe('BrnCheckboxComponentNgModelIntegration', () => {
	const setup = async (airplaneMode = false, disabled = false) => {
		const container = await render(BrnCheckboxNgModelSpecComponent, {
			componentInputs: {
				disabled,
				airplaneMode,
			},
		});
		const labelMatch = airplaneMode ? /airplane mode is: on/i : /airplane mode is: off/i;
		return {
			user: userEvent.setup(),
			container,
			checkboxElement: screen.getByLabelText(labelMatch),
			labelElement: screen.getByText(labelMatch),
		};
	};

	it('click should toggle value correctly', async () => {
		const { labelElement, user, container } = await setup();
		expect(labelElement).toBeInTheDocument();
		await user.click(labelElement);
		await screen.findByDisplayValue('on');
		expect(container.fixture.componentInstance.airplaneMode()).toBe(true);
	});

	it('should set input as default correctly and click should toggle then', async () => {
		const { labelElement, user, container } = await setup(true);

		await user.click(labelElement);
		await screen.findByDisplayValue('off');
		expect(container.fixture.componentInstance.airplaneMode()).toBe(false);

		await user.click(labelElement);
		await screen.findByDisplayValue('on');
		expect(container.fixture.componentInstance.airplaneMode()).toBe(true);
	});

	it('should set input as default correctly and enter should toggle then', async () => {
		const { user, container } = await setup(true);

		await user.keyboard('[Tab][Enter]');
		expect(container.fixture.componentInstance.airplaneMode()).toBe(false);

		await user.keyboard('[Enter]');
		expect(container.fixture.componentInstance.airplaneMode()).toBe(true);
	});

	it('should do nothing when disabled', async () => {
		const { labelElement, user, container } = await setup(false, true);

		await user.click(labelElement);
		await screen.findByDisplayValue('off');
		expect(container.fixture.componentInstance.airplaneMode()).toBe(false);

		await user.click(labelElement);
		await screen.findByDisplayValue('off');
		expect(container.fixture.componentInstance.airplaneMode()).toBe(false);
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/checkbox/src/lib/brn-checkbox.component.spec.ts
```typescript
import { render, screen } from '@testing-library/angular';
import userEvent from '@testing-library/user-event';
import { axe } from 'jest-axe';
import { BrnCheckboxComponent } from './brn-checkbox.component';

describe('BrnCheckboxComponent', () => {
	const setup = async () => {
		const container = await render(
			`
     <brn-checkbox id='checkboxId' name='checkboxName' data-testid='checkbox' aria-label='checkbox'>
      </brn-checkbox>
    `,
			{
				imports: [BrnCheckboxComponent],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			checkboxElement: screen.getByLabelText('checkbox'),
		};
	};

	const setupInsideLabel = async () => {
		const container = await render(
			`
     <label data-testid='label'>
     Checkbox Inside Label
     <brn-checkbox id='checkboxId' data-testid='checkbox' name='checkboxName'>
      </brn-checkbox>
      </label>
    `,
			{
				imports: [BrnCheckboxComponent],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			checkboxElement: screen.getByLabelText(/checkbox inside label/i),
			labelElement: screen.getByText(/checkbox inside label/i),
		};
	};
	const setupInsideLabelDisabled = async () => {
		const container = await render(
			`
     <label data-testid='label'>
     Checkbox Inside Label
     <brn-checkbox disabled id='checkboxId' data-testid='checkbox' name='checkboxName'>
      </brn-checkbox>
      </label>
    `,
			{
				imports: [BrnCheckboxComponent],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			checkboxElement: screen.getByLabelText(/checkbox inside label/i),
			labelElement: screen.getByText(/checkbox inside label/i),
		};
	};

	const setupOutsideLabelWithAriaLabelledBy = async () => {
		const container = await render(
			`
     <!-- need for because arialabelledby only provides accessible name -->
     <label id='labelId' for='checkboxId' data-testid='label'>
     Checkbox Outside Label with ariaLabelledBy
     </label>
     <brn-checkbox id='checkboxId' name='checkboxName' data-testid='checkbox' aria-labelledby='labelId'>
      </brn-checkbox>
    `,
			{
				imports: [BrnCheckboxComponent],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			checkboxElement: screen.getByLabelText(/checkbox outside label with arialabelledby/i),
			labelElement: screen.getByText(/checkbox outside label with arialabelledby/i),
		};
	};

	const setupOutsideLabelWithForAndId = async () => {
		const container = await render(
			`
     <label for='checkboxId' data-testid='label'>
     Checkbox Outside Label with id
     </label>
     <brn-checkbox id='checkboxId' name='checkboxName' data-testid='checkbox'>
      </brn-checkbox>
    `,
			{
				imports: [BrnCheckboxComponent],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			checkboxElement: screen.getByLabelText(/checkbox outside label with id/i),
			labelElement: screen.getByText(/checkbox outside label with id/i),
		};
	};
	const setupOutsideLabelWithForAndIdDisabled = async () => {
		const container = await render(
			`
     <label for='checkboxId' data-testid='label'>
     Checkbox Outside Label with id
     </label>
     <brn-checkbox disabled id='checkboxId' name='checkboxName' data-testid='checkbox'>
      </brn-checkbox>
    `,
			{
				imports: [BrnCheckboxComponent],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			checkboxElement: screen.getByLabelText(/checkbox outside label with id/i),
			labelElement: screen.getByText(/checkbox outside label with id/i),
		};
	};

	type Options = Partial<{ focus: boolean; focusVisible: boolean; disabled: boolean }>;

	const validateAttributes = async (
		inputElement: HTMLElement,
		checkboxElement: HTMLElement,
		shouldBeChecked: boolean,
		opts?: Options,
	) => {
		expect(inputElement).toBeInTheDocument();
		expect(inputElement).toHaveAttribute('role', 'checkbox');
		expect(inputElement).toHaveAttribute('id', 'checkboxId');
		expect(inputElement).toHaveAttribute('name', 'checkboxName');
		expect(await axe(inputElement)).toHaveNoViolations();

		expect(checkboxElement).toHaveAttribute('id', 'checkboxId-checkbox');
		expect(checkboxElement).toHaveAttribute('name', 'checkboxName-checkbox');
		expect(checkboxElement).toHaveAttribute('data-state', shouldBeChecked ? 'checked' : 'unchecked');
		expect(checkboxElement).toHaveAttribute('data-disabled', `${!!opts?.disabled}`);
		expect(checkboxElement).toHaveAttribute('data-focus', `${!!opts?.focus}`);
		expect(checkboxElement).toHaveAttribute('data-focus-visible', `${!!opts?.focusVisible}`);
		expect(await axe(checkboxElement)).toHaveNoViolations();
	};
	const validateCheckboxOn = async (opts?: Options) => {
		const inputElement = await screen.findByDisplayValue('on');
		const checkboxElement = await screen.findByTestId('checkbox');

		await validateAttributes(inputElement, checkboxElement, true, opts);
	};
	const validateCheckboxOff = async (opts?: Options) => {
		const inputElement = await screen.findByDisplayValue('off');
		const checkboxElement = await screen.findByTestId('checkbox');

		await validateAttributes(inputElement, checkboxElement, false, opts);
	};

	describe('with aria-label', () => {
		it('unchecked by default', async () => {
			await setup();
			await validateCheckboxOff();
		});
		it('mouse click on element toggles', async () => {
			const { user, checkboxElement } = await setup();
			await validateCheckboxOff();
			await user.click(checkboxElement);
			await validateCheckboxOn({ focus: true });
			await user.click(checkboxElement);
			await validateCheckboxOff({ focus: true });
		});
		it('focus with tab and enter toggles', async () => {
			const { user } = await setup();
			const options = { focus: true, focusVisible: true };
			await validateCheckboxOff();
			await user.keyboard('[Tab][Enter]');
			await validateCheckboxOn(options);
			await user.keyboard('[Enter]');
			await validateCheckboxOff(options);
			await user.keyboard('[Enter]');
			await validateCheckboxOn(options);
		});
		it('focus with tab and space toggles', async () => {
			const { user } = await setup();
			const options = { focus: true, focusVisible: true };
			await validateCheckboxOff();
			await user.keyboard('[Tab][Space]');
			await validateCheckboxOn(options);
			await user.keyboard('[Space]');
			await validateCheckboxOff(options);
			await user.keyboard('[Space]');
			await validateCheckboxOn(options);
		});
	});

	describe('inside <label>', () => {
		it('unchecked by default', async () => {
			await setupInsideLabel();
			await validateCheckboxOff();
		});
		it('mouse click on element toggles', async () => {
			const { user, labelElement } = await setupInsideLabel();
			await validateCheckboxOff();
			await user.click(labelElement);
			await validateCheckboxOn({ focus: true });
			await user.click(labelElement);
			await validateCheckboxOff({ focus: true });
		});
		it('focus with tab and enter toggles', async () => {
			const { user } = await setupInsideLabel();
			const options = { focus: true, focusVisible: true };
			await validateCheckboxOff();
			await user.keyboard('[Tab][Enter]');
			await validateCheckboxOn(options);
			await user.keyboard('[Enter]');
			await validateCheckboxOff(options);
			await user.keyboard('[Enter]');
			await validateCheckboxOn(options);
		});
		it('focus with tab and space toggles', async () => {
			const { user } = await setupInsideLabel();
			const options = { focus: true, focusVisible: true };
			await validateCheckboxOff();
			await user.keyboard('[Tab][Space]');
			await validateCheckboxOn(options);
			await user.keyboard('[Space]');
			await validateCheckboxOff(options);
			await user.keyboard('[Space]');
			await validateCheckboxOn(options);
		});
		it('disabled', async () => {
			const { user } = await setupInsideLabelDisabled();
			// await validateCheckboxOff({ focus: false, focusVisible: false, disabled: true });
			const options = { focus: false, focusVisible: false, disabled: true };
			await user.keyboard('[Tab][Space]');
			await validateCheckboxOff(options);
			await user.keyboard('[Space]');
			await validateCheckboxOff(options);
			await user.keyboard('[Space]');
			await validateCheckboxOff(options);
			const label = await screen.findByTestId('label');
			expect(label).toHaveAttribute('data-disabled', 'true');
		});
	});

	describe('outside <label> with aria-labelledby', () => {
		it('unchecked by default', async () => {
			await setupOutsideLabelWithAriaLabelledBy();
			await validateCheckboxOff();
		});
		it('mouse click on element toggles', async () => {
			const { user, labelElement } = await setupOutsideLabelWithAriaLabelledBy();
			await validateCheckboxOff();
			await user.click(labelElement);
			await validateCheckboxOn({ focus: true });
			await user.click(labelElement);
			await validateCheckboxOff({ focus: true });
		});
		it('focus with tab and enter toggles', async () => {
			const { user } = await setupOutsideLabelWithAriaLabelledBy();
			const options = { focus: true, focusVisible: true };
			await validateCheckboxOff();
			await user.keyboard('[Tab][Enter]');
			await validateCheckboxOn(options);
			await user.keyboard('[Enter]');
			await validateCheckboxOff(options);
			await user.keyboard('[Enter]');
			await validateCheckboxOn(options);
		});
		it('focus with tab and space toggles', async () => {
			const { user } = await setupOutsideLabelWithAriaLabelledBy();
			const options = { focus: true, focusVisible: true };
			await validateCheckboxOff();
			await user.keyboard('[Tab][Space]');
			await validateCheckboxOn(options);
			await user.keyboard('[Space]');
			await validateCheckboxOff(options);
			await user.keyboard('[Space]');
			await validateCheckboxOn(options);
		});
	});

	describe('outside <label> with for and id', () => {
		it('unchecked by default', async () => {
			await setupOutsideLabelWithForAndId();
			await validateCheckboxOff();
		});
		it('mouse click on element toggles', async () => {
			const { user, labelElement } = await setupOutsideLabelWithForAndId();
			await validateCheckboxOff();
			await user.click(labelElement);
			await validateCheckboxOn({ focus: true });
			await user.click(labelElement);
			await validateCheckboxOff({ focus: true });
		});
		it('focus with tab and enter toggles', async () => {
			const { user } = await setupOutsideLabelWithForAndId();
			const options = { focus: true, focusVisible: true };
			await validateCheckboxOff();
			await user.keyboard('[Tab][Enter]');
			await validateCheckboxOn(options);
			await user.keyboard('[Enter]');
			await validateCheckboxOff(options);
			await user.keyboard('[Enter]');
			await validateCheckboxOn(options);
		});
		it('focus with tab and space toggles', async () => {
			const { user } = await setupOutsideLabelWithForAndId();
			const options = { focus: true, focusVisible: true };
			await validateCheckboxOff();
			await user.keyboard('[Tab][Space]');
			await validateCheckboxOn(options);
			await user.keyboard('[Space]');
			await validateCheckboxOff(options);
			await user.keyboard('[Space]');
			await validateCheckboxOn(options);
			const label = await screen.findByTestId('label');
			expect(label).toHaveAttribute('data-disabled', 'false');
		});
		it('sets data-disabled to the label toggles do not change anything', async () => {
			const { user } = await setupOutsideLabelWithForAndIdDisabled();
			const options = { focus: false, focusVisible: false, disabled: true };
			await validateCheckboxOff(options);
			await user.keyboard('[Tab][Space]');
			await validateCheckboxOff(options);
			await user.keyboard('[Space]');
			await validateCheckboxOff(options);
			await user.keyboard('[Space]');
			await validateCheckboxOff(options);
			const label = await screen.findByTestId('label');
			expect(label).toHaveAttribute('data-disabled', 'true');
		});
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/checkbox/src/lib/brn-checkbox.component.ts
```typescript
import { FocusMonitor } from '@angular/cdk/a11y';
import { NgStyle, isPlatformBrowser } from '@angular/common';
import {
	type AfterContentInit,
	ChangeDetectionStrategy,
	Component,
	ElementRef,
	HostListener,
	type OnDestroy,
	PLATFORM_ID,
	Renderer2,
	ViewEncapsulation,
	booleanAttribute,
	computed,
	effect,
	forwardRef,
	inject,
	input,
	model,
	output,
	signal,
	viewChild,
} from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { ChangeFn, TouchFn } from '@spartan-ng/brain/forms';

export const BRN_CHECKBOX_VALUE_ACCESSOR = {
	provide: NG_VALUE_ACCESSOR,
	useExisting: forwardRef(() => BrnCheckboxComponent),
	multi: true,
};

export function indeterminateBooleanAttribute(value: unknown): boolean | 'indeterminate' {
	if (value === 'indeterminate') return 'indeterminate';
	return booleanAttribute(value);
}

const CONTAINER_POST_FIX = '-checkbox';

@Component({
	selector: 'brn-checkbox',
	imports: [NgStyle],
	template: `
		<input
			#checkBox
			tabindex="-1"
			type="checkbox"
			role="checkbox"
			[ngStyle]="{
				position: 'absolute',
				width: '1px',
				height: '1px',
				padding: '0',
				margin: '-1px',
				overflow: 'hidden',
				clip: 'rect(0, 0, 0, 0)',
				whiteSpace: 'nowrap',
				borderWidth: '0',
			}"
			[id]="id() ?? ''"
			[name]="name() ?? ''"
			[value]="_value()"
			[checked]="isChecked()"
			[required]="required()"
			[attr.aria-label]="ariaLabel()"
			[attr.aria-labelledby]="ariaLabelledby()"
			[attr.aria-describedby]="ariaDescribedby()"
			[attr.aria-required]="required() || null"
			[attr.aria-checked]="_ariaChecked()"
		/>
		<ng-content />
	`,
	host: {
		'[attr.tabindex]': 'state().disabled() ? "-1" : "0"',
		'[attr.data-state]': '_dataState()',
		'[attr.data-focus-visible]': 'focusVisible()',
		'[attr.data-focus]': 'focused()',
		'[attr.data-disabled]': 'state().disabled()',
		'[attr.aria-labelledby]': 'null',
		'[attr.aria-label]': 'null',
		'[attr.aria-describedby]': 'null',
		'[attr.id]': 'hostId()',
		'[attr.name]': 'hostName()',
	},
	providers: [BRN_CHECKBOX_VALUE_ACCESSOR],
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class BrnCheckboxComponent implements AfterContentInit, OnDestroy {
	private readonly _renderer = inject(Renderer2);
	private readonly _elementRef = inject(ElementRef);
	private readonly _focusMonitor = inject(FocusMonitor);
	private readonly _isBrowser = isPlatformBrowser(inject(PLATFORM_ID));

	private readonly _focusVisible = signal(false);
	public readonly focusVisible = this._focusVisible.asReadonly();
	private readonly _focused = signal(false);
	public readonly focused = this._focused.asReadonly();

	public readonly checked = model<BrnCheckboxValue>(false);
	public readonly isChecked = this.checked.asReadonly();

	protected readonly _dataState = computed(() => {
		const checked = this.checked();
		if (checked === 'indeterminate') return 'indeterminate';
		return checked ? 'checked' : 'unchecked';
	});
	protected readonly _ariaChecked = computed(() => {
		const checked = this.checked();
		if (checked === 'indeterminate') return 'mixed';
		return checked ? 'true' : 'false';
	});
	protected readonly _value = computed(() => {
		const checked = this.checked();
		if (checked === 'indeterminate') return '';
		return checked ? 'on' : 'off';
	});

	/** Used to set the id on the underlying input element. */
	public readonly id = input<string | null>(null);
	protected readonly hostId = computed(() => (this.id() ? this.id() + CONTAINER_POST_FIX : null));

	/** Used to set the name attribute on the underlying input element. */
	public readonly name = input<string | null>(null);
	protected readonly hostName = computed(() => (this.name() ? this.name() + CONTAINER_POST_FIX : null));

	/** Used to set the aria-label attribute on the underlying input element. */
	public readonly ariaLabel = input<string | null>(null, { alias: 'aria-label' });

	/** Used to set the aria-labelledby attribute on the underlying input element. */
	public readonly ariaLabelledby = input<string | null>(null, { alias: 'aria-labelledby' });

	public readonly ariaDescribedby = input<string | null>(null, { alias: 'aria-describedby' });

	public readonly required = input(false, { transform: booleanAttribute });

	public readonly disabled = input(false, { transform: booleanAttribute });

	protected readonly state = computed(() => ({
		disabled: signal(this.disabled()),
	}));

	// eslint-disable-next-line @typescript-eslint/no-empty-function
	protected _onChange: ChangeFn<BrnCheckboxValue> = () => {};
	// eslint-disable-next-line @typescript-eslint/no-empty-function
	private _onTouched: TouchFn = () => {};

	public readonly checkbox = viewChild.required<ElementRef<HTMLInputElement>>('checkBox');

	public readonly changed = output<BrnCheckboxValue>();

	constructor() {
		effect(() => {
			const parent = this._renderer.parentNode(this._elementRef.nativeElement);
			if (!parent) return;
			// check if parent is a label and assume it is for this checkbox
			if (parent?.tagName === 'LABEL') {
				this._renderer.setAttribute(parent, 'data-disabled', this.state().disabled() ? 'true' : 'false');
				return;
			}
			if (!this._isBrowser) return;

			const label = parent?.querySelector(`label[for="${this.id()}"]`);
			if (!label) return;
			this._renderer.setAttribute(label, 'data-disabled', this.state().disabled() ? 'true' : 'false');
		});
	}

	@HostListener('click', ['$event'])
	@HostListener('keyup.space', ['$event'])
	@HostListener('keyup.enter', ['$event'])
	toggle(event: Event) {
		if (this.state().disabled()) return;
		event.preventDefault();
		const previousChecked = this.checked();
		this.checked.set(previousChecked === 'indeterminate' ? true : !previousChecked);
		this._onChange(!previousChecked);
		this.changed.emit(!previousChecked);
	}

	ngAfterContentInit() {
		this._focusMonitor.monitor(this._elementRef, true).subscribe((focusOrigin) => {
			if (focusOrigin) this._focused.set(true);
			if (focusOrigin === 'keyboard' || focusOrigin === 'program') {
				this._focusVisible.set(true);
			}
			if (!focusOrigin) {
				// When a focused element becomes disabled, the browser *immediately* fires a blur event.
				// Angular does not expect events to be raised during change detection, so any state
				// change (such as a form control's ng-touched) will cause a changed-after-checked error.
				// See https://github.com/angular/angular/issues/17793. To work around this, we defer
				// telling the form control it has been touched until the next tick.
				Promise.resolve().then(() => {
					this._focusVisible.set(false);
					this._focused.set(false);
					this._onTouched();
				});
			}
		});

		this.checkbox().nativeElement.indeterminate = this.checked() === 'indeterminate';
		if (this.checkbox().nativeElement.indeterminate) {
			this.checkbox().nativeElement.value = 'indeterminate';
		} else {
			this.checkbox().nativeElement.value = this.checked() ? 'on' : 'off';
		}
		this.checkbox().nativeElement.dispatchEvent(new Event('change'));
	}

	ngOnDestroy() {
		this._focusMonitor.stopMonitoring(this._elementRef);
	}

	writeValue(value: BrnCheckboxValue): void {
		if (value === 'indeterminate') {
			this.checked.set('indeterminate');
		} else {
			this.checked.set(!!value);
		}
	}

	registerOnChange(fn: ChangeFn<BrnCheckboxValue>): void {
		this._onChange = fn;
	}

	registerOnTouched(fn: TouchFn): void {
		this._onTouched = fn;
	}

	/** Implemented as a part of ControlValueAccessor. */
	setDisabledState(isDisabled: boolean): void {
		this.state().disabled.set(isDisabled);
	}

	/**
	 * If the space key is pressed, prevent the default action to stop the page from scrolling.
	 */
	@HostListener('keydown.space', ['$event'])
	protected preventScrolling(event: KeyboardEvent): void {
		event.preventDefault();
	}
}

type BrnCheckboxValue = boolean | 'indeterminate';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/label/README.md
```
# @spartan-ng/brain/label

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/label`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/label/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/label/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { BrnLabelDirective } from './lib/brn-label.directive';

export * from './lib/brn-label.directive';

@NgModule({
	imports: [BrnLabelDirective],
	exports: [BrnLabelDirective],
})
export class BrnLabelModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/label/src/lib/brn-label.directive.ts
```typescript
import { isPlatformBrowser } from '@angular/common';
import { Directive, ElementRef, type OnInit, PLATFORM_ID, inject, input, signal } from '@angular/core';
import { NgControl } from '@angular/forms';

let nextId = 0;

@Directive({
	selector: '[brnLabel]',
	standalone: true,
	host: {
		'[id]': 'id()',
		'[class.ng-invalid]': 'this._ngControl?.invalid || null',
		'[class.ng-dirty]': 'this._ngControl?.dirty || null',
		'[class.ng-valid]': 'this._ngControl?.valid || null',
		'[class.ng-touched]': 'this._ngControl?.touched || null',
	},
})
export class BrnLabelDirective implements OnInit {
	protected readonly _ngControl = inject(NgControl, { optional: true });

	public readonly id = input<string>(`brn-label-${nextId++}`);

	private readonly _isBrowser = isPlatformBrowser(inject(PLATFORM_ID));
	private readonly _element = inject(ElementRef).nativeElement;
	private _changes?: MutationObserver;
	private readonly _dataDisabled = signal<boolean | 'auto'>('auto');
	public readonly dataDisabled = this._dataDisabled.asReadonly();

	ngOnInit(): void {
		if (!this._isBrowser) return;
		this._changes = new MutationObserver((mutations: MutationRecord[]) => {
			mutations.forEach((mutation: MutationRecord) => {
				if (mutation.attributeName !== 'data-disabled') return;
				// eslint-disable-next-line
				const state = (mutation.target as any).attributes.getNamedItem(mutation.attributeName)?.value === 'true';
				this._dataDisabled.set(state ?? 'auto');
			});
		});
		this._changes?.observe(this._element, {
			attributes: true,
			childList: true,
			characterData: true,
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/slider/README.md
```
# @spartan-ng/brain/slider

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/slider`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/slider/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/slider/src/index.ts
```typescript
import { BrnSliderRangeDirective } from './lib/brn-slider-range.directive';
import { BrnSliderThumbDirective } from './lib/brn-slider-thumb.directive';
import { BrnSliderTickDirective } from './lib/brn-slider-tick.directive';
import { BrnSliderTrackDirective } from './lib/brn-slider-track.directive';
import { BrnSliderDirective } from './lib/brn-slider.directive';

export * from './lib/brn-slider-range.directive';
export * from './lib/brn-slider-thumb.directive';
export * from './lib/brn-slider-tick.directive';
export * from './lib/brn-slider-track.directive';
export * from './lib/brn-slider.directive';
export * from './lib/brn-slider.token';

export const BrnSliderImports = [
	BrnSliderDirective,
	BrnSliderTrackDirective,
	BrnSliderThumbDirective,
	BrnSliderRangeDirective,
	BrnSliderTickDirective,
] as const;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/slider/src/lib/brn-slider-range.directive.ts
```typescript
import { Directive } from '@angular/core';
import { injectBrnSlider } from './brn-slider.token';

@Directive({
	selector: '[brnSliderRange]',
	host: {
		'[attr.data-disabled]': 'slider.disabled()',
		'[style.width.%]': 'slider.percentage()',
	},
})
export class BrnSliderRangeDirective {
	/** Access the slider */
	protected readonly slider = injectBrnSlider();
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/slider/src/lib/brn-slider-thumb.directive.ts
```typescript
import { DOCUMENT, isPlatformServer } from '@angular/common';
import { computed, Directive, ElementRef, HostListener, inject, PLATFORM_ID } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { fromEvent } from 'rxjs';
import { switchMap, takeUntil } from 'rxjs/operators';
import { injectBrnSlider } from './brn-slider.token';

@Directive({
	selector: '[brnSliderThumb]',
	host: {
		role: 'slider',
		'[attr.aria-valuenow]': 'slider.value()',
		'[attr.aria-valuemin]': 'slider.min()',
		'[attr.aria-valuemax]': 'slider.max()',
		'[attr.tabindex]': 'slider.disabled() ? -1 : 0',
		'[attr.data-disabled]': 'slider.disabled()',
		'[style.inset-inline-start]': 'thumbOffset()',
	},
})
export class BrnSliderThumbDirective {
	protected readonly slider = injectBrnSlider();
	private readonly _document = inject<Document>(DOCUMENT);
	private readonly _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);
	private readonly _platform = inject(PLATFORM_ID);

	/**
	 * Offsets the thumb centre point while sliding to ensure it remains
	 * within the bounds of the slider when reaching the edges.
	 * Based on https://github.com/radix-ui/primitives/blob/main/packages/react/slider/src/slider.tsx
	 */
	protected readonly thumbOffset = computed(() => {
		// we can't compute the offset on the server
		if (isPlatformServer(this._platform)) {
			return this.slider.percentage() + '%';
		}

		const halfWidth = this._elementRef.nativeElement.offsetWidth / 2;
		const offset = this.linearScale([0, 50], [0, halfWidth]);
		const thumbInBoundsOffset = halfWidth - offset(this.slider.percentage());
		const percent = this.slider.percentage();

		return `calc(${percent}% + ${thumbInBoundsOffset}px)`;
	});

	constructor() {
		const mousedown = fromEvent<MouseEvent>(this._elementRef.nativeElement, 'pointerdown');
		const mouseup = fromEvent<MouseEvent>(this._document, 'pointerup');
		const mousemove = fromEvent<MouseEvent>(this._document, 'pointermove');

		// Listen for mousedown events on the slider thumb
		mousedown
			.pipe(
				switchMap(() => mousemove.pipe(takeUntil(mouseup))),
				takeUntilDestroyed(),
			)
			.subscribe(this.dragThumb.bind(this));
	}

	/** @internal */
	private dragThumb(event: MouseEvent): void {
		if (this.slider.disabled()) {
			return;
		}

		const rect = this.slider.track()?.elementRef.nativeElement.getBoundingClientRect();

		if (!rect) {
			return;
		}

		const percentage = (event.clientX - rect.left) / rect.width;

		this.slider.setValue(
			this.slider.min() + (this.slider.max() - this.slider.min()) * Math.max(0, Math.min(1, percentage)),
		);
	}

	/**
	 * Handle keyboard events.
	 * @param event
	 */
	@HostListener('keydown', ['$event'])
	protected handleKeydown(event: KeyboardEvent): void {
		const dir = getComputedStyle(this._elementRef.nativeElement).direction;
		let multiplier = event.shiftKey ? 10 : 1;
		const value = this.slider.value();

		// if the slider is RTL, flip the multiplier
		if (dir === 'rtl') {
			multiplier = event.shiftKey ? -10 : -1;
		}

		switch (event.key) {
			case 'ArrowLeft':
				this.slider.setValue(Math.max(value - this.slider.step() * multiplier, this.slider.min()));
				event.preventDefault();
				break;
			case 'ArrowRight':
				this.slider.setValue(Math.min(value + this.slider.step() * multiplier, this.slider.max()));
				event.preventDefault();
				break;
			case 'Home':
				this.slider.setValue(this.slider.min());
				event.preventDefault();
				break;
			case 'End':
				this.slider.setValue(this.slider.max());
				event.preventDefault();
				break;
		}
	}

	private linearScale(input: readonly [number, number], output: readonly [number, number]): (value: number) => number {
		return (value: number) => {
			if (input[0] === input[1] || output[0] === output[1]) return output[0];
			const ratio = (output[1] - output[0]) / (input[1] - input[0]);
			return output[0] + ratio * (value - input[0]);
		};
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/slider/src/lib/brn-slider-tick.directive.ts
```typescript
import { Directive, effect, EmbeddedViewRef, inject, OnDestroy, TemplateRef, ViewContainerRef } from '@angular/core';
import { injectBrnSlider } from './brn-slider.token';

@Directive({
	selector: '[brnSliderTick]',
})
export class BrnSliderTickDirective implements OnDestroy {
	private readonly _slider = injectBrnSlider();
	private readonly _templateRef = inject<TemplateRef<BrnSliderTickContext>>(TemplateRef);
	private readonly _viewContainer = inject(ViewContainerRef);
	private _ticks: EmbeddedViewRef<BrnSliderTickContext>[] = [];

	constructor() {
		effect(() => {
			const ticks = this._slider.ticks();

			// remove any existing ticks
			this._ticks.forEach((tick) => this._viewContainer.remove(this._viewContainer.indexOf(tick)));

			// create new ticks
			this._ticks = [];

			ticks.forEach((tick, index) => {
				const view = this._viewContainer.createEmbeddedView(this._templateRef, {
					$implicit: tick,
					index,
					position: (index / (ticks.length - 1)) * 100,
				});
				this._ticks.push(view);
			});
		});
	}

	ngOnDestroy(): void {
		this._ticks.forEach((tick) => this._viewContainer.remove(this._viewContainer.indexOf(tick)));
	}
}

interface BrnSliderTickContext {
	$implicit: number;
	index: number;
	position: number;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/slider/src/lib/brn-slider-track.directive.ts
```typescript
import { Directive, ElementRef, HostListener, inject } from '@angular/core';
import { provideBrnSliderTrack } from './brn-slider-track.token';
import { injectBrnSlider } from './brn-slider.token';

@Directive({
	selector: '[brnSliderTrack]',
	providers: [provideBrnSliderTrack(BrnSliderTrackDirective)],
	host: {
		'[attr.data-disabled]': 'slider.disabled()',
	},
})
export class BrnSliderTrackDirective {
	/** Access the slider */
	protected readonly slider = injectBrnSlider();

	/** @internal Access the slider track */
	public readonly elementRef = inject<ElementRef<HTMLElement>>(ElementRef);

	constructor() {
		this.slider.track.set(this);
	}

	@HostListener('mousedown', ['$event'])
	protected moveThumbToPoint(event: MouseEvent): void {
		if (this.slider.disabled()) {
			return;
		}

		const position = event.clientX;
		const rect = this.elementRef.nativeElement.getBoundingClientRect();
		const percentage = (position - rect.left) / rect.width;

		// update the value based on the position
		this.slider.setValue(this.slider.min() + (this.slider.max() - this.slider.min()) * percentage);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/slider/src/lib/brn-slider-track.token.ts
```typescript
import { ExistingProvider, inject, InjectionToken, Type } from '@angular/core';
import type { BrnSliderTrackDirective } from './brn-slider-track.directive';

export const BrnSliderTrackToken = new InjectionToken<BrnSliderTrackDirective>('BrnSliderTrackToken');

export function provideBrnSliderTrack(slider: Type<BrnSliderTrackDirective>): ExistingProvider {
	return { provide: BrnSliderTrackToken, useExisting: slider };
}

export function injectBrnSliderTrack(): BrnSliderTrackDirective {
	return inject(BrnSliderTrackToken);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/slider/src/lib/brn-slider.directive.ts
```typescript
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import {
	booleanAttribute,
	ChangeDetectorRef,
	computed,
	Directive,
	ElementRef,
	inject,
	input,
	linkedSignal,
	model,
	numberAttribute,
	OnInit,
	signal,
} from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';
import { ChangeFn, TouchFn } from '@spartan-ng/brain/forms';
import type { BrnSliderTrackDirective } from './brn-slider-track.directive';
import { provideBrnSlider } from './brn-slider.token';

@Directive({
	selector: '[brnSlider]',
	exportAs: 'brnSlider',
	providers: [
		provideBrnSlider(BrnSliderDirective),
		{
			provide: NG_VALUE_ACCESSOR,
			useExisting: BrnSliderDirective,
			multi: true,
		},
	],
	host: {
		'aria-orientation': 'horizontal',
		'(focusout)': '_onTouched?.()',
	},
})
export class BrnSliderDirective implements ControlValueAccessor, OnInit {
	private readonly _changeDetectorRef = inject(ChangeDetectorRef);
	private readonly _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);

	public readonly value = model<number>(0);

	public readonly min = input<number, NumberInput>(0, {
		transform: numberAttribute,
	});

	public readonly max = input<number, NumberInput>(100, {
		transform: numberAttribute,
	});

	public readonly step = input<number, NumberInput>(1, {
		transform: numberAttribute,
	});

	public readonly _disabled = input<boolean, BooleanInput>(false, {
		alias: 'disabled',
		transform: booleanAttribute,
	});

	/** Whether we should show tick marks */
	public readonly showTicks = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** @internal */
	public readonly ticks = computed(() => {
		const value = this.value();

		if (!this.showTicks()) {
			return [];
		}

		let numActive = Math.max(Math.floor((value - this.min()) / this.step()), 0);
		let numInactive = Math.max(Math.floor((this.max() - value) / this.step()), 0);

		const direction = getComputedStyle(this._elementRef.nativeElement).direction;

		direction === 'rtl' ? numInactive++ : numActive++;

		return Array(numActive).fill(true).concat(Array(numInactive).fill(false));
	});

	/** @internal */
	public readonly disabled = linkedSignal(() => this._disabled());

	/** @internal */
	public readonly percentage = computed(() => ((this.value() - this.min()) / (this.max() - this.min())) * 100);

	/** @internal Store the on change callback */
	protected _onChange?: ChangeFn<number>;

	/** @internal Store the on touched callback */
	protected _onTouched?: TouchFn;

	/** @internal Store the track */
	public readonly track = signal<BrnSliderTrackDirective | null>(null);

	ngOnInit(): void {
		// ensure the value is within the min and max range
		if (this.value() < this.min()) {
			this.value.set(this.min());
		}
		if (this.value() > this.max()) {
			this.value.set(this.max());
		}
	}

	registerOnChange(fn: (value: number) => void): void {
		this._onChange = fn;
	}

	registerOnTouched(fn: () => void): void {
		this._onTouched = fn;
	}

	setDisabledState(isDisabled: boolean): void {
		this.disabled.set(isDisabled);
	}

	writeValue(value: number): void {
		const clampedValue = clamp(value, [this.min(), this.max()]);
		this.value.set(clampedValue);

		if (value !== clampedValue) {
			this._onChange?.(clampedValue);
		}

		this._changeDetectorRef.detectChanges();
	}

	setValue(value: number): void {
		const decimalCount = getDecimalCount(this.step());
		const snapToStep = roundValue(
			Math.round((value - this.min()) / this.step()) * this.step() + this.min(),
			decimalCount,
		);

		value = clamp(snapToStep, [this.min(), this.max()]);

		this.value.set(value);
		this._onChange?.(value);
	}
}

function roundValue(value: number, decimalCount: number): number {
	const rounder = Math.pow(10, decimalCount);
	return Math.round(value * rounder) / rounder;
}

function getDecimalCount(value: number): number {
	return (String(value).split('.')[1] || '').length;
}

function clamp(value: number, [min, max]: [number, number]): number {
	return Math.min(max, Math.max(min, value));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/slider/src/lib/brn-slider.token.ts
```typescript
import { ExistingProvider, inject, InjectionToken, Type } from '@angular/core';
import type { BrnSliderDirective } from './brn-slider.directive';

const BrnSliderToken = new InjectionToken<BrnSliderDirective>('BrnSliderToken');

export function provideBrnSlider(slider: Type<BrnSliderDirective>): ExistingProvider {
	return { provide: BrnSliderToken, useExisting: slider };
}

export function injectBrnSlider(): BrnSliderDirective {
	return inject(BrnSliderToken);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/slider/src/lib/tests/brn-slider-reactive-form.spec.ts
```typescript
import { render } from '@testing-library/angular';
import userEvent from '@testing-library/user-event';
import { ReactiveFormSliderComponent } from './brn-slider-states.component';

async function setupSlider() {
	const { getByRole, getByTestId, fixture } = await render(ReactiveFormSliderComponent);

	return {
		fixture,
		thumb: getByRole('slider'),
		changeValueBtn: getByTestId('change-value-btn'),
		valueIndicatorPre: getByTestId('value-indicator-pre'),
	};
}

describe('Reactive Form Slider State', () => {
	it('should reflect the correct value indicator and the related aria attributes when selecting a value between min and max', async () => {
		const { thumb, valueIndicatorPre, fixture } = await setupSlider();

		expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 46');
		expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('46');
		expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
		expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');

		fixture.componentInstance.changeValue(25);
		fixture.detectChanges();

		expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 25');
		expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('25');
		expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
		expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');
	});

	it('Should reflect the correct value indicator and the related aria attributes when selecting a value below min', async () => {
		const { thumb, valueIndicatorPre, fixture } = await setupSlider();

		expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 46');
		expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('46');
		expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
		expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');

		fixture.componentInstance.changeValue(-25);
		fixture.detectChanges();

		expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 0');
		expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('0');
		expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
		expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');
	});

	it('Should reflect the correct value indicator and the related aria attributes when selecting a value after max', async () => {
		const { fixture, thumb, valueIndicatorPre } = await setupSlider();

		expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 46');
		expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('46');
		expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
		expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');

		//simulate slider dragging/selecting a value
		fixture.componentInstance.changeValue(225);
		fixture.detectChanges();

		expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 100');
		expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('100');
		expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
		expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');
	});

	it('Should reflect the correct value indicator and the related aria attributes when changing the slider value', async () => {
		const { thumb, fixture, changeValueBtn, valueIndicatorPre } = await setupSlider();

		expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 46');
		expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('46');
		expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
		expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');

		//simulate slider dragging/selecting a value
		fixture.componentInstance.changeValue(225);
		fixture.detectChanges();

		expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 100');
		expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('100');
		expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
		expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');

		//change slider value using a button
		await userEvent.click(changeValueBtn);

		expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 24');
		expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('24');
		expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
		expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/slider/src/lib/tests/brn-slider-states.component.ts
```typescript
import { Component, model } from '@angular/core';
import { FormControl, FormGroup, FormsModule, ReactiveFormsModule } from '@angular/forms';
import {
	BrnSliderDirective,
	BrnSliderRangeDirective,
	BrnSliderThumbDirective,
	BrnSliderTrackDirective,
} from '../../index';

@Component({
	template: `
		<div>
			<pre data-testid="value-indicator-pre">Temperature: {{ temperature() }}</pre>
		</div>
		<form ngForm>
			<div brnSlider aria-label="fallback-label" [min]="0" [(ngModel)]="temperature" name="temperature">
				<div brnSliderTrack>
					<div brnSliderRange></div>
				</div>

				<span brnSliderThumb></span>
			</div>
		</form>
		<button data-testid="change-value-btn" (click)="changeValue(24)">Change temperature value</button>
	`,
	imports: [FormsModule, BrnSliderDirective, BrnSliderThumbDirective, BrnSliderTrackDirective, BrnSliderRangeDirective],
})
export class TemplateDrivenFormSliderComponent {
	public readonly temperature = model<number>(0);

	changeValue(value: number) {
		this.temperature.set(value);
	}
}

@Component({
	template: `
		<div>
			<pre data-testid="value-indicator-pre">
				Temperature: {{ temperatureGroup.controls.temperature.getRawValue() }}
			</pre
			>
		</div>
		<form [formGroup]="temperatureGroup">
			<div brnSlider aria-label="fallback-label" [min]="0" formControlName="temperature">
				<div brnSliderTrack>
					<div brnSliderRange></div>
				</div>

				<span brnSliderThumb></span>
			</div>
		</form>
		<button data-testid="change-value-btn" (click)="changeValue(24)">Change temperature value</button>
	`,
	imports: [
		ReactiveFormsModule,
		BrnSliderDirective,
		BrnSliderThumbDirective,
		BrnSliderTrackDirective,
		BrnSliderRangeDirective,
	],
})
export class ReactiveFormSliderComponent {
	public readonly temperature = model<number>(46);

	protected readonly temperatureGroup = new FormGroup({
		temperature: new FormControl<number>(this.temperature()),
	});

	changeValue(value: number) {
		this.temperatureGroup.controls.temperature.patchValue(value);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/slider/src/lib/tests/brn-slider-template-driven-form.spec.ts
```typescript
import { render } from '@testing-library/angular';
import userEvent from '@testing-library/user-event';
import { TemplateDrivenFormSliderComponent } from './brn-slider-states.component';

async function setupSlider() {
	const { fixture, getByRole, getByTestId } = await render(TemplateDrivenFormSliderComponent);

	return {
		fixture,
		thumb: getByRole('slider'),
		changeValueBtn: getByTestId('change-value-btn'),
		valueIndicatorPre: getByTestId('value-indicator-pre'),
	};
}

async function setupSliderWithInitialValue(initialValue: number) {
	const { getByRole, getByTestId, fixture } = await render(TemplateDrivenFormSliderComponent, {
		componentInputs: { temperature: initialValue },
	});

	return {
		fixture,
		thumb: getByRole('slider'),
		changeValueBtn: getByTestId('change-value-btn'),
		valueIndicatorPre: getByTestId('value-indicator-pre'),
	};
}

describe('Template Driven Form Slider State', () => {
	describe('Default Initial Value', () => {
		it('Should reflect the correct value indicator and the related aria attributes when selecting a value between min and max', async () => {
			const { thumb, fixture, valueIndicatorPre } = await setupSlider();

			expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 0');
			expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');

			//simulate slider dragging/selecting a value
			fixture.componentInstance.changeValue(25);
			fixture.detectChanges();
			await fixture.whenStable();

			expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 25');
			expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('25');
			expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');
		});

		it('Should reflect the correct value indicator and the related aria attributes when selecting a value below min', async () => {
			const { thumb, valueIndicatorPre, fixture } = await setupSlider();

			expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 0');
			expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');

			//simulate slider dragging/selecting a value
			fixture.componentInstance.changeValue(-25);
			fixture.detectChanges();
			await fixture.whenStable();

			expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 0');
			expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');
		});

		it('Should reflect the correct value indicator and the related aria attributes when selecting a value after max', async () => {
			const { thumb, valueIndicatorPre, fixture } = await setupSlider();

			expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 0');
			expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');

			//simulate slider dragging/selecting a value
			fixture.componentInstance.changeValue(225);
			fixture.detectChanges();
			await fixture.whenStable();

			expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 100');
			expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('100');
			expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');
		});

		it('Should reflect the correct value indicator and the related aria attributes when changing the slider value', async () => {
			const { fixture, thumb, changeValueBtn, valueIndicatorPre } = await setupSlider();

			expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 0');
			expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');

			//simulate slider dragging/selecting a value
			fixture.componentInstance.changeValue(225);
			fixture.detectChanges();
			await fixture.whenStable();

			expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 100');
			expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('100');
			expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');

			//change slider value using a button
			await userEvent.click(changeValueBtn);

			fixture.detectChanges();

			expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 24');
			expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('24');
			expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');
		});
	});

	describe('With Initial Value', () => {
		it('Should reflect the correct value indicator and the related aria attributes when selecting a value between min and max', async () => {
			const { fixture, thumb, valueIndicatorPre } = await setupSliderWithInitialValue(12);

			fixture.detectChanges();

			expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 12');
			expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('12');
			expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');

			//simulate slider dragging/selecting a value
			fixture.componentInstance.changeValue(25);
			fixture.detectChanges();
			await fixture.whenStable();

			expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 25');
			expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('25');
			expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');
		});

		it('Should reflect the correct value indicator and the related aria attributes when selecting a value below min', async () => {
			const { fixture, thumb, valueIndicatorPre } = await setupSliderWithInitialValue(67);

			fixture.detectChanges();

			expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 67');
			expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('67');
			expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');

			//simulate slider dragging/selecting a value
			fixture.componentInstance.changeValue(-25);
			fixture.detectChanges();
			await fixture.whenStable();

			expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 0');
			expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');
		});

		it('Should reflect the correct value indicator and the related aria attributes when selecting a value after max', async () => {
			const { fixture, thumb, valueIndicatorPre } = await setupSliderWithInitialValue(34);

			fixture.detectChanges();

			expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 34');
			expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('34');
			expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');

			//simulate slider dragging/selecting a value
			fixture.componentInstance.changeValue(225);
			fixture.detectChanges();
			await fixture.whenStable();

			expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 100');
			expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('100');
			expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');
		});

		it('Should reflect the correct value indicator and the related aria attributes when changing the slider value', async () => {
			const { fixture, thumb, changeValueBtn, valueIndicatorPre } = await setupSliderWithInitialValue(88);

			fixture.detectChanges();

			expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 88');
			expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('88');
			expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');

			//simulate slider dragging/selecting a value
			fixture.componentInstance.changeValue(225);
			fixture.detectChanges();
			await fixture.whenStable();

			expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 100');
			expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('100');
			expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');

			//change slider value using a button
			await userEvent.click(changeValueBtn);

			fixture.detectChanges();

			expect(valueIndicatorPre.textContent?.trim()).toBe('Temperature: 24');
			expect(thumb.getAttribute('aria-valuenow')?.trim()).toBe('24');
			expect(thumb.getAttribute('aria-valuemin')?.trim()).toBe('0');
			expect(thumb.getAttribute('aria-valuemax')?.trim()).toBe('100');
		});
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/date-time-luxon/README.md
```
# @spartan-ng/brain/date-time-luxon

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/date-time-luxon`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/date-time-luxon/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/date-time-luxon/src/index.ts
```typescript
export * from './lib/date-adapter';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/date-time-luxon/src/lib/date-adapter.ts
```typescript
import { BrnDateAdapter, BrnDateUnits, BrnDuration } from '@spartan-ng/brain/date-time';
import { DateTime } from 'luxon';

export class BrnLuxonDateAdapter implements BrnDateAdapter<DateTime> {
	now() {
		return DateTime.now();
	}

	set(date: DateTime, values: BrnDateUnits) {
		return date.set(values);
	}

	add(date: DateTime, duration: BrnDuration) {
		return date.plus(duration);
	}

	subtract(date: DateTime, duration: BrnDuration) {
		return date.minus(duration);
	}

	compare(a: DateTime, b: DateTime): number {
		if (a < b) {
			return -1;
		}

		if (a > b) {
			return 1;
		}

		return 0;
	}

	isEqual(a: DateTime, b: DateTime): boolean {
		return a.equals(b);
	}

	isBefore(a: DateTime, b: DateTime): boolean {
		return a < b;
	}

	isAfter(a: DateTime, b: DateTime): boolean {
		return a > b;
	}

	isSameDay(a: DateTime, b: DateTime): boolean {
		return a.hasSame(b, 'day') && a.hasSame(b, 'month') && a.hasSame(b, 'year');
	}

	isSameMonth(a: DateTime, b: DateTime): boolean {
		return a.hasSame(b, 'month') && a.hasSame(b, 'year');
	}

	isSameYear(a: DateTime, b: DateTime): boolean {
		return a.hasSame(b, 'year');
	}

	getYear(date: DateTime): number {
		return date.year;
	}

	getMonth(date: DateTime): number {
		return date.month;
	}

	getDate(date: DateTime): number {
		return date.day;
	}

	getDay(date: DateTime): number {
		return date.weekday;
	}

	getHours(date: DateTime): number {
		return date.hour;
	}

	getMinutes(date: DateTime): number {
		return date.minute;
	}

	getSeconds(date: DateTime): number {
		return date.second;
	}

	getMilliseconds(date: DateTime): number {
		return date.millisecond;
	}

	getTime(date: DateTime<boolean>): number {
		return date.toMillis();
	}

	startOfMonth(date: DateTime) {
		return date.startOf('month');
	}

	endOfMonth(date: DateTime) {
		return date.endOf('month');
	}

	startOfDay(date: DateTime) {
		return date.startOf('day');
	}

	endOfDay(date: DateTime) {
		return date.endOf('day');
	}

	create(values: BrnDateUnits) {
		return DateTime.fromObject(values);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/toggle-group/README.md
```
# @spartan-ng/brain/toggle-group

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/toggle-group`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/toggle-group/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/toggle-group/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { BrnToggleGroupComponent } from './lib/brn-toggle-group.component';
import { BrnToggleGroupItemDirective } from './lib/brn-toggle-item.directive';

export * from './lib/brn-toggle-group.component';
export * from './lib/brn-toggle-item.directive';

@NgModule({
	imports: [BrnToggleGroupItemDirective, BrnToggleGroupComponent],
	exports: [BrnToggleGroupItemDirective, BrnToggleGroupComponent],
})
export class BrnToggleGroupModule {}

@NgModule({
	imports: [BrnToggleGroupItemDirective],
	exports: [BrnToggleGroupItemDirective],
})
export class BrnToggleGroupItemModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/toggle-group/src/lib/brn-toggle-group.component.spec.ts
```typescript
import { Component, Input } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { fireEvent, render } from '@testing-library/angular';
import { BrnToggleGroupComponent } from './brn-toggle-group.component';
import { BrnToggleGroupItemDirective } from './brn-toggle-item.directive';

@Component({
	standalone: true,
	imports: [BrnToggleGroupItemDirective, BrnToggleGroupComponent],
	template: `
		<brn-toggle-group [(value)]="value" [disabled]="disabled" [multiple]="multiple">
			<button brnToggleGroupItem value="option-1">Option 1</button>
			<button brnToggleGroupItem value="option-2">Option 2</button>
			<button brnToggleGroupItem value="option-3">Option 3</button>
		</brn-toggle-group>
	`,
})
class BrnToggleGroupDirectiveSpecComponent {
	@Input() public value?: string | string[];
	@Input() public disabled = false;
	@Input() public multiple = false;
}

@Component({
	standalone: true,
	imports: [BrnToggleGroupItemDirective, BrnToggleGroupComponent, FormsModule],
	template: `
		<brn-toggle-group [(ngModel)]="value" [multiple]="multiple">
			<button brnToggleGroupItem value="option-1">Option 1</button>
			<button brnToggleGroupItem value="option-2">Option 2</button>
			<button brnToggleGroupItem value="option-3">Option 3</button>
		</brn-toggle-group>
	`,
})
class BrnToggleGroupDirectiveFormSpecComponent {
	@Input() public value?: string | string[];
	@Input() public multiple = false;
}

describe('BrnToggleGroupDirective', () => {
	it('should allow only a single selected toggle button when multiple is false', async () => {
		const { getAllByRole } = await render(BrnToggleGroupDirectiveSpecComponent);
		const buttons = getAllByRole('button');

		expect(buttons[0]).toHaveAttribute('data-state', 'off');
		expect(buttons[1]).toHaveAttribute('data-state', 'off');
		expect(buttons[2]).toHaveAttribute('data-state', 'off');

		await fireEvent.click(buttons[0]);
		expect(buttons[0]).toHaveAttribute('data-state', 'on');
		expect(buttons[1]).toHaveAttribute('data-state', 'off');
		expect(buttons[2]).toHaveAttribute('data-state', 'off');

		await fireEvent.click(buttons[1]);
		expect(buttons[0]).toHaveAttribute('data-state', 'off');
		expect(buttons[1]).toHaveAttribute('data-state', 'on');
		expect(buttons[2]).toHaveAttribute('data-state', 'off');
	});

	it('should allow multiple selected toggle buttons when multiple is true', async () => {
		const { getAllByRole, detectChanges } = await render(BrnToggleGroupDirectiveSpecComponent, {
			inputs: {
				multiple: true,
			},
		});
		const buttons = getAllByRole('button');

		expect(buttons[0]).toHaveAttribute('data-state', 'off');
		expect(buttons[1]).toHaveAttribute('data-state', 'off');
		expect(buttons[2]).toHaveAttribute('data-state', 'off');

		await fireEvent.click(buttons[0]);
		detectChanges();
		expect(buttons[0]).toHaveAttribute('data-state', 'on');
		expect(buttons[1]).toHaveAttribute('data-state', 'off');
		expect(buttons[2]).toHaveAttribute('data-state', 'off');

		await fireEvent.click(buttons[1]);
		detectChanges();
		expect(buttons[0]).toHaveAttribute('data-state', 'on');
		expect(buttons[1]).toHaveAttribute('data-state', 'on');
		expect(buttons[2]).toHaveAttribute('data-state', 'off');
	});

	it('should disable all toggle buttons when disabled is true', async () => {
		const { getAllByRole } = await render(BrnToggleGroupDirectiveSpecComponent, {
			inputs: {
				disabled: true,
			},
		});
		const buttons = getAllByRole('button');

		expect(buttons[0]).toHaveAttribute('disabled');
		expect(buttons[1]).toHaveAttribute('disabled');
		expect(buttons[2]).toHaveAttribute('disabled');
	});

	it('should initially select the button with the provided value (multiple = false)', async () => {
		const { getAllByRole, detectChanges } = await render(BrnToggleGroupDirectiveFormSpecComponent, {
			inputs: {
				value: 'option-2',
			},
		});
		detectChanges();
		const buttons = getAllByRole('button');

		expect(buttons[0]).toHaveAttribute('data-state', 'off');
		expect(buttons[1]).toHaveAttribute('data-state', 'on');
		expect(buttons[2]).toHaveAttribute('data-state', 'off');
	});

	it('should initially select the buttons with the provided values (multiple = true)', async () => {
		const { getAllByRole, detectChanges } = await render(BrnToggleGroupDirectiveFormSpecComponent, {
			inputs: {
				value: ['option-1', 'option-3'],
				multiple: true,
			},
		});
		detectChanges();
		const buttons = getAllByRole('button');

		expect(buttons[0]).toHaveAttribute('data-state', 'on');
		expect(buttons[1]).toHaveAttribute('data-state', 'off');
		expect(buttons[2]).toHaveAttribute('data-state', 'on');
	});

	it('should initially select the button with the provided value (multiple = false) using ngModel', async () => {
		const { getAllByRole, detectChanges } = await render(BrnToggleGroupDirectiveFormSpecComponent, {
			inputs: {
				value: 'option-2',
			},
		});
		detectChanges();
		const buttons = getAllByRole('button');

		expect(buttons[0]).toHaveAttribute('data-state', 'off');
		expect(buttons[1]).toHaveAttribute('data-state', 'on');
		expect(buttons[2]).toHaveAttribute('data-state', 'off');
	});

	it('should initially select the buttons with the provided values (multiple = true) using ngModel', async () => {
		const { getAllByRole, detectChanges } = await render(BrnToggleGroupDirectiveFormSpecComponent, {
			inputs: {
				value: ['option-1', 'option-3'],
				multiple: true,
			},
		});
		detectChanges();
		const buttons = getAllByRole('button');

		expect(buttons[0]).toHaveAttribute('data-state', 'on');
		expect(buttons[1]).toHaveAttribute('data-state', 'off');
		expect(buttons[2]).toHaveAttribute('data-state', 'on');
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/toggle-group/src/lib/brn-toggle-group.component.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { Component, booleanAttribute, computed, forwardRef, input, model, output, signal } from '@angular/core';
import { type ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';
import { provideBrnToggleGroup } from './brn-toggle-group.token';
import { BrnToggleGroupItemDirective } from './brn-toggle-item.directive';

export const BRN_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR = {
	provide: NG_VALUE_ACCESSOR,
	useExisting: forwardRef(() => BrnToggleGroupComponent),
	multi: true,
};

export class BrnButtonToggleChange<T = unknown> {
	constructor(
		public source: BrnToggleGroupItemDirective<T>,
		public value: ToggleValue<T>,
	) {}
}

@Component({
	selector: 'brn-toggle-group',
	standalone: true,
	providers: [provideBrnToggleGroup(BrnToggleGroupComponent), BRN_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR],
	host: {
		role: 'group',
		class: 'brn-button-toggle-group',
		'[attr.aria-disabled]': 'state().disabled()',
		'[attr.data-disabled]': 'state().disabled()',
		'[attr.data-vertical]': 'vertical()',
		'(focusout)': 'onTouched()',
	},
	exportAs: 'brnToggleGroup',
	template: `
		<ng-content />
	`,
})
export class BrnToggleGroupComponent<T = unknown> implements ControlValueAccessor {
	/**
	 * The method to be called in order to update ngModel.
	 */
	// eslint-disable-next-line @typescript-eslint/no-empty-function
	private _onChange: (value: ToggleValue<T>) => void = () => {};

	/** onTouch function registered via registerOnTouch (ControlValueAccessor). */
	// eslint-disable-next-line @typescript-eslint/no-empty-function
	protected onTouched: () => void = () => {};

	/** Whether the button toggle group has a vertical orientation */
	public readonly vertical = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** Value of the toggle group. */
	public readonly value = model<ToggleValue<T>>(undefined);

	/** Whether no button toggles need to be selected. */
	public readonly nullable = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** Whether multiple button toggles can be selected. */
	public readonly multiple = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** Whether the button toggle group is disabled. */
	public readonly disabled = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** The internal state of the component. This can be replaced with linkedSignal in the future. */
	public readonly state = computed(() => ({
		disabled: signal(this.disabled()),
	}));

	/** Emit event when the group value changes. */
	public readonly change = output<BrnButtonToggleChange<T>>();

	writeValue(value: ToggleValue<T>): void {
		this.value.set(value);
	}

	registerOnChange(fn: (value: ToggleValue<T>) => void) {
		this._onChange = fn;
	}

	registerOnTouched(fn: () => void) {
		this.onTouched = fn;
	}

	setDisabledState(isDisabled: boolean): void {
		this.state().disabled.set(isDisabled);
	}

	/**
	 * @internal
	 * Determines whether a value can be set on the group.
	 */
	canDeselect(value: ToggleValue<T>): boolean {
		// if null values are allowed, the group can always be nullable
		if (this.nullable()) return true;

		const currentValue = this.value();

		if (this.multiple() && Array.isArray(currentValue)) {
			return !(currentValue.length === 1 && currentValue[0] === value);
		}

		return currentValue !== value;
	}

	/**
	 * @internal
	 * Selects a value.
	 */
	select(value: T, source: BrnToggleGroupItemDirective<T>): void {
		if (this.state().disabled() || this.isSelected(value)) {
			return;
		}

		const currentValue = this.value();

		// emit the valueChange event here as we should only emit based on user interaction
		if (this.multiple()) {
			this.emitSelectionChange([...((currentValue ?? []) as T[]), value], source);
		} else {
			this.emitSelectionChange(value, source);
		}

		this._onChange(this.value());
		this.change.emit(new BrnButtonToggleChange<T>(source, this.value()));
	}

	/**
	 * @internal
	 * Deselects a value.
	 */
	deselect(value: T, source: BrnToggleGroupItemDirective<T>): void {
		if (this.state().disabled() || !this.isSelected(value) || !this.canDeselect(value)) {
			return;
		}

		const currentValue = this.value();

		if (this.multiple()) {
			this.emitSelectionChange(
				((currentValue ?? []) as T[]).filter((v) => v !== value),
				source,
			);
		} else if (currentValue === value) {
			this.emitSelectionChange(null, source);
		}
	}

	/**
	 * @internal
	 * Determines whether a value is selected.
	 */
	isSelected(value: T): boolean {
		const currentValue = this.value();

		if (
			currentValue == null ||
			currentValue === undefined ||
			(Array.isArray(currentValue) && currentValue.length === 0)
		) {
			return false;
		}

		if (this.multiple()) {
			return (currentValue as T[])?.includes(value);
		}
		return currentValue === value;
	}

	/** Update the value of the group */
	private emitSelectionChange(value: ToggleValue<T>, source: BrnToggleGroupItemDirective<T>): void {
		this.value.set(value);
		this._onChange(value);
		this.change.emit(new BrnButtonToggleChange<T>(source, this.value()));
	}
}

type ToggleValue<T> = T | T[] | null | undefined;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/toggle-group/src/lib/brn-toggle-group.token.ts
```typescript
import { ExistingProvider, InjectionToken, Type, inject } from '@angular/core';
import type { BrnToggleGroupComponent } from './brn-toggle-group.component';

const BrnToggleGroupToken = new InjectionToken<BrnToggleGroupComponent>('BrnToggleGroupToken');

export function injectBrnToggleGroup<T>(): BrnToggleGroupComponent<T> | null {
	return inject(BrnToggleGroupToken, { optional: true }) as BrnToggleGroupComponent<T> | null;
}

export function provideBrnToggleGroup<T>(value: Type<BrnToggleGroupComponent<T>>): ExistingProvider {
	return { provide: BrnToggleGroupToken, useExisting: value };
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/toggle-group/src/lib/brn-toggle-item.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { ChangeDetectorRef, Directive, booleanAttribute, computed, inject, input, model } from '@angular/core';
import { injectBrnToggleGroup } from './brn-toggle-group.token';

@Directive({
	selector: 'button[hlmToggleGroupItem], button[brnToggleGroupItem]',
	standalone: true,
	host: {
		'[id]': 'id()',
		'[attr.disabled]': 'disabled() || group?.disabled() ? true : null',
		'[attr.data-disabled]': 'disabled() || group?.disabled() ? true : null',
		'[attr.data-state]': '_state()',
		'[attr.aria-pressed]': 'isOn()',
		'(click)': 'toggle()',
	},
})
export class BrnToggleGroupItemDirective<T> {
	private static _uniqueId = 0;

	private readonly _changeDetector = inject(ChangeDetectorRef);

	/** Access the toggle group if available. */
	protected readonly group = injectBrnToggleGroup<T>();

	/** The id of the toggle. */
	public readonly id = input(`brn-toggle-group-item-${BrnToggleGroupItemDirective._uniqueId++}`);

	/** The value this toggle represents. */
	public readonly value = input<T>();

	/** Whether the toggle is disabled. */
	public readonly disabled = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** The current state of the toggle when not used in a group. */
	public readonly state = model<'on' | 'off'>('off');

	/** Whether the toggle is responds to click events. */
	public readonly disableToggleClick = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** Whether the toggle is in the on state. */
	protected readonly isOn = computed(() => this._state() === 'on');

	/** The current state that reflects the group state or the model state. */
	protected readonly _state = computed(() => {
		if (this.group) {
			return this.group.isSelected(this.value() as T) ? 'on' : 'off';
		}
		return this.state();
	});

	toggle(): void {
		if (this.disableToggleClick()) return;

		if (this.group) {
			if (this.isOn()) {
				this.group.deselect(this.value() as T, this);
			} else {
				this.group.select(this.value() as T, this);
			}
		} else {
			this.state.set(this.isOn() ? 'off' : 'on');
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/toggle/README.md
```
# @spartan-ng/brain/toggle

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/toggle`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/toggle/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/toggle/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { BrnToggleDirective } from './lib/brn-toggle.directive';

export * from './lib/brn-toggle.directive';

@NgModule({
	imports: [BrnToggleDirective],
	exports: [BrnToggleDirective],
})
export class BrnToggleModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/toggle/src/lib/brn-toggle.directive.spec.ts
```typescript
import { render, screen } from '@testing-library/angular';
import userEvent from '@testing-library/user-event';
import { BrnToggleDirective } from './brn-toggle.directive';

describe('BrnToggleDirective', () => {
	const setup = async (disabled = false) => {
		const container = await render(
			`
     <button ${disabled ? 'disabled' : ''} brnToggle>Toggle</button>
    `,
			{
				imports: [BrnToggleDirective],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			toggle: screen.getByRole('button'),
		};
	};

	it('should be toggled off by default and then toggle between on and off on for click', async () => {
		const { toggle, container, user } = await setup();
		expect(toggle).not.toHaveAttribute('data-disabled');
		expect(toggle).not.toHaveAttribute('disabled');

		container.detectChanges();
		expect(toggle).toHaveAttribute('data-state', 'off');

		await user.click(toggle);
		container.detectChanges();
		expect(toggle).toHaveAttribute('data-state', 'on');

		await user.click(toggle);
		container.detectChanges();
		expect(toggle).toHaveAttribute('data-state', 'off');
	});

	it('should be toggled off by default and then toggle between on and off on for enter', async () => {
		const { toggle, container, user } = await setup();
		expect(toggle).not.toHaveAttribute('data-disabled');
		expect(toggle).not.toHaveAttribute('disabled');

		container.detectChanges();
		expect(toggle).toHaveAttribute('data-state', 'off');

		await user.keyboard('[Tab][Enter]');
		container.detectChanges();
		expect(toggle).toHaveAttribute('data-state', 'on');

		await user.keyboard('[Enter]');
		container.detectChanges();
		expect(toggle).toHaveAttribute('data-state', 'off');
	});

	it('should be toggled off by default and then toggle between on and off on for space', async () => {
		const { toggle, container, user } = await setup();
		expect(toggle).not.toHaveAttribute('data-disabled');
		expect(toggle).not.toHaveAttribute('disabled');

		container.detectChanges();
		expect(toggle).toHaveAttribute('data-state', 'off');

		await user.keyboard('[Tab][Space]');
		container.detectChanges();
		expect(toggle).toHaveAttribute('data-state', 'on');

		await user.keyboard('[Space]');
		container.detectChanges();
		expect(toggle).toHaveAttribute('data-state', 'off');
	});

	it('should add correct id, aria and disabled toggling when disabled', async () => {
		const { toggle, container, user } = await setup(true);
		expect(toggle).toHaveAttribute('data-state', 'off');
		expect(toggle).toHaveAttribute('id', expect.stringMatching(/brn-toggle-\d+/));
		expect(toggle).toHaveAttribute('data-disabled');
		expect(toggle).toHaveAttribute('disabled');

		await user.keyboard('[Tab][Space]');
		container.detectChanges();
		expect(toggle).toHaveAttribute('data-state', 'off');

		await user.click(toggle);
		container.detectChanges();
		expect(toggle).toHaveAttribute('data-state', 'off');

		await user.keyboard('[Enter]');
		container.detectChanges();
		expect(toggle).toHaveAttribute('data-state', 'off');
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/toggle/src/lib/brn-toggle.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { ChangeDetectorRef, Directive, booleanAttribute, computed, inject, input, model } from '@angular/core';

@Directive({
	selector: 'button[hlmToggle], button[brnToggle]',
	standalone: true,
	host: {
		'[id]': 'id()',
		'[attr.disabled]': 'disabled() ? true : null',
		'[attr.data-disabled]': 'disabled() ? true : null',
		'[attr.data-state]': '_state()',
		'[attr.aria-pressed]': 'isOn()',
		'(click)': 'toggle()',
	},
})
export class BrnToggleDirective<T> {
	private static _uniqueId = 0;

	private readonly _changeDetector = inject(ChangeDetectorRef);

	/** The id of the toggle. */
	public readonly id = input(`brn-toggle-${BrnToggleDirective._uniqueId++}`);

	/** The value this toggle represents. */
	public readonly value = input<T>();

	/** Whether the toggle is disabled. */
	public readonly disabled = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** The current state of the toggle when not used in a group. */
	public readonly state = model<'on' | 'off'>('off');

	/** Whether the toggle is responds to click events. */
	public readonly disableToggleClick = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/** Whether the toggle is in the on state. */
	protected readonly isOn = computed(() => this._state() === 'on');

	/** The current state that reflects the group state or the model state. */
	protected readonly _state = computed(() => {
		return this.state();
	});

	toggle(): void {
		if (this.disableToggleClick()) return;

		this.state.set(this.isOn() ? 'off' : 'on');
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/dialog/README.md
```
# @spartan-ng/brain/dialog

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/dialog`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/dialog/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/dialog/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { BrnDialogCloseDirective } from './lib/brn-dialog-close.directive';
import { BrnDialogContentDirective } from './lib/brn-dialog-content.directive';
import { BrnDialogDescriptionDirective } from './lib/brn-dialog-description.directive';
import { BrnDialogOverlayComponent } from './lib/brn-dialog-overlay.component';
import { BrnDialogTitleDirective } from './lib/brn-dialog-title.directive';
import { BrnDialogTriggerDirective } from './lib/brn-dialog-trigger.directive';
import { BrnDialogComponent } from './lib/brn-dialog.component';

export * from './lib/brn-dialog-close.directive';
export * from './lib/brn-dialog-content.directive';
export * from './lib/brn-dialog-description.directive';
export * from './lib/brn-dialog-options';
export * from './lib/brn-dialog-overlay.component';
export * from './lib/brn-dialog-ref';
export * from './lib/brn-dialog-state';
export * from './lib/brn-dialog-title.directive';
export * from './lib/brn-dialog-token';
export * from './lib/brn-dialog-trigger.directive';
export * from './lib/brn-dialog-utils';
export * from './lib/brn-dialog.component';
export * from './lib/brn-dialog.service';

export const BrnDialogImports = [
	BrnDialogComponent,
	BrnDialogOverlayComponent,
	BrnDialogTriggerDirective,
	BrnDialogCloseDirective,
	BrnDialogContentDirective,
	BrnDialogTitleDirective,
	BrnDialogDescriptionDirective,
] as const;

@NgModule({
	imports: [...BrnDialogImports],
	exports: [...BrnDialogImports],
})
export class BrnDialogModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/dialog/src/lib/brn-dialog-close.directive.ts
```typescript
import { coerceNumberProperty } from '@angular/cdk/coercion';
import { Directive, inject, input } from '@angular/core';
import { BrnDialogRef } from './brn-dialog-ref';

@Directive({
	selector: 'button[brnDialogClose]',
	standalone: true,
	host: {
		'(click)': 'close()',
	},
})
export class BrnDialogCloseDirective {
	private readonly _brnDialogRef = inject(BrnDialogRef);

	public readonly delay = input<number | undefined, number>(undefined, { transform: coerceNumberProperty });

	public close() {
		this._brnDialogRef.close(undefined, this.delay());
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/dialog/src/lib/brn-dialog-content.directive.ts
```typescript
import { computed, Directive, effect, inject, input, TemplateRef, untracked } from '@angular/core';
import { provideExposesStateProviderExisting } from '@spartan-ng/brain/core';
import { BrnDialogRef } from './brn-dialog-ref';
import { BrnDialogComponent } from './brn-dialog.component';

@Directive({
	selector: '[brnDialogContent]',
	standalone: true,
	providers: [provideExposesStateProviderExisting(() => BrnDialogContentDirective)],
})
export class BrnDialogContentDirective<T> {
	private readonly _brnDialog = inject(BrnDialogComponent, { optional: true });
	private readonly _brnDialogRef = inject(BrnDialogRef, { optional: true });
	private readonly _template = inject(TemplateRef);
	public readonly state = computed(() => this._brnDialog?.stateComputed() ?? this._brnDialogRef?.state() ?? 'closed');

	public readonly className = input<string | null | undefined>(undefined, { alias: 'class' });

	public readonly context = input<T | undefined>(undefined);

	constructor() {
		if (!this._brnDialog) return;
		this._brnDialog.registerTemplate(this._template);
		effect(() => {
			const context = this.context();
			if (!this._brnDialog || !context) return;
			untracked(() => this._brnDialog?.setContext(context));
		});
		effect(() => {
			if (!this._brnDialog) return;
			const newClass = this.className();
			untracked(() => this._brnDialog?.setPanelClass(newClass));
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/dialog/src/lib/brn-dialog-description.directive.ts
```typescript
import { Directive, effect, inject, signal } from '@angular/core';
import { BrnDialogRef } from './brn-dialog-ref';

@Directive({
	selector: '[brnDialogDescription]',
	standalone: true,
	host: {
		'[id]': '_id()',
	},
})
export class BrnDialogDescriptionDirective {
	private readonly _brnDialogRef = inject(BrnDialogRef);

	protected _id = signal(`brn-dialog-description-${this._brnDialogRef?.dialogId}`);

	constructor() {
		effect(() => {
			this._brnDialogRef.setAriaDescribedBy(this._id());
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/dialog/src/lib/brn-dialog-options.ts
```typescript
import type { AutoFocusTarget } from '@angular/cdk/dialog';
import type {
	ConnectedPosition,
	FlexibleConnectedPositionStrategyOrigin,
	PositionStrategy,
	ScrollStrategy,
} from '@angular/cdk/overlay';
import type { ElementRef, StaticProvider } from '@angular/core';

export type BrnDialogOptions = {
	id: string;
	role: 'dialog' | 'alertdialog';
	hasBackdrop: boolean;
	panelClass: string | string[];
	backdropClass: string | string[];
	positionStrategy: PositionStrategy | null | undefined;
	scrollStrategy: ScrollStrategy | null | undefined;
	restoreFocus: boolean | string | ElementRef;
	closeDelay: number;
	closeOnOutsidePointerEvents: boolean;
	closeOnBackdropClick: boolean;
	attachTo: FlexibleConnectedPositionStrategyOrigin | null | undefined;
	attachPositions: ConnectedPosition[];
	autoFocus: AutoFocusTarget | (Record<never, never> & string);
	disableClose: boolean;
	ariaDescribedBy: string | null | undefined;
	ariaLabelledBy: string | null | undefined;
	ariaLabel: string | null | undefined;
	ariaModal: boolean;
	providers?: StaticProvider[] | (() => StaticProvider[]);
};

export const DEFAULT_BRN_DIALOG_OPTIONS: Readonly<Partial<BrnDialogOptions>> = {
	role: 'dialog',
	attachPositions: [],
	attachTo: null,
	autoFocus: 'first-tabbable',
	backdropClass: '',
	closeDelay: 100,
	closeOnBackdropClick: true,
	closeOnOutsidePointerEvents: false,
	hasBackdrop: true,
	panelClass: '',
	positionStrategy: null,
	restoreFocus: true,
	scrollStrategy: null,
	disableClose: false,
	ariaLabel: undefined,
	ariaModal: true,
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/dialog/src/lib/brn-dialog-overlay.component.ts
```typescript
import { ChangeDetectionStrategy, Component, effect, inject, input, untracked, ViewEncapsulation } from '@angular/core';
import { provideCustomClassSettableExisting } from '@spartan-ng/brain/core';
import { BrnDialogComponent } from './brn-dialog.component';

@Component({
	selector: 'brn-dialog-overlay',
	standalone: true,
	template: '',
	providers: [provideCustomClassSettableExisting(() => BrnDialogOverlayComponent)],
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class BrnDialogOverlayComponent {
	private readonly _brnDialog = inject(BrnDialogComponent);

	public readonly className = input<string | null | undefined>(undefined, { alias: 'class' });

	setClassToCustomElement(newClass: string) {
		this._brnDialog.setOverlayClass(newClass);
	}
	constructor() {
		effect(() => {
			if (!this._brnDialog) return;
			const newClass = this.className();
			untracked(() => this._brnDialog.setOverlayClass(newClass));
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/dialog/src/lib/brn-dialog-ref.ts
```typescript
import type { DialogRef } from '@angular/cdk/dialog';
import type { Signal, WritableSignal } from '@angular/core';
import { Observable, Subject } from 'rxjs';
import { take } from 'rxjs/operators';
import type { BrnDialogOptions } from './brn-dialog-options';
import type { BrnDialogState } from './brn-dialog-state';
import { cssClassesToArray } from './brn-dialog-utils';

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export class BrnDialogRef<DialogResult = any> {
	private readonly _closing$ = new Subject<void>();
	public readonly closing$ = this._closing$.asObservable();

	public readonly closed$: Observable<DialogResult | undefined>;

	private _previousTimeout: ReturnType<typeof setTimeout> | undefined;

	public get open() {
		return this.state() === 'open';
	}

	constructor(
		private readonly _cdkDialogRef: DialogRef<DialogResult>,
		private readonly _open: WritableSignal<boolean>,
		public readonly state: Signal<BrnDialogState>,
		public readonly dialogId: number,
		private readonly _options?: BrnDialogOptions,
	) {
		this.closed$ = this._cdkDialogRef.closed.pipe(take(1));
	}

	public close(result?: DialogResult, delay: number = this._options?.closeDelay ?? 0) {
		if (!this.open || this._options?.disableClose) return;

		this._closing$.next();
		this._open.set(false);

		if (this._previousTimeout) {
			clearTimeout(this._previousTimeout);
		}

		this._previousTimeout = setTimeout(() => {
			this._cdkDialogRef.close(result);
		}, delay);
	}

	public setPanelClass(paneClass: string | null | undefined) {
		this._cdkDialogRef.config.panelClass = cssClassesToArray(paneClass);
	}

	public setOverlayClass(overlayClass: string | null | undefined) {
		this._cdkDialogRef.config.backdropClass = cssClassesToArray(overlayClass);
	}

	public setAriaDescribedBy(ariaDescribedBy: string | null | undefined) {
		this._cdkDialogRef.config.ariaDescribedBy = ariaDescribedBy;
	}

	public setAriaLabelledBy(ariaLabelledBy: string | null | undefined) {
		this._cdkDialogRef.config.ariaLabelledBy = ariaLabelledBy;
	}

	public setAriaLabel(ariaLabel: string | null | undefined) {
		this._cdkDialogRef.config.ariaLabel = ariaLabel;
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/dialog/src/lib/brn-dialog-state.ts
```typescript
export type BrnDialogState = 'closed' | 'open';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/dialog/src/lib/brn-dialog-title.directive.ts
```typescript
import { Directive, effect, inject, signal } from '@angular/core';
import { BrnDialogRef } from './brn-dialog-ref';

@Directive({
	selector: '[brnDialogTitle]',
	standalone: true,
	host: {
		'[id]': '_id()',
	},
})
export class BrnDialogTitleDirective {
	private readonly _brnDialogRef = inject(BrnDialogRef);

	protected _id = signal(`brn-dialog-title-${this._brnDialogRef?.dialogId}`);

	constructor() {
		effect(() => {
			this._brnDialogRef.setAriaLabelledBy(this._id());
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/dialog/src/lib/brn-dialog-token.ts
```typescript
import { inject, InjectionToken, ValueProvider } from '@angular/core';
import { BrnDialogOptions } from './brn-dialog-options';

export interface BrnDialogDefaultOptions {
	/** A connected position as specified by the user. */
	attachPositions: BrnDialogOptions['attachPositions'];

	/** Options for where to set focus to automatically on dialog open */
	autoFocus: BrnDialogOptions['autoFocus'];

	/** The delay in milliseconds before the dialog closes. */
	closeDelay: number;

	/** Close dialog on backdrop click */
	closeOnBackdropClick: boolean;

	/** Close dialog on outside pointer event */
	closeOnOutsidePointerEvents: boolean;

	/** Whether the dialog closes with the escape key or pointer events outside the panel element. */
	disableClose: boolean;

	/** Whether the dialog has a backdrop. */
	hasBackdrop: boolean;

	/** Strategy to use when positioning the dialog */
	positionStrategy: BrnDialogOptions['positionStrategy'];

	/** Whether the dialog should restore focus to the previously-focused element upon closing. */
	restoreFocus: BrnDialogOptions['restoreFocus'];

	/** The role of the dialog */
	role: BrnDialogOptions['role'];

	/** Scroll strategy to be used for the dialog. */
	scrollStrategy: BrnDialogOptions['scrollStrategy'] | 'close' | 'reposition';
}

export const defaultOptions: BrnDialogDefaultOptions = {
	attachPositions: [],
	autoFocus: 'first-tabbable',
	closeDelay: 100,
	closeOnBackdropClick: true,
	closeOnOutsidePointerEvents: false,
	disableClose: false,
	hasBackdrop: true,
	positionStrategy: null,
	restoreFocus: true,
	role: 'dialog',
	scrollStrategy: null,
};

const BRN_DIALOG_DEFAULT_OPTIONS = new InjectionToken<BrnDialogDefaultOptions>('brn-dialog-default-options', {
	providedIn: 'root',
	factory: () => defaultOptions,
});

export function provideBrnDialogDefaultOptions(options: Partial<BrnDialogDefaultOptions>): ValueProvider {
	return { provide: BRN_DIALOG_DEFAULT_OPTIONS, useValue: { ...defaultOptions, ...options } };
}

export function injectBrnDialogDefaultOptions(): BrnDialogDefaultOptions {
	return inject(BRN_DIALOG_DEFAULT_OPTIONS, { optional: true }) ?? defaultOptions;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/dialog/src/lib/brn-dialog-trigger.directive.ts
```typescript
import { computed, Directive, effect, inject, input, type Signal, signal } from '@angular/core';
import { BrnDialogRef } from './brn-dialog-ref';
import type { BrnDialogState } from './brn-dialog-state';
import { BrnDialogComponent } from './brn-dialog.component';

let idSequence = 0;

@Directive({
	selector: 'button[brnDialogTrigger],button[brnDialogTriggerFor]',
	standalone: true,
	host: {
		'[id]': 'id()',
		'(click)': 'open()',
		'aria-haspopup': 'dialog',
		'[attr.aria-expanded]': "state() === 'open' ? 'true': 'false'",
		'[attr.data-state]': 'state()',
		'[attr.aria-controls]': 'dialogId',
	},
	exportAs: 'brnDialogTrigger',
})
export class BrnDialogTriggerDirective {
	protected _brnDialog = inject(BrnDialogComponent, { optional: true });
	protected readonly _brnDialogRef = inject(BrnDialogRef, { optional: true });

	public readonly id = input(`brn-dialog-trigger-${idSequence++}`);

	public readonly state: Signal<BrnDialogState> = this._brnDialogRef?.state ?? signal('closed');
	public readonly dialogId = `brn-dialog-${this._brnDialogRef?.dialogId ?? idSequence++}`;

	public readonly brnDialogTriggerFor = input<BrnDialogComponent | undefined>(undefined, {
		alias: 'brnDialogTriggerFor',
	});
	public readonly mutableBrnDialogTriggerFor = computed(() => signal(this.brnDialogTriggerFor()));
	public readonly brnDialogTriggerForState = computed(() => this.mutableBrnDialogTriggerFor()());

	constructor() {
		effect(() => {
			const brnDialog = this.brnDialogTriggerForState();
			if (!brnDialog) return;
			this._brnDialog = brnDialog;
		});
	}

	open() {
		this._brnDialog?.open();
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/dialog/src/lib/brn-dialog-utils.ts
```typescript
// brn-dialog-utils.ts

export const cssClassesToArray = (classes: string | string[] | undefined | null, defaultClass = ''): string[] => {
	if (typeof classes === 'string') {
		const splitClasses = classes.trim().split(' ');
		if (splitClasses.length === 0) {
			return [defaultClass];
		}
		return splitClasses;
	}
	return classes ?? [];
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/dialog/src/lib/brn-dialog.component.ts
```typescript
import { OverlayPositionBuilder, ScrollStrategy, ScrollStrategyOptions } from '@angular/cdk/overlay';
import {
	booleanAttribute,
	ChangeDetectionStrategy,
	Component,
	computed,
	effect,
	type EffectRef,
	inject,
	Injector,
	input,
	numberAttribute,
	output,
	runInInjectionContext,
	signal,
	type TemplateRef,
	untracked,
	ViewContainerRef,
	ViewEncapsulation,
} from '@angular/core';
import { take } from 'rxjs/operators';
import { type BrnDialogOptions } from './brn-dialog-options';
import type { BrnDialogRef } from './brn-dialog-ref';
import type { BrnDialogState } from './brn-dialog-state';
import { injectBrnDialogDefaultOptions } from './brn-dialog-token';
import { BrnDialogService } from './brn-dialog.service';

@Component({
	selector: 'brn-dialog',
	standalone: true,
	template: `
		<ng-content />
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	exportAs: 'brnDialog',
})
export class BrnDialogComponent {
	private readonly _dialogService = inject(BrnDialogService);
	private readonly _vcr = inject(ViewContainerRef);
	public readonly positionBuilder = inject(OverlayPositionBuilder);
	public readonly ssos = inject(ScrollStrategyOptions);
	private readonly _injector = inject(Injector);

	protected readonly _defaultOptions = injectBrnDialogDefaultOptions();

	private _context = {};
	public readonly stateComputed = computed(() => this._dialogRef()?.state() ?? 'closed');

	private _contentTemplate: TemplateRef<unknown> | undefined;
	private readonly _dialogRef = signal<BrnDialogRef | undefined>(undefined);
	private _dialogStateEffectRef?: EffectRef;
	private readonly _backdropClass = signal<string | null | undefined>(null);
	private readonly _panelClass = signal<string | null | undefined>(null);

	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	public readonly closed = output<any>();

	public readonly stateChanged = output<BrnDialogState>();

	public readonly state = input<BrnDialogState | null>(null);

	public readonly role = input<BrnDialogOptions['role']>(this._defaultOptions.role);

	public readonly hasBackdrop = input(this._defaultOptions.hasBackdrop, { transform: booleanAttribute });

	public readonly positionStrategy = input<BrnDialogOptions['positionStrategy']>(this._defaultOptions.positionStrategy);
	public readonly mutablePositionStrategy = computed(() => signal(this.positionStrategy()));
	private readonly _positionStrategyState = computed(() => this.mutablePositionStrategy()());

	public readonly scrollStrategy = input<BrnDialogOptions['scrollStrategy'] | 'close' | 'reposition' | null>(
		this._defaultOptions.scrollStrategy,
	);

	protected _options = computed<Partial<BrnDialogOptions>>(() => {
		const scrollStrategyInput = this.scrollStrategy();
		let scrollStrategy: ScrollStrategy | null | undefined;

		if (scrollStrategyInput === 'close') {
			scrollStrategy = this.ssos.close();
		} else if (scrollStrategyInput === 'reposition') {
			scrollStrategy = this.ssos.reposition();
		} else {
			scrollStrategy = scrollStrategyInput;
		}

		return {
			role: this.role(),
			hasBackdrop: this.hasBackdrop(),
			positionStrategy: this._positionStrategyState(),
			scrollStrategy,
			restoreFocus: this.restoreFocus(),
			closeOnOutsidePointerEvents: this._closeOnOutsidePointerEventsState(),
			closeOnBackdropClick: this.closeOnBackdropClick(),
			attachTo: this._attachToState(),
			attachPositions: this._attachPositionsState(),
			autoFocus: this.autoFocus(),
			closeDelay: this.closeDelay(),
			disableClose: this.disableClose(),
			backdropClass: this._backdropClass() ?? '',
			panelClass: this._panelClass() ?? '',
			ariaDescribedBy: this._ariaDescribedByState(),
			ariaLabelledBy: this._ariaLabelledByState(),
			ariaLabel: this._ariaLabelState(),
			ariaModal: this._ariaModalState(),
		};
	});

	constructor() {
		effect(() => {
			const state = this.state();
			if (state === 'open') {
				untracked(() => this.open());
			}
			if (state === 'closed') {
				untracked(() => this.close());
			}
		});
	}

	public readonly restoreFocus = input<BrnDialogOptions['restoreFocus']>(this._defaultOptions.restoreFocus);

	public readonly closeOnOutsidePointerEvents = input(this._defaultOptions.closeOnOutsidePointerEvents, {
		transform: booleanAttribute,
	});
	public readonly mutableCloseOnOutsidePointerEvents = computed(() => signal(this.closeOnOutsidePointerEvents()));
	private readonly _closeOnOutsidePointerEventsState = computed(() => this.mutableCloseOnOutsidePointerEvents()());

	public readonly closeOnBackdropClick = input(this._defaultOptions.closeOnBackdropClick, {
		transform: booleanAttribute,
	});

	public readonly attachTo = input<BrnDialogOptions['attachTo']>(null);
	public readonly mutableAttachTo = computed(() => signal(this.attachTo()));
	private readonly _attachToState = computed(() => this.mutableAttachTo()());

	public readonly attachPositions = input<BrnDialogOptions['attachPositions']>(this._defaultOptions.attachPositions);
	public readonly mutableAttachPositions = computed(() => signal(this.attachPositions()));
	private readonly _attachPositionsState = computed(() => this.mutableAttachPositions()());

	public readonly autoFocus = input<BrnDialogOptions['autoFocus']>(this._defaultOptions.autoFocus);

	public readonly closeDelay = input(this._defaultOptions.closeDelay, {
		transform: numberAttribute,
	});

	public readonly disableClose = input(this._defaultOptions.disableClose, { transform: booleanAttribute });

	public readonly ariaDescribedBy = input<BrnDialogOptions['ariaDescribedBy']>(null, {
		alias: 'aria-describedby',
	});
	private readonly _mutableAriaDescribedBy = computed(() => signal(this.ariaDescribedBy()));
	private readonly _ariaDescribedByState = computed(() => this._mutableAriaDescribedBy()());

	public readonly ariaLabelledBy = input<BrnDialogOptions['ariaLabelledBy']>(null, { alias: 'aria-labelledby' });
	private readonly _mutableAriaLabelledBy = computed(() => signal(this.ariaLabelledBy()));
	private readonly _ariaLabelledByState = computed(() => this._mutableAriaLabelledBy()());

	public readonly ariaLabel = input<BrnDialogOptions['ariaLabel']>(null, { alias: 'aria-label' });
	private readonly _mutableAriaLabel = computed(() => signal(this.ariaLabel()));
	private readonly _ariaLabelState = computed(() => this._mutableAriaLabel()());

	public readonly ariaModal = input(true, { alias: 'aria-modal', transform: booleanAttribute });
	private readonly _mutableAriaModal = computed(() => signal(this.ariaModal()));
	private readonly _ariaModalState = computed(() => this._mutableAriaModal()());

	public open<DialogContext>() {
		if (!this._contentTemplate || this._dialogRef()) return;

		this._dialogStateEffectRef?.destroy();

		const dialogRef = this._dialogService.open<DialogContext>(
			this._contentTemplate,
			this._vcr,
			this._context as DialogContext,
			this._options(),
		);

		this._dialogRef.set(dialogRef);

		runInInjectionContext(this._injector, () => {
			this._dialogStateEffectRef = effect(() => {
				const state = dialogRef.state();
				untracked(() => this.stateChanged.emit(state));
			});
		});

		dialogRef.closed$.pipe(take(1)).subscribe((result) => {
			this._dialogRef.set(undefined);
			this.closed.emit(result);
		});
	}

	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	public close(result?: any, delay?: number) {
		this._dialogRef()?.close(result, delay ?? this._options().closeDelay);
	}

	public registerTemplate(template: TemplateRef<unknown>) {
		this._contentTemplate = template;
	}

	public setOverlayClass(overlayClass: string | null | undefined) {
		this._backdropClass.set(overlayClass);
		this._dialogRef()?.setOverlayClass(overlayClass);
	}

	public setPanelClass(panelClass: string | null | undefined) {
		this._panelClass.set(panelClass ?? '');
		this._dialogRef()?.setPanelClass(panelClass);
	}

	public setContext(context: unknown) {
		// eslint-disable-next-line @typescript-eslint/ban-ts-comment
		// @ts-expect-error
		this._context = { ...this._context, ...context };
	}

	public setAriaDescribedBy(ariaDescribedBy: string | null | undefined) {
		this._mutableAriaDescribedBy().set(ariaDescribedBy);
		this._dialogRef()?.setAriaDescribedBy(ariaDescribedBy);
	}

	public setAriaLabelledBy(ariaLabelledBy: string | null | undefined) {
		this._mutableAriaLabelledBy().set(ariaLabelledBy);
		this._dialogRef()?.setAriaLabelledBy(ariaLabelledBy);
	}

	public setAriaLabel(ariaLabel: string | null | undefined) {
		this._mutableAriaLabel().set(ariaLabel);
		this._dialogRef()?.setAriaLabel(ariaLabel);
	}

	public setAriaModal(ariaModal: boolean) {
		this._mutableAriaModal().set(ariaModal);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/dialog/src/lib/brn-dialog.service.ts
```typescript
import { DIALOG_DATA, Dialog } from '@angular/cdk/dialog';
import { type ComponentType, OverlayPositionBuilder, ScrollStrategyOptions } from '@angular/cdk/overlay';
import {
	type EffectRef,
	type InjectOptions,
	Injectable,
	Injector,
	RendererFactory2,
	type StaticProvider,
	type TemplateRef,
	type ViewContainerRef,
	computed,
	effect,
	inject,
	runInInjectionContext,
	signal,
} from '@angular/core';
import { Subject } from 'rxjs';
import { filter, takeUntil } from 'rxjs/operators';
import type { BrnDialogOptions } from './brn-dialog-options';
import { BrnDialogRef } from './brn-dialog-ref';
import type { BrnDialogState } from './brn-dialog-state';
import { cssClassesToArray } from './brn-dialog-utils';

let dialogSequence = 0;

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type BrnDialogContext<T> = T & { close: (result?: any) => void };

/** @deprecated `injectBrnDialogCtx` will no longer be supported once components are stable. Use `injectBrnDialogContext` instead.  */
export const injectBrnDialogCtx = <T>(): BrnDialogContext<T> => {
	return inject(DIALOG_DATA);
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const injectBrnDialogContext = <DialogContext = any>(options: InjectOptions = {}) => {
	return inject(DIALOG_DATA, options) as DialogContext;
};

@Injectable({ providedIn: 'root' })
export class BrnDialogService {
	private readonly _cdkDialog = inject(Dialog);
	private readonly _rendererFactory = inject(RendererFactory2);
	private readonly _renderer = this._rendererFactory.createRenderer(null, null);
	private readonly _positionBuilder = inject(OverlayPositionBuilder);
	private readonly _sso = inject(ScrollStrategyOptions);
	private readonly _injector = inject(Injector);

	public open<DialogContext>(
		content: ComponentType<unknown> | TemplateRef<unknown>,
		vcr?: ViewContainerRef,
		context?: DialogContext,
		options?: Partial<BrnDialogOptions>,
	) {
		if (options?.id && this._cdkDialog.getDialogById(options.id)) {
			throw new Error(`Dialog with ID: ${options.id} already exists`);
		}

		const positionStrategy =
			options?.positionStrategy ??
			(options?.attachTo && options?.attachPositions && options?.attachPositions?.length > 0
				? this._positionBuilder?.flexibleConnectedTo(options.attachTo).withPositions(options.attachPositions ?? [])
				: this._positionBuilder.global().centerHorizontally().centerVertically());

		let brnDialogRef!: BrnDialogRef;
		let effectRef!: EffectRef;

		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		const contextOrData: BrnDialogContext<any> = {
			...context,
			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			close: (result: any = undefined) => brnDialogRef.close(result, options?.closeDelay),
		};

		const destroyed$ = new Subject<void>();
		const open = signal<boolean>(true);
		const state = computed<BrnDialogState>(() => (open() ? 'open' : 'closed'));
		const dialogId = dialogSequence++;

		// eslint-disable-next-line @typescript-eslint/ban-ts-comment
		// @ts-ignore
		const cdkDialogRef = this._cdkDialog.open(content, {
			id: options?.id ?? `brn-dialog-${dialogId}`,
			role: options?.role,
			viewContainerRef: vcr,
			templateContext: () => ({
				$implicit: contextOrData,
			}),
			data: contextOrData,
			hasBackdrop: options?.hasBackdrop,
			panelClass: cssClassesToArray(options?.panelClass),
			backdropClass: cssClassesToArray(options?.backdropClass, 'bg-transparent'),
			positionStrategy,
			scrollStrategy: options?.scrollStrategy ?? this._sso?.block(),
			restoreFocus: options?.restoreFocus,
			disableClose: true,
			autoFocus: options?.autoFocus ?? 'first-tabbable',
			ariaDescribedBy: options?.ariaDescribedBy ?? `brn-dialog-description-${dialogId}`,
			ariaLabelledBy: options?.ariaLabelledBy ?? `brn-dialog-title-${dialogId}`,
			ariaLabel: options?.ariaLabel,
			ariaModal: options?.ariaModal,
			providers: (cdkDialogRef) => {
				brnDialogRef = new BrnDialogRef(cdkDialogRef, open, state, dialogId, options as BrnDialogOptions);

				runInInjectionContext(this._injector, () => {
					effectRef = effect(() => {
						if (overlay) {
							this._renderer.setAttribute(overlay, 'data-state', state());
						}
						if (backdrop) {
							this._renderer.setAttribute(backdrop, 'data-state', state());
						}
					});
				});

				const providers: StaticProvider[] = [
					{
						provide: BrnDialogRef,
						useValue: brnDialogRef,
					},
				];

				if (options?.providers) {
					if (typeof options.providers === 'function') {
						providers.push(...options.providers());
					}

					if (Array.isArray(options.providers)) {
						providers.push(...options.providers);
					}
				}

				return providers;
			},
		});

		const overlay = cdkDialogRef.overlayRef.overlayElement;
		const backdrop = cdkDialogRef.overlayRef.backdropElement;

		if (options?.closeOnOutsidePointerEvents) {
			cdkDialogRef.outsidePointerEvents.pipe(takeUntil(destroyed$)).subscribe(() => {
				brnDialogRef.close(undefined, options?.closeDelay);
			});
		}

		if (options?.closeOnBackdropClick) {
			cdkDialogRef.backdropClick.pipe(takeUntil(destroyed$)).subscribe(() => {
				brnDialogRef.close(undefined, options?.closeDelay);
			});
		}

		if (!options?.disableClose) {
			cdkDialogRef.keydownEvents
				.pipe(
					filter((e) => e.key === 'Escape'),
					takeUntil(destroyed$),
				)
				.subscribe(() => {
					brnDialogRef.close(undefined, options?.closeDelay);
				});
		}

		cdkDialogRef.closed.pipe(takeUntil(destroyed$)).subscribe(() => {
			effectRef?.destroy();
			destroyed$.next();
		});

		return brnDialogRef;
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/form-field/README.md
```
# @spartan-ng/brain/form-field

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/form-field`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/form-field/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/form-field/src/index.ts
```typescript
export * from './lib/brn-form-field-control';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/form-field/src/lib/brn-form-field-control.ts
```typescript
import { Directive, type Signal, signal } from '@angular/core';
import type { AbstractControlDirective, NgControl } from '@angular/forms';

@Directive()
export class BrnFormFieldControl {
	/** Gets the AbstractControlDirective for this control. */
	public readonly ngControl: NgControl | AbstractControlDirective | null = null;

	/** Whether the control is in an error state. */
	public readonly errorState: Signal<boolean> = signal(false);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/popover/README.md
```
# @spartan-ng/brain/popover

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/popover`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/popover/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/popover/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { BrnPopoverCloseDirective } from './lib/brn-popover-close.directive';
import { BrnPopoverContentDirective } from './lib/brn-popover-content.directive';
import { BrnPopoverTriggerDirective } from './lib/brn-popover-trigger.directive';
import { BrnPopoverComponent } from './lib/brn-popover.component';

export * from './lib/brn-popover-close.directive';
export * from './lib/brn-popover-content.directive';
export * from './lib/brn-popover-trigger.directive';
export * from './lib/brn-popover.component';

export const BrnPopoverImports = [
	BrnPopoverComponent,
	BrnPopoverTriggerDirective,
	BrnPopoverCloseDirective,
	BrnPopoverContentDirective,
] as const;

@NgModule({
	imports: [...BrnPopoverImports],
	exports: [...BrnPopoverImports],
})
export class BrnPopoverModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/popover/src/lib/brn-popover-close.directive.ts
```typescript
import { Directive } from '@angular/core';
import { BrnDialogCloseDirective } from '@spartan-ng/brain/dialog';

@Directive({
	selector: 'button[brnPopoverClose]',
	standalone: true,
})
export class BrnPopoverCloseDirective extends BrnDialogCloseDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/popover/src/lib/brn-popover-content.directive.ts
```typescript
import { Directive } from '@angular/core';
import { provideExposesStateProviderExisting } from '@spartan-ng/brain/core';
import { BrnDialogContentDirective } from '@spartan-ng/brain/dialog';

@Directive({
	selector: '[brnPopoverContent]',
	standalone: true,
	providers: [provideExposesStateProviderExisting(() => BrnPopoverContentDirective)],
})
export class BrnPopoverContentDirective<T> extends BrnDialogContentDirective<T> {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/popover/src/lib/brn-popover-trigger.directive.ts
```typescript
import { Directive, ElementRef, effect, inject, input, untracked } from '@angular/core';
import { BrnDialogTriggerDirective } from '@spartan-ng/brain/dialog';
import type { BrnPopoverComponent } from './brn-popover.component';

@Directive({
	selector: 'button[brnPopoverTrigger],button[brnPopoverTriggerFor]',
	standalone: true,
	host: {
		'[id]': 'id()',
		'aria-haspopup': 'dialog',
		'[attr.aria-expanded]': "state() === 'open' ? 'true': 'false'",
		'[attr.data-state]': 'state()',
		'[attr.aria-controls]': 'dialogId',
	},
})
export class BrnPopoverTriggerDirective extends BrnDialogTriggerDirective {
	private readonly _host = inject(ElementRef, { host: true });

	public readonly brnPopoverTriggerFor = input<BrnPopoverComponent | undefined>(undefined, {
		alias: 'brnPopoverTriggerFor',
	});

	constructor() {
		super();
		if (!this._brnDialog) return;
		this._brnDialog.mutableAttachTo().set(this._host.nativeElement);
		this._brnDialog.mutableCloseOnOutsidePointerEvents().set(true);

		effect(() => {
			const brnDialog = this.brnPopoverTriggerFor();
			untracked(() => {
				if (!brnDialog) return;
				brnDialog.mutableAttachTo().set(this._host.nativeElement);
				brnDialog.mutableCloseOnOutsidePointerEvents().set(true);
				this.mutableBrnDialogTriggerFor().set(brnDialog);
			});
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/popover/src/lib/brn-popover.component.ts
```typescript
import {
	ChangeDetectionStrategy,
	Component,
	effect,
	forwardRef,
	input,
	numberAttribute,
	untracked,
	ViewEncapsulation,
} from '@angular/core';
import { BrnDialogComponent, BrnDialogDefaultOptions, provideBrnDialogDefaultOptions } from '@spartan-ng/brain/dialog';

export const BRN_POPOVER_DIALOG_DEFAULT_OPTIONS: Partial<BrnDialogDefaultOptions> = {
	hasBackdrop: false,
	scrollStrategy: 'reposition',
};

export type BrnPopoverAlign = 'start' | 'center' | 'end';

@Component({
	selector: 'brn-popover',
	standalone: true,
	template: `
		<ng-content />
	`,
	providers: [
		{
			provide: BrnDialogComponent,
			useExisting: forwardRef(() => BrnPopoverComponent),
		},
		provideBrnDialogDefaultOptions(BRN_POPOVER_DIALOG_DEFAULT_OPTIONS),
	],
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	exportAs: 'brnPopover',
})
export class BrnPopoverComponent extends BrnDialogComponent {
	public readonly align = input<BrnPopoverAlign>('center');
	public readonly sideOffset = input(0, { transform: numberAttribute });

	constructor() {
		super();
		this.setAriaDescribedBy('');
		this.setAriaLabelledBy('');

		effect(() => {
			const align = this.align();
			untracked(() => {
				this.mutableAttachPositions().set([
					{
						originX: align,
						originY: 'bottom',
						overlayX: align,
						overlayY: 'top',
					},
					{
						originX: align,
						originY: 'top',
						overlayX: align,
						overlayY: 'bottom',
					},
				]);
			});
			untracked(() => {
				this.applySideOffset(this.sideOffset());
			});
		});
		effect(() => {
			const sideOffset = this.sideOffset();
			untracked(() => {
				this.applySideOffset(sideOffset);
			});
		});
	}

	private applySideOffset(sideOffset: number) {
		this.mutableAttachPositions().update((positions) =>
			positions.map((position) => ({
				...position,
				offsetY: position.originY === 'top' ? -sideOffset : sideOffset,
			})),
		);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/table/README.md
```
# @spartan-ng/brain/table

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/table`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/table/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/table/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { BrnCellDefDirective } from './lib/brn-cell-def.directive';
import { BrnColumnDefComponent } from './lib/brn-column-def.component';
import { BrnFooterDefDirective } from './lib/brn-footer-def.directive';
import { BrnHeaderDefDirective } from './lib/brn-header-def.directive';
import { BrnPaginatorDirective } from './lib/brn-paginator.directive';
import { BrnTableComponent } from './lib/brn-table.component';

export { BrnCellDefDirective } from './lib/brn-cell-def.directive';
export { BrnColumnDefComponent } from './lib/brn-column-def.component';
export { BrnColumnManager, useBrnColumnManager } from './lib/brn-column-manager';
export { BrnFooterDefDirective } from './lib/brn-footer-def.directive';
export { BrnHeaderDefDirective } from './lib/brn-header-def.directive';
export { BrnPaginatorDirective, PaginatorContext, PaginatorState } from './lib/brn-paginator.directive';
export { BrnTableComponent } from './lib/brn-table.component';

export const BrnTableImports = [
	BrnCellDefDirective,
	BrnColumnDefComponent,
	BrnFooterDefDirective,
	BrnHeaderDefDirective,
	BrnTableComponent,
	BrnPaginatorDirective,
] as const;

@NgModule({
	imports: [...BrnTableImports],
	exports: [...BrnTableImports],
})
export class BrnTableModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/table/src/lib/brn-cell-def.directive.ts
```typescript
import { CdkCellDef } from '@angular/cdk/table';
import { Directive, TemplateRef, inject } from '@angular/core';

@Directive({
	standalone: true,
	selector: '[brnCellDef]',
	exportAs: 'brnCellDef',
})
export class BrnCellDefDirective extends CdkCellDef {
	public override template: TemplateRef<unknown>;

	constructor() {
		const template = inject<TemplateRef<unknown>>(TemplateRef);

		super(template);
		this.template = template;
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/table/src/lib/brn-column-def.component.ts
```typescript
import {
	type CdkCellDef,
	CdkColumnDef,
	type CdkFooterCellDef,
	type CdkHeaderCellDef,
	CdkTableModule,
} from '@angular/cdk/table';
import {
	type AfterContentChecked,
	ChangeDetectionStrategy,
	Component,
	ContentChild,
	Input,
	ViewChild,
	ViewEncapsulation,
	input,
} from '@angular/core';
import { BrnCellDefDirective } from './brn-cell-def.directive';
import { BrnFooterDefDirective } from './brn-footer-def.directive';
import { BrnHeaderDefDirective } from './brn-header-def.directive';

@Component({
	selector: 'brn-column-def',
	imports: [CdkTableModule],
	template: `
		<ng-container [cdkColumnDef]="name">
			<ng-content select="[brnHeaderDef]" />
			<ng-content select="[brnCellDef]" />
			<ng-content select="[brnFooterDef]" />
		</ng-container>
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class BrnColumnDefComponent implements AfterContentChecked {
	public get columnDef() {
		return this._columnDef;
	}

	public get cell() {
		return this._columnDef.cell;
	}

	private _name = '';
	@Input()
	public get name(): string {
		return this._name;
	}

	public set name(value: string) {
		this._name = value;
		if (!this._columnDef) return;
		this._columnDef.name = value;
	}

	public readonly class = input('');

	@ViewChild(CdkColumnDef, { static: true })
	private readonly _columnDef!: CdkColumnDef;

	@ContentChild(BrnCellDefDirective, { static: true })
	private readonly _cellDef?: CdkCellDef;
	@ContentChild(BrnFooterDefDirective, { static: true })
	private readonly _footerCellDef?: CdkFooterCellDef;
	@ContentChild(BrnHeaderDefDirective, { static: true })
	private readonly _headerCellDef?: CdkHeaderCellDef;

	public ngAfterContentChecked(): void {
		this._columnDef.name = this.name;
		if (this._cellDef) {
			this._columnDef.cell = this._cellDef;
		}
		if (this._headerCellDef) {
			this._columnDef.headerCell = this._headerCellDef;
		}
		if (this._footerCellDef) {
			this._columnDef.footerCell = this._footerCellDef;
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/table/src/lib/brn-column-manager.spec.ts
```typescript
import { useBrnColumnManager } from './brn-column-manager';

describe('BrnColumnManager', () => {
	it('should initialize with a Record of column names to booleans', () => {
		const columnManager = useBrnColumnManager({
			name: true,
			age: false,
		});

		expect(columnManager.allColumns).toEqual(['name', 'age']);
		expect(columnManager.displayedColumns()).toEqual(['name']);
		expect(columnManager.isColumnVisible('name')).toBe(true);
		expect(columnManager.isColumnVisible('age')).toBe(false);
	});

	it('should initialize with a Record of column names to objects', () => {
		const columnManager = useBrnColumnManager({
			name: { visible: true },
			age: { visible: false },
		});

		expect(columnManager.allColumns).toEqual([
			{ name: 'name', visible: true },
			{ name: 'age', visible: false },
		]);
		expect(columnManager.displayedColumns()).toEqual(['name']);
		expect(columnManager.isColumnVisible('name')).toBe(true);
		expect(columnManager.isColumnVisible('age')).toBe(false);
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/table/src/lib/brn-column-manager.ts
```typescript
import { type Signal, computed, signal } from '@angular/core';

type BrnColumnVisibility = Record<string, boolean> | Record<string, { visible: boolean }>;

// prettier-ignore
type AllColumnsPropertyType<T> = T extends Record<string, boolean>
	? (keyof T)[]
	: T extends Record<string, infer R>
		? (R extends { visible: boolean } ? { name: keyof T } & R : never)[]
		: never;

export class BrnColumnManager<T extends BrnColumnVisibility> {
	private readonly _initialColumnVisibility: T;
	private readonly _columnVisibility;

	public readonly allColumns: AllColumnsPropertyType<T>;
	public readonly columnVisibility;
	public readonly displayedColumns: Signal<(keyof T)[]> = computed(() => {
		return Object.entries(this._columnVisibility())
			.filter(([, value]) => (typeof value === 'boolean' ? value : value.visible))
			.map(([key]) => key);
	});

	constructor(initialColumnVisibility: T) {
		this._initialColumnVisibility = initialColumnVisibility;
		this._columnVisibility = signal(this._initialColumnVisibility);
		this._columnVisibility.set(this._initialColumnVisibility);
		this.columnVisibility = this._columnVisibility.asReadonly();
		this.allColumns = this.createAllColumns(this._initialColumnVisibility);
	}

	public readonly isColumnVisible = (columnName: string) => {
		const visibilityMap = this.columnVisibility();
		const columnEntry = visibilityMap[columnName];
		return typeof columnEntry === 'boolean' ? columnEntry : columnEntry.visible;
	};
	public readonly isColumnDisabled = (columnName: string) =>
		this.isColumnVisible(columnName) && this.displayedColumns().length === 1;

	public toggleVisibility(columnName: keyof T) {
		const visibilityMap = this._columnVisibility();
		const columnEntry = visibilityMap[columnName];
		const newVisibilityState = typeof columnEntry === 'boolean' ? !columnEntry : { visible: !columnEntry.visible };
		this._columnVisibility.set({ ...visibilityMap, [columnName]: newVisibilityState });
	}
	public setVisible(columnName: keyof T) {
		const visibilityMap = this._columnVisibility();
		const columnEntry = visibilityMap[columnName];
		const newVisibilityState = typeof columnEntry === 'boolean' ? true : { visible: true };
		this._columnVisibility.set({ ...visibilityMap, [columnName]: newVisibilityState });
	}
	public setInvisible(columnName: keyof T) {
		const visibilityMap = this._columnVisibility();
		const columnEntry = visibilityMap[columnName];
		const newVisibilityState = typeof columnEntry === 'boolean' ? false : { visible: false };
		this._columnVisibility.set({ ...visibilityMap, [columnName]: newVisibilityState });
	}

	private createAllColumns(initialColumnVisibility: T): AllColumnsPropertyType<T> {
		const keys = Object.keys(initialColumnVisibility) as (keyof T)[];
		if (this.isBooleanConfig(initialColumnVisibility)) {
			return keys as unknown as AllColumnsPropertyType<T>;
		}
		return keys.map((key) => {
			const values = initialColumnVisibility[key] as { visible: boolean };
			return {
				name: key,
				...values,
			};
		}) as AllColumnsPropertyType<T>;
	}

	private isBooleanConfig(config: any): config is Record<string, boolean> {
		return typeof Object.values(config)[0] === 'boolean';
	}
}

export const useBrnColumnManager = <T extends BrnColumnVisibility>(initialColumnVisibility: T) =>
	new BrnColumnManager(initialColumnVisibility);

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/table/src/lib/brn-footer-def.directive.ts
```typescript
import { CdkFooterCellDef } from '@angular/cdk/table';
import { Directive, TemplateRef, inject } from '@angular/core';

@Directive({
	standalone: true,
	selector: '[brnFooterDef]',
	exportAs: 'brnFooterDef',
})
export class BrnFooterDefDirective extends CdkFooterCellDef {
	public override template: TemplateRef<unknown>;

	constructor() {
		const template = inject<TemplateRef<unknown>>(TemplateRef);

		super(template);
		this.template = template;
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/table/src/lib/brn-header-def.directive.ts
```typescript
import { CdkHeaderCellDef } from '@angular/cdk/table';
import { Directive, TemplateRef, inject } from '@angular/core';

@Directive({
	standalone: true,
	selector: '[brnHeaderDef]',
	exportAs: 'brnHeaderDef',
})
export class BrnHeaderDefDirective extends CdkHeaderCellDef {
	public override template: TemplateRef<unknown>;

	constructor() {
		const template = inject<TemplateRef<unknown>>(TemplateRef);

		super(template);
		this.template = template;
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/table/src/lib/brn-paginator.directive.ts
```typescript
import {
	Directive,
	Input,
	type OnInit,
	type Signal,
	TemplateRef,
	ViewContainerRef,
	computed,
	effect,
	inject,
	numberAttribute,
	signal,
	untracked,
} from '@angular/core';

export type PaginatorState = {
	currentPage: number;
	startIndex: number;
	endIndex: number;
	pageSize: number;
	totalPages: number;
	totalElements: number | null | undefined;
};

export type PaginatorContext = {
	$implicit: {
		state: Signal<PaginatorState>;
		incrementable: Signal<boolean>;
		decrementable: Signal<boolean>;
		increment: () => void;
		decrement: () => void;
	};
};

@Directive({
	standalone: true,
	selector: '[brnPaginator]',
	exportAs: 'brnPaginator',
})
export class BrnPaginatorDirective implements OnInit {
	static ngTemplateContextGuard(_directive: BrnPaginatorDirective, _context: unknown): _context is PaginatorContext {
		return true;
	}

	private readonly _vcr = inject(ViewContainerRef);
	private readonly _template = inject(TemplateRef<unknown>);

	private readonly _state = signal<PaginatorState>({
		currentPage: 0,
		startIndex: 0,
		endIndex: 0,
		pageSize: 10,
		totalPages: 0,
		totalElements: null,
	});
	private readonly _decrementable = computed(() => 0 < this._state().startIndex);
	private readonly _incrementable = computed(() => this._state().endIndex < (this._state().totalElements ?? 0) - 1);

	@Input({ alias: 'brnPaginatorTotalElements' })
	public set totalElements(value: number | null | undefined) {
		this.calculateNewState({ newTotalElements: value, newPage: 0 });
	}

	@Input({ alias: 'brnPaginatorCurrentPage', transform: numberAttribute })
	public set currentPage(value: number) {
		this.calculateNewState({ newPage: value });
	}

	@Input({ alias: 'brnPaginatorPageSize', transform: numberAttribute })
	public set pageSize(value: number) {
		this.calculateNewState({ newPageSize: value, newPage: 0 });
	}

	@Input({ alias: 'brnPaginatorOnStateChange' })
	public onStateChange?: (state: PaginatorState) => void;

	constructor() {
		effect(() => {
			const state = this._state();
			untracked(() => {
				Promise.resolve().then(() => {
					if (this.onStateChange) {
						this.onStateChange(state);
					}
				});
			});
		});
	}

	public ngOnInit() {
		this._vcr.createEmbeddedView<PaginatorContext>(this._template, {
			$implicit: {
				state: this._state,
				increment: () => this.incrementPage(),
				decrement: () => this.decrementPage(),
				incrementable: this._incrementable,
				decrementable: this._decrementable,
			},
		});
	}

	public decrementPage(): void {
		const { currentPage } = this._state();
		if (0 < currentPage) {
			this.calculateNewState({ newPage: currentPage - 1 });
		}
	}

	public incrementPage(): void {
		const { currentPage, totalPages } = this._state();
		if (totalPages > currentPage) {
			this.calculateNewState({ newPage: currentPage + 1 });
		}
	}

	public reset(): void {
		this.currentPage = 0;
	}

	private calculateNewState({
		newPage,
		newPageSize,
		newTotalElements,
	}: Partial<{
		newPage: number;
		newPageSize: number;
		newTotalElements: number | null | undefined;
	}>) {
		const previousState = this._state();

		let currentPage = newPage ?? previousState.currentPage;
		const pageSize = newPageSize ?? previousState.pageSize;
		const totalElements = newTotalElements ?? previousState.totalElements ?? 0;

		const newTotalPages = totalElements ? Math.floor(totalElements / pageSize) : 0;

		if (newTotalPages < currentPage - 1) {
			currentPage = newTotalPages - 1;
		}

		const newStartIndex = totalElements === 0 ? 0 : Math.min(totalElements - 1, currentPage * pageSize);
		const newEndIndex = Math.min((currentPage + 1) * pageSize - 1, totalElements - 1);

		const newState = {
			currentPage: currentPage,
			startIndex: newStartIndex,
			endIndex: newEndIndex,
			pageSize: pageSize,
			totalPages: newTotalPages,
			totalElements: totalElements,
		};

		this._state.set(newState);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/table/src/lib/brn-table.component.ts
```typescript
import { CdkRowDef, CdkTable, type CdkTableDataSourceInput, CdkTableModule } from '@angular/cdk/table';
import {
	type AfterContentInit,
	ChangeDetectionStrategy,
	Component,
	ContentChildren,
	EventEmitter,
	Input,
	Output,
	type QueryList,
	type TrackByFunction,
	ViewChild,
	ViewEncapsulation,
	booleanAttribute,
} from '@angular/core';
import { type TableClassesSettable, provideTableClassesSettableExisting } from '@spartan-ng/brain/core';
import { BrnColumnDefComponent } from './brn-column-def.component';

export type BrnTableDataSourceInput<T> = CdkTableDataSourceInput<T>;

@Component({
	selector: 'brn-table',
	imports: [CdkTableModule],
	providers: [provideTableClassesSettableExisting(<T>() => BrnTableComponent<T>)],
	template: `
		<cdk-table
			#cdkTable
			[class]="tableClasses"
			[dataSource]="dataSource"
			[fixedLayout]="fixedLayout"
			[multiTemplateDataRows]="multiTemplateDataRows"
			(contentChanged)="contentChanged.emit()"
		>
			<ng-content />

			<cdk-header-row [class]="headerRowClasses" *cdkHeaderRowDef="displayedColumns; sticky: stickyHeader" />
			@if (!customTemplateDataRows) {
				<cdk-row
					[tabindex]="!!onRowClick ? 0 : -1"
					[attr.role]="!!onRowClick ? 'button' : 'row'"
					[class.row-interactive]="!!onRowClick"
					(keydown.enter)="!!onRowClick && onRowClick(row)"
					(click)="!!onRowClick && onRowClick(row)"
					[class]="bodyRowClasses"
					*cdkRowDef="let row; columns: displayedColumns"
				/>
			}

			<ng-template cdkNoDataRow>
				<ng-content select="[brnNoDataRow]" />
			</ng-template>
		</cdk-table>
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class BrnTableComponent<T> implements TableClassesSettable, AfterContentInit {
	@ViewChild('cdkTable', { read: CdkTable, static: true })
	private readonly _cdkTable?: CdkTable<T>;
	// Cdk Table Inputs / Outputs
	@Input()
	public dataSource: BrnTableDataSourceInput<T> = [];
	@Input({ transform: booleanAttribute })
	public fixedLayout = false;
	@Input({ transform: booleanAttribute })
	public multiTemplateDataRows = false;
	@Input()
	public displayedColumns: string[] = [];

	private _trackBy?: TrackByFunction<T>;
	public get trackBy(): TrackByFunction<T> | undefined {
		return this._trackBy;
	}

	@Input()
	public set trackBy(value: TrackByFunction<T>) {
		this._trackBy = value;
		if (this._cdkTable) {
			this._cdkTable.trackBy = this._trackBy;
		}
	}

	@Output()
	public readonly contentChanged: EventEmitter<void> = new EventEmitter<void>();

	// Brn Inputs / Outputs
	@Input({ transform: booleanAttribute })
	public customTemplateDataRows = false;
	@Input()
	public onRowClick: ((element: T) => void) | undefined;

	@Input({ transform: booleanAttribute })
	public stickyHeader = false;
	@Input()
	public tableClasses = '';
	@Input()
	public headerRowClasses = '';
	@Input()
	public bodyRowClasses = '';

	@ContentChildren(BrnColumnDefComponent) public columnDefComponents!: QueryList<BrnColumnDefComponent>;
	@ContentChildren(CdkRowDef) public rowDefs!: QueryList<CdkRowDef<T>>;

	// after the <ng-content> has been initialized, the column definitions are available.
	// All that's left is to add them to the table ourselves:
	public ngAfterContentInit(): void {
		this.columnDefComponents.forEach((component) => {
			if (!this._cdkTable) return;
			if (component.cell) {
				this._cdkTable.addColumnDef(component.columnDef);
			}
		});
		this.rowDefs.forEach((rowDef) => {
			if (!this._cdkTable) return;
			this._cdkTable.addRowDef(rowDef);
		});
	}

	public setTableClasses({
		table,
		headerRow,
		bodyRow,
	}: Partial<{ table: string; headerRow: string; bodyRow: string }>): void {
		if (table) {
			this.tableClasses = table;
		}
		if (headerRow) {
			this.headerRowClasses = headerRow;
		}
		if (bodyRow) {
			this.bodyRowClasses = bodyRow;
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/collapsible/README.md
```
# @spartan-ng/brain/collapsible

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/collapsible`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/collapsible/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/collapsible/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { BrnCollapsibleContentComponent } from './lib/brn-collapsible-content.component';
import { BrnCollapsibleTriggerDirective } from './lib/brn-collapsible-trigger.directive';
import { BrnCollapsibleComponent } from './lib/brn-collapsible.component';

export * from './lib/brn-collapsible-content.component';
export * from './lib/brn-collapsible-trigger.directive';
export * from './lib/brn-collapsible.component';

export const BrnCollapsibleImports = [
	BrnCollapsibleComponent,
	BrnCollapsibleTriggerDirective,
	BrnCollapsibleContentComponent,
] as const;

@NgModule({
	imports: [...BrnCollapsibleImports],
	exports: [...BrnCollapsibleImports],
})
export class BrnCollapsibleModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/collapsible/src/lib/brn-collapsible-content.component.ts
```typescript
import { isPlatformServer } from '@angular/common';
import { Component, ElementRef, OnInit, PLATFORM_ID, effect, inject, input, signal, untracked } from '@angular/core';
import { BrnCollapsibleComponent } from './brn-collapsible.component';

@Component({
	selector: 'brn-collapsible-content',
	standalone: true,
	host: {
		'[hidden]': '!collapsible?.expanded()',
		'[attr.data-state]': 'collapsible?.expanded() ? "open" : "closed"',
		'[id]': 'collapsible?.contentId()',
		'[style.--brn-collapsible-content-width.px]': 'width()',
		'[style.--brn-collapsible-content-height.px]': 'height()',
	},
	template: `
		<ng-content />
	`,
})
export class BrnCollapsibleContentComponent implements OnInit {
	protected readonly collapsible = inject(BrnCollapsibleComponent, { optional: true });
	private readonly _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);
	private readonly _platformId = inject(PLATFORM_ID);
	/**
	 * The id of the collapsible content element.
	 */
	public readonly id = input<string | null | undefined>();
	protected readonly width = signal<number | null>(null);
	protected readonly height = signal<number | null>(null);

	constructor() {
		if (!this.collapsible) {
			throw Error('Collapsible trigger directive can only be used inside a brn-collapsible element.');
		}

		effect(() => {
			const id = this.id();
			const collapsible = this.collapsible;
			if (!id || !collapsible) return;
			untracked(() => collapsible.contentId.set(id));
		});
	}

	ngOnInit(): void {
		if (isPlatformServer(this._platformId)) {
			return;
		}

		// ensure the element is not hidden when measuring its size
		this._elementRef.nativeElement.hidden = false;

		const { width, height } = this._elementRef.nativeElement.getBoundingClientRect();
		this.width.set(width);
		this.height.set(height);

		// we force the element to be hidden again if collapsed after measuring its size
		// this is handled by the host binding, but it can cause a flicker if we don't do this here manually
		this._elementRef.nativeElement.hidden = this.collapsible?.expanded() ?? false;
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/collapsible/src/lib/brn-collapsible-trigger.directive.ts
```typescript
import { Directive, inject } from '@angular/core';
import { BrnCollapsibleComponent } from './brn-collapsible.component';

@Directive({
	selector: 'button[brnCollapsibleTrigger]',
	standalone: true,
	host: {
		'[attr.data-state]': 'collapsible?.expanded() ? "open" : "closed"',
		'[attr.disabled]': 'collapsible?.disabled() ? true : undefined',
		'[attr.aria-expanded]': 'collapsible?.expanded()',
		'[attr.aria-controls]': 'collapsible?.contentId()',
		'(click)': 'toggle()',
	},
})
export class BrnCollapsibleTriggerDirective {
	protected readonly collapsible = inject(BrnCollapsibleComponent, { optional: true });

	constructor() {
		if (!this.collapsible) {
			throw Error('Collapsible trigger directive can only be used inside a brn-collapsible element.');
		}
	}

	toggle(): void {
		this.collapsible?.toggle();
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/collapsible/src/lib/brn-collapsible.component.spec.ts
```typescript
import { render, screen } from '@testing-library/angular';
import userEvent from '@testing-library/user-event';
import { axe } from 'jest-axe';
import { BrnCollapsibleContentComponent } from './brn-collapsible-content.component';
import { BrnCollapsibleTriggerDirective } from './brn-collapsible-trigger.directive';
import { BrnCollapsibleComponent } from './brn-collapsible.component';

describe('BrnCollapsibleComponent', () => {
	const setup = async (id?: string, disabled = false) => {
		const container = await render(
			`
     <brn-collapsible ${disabled ? 'disabled' : ''} data-testid='root'>
      <div>
        <h4>&#64;peduarte starred 3 repositories</h4>
        <button brnCollapsibleTrigger data-testid='trigger'>Toggle</button>
      </div>
      <div>&#64;radix-ui/primitives</div>
      <brn-collapsible-content ${id ? `id=${id}` : ''} data-testid='content'>
        <div>&#64;radix-ui/colors</div>
        <div>&#64;stitches/react</div>
      </brn-collapsible-content>
    </brn-collapsible>
    `,
			{
				imports: [BrnCollapsibleComponent, BrnCollapsibleContentComponent, BrnCollapsibleTriggerDirective],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			triggerElement: screen.getByTestId('trigger'),
		};
	};

	type Options = {
		root: HTMLElement;
		trigger: HTMLElement;
		content: HTMLElement;
		id?: string;
	};
	const validateAttributes = async ({ root, trigger, content, id }: Options) => {
		const idMatcher = id ?? expect.stringContaining('brn-collapsible-content');
		expect(root).toBeInTheDocument();
		expect(await axe(root)).toHaveNoViolations();

		expect(trigger).toBeInTheDocument();
		expect(trigger).toHaveAttribute('aria-controls', idMatcher);
		expect(await axe(trigger)).toHaveNoViolations();

		expect(content).toBeInTheDocument();
		expect(content).toHaveAttribute('id', idMatcher);
		expect(await axe(trigger)).toHaveNoViolations();
	};
	const validateOpen = async (id?: string) => {
		const root = await screen.findByTestId('root');
		const trigger = await screen.findByTestId('trigger');
		const content = await screen.findByTestId('content');

		expect(root).toHaveAttribute('data-state', 'open');
		expect(trigger).toHaveAttribute('data-state', 'open');
		expect(trigger).toHaveAttribute('aria-expanded', 'true');
		expect(content).toHaveAttribute('data-state', 'open');

		await validateAttributes({ root, trigger, content, id });
	};
	const validateClosed = async (id?: string) => {
		const root = await screen.findByTestId('root');
		const trigger = await screen.findByTestId('trigger');
		const content = await screen.findByTestId('content');

		expect(root).toHaveAttribute('data-state', 'closed');
		expect(trigger).toHaveAttribute('data-state', 'closed');
		expect(trigger).toHaveAttribute('aria-expanded', 'false');
		expect(content).toHaveAttribute('data-state', 'closed');

		await validateAttributes({ root, trigger, content, id });
	};

	it('not given id on content should create id and set it to aria-described. by default collapsible is closed', async () => {
		await setup();
		await validateClosed();
	});

	it('given id on content should use id and set it to aria-described. by default collapsible is closed', async () => {
		await setup('hello-world');
		await validateClosed('hello-world');
	});

	it('mouse click on element toggles collapsible', async () => {
		const { user, container, triggerElement } = await setup();
		await validateClosed();
		await user.click(triggerElement);
		container.detectChanges();
		await validateOpen();
		await user.click(triggerElement);
		container.detectChanges();
		await validateClosed();
	});

	it('focus with tab and enter toggles collapsible', async () => {
		const { user, container } = await setup();
		await validateClosed();
		await user.keyboard('[Tab][Enter]');
		container.detectChanges();
		await validateOpen();
		await user.keyboard('[Enter]');
		container.detectChanges();
		await validateClosed();
		await user.keyboard('[Enter]');
		container.detectChanges();
		await validateOpen();
	});

	it('focus with tab and space toggles collapsible', async () => {
		const { user, container } = await setup();
		await validateClosed();
		await user.keyboard('[Tab][Space]');
		container.detectChanges();
		await validateOpen();
		await user.keyboard('[Space]');
		container.detectChanges();
		await validateClosed();
		await user.keyboard('[Space]');
		container.detectChanges();
		await validateOpen();
	});

	it('disabled adds correct aria attributes and prevents toggle', async () => {
		const { user, container, triggerElement } = await setup(undefined, true);
		const root = await screen.findByTestId('root');

		expect(root).toHaveAttribute('disabled');
		expect(triggerElement).toHaveAttribute('disabled');

		await validateClosed();
		await user.click(triggerElement);
		container.detectChanges();
		await validateClosed();
		await user.keyboard('[Enter]');
		container.detectChanges();
		await validateClosed();
		await user.keyboard('[Space]');
		container.detectChanges();
		await validateClosed();
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/collapsible/src/lib/brn-collapsible.component.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { ChangeDetectionStrategy, Component, booleanAttribute, input, model, signal } from '@angular/core';

let collapsibleContentIdSequence = 0;

export type BrnCollapsibleState = 'open' | 'closed';

@Component({
	selector: 'brn-collapsible',
	standalone: true,
	host: {
		'[attr.data-state]': 'expanded() ? "open" : "closed"',
		'[attr.disabled]': 'disabled() ? true : undefined',
	},
	template: `
		<ng-content />
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
})
export class BrnCollapsibleComponent {
	public readonly contentId = signal(`brn-collapsible-content-${collapsibleContentIdSequence++}`);

	/**
	 * The expanded or collapsed state of the collapsible component.
	 */
	public readonly expanded = model<boolean>(false);

	/**
	 * The disabled state of the collapsible component.
	 */
	public readonly disabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

	/**
	 * Toggles the expanded state of the collapsible component.
	 */
	public toggle(): void {
		this.expanded.update((expanded) => !expanded);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/menu/README.md
```
# @spartan-ng/brain/menu

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/menu`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/menu/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/menu/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { BrnContextMenuTriggerDirective } from './lib/brn-context-menu-trigger.directive';
import { BrnMenuBarDirective } from './lib/brn-menu-bar.directive';
import { BrnMenuGroupDirective } from './lib/brn-menu-group.directive';
import { BrnMenuItemCheckboxDirective } from './lib/brn-menu-item-checkbox.directive';
import { BrnMenuItemRadioDirective } from './lib/brn-menu-item-radio.directive';
import { BrnMenuItemDirective } from './lib/brn-menu-item.directive';
import { BrnMenuTriggerDirective } from './lib/brn-menu-trigger.directive';
import { BrnMenuDirective } from './lib/brn-menu.directive';

export * from './lib/brn-context-menu-trigger.directive';
export * from './lib/brn-menu-bar.directive';
export * from './lib/brn-menu-group.directive';
export * from './lib/brn-menu-item-checkbox.directive';
export * from './lib/brn-menu-item-radio.directive';
export * from './lib/brn-menu-item.directive';
export * from './lib/brn-menu-trigger.directive';
export * from './lib/brn-menu.directive';

export const BrnMenuItemImports = [
	BrnMenuGroupDirective,
	BrnMenuItemDirective,
	BrnMenuItemRadioDirective,
	BrnMenuItemCheckboxDirective,
] as const;
export const BrnMenuImports = [BrnMenuTriggerDirective, BrnMenuDirective, ...BrnMenuItemImports] as const;
export const BrnMenuBarImports = [...BrnMenuImports, BrnMenuBarDirective] as const;
export const BrnContextMenuImports = [...BrnMenuImports, BrnContextMenuTriggerDirective] as const;

@NgModule({
	imports: [...BrnMenuItemImports],
	exports: [...BrnMenuItemImports],
})
export class BrnMenuItemModule {}

@NgModule({
	imports: [...BrnMenuImports],
	exports: [...BrnMenuImports],
})
export class BrnMenuModule {}

@NgModule({
	imports: [...BrnMenuBarImports],
	exports: [...BrnMenuBarImports],
})
export class BrnMenuBarModule {}

@NgModule({
	imports: [...BrnContextMenuImports],
	exports: [...BrnContextMenuImports],
})
export class BrnContextMenuModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/menu/src/lib/brn-context-menu-trigger.directive.ts
```typescript
import { CdkContextMenuTrigger } from '@angular/cdk/menu';
import { Directive, effect, inject, input, type TemplateRef } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { BrnMenuAlign, getBrnMenuAlign } from './brn-menu-align';

@Directive({
	selector: '[brnCtxMenuTriggerFor]',
	standalone: true,
	hostDirectives: [CdkContextMenuTrigger],
})
export class BrnContextMenuTriggerDirective {
	private readonly _cdkTrigger = inject(CdkContextMenuTrigger, { host: true });
	public brnCtxMenuTriggerFor = input<TemplateRef<unknown> | null>(null);
	public brnCtxMenuTriggerData = input<unknown>(undefined);
	public readonly align = input<BrnMenuAlign>(undefined);

	constructor() {
		// once the trigger opens we wait until the next tick and then grab the last position
		// used to position the menu. we store this in our trigger which the brnMenu directive has
		// access to through DI
		this._cdkTrigger.opened.pipe(takeUntilDestroyed()).subscribe(() =>
			setTimeout(
				() =>
					// eslint-disable-next-line
					((this._cdkTrigger as any)._spartanLastPosition = // eslint-disable-next-line
						(this._cdkTrigger as any).overlayRef._positionStrategy._lastPosition),
			),
		);

		effect(() => (this._cdkTrigger.menuTemplateRef = this.brnCtxMenuTriggerFor()));
		effect(() => (this._cdkTrigger.menuData = this.brnCtxMenuTriggerData()));
		effect(() => {
			const align = this.align();
			if (!align) return;
			this._cdkTrigger.menuPosition = getBrnMenuAlign(align);
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/menu/src/lib/brn-menu-align.ts
```typescript
import { ConnectedPosition } from '@angular/cdk/overlay';

export type BrnMenuAlign = 'start' | 'center' | 'end' | undefined;
export const getBrnMenuAlign = (align: Exclude<BrnMenuAlign, undefined>): ConnectedPosition[] => [
	{
		originX: align,
		originY: 'bottom',
		overlayX: align,
		overlayY: 'top',
	},
	{
		originX: align,
		originY: 'top',
		overlayX: align,
		overlayY: 'bottom',
	},
];

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/menu/src/lib/brn-menu-bar.directive.ts
```typescript
import { CdkMenuBar } from '@angular/cdk/menu';
import { Directive } from '@angular/core';

@Directive({
	selector: '[brnMenuBar]',
	standalone: true,
	hostDirectives: [CdkMenuBar],
})
export class BrnMenuBarDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/menu/src/lib/brn-menu-group.directive.ts
```typescript
import { CdkMenuGroup } from '@angular/cdk/menu';
import { Directive } from '@angular/core';

@Directive({
	selector: '[brnMenuGroup]',
	standalone: true,
	hostDirectives: [CdkMenuGroup],
})
export class BrnMenuGroupDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/menu/src/lib/brn-menu-item-checkbox.directive.ts
```typescript
import { CdkMenuItemCheckbox } from '@angular/cdk/menu';
import { booleanAttribute, Directive, effect, inject, input } from '@angular/core';
import { outputFromObservable } from '@angular/core/rxjs-interop';

@Directive({
	selector: '[brnMenuItemCheckbox]',
	standalone: true,
	hostDirectives: [CdkMenuItemCheckbox],
	host: {
		'[class.checked]': 'checked()',
		'[disabled]': 'disabled()',
	},
})
export class BrnMenuItemCheckboxDirective {
	private readonly _cdkMenuItem = inject(CdkMenuItemCheckbox);
	public readonly checked = input(this._cdkMenuItem.checked, { transform: booleanAttribute });
	public readonly disabled = input(this._cdkMenuItem.disabled, { transform: booleanAttribute });
	public readonly triggered = outputFromObservable(this._cdkMenuItem.triggered);

	constructor() {
		effect(() => (this._cdkMenuItem.disabled = this.disabled()));
		effect(() => (this._cdkMenuItem.checked = this.checked()));
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/menu/src/lib/brn-menu-item-radio.directive.ts
```typescript
import { CdkMenuItemRadio } from '@angular/cdk/menu';
import { booleanAttribute, Directive, effect, inject, input } from '@angular/core';
import { outputFromObservable } from '@angular/core/rxjs-interop';

@Directive({
	selector: '[brnMenuItemRadio]',
	standalone: true,
	hostDirectives: [CdkMenuItemRadio],
	host: {
		'[class.checked]': 'checked()',
		'[disabled]': 'disabled()',
	},
})
export class BrnMenuItemRadioDirective {
	private readonly _cdkMenuItem = inject(CdkMenuItemRadio);
	public readonly checked = input(this._cdkMenuItem.checked, { transform: booleanAttribute });
	public readonly disabled = input(this._cdkMenuItem.disabled, { transform: booleanAttribute });
	public readonly triggered = outputFromObservable(this._cdkMenuItem.triggered);

	constructor() {
		effect(() => (this._cdkMenuItem.disabled = this.disabled()));
		effect(() => (this._cdkMenuItem.checked = this.checked()));
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/menu/src/lib/brn-menu-item.directive.ts
```typescript
import { CdkMenuItem } from '@angular/cdk/menu';
import { booleanAttribute, Directive, effect, inject, input } from '@angular/core';
import { outputFromObservable } from '@angular/core/rxjs-interop';

@Directive({
	selector: '[brnMenuItem]',
	standalone: true,
	hostDirectives: [CdkMenuItem],
	host: {
		'[disabled]': 'disabled()',
	},
})
export class BrnMenuItemDirective {
	private readonly _cdkMenuItem = inject(CdkMenuItem);
	public readonly disabled = input(this._cdkMenuItem.disabled, { transform: booleanAttribute });
	public readonly triggered = outputFromObservable(this._cdkMenuItem.triggered);

	constructor() {
		effect(() => (this._cdkMenuItem.disabled = this.disabled()));
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/menu/src/lib/brn-menu-trigger.directive.ts
```typescript
import { CdkMenuTrigger } from '@angular/cdk/menu';
import { Directive, effect, inject, input } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { BrnMenuAlign, getBrnMenuAlign } from './brn-menu-align';

@Directive({
	selector: '[brnMenuTriggerFor]',
	standalone: true,
	hostDirectives: [
		{
			directive: CdkMenuTrigger,
			inputs: ['cdkMenuTriggerFor: brnMenuTriggerFor', 'cdkMenuTriggerData: brnMenuTriggerData'],
			outputs: ['cdkMenuOpened: brnMenuOpened', 'cdkMenuClosed: brnMenuClosed'],
		},
	],
})
export class BrnMenuTriggerDirective {
	private readonly _cdkTrigger = inject(CdkMenuTrigger, { host: true });
	public readonly align = input<BrnMenuAlign>(undefined);

	constructor() {
		// once the trigger opens we wait until the next tick and then grab the last position
		// used to position the menu. we store this in our trigger which the brnMenu directive has
		// access to through DI
		this._cdkTrigger.opened.pipe(takeUntilDestroyed()).subscribe(() =>
			setTimeout(
				() =>
					// eslint-disable-next-line
					((this._cdkTrigger as any)._spartanLastPosition = // eslint-disable-next-line
						(this._cdkTrigger as any).overlayRef._positionStrategy._lastPosition),
			),
		);

		effect(() => {
			const align = this.align();
			if (!align) return;
			this._cdkTrigger.menuPosition = getBrnMenuAlign(align);
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/menu/src/lib/brn-menu.directive.ts
```typescript
import { CdkMenu } from '@angular/cdk/menu';
import { Directive, inject, signal } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';

@Directive({
	selector: '[brnMenu],[brnSubMenu]',
	standalone: true,
	host: {
		'[attr.data-state]': '_state()',
		'[attr.data-side]': '_side()',
	},
	hostDirectives: [CdkMenu],
})
export class BrnMenuDirective {
	private readonly _host = inject(CdkMenu);

	protected readonly _state = signal('open');
	protected readonly _side = signal('top');

	constructor() {
		this.setSideWithDarkMagic();
		// this is a best effort, but does not seem to work currently
		// TODO: figure out a way for us to know the host is about to be closed. might not be possible with CDK
		this._host.closed.pipe(takeUntilDestroyed()).subscribe(() => this._state.set('closed'));
	}

	private setSideWithDarkMagic() {
		/**
		 * This is an ugly workaround to at least figure out the correct side of where a submenu
		 * will appear and set the attribute to the host accordingly
		 *
		 * First of all we take advantage of the menu stack not being aware of the root
		 * object immediately after it is added. This code executes before the root element is added,
		 * which means the stack is still empty and the peek method returns undefined.
		 */
		const isRoot = this._host.menuStack.peek() === undefined;
		setTimeout(() => {
			// our menu trigger directive leaves the last position used for use immediately after opening
			// we can access it here and determine the correct side.
			// eslint-disable-next-line
			const ps = (this._host as any)._parentTrigger._spartanLastPosition;
			if (!ps) {
				// if we have no last position we default to the most likely option
				// I hate that we have to do this and hope we can revisit soon and improve
				this._side.set(isRoot ? 'top' : 'left');
				return;
			}
			const side = isRoot ? ps.originY : ps.originX === 'end' ? 'right' : 'left';
			this._side.set(side);
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/avatar/README.md
```
# @spartan-ng/brain/avatar

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/avatar`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/avatar/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/avatar/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { BrnAvatarComponent } from './lib/brn-avatar.component';
import { BrnAvatarFallbackDirective } from './lib/fallback';
import { BrnAvatarImageDirective } from './lib/image';

export * from './lib/brn-avatar.component';
export * from './lib/fallback';
export * from './lib/image';
export * from './lib/util';

export const BrnAvatarImports = [BrnAvatarComponent, BrnAvatarFallbackDirective, BrnAvatarImageDirective] as const;

@NgModule({
	imports: [...BrnAvatarImports],
	exports: [...BrnAvatarImports],
})
export class BrnAvatarModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/avatar/src/lib/brn-avatar.component.spec.ts
```typescript
import { Component } from '@angular/core';
import { type ComponentFixture, TestBed } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { BrnAvatarComponent } from './brn-avatar.component';
import { BrnAvatarFallbackDirective } from './fallback/brn-avatar-fallback.directive';
import { BrnAvatarImageDirective } from './image/brn-avatar-image.directive';

@Component({
	selector: 'brn-mock',
	imports: [BrnAvatarImageDirective, BrnAvatarFallbackDirective, BrnAvatarComponent],
	template: `
		<brn-avatar id="empty">
			<p>empty</p>
		</brn-avatar>
		<brn-avatar id="fallbackOnly">
			<span brnAvatarFallback>fallback</span>
		</brn-avatar>
		<brn-avatar id="noSrc">
			<img brnAvatarImage alt="Avatar image" />
			<span brnAvatarFallback>fallback</span>
		</brn-avatar>
		<brn-avatar id="good">
			<img
				brnAvatarImage
				alt="Avatar image"
				src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAANCSURBVEiJtZZPbBtFFMZ/M7ubXdtdb1xSFyeilBapySVU8h8OoFaooFSqiihIVIpQBKci6KEg9Q6H9kovIHoCIVQJJCKE1ENFjnAgcaSGC6rEnxBwA04Tx43t2FnvDAfjkNibxgHxnWb2e/u992bee7tCa00YFsffekFY+nUzFtjW0LrvjRXrCDIAaPLlW0nHL0SsZtVoaF98mLrx3pdhOqLtYPHChahZcYYO7KvPFxvRl5XPp1sN3adWiD1ZAqD6XYK1b/dvE5IWryTt2udLFedwc1+9kLp+vbbpoDh+6TklxBeAi9TL0taeWpdmZzQDry0AcO+jQ12RyohqqoYoo8RDwJrU+qXkjWtfi8Xxt58BdQuwQs9qC/afLwCw8tnQbqYAPsgxE1S6F3EAIXux2oQFKm0ihMsOF71dHYx+f3NND68ghCu1YIoePPQN1pGRABkJ6Bus96CutRZMydTl+TvuiRW1m3n0eDl0vRPcEysqdXn+jsQPsrHMquGeXEaY4Yk4wxWcY5V/9scqOMOVUFthatyTy8QyqwZ+kDURKoMWxNKr2EeqVKcTNOajqKoBgOE28U4tdQl5p5bwCw7BWquaZSzAPlwjlithJtp3pTImSqQRrb2Z8PHGigD4RZuNX6JYj6wj7O4TFLbCO/Mn/m8R+h6rYSUb3ekokRY6f/YukArN979jcW+V/S8g0eT/N3VN3kTqWbQ428m9/8k0P/1aIhF36PccEl6EhOcAUCrXKZXXWS3XKd2vc/TRBG9O5ELC17MmWubD2nKhUKZa26Ba2+D3P+4/MNCFwg59oWVeYhkzgN/JDR8deKBoD7Y+ljEjGZ0sosXVTvbc6RHirr2reNy1OXd6pJsQ+gqjk8VWFYmHrwBzW/n+uMPFiRwHB2I7ih8ciHFxIkd/3Omk5tCDV1t+2nNu5sxxpDFNx+huNhVT3/zMDz8usXC3ddaHBj1GHj/As08fwTS7Kt1HBTmyN29vdwAw+/wbwLVOJ3uAD1wi/dUH7Qei66PfyuRj4Ik9is+hglfbkbfR3cnZm7chlUWLdwmprtCohX4HUtlOcQjLYCu+fzGJH2QRKvP3UNz8bWk1qMxjGTOMThZ3kvgLI5AzFfo379UAAAAASUVORK5CYII="
			/>
			<span brnAvatarFallback>fallback</span>
		</brn-avatar>
	`,
	standalone: true,
})
class MockComponent {}

describe('BrnAvatarComponent', () => {
	let component: MockComponent;
	let fixture: ComponentFixture<MockComponent>;

	beforeEach(() => {
		fixture = TestBed.createComponent(MockComponent);
		component = fixture.componentInstance;
		fixture.autoDetectChanges();
	});
	it('should compile', () => {
		expect(component).toBeTruthy();
	});

	it('should render the fallback when no image is provided', () => {
		const fallback = fixture.nativeElement.querySelector('#fallbackOnly span');
		expect(fallback.textContent).toEqual('fallback');
	});

	it('should not render anything when no image or fallback is provided', () => {
		const empty = fixture.nativeElement.querySelector('#empty p');
		expect(empty).toBeFalsy();
	});

	it('should render the fallback when provided and image with no src', () => {
		const fallback = fixture.nativeElement.querySelector('#noSrc span');
		expect(fallback.textContent).toEqual('fallback');
	});

	it('should not render the fallback, but rather the image when provided with a valid src', () => {
		// delay test to allow for image to resolve
		setTimeout(() => {
			const img = fixture.debugElement.query(By.css('#good img'));
			expect(img).toBeTruthy();
			const fallback = fixture.nativeElement.querySelector('#good span');
			expect(fallback).toBeFalsy();
		});
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/avatar/src/lib/brn-avatar.component.ts
```typescript
import { ChangeDetectionStrategy, Component, ViewEncapsulation, contentChild } from '@angular/core';
import { BrnAvatarImageDirective } from './image';

@Component({
	selector: 'brn-avatar',
	standalone: true,
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	template: `
		@if (image()?.canShow()) {
			<ng-content select="[brnAvatarImage]" />
		} @else {
			<ng-content select="[brnAvatarFallback]" />
		}
	`,
})
export class BrnAvatarComponent {
	protected readonly image = contentChild(BrnAvatarImageDirective);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/avatar/src/lib/util/hex-color-for.spec.ts
```typescript
import { faker } from '@faker-js/faker';
import { hexColorFor } from './hex-color-for';

describe('hexColorFor', () => {
	it('should return a text color of white and a pink-ish background for John Doe', () => {
		const generated = hexColorFor('John Doe');
		expect(generated).toBe('#a55c80');
	});

	it('should return a text color of white and a blue-ish background for Jane Doe', () => {
		const generated = hexColorFor('Jane Doe');
		expect(generated).toBe('#485fa7');
	});

	it('should return different colors for different names', () => {
		expect(hexColorFor(faker.person.fullName())).not.toBe(hexColorFor(faker.person.fullName()));
	});

	it('should return the same style when given the same name', () => {
		const name = faker.person.fullName();
		expect(hexColorFor(name)).toBe(hexColorFor(name));
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/avatar/src/lib/util/hex-color-for.ts
```typescript
function hashString(str: string) {
	let h;
	for (let i = 0; i < str.length; i++) h = (Math.imul(31, h || 0) + str.charCodeAt(i)) | 0;

	return h || 0;
}

function hashManyTimes(times: number, str: string) {
	let h = hashString(str);

	for (let i = 0; i < times; i++) h = hashString(String(h));

	return h;
}

export function hexColorFor(str: string) {
	const hash = str.length <= 2 ? hashManyTimes(5, str) : hashString(str);

	let color = '#';

	for (let i = 0; i < 3; i += 1) {
		const value = (hash >> (i * 8)) & 0xff;
		color += `00${value.toString(16)}`.slice(-2);
	}

	return color;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/avatar/src/lib/util/index.ts
```typescript
export * from './hex-color-for';
export * from './initials.pipe';
export * from './is-bright';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/avatar/src/lib/util/initials.pipe.spec.ts
```typescript
import { faker } from '@faker-js/faker';
import { InitialsPipe } from './initials.pipe';

describe('InitialsPipe', () => {
	const pipe = new InitialsPipe();

	it('should compile', () => {
		expect(pipe).toBeTruthy();
	});

	it('should return an empty string, when an empty string is provided', () => {
		expect(pipe.transform('')).toBe('');
		expect(pipe.transform(' ')).toBe('');
	});

	it.skip('should return the uppercased initials of a provided name', () => {
		const name = 'John Doe';
		const otherName = 'Mary Ann Smith';
		const randomName = faker.person.fullName();

		expect(pipe.transform(name)).toBe('JD');
		expect(pipe.transform(otherName)).toBe('MS');
		expect(pipe.transform(randomName)).toBe(
			`${randomName.charAt(0).toLocaleUpperCase()}${randomName.charAt(randomName.indexOf(' ') + 1).toLocaleUpperCase()}`,
		);
	});

	it('should not capitalize the initials, when the capitalize flag is set to false', () => {
		const name = 'john Doe';
		const otherName = 'mary ann smith';
		const randomName = `${faker.person.firstName()} ${faker.person.lastName()}`;

		expect(pipe.transform(name, false)).toBe('jD');
		expect(pipe.transform(otherName, false)).toBe('ms');
		expect(pipe.transform(randomName, false)).toBe(
			`${randomName.charAt(0)}${randomName.charAt(randomName.lastIndexOf(' ') + 1)}`,
		);
	});

	it('should return all initials when the firstAndLastOnly flag is set to false', () => {
		const name = 'Mary Ann       Smith';

		expect(pipe.transform(name, true, false)).toBe('MAS');
	});

	it('should split the name by the provided delimiter', () => {
		const name = 'Mary:Ann:Smith: ';

		expect(pipe.transform(name, true, true, ':')).toBe('MS');
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/avatar/src/lib/util/initials.pipe.ts
```typescript
import { Pipe, type PipeTransform } from '@angular/core';

const toInitial =
	(capitalize = true) =>
	(word: string) => {
		const initial = word.charAt(0);
		return capitalize ? initial.toLocaleUpperCase() : initial;
	};

const firstAndLast = (initials: string[]) => `${initials[0]}${initials[initials.length - 1]}`;

@Pipe({
	name: 'initials',
	standalone: true,
})
export class InitialsPipe implements PipeTransform {
	transform(name: string, capitalize = true, firstAndLastOnly = true, delimiter = ' '): string {
		if (!name) return '';

		const initials = name.trim().split(delimiter).filter(Boolean).map(toInitial(capitalize));

		if (firstAndLastOnly && initials.length > 1) return firstAndLast(initials);

		return initials.join('');
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/avatar/src/lib/util/is-bright.spec.ts
```typescript
import { isBright } from './is-bright';

describe('isBright', () => {
	it('should return true for white hex code', () => {
		expect(isBright('#ffffff')).toBe(true);
	});

	it('should return false for black hex code', () => {
		expect(isBright('#000000')).toBe(false);
	});

	it('should return true for a light hex code', () => {
		expect(isBright('#e394bb')).toBe(true);
	});

	it('should return false for a dark hex code', () => {
		expect(isBright('#485fa7')).toBe(false);
	});

	it('should support hex color shorthand, with our without hash & ignore capitalization', () => {
		expect(isBright('ffffff')).toBe(true);
		expect(isBright('#fff')).toBe(true);
		expect(isBright('fff')).toBe(true);
		expect(isBright('#FFF')).toBe(true);
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/avatar/src/lib/util/is-bright.ts
```typescript
const isShortHand = (hex: string) => hex.length === 3;

const cleanup = (hex: string) => {
	const noHash = hex.replace('#', '').trim().toLowerCase();

	if (!isShortHand(noHash)) return noHash;

	return noHash
		.split('')
		.map((char) => char + char)
		.join('');
};

export const isBright = (hex: string) => Number.parseInt(cleanup(hex), 16) > 0xffffff / 1.25;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/avatar/src/lib/fallback/brn-avatar-fallback.directive.spec.ts
```typescript
import { Component, PLATFORM_ID } from '@angular/core';
import { type ComponentFixture, TestBed } from '@angular/core/testing';
import { BrnAvatarFallbackDirective } from './brn-avatar-fallback.directive';

@Component({
	selector: 'brn-mock',
	standalone: true,
	imports: [BrnAvatarFallbackDirective],
	template: `
		<span *brnAvatarFallback>fallback</span>
		<span brnAvatarFallback>fallback2</span>
	`,
})
class BrnMockComponent {}

describe('BrnAvatarFallbackDirective', () => {
	let component: BrnMockComponent;
	let fixture: ComponentFixture<BrnMockComponent>;

	beforeEach(() => {
		fixture = TestBed.overrideProvider(PLATFORM_ID, { useValue: 'browser' }).createComponent(BrnMockComponent);
		component = fixture.componentInstance;
	});

	it('should compile', () => {
		expect(component).toBeTruthy();
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/avatar/src/lib/fallback/brn-avatar-fallback.directive.ts
```typescript
import { BooleanInput } from '@angular/cdk/coercion';
import { Directive, ElementRef, booleanAttribute, inject, input } from '@angular/core';
import type { ClassValue } from 'clsx';

@Directive({
	selector: '[brnAvatarFallback]',
	standalone: true,
	exportAs: 'avatarFallback',
})
export class BrnAvatarFallbackDirective {
	private readonly _element = inject(ElementRef).nativeElement;

	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly autoColor = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

	getTextContent(): string {
		return this._element.textContent;
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/avatar/src/lib/fallback/index.ts
```typescript
export * from './brn-avatar-fallback.directive';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/avatar/src/lib/image/brn-avatar-image.directive.spec.ts
```typescript
import { Component } from '@angular/core';
import { type ComponentFixture, TestBed } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { BrnAvatarImageDirective } from './brn-avatar-image.directive';

@Component({
	selector: 'brn-mock',
	standalone: true,
	imports: [BrnAvatarImageDirective],
	template: `
		<div id="bad">
			<img brnAvatarImage #bad="avatarImage" alt="Avatar image" />
			<span>{{ bad.canShow() }}</span>
		</div>
		<div id="unloaded">
			<img
				src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAANCSURBVEiJtZZPbBtFFMZ/M7ubXdtdb1xSFyeilBapySVU8h8OoFaooFSqiihIVIpQBKci6KEg9Q6H9kovIHoCIVQJJCKE1ENFjnAgcaSGC6rEnxBwA04Tx43t2FnvDAfjkNibxgHxnWb2e/u992bee7tCa00YFsffekFY+nUzFtjW0LrvjRXrCDIAaPLlW0nHL0SsZtVoaF98mLrx3pdhOqLtYPHChahZcYYO7KvPFxvRl5XPp1sN3adWiD1ZAqD6XYK1b/dvE5IWryTt2udLFedwc1+9kLp+vbbpoDh+6TklxBeAi9TL0taeWpdmZzQDry0AcO+jQ12RyohqqoYoo8RDwJrU+qXkjWtfi8Xxt58BdQuwQs9qC/afLwCw8tnQbqYAPsgxE1S6F3EAIXux2oQFKm0ihMsOF71dHYx+f3NND68ghCu1YIoePPQN1pGRABkJ6Bus96CutRZMydTl+TvuiRW1m3n0eDl0vRPcEysqdXn+jsQPsrHMquGeXEaY4Yk4wxWcY5V/9scqOMOVUFthatyTy8QyqwZ+kDURKoMWxNKr2EeqVKcTNOajqKoBgOE28U4tdQl5p5bwCw7BWquaZSzAPlwjlithJtp3pTImSqQRrb2Z8PHGigD4RZuNX6JYj6wj7O4TFLbCO/Mn/m8R+h6rYSUb3ekokRY6f/YukArN979jcW+V/S8g0eT/N3VN3kTqWbQ428m9/8k0P/1aIhF36PccEl6EhOcAUCrXKZXXWS3XKd2vc/TRBG9O5ELC17MmWubD2nKhUKZa26Ba2+D3P+4/MNCFwg59oWVeYhkzgN/JDR8deKBoD7Y+ljEjGZ0sosXVTvbc6RHirr2reNy1OXd6pJsQ+gqjk8VWFYmHrwBzW/n+uMPFiRwHB2I7ih8ciHFxIkd/3Omk5tCDV1t+2nNu5sxxpDFNx+huNhVT3/zMDz8usXC3ddaHBj1GHj/As08fwTS7Kt1HBTmyN29vdwAw+/wbwLVOJ3uAD1wi/dUH7Qei66PfyuRj4Ik9is+hglfbkbfR3cnZm7chlUWLdwmprtCohX4HUtlOcQjLYCu+fzGJH2QRKvP3UNz8bWk1qMxjGTOMThZ3kvgLI5AzFfo379UAAAAASUVORK5CYII="
				brnAvatarImage
				alt="Avatar image"
				#unloaded="avatarImage"
			/>
			<span>{{ unloaded.canShow() }}</span>
		</div>
		<div id="loaded">
			<img
				src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAANCSURBVEiJtZZPbBtFFMZ/M7ubXdtdb1xSFyeilBapySVU8h8OoFaooFSqiihIVIpQBKci6KEg9Q6H9kovIHoCIVQJJCKE1ENFjnAgcaSGC6rEnxBwA04Tx43t2FnvDAfjkNibxgHxnWb2e/u992bee7tCa00YFsffekFY+nUzFtjW0LrvjRXrCDIAaPLlW0nHL0SsZtVoaF98mLrx3pdhOqLtYPHChahZcYYO7KvPFxvRl5XPp1sN3adWiD1ZAqD6XYK1b/dvE5IWryTt2udLFedwc1+9kLp+vbbpoDh+6TklxBeAi9TL0taeWpdmZzQDry0AcO+jQ12RyohqqoYoo8RDwJrU+qXkjWtfi8Xxt58BdQuwQs9qC/afLwCw8tnQbqYAPsgxE1S6F3EAIXux2oQFKm0ihMsOF71dHYx+f3NND68ghCu1YIoePPQN1pGRABkJ6Bus96CutRZMydTl+TvuiRW1m3n0eDl0vRPcEysqdXn+jsQPsrHMquGeXEaY4Yk4wxWcY5V/9scqOMOVUFthatyTy8QyqwZ+kDURKoMWxNKr2EeqVKcTNOajqKoBgOE28U4tdQl5p5bwCw7BWquaZSzAPlwjlithJtp3pTImSqQRrb2Z8PHGigD4RZuNX6JYj6wj7O4TFLbCO/Mn/m8R+h6rYSUb3ekokRY6f/YukArN979jcW+V/S8g0eT/N3VN3kTqWbQ428m9/8k0P/1aIhF36PccEl6EhOcAUCrXKZXXWS3XKd2vc/TRBG9O5ELC17MmWubD2nKhUKZa26Ba2+D3P+4/MNCFwg59oWVeYhkzgN/JDR8deKBoD7Y+ljEjGZ0sosXVTvbc6RHirr2reNy1OXd6pJsQ+gqjk8VWFYmHrwBzW/n+uMPFiRwHB2I7ih8ciHFxIkd/3Omk5tCDV1t+2nNu5sxxpDFNx+huNhVT3/zMDz8usXC3ddaHBj1GHj/As08fwTS7Kt1HBTmyN29vdwAw+/wbwLVOJ3uAD1wi/dUH7Qei66PfyuRj4Ik9is+hglfbkbfR3cnZm7chlUWLdwmprtCohX4HUtlOcQjLYCu+fzGJH2QRKvP3UNz8bWk1qMxjGTOMThZ3kvgLI5AzFfo379UAAAAASUVORK5CYII="
				brnAvatarImage
				alt="Avatar image"
				#good="avatarImage"
			/>
			<span>{{ good.canShow() }}</span>
		</div>
	`,
})
class BrnMockComponent {}

describe('BrnAvatarImageDirective', () => {
	let component: BrnMockComponent;
	let fixture: ComponentFixture<BrnMockComponent>;

	beforeEach(() => {
		fixture = TestBed.createComponent(BrnMockComponent);
		component = fixture.componentInstance;
	});

	it('should compile', () => {
		expect(component).toBeTruthy();
	});

	it('should return false when image has no src', () => {
		fixture.detectChanges();
		const bad = fixture.nativeElement.querySelector('#bad');
		expect(bad.querySelector('span').textContent).toEqual('false');
	});

	it('should return false when image has a valid src but isnt loaded', async () => {
		fixture.detectChanges();
		await fixture.whenRenderingDone();
		const unloaded = fixture.nativeElement.querySelector('#unloaded');
		expect(unloaded.querySelector('span').textContent).toEqual('false');
	});

	it('should return true when the image is loaded without error', async () => {
		fixture.debugElement.query(By.css('#loaded img')).triggerEventHandler('load', null);
		fixture.detectChanges();
		const unloaded = fixture.nativeElement.querySelector('#loaded');
		expect(unloaded.querySelector('span').textContent).toEqual('true');
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/avatar/src/lib/image/brn-avatar-image.directive.ts
```typescript
import { Directive, HostListener, computed, signal } from '@angular/core';

@Directive({
	selector: 'img[brnAvatarImage]',
	standalone: true,
	exportAs: 'avatarImage',
})
export class BrnAvatarImageDirective {
	private readonly _loaded = signal(false);

	@HostListener('error')
	private onError() {
		this._loaded.set(false);
	}

	@HostListener('load')
	private onLoad() {
		this._loaded.set(true);
	}

	public canShow = computed(() => this._loaded());
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/avatar/src/lib/image/index.ts
```typescript
export * from './brn-avatar-image.directive';

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/switch/README.md
```
# @spartan-ng/brain/switch

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/switch`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/switch/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/switch/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { BrnSwitchThumbComponent } from './lib/brn-switch-thumb.component';
import { BrnSwitchComponent } from './lib/brn-switch.component';

export * from './lib/brn-switch-thumb.component';
export * from './lib/brn-switch.component';

export const BrnSwitchImports = [BrnSwitchComponent, BrnSwitchThumbComponent] as const;

@NgModule({
	imports: [...BrnSwitchImports],
	exports: [...BrnSwitchImports],
})
export class BrnSwitchModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/switch/src/lib/brn-switch-ng-model.spec.ts
```typescript
import { render, screen } from '@testing-library/angular';
import userEvent from '@testing-library/user-event';

import { Component, Input } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { BrnSwitchThumbComponent } from './brn-switch-thumb.component';
import { BrnSwitchComponent } from './brn-switch.component';

@Component({
	selector: 'brn-switch-ng-model',
	template: `
		<label>
			Airplane mode is: {{ airplaneMode ? 'on' : 'off' }}
			<brn-switch [disabled]="disabled" [(ngModel)]="airplaneMode">
				<brn-switch-thumb />
			</brn-switch>
		</label>
	`,
	imports: [BrnSwitchComponent, BrnSwitchThumbComponent, FormsModule],
})
export class BrnSwitchNgModelSpecComponent {
	@Input()
	public disabled = false;
	@Input()
	public airplaneMode = false;
}

describe('BrnSwitchComponentNgModelIntegration', () => {
	const setup = async (airplaneMode = false, disabled = false) => {
		const container = await render(BrnSwitchNgModelSpecComponent, {
			componentInputs: {
				disabled,
				airplaneMode,
			},
		});
		const labelMatch = airplaneMode ? /airplane mode is: on/i : /airplane mode is: off/i;
		return {
			user: userEvent.setup(),
			container,
			switchElement: screen.getByLabelText(labelMatch),
			labelElement: screen.getByText(labelMatch),
		};
	};

	it('click should toggle value correctly', async () => {
		const { labelElement, user, container } = await setup();
		expect(labelElement).toBeInTheDocument();
		await user.click(labelElement);
		expect(await screen.findByRole('switch')).toHaveAttribute('value', 'on');
		expect(container.fixture.componentInstance.airplaneMode).toBe(true);
	});

	it('should set input as default correctly and click should toggle then', async () => {
		const { labelElement, user, container } = await setup(true);

		await user.click(labelElement);
		expect(await screen.findByRole('switch')).toHaveAttribute('value', 'off');
		expect(container.fixture.componentInstance.airplaneMode).toBe(false);

		await user.click(labelElement);
		expect(await screen.findByRole('switch')).toHaveAttribute('value', 'on');
		expect(container.fixture.componentInstance.airplaneMode).toBe(true);
	});

	it('should set input as default correctly and enter should toggle then', async () => {
		const { user, container } = await setup(true);

		await user.keyboard('[Tab][Enter]');
		expect(container.fixture.componentInstance.airplaneMode).toBe(false);

		await user.keyboard('[Enter]');
		expect(container.fixture.componentInstance.airplaneMode).toBe(true);
	});

	it('should do nothing when disabled', async () => {
		const { labelElement, user, container } = await setup(false, true);

		await user.click(labelElement);
		expect(await screen.findByRole('switch')).toHaveAttribute('value', 'off');
		expect(container.fixture.componentInstance.airplaneMode).toBe(false);

		await user.click(labelElement);
		expect(await screen.findByRole('switch')).toHaveAttribute('value', 'off');
		expect(container.fixture.componentInstance.airplaneMode).toBe(false);
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/switch/src/lib/brn-switch-thumb.component.ts
```typescript
import { Component } from '@angular/core';

@Component({
	selector: 'brn-switch-thumb',
	template: '',
	host: {
		role: 'presentation',
		'(click)': '$event.preventDefault()',
	},
})
export class BrnSwitchThumbComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/switch/src/lib/brn-switch.component.spec.ts
```typescript
import { render, screen } from '@testing-library/angular';
import userEvent from '@testing-library/user-event';
import { axe } from 'jest-axe';
import { BrnSwitchThumbComponent } from './brn-switch-thumb.component';
import { BrnSwitchComponent } from './brn-switch.component';

describe('BrnSwitchComponent', () => {
	const setup = async () => {
		const container = await render(
			`
     <brn-switch id='switchId' name='switchName' data-testid='brnSwitch' aria-label='switch'>
             <brn-switch-thumb />
      </brn-switch>
    `,
			{
				imports: [BrnSwitchComponent, BrnSwitchThumbComponent],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			containerElement: screen.getByLabelText('switch'),
		};
	};

	const setupInsideLabel = async () => {
		const container = await render(
			`
     <label>
     Switch Inside Label
     <brn-switch id='switchId' data-testid='brnSwitch' name='switchName'>
             <brn-switch-thumb />
      </brn-switch>
      </label>
    `,
			{
				imports: [BrnSwitchComponent, BrnSwitchThumbComponent],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			containerElement: screen.getByLabelText(/switch inside label/i),
			labelElement: screen.getByText(/switch inside label/i),
		};
	};

	const setupOutsideLabelWithAriaLabelledBy = async () => {
		const container = await render(
			`
     <!-- need for because arialabelledby only provides accessible name -->
     <label id='labelId' for='switchId'>
     Switch Outside Label with ariaLabelledBy
     </label>
     <brn-switch id='switchId' name='switchName' data-testid='brnSwitch' aria-labelledby='labelId'>
             <brn-switch-thumb />
      </brn-switch>
    `,
			{
				imports: [BrnSwitchComponent, BrnSwitchThumbComponent],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			containerElement: screen.getByLabelText(/switch outside label with arialabelledby/i),
			labelElement: screen.getByText(/switch outside label with arialabelledby/i),
		};
	};

	const setupOutsideLabelWithForAndId = async () => {
		const container = await render(
			`
     <label for='switchId'>
     Switch Outside Label with id
     </label>
     <brn-switch id='switchId' name='switchName' data-testid='brnSwitch'>
             <brn-switch-thumb />
      </brn-switch>
    `,
			{
				imports: [BrnSwitchComponent, BrnSwitchThumbComponent],
			},
		);
		return {
			user: userEvent.setup(),
			container,
			containerElement: screen.getByLabelText(/switch outside label with id/i),
			labelElement: screen.getByText(/switch outside label with id/i),
		};
	};

	type Options = Partial<{ focus: boolean; focusVisible: boolean; disabled: boolean }>;

	const validateAttributes = async (
		switchElement: HTMLElement,
		containerElement: HTMLElement,
		shouldBeChecked: boolean,
		opts?: Options,
	) => {
		expect(switchElement).toBeInTheDocument();
		expect(switchElement).toHaveAttribute('type', 'button');
		expect(switchElement).toHaveAttribute('id', 'switchId');
		expect(switchElement).toHaveAttribute('name', 'switchName');
		expect(await axe(switchElement)).toHaveNoViolations();

		expect(containerElement).toHaveAttribute('id', 'switchId-switch');
		expect(containerElement).toHaveAttribute('name', 'switchName-switch');
		expect(containerElement).toHaveAttribute('data-state', shouldBeChecked ? 'checked' : 'unchecked');
		expect(containerElement).toHaveAttribute('data-disabled', `${!!opts?.disabled}`);
		expect(containerElement).toHaveAttribute('data-focus', `${!!opts?.focus}`);
		expect(containerElement).toHaveAttribute('data-focus-visible', `${!!opts?.focusVisible}`);
		expect(await axe(containerElement)).toHaveNoViolations();
	};
	const validateSwitchOn = async (opts?: Options) => {
		const switchElement = await screen.findByRole('switch');
		const containerElement = await screen.findByTestId('brnSwitch');

		await validateAttributes(switchElement, containerElement, true, opts);
	};
	const validateSwitchOff = async (opts?: Options) => {
		const switchElement = await screen.findByRole('switch');
		const containerElement = await screen.findByTestId('brnSwitch');

		await validateAttributes(switchElement, containerElement, false, opts);
	};

	describe('with aria-label', () => {
		it('unchecked by default', async () => {
			await setup();
			await validateSwitchOff();
		});
		it('mouse click on element toggles', async () => {
			const { user, containerElement } = await setup();
			await validateSwitchOff();
			await user.click(containerElement);
			await validateSwitchOn({ focus: true });
			await user.click(containerElement);
			await validateSwitchOff({ focus: true });
		});
		it('focus with tab and enter toggles', async () => {
			const { user } = await setup();
			const options = { focus: true, focusVisible: true };
			await validateSwitchOff();
			await user.keyboard('[Tab][Enter]');
			await validateSwitchOn(options);
			await user.keyboard('[Enter]');
			await validateSwitchOff(options);
			await user.keyboard('[Enter]');
			await validateSwitchOn(options);
		});
		it('focus with tab and space toggles', async () => {
			const { user } = await setup();
			const options = { focus: true, focusVisible: true };
			await validateSwitchOff();
			await user.keyboard('[Tab][Space]');
			await validateSwitchOn(options);
			await user.keyboard('[Space]');
			await validateSwitchOff(options);
			await user.keyboard('[Space]');
			await validateSwitchOn(options);
		});
	});

	describe('inside <label>', () => {
		it('unchecked by default', async () => {
			await setupInsideLabel();
			await validateSwitchOff();
		});
		it('mouse click on element toggles', async () => {
			const { user, labelElement } = await setupInsideLabel();
			await validateSwitchOff();
			await user.click(labelElement);
			await validateSwitchOn({ focus: true });
			await user.click(labelElement);
			await validateSwitchOff({ focus: true });
		});
		it('focus with tab and enter toggles', async () => {
			const { user } = await setupInsideLabel();
			const options = { focus: true, focusVisible: true };
			await validateSwitchOff();
			await user.keyboard('[Tab][Enter]');
			await validateSwitchOn(options);
			await user.keyboard('[Enter]');
			await validateSwitchOff(options);
			await user.keyboard('[Enter]');
			await validateSwitchOn(options);
		});
		it('focus with tab and space toggles', async () => {
			const { user } = await setupInsideLabel();
			const options = { focus: true, focusVisible: true };
			await validateSwitchOff();
			await user.keyboard('[Tab][Space]');
			await validateSwitchOn(options);
			await user.keyboard('[Space]');
			await validateSwitchOff(options);
			await user.keyboard('[Space]');
			await validateSwitchOn(options);
		});
	});

	describe('outside <label> with aria-labelledby', () => {
		it('unchecked by default', async () => {
			await setupOutsideLabelWithAriaLabelledBy();
			await validateSwitchOff();
		});
		it('mouse click on element toggles', async () => {
			const { user, labelElement } = await setupOutsideLabelWithAriaLabelledBy();
			await validateSwitchOff();
			await user.click(labelElement);
			await validateSwitchOn({ focus: true });
			await user.click(labelElement);
			await validateSwitchOff({ focus: true });
		});
		it('focus with tab and enter toggles', async () => {
			const { user } = await setupOutsideLabelWithAriaLabelledBy();
			const options = { focus: true, focusVisible: true };
			await validateSwitchOff();
			await user.keyboard('[Tab][Enter]');
			await validateSwitchOn(options);
			await user.keyboard('[Enter]');
			await validateSwitchOff(options);
			await user.keyboard('[Enter]');
			await validateSwitchOn(options);
		});
		it('focus with tab and space toggles', async () => {
			const { user } = await setupOutsideLabelWithAriaLabelledBy();
			const options = { focus: true, focusVisible: true };
			await validateSwitchOff();
			await user.keyboard('[Tab][Space]');
			await validateSwitchOn(options);
			await user.keyboard('[Space]');
			await validateSwitchOff(options);
			await user.keyboard('[Space]');
			await validateSwitchOn(options);
		});
	});

	describe('outside <label> with for and id', () => {
		it('unchecked by default', async () => {
			await setupOutsideLabelWithForAndId();
			await validateSwitchOff();
		});
		it('mouse click on element toggles', async () => {
			const { user, labelElement } = await setupOutsideLabelWithForAndId();
			await validateSwitchOff();
			await user.click(labelElement);
			await validateSwitchOn({ focus: true });
			await user.click(labelElement);
			await validateSwitchOff({ focus: true });
		});
		it('focus with tab and enter toggles', async () => {
			const { user } = await setupOutsideLabelWithForAndId();
			const options = { focus: true, focusVisible: true };
			await validateSwitchOff();
			await user.keyboard('[Tab][Enter]');
			await validateSwitchOn(options);
			await user.keyboard('[Enter]');
			await validateSwitchOff(options);
			await user.keyboard('[Enter]');
			await validateSwitchOn(options);
		});
		it('focus with tab and space toggles', async () => {
			const { user } = await setupOutsideLabelWithForAndId();
			const options = { focus: true, focusVisible: true };
			await validateSwitchOff();
			await user.keyboard('[Tab][Space]');
			await validateSwitchOn(options);
			await user.keyboard('[Space]');
			await validateSwitchOff(options);
			await user.keyboard('[Space]');
			await validateSwitchOn(options);
		});
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/switch/src/lib/brn-switch.component.ts
```typescript
import { FocusMonitor } from '@angular/cdk/a11y';
import { BooleanInput } from '@angular/cdk/coercion';
import { DOCUMENT, isPlatformBrowser } from '@angular/common';
import {
	type AfterContentInit,
	booleanAttribute,
	ChangeDetectionStrategy,
	ChangeDetectorRef,
	Component,
	computed,
	DestroyRef,
	effect,
	ElementRef,
	forwardRef,
	inject,
	input,
	linkedSignal,
	model,
	type OnDestroy,
	output,
	PLATFORM_ID,
	Renderer2,
	signal,
	viewChild,
	ViewEncapsulation,
} from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { ChangeFn, TouchFn } from '@spartan-ng/brain/forms';

export const BRN_SWITCH_VALUE_ACCESSOR = {
	provide: NG_VALUE_ACCESSOR,
	useExisting: forwardRef(() => BrnSwitchComponent),
	multi: true,
};

const CONTAINER_POST_FIX = '-switch';

let uniqueIdCounter = 0;

@Component({
	selector: 'brn-switch',
	template: `
		<button
			#switch
			role="switch"
			type="button"
			[class]="class()"
			[id]="getSwitchButtonId(state().id) ?? ''"
			[name]="getSwitchButtonId(state().name) ?? ''"
			[value]="checked() ? 'on' : 'off'"
			[attr.aria-checked]="checked()"
			[attr.aria-label]="ariaLabel() || null"
			[attr.aria-labelledby]="mutableAriaLabelledby() || null"
			[attr.aria-describedby]="ariaDescribedby() || null"
			[attr.data-state]="checked() ? 'checked' : 'unchecked'"
			[attr.data-focus-visible]="focusVisible()"
			[attr.data-focus]="focused()"
			[attr.data-disabled]="state().disabled()"
			[disabled]="state().disabled()"
			[tabIndex]="tabIndex()"
			(click)="$event.preventDefault(); toggle()"
		>
			<ng-content select="brn-switch-thumb" />
		</button>
	`,
	host: {
		'[style]': '{display: "contents"}',
		'[attr.id]': 'state().id',
		'[attr.name]': 'state().name',
		'[attr.aria-labelledby]': 'null',
		'[attr.aria-label]': 'null',
		'[attr.aria-describedby]': 'null',
		'[attr.data-state]': 'checked() ? "checked" : "unchecked"',
		'[attr.data-focus-visible]': 'focusVisible()',
		'[attr.data-focus]': 'focused()',
		'[attr.data-disabled]': 'state().disabled()',
	},
	providers: [BRN_SWITCH_VALUE_ACCESSOR],
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class BrnSwitchComponent implements AfterContentInit, OnDestroy {
	private readonly _destroyRef = inject(DestroyRef);
	private readonly _renderer = inject(Renderer2);
	private readonly _isBrowser = isPlatformBrowser(inject(PLATFORM_ID));
	private readonly _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);
	private readonly _focusMonitor = inject(FocusMonitor);
	private readonly _cdr = inject(ChangeDetectorRef);
	private readonly _document = inject(DOCUMENT);

	protected readonly focusVisible = signal(false);
	protected readonly focused = signal(false);

	/**
	 * Whether the switch is checked.
	 * Can be bound with [(checked)]
	 */
	public readonly checked = model<boolean>(false);

	/**
	 * Sets the ID on the switch.
	 * When provided, the inner button gets this ID without the '-switch' suffix.
	 */
	public readonly id = input<string | null>(uniqueIdCounter++ + '');

	/**
	 * Sets the name on the switch.
	 * When provided, the inner button gets this name without a '-switch' suffix.
	 */
	public readonly name = input<string | null>(null);

	/**
	 * Sets class set on the inner button
	 */
	public readonly class = input<string | null>(null);

	/**
	 * Sets the aria-label attribute for accessibility.
	 */
	public readonly ariaLabel = input<string | null>(null, { alias: 'aria-label' });

	/**
	 * Sets the aria-labelledby attribute for accessibility.
	 */
	public readonly ariaLabelledby = input<string | null>(null, { alias: 'aria-labelledby' });
	public readonly mutableAriaLabelledby = linkedSignal(() => this.ariaLabelledby());

	/**
	 * Sets the aria-describedby attribute for accessibility.
	 */
	public readonly ariaDescribedby = input<string | null>(null, { alias: 'aria-describedby' });

	/**
	 * Whether the switch is required in a form.
	 */
	public readonly required = input(false, { transform: booleanAttribute });

	/**
	 * Whether the switch is disabled.
	 */
	public readonly disabled = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/**
	 * tabIndex of the switch.
	 */
	public readonly tabIndex = input(0);

	/**
	 * Event emitted when the switch value changes.
	 */
	public readonly changed = output<boolean>();

	/**
	 * Event emitted when the switch is blurred (loses focus).
	 */
	public readonly touched = output<void>();

	// eslint-disable-next-line @typescript-eslint/no-empty-function
	protected _onChange: ChangeFn<boolean> = () => {};
	// eslint-disable-next-line @typescript-eslint/no-empty-function
	private _onTouched: TouchFn = () => {};

	public readonly switch = viewChild.required<ElementRef<HTMLInputElement>>('switch');

	protected readonly state = computed(() => {
		const name = this.name();
		const id = this.id();
		return {
			disabled: signal(this.disabled()),
			name: name ? name + CONTAINER_POST_FIX : null,
			id: id ? id + CONTAINER_POST_FIX : null,
		};
	});

	constructor() {
		effect(() => {
			const state = this.state();
			const isDisabled = state.disabled();

			if (!this._elementRef.nativeElement || !this._isBrowser) return;

			const newLabelId = state.id + '-label';
			const switchButtonId = this.getSwitchButtonId(state.id);
			const labelElement =
				this._elementRef.nativeElement.closest('label') ??
				this._document.querySelector(`label[for="${switchButtonId}"]`);

			if (!labelElement) return;
			const existingLabelId = labelElement.id;

			this._renderer.setAttribute(labelElement, 'data-disabled', isDisabled ? 'true' : 'false');
			this.mutableAriaLabelledby.set(existingLabelId || newLabelId);

			if (!existingLabelId || existingLabelId.length === 0) {
				this._renderer.setAttribute(labelElement, 'id', newLabelId);
			}
		});
	}

	protected toggle(): void {
		if (this.state().disabled()) return;

		this.checked.update((checked) => !checked);
		this._onChange(this.checked());
		this.changed.emit(this.checked());
	}

	ngAfterContentInit() {
		this._focusMonitor
			.monitor(this._elementRef, true)
			.pipe(takeUntilDestroyed(this._destroyRef))
			.subscribe((focusOrigin) => {
				if (focusOrigin) this.focused.set(true);
				if (focusOrigin === 'keyboard' || focusOrigin === 'program') {
					this.focusVisible.set(true);
					this._cdr.markForCheck();
				}
				if (!focusOrigin) {
					// When a focused element becomes disabled, the browser *immediately* fires a blur event.
					// Angular does not expect events to be raised during change detection, so any state
					// change (such as a form control's ng-touched) will cause a changed-after-checked error.
					// See https://github.com/angular/angular/issues/17793. To work around this, we defer
					// telling the form control it has been touched until the next tick.
					Promise.resolve().then(() => {
						this.focusVisible.set(false);
						this.focused.set(false);
						this._onTouched();
						this.touched.emit();
						this._cdr.markForCheck();
					});
				}
			});

		if (!this.switch()) return;
		this.switch().nativeElement.value = this.checked() ? 'on' : 'off';
		this.switch().nativeElement.dispatchEvent(new Event('change'));
	}

	ngOnDestroy() {
		this._focusMonitor.stopMonitoring(this._elementRef);
	}

	/** We intercept the id passed to the wrapper component and pass it to the underlying button switch control **/
	protected getSwitchButtonId(idPassedToContainer: string | null | undefined): string | null {
		return idPassedToContainer ? idPassedToContainer.replace(CONTAINER_POST_FIX, '') : null;
	}

	writeValue(value: boolean): void {
		this.checked.set(Boolean(value));
	}

	registerOnChange(fn: ChangeFn<boolean>): void {
		this._onChange = fn;
	}

	registerOnTouched(fn: TouchFn): void {
		this._onTouched = fn;
	}

	/** Implemented as a part of ControlValueAccessor. */
	setDisabledState(isDisabled: boolean): void {
		this.state().disabled.set(isDisabled);
		this._cdr.markForCheck();
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/command/README.md
```
# @spartan-ng/brain/command

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/command`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/command/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/command/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import { BrnCommandEmptyDirective } from './lib/brn-command-empty.directive';
import { BrnCommandGroupDirective } from './lib/brn-command-group.directive';
import { BrnCommandItemDirective } from './lib/brn-command-item.directive';
import { BrnCommandListDirective } from './lib/brn-command-list.directive';
import { BrnCommandSearchInputDirective } from './lib/brn-command-search-input.directive';
import { BrnCommandDirective } from './lib/brn-command.directive';

export * from './lib/brn-command-empty.directive';
export * from './lib/brn-command-group.directive';
export * from './lib/brn-command-item.directive';
export * from './lib/brn-command-item.token';
export * from './lib/brn-command-list.directive';
export * from './lib/brn-command-search-input.directive';
export * from './lib/brn-command-search-input.token';
export * from './lib/brn-command.directive';
export * from './lib/brn-command.token';

export const BrnCommandImports = [
	BrnCommandEmptyDirective,
	BrnCommandGroupDirective,
	BrnCommandItemDirective,
	BrnCommandListDirective,
	BrnCommandSearchInputDirective,
	BrnCommandDirective,
] as const;

@NgModule({
	imports: [...BrnCommandImports],
	exports: [...BrnCommandImports],
})
export class BrnCommandModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/command/src/lib/brn-command-empty.directive.ts
```typescript
import { computed, Directive, effect, inject, TemplateRef, ViewContainerRef } from '@angular/core';
import { injectBrnCommand } from './brn-command.token';

@Directive({
	standalone: true,
	selector: '[brnCommandEmpty]',
})
export class BrnCommandEmptyDirective {
	private readonly _templateRef = inject<TemplateRef<void>>(TemplateRef);
	private readonly _viewContainerRef = inject(ViewContainerRef);
	private readonly _command = injectBrnCommand();

	/** Determine if the command has any visible items */
	private readonly _visible = computed(() => this._command.items().some((item) => item.visible()));

	constructor() {
		effect(() => {
			if (this._visible()) {
				this._viewContainerRef.clear();
			} else {
				this._viewContainerRef.createEmbeddedView(this._templateRef);
			}
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/command/src/lib/brn-command-group.directive.ts
```typescript
import { computed, contentChildren, Directive, input } from '@angular/core';
import { BrnCommandItemToken } from './brn-command-item.token';

@Directive({
	selector: '[brnCommandGroup]',
	standalone: true,
	host: {
		role: 'group',
		'[attr.data-hidden]': '!visible() ? "" : null',
		'[id]': 'id()',
	},
})
export class BrnCommandGroupDirective {
	private static _id = 0;

	/** The id of the command list */
	public readonly id = input<string>(`brn-command-group-${BrnCommandGroupDirective._id++}`);

	/** Get the items in the group */
	private readonly _items = contentChildren(BrnCommandItemToken, {
		descendants: true,
	});

	/** Determine if there are any visible items in the group */
	protected readonly visible = computed(() => this._items().some((item) => item.visible()));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/command/src/lib/brn-command-item.directive.ts
```typescript
import { Highlightable } from '@angular/cdk/a11y';
import { BooleanInput } from '@angular/cdk/coercion';
import { isPlatformBrowser } from '@angular/common';
import {
	booleanAttribute,
	computed,
	Directive,
	ElementRef,
	HostListener,
	inject,
	input,
	OnInit,
	output,
	PLATFORM_ID,
	signal,
} from '@angular/core';
import { provideBrnCommandItem } from './brn-command-item.token';
import { injectBrnCommand } from './brn-command.token';

@Directive({
	selector: 'button[brnCommandItem]',
	standalone: true,
	providers: [provideBrnCommandItem(BrnCommandItemDirective)],
	host: {
		type: 'button',
		role: 'option',
		tabIndex: '-1',
		'[id]': 'id()',
		'[attr.disabled]': '_disabled() ? true : null',
		'[attr.data-value]': 'value()',
		'[attr.data-hidden]': "!visible() ? '' : null",
		'[attr.aria-selected]': 'active()',
		'[attr.data-selected]': "active() ? '' : null",
	},
})
export class BrnCommandItemDirective implements Highlightable, OnInit {
	private static _id = 0;

	private readonly _platform = inject(PLATFORM_ID);

	private readonly _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);

	/** Access the command component */
	private readonly _command = injectBrnCommand();

	/** A unique id for the item */
	public readonly id = input(`brn-command-item-${BrnCommandItemDirective._id++}`);

	/** The value this item represents. */
	public readonly value = input.required<string>();

	/** Whether the item is disabled. */
	public readonly _disabled = input<boolean, BooleanInput>(false, {
		alias: 'disabled',
		transform: booleanAttribute,
	});

	/** Expose disabled as a value - used by the Highlightable interface */
	public get disabled() {
		return this._disabled();
	}

	/** Whether the item is initialized, this is to prevent accessing the value-input before the component is initialized.
	 * The brn-command-empty directive accesses the value before the component is initialized, which causes an error.
	 */
	private readonly _initialized = signal(false);

	/** Whether the item is selected. */
	protected readonly active = signal(false);

	/** Emits when the item is selected. */
	public readonly selected = output<void>();

	/** @internal Determine if this item is visible based on the current search query */
	public readonly visible = computed(() => {
		return this._command.filter()(this.safeValue(), this._command.search());
	});

	/** @internal Get the value of the item, with check if it has been initialized to avoid errors */
	public safeValue = computed(() => {
		if (!this._initialized()) {
			return '';
		}
		return this.value();
	});

	/** @internal Get the display value */
	public getLabel(): string {
		return this.safeValue();
	}

	/** @internal */
	setActiveStyles(): void {
		this.active.set(true);

		// ensure the item is in view
		if (isPlatformBrowser(this._platform)) {
			this._elementRef.nativeElement.scrollIntoView({ block: 'nearest' });
		}
	}

	/** @internal */
	setInactiveStyles(): void {
		this.active.set(false);
	}

	@HostListener('click')
	protected onClick(): void {
		this._command.keyManager.setActiveItem(this);
		this.selected.emit();
	}

	ngOnInit(): void {
		this._initialized.set(true);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/command/src/lib/brn-command-item.token.ts
```typescript
import { ExistingProvider, InjectionToken, Type } from '@angular/core';
import type { BrnCommandItemDirective } from './brn-command-item.directive';

export const BrnCommandItemToken = new InjectionToken<BrnCommandItemDirective>('BrnCommandItemToken');

export function provideBrnCommandItem(command: Type<BrnCommandItemDirective>): ExistingProvider {
	return { provide: BrnCommandItemToken, useExisting: command };
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/command/src/lib/brn-command-list.directive.ts
```typescript
import { Directive, input } from '@angular/core';

@Directive({
	standalone: true,
	selector: '[brnCommandList]',
	host: {
		role: 'listbox',
		'[id]': 'id()',
	},
})
export class BrnCommandListDirective {
	private static _id = 0;

	/** The id of the command list */
	public readonly id = input<string>(`brn-command-list-${BrnCommandListDirective._id++}`);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/command/src/lib/brn-command-search-input.directive.ts
```typescript
import { computed, Directive, effect, ElementRef, Inject, input, Optional, Renderer2, signal } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { COMPOSITION_BUFFER_MODE, DefaultValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';
import { startWith } from 'rxjs/operators';
import { provideBrnCommandSearchInput } from './brn-command-search-input.token';
import { injectBrnCommand } from './brn-command.token';

@Directive({
	selector: 'input[brnCommandSearchInput]',
	standalone: true,
	providers: [
		provideBrnCommandSearchInput(BrnCommandSearchInputDirective),
		{
			provide: NG_VALUE_ACCESSOR,
			useExisting: BrnCommandSearchInputDirective,
			multi: true,
		},
	],
	host: {
		role: 'combobox',
		'aria-autocomplete': 'list',
		'[attr.aria-activedescendant]': '_activeDescendant()',
		'(keydown)': 'onKeyDown($event)',
		'(input)': 'onInput()',
	},
})
export class BrnCommandSearchInputDirective extends DefaultValueAccessor {
	private readonly _command = injectBrnCommand();

	/** The initial value of the search input */
	public readonly value = input<string>('');

	/** @internal The mutable value of the search input */
	public readonly mutableValue = computed(() => signal(this.value()));

	/** @internal The "real" value of the search input */
	public readonly valueState = computed(() => this.mutableValue()());

	/** The id of the active option */
	protected readonly _activeDescendant = signal<string | undefined>(undefined);

	constructor(
		renderer: Renderer2,
		private readonly elementRef: ElementRef,
		@Optional() @Inject(COMPOSITION_BUFFER_MODE) compositionMode: boolean,
	) {
		super(renderer, elementRef, compositionMode);
		this._command.keyManager.change
			.pipe(startWith(this._command.keyManager.activeItemIndex), takeUntilDestroyed())
			.subscribe(() => this._activeDescendant.set(this._command.keyManager.activeItem?.id()));
		effect(() => {
			this.elementRef.nativeElement.value = this.valueState();
		});
	}
	/** Listen for changes to the input value */
	protected onInput(): void {
		this.mutableValue().set(this.elementRef.nativeElement.value);
	}

	/** Listen for keydown events */
	protected onKeyDown(event: KeyboardEvent): void {
		this._command.keyManager.onKeydown(event);
	}

	/** CONROL VALUE ACCESSOR */
	override writeValue(value: string | null): void {
		super.writeValue(value);
		if (value) {
			this.mutableValue().set(value);
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/command/src/lib/brn-command-search-input.token.ts
```typescript
import { ExistingProvider, InjectionToken, Type } from '@angular/core';
import type { BrnCommandSearchInputDirective } from './brn-command-search-input.directive';

export const BrnCommandSearchInputToken = new InjectionToken<BrnCommandSearchInputDirective>(
	'BrnCommandSearchInputToken',
);

export function provideBrnCommandSearchInput(command: Type<BrnCommandSearchInputDirective>): ExistingProvider {
	return { provide: BrnCommandSearchInputToken, useExisting: command };
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/command/src/lib/brn-command.directive.ts
```typescript
import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';
import { isPlatformBrowser } from '@angular/common';
import {
	AfterViewInit,
	computed,
	contentChild,
	contentChildren,
	Directive,
	effect,
	HostListener,
	inject,
	Injector,
	input,
	output,
	PLATFORM_ID,
	untracked,
} from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { BrnCommandItemToken } from './brn-command-item.token';
import { BrnCommandSearchInputDirective } from './brn-command-search-input.directive';
import { provideBrnCommand } from './brn-command.token';

@Directive({
	selector: '[brnCommand]',
	standalone: true,
	providers: [provideBrnCommand(BrnCommandDirective)],
	host: {
		'[id]': 'id()',
	},
})
export class BrnCommandDirective implements AfterViewInit {
	private static _id = 0;

	private readonly _platform = inject(PLATFORM_ID);

	private readonly _injector = inject(Injector);

	/** The id of the command */
	public readonly id = input<string>(`brn-command-${BrnCommandDirective._id++}`);

	/** The default filter function */
	private readonly _defaultFilter = (value: string, search: string) =>
		value.toLowerCase().includes(search.toLowerCase());

	/** A custom filter function to use when searching. */
	public readonly filter = input<CommandFilter>(this._defaultFilter);

	/** when the selection has changed */
	public readonly valueChange = output<string>();

	/** @internal The search query */
	public readonly search = computed(() => this._searchInput()?.valueState() ?? '');

	/** Access the search input if present */
	private readonly _searchInput = contentChild(BrnCommandSearchInputDirective, {
		descendants: true,
	});

	/** @internal Access all the items within the commmand */
	public readonly items = contentChildren(BrnCommandItemToken, {
		descendants: true,
	});

	/** @internal The key manager for managing active descendant */
	public readonly keyManager = new ActiveDescendantKeyManager(this.items, this._injector);

	constructor() {
		this.keyManager
			.withVerticalOrientation()
			.withHomeAndEnd()
			.withWrap()
			.skipPredicate((item) => item.disabled || !item.visible());

		// When clearing the search input we also want to reset the active item to the first one
		effect(() => {
			const searchInput = this.search();
			untracked(() => {
				const activeItemIsVisible = this.keyManager.activeItem?.visible();
				if ((searchInput !== undefined && searchInput.length === 0) || !activeItemIsVisible) {
					this.keyManager.setFirstItemActive();
				}
			});
		});

		this.keyManager.change.pipe(takeUntilDestroyed()).subscribe(() => {
			const value = this.keyManager.activeItem?.safeValue();
			if (value) {
				this.valueChange.emit(value);
			}
		});
	}

	ngAfterViewInit(): void {
		if (isPlatformBrowser(this._platform) && this.items().length) {
			this.keyManager.setActiveItem(0);
		}
	}

	@HostListener('keydown.enter')
	protected selectActiveItem(): void {
		this.keyManager.activeItem?.selected.emit();
	}
}

export type CommandFilter = (value: string, search: string) => boolean;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/command/src/lib/brn-command.token.ts
```typescript
import { ExistingProvider, inject, InjectionToken, Type } from '@angular/core';
import type { BrnCommandDirective } from './brn-command.directive';

export const BrnCommandToken = new InjectionToken<BrnCommandDirective>('BrnCommandToken');

export function provideBrnCommand(command: Type<BrnCommandDirective>): ExistingProvider {
	return { provide: BrnCommandToken, useExisting: command };
}

export function injectBrnCommand(): BrnCommandDirective {
	return inject(BrnCommandToken);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/radio-group/README.md
```
# @spartan-ng/brain/radio-group

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/radio-group`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/radio-group/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/radio-group/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { BrnRadioGroupDirective } from './lib/brn-radio-group.directive';
import { BrnRadioComponent } from './lib/brn-radio.component';

export * from './lib/brn-radio-group.directive';
export * from './lib/brn-radio.component';

export const BrnRadioGroupImports = [BrnRadioGroupDirective, BrnRadioComponent] as const;

@NgModule({
	imports: [...BrnRadioGroupImports],
	exports: [...BrnRadioGroupImports],
})
export class BrnRadioGroupModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/radio-group/src/lib/brn-radio-group.directive.ts
```typescript
/* eslint-disable @typescript-eslint/no-empty-function */
import { BooleanInput } from '@angular/cdk/coercion';
import {
	booleanAttribute,
	contentChildren,
	Directive,
	forwardRef,
	input,
	linkedSignal,
	model,
	output,
} from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';
import { ChangeFn, TouchFn } from '@spartan-ng/brain/forms';
import { provideBrnRadioGroupToken } from './brn-radio-group.token';
import { BrnRadioChange, BrnRadioComponent } from './brn-radio.component';

export const BRN_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {
	provide: NG_VALUE_ACCESSOR,
	useExisting: forwardRef(() => BrnRadioGroupDirective),
	multi: true,
};

@Directive({
	selector: '[brnRadioGroup]',
	standalone: true,
	providers: [BRN_RADIO_GROUP_CONTROL_VALUE_ACCESSOR, provideBrnRadioGroupToken(BrnRadioGroupDirective)],
	host: {
		role: 'radiogroup',
		'[dir]': 'direction()',
		'(focusout)': 'onTouched()',
	},
})
export class BrnRadioGroupDirective<T = unknown> implements ControlValueAccessor {
	private static _nextUniqueId = 0;

	protected onChange: ChangeFn<T> = () => {};

	protected onTouched: TouchFn = () => {};

	public readonly name = input(`brn-radio-group-${BrnRadioGroupDirective._nextUniqueId++}`);

	/**
	 * The value of the selected radio button.
	 */
	public readonly value = model<T>();

	/**
	 * Whether the radio group is disabled.
	 */
	public disabled = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/**
	 * Whether the radio group should be required.
	 */
	public readonly required = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/**
	 * The direction of the radio group.
	 */
	public readonly direction = input<'ltr' | 'rtl' | null>('ltr');

	/**
	 * Event emitted when the group value changes.
	 */
	public readonly change = output<BrnRadioChange<T>>();

	/**
	 * The internal disabled state of the radio group. This could be switched to a linkedSignal when we can drop v18 support.
	 * @internal
	 */
	public readonly disabledState = linkedSignal(() => this.disabled());

	/**
	 * Access the radio buttons within the group.
	 * @internal
	 */
	public readonly radioButtons = contentChildren(BrnRadioComponent, { descendants: true });

	writeValue(value: T): void {
		this.value.set(value);
	}

	registerOnChange(fn: ChangeFn<T>): void {
		this.onChange = fn;
	}

	registerOnTouched(fn: TouchFn): void {
		this.onTouched = fn;
	}

	setDisabledState(isDisabled: boolean): void {
		this.disabledState.set(isDisabled);
	}

	/**
	 * Select a radio button.
	 * @internal
	 */
	select(radioButton: BrnRadioComponent<T>, value: T): void {
		if (this.value() === value) {
			return;
		}

		this.value.set(value);
		this.onChange(value);
		this.change.emit(new BrnRadioChange<T>(radioButton, value));
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/radio-group/src/lib/brn-radio-group.token.ts
```typescript
import { ExistingProvider, inject, InjectionToken, Type } from '@angular/core';
import type { BrnRadioGroupDirective } from './brn-radio-group.directive';

const BrnRadioGroupToken = new InjectionToken<BrnRadioGroupDirective<unknown>>('BrnRadioGroupToken');

export function provideBrnRadioGroupToken<T>(directive: Type<BrnRadioGroupDirective<T>>): ExistingProvider {
	return { provide: BrnRadioGroupToken, useExisting: directive };
}

export function injectBrnRadioGroup<T = unknown>(): BrnRadioGroupDirective<T> {
	return inject(BrnRadioGroupToken) as BrnRadioGroupDirective<T>;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/radio-group/src/lib/brn-radio.component.spec.ts
```typescript
import { FormControl, FormGroup, ReactiveFormsModule } from '@angular/forms';
import { render } from '@testing-library/angular';
import { BrnRadioGroupModule } from '../index';

describe('BrnRadioComponent', () => {
	it('should disable the radio button when disabled is true (reactive forms)', async () => {
		const form = new FormGroup({
			radioGroup: new FormControl('16.1.4'),
		});

		form.disable();

		const { getAllByRole } = await render(
			`
			<form [formGroup]="form">

      <div brnRadioGroup formControlName="radioGroup">
        <brn-radio value="16.1.4">16.1.4</brn-radio>
        <brn-radio value="16.0.0">16.0.0</brn-radio>
        <brn-radio value="15.3.0">15.3.0</brn-radio>
      </div>
    </form>
			`,
			{
				imports: [ReactiveFormsModule, BrnRadioGroupModule],
				componentProperties: {
					form,
				},
			},
		);

		const radioButtons = getAllByRole('radio');
		radioButtons.forEach((button) => expect(button).toBeDisabled());
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/radio-group/src/lib/brn-radio.component.ts
```typescript
import { FocusMonitor } from '@angular/cdk/a11y';
import { BooleanInput } from '@angular/cdk/coercion';
import {
	ChangeDetectionStrategy,
	Component,
	ElementRef,
	type OnDestroy,
	ViewEncapsulation,
	booleanAttribute,
	computed,
	inject,
	input,
	output,
	viewChild,
} from '@angular/core';
import { injectBrnRadioGroup } from './brn-radio-group.token';

export class BrnRadioChange<T> {
	constructor(
		public source: BrnRadioComponent<T>,
		public value: T,
	) {}
}

@Component({
	selector: 'brn-radio',
	standalone: true,
	host: {
		class: 'brn-radio',
		'[attr.id]': 'hostId()',
		'[class.brn-radio-checked]': 'checked()',
		'[class.brn-radio-disabled]': 'disabledState()',
		'[attr.data-checked]': 'checked()',
		'[attr.data-disabled]': 'disabledState()',
		'[attr.data-value]': 'value()',
		// Needs to be removed since it causes some a11y issues (see #21266).
		'[attr.tabindex]': 'null',
		'[attr.aria-label]': 'null',
		'[attr.aria-labelledby]': 'null',
		'[attr.aria-describedby]': 'null',
		// Note: under normal conditions focus shouldn't land on this element, however it may be
		// programmatically set, for example inside of a focus trap, in this case we want to forward
		// the focus to the native element.
		'(focus)': 'inputElement().nativeElement.focus()',
	},
	exportAs: 'brnRadio',
	encapsulation: ViewEncapsulation.None,
	changeDetection: ChangeDetectionStrategy.OnPush,
	template: `
		<div
			data-slot="indicator"
			style="display: flex; height: fit-content; width: fit-content"
			(click)="onTouchTargetClick($event)"
		>
			<ng-content select="[target],[indicator]" />
		</div>
		<input
			#input
			style="position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0;"
			type="radio"
			[id]="inputId()"
			[checked]="checked()"
			[disabled]="disabledState()"
			[tabIndex]="tabIndex()"
			[attr.name]="radioGroup.name()"
			[attr.value]="value()"
			[required]="required()"
			[attr.aria-label]="ariaLabel()"
			[attr.aria-labelledby]="ariaLabelledby()"
			[attr.aria-describedby]="ariaDescribedby()"
			(change)="onInputInteraction($event)"
			(click)="onInputClick($event)"
		/>
		<label [for]="inputId()" data-slot="label">
			<ng-content />
		</label>
	`,
})
export class BrnRadioComponent<T = unknown> implements OnDestroy {
	private static _nextUniqueId = 0;
	private readonly _focusMonitor = inject(FocusMonitor);
	private readonly _elementRef = inject(ElementRef);
	protected readonly radioGroup = injectBrnRadioGroup<T>();

	/**
	 * Whether the radio button is disabled.
	 */
	public readonly disabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

	/**
	 * Whether the radio button is disabled or the radio group is disabled.
	 */
	protected readonly disabledState = computed(() => this.disabled() || this.radioGroup.disabledState());

	/**
	 * Whether the radio button is checked.
	 */
	protected readonly checked = computed(() => this.radioGroup.value() === this.value());

	protected readonly tabIndex = computed(() => {
		const disabled = this.disabledState();
		const checked = this.checked();
		const hasSelectedRadio = this.radioGroup.value() !== undefined;
		const isFirstRadio = this.radioGroup.radioButtons()[0] === this;

		if (disabled || (!checked && (hasSelectedRadio || !isFirstRadio))) {
			return -1;
		}
		return 0;
	});

	/**
	 * The unique ID for the radio button input. If none is supplied, it will be auto-generated.
	 */
	public readonly id = input<string | undefined>(undefined);

	public readonly ariaLabel = input<string | undefined>(undefined, { alias: 'aria-label' });

	public readonly ariaLabelledby = input<string | undefined>(undefined, { alias: 'aria-labelledby' });

	public readonly ariaDescribedby = input<string | undefined>(undefined, { alias: 'aria-describedby' });

	/**
	 * The value this radio button represents.
	 */
	public readonly value = input.required<T>();

	/**
	 * Whether the radio button is required.
	 */
	public readonly required = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});

	/**
	 * Event emitted when the checked state of this radio button changes.
	 */
	public readonly change = output<BrnRadioChange<T>>();

	protected readonly hostId = computed(() =>
		this.id() ? this.id() : `brn-radio-${++BrnRadioComponent._nextUniqueId}`,
	);

	protected readonly inputId = computed(() => `${this.hostId()}-input`);

	protected readonly inputElement = viewChild.required<ElementRef<HTMLInputElement>>('input');

	constructor() {
		this._focusMonitor.monitor(this._elementRef, true);
	}

	ngOnDestroy(): void {
		this._focusMonitor.stopMonitoring(this._elementRef);
	}

	/** Dispatch change event with current value. */
	private emitChangeEvent(): void {
		this.change.emit(new BrnRadioChange(this, this.value()));
	}

	protected onInputClick(event: Event): void {
		// We have to stop propagation for click events on the visual hidden input element.
		// By default, when a user clicks on a label element, a generated click event will be
		// dispatched on the associated input element. Since we are using a label element as our
		// root container, the click event on the `radio-button` will be executed twice.
		// The real click event will bubble up, and the generated click event also tries to bubble up.
		// This will lead to multiple click events.
		// Preventing bubbling for the second event will solve that issue.
		event.stopPropagation();
	}

	protected onInputInteraction(event: Event): void {
		// We always have to stop propagation on the change event.
		// Otherwise the change event, from the input element, will bubble up and
		// emit its event object to the `change` output.
		event.stopPropagation();

		if (!this.checked() && !this.disabledState()) {
			this.emitChangeEvent();
			this.radioGroup.select(this, this.value());
		}
	}

	/** Triggered when the user clicks on the touch target. */
	protected onTouchTargetClick(event: Event): void {
		this.onInputInteraction(event);

		if (!this.disabledState()) {
			// Normally the input should be focused already, but if the click
			// comes from the touch target, then we might have to focus it ourselves.
			this.inputElement().nativeElement.focus();
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/README.md
```
# @spartan-ng/brain/select

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/select`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/src/index.ts
```typescript
import { NgModule } from '@angular/core';
import {
	BrnSelectContentComponent,
	BrnSelectScrollDownDirective,
	BrnSelectScrollUpDirective,
} from './lib/brn-select-content.component';
import { BrnSelectGroupDirective } from './lib/brn-select-group.directive';
import { BrnSelectLabelDirective } from './lib/brn-select-label.directive';
import { BrnSelectOptionDirective } from './lib/brn-select-option.directive';
import { BrnSelectPlaceholderDirective } from './lib/brn-select-placeholder.directive';
import { BrnSelectTriggerDirective } from './lib/brn-select-trigger.directive';
import { BrnSelectValueComponent } from './lib/brn-select-value.component';
import { BrnSelectValueDirective } from './lib/brn-select-value.directive';
import { BrnSelectComponent } from './lib/brn-select.component';
export * from './lib/brn-select-content.component';
export * from './lib/brn-select-group.directive';
export * from './lib/brn-select-label.directive';
export * from './lib/brn-select-option.directive';
export * from './lib/brn-select-placeholder.directive';
export * from './lib/brn-select-trigger.directive';
export * from './lib/brn-select-value.component';
export * from './lib/brn-select-value.directive';
export * from './lib/brn-select.component';

export const BrnSelectImports = [
	BrnSelectComponent,
	BrnSelectContentComponent,
	BrnSelectTriggerDirective,
	BrnSelectOptionDirective,
	BrnSelectValueComponent,
	BrnSelectScrollDownDirective,
	BrnSelectScrollUpDirective,
	BrnSelectGroupDirective,
	BrnSelectLabelDirective,
	BrnSelectValueDirective,
	BrnSelectPlaceholderDirective,
] as const;

@NgModule({
	imports: [...BrnSelectImports],
	exports: [...BrnSelectImports],
})
export class BrnSelectModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/src/lib/brn-select-content.component.ts
```typescript
import { NgTemplateOutlet } from '@angular/common';
import {
	AfterContentInit,
	ChangeDetectionStrategy,
	Component,
	DestroyRef,
	ElementRef,
	Injector,
	afterNextRender,
	contentChild,
	contentChildren,
	effect,
	inject,
	signal,
	untracked,
	viewChild,
} from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { BrnSelectOptionDirective } from './brn-select-option.directive';

import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';
import { Directive } from '@angular/core';
import { Subject, fromEvent, interval } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { provideBrnSelectContent } from './brn-select-content.token';
import { injectBrnSelect } from './brn-select.token';

const SCROLLBY_PIXELS = 100;

@Directive({
	selector: '[brnSelectScrollUp], brn-select-scroll-up, hlm-select-scroll-up:not(noHlm)',
	standalone: true,
	host: {
		'aria-hidden': 'true',
		'(mouseenter)': 'startEmittingEvents()',
	},
})
export class BrnSelectScrollUpDirective {
	private readonly _el = inject(ElementRef);
	private readonly _selectContent = inject(BrnSelectContentComponent);

	private readonly _endReached = new Subject<boolean>();
	private readonly _destroyRef = inject(DestroyRef);

	public startEmittingEvents(): void {
		const mouseLeave$ = fromEvent(this._el.nativeElement, 'mouseleave');

		interval(100)
			.pipe(takeUntil(mouseLeave$), takeUntil(this._endReached), takeUntilDestroyed(this._destroyRef))
			.subscribe(() => this._selectContent.moveFocusUp());
	}

	public stopEmittingEvents(): void {
		this._endReached.next(true);
	}
}

@Directive({
	selector: '[brnSelectScrollDown], brn-select-scroll-down, hlm-select-scroll-down:not(noHlm)',
	standalone: true,
	host: {
		'aria-hidden': 'true',
		'(mouseenter)': 'startEmittingEvents()',
	},
})
export class BrnSelectScrollDownDirective {
	private readonly _el = inject(ElementRef);
	private readonly _selectContent = inject(BrnSelectContentComponent);

	private readonly _endReached = new Subject<boolean>();
	private readonly _destroyRef = inject(DestroyRef);

	public startEmittingEvents(): void {
		const mouseLeave$ = fromEvent(this._el.nativeElement, 'mouseleave');

		interval(100)
			.pipe(takeUntil(mouseLeave$), takeUntil(this._endReached), takeUntilDestroyed(this._destroyRef))
			.subscribe(() => this._selectContent.moveFocusDown());
	}

	public stopEmittingEvents(): void {
		this._endReached.next(true);
	}
}

@Component({
	selector: 'brn-select-content, hlm-select-content:not(noHlm)',
	imports: [NgTemplateOutlet],
	providers: [provideBrnSelectContent(BrnSelectContentComponent)],
	changeDetection: ChangeDetectionStrategy.OnPush,
	host: {
		role: 'listbox',
		tabindex: '0',
		'[attr.aria-multiselectable]': '_select.multiple()',
		'[attr.aria-disabled]': '_select.disabled() || _select._formDisabled()',
		'aria-orientation': 'vertical',
		'[attr.aria-activedescendant]': 'keyManager?.activeItem?.id()',
		'[attr.aria-labelledBy]': '_select.labelId()',
		'[attr.aria-controlledBy]': "_select.id() +'--trigger'",
		'[id]': "_select.id() + '--content'",
		'[attr.dir]': '_select.dir()',
		'(keydown)': 'keyManager?.onKeydown($event)',
		'(keydown.enter)': 'selectActiveItem($event)',
		'(keydown.space)': 'selectActiveItem($event)',
	},
	styles: [
		`
			:host {
				display: flex;
				box-sizing: border-box;
				flex-direction: column;
				outline: none;
				pointer-events: auto;
			}

			[data-brn-select-viewport] {
				scrollbar-width: none;
				-ms-overflow-style: none;
				-webkit-overflow-scrolling: touch;
			}

			[data-brn-select-viewport]::-webkit-scrollbar {
				display: none;
			}
		`,
	],
	template: `
		<ng-template #scrollUp>
			<ng-content select="hlm-select-scroll-up" />
			<ng-content select="brnSelectScrollUp" />
		</ng-template>
		<ng-container *ngTemplateOutlet="canScrollUp() && scrollUpBtn() ? scrollUp : null" />
		<div
			data-brn-select-viewport
			#viewport
			(scroll)="handleScroll()"
			style="flex: 1 1 0%;
			position: relative;
			width:100%;
			overflow:auto;
			min-height: 36px;
      padding-bottom: 2px;
      margin-bottom: -2px;"
		>
			<ng-content />
		</div>
		<ng-template #scrollDown>
			<ng-content select="brnSelectScrollDown" />
			<ng-content select="hlm-select-scroll-down" />
		</ng-template>
		<ng-container *ngTemplateOutlet="canScrollDown() && scrollDownBtn() ? scrollDown : null" />
	`,
})
export class BrnSelectContentComponent<T> implements AfterContentInit {
	private readonly _elementRef: ElementRef<HTMLElement> = inject(ElementRef);
	private readonly _injector = inject(Injector);
	protected readonly _select = injectBrnSelect<T>();
	protected readonly canScrollUp = signal(false);
	protected readonly canScrollDown = signal(false);
	protected readonly viewport = viewChild.required<ElementRef<HTMLElement>>('viewport');
	protected readonly scrollUpBtn = contentChild(BrnSelectScrollUpDirective);
	protected readonly scrollDownBtn = contentChild(BrnSelectScrollDownDirective);
	private readonly _options = contentChildren(BrnSelectOptionDirective, { descendants: true });

	/** @internal */
	public keyManager: ActiveDescendantKeyManager<BrnSelectOptionDirective<T>> | null = null;

	constructor() {
		effect(() => {
			this._select.open() && afterNextRender(() => this.updateArrowDisplay(), { injector: this._injector });
		});
	}

	ngAfterContentInit(): void {
		this.keyManager = new ActiveDescendantKeyManager(this._options, this._injector)
			.withHomeAndEnd()
			.withVerticalOrientation()
			.withTypeAhead()
			.withAllowedModifierKeys(['shiftKey'])
			.withWrap()
			.skipPredicate((option) => option._disabled());

		effect(
			() => {
				// any time the select is opened, we need to focus the first selected option or the first option
				const open = this._select.open();
				const options = this._options();

				if (!open || !options.length) {
					return;
				}

				untracked(() => {
					const selectedOption = options.find((option) => option.selected());

					if (selectedOption) {
						this.keyManager?.setActiveItem(selectedOption);
					} else {
						this.keyManager?.setFirstItemActive();
					}
				});
			},
			{ injector: this._injector },
		);
	}

	public updateArrowDisplay(): void {
		const { scrollTop, scrollHeight, clientHeight } = this.viewport().nativeElement;
		this.canScrollUp.set(scrollTop > 0);
		const maxScroll = scrollHeight - clientHeight;
		this.canScrollDown.set(Math.ceil(scrollTop) < maxScroll);
	}

	public handleScroll(): void {
		this.updateArrowDisplay();
	}

	public focusList(): void {
		this._elementRef.nativeElement.focus();
	}

	public moveFocusUp(): void {
		this.viewport().nativeElement.scrollBy({ top: -SCROLLBY_PIXELS, behavior: 'smooth' });
		if (this.viewport().nativeElement.scrollTop === 0) {
			this.scrollUpBtn()?.stopEmittingEvents();
		}
	}

	public moveFocusDown(): void {
		this.viewport().nativeElement.scrollBy({ top: SCROLLBY_PIXELS, behavior: 'smooth' });
		const viewportSize = this._elementRef.nativeElement.scrollHeight;
		const viewportScrollPosition = this.viewport().nativeElement.scrollTop;
		if (
			viewportSize + viewportScrollPosition + SCROLLBY_PIXELS >
			this.viewport().nativeElement.scrollHeight + SCROLLBY_PIXELS / 2
		) {
			this.scrollDownBtn()?.stopEmittingEvents();
		}
	}

	setActiveOption(option: BrnSelectOptionDirective<T>): void {
		const index = this._options().findIndex((o) => o === option);

		if (index === -1) {
			return;
		}

		this.keyManager?.setActiveItem(index);
	}

	protected selectActiveItem(event: KeyboardEvent): void {
		event.preventDefault();

		const activeOption = this.keyManager?.activeItem;

		if (activeOption) {
			this._select.selectOption(activeOption.value()!);
		}
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/src/lib/brn-select-content.token.ts
```typescript
import { ExistingProvider, inject, InjectionToken, Type } from '@angular/core';
import type { BrnSelectContentComponent } from './brn-select-content.component';

const BrnSelectContentToken = new InjectionToken<BrnSelectContentComponent<unknown>>('BrnSelectContentToken');

export function injectBrnSelectContent<T>(): BrnSelectContentComponent<T> {
	return inject(BrnSelectContentToken) as BrnSelectContentComponent<T>;
}

export function provideBrnSelectContent(select: Type<BrnSelectContentComponent<unknown>>): ExistingProvider {
	return { provide: BrnSelectContentToken, useExisting: select };
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/src/lib/brn-select-group.directive.ts
```typescript
import { Directive, signal } from '@angular/core';

@Directive({
	selector: '[brnSelectGroup]',
	standalone: true,
	host: {
		role: 'group',
		'[attr.aria-labelledby]': 'labelledBy()',
	},
})
export class BrnSelectGroupDirective {
	public readonly labelledBy = signal('');
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/src/lib/brn-select-label.directive.ts
```typescript
import { Directive, inject } from '@angular/core';
import { BrnLabelDirective } from '@spartan-ng/brain/label';
import { BrnSelectGroupDirective } from './brn-select-group.directive';

@Directive({
	selector: '[brnSelectLabel]',
	hostDirectives: [BrnLabelDirective],
	standalone: true,
})
export class BrnSelectLabelDirective {
	private readonly _group = inject(BrnSelectGroupDirective, { optional: true });
	private readonly _label = inject(BrnLabelDirective, { host: true });

	constructor() {
		this._group?.labelledBy.set(this._label.id());
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/src/lib/brn-select-option.directive.ts
```typescript
import type { Highlightable } from '@angular/cdk/a11y';
import { BooleanInput } from '@angular/cdk/coercion';
import { booleanAttribute, computed, Directive, ElementRef, inject, input, signal } from '@angular/core';
import { injectBrnSelectContent } from './brn-select-content.token';
import { injectBrnSelect } from './brn-select.token';

let nextId = 0;

@Directive({
	selector: '[brnOption]',
	standalone: true,
	host: {
		role: 'option',
		'[id]': 'id()',
		'[attr.aria-selected]': 'selected()',
		'[attr.aria-disabled]': '_disabled()',
		'(click)': 'select()',
		'[attr.dir]': '_select.dir()',
		'[attr.data-active]': "_active() ? '' : undefined",
		'[attr.data-disabled]': "_disabled() ? '' : undefined",
		'(mouseenter)': 'activate()',
	},
})
export class BrnSelectOptionDirective<T> implements Highlightable {
	protected readonly _select = injectBrnSelect();
	protected readonly _content = injectBrnSelectContent<T>();
	public readonly elementRef = inject(ElementRef);
	public readonly id = input(`brn-option-${nextId++}`);
	public readonly value = input<T>();

	// we use "_disabled" here because disabled is already defined in the Highlightable interface
	public readonly _disabled = input<boolean, BooleanInput>(false, {
		alias: 'disabled',
		transform: booleanAttribute,
	});

	public get disabled(): boolean {
		return this._disabled();
	}

	public readonly selected = computed(() => this.value() !== undefined && this._select.isSelected(this.value()));
	protected readonly _active = signal(false);
	public readonly checkedState = computed(() => (this.selected() ? 'checked' : 'unchecked'));
	public readonly dir = this._select.dir;

	public select(): void {
		if (this._disabled()) {
			return;
		}

		if (this._select.multiple()) {
			this._select.toggleSelect(this.value());
			return;
		}

		this._select.selectOption(this.value());
	}

	/** Get the label for this element which is required by the FocusableOption interface. */
	getLabel(): string {
		return this.elementRef.nativeElement.textContent?.trim() ?? '';
	}

	setActiveStyles(): void {
		this._active.set(true);

		// scroll the option into view if it is not visible
		this.elementRef.nativeElement.scrollIntoView({ block: 'nearest' });
	}

	setInactiveStyles(): void {
		this._active.set(false);
	}

	protected activate(): void {
		if (this._disabled()) {
			return;
		}
		this._content.setActiveOption(this);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/src/lib/brn-select-placeholder.directive.ts
```typescript
import { Directive, inject, TemplateRef } from '@angular/core';

@Directive({
	standalone: true,
	selector: '[brnSelectPlaceholder], [hlmSelectPlaceholder]',
})
export class BrnSelectPlaceholderDirective {
	/** @internale */
	public readonly templateRef = inject<TemplateRef<void>>(TemplateRef);
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/src/lib/brn-select-trigger.directive.ts
```typescript
import { isPlatformBrowser } from '@angular/common';
import { type AfterViewInit, Directive, ElementRef, OnDestroy, PLATFORM_ID, computed, inject } from '@angular/core';
import { NgControl } from '@angular/forms';
import { injectBrnSelect } from './brn-select.token';

@Directive({
	selector: '[brnSelectTrigger]',
	standalone: true,
	host: {
		type: 'button',
		role: 'combobox',
		'[attr.id]': '_triggerId()',
		'[disabled]': '_disabled()',
		'[attr.aria-expanded]': '_select.open()',
		'[attr.aria-controls]': '_contentId()',
		'[attr.aria-labelledBy]': '_labelledBy()',
		'aria-autocomplete': 'none',
		'[attr.dir]': '_select.dir()',
		'[class.ng-invalid]': '_ngControl?.invalid || null',
		'[class.ng-dirty]': '_ngControl?.dirty || null',
		'[class.ng-valid]': '_ngControl?.valid || null',
		'[class.ng-touched]': '_ngControl?.touched || null',
		'[class.ng-untouched]': '_ngControl?.untouched || null',
		'[class.ng-pristine]': '_ngControl?.pristine || null',
		'(keydown.ArrowDown)': '_select.show()',
	},
})
export class BrnSelectTriggerDirective<T> implements AfterViewInit, OnDestroy {
	private readonly _elementRef = inject(ElementRef);
	protected readonly _select = injectBrnSelect<T>();
	protected readonly _ngControl = inject(NgControl, { optional: true });
	private readonly _platform = inject(PLATFORM_ID);
	protected readonly _triggerId = computed(() => `${this._select.id()}--trigger`);
	protected readonly _contentId = computed(() => `${this._select.id()}--content`);
	protected readonly _disabled = computed(() => this._select.disabled() || this._select._formDisabled());
	protected readonly _labelledBy = computed(() => {
		const value = this._select.value();

		if (Array.isArray(value) && value.length > 0) {
			return `${this._select.labelId()} ${this._select.id()}--value`;
		}
		return this._select.labelId();
	});

	private _resizeObserver?: ResizeObserver;

	constructor() {
		this._select.trigger.set(this);
	}

	ngAfterViewInit() {
		this._select.triggerWidth.set(this._elementRef.nativeElement.offsetWidth);

		// if we are on the client, listen for element resize events
		if (isPlatformBrowser(this._platform)) {
			this._resizeObserver = new ResizeObserver(() =>
				this._select.triggerWidth.set(this._elementRef.nativeElement.offsetWidth),
			);

			this._resizeObserver.observe(this._elementRef.nativeElement);
		}
	}

	ngOnDestroy(): void {
		this._resizeObserver?.disconnect();
	}

	focus(): void {
		this._elementRef.nativeElement.focus();
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/src/lib/brn-select-value.component.ts
```typescript
import { NgTemplateOutlet } from '@angular/common';
import { ChangeDetectionStrategy, Component, computed, contentChild, input } from '@angular/core';
import { BrnSelectPlaceholderDirective } from './brn-select-placeholder.directive';
import { BrnSelectValueDirective } from './brn-select-value.directive';
import { injectBrnSelect } from './brn-select.token';

@Component({
	selector: 'brn-select-value, hlm-select-value',
	imports: [NgTemplateOutlet],
	template: `
		@if (_showPlaceholder()) {
			<ng-container [ngTemplateOutlet]="customPlaceholderTemplate()?.templateRef ?? defaultPlaceholderTemplate" />
		} @else {
			<ng-container
				[ngTemplateOutlet]="customValueTemplate()?.templateRef ?? defaultValueTemplate"
				[ngTemplateOutletContext]="{ $implicit: _select.value() }"
			/>
		}

		<ng-template #defaultValueTemplate>{{ value() }}</ng-template>
		<ng-template #defaultPlaceholderTemplate>{{ placeholder() }}</ng-template>
	`,
	host: {
		'[id]': 'id()',
		'[attr.data-placeholder]': '_showPlaceholder() ? "" : null',
	},
	styles: [
		`
			:host {
				display: -webkit-box;
				-webkit-box-orient: vertical;
				-webkit-line-clamp: 1;
				white-space: nowrap;
				pointer-events: none;
			}
		`,
	],
	changeDetection: ChangeDetectionStrategy.OnPush,
})
export class BrnSelectValueComponent<T> {
	protected readonly _select = injectBrnSelect<T>();
	public readonly id = computed(() => `${this._select.id()}--value`);
	public readonly placeholder = computed(() => this._select.placeholder());

	protected readonly _showPlaceholder = computed(
		() => this.value() === null || this.value() === undefined || this.value() === '',
	);

	/** Allow a custom value template */
	protected readonly customValueTemplate = contentChild(BrnSelectValueDirective, { descendants: true });
	protected readonly customPlaceholderTemplate = contentChild(BrnSelectPlaceholderDirective, { descendants: true });

	protected readonly value = computed(() => {
		const value = this._values();

		if (value.length === 0) {
			return null;
		}

		// remove any selected values that are not in the options list
		const existingOptions = value.filter((val) =>
			this._select.options().some((option) => this._select.compareWith()(option.value(), val)),
		);
		const selectedOption = existingOptions.map((val) =>
			this._select.options().find((option) => this._select.compareWith()(option.value(), val)),
		);

		if (selectedOption.length === 0) {
			return null;
		}

		const selectedLabels = selectedOption.map((option) => option?.getLabel());

		if (this._select.dir() === 'rtl') {
			selectedLabels.reverse();
		}
		return this.transformFn()(selectedLabels);
	});

	/** Normalize the values as an array */
	protected readonly _values = computed(() =>
		Array.isArray(this._select.value()) ? (this._select.value() as T[]) : ([this._select.value()] as T[]),
	);

	public readonly transformFn = input<(values: (string | undefined)[]) => any>((values) => (values ?? []).join(', '));
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/src/lib/brn-select-value.directive.ts
```typescript
import { Directive, inject, TemplateRef } from '@angular/core';

@Directive({
	standalone: true,
	selector: '[brnSelectValue], [hlmSelectValue]',
})
export class BrnSelectValueDirective<T> {
	/** @internale */
	public readonly templateRef = inject<TemplateRef<BrnSelectValueContext<T>>>(TemplateRef);
}

export interface BrnSelectValueContext<T> {
	$implicit: T | T[];
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/src/lib/brn-select.component.ts
```typescript
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import { CdkListboxModule } from '@angular/cdk/listbox';
import {
	CdkConnectedOverlay,
	type ConnectedOverlayPositionChange,
	type ConnectedPosition,
	OverlayModule,
} from '@angular/cdk/overlay';
import {
	ChangeDetectionStrategy,
	Component,
	type DoCheck,
	Injector,
	type Signal,
	afterNextRender,
	booleanAttribute,
	computed,
	contentChild,
	contentChildren,
	inject,
	input,
	model,
	numberAttribute,
	signal,
	viewChild,
} from '@angular/core';
import { takeUntilDestroyed, toObservable, toSignal } from '@angular/core/rxjs-interop';
import { type ControlValueAccessor, FormGroupDirective, NgControl, NgForm } from '@angular/forms';
import {
	type ExposesSide,
	type ExposesState,
	provideExposedSideProviderExisting,
	provideExposesStateProviderExisting,
} from '@spartan-ng/brain/core';
import { BrnFormFieldControl } from '@spartan-ng/brain/form-field';
import { ChangeFn, ErrorStateMatcher, ErrorStateTracker, TouchFn } from '@spartan-ng/brain/forms';
import { BrnLabelDirective } from '@spartan-ng/brain/label';
import { Subject, of } from 'rxjs';
import { delay, map, switchMap } from 'rxjs/operators';
import { BrnSelectContentComponent } from './brn-select-content.component';
import { BrnSelectOptionDirective } from './brn-select-option.directive';
import { BrnSelectTriggerDirective } from './brn-select-trigger.directive';
import { provideBrnSelect } from './brn-select.token';

export type BrnReadDirection = 'ltr' | 'rtl';

let nextId = 0;

@Component({
	selector: 'brn-select, hlm-select',
	imports: [OverlayModule, CdkListboxModule],
	changeDetection: ChangeDetectionStrategy.OnPush,
	providers: [
		provideExposedSideProviderExisting(() => BrnSelectComponent),
		provideExposesStateProviderExisting(() => BrnSelectComponent),
		provideBrnSelect(BrnSelectComponent),
		{
			provide: BrnFormFieldControl,
			useExisting: BrnSelectComponent,
		},
	],
	template: `
		@if (!selectLabel() && placeholder()) {
			<label class="hidden" [attr.id]="labelId()">{{ placeholder() }}</label>
		} @else {
			<ng-content select="label[hlmLabel],label[brnLabel]" />
		}

		<div cdk-overlay-origin (click)="toggle()" #trigger="cdkOverlayOrigin">
			<ng-content select="hlm-select-trigger,[brnSelectTrigger]" />
		</div>

		<ng-template
			cdk-connected-overlay
			cdkConnectedOverlayLockPosition
			cdkConnectedOverlayHasBackdrop
			cdkConnectedOverlayBackdropClass="cdk-overlay-transparent-backdrop"
			[cdkConnectedOverlayOrigin]="trigger"
			[cdkConnectedOverlayOpen]="_delayedExpanded()"
			[cdkConnectedOverlayPositions]="_positions"
			[cdkConnectedOverlayWidth]="triggerWidth() > 0 ? triggerWidth() : 'auto'"
			(backdropClick)="hide()"
			(detach)="hide()"
			(positionChange)="_positionChanges$.next($event)"
		>
			<ng-content />
		</ng-template>
	`,
})
export class BrnSelectComponent<T = unknown>
	implements ControlValueAccessor, DoCheck, ExposesSide, ExposesState, BrnFormFieldControl
{
	private readonly _defaultErrorStateMatcher = inject(ErrorStateMatcher);
	private readonly _parentForm = inject(NgForm, { optional: true });
	private readonly _injector = inject(Injector);
	private readonly _parentFormGroup = inject(FormGroupDirective, { optional: true });
	public readonly ngControl = inject(NgControl, { optional: true, self: true });

	public readonly id = input<string>(`brn-select-${nextId++}`);
	public readonly multiple = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});
	public readonly placeholder = input<string>('');
	public readonly disabled = input<boolean, BooleanInput>(false, {
		transform: booleanAttribute,
	});
	public readonly dir = input<BrnReadDirection>('ltr');
	public readonly closeDelay = input<number, NumberInput>(100, {
		transform: numberAttribute,
	});

	public readonly open = model<boolean>(false);
	public readonly value = model<T | T[]>();
	public readonly compareWith = input<(o1: T, o2: T) => boolean>((o1, o2) => o1 === o2);
	public readonly _formDisabled = signal(false);

	/** Label provided by the consumer. */
	protected readonly selectLabel = contentChild(BrnLabelDirective, { descendants: false });

	/** Overlay pane containing the options. */
	protected readonly selectContent = contentChild.required(BrnSelectContentComponent);

	/** @internal */
	public readonly options = contentChildren(BrnSelectOptionDirective, { descendants: true });

	/** @internal Derive the selected options to filter out the unselected options */
	public readonly selectedOptions = computed(() => this.options().filter((option) => option.selected()));

	/** Overlay pane containing the options. */
	protected readonly _overlayDir = viewChild.required(CdkConnectedOverlay);
	public readonly trigger = signal<BrnSelectTriggerDirective<T> | null>(null);
	public readonly triggerWidth = signal<number>(0);

	protected readonly _delayedExpanded = toSignal(
		toObservable(this.open).pipe(
			switchMap((expanded) => (!expanded ? of(expanded).pipe(delay(this.closeDelay())) : of(expanded))),
			takeUntilDestroyed(),
		),
		{ initialValue: false },
	);

	public readonly state = computed(() => (this.open() ? 'open' : 'closed'));

	protected readonly _positionChanges$ = new Subject<ConnectedOverlayPositionChange>();

	public readonly side: Signal<'top' | 'bottom' | 'left' | 'right'> = toSignal(
		this._positionChanges$.pipe(
			map<ConnectedOverlayPositionChange, 'top' | 'bottom' | 'left' | 'right'>((change) =>
				// todo: better translation or adjusting hlm to take that into account
				change.connectionPair.originY === 'center'
					? change.connectionPair.originX === 'start'
						? 'left'
						: 'right'
					: change.connectionPair.originY,
			),
		),
		{ initialValue: 'bottom' },
	);

	public readonly labelId = computed(() => this.selectLabel()?.id ?? `${this.id()}--label`);

	// eslint-disable-next-line @typescript-eslint/no-empty-function
	private _onChange: ChangeFn<T | T[]> = () => {};
	// eslint-disable-next-line @typescript-eslint/no-empty-function
	private _onTouched: TouchFn = () => {};

	/*
	 * This position config ensures that the top "start" corner of the overlay
	 * is aligned with with the top "start" of the origin by default (overlapping
	 * the trigger completely). If the panel cannot fit below the trigger, it
	 * will fall back to a position above the trigger.
	 */
	protected _positions: ConnectedPosition[] = [
		{
			originX: 'start',
			originY: 'bottom',
			overlayX: 'start',
			overlayY: 'top',
		},
		{
			originX: 'end',
			originY: 'bottom',
			overlayX: 'end',
			overlayY: 'top',
		},
		{
			originX: 'start',
			originY: 'top',
			overlayX: 'start',
			overlayY: 'bottom',
		},
		{
			originX: 'end',
			originY: 'top',
			overlayX: 'end',
			overlayY: 'bottom',
		},
	];

	public errorStateTracker: ErrorStateTracker;

	public readonly errorState = computed(() => this.errorStateTracker.errorState());

	constructor() {
		if (this.ngControl !== null) {
			this.ngControl.valueAccessor = this;
		}

		this.errorStateTracker = new ErrorStateTracker(
			this._defaultErrorStateMatcher,
			this.ngControl,
			this._parentFormGroup,
			this._parentForm,
		);
	}

	ngDoCheck() {
		this.errorStateTracker.updateErrorState();
	}

	public toggle(): void {
		if (this.open()) {
			this.hide();
		} else {
			this.show();
		}
	}

	public show(): void {
		if (this.open() || this.disabled() || this._formDisabled() || this.options()?.length == 0) {
			return;
		}

		this.open.set(true);
		afterNextRender(() => this.selectContent().focusList(), { injector: this._injector });
	}

	public hide(): void {
		if (!this.open()) return;

		this.open.set(false);
		this._onTouched();

		// restore focus to the trigger
		this.trigger()?.focus();
	}

	public writeValue(value: T): void {
		this.value.set(value);
	}

	public registerOnChange(fn: ChangeFn<T | T[]>): void {
		this._onChange = fn;
	}

	public registerOnTouched(fn: TouchFn): void {
		this._onTouched = fn;
	}

	public setDisabledState(isDisabled: boolean) {
		this._formDisabled.set(isDisabled);
	}

	selectOption(value: T): void {
		// if this is a multiple select we need to add the value to the array
		if (this.multiple()) {
			const currentValue = this.value() as T[];
			const newValue = currentValue ? [...currentValue, value] : [value];
			this.value.set(newValue);
		} else {
			this.value.set(value);
		}

		this._onChange?.(this.value() as T | T[]);

		// if this is single select close the dropdown
		if (!this.multiple()) {
			this.hide();
		}
	}

	deselectOption(value: T): void {
		if (this.multiple()) {
			const currentValue = this.value() as T[];
			this.value.set(currentValue.filter((val) => !this.compareWith()(val, value)));
		} else {
			this.value.set(null as T);
		}

		this._onChange?.(this.value() as T | T[]);
	}

	toggleSelect(value: T): void {
		if (this.isSelected(value)) {
			this.deselectOption(value);
		} else {
			this.selectOption(value);
		}
	}

	isSelected(value: T): boolean {
		const selection = this.value();

		if (Array.isArray(selection)) {
			return selection.some((val) => this.compareWith()(val, value));
		} else if (value !== undefined) {
			return this.compareWith()(selection as T, value);
		}

		return false;
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/src/lib/brn-select.token.ts
```typescript
import { ExistingProvider, inject, InjectionToken, Type } from '@angular/core';
import type { BrnSelectComponent } from './brn-select.component';

const BrnSelectToken = new InjectionToken<BrnSelectComponent>('BrnSelectToken');

export function injectBrnSelect<T>(): BrnSelectComponent<T> {
	return inject(BrnSelectToken) as BrnSelectComponent<T>;
}

export function provideBrnSelect(select: Type<BrnSelectComponent>): ExistingProvider {
	return { provide: BrnSelectToken, useExisting: select };
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/src/lib/tests/brn-select.component.numbers.spec.ts
```typescript
import { signal } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { render, screen } from '@testing-library/angular';
import userEvent from '@testing-library/user-event';
import { BrnSelectImports } from '../../index';

describe('BrnSelectComponent NumberValues', () => {
	beforeAll(() => {
		global.ResizeObserver = jest.fn().mockImplementation(() => ({
			observe: jest.fn(),
			unobserve: jest.fn(),
			disconnect: jest.fn(),
		}));
		window.HTMLElement.prototype.scrollIntoView = jest.fn();
	});

	const setup = async () => {
		const selectedValue = signal(15);
		const container = await render(
			`
			 <brn-select class="inline-block" [(ngModel)]="selectedValue" [multiple]="multiple">
			   <button brnSelectTrigger class='w-56' data-testid="brn-select-trigger">
			     <brn-select-value data-testid="brn-select-value" />
			   </button>
			   <brn-select-content class="w-56" data-testid="brn-select-content">
			     <label brnSelectLabel>Numbers</label>
			     <div brnOption [value]="0">0</div>
			     <div brnOption [value]="5">5</div>
			     <div brnOption [value]="10">10</div>
			     <div brnOption [value]="15">15</div>
			     <div brnOption [value]="20">20</div>
			   </brn-select-content>
			 </brn-select>
      `,
			{
				imports: [...BrnSelectImports, FormsModule],
				componentProperties: {
					selectedValue,
					multiple: false,
				},
			},
		);
		return {
			user: userEvent.setup(),
			container,
			trigger: screen.getByTestId('brn-select-trigger'),
			selectedValue,
			value: screen.getByTestId('brn-select-value'),
		};
	};

	it('should display the correct value after render', async () => {
		const { container, user, trigger, value, selectedValue } = await setup();
		// without rerenderung
		container.detectChanges();
		expect(value.textContent?.trim()).toBe('15');

		await user.click(trigger);
		const options = await screen.getAllByRole('option');

		await user.click(options[0]);
		expect(trigger.textContent?.trim()).toBe('0');
		expect(selectedValue()).toBe(0);

		await user.click(options[1]);
		expect(selectedValue()).toBe(5);
		expect(trigger.textContent?.trim()).toBe('5');

		await user.click(options[2]);
		expect(trigger.textContent?.trim()).toBe('10');
		expect(selectedValue()).toBe(10);
	});

	it('should display the correct value after render when multiple is true', async () => {
		const { container, user, trigger, value } = await setup();
		const selectedValue = signal([15]);
		await container.rerender({
			componentProperties: {
				multiple: true,
				selectedValue,
			},
		});
		container.detectChanges();
		expect(value.textContent?.trim()).toBe('15');
		expect(selectedValue()).toEqual([15]);

		await user.click(trigger);
		const options = await screen.getAllByRole('option');

		await user.click(options[1]);
		expect(selectedValue()).toEqual([15, 5]);
		expect(trigger.textContent?.trim()).toBe('15, 5');

		await user.click(options[2]);
		expect(trigger.textContent?.trim()).toBe('15, 5, 10');
		expect(selectedValue()).toEqual([15, 5, 10]);
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/src/lib/tests/brn-select.component.spec.ts
```typescript
import { render, screen } from '@testing-library/angular';
import userEvent from '@testing-library/user-event';
import { BrnSelectImports } from '../../index';

describe('BrnSelectComponent', () => {
	beforeAll(() => {
		global.ResizeObserver = jest.fn().mockImplementation(() => ({
			observe: jest.fn(),
			unobserve: jest.fn(),
			disconnect: jest.fn(),
		}));
		window.HTMLElement.prototype.scrollIntoView = jest.fn();
	});

	const setup = async () => {
		const openChangeSpy = jest.fn();
		const valueChangeSpy = jest.fn();
		const container = await render(
			`
            <brn-select class="inline-block" [multiple]="multiple" (openChange)="openChange($event)" (valueChange)="valueChange($event)">
			<button brnSelectTrigger class='w-56' data-testid="brn-select-trigger">
				<brn-select-value />
			</button>
			<brn-select-content class="w-56" data-testid="brn-select-content">
				<label brnSelectLabel>Fruits</label>
				<div brnOption value="apple">Apple</div>
				<div brnOption value="banana">Banana</div>
				<div brnOption value="blueberry">Blueberry</div>
				<div brnOption value="grapes">Grapes</div>
				<div brnOption value="pineapple">Pineapple</div>
				<div brnOption value="disabled" [disabled]="true">Disabled Option</div>
		  </brn-select-content>
		</brn-select>
    `,
			{
				imports: [...BrnSelectImports],
				componentProperties: {
					multiple: true,
					openChange: openChangeSpy,
					valueChange: valueChangeSpy,
				},
			},
		);
		return {
			user: userEvent.setup(),
			container,
			trigger: screen.getByTestId('brn-select-trigger'),
			openChangeSpy,
			valueChangeSpy,
		};
	};

	describe('default', () => {
		it('openChanged should emit event on open and close', async () => {
			const { user, trigger, openChangeSpy } = await setup();
			await user.click(trigger);
			expect(openChangeSpy).toHaveBeenCalledTimes(1);
			await user.click(trigger);
			expect(openChangeSpy).toHaveBeenCalledTimes(2);
		});
		it('should add data-disabled to a disabled option', async () => {
			const { user, trigger } = await setup();
			await user.click(trigger);
			const disabledOption = await screen.getByText('Disabled Option');

			expect(disabledOption).toHaveAttribute('data-disabled');
			await user.click(disabledOption);
			expect(trigger.textContent).not.toContain('Disabled Option');
		});

		it('should add data-placeholder to the value when no value is selected', async () => {
			const { container, user, trigger } = await setup();
			const value = container.container.querySelector('brn-select-value');
			expect(value).toHaveAttribute('data-placeholder');

			await user.click(trigger);
			const options = await screen.getAllByRole('option');
			await userEvent.click(options[0]);
			expect(value).not.toHaveAttribute('data-placeholder');
		});

		it('single mode: valueChange should emit event on selection', async () => {
			const { user, trigger, container, openChangeSpy, valueChangeSpy } = await setup();
			container.rerender({
				componentProperties: {
					multiple: false,
					openChange: openChangeSpy,
					valueChange: valueChangeSpy,
				},
			});
			await user.click(trigger);
			const options = await screen.getAllByRole('option');
			await user.click(options[0]);
			expect(valueChangeSpy).toHaveBeenCalledWith('apple');
		});

		it('multi mode: valueChange should emit event on selection', async () => {
			const { user, trigger, valueChangeSpy } = await setup();
			await user.click(trigger);
			const options = await screen.getAllByRole('option');
			await user.click(options[0]);
			expect(valueChangeSpy).toHaveBeenCalledWith(['apple']);
			await user.click(options[1]);
			expect(valueChangeSpy).toHaveBeenCalledWith(['apple', 'banana']);
		});
	});

	describe('multiple option select', () => {
		it('when multiple true -> false with multiple selected values, should reset', async () => {
			const { user, trigger, container } = await setup();
			await user.click(trigger);
			const options = await screen.getAllByRole('option');
			await user.click(options[0]);
			await user.click(options[1]);
			expect(trigger.textContent).toContain(`${options[0].textContent}, ${options[1].textContent}`);
			container.rerender({
				componentProperties: {
					multiple: false,
				},
			});
			expect(trigger.textContent).toContain('');
		});

		it('when multiple true -> false with single value, should retain value', async () => {
			const { user, trigger, container } = await setup();
			await user.click(trigger);
			const options = await screen.getAllByRole('option');
			await user.click(options[0]);
			expect(trigger.textContent).toContain(`${options[0].textContent}`);
			container.rerender({
				componentProperties: {
					multiple: false,
				},
			});
			expect(trigger.textContent).toContain(`${options[0].textContent}`);
		});
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/src/lib/tests/select-multi-mode.spec.ts
```typescript
import { Validators } from '@angular/forms';
import { render, screen } from '@testing-library/angular';
import userEvent from '@testing-library/user-event';
import {
	SelectMultiValueTestComponent,
	SelectMultiValueWithInitialValueTestComponent,
	SelectMultiValueWithInitialValueWithForLoopTestComponent,
} from './select-reactive-form';
import { getFormControlStatus, getFormValidationClasses } from './utils';

describe('Brn Select Component in multi-mode', () => {
	beforeAll(() => {
		global.ResizeObserver = jest.fn().mockImplementation(() => ({
			observe: jest.fn(),
			unobserve: jest.fn(),
			disconnect: jest.fn(),
		}));
		window.HTMLElement.prototype.scrollIntoView = jest.fn();
	});

	const DEFAULT_LABEL = 'Select a Fruit';

	const setupWithFormValidationMulti = async () => {
		const { fixture } = await render(SelectMultiValueTestComponent);
		return {
			user: userEvent.setup(),
			fixture,
			trigger: screen.getByTestId('brn-select-trigger'),
			value: screen.getByTestId('brn-select-value'),
		};
	};

	const setupWithFormValidationMultiWithInitialValue = async () => {
		const { fixture } = await render(SelectMultiValueWithInitialValueTestComponent);
		return {
			user: userEvent.setup(),
			fixture,
			trigger: screen.getByTestId('brn-select-trigger'),
			value: screen.getByTestId('brn-select-value'),
		};
	};

	const setupWithFormValidationMultiWithInitialValueWithForLoop = async () => {
		const { fixture } = await render(SelectMultiValueWithInitialValueWithForLoopTestComponent);
		return {
			user: userEvent.setup(),
			fixture,
			trigger: screen.getByTestId('brn-select-trigger'),
			value: screen.getByTestId('brn-select-value'),
			updateOptionsBtn: screen.getByTestId('update-options-btn'),
			updatePartialOptionsBtn: screen.getByTestId('partial-options-btn'),
			updateDiffOptionsBtn: screen.getByTestId('diff-options-btn'),
		};
	};

	describe('form validation - multi mode', () => {
		it('should become dirty only after an actual user option selection', async () => {
			const { user, fixture, trigger } = await setupWithFormValidationMulti();
			const cmpInstance = fixture.componentInstance;

			const expected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			expect(cmpInstance.form?.get('fruit')?.value).toEqual([]);

			// open
			await user.click(trigger);
			// close
			await user.click(trigger);

			// Patch Value
			expect(cmpInstance.form?.get('fruit')?.patchValue(['apple', 'banana', 'blueberry']));

			// validate patch value
			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['apple', 'banana', 'blueberry']);
			fixture.detectChanges();

			const afterValuePatchExpected = {
				untouched: false,
				touched: true,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterValuePatchExpected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterValuePatchExpected);
		});

		// should have correct status when initialized with no value and as optional
		it('should reflect correct form control status with no initial value', async () => {
			const { fixture, trigger, value } = await setupWithFormValidationMulti();
			const cmpInstance = fixture.componentInstance as SelectMultiValueTestComponent;

			const expected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			expect(value.textContent?.trim()).toBe(DEFAULT_LABEL);
			expect(cmpInstance.form?.get('fruit')?.value).toEqual([]);
		});

		it('should reflect correct form control status with initial value', async () => {
			const { fixture, trigger, value } = await setupWithFormValidationMultiWithInitialValue();
			const cmpInstance = fixture.componentInstance;

			const expected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			expect(value.textContent?.trim()).toBe('Apple, Blueberry');
			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['apple', 'blueberry']);
		});

		it('should reflect correct form control status and value after first user selection with no initial value', async () => {
			const { fixture, trigger, user } = await setupWithFormValidationMulti();
			const cmpInstance = fixture.componentInstance;

			const expected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			expect(cmpInstance.form?.get('fruit')?.value).toEqual([]);

			// open select
			await user.click(trigger);

			// Make 1st selection
			const options = await screen.getAllByRole('option');
			await user.click(options[1]);

			// status prior to closing select
			const afterFirstSelectionExpected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: false,
				dirty: true,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterFirstSelectionExpected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterFirstSelectionExpected);

			// close select
			await user.click(trigger);

			// validate status and value
			const afterClose = {
				untouched: false,
				touched: true,
				valid: true,
				invalid: false,
				pristine: false,
				dirty: true,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterClose);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterClose);

			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['banana']);
		});

		it('should reflect correct form control status and value after patching value with no initial value', async () => {
			const { fixture, trigger } = await setupWithFormValidationMulti();
			const cmpInstance = fixture.componentInstance;

			const expected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			expect(cmpInstance.form?.get('fruit')?.value).toEqual([]);

			expect(cmpInstance.form?.get('fruit')?.patchValue(['apple', 'banana', 'blueberry']));

			// validate patch value
			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['apple', 'banana', 'blueberry']);

			const afterValuePatchExpected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterValuePatchExpected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterValuePatchExpected);
		});

		it('should reflect correct form control status and value after first user selection with initial value', async () => {
			const { fixture, trigger, user } = await setupWithFormValidationMulti();
			const cmpInstance = fixture.componentInstance;

			const expected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			expect(cmpInstance.form?.get('fruit')?.value).toEqual([]);

			// open select
			await user.click(trigger);

			// Make 1st selection
			const options = await screen.getAllByRole('option');
			await user.click(options[1]);

			// status prior to closing select
			const afterFirstSelectionExpected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: false,
				dirty: true,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterFirstSelectionExpected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterFirstSelectionExpected);

			// close select
			await user.click(trigger);

			// validate status and value
			const afterCloseExpected = {
				untouched: false,
				touched: true,
				valid: true,
				invalid: false,
				pristine: false,
				dirty: true,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterCloseExpected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterCloseExpected);

			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['banana']);
		});

		it('should reflect correct form control status and value after patching value with initial value', async () => {
			const { fixture, trigger } = await setupWithFormValidationMulti();
			const cmpInstance = fixture.componentInstance;

			const expected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			expect(cmpInstance.form?.get('fruit')?.value).toEqual([]);

			expect(cmpInstance.form?.get('fruit')?.patchValue(['apple', 'banana', 'blueberry']));

			// validate patch value
			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['apple', 'banana', 'blueberry']);

			const afterValuePatchExpected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterValuePatchExpected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterValuePatchExpected);
		});

		/**
		 * Update Options
		 */
		it('should reset display but not value if options change and are completely different', async () => {
			const { fixture, trigger, updateDiffOptionsBtn, user } =
				await setupWithFormValidationMultiWithInitialValueWithForLoop();
			const cmpInstance = fixture.componentInstance;

			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['apple', 'pineapple']);

			// update with
			await user.click(updateDiffOptionsBtn);

			//display should be updated
			expect(trigger).toHaveTextContent('Select a Fruit');

			// value should remain same
			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['apple', 'pineapple']);
		});

		it('should update display but not value if options updated and only some options are same', async () => {
			const { fixture, trigger, updatePartialOptionsBtn, user } =
				await setupWithFormValidationMultiWithInitialValueWithForLoop();
			const cmpInstance = fixture.componentInstance;

			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['apple', 'pineapple']);

			// actionBtn.
			await user.click(updatePartialOptionsBtn);

			//display should be updated
			expect(trigger).toHaveTextContent('Apple');

			// expect value to remain same
			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['apple', 'pineapple']);
		});

		it('should maintain exact display and value if options updated but exactly same', async () => {
			const { fixture, trigger, updateOptionsBtn, user } =
				await setupWithFormValidationMultiWithInitialValueWithForLoop();
			const cmpInstance = fixture.componentInstance;

			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['apple', 'pineapple']);

			// actionBtn.
			user.click(updateOptionsBtn);

			// open select
			await user.click(trigger);

			// display should be same
			expect(trigger).toHaveTextContent('Apple, Pineapple');

			// value should be same
			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['apple', 'pineapple']);
		});
	});

	describe('form validation - multi mode and required', () => {
		/**
		 * No Initial Value
		 */
		it('should reflect correct form control status with no initial value', async () => {
			const { fixture, trigger, value } = await setupWithFormValidationMulti();
			const cmpInstance = fixture.componentInstance;

			cmpInstance.form?.get('fruit')?.addValidators(Validators.required);
			cmpInstance.form?.get('fruit')?.updateValueAndValidity();
			fixture.detectChanges();

			const expected = {
				untouched: true,
				touched: false,
				valid: false,
				invalid: true,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			expect(value.textContent?.trim()).toBe(DEFAULT_LABEL);
			expect(cmpInstance.form?.get('fruit')?.value).toEqual([]);
		});

		/**
		 * Initial Value
		 */
		// should initialize with correct status and initial value when required
		it('should reflect correct form control status with initial value', async () => {
			const { fixture, trigger, value } = await setupWithFormValidationMultiWithInitialValue();
			const cmpInstance = fixture.componentInstance;

			cmpInstance.form?.get('fruit')?.addValidators(Validators.required);
			cmpInstance.form?.get('fruit')?.updateValueAndValidity();
			fixture.detectChanges();

			const expected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			expect(value.textContent?.trim()).toBe('Apple, Blueberry');
			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['apple', 'blueberry']);
		});

		/**
		 * User Selection with no initial value
		 */
		it('should reflect correct form control status and value after first user selection with no initial value', async () => {
			const { fixture, trigger, user } = await setupWithFormValidationMulti();
			const cmpInstance = fixture.componentInstance;

			cmpInstance.form?.get('fruit')?.addValidators(Validators.required);
			cmpInstance.form?.get('fruit')?.updateValueAndValidity();
			fixture.detectChanges();

			const expected = {
				untouched: true,
				touched: false,
				valid: false,
				invalid: true,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			expect(cmpInstance.form?.get('fruit')?.value).toEqual([]);

			// open select
			await user.click(trigger);

			// Make 1st selection
			const options = await screen.getAllByRole('option');
			await user.click(options[1]);

			// status prior to closing select
			const afterFirstSelectioneExpected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: false,
				dirty: true,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterFirstSelectioneExpected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterFirstSelectioneExpected);

			// close select
			await user.click(trigger);

			// validate status and value
			const afterCloseExpected = {
				untouched: false,
				touched: true,
				valid: true,
				invalid: false,
				pristine: false,
				dirty: true,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterCloseExpected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterCloseExpected);

			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['banana']);
		});

		/**
		 * User Selection with initial value
		 */
		it('should reflect correct form control status and value after first user selection with initial value', async () => {
			const { fixture, trigger, user } = await setupWithFormValidationMultiWithInitialValue();
			const cmpInstance = fixture.componentInstance;

			cmpInstance.form?.get('fruit')?.addValidators(Validators.required);
			cmpInstance.form?.get('fruit')?.updateValueAndValidity();
			fixture.detectChanges();

			const expected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['apple', 'blueberry']);

			// open select
			await user.click(trigger);

			// Make 1st selection
			const options = await screen.getAllByRole('option');
			await user.click(options[1]);

			// status prior to closing select
			const afterFirstSelectionExpected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: false,
				dirty: true,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterFirstSelectionExpected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterFirstSelectionExpected);

			// close select
			await user.click(trigger);

			// validate status and value
			const afterCloseExpected = {
				untouched: false,
				touched: true,
				valid: true,
				invalid: false,
				pristine: false,
				dirty: true,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterCloseExpected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterCloseExpected);
			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['apple', 'blueberry', 'banana']);
		});

		/**
		 * User Selection with initial value when options are dynamically added with a for-loop
		 */
		it('should reflect correct form control status and value after first user selection with initial value with dynamic options', async () => {
			const { fixture, trigger, value, user } = await setupWithFormValidationMultiWithInitialValueWithForLoop();
			const cmpInstance = fixture.componentInstance as SelectMultiValueWithInitialValueWithForLoopTestComponent;

			cmpInstance.form?.get('fruit')?.addValidators(Validators.required);
			cmpInstance.form?.get('fruit')?.updateValueAndValidity();
			fixture.detectChanges();

			const expected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			fixture.detectChanges();

			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['apple', 'pineapple']);

			expect(value.textContent?.trim()).toBe('Apple, Pineapple');

			// open select
			await user.click(trigger);

			// Make 1st selection
			const options = await screen.getAllByRole('option');
			await user.click(options[1]);

			// status prior to closing select
			const afterFirstSelectionExpected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: false,
				dirty: true,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterFirstSelectionExpected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterFirstSelectionExpected);

			// close select
			await user.click(trigger);

			// validate status and value
			const afterCloseExpected = {
				untouched: false,
				touched: true,
				valid: true,
				invalid: false,
				pristine: false,
				dirty: true,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterCloseExpected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterCloseExpected);
			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['apple', 'pineapple', 'banana']);
		});

		/**
		 * Patch value with no initial value
		 */
		it('should reflect correct form control status and value after patching value with no initial value', async () => {
			const { fixture, trigger } = await setupWithFormValidationMulti();
			const cmpInstance = fixture.componentInstance;

			// Setting to be required
			cmpInstance.form?.get('fruit')?.addValidators(Validators.required);
			cmpInstance.form?.get('fruit')?.updateValueAndValidity();
			fixture.detectChanges();

			const expected = {
				untouched: true,
				touched: false,
				valid: false,
				invalid: true,
				pristine: true,
				dirty: false,
			};

			// Some issue
			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			expect(cmpInstance.form?.get('fruit')?.value).toEqual([]);

			expect(cmpInstance.form?.get('fruit')?.patchValue(['apple', 'banana', 'blueberry']));

			// validate patch value
			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['apple', 'banana', 'blueberry']);
			fixture.detectChanges();

			const afterValuePatchExpected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterValuePatchExpected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterValuePatchExpected);
		});

		/**
		 * Patch value with initial value
		 */
		it('should reflect correct form control status and value after patching value with initial value', async () => {
			const { fixture, trigger } = await setupWithFormValidationMultiWithInitialValue();
			const cmpInstance = fixture.componentInstance;

			// Setting to be required
			cmpInstance.form?.get('fruit')?.addValidators(Validators.required);
			cmpInstance.form?.get('fruit')?.updateValueAndValidity();
			fixture.detectChanges();

			const expected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['apple', 'blueberry']);

			expect(cmpInstance.form?.get('fruit')?.patchValue(['apple', 'banana', 'blueberry']));

			// validate patch value
			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['apple', 'banana', 'blueberry']);

			const afterValuePatchExpected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterValuePatchExpected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterValuePatchExpected);
		});
	});

	describe('deselect option - multi mode', () => {
		it('should reflect correct form control status with no initial value', async () => {
			const { fixture, trigger, user } = await setupWithFormValidationMulti();
			const cmpInstance = fixture.componentInstance as SelectMultiValueTestComponent;

			expect(cmpInstance.form?.get('fruit')?.value).toEqual([]);

			// open select
			await user.click(trigger);

			const options = await screen.getAllByRole('option');
			await user.click(options[1]);

			expect(cmpInstance.form?.get('fruit')?.value).toEqual(['banana']);
			expect(screen.getByTestId('brn-select-value').textContent?.trim()).toBe('Banana');

			await user.click(options[1]);

			expect(trigger).toHaveTextContent('Select a Fruit');
			expect(cmpInstance.form?.get('fruit')?.value).toEqual([]);
		});
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/src/lib/tests/select-ng-model-form.ts
```typescript
import { Component, signal } from '@angular/core';

@Component({
	selector: 'select-ngmodel-form',
	template: `
		<form ngForm>
			<div class="mb-3">
				<pre>Form Control Value: {{ fruit() | json }}</pre>
			</div>
			<hlm-select class="w-56" ${argsToTemplate(args, { exclude: ['initialValue'] })} [(ngModel)]="fruit" name="fruit">
				<label hlmLabel>Select a Fruit</label>
				<hlm-select-trigger>
					<brn-select-value hlm />
				</hlm-select-trigger>
				<hlm-select-content>
					<hlm-select-label>Fruits</hlm-select-label>
					<hlm-option value="apple">Apple</hlm-option>
					<hlm-option value="banana">Banana</hlm-option>
					<hlm-option value="blueberry">Blueberry</hlm-option>
					<hlm-option value="grapes">Grapes</hlm-option>
					<hlm-option value="pineapple">Pineapple</hlm-option>
				</hlm-select-content>
			</hlm-select>
		</form>
	`,
	// eslint-disable-next-line @angular-eslint/prefer-standalone
	standalone: false,
})
export class SelectNgModelComponent {
	public fruit = signal('');
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/src/lib/tests/select-reactive-form.ts
```typescript
import { ChangeDetectionStrategy, Component, OnInit, signal, viewChild } from '@angular/core';
import { FormControl, FormGroup, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { BrnSelectComponent, BrnSelectImports } from '../../';

@Component({
	imports: [FormsModule, ReactiveFormsModule, BrnSelectImports],
	selector: 'select-reactive-field-fixture',
	template: `
		<form [formGroup]="fruitGroup">
			<brn-select class="w-56" formControlName="fruit" placeholder="Select a Fruit">
				<button brnSelectTrigger data-testid="brn-select-trigger">
					<brn-select-value />
				</button>
				<brn-select-content class="w-56" data-testid="brn-select-content">
					<label brnSelectLabel>Fruits</label>
					<div brnOption value="apple">Apple</div>
					<div brnOption value="banana">Banana</div>
					<div brnOption value="blueberry">Blueberry</div>
					<div brnOption value="grapes">Grapes</div>
					<div brnOption value="pineapple">Pineapple</div>
					<div>Clear</div>
				</brn-select-content>
			</brn-select>
			@if (fruitGroup.controls.fruit.invalid && fruitGroup.controls.fruit.touched) {
				<span class="text-destructive">Required</span>
			}
		</form>
	`,
})
export class SelectReactiveFieldComponent {
	public fruitGroup = new FormGroup({ fruit: new FormControl() });
}

@Component({
	imports: [FormsModule, ReactiveFormsModule, BrnSelectImports],
	selector: 'select-reactive-field-fixture',
	template: `
		<form [formGroup]="form">
			<brn-select class="w-56" formControlName="fruit" placeholder="Select a Fruit">
				<button brnSelectTrigger data-testid="brn-select-trigger">
					<brn-select-value data-testid="brn-select-value" />
				</button>
				<brn-select-content class="w-56" data-testid="brn-select-content">
					<label brnSelectLabel>Fruits</label>
					<div brnOption value="apple">Apple</div>
					<div brnOption value="banana">Banana</div>
					<div brnOption value="blueberry">Blueberry</div>
					<div brnOption value="grapes">Grapes</div>
					<div brnOption value="pineapple">Pineapple</div>
					<div>Clear</div>
				</brn-select-content>
			</brn-select>
			@if (form.controls.fruit.invalid && form.controls.fruit.touched) {
				<span class="text-destructive">Required</span>
			}
		</form>
	`,
})
export class SelectSingleValueTestComponent {
	public form = new FormGroup({ fruit: new FormControl(null) });

	public brnSelectComponent = viewChild(BrnSelectComponent);
}

@Component({
	imports: [FormsModule, ReactiveFormsModule, BrnSelectImports],
	selector: 'select-reactive-field-fixture',
	template: `
		<form [formGroup]="form">
			<brn-select class="w-56" formControlName="fruit" placeholder="Select a Fruit">
				<button brnSelectTrigger data-testid="brn-select-trigger">
					<brn-select-value data-testid="brn-select-value" />
				</button>
				<brn-select-content class="w-56" data-testid="brn-select-content">
					<label brnSelectLabel>Fruits</label>
					<div brnOption value="apple">Apple</div>
					<div brnOption value="banana">Banana</div>
					<div brnOption value="blueberry">Blueberry</div>
					<div brnOption value="grapes">Grapes</div>
					<div brnOption value="pineapple">Pineapple</div>
					<div>Clear</div>
				</brn-select-content>
			</brn-select>
			@if (form.controls.fruit.invalid && form.controls.fruit.touched) {
				<span class="text-destructive">Required</span>
			}
		</form>
	`,
})
export class SelectSingleValueWithInitialValueTestComponent {
	public form = new FormGroup({ fruit: new FormControl('apple') });
}

@Component({
	imports: [FormsModule, ReactiveFormsModule, BrnSelectImports],
	selector: 'select-reactive-field-fixture',
	template: `
		<form [formGroup]="form">
			<brn-select class="w-56" formControlName="fruit" placeholder="Select a Fruit">
				<button brnSelectTrigger data-testid="brn-select-trigger">
					<brn-select-value data-testid="brn-select-value" />
				</button>
				<brn-select-content class="w-56" data-testid="brn-select-content">
					<label brnSelectLabel>Fruits</label>
					<div brnOption value="apple">Apple</div>
					<div brnOption value="banana">Banana</div>
					<div brnOption value="blueberry">Blueberry</div>
					<div brnOption value="grapes">Grapes</div>
					<div brnOption value="pineapple">Pineapple</div>
					<div>Clear</div>
				</brn-select-content>
			</brn-select>
			@if (form.controls.fruit.invalid && form.controls.fruit.touched) {
				<span class="text-destructive">Required</span>
			}
		</form>
	`,
})
export class SelectSingleValueWithInitialValueWithAsyncUpdateTestComponent {
	public form = new FormGroup({ fruit: new FormControl('apple') });

	constructor() {
		// queueMicrotask(() => {
		// 	this.form.patchValue({ fruit: 'apple' });
		// });
		setTimeout(() => {
			this.form.patchValue({ fruit: 'apple' });
		});
	}
}

@Component({
	imports: [FormsModule, ReactiveFormsModule, BrnSelectImports],
	selector: 'select-reactive-field-fixture',
	template: `
		<form [formGroup]="form">
			<brn-select class="w-56" formControlName="fruit" placeholder="Select a Fruit" [multiple]="true">
				<button brnSelectTrigger data-testid="brn-select-trigger">
					<brn-select-value data-testid="brn-select-value" />
				</button>
				<brn-select-content class="w-56" data-testid="brn-select-content">
					<label brnSelectLabel>Fruits</label>
					<div brnOption value="apple">Apple</div>
					<div brnOption value="banana">Banana</div>
					<div brnOption value="blueberry">Blueberry</div>
					<div brnOption value="grapes">Grapes</div>
					<div brnOption value="pineapple">Pineapple</div>
					<div>Clear</div>
				</brn-select-content>
			</brn-select>
			@if (form.controls.fruit.invalid && form.controls.fruit.touched) {
				<span class="text-destructive">Required</span>
			}
		</form>
	`,
})
export class SelectMultiValueTestComponent {
	public form = new FormGroup({ fruit: new FormControl<string[]>([]) });
}

@Component({
	imports: [FormsModule, ReactiveFormsModule, BrnSelectImports],
	selector: 'select-reactive-field-fixture',
	template: `
		<form [formGroup]="form">
			<brn-select class="w-56" formControlName="fruit" placeholder="Select a Fruit" [multiple]="true">
				<button brnSelectTrigger data-testid="brn-select-trigger">
					<brn-select-value data-testid="brn-select-value" />
				</button>
				<brn-select-content class="w-56" data-testid="brn-select-content">
					<label brnSelectLabel>Fruits</label>
					<div brnOption value="apple">Apple</div>
					<div brnOption value="banana">Banana</div>
					<div brnOption value="blueberry">Blueberry</div>
					<div brnOption value="grapes">Grapes</div>
					<div brnOption value="pineapple">Pineapple</div>
					<div>Clear</div>
				</brn-select-content>
			</brn-select>
			@if (form.controls.fruit.invalid && form.controls.fruit.touched) {
				<span class="text-destructive">Required</span>
			}
		</form>
	`,
})
export class SelectMultiValueWithInitialValueTestComponent {
	public form = new FormGroup({ fruit: new FormControl(['apple', 'blueberry']) });
}

@Component({
	imports: [FormsModule, ReactiveFormsModule, BrnSelectImports],
	selector: 'select-reactive-field-fixture',
	changeDetection: ChangeDetectionStrategy.OnPush,
	template: `
		<form [formGroup]="form">
			<brn-select class="w-56" formControlName="fruit" placeholder="Select a Fruit" [multiple]="true">
				<button brnSelectTrigger data-testid="brn-select-trigger">
					<brn-select-value data-testid="brn-select-value" />
				</button>
				<brn-select-content class="w-56" data-testid="brn-select-content">
					<label brnSelectLabel>Fruits</label>
					@for (selectOption of options(); track selectOption.value) {
						<div brnOption [value]="selectOption.value">{{ selectOption.label }}</div>
					}
				</brn-select-content>
			</brn-select>
			@if (form.controls.fruit.invalid && form.controls.fruit.touched) {
				<span class="text-destructive">Required</span>
			}
		</form>

		<button (click)="updateOptions()" data-testid="update-options-btn">Update Options</button>
		<button (click)="updatePartialOptions()" data-testid="partial-options-btn">Partial Options</button>
		<button (click)="updateDiffOptions()" data-testid="diff-options-btn">Diff Options</button>
	`,
})
export class SelectMultiValueWithInitialValueWithForLoopTestComponent implements OnInit {
	public options = signal<{ value: string; label: string }[]>([]);
	public form = new FormGroup({ fruit: new FormControl(['apple', 'pineapple']) });

	ngOnInit(): void {
		this.options.set([
			{ label: 'Apple', value: 'apple' },
			{ label: 'Banana', value: 'banana' },
			{ label: 'Blueberry', value: 'blueberry' },
			{ label: 'Grapes', value: 'grapes' },
			{ label: 'Pineapple', value: 'pineapple' },
		]);
	}

	public updateOptions() {
		// Reset same options
		this.options.set([
			{ label: 'Apple', value: 'apple' },
			{ label: 'Banana', value: 'banana' },
			{ label: 'Blueberry', value: 'blueberry' },
			{ label: 'Grapes', value: 'grapes' },
			{ label: 'Pineapple', value: 'pineapple' },
		]);
	}

	public updateDiffOptions() {
		// Reset with different option values
		this.options.set([
			{ label: 'Coconut', value: 'coconut' },
			{ label: 'Grapefruit', value: 'grapefruit' },
			{ label: 'Kiwi', value: 'kiwi' },
			{ label: 'Pomegranate', value: 'pomegranate' },
			{ label: 'Watermelon', value: 'watermelon' },
		]);
	}

	public updatePartialOptions() {
		// Reset with different option values
		this.options.set([
			{ label: 'Apple', value: 'apple' },
			{ label: 'Banana', value: 'banana' },
			{ label: 'Blueberry', value: 'blueberry' },
			{ label: 'Pomegranate', value: 'pomegranate' },
			{ label: 'Watermelon', value: 'watermelon' },
		]);
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/src/lib/tests/select-single-mode.spec.ts
```typescript
import { Validators } from '@angular/forms';
import { render, screen } from '@testing-library/angular';
import userEvent from '@testing-library/user-event';
import {
	SelectSingleValueTestComponent,
	SelectSingleValueWithInitialValueTestComponent,
	SelectSingleValueWithInitialValueWithAsyncUpdateTestComponent,
} from './select-reactive-form';
import { getFormControlStatus, getFormValidationClasses } from './utils';

describe('Brn Select Component in single-mode', () => {
	const DEFAULT_LABEL = 'Select a Fruit';
	const INITIAL_VALUE_TEXT = 'Apple';
	const INITIAL_VALUE = 'apple';

	beforeAll(() => {
		global.ResizeObserver = jest.fn().mockImplementation(() => ({
			observe: jest.fn(),
			unobserve: jest.fn(),
			disconnect: jest.fn(),
		}));

		window.HTMLElement.prototype.scrollIntoView = jest.fn();
	});

	const setupWithFormValidation = async () => {
		const { fixture } = await render(SelectSingleValueTestComponent);
		return {
			user: userEvent.setup(),
			fixture,
			trigger: screen.getByTestId('brn-select-trigger'),
			value: screen.getByTestId('brn-select-value'),
		};
	};

	const setupWithFormValidationAndInitialValue = async () => {
		const { fixture } = await render(SelectSingleValueWithInitialValueTestComponent);
		return {
			user: userEvent.setup(),
			fixture,
			trigger: screen.getByTestId('brn-select-trigger'),
			value: screen.getByTestId('brn-select-value'),
		};
	};

	const setupWithFormValidationAndInitialValueAndAsyncUpdate = async () => {
		const { fixture } = await render(SelectSingleValueWithInitialValueWithAsyncUpdateTestComponent);
		return {
			user: userEvent.setup(),
			fixture,
			trigger: screen.getByTestId('brn-select-trigger'),
			value: screen.getByTestId('brn-select-value'),
		};
	};

	describe('form validation - single mode', () => {
		it('should reflect correct formcontrol status and value with no initial value', async () => {
			const { fixture, trigger, value } = await setupWithFormValidation();
			const cmpInstance = fixture.componentInstance as SelectSingleValueTestComponent;

			const expected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			expect(value.textContent?.trim()).toBe(DEFAULT_LABEL);
			expect(cmpInstance.form?.get('fruit')?.value).toEqual(null);
		});

		it('should reflect correct formcontrol status and value with initial value', async () => {
			const { fixture, trigger, value } = await setupWithFormValidationAndInitialValue();
			const cmpInstance = fixture.componentInstance;

			const expected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			expect(value.textContent?.trim()).toBe(INITIAL_VALUE_TEXT);
			expect(cmpInstance.form?.get('fruit')?.value).toEqual(INITIAL_VALUE);
		});

		it('should reflect correct formcontrol status after first user selection with no initial value', async () => {
			const { user, trigger, fixture, value } = await setupWithFormValidation();
			const cmpInstance = fixture.componentInstance as SelectSingleValueTestComponent;

			expect(value.textContent?.trim()).toBe(DEFAULT_LABEL);
			expect(cmpInstance.form?.get('fruit')?.value).toEqual(null);

			const expected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			// Open Select
			await user.click(trigger);

			const afterOpenExpected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterOpenExpected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterOpenExpected);

			// Select option
			const options = await screen.getAllByRole('option');
			await user.click(options[1]);

			const afterSelectionExpected = {
				untouched: false,
				touched: true,
				valid: true,
				invalid: false,
				pristine: false,
				dirty: true,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterSelectionExpected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterSelectionExpected);

			expect(cmpInstance.form?.get('fruit')?.value).toEqual('banana');
		});

		it('should reflect correct formcontrol status after first user selection with initial value', async () => {
			const { user, trigger, fixture, value } = await setupWithFormValidationAndInitialValue();
			const cmpInstance = fixture.componentInstance as SelectSingleValueWithInitialValueTestComponent;

			expect(value.textContent?.trim()).toBe(INITIAL_VALUE_TEXT);
			expect(cmpInstance.form?.get('fruit')?.value).toEqual(INITIAL_VALUE);

			const expected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			// Open Select
			await user.click(trigger);

			const afterOpenExpected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterOpenExpected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterOpenExpected);

			// Select option
			const options = await screen.getAllByRole('option');
			await user.click(options[1]);

			const afterSelectionExpected = {
				untouched: false,
				touched: true,
				valid: true,
				invalid: false,
				pristine: false,
				dirty: true,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterSelectionExpected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterSelectionExpected);

			expect(cmpInstance.form?.get('fruit')?.value).toEqual('banana');
			expect(screen.getByTestId('brn-select-value').textContent?.trim()).toBe('Banana');
		});

		it('should reflect correct formcontrol status after first user selection with initial value and async update', async () => {
			const { user, trigger, fixture, value } = await setupWithFormValidationAndInitialValueAndAsyncUpdate();
			const cmpInstance = fixture.componentInstance as SelectSingleValueWithInitialValueTestComponent;

			expect(value.textContent?.trim()).toBe(INITIAL_VALUE_TEXT);
			expect(cmpInstance.form?.get('fruit')?.value).toEqual(INITIAL_VALUE);

			const expected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			// Open Select
			await user.click(trigger);

			const afterOpenExpected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterOpenExpected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterOpenExpected);

			// Select option
			const options = await screen.getAllByRole('option');
			await user.click(options[1]);

			const afterSelectionExpected = {
				untouched: false,
				touched: true,
				valid: true,
				invalid: false,
				pristine: false,
				dirty: true,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(afterSelectionExpected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(afterSelectionExpected);

			expect(cmpInstance.form?.get('fruit')?.value).toEqual('banana');
			expect(value.textContent?.trim()).toBe('Banana');
		});
	});

	describe('form validation - single mode and required', () => {
		it('should reflect correct formcontrol status with no initial value', async () => {
			const { fixture, trigger, value } = await setupWithFormValidation();
			const cmpInstance = fixture.componentInstance as SelectSingleValueTestComponent;

			cmpInstance.form?.get('fruit')?.addValidators(Validators.required);
			cmpInstance.form?.get('fruit')?.updateValueAndValidity();
			fixture.detectChanges();

			const expected = {
				untouched: true,
				touched: false,
				valid: false,
				invalid: true,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			expect(value.textContent?.trim()).toBe(DEFAULT_LABEL);
			expect(cmpInstance.form?.get('fruit')?.value).toEqual(null);
		});

		it('should have the errorState in true when the select has been triggered and no option has been selected', async () => {
			const { user, fixture, trigger } = await setupWithFormValidation();
			const cmpInstance = fixture.componentInstance as SelectSingleValueTestComponent;

			cmpInstance.form?.get('fruit')?.addValidators(Validators.required);
			cmpInstance.form?.get('fruit')?.updateValueAndValidity();
			fixture.detectChanges();

			// open
			await user.click(trigger);
			// close
			await user.click(trigger);

			expect(cmpInstance.brnSelectComponent()?.errorState()).toBeTruthy();
			expect(cmpInstance.form?.get('fruit')?.value).toEqual(null);
		});

		it('should reflect initial single value set on formcontrol', async () => {
			const { fixture, trigger, value } = await setupWithFormValidationAndInitialValue();
			const cmpInstance = fixture.componentInstance as SelectSingleValueTestComponent;

			const expected = {
				untouched: true,
				touched: false,
				valid: true,
				invalid: false,
				pristine: true,
				dirty: false,
			};

			expect(getFormControlStatus(cmpInstance.form?.get('fruit'))).toStrictEqual(expected);
			expect(getFormValidationClasses(trigger)).toStrictEqual(expected);

			expect(value.textContent?.trim()).toBe(INITIAL_VALUE_TEXT);
			expect(cmpInstance.form?.get('fruit')?.value).toEqual(INITIAL_VALUE);
		});
	});
});

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/select/src/lib/tests/utils.ts
```typescript
import type { AbstractControl } from '@angular/forms';

export interface ExpectedFormStatus {
	[key: string]: boolean | string | null;
	untouched: boolean | string | null;
	valid: boolean | string | null;
	pristine: boolean | string | null;
	touched: boolean | string | null;
	invalid: boolean | string | null;
	dirty: boolean | string | null;
}

export const getFormControlStatus = (
	formControl: AbstractControl<string | string[] | null, string | string[] | null> | null,
) => {
	const actualValues: ExpectedFormStatus = {
		untouched: null,
		valid: null,
		pristine: null,
		touched: null,
		invalid: null,
		dirty: null,
	};
	for (const status in actualValues) {
		actualValues[status] = formControl?.[status as keyof typeof formControl] as boolean;
	}
	return actualValues;
};

export const getFormValidationClasses = (el: HTMLElement): ExpectedFormStatus => {
	const actualValues: ExpectedFormStatus = {
		untouched: null,
		valid: null,
		pristine: null,
		touched: null,
		invalid: null,
		dirty: null,
	};
	for (const status in actualValues) {
		actualValues[status] = el.classList.contains(`ng-${status}`);
	}
	return actualValues;
};

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/sheet/README.md
```
# @spartan-ng/brain/sheet

Secondary entry point of `@spartan-ng/brain`. It can be used by importing from `@spartan-ng/brain/sheet`.

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/sheet/ng-package.json
```json
{
	"lib": {
		"entryFile": "src/index.ts"
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/sheet/src/index.ts
```typescript
import { NgModule } from '@angular/core';

import { BrnSheetCloseDirective } from './lib/brn-sheet-close.directive';
import { BrnSheetContentDirective } from './lib/brn-sheet-content.directive';
import { BrnSheetDescriptionDirective } from './lib/brn-sheet-description.directive';
import { BrnSheetOverlayComponent } from './lib/brn-sheet-overlay.component';
import { BrnSheetTitleDirective } from './lib/brn-sheet-title.directive';
import { BrnSheetTriggerDirective } from './lib/brn-sheet-trigger.directive';
import { BrnSheetComponent } from './lib/brn-sheet.component';

export * from './lib/brn-sheet-close.directive';
export * from './lib/brn-sheet-content.directive';
export * from './lib/brn-sheet-description.directive';
export * from './lib/brn-sheet-overlay.component';
export * from './lib/brn-sheet-title.directive';
export * from './lib/brn-sheet-trigger.directive';
export * from './lib/brn-sheet.component';

export const BrnSheetImports = [
	BrnSheetComponent,
	BrnSheetOverlayComponent,
	BrnSheetTriggerDirective,
	BrnSheetCloseDirective,
	BrnSheetContentDirective,
	BrnSheetTitleDirective,
	BrnSheetDescriptionDirective,
] as const;

@NgModule({
	imports: [...BrnSheetImports],
	exports: [...BrnSheetImports],
})
export class BrnSheetModule {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/sheet/src/lib/brn-sheet-close.directive.ts
```typescript
import { Directive } from '@angular/core';
import { BrnDialogCloseDirective } from '@spartan-ng/brain/dialog';

@Directive({
	selector: 'button[brnSheetClose]',
	standalone: true,
})
export class BrnSheetCloseDirective extends BrnDialogCloseDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/sheet/src/lib/brn-sheet-content.directive.ts
```typescript
import { Directive, inject } from '@angular/core';
import {
	type ExposesSide,
	provideExposedSideProviderExisting,
	provideExposesStateProviderExisting,
} from '@spartan-ng/brain/core';
import { BrnDialogContentDirective } from '@spartan-ng/brain/dialog';
import { BrnSheetComponent } from './brn-sheet.component';

@Directive({
	selector: '[brnSheetContent]',
	standalone: true,
	providers: [
		provideExposesStateProviderExisting(() => BrnSheetContentDirective),
		provideExposedSideProviderExisting(() => BrnSheetContentDirective),
	],
})
export class BrnSheetContentDirective<T> extends BrnDialogContentDirective<T> implements ExposesSide {
	public readonly side = inject(BrnSheetComponent).side;
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/sheet/src/lib/brn-sheet-description.directive.ts
```typescript
import { Directive } from '@angular/core';
import { BrnDialogDescriptionDirective } from '@spartan-ng/brain/dialog';

@Directive({
	selector: '[brnSheetDescription]',
	standalone: true,
	host: {
		'[id]': '_id()',
	},
})
export class BrnSheetDescriptionDirective extends BrnDialogDescriptionDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/sheet/src/lib/brn-sheet-overlay.component.ts
```typescript
import { ChangeDetectionStrategy, Component, ViewEncapsulation } from '@angular/core';
import { provideCustomClassSettableExisting } from '@spartan-ng/brain/core';
import { BrnDialogOverlayComponent } from '@spartan-ng/brain/dialog';

@Component({
	selector: 'brn-sheet-overlay',
	standalone: true,
	providers: [provideCustomClassSettableExisting(() => BrnSheetOverlayComponent)],
	template: '',
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
})
export class BrnSheetOverlayComponent extends BrnDialogOverlayComponent {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/sheet/src/lib/brn-sheet-title.directive.ts
```typescript
import { Directive } from '@angular/core';
import { BrnDialogTitleDirective } from '@spartan-ng/brain/dialog';

@Directive({
	selector: '[brnSheetTitle]',
	standalone: true,
	host: {
		'[id]': '_id()',
	},
})
export class BrnSheetTitleDirective extends BrnDialogTitleDirective {}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/sheet/src/lib/brn-sheet-trigger.directive.ts
```typescript
import { Directive, inject, input } from '@angular/core';
import { BrnDialogTriggerDirective } from '@spartan-ng/brain/dialog';
import { BrnSheetComponent } from './brn-sheet.component';

@Directive({
	selector: 'button[brnSheetTrigger]',
	standalone: true,
})
export class BrnSheetTriggerDirective extends BrnDialogTriggerDirective {
	private readonly _sheet = inject(BrnSheetComponent, { optional: true });

	public side = input<'top' | 'bottom' | 'left' | 'right' | undefined>(undefined);

	override open() {
		const side = this.side();
		if (this._sheet && side) {
			this._sheet.sideInputState().set(side);
		}
		super.open();
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/sheet/src/lib/brn-sheet.component.ts
```typescript
import {
	ChangeDetectionStrategy,
	Component,
	computed,
	effect,
	forwardRef,
	input,
	signal,
	untracked,
	ViewEncapsulation,
} from '@angular/core';
import { BrnDialogComponent } from '@spartan-ng/brain/dialog';

@Component({
	selector: 'brn-sheet',
	standalone: true,
	template: `
		<ng-content />
	`,
	providers: [
		{
			provide: BrnDialogComponent,
			useExisting: forwardRef(() => BrnSheetComponent),
		},
	],
	changeDetection: ChangeDetectionStrategy.OnPush,
	encapsulation: ViewEncapsulation.None,
	exportAs: 'brnSheet',
})
export class BrnSheetComponent extends BrnDialogComponent {
	public readonly sideInput = input<'top' | 'bottom' | 'left' | 'right'>('top', { alias: 'side' });
	public readonly sideInputState = computed(() => signal(this.sideInput()));
	public readonly side = computed(() => this.sideInputState().asReadonly()());
	constructor() {
		super();
		effect(() => {
			const side = this.side();
			untracked(() => {
				if (side === 'top') {
					this.mutablePositionStrategy().set(this.positionBuilder.global().top());
				}
				if (side === 'bottom') {
					this.mutablePositionStrategy().set(this.positionBuilder.global().bottom());
				}
				if (side === 'left') {
					this.mutablePositionStrategy().set(this.positionBuilder.global().left());
				}
				if (side === 'right') {
					this.mutablePositionStrategy().set(this.positionBuilder.global().right());
				}
			});
		});
	}
}

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/src/index.ts
```typescript
// this file can't be empty, otherwise the build will fail
export default true;

```
/Users/josh/Documents/GitHub/spartan-ng/spartan/libs/brain/src/test-setup.ts
```typescript
import '@testing-library/jest-dom';
import { setupZoneTestEnv } from 'jest-preset-angular/setup-env/zone';

setupZoneTestEnv();

import { toHaveNoViolations } from 'jest-axe';

expect.extend(toHaveNoViolations);

```
