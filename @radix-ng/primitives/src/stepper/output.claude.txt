<documents>
<document index="1">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/README.md</source>
<document_content>
# @radix-ng/primitives/stepper

</document_content>
</document>
<document index="2">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/index.ts</source>
<document_content>
import { NgModule } from '@angular/core';
import { RdxStepperDescriptionDirective } from './src/stepper-description.directive';
import { RdxStepperIndicatorDirective } from './src/stepper-indicator.directive';
import { RdxStepperItemDirective } from './src/stepper-item.directive';
import { RdxStepperRootDirective } from './src/stepper-root.directive';
import { RdxStepperSeparatorDirective } from './src/stepper-separator.directive';
import { RdxStepperTitleDirective } from './src/stepper-title.directive';
import { RdxStepperTriggerDirective } from './src/stepper-trigger.directive';

export * from './src/stepper-description.directive';
export * from './src/stepper-indicator.directive';
export * from './src/stepper-item.directive';
export * from './src/stepper-root-context.token';
export * from './src/stepper-root.directive';
export * from './src/stepper-separator.directive';
export * from './src/stepper-title.directive';
export * from './src/stepper-trigger.directive';
export * from './src/types';

const _imports = [
    RdxStepperDescriptionDirective,
    RdxStepperTitleDirective,
    RdxStepperSeparatorDirective,
    RdxStepperItemDirective,
    RdxStepperIndicatorDirective,
    RdxStepperRootDirective,
    RdxStepperTriggerDirective
];

@NgModule({
    imports: [..._imports],
    exports: [..._imports]
})
export class RdxStepperModule {}

</document_content>
</document>
<document index="3">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/ng-package.json</source>
<document_content>
{
    "lib": {
        "entryFile": "index.ts"
    }
}

</document_content>
</document>
<document index="4">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/stories/stepper-navigation.component.ts</source>
<document_content>
import { Component, computed, signal } from '@angular/core';
import { ChevronLeft, ChevronRight, LucideAngularModule } from 'lucide-angular';
import { RdxStepperModule } from '../index';

@Component({
    selector: 'StepperNavigation',
    imports: [RdxStepperModule, LucideAngularModule],
    template: `
        <div class="StepperContainer">
            <div class="StepperNavigation">
                <button
                    class="StepperButton Button violet"
                    [disabled]="isFirstStep()"
                    (click)="prevStep()"
                    aria-label="Prev step"
                >
                    <lucide-angular
                        [img]="ChevronLeft"
                        size="16"
                        strokeWidth="2"
                        style="display: flex;"
                        aria-hidden="true"
                    />
                </button>

                <div class="Stepper" [value]="currentStep()" rdxStepperRoot>
                    @for (item of steps; track $index) {
                        <div class="StepperItem" [step]="item" rdxStepperItem>
                            <button class="StepperTrigger" rdxStepperTrigger>
                                <div class="StepperIndicator" rdxStepperIndicator>
                                    <span class="sr-only">{{ item }}</span>
                                </div>
                            </button>
                        </div>
                    }
                </div>

                <button
                    class="StepperButton Button violet"
                    [disabled]="isLastStep()"
                    (click)="nextStep()"
                    aria-label="Next step"
                >
                    <lucide-angular
                        [img]="ChevronRight"
                        style="display: flex;"
                        size="16"
                        strokeWidth="2"
                        aria-hidden="true"
                    />
                </button>
            </div>

            <p class="StepperPagination" role="region" aria-live="polite">Paginated stepper</p>
        </div>
    `,
    styles: `
        :host {
            button {
                all: unset;
            }
        }

        .StepperContainer {
            margin-left: auto;
            margin-right: auto;
            max-width: 40rem;
            text-align: center;
        }

        /* Контейнер шагов */
        .StepperNavigation {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .StepperButton {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 2.5rem;
            height: 2rem;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 4px;
        }

        .StepperButton:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .Stepper {
            display: flex;
            gap: 0.25rem;
            flex-grow: 1;
        }

        .StepperItem {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .StepperTrigger {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            width: 100%;
            gap: 0.5rem;
        }

        .StepperTrigger:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--gray-2);
            border-radius: 9999px;
        }

        .StepperIndicator {
            width: 100%;
            height: 4px;
            background-color: var(--border);
            border-radius: 4px;
        }

        .StepperItem[data-state='inactive'] .StepperIndicator {
            background-color: rgba(0, 0, 0, 0.38);
        }

        .StepperItem[data-state='active'] .StepperIndicator {
            background-color: #000;
        }

        .StepperItem[data-state='completed'] .StepperIndicator {
            background-color: var(--green-9);
        }

        .StepperPagination {
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: var(--white-a10);
        }

        .Button.violet {
            background-color: white;
            color: var(--violet-11);
            box-shadow: 0 2px 10px var(--black-a7);
        }

        .Button.violet:hover {
            background-color: var(--mauve-3);
        }

        .Button.violet:focus {
            box-shadow: 0 0 0 2px black;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
    `
})
export class StepperNavigationComponent {
    steps = [1, 2, 3, 4];

    readonly currentStep = signal(2);

    isFirstStep = computed(() => this.currentStep() === 1);
    isLastStep = computed(() => this.currentStep() === this.steps.length);

    prevStep() {
        if (!this.isFirstStep()) {
            this.currentStep.set(this.currentStep() - 1);
        }
    }

    nextStep() {
        if (!this.isLastStep()) {
            this.currentStep.set(this.currentStep() + 1);
        }
    }

    protected readonly ChevronLeft = ChevronLeft;
    protected readonly ChevronRight = ChevronRight;
}

</document_content>
</document>
<document index="5">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/stories/stepper.docs.mdx</source>
<document_content>
import { ArgTypes, Canvas, Meta } from '@storybook/blocks';
import * as Stories from './stepper.stories';
import {RdxStepperRootDirective} from "../src/stepper-root.directive";
import {RdxStepperItemDirective} from "../src/stepper-item.directive";

<Meta title="Primitives/Stepper" />

# Stepper

####  A set of steps that are used to indicate progress through a multi-step process.

<Canvas sourceState="hidden" of={Stories.Default} />

## Features

- ✅ Can be controlled or uncontrolled.
- ✅ Supports horizontal/vertical orientation.
- ✅ Supports linear/non-linear activation.
- ✅ Full keyboard navigation.

## Anatomy

Import all parts and piece them together.

```html
<div rdxStepperRoot >
    <div rdxStepperItem >
        <div rdxStepperSeparator></div>
        <button rdxStepperTrigger>
            <div rdxStepperIndicator></div>
        </button>

        <h4 rdxStepperTitle></h4>
        <p rdxStepperDescription></p>
    </div>
</div>
```

## API Reference

### Root

`RdxStepperRootDirective`

<ArgTypes of={RdxStepperRootDirective} />

### Item

`RdxStepperItemDirective`

The step item component.

<ArgTypes of={RdxStepperItemDirective} />

## Examples

### Vertical

<Canvas sourceState="hidden" of={Stories.Vertical} />

### Navigation

<Canvas sourceState="hidden" of={Stories.Navigation} />

</document_content>
</document>
<document index="6">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/stories/stepper.stories.ts</source>
<document_content>
import { componentWrapperDecorator, Meta, moduleMetadata, StoryObj } from '@storybook/angular';
import { RdxStepperIndicatorDirective } from '../src/stepper-indicator.directive';
import { RdxStepperItemDirective } from '../src/stepper-item.directive';
import { RdxStepperRootDirective } from '../src/stepper-root.directive';
import { RdxStepperSeparatorDirective } from '../src/stepper-separator.directive';
import { RdxStepperTriggerDirective } from '../src/stepper-trigger.directive';
import { StepperNavigationComponent } from './stepper-navigation.component';

const html = String.raw;

export default {
    title: 'Primitives/Stepper',
    decorators: [
        moduleMetadata({
            imports: [
                RdxStepperRootDirective,
                RdxStepperItemDirective,
                RdxStepperTriggerDirective,
                RdxStepperIndicatorDirective,
                RdxStepperSeparatorDirective,
                StepperNavigationComponent
            ]
        }),
        componentWrapperDecorator(
            (story) => html`
                <div class="radix-themes light light-theme" data-radius="medium" data-scaling="100%">
                    ${story}

                    <style>
                        button {
                            all: unset;
                        }

                        /* StepperList */
                        .StepperList {
                            display: flex;
                            gap: 1rem;
                            max-width: 36rem;
                            width: 100%;
                            flex-direction: row;
                        }

                        .StepperList[data-orientation='vertical'] {
                            flex-direction: column;
                            max-width: 16rem;
                            /*align-items: center;*/
                            display: flex;
                        }

                        /* StepperItem */
                        .StepperItem {
                            padding-left: 1rem;
                            padding-right: 1rem;
                            position: relative;
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                        }

                        .StepperItem[data-orientation='vertical'] {
                            display: block;
                            padding: 0;
                        }

                        /* Disabled state */
                        .StepperItem[data-disabled] {
                            pointer-events: none;
                        }

                        .StepperItem[data-disabled] .StepperIndicator {
                            color: #9ca3af;
                        }

                        .StepperItem[data-disabled='true'] {
                            opacity: 0.5;
                            cursor: not-allowed;
                        }

                        /* Stepper states */
                        .StepperItem[data-state='inactive'] .StepperIndicator {
                            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.38);
                            background-color: rgba(0, 0, 0, 0.38);
                            color: white;
                        }

                        .StepperItem[data-state='active'] .StepperIndicator {
                            background-color: #000;
                            color: #fff;
                            box-shadow: 0 0 0 2px #000;
                        }

                        .StepperItem[data-state='completed'] .StepperIndicator {
                            background-color: var(--green-9);
                            color: #fff;
                            box-shadow: 0 0 0 2px var(--green-9);
                        }

                        /* StepperIndicator */
                        .StepperIndicator {
                            display: inline-flex;
                            align-items: center;
                            justify-content: center;
                            border-radius: 9999px;
                            width: 1.5rem;
                            height: 1.5rem;
                            color: var(--grass-11);
                            box-shadow: 0 0 0 2px #000;
                        }

                        .StepperIndicator[data-orientation='vertical'] {
                            margin-bottom: 0.5rem;
                        }

                        /* Stepper text elements */
                        .StepperItemText {
                            text-align: center;
                            top: 100%;
                            left: 0;
                            width: 100%;
                            margin-top: 0.5rem;
                            color: #57534e;
                        }

                        .StepperItemText[data-orientation='vertical'] {
                            text-align: left;
                            margin-top: -50px;
                            margin-left: 2.5rem;
                        }

                        .StepperTitle {
                            font-size: 0.875rem;
                            font-weight: 500;
                            color: white;
                        }

                        .StepperDescription {
                            font-size: 0.75rem;
                            color: white;
                        }

                        /* StepperSeparator */
                        .StepperSeparator {
                            position: absolute;
                            height: 1px;
                            left: calc(50% + 30px);
                            right: calc(-50% + 20px);
                            top: 21px;
                            background-color: var(--green-5);
                        }

                        .StepperSeparator[data-orientation='vertical'] {
                            width: 1px;
                            height: 70%;
                            top: 50%;
                            left: 8%;
                            right: auto;
                        }

                        /* StepperTrigger */
                        .StepperTrigger {
                            display: flex;
                            cursor: pointer;
                            gap: 0.5rem;
                            width: 2.5rem;
                            height: 2.5rem;
                            align-items: center;
                            justify-content: center;
                        }

                        .StepperTrigger:focus {
                            box-shadow: 0 0 0 2px black;
                            border-radius: 9999px;
                        }
                    </style>
                </div>
            `
        )
    ]
} as Meta;

type Story = StoryObj;

const steps = [
    {
        step: 1,
        title: 'Address',
        description: 'Add your address here',
        icon: 'radix-icons:home'
    },
    {
        step: 2,
        title: 'Shipping',
        description: 'Set your preferred shipping method',
        icon: 'radix-icons:archive'
    },
    {
        step: 3,
        title: 'Trade-in',
        description: 'Add any trade-in items you have',
        icon: 'radix-icons:update'
    },
    {
        step: 4,
        title: 'Payment',
        description: 'Add any payment information you have',
        icon: 'radix-icons:sketch-logo'
    },
    {
        step: 5,
        title: 'Checkout',
        description: 'Confirm your order',
        icon: 'radix-icons:check'
    }
];

export const Default: Story = {
    render: () => ({
        props: {
            steps: steps
        },
        template: `
            <div rdxStepperRoot [value]="2" class="StepperList">
                @for (item of steps; track $index) {
                    <div rdxStepperItem [step]="item.step" class="StepperItem">
                        @if (item.step !== steps[steps.length - 1].step) {
                            <div rdxStepperSeparator class="StepperSeparator"></div>
                        }
                        <button rdxStepperTrigger class="StepperTrigger">
                            <div rdxStepperIndicator class="StepperIndicator">{{$index+1}}</div>
                        </button>
                        <div class="StepperItemText">
                            <h4 class="StepperTitle">
                               {{ item.title }}
                            </h4>
                            <p class="StepperDescription">
                               {{ item.description }}
                            </p>
                        </div>
                    </div>
                }
            </div>
        `
    })
};

export const Vertical: Story = {
    render: () => ({
        props: {
            steps: steps
        },
        template: `
            <div rdxStepperRoot [value]="2" orientation="vertical" class="StepperList">
                @for (item of steps; track $index) {
                    <div rdxStepperItem [step]="item.step" class="StepperItem">
                        @if (item.step !== steps[steps.length - 1].step) {
                            <div rdxStepperSeparator class="StepperSeparator"></div>
                        }
                        <button rdxStepperTrigger class="StepperTrigger">
                            <div rdxStepperIndicator class="StepperIndicator">{{$index+1}}</div>
                        </button>
                        <div class="StepperItemText" data-orientation='vertical'>
                            <h4 class="StepperTitle">
                               {{ item.title }}
                            </h4>
                            <p class="StepperDescription">
                               {{ item.description }}
                            </p>
                        </div>
                    </div>
                }
            </div>
        `
    })
};

export const Navigation: Story = {
    render: () => ({
        props: {
            steps: [1, 2, 3, 4]
        },
        template: `
              <StepperNavigation />
        `
    })
};

</document_content>
</document>
<document index="7">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/stepper-description.directive.ts</source>
<document_content>
import { Directive } from '@angular/core';
import { injectStepperItemContext } from './stepper-item-context.token';

@Directive({
    selector: '[rdxStepperDescription]',
    host: {
        '[attr.id]': 'itemContext.descriptionId'
    }
})
export class RdxStepperDescriptionDirective {
    readonly itemContext = injectStepperItemContext();
}

</document_content>
</document>
<document index="8">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/stepper-indicator.directive.ts</source>
<document_content>
import { Directive } from '@angular/core';
import { injectStepperItemContext } from './stepper-item-context.token';

@Directive({
    selector: '[rdxStepperIndicator]',
    exportAs: 'rdxStepperIndicator'
})
export class RdxStepperIndicatorDirective {
    readonly itemContext = injectStepperItemContext();
}

</document_content>
</document>
<document index="9">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/stepper-item-context.token.ts</source>
<document_content>
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import { inject, InjectionToken, InputSignalWithTransform, Signal } from '@angular/core';
import { StepperState } from './types';

export interface StepperItemContext {
    titleId: string;
    descriptionId: string;
    step: InputSignalWithTransform<number, NumberInput>;
    disabled: InputSignalWithTransform<boolean, BooleanInput>;
    isFocusable: Signal<boolean>;
    itemState: Signal<StepperState>;
}

export const STEPPER_ITEM_CONTEXT = new InjectionToken<StepperItemContext>('StepperItemContext');

export function injectStepperItemContext(): StepperItemContext {
    return inject(STEPPER_ITEM_CONTEXT);
}

</document_content>
</document>
<document index="10">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/stepper-item.directive.ts</source>
<document_content>
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import { booleanAttribute, computed, Directive, forwardRef, inject, input, numberAttribute } from '@angular/core';
import { _IdGenerator } from '@radix-ng/primitives/core';
import { STEPPER_ITEM_CONTEXT, StepperItemContext } from './stepper-item-context.token';
import { injectStepperRootContext } from './stepper-root-context.token';
import { StepperState } from './types';

@Directive({
    selector: '[rdxStepperItem]',
    providers: [
        {
            provide: STEPPER_ITEM_CONTEXT,
            useExisting: forwardRef(() => RdxStepperItemDirective)
        }
    ],
    host: {
        '[attr.aria-current]': 'itemState() === "active" ? true : undefined',

        '[attr.data-state]': 'itemState()',
        '[attr.disabled]': 'disabled() || !isFocusable() ? "" : undefined',
        '[attr.data-disabled]': 'disabled() || !isFocusable() ? "" : undefined',
        '[attr.data-orientation]': 'rootContext.orientation()'
    }
})
export class RdxStepperItemDirective implements StepperItemContext {
    protected readonly rootContext = injectStepperRootContext();

    /** @ignore */
    readonly titleId = inject(_IdGenerator).getId('rdx-stepper-item-title');

    /** @ignore */
    readonly descriptionId = inject(_IdGenerator).getId('rdx-stepper-item-description');

    readonly step = input<number, NumberInput>(NaN, { transform: numberAttribute });

    readonly disabled = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /** @ignore */
    readonly completed = input<boolean, BooleanInput>(false, { transform: booleanAttribute });

    /** @ignore */
    readonly itemState = computed<StepperState>(() => {
        if (this.completed()) return 'completed';
        if (this.rootContext.value() === this.step()) return 'active';

        const step = this.step() ?? 1;
        if (this.rootContext.value()! > step) {
            return 'completed';
        }

        return 'inactive';
    });

    /** @ignore */
    readonly isFocusable = computed(() => {
        if (this.disabled()) return false;

        const step = this.step() ?? 1;
        if (this.rootContext.linear()) {
            return step <= this.rootContext.value()! || step === this.rootContext.value()! + 1;
        }

        return true;
    });
}

</document_content>
</document>
<document index="11">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/stepper-root-context.token.ts</source>
<document_content>
import { Direction } from '@angular/cdk/bidi';
import { BooleanInput } from '@angular/cdk/coercion';
import {
    inject,
    InjectionToken,
    InputSignal,
    InputSignalWithTransform,
    ModelSignal,
    WritableSignal
} from '@angular/core';

export interface StepperRootContext {
    value: ModelSignal<number | undefined>;
    orientation: InputSignal<'vertical' | 'horizontal'>;
    dir: InputSignal<Direction>;
    linear: InputSignalWithTransform<boolean, BooleanInput>;
    totalStepperItems: WritableSignal<HTMLElement[]>;
}

export const STEPPER_ROOT_CONTEXT = new InjectionToken<StepperRootContext>('StepperRootContext');

export function injectStepperRootContext(): StepperRootContext {
    return inject(STEPPER_ROOT_CONTEXT);
}

</document_content>
</document>
<document index="12">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/stepper-root.directive.ts</source>
<document_content>
import { LiveAnnouncer } from '@angular/cdk/a11y';
import { Direction } from '@angular/cdk/bidi';
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import {
    booleanAttribute,
    computed,
    Directive,
    effect,
    forwardRef,
    inject,
    input,
    model,
    numberAttribute,
    output,
    signal
} from '@angular/core';
import { STEPPER_ROOT_CONTEXT, StepperRootContext } from './stepper-root-context.token';

@Directive({
    selector: '[rdxStepperRoot]',
    exportAs: 'rdxStepperRoot',
    providers: [
        {
            provide: STEPPER_ROOT_CONTEXT,
            useExisting: forwardRef(() => RdxStepperRootDirective)
        }
    ],
    host: {
        role: 'group',
        '[attr.aria-label]': '"progress"',
        '[attr.data-linear]': 'linear() ? "" : undefined',
        '[attr.data-orientation]': 'orientation()'
    }
})
export class RdxStepperRootDirective implements StepperRootContext {
    private readonly liveAnnouncer = inject(LiveAnnouncer);

    readonly defaultValue = input<number, NumberInput>(undefined, { transform: numberAttribute });

    readonly value = model<number | undefined>(this.defaultValue());

    readonly linear = input<boolean, BooleanInput>(true, { transform: booleanAttribute });

    readonly dir = input<Direction>('ltr');

    readonly orientation = input<'vertical' | 'horizontal'>('horizontal');

    /** @ignore */
    readonly totalStepperItemsArray = computed(() => Array.from(this.totalStepperItems()));

    readonly onValueChange = output<number>();

    /** @ignore */
    readonly isFirstStep = computed(() => this.value() === 1);

    /** @ignore */
    readonly isLastStep = computed(() => this.value() === this.totalStepperItemsArray().length);

    /** @ignore */
    readonly totalSteps = computed(() => this.totalStepperItems().length);

    /** @ignore */
    readonly isNextDisabled = computed<boolean>(() => {
        const item = this.nextStepperItem();
        return item ? item.hasAttribute('disabled') : true;
    });

    /** @ignore */
    readonly isPrevDisabled = computed<boolean>(() => {
        const item = this.prevStepperItem();
        return item ? item.hasAttribute('disabled') : true;
    });

    /** @ignore */
    readonly totalStepperItems = signal<HTMLElement[]>([]);

    private readonly nextStepperItem = signal<HTMLElement | null>(null);
    private readonly prevStepperItem = signal<HTMLElement | null>(null);

    constructor() {
        effect(() => {
            const items = this.totalStepperItemsArray();
            const currentValue = this.value();

            if (currentValue) {
                if (items.length && currentValue < items.length) {
                    this.nextStepperItem.set(items[currentValue]);
                } else {
                    this.nextStepperItem.set(null);
                }

                if (items.length && currentValue > 1) {
                    this.prevStepperItem.set(items[currentValue - 2]);
                } else {
                    this.prevStepperItem.set(null);
                }

                this.onValueChange.emit(currentValue);
                this.liveAnnouncer.announce(`Step ${currentValue} of ${items.length}`);
            }
        });
    }

    goToStep(step: number) {
        if (step > this.totalSteps()) {
            return;
        }

        if (step < 1) {
            return;
        }

        if (
            this.totalStepperItems().length &&
            !!this.totalStepperItemsArray()[step] &&
            this.totalStepperItemsArray()[step].hasAttribute('disabled')
        ) {
            return;
        }

        if (this.linear()) {
            const currentValue = this.value() ?? 1;
            if (step > currentValue + 1) {
                return;
            }
        }
        this.value.set(step);
        this.onValueChange.emit(step);
    }
}

</document_content>
</document>
<document index="13">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/stepper-separator.directive.ts</source>
<document_content>
import { Directive, effect, inject } from '@angular/core';
import { RdxSeparatorRootDirective } from '@radix-ng/primitives/separator';
import { injectStepperItemContext } from './stepper-item-context.token';
import { injectStepperRootContext } from './stepper-root-context.token';

@Directive({
    selector: '[rdxStepperSeparator]',
    hostDirectives: [{ directive: RdxSeparatorRootDirective, inputs: ['orientation', 'decorative'] }],
    host: {
        '[attr.data-state]': 'itemContext.itemState()'
    }
})
export class RdxStepperSeparatorDirective {
    protected readonly rootContext = injectStepperRootContext();
    protected readonly itemContext = injectStepperItemContext();

    private readonly rdxSeparator = inject(RdxSeparatorRootDirective, { host: true });

    constructor() {
        effect(() => {
            this.rdxSeparator.updateDecorative(true);
            this.rdxSeparator.updateOrientation(this.rootContext.orientation());
        });
    }
}

</document_content>
</document>
<document index="14">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/stepper-title.directive.ts</source>
<document_content>
import { Directive } from '@angular/core';
import { injectStepperItemContext } from './stepper-item-context.token';

@Directive({
    selector: '[rdxStepperTitle]',
    host: {
        '[attr.id]': 'itemContext.titleId'
    }
})
export class RdxStepperTitleDirective {
    readonly itemContext = injectStepperItemContext();
}

</document_content>
</document>
<document index="15">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/stepper-trigger.directive.ts</source>
<document_content>
import { computed, Directive, ElementRef, inject, OnDestroy, OnInit } from '@angular/core';
import * as kbd from '@radix-ng/primitives/core';
import { injectStepperItemContext } from './stepper-item-context.token';
import { injectStepperRootContext } from './stepper-root-context.token';
import { getActiveElement } from './utils/getActiveElement';
import { useArrowNavigation } from './utils/useArrowNavigation';

// as button
@Directive({
    selector: 'button[rdxStepperTrigger]',
    host: {
        '[attr.tabindex]': 'itemContext.isFocusable() ? 0 : -1',
        '[attr.aria-describedby]': 'itemContext.descriptionId',
        '[attr.aria-labelledby]': 'itemContext.titleId',

        '[attr.data-state]': 'itemContext.itemState()',
        '[attr.data-orientation]': 'rootContext.orientation()',
        '[attr.disabled]': 'itemContext.disabled() || !itemContext.isFocusable() ? "" : undefined',
        '[attr.data-disabled]': 'itemContext.disabled() || !itemContext.isFocusable() ? "" : undefined',

        '(mousedown)': 'handleMouseDown($event)',

        '(keydown.Enter)': 'handleKeyDown($event)',
        '(keydown.Space)': 'handleKeyDown($event)',
        '(keydown.ArrowLeft)': 'handleKeyDown($event)',
        '(keydown.ArrowRight)': 'handleKeyDown($event)',
        '(keydown.ArrowUp)': 'handleKeyDown($event)',
        '(keydown.ArrowDown)': 'handleKeyDown($event)'
    }
})
export class RdxStepperTriggerDirective implements OnInit, OnDestroy {
    protected readonly rootContext = injectStepperRootContext();
    protected readonly itemContext = injectStepperItemContext();

    private readonly elementRef = inject(ElementRef);

    readonly stepperItems = computed(() => Array.from(this.rootContext.totalStepperItems()));

    ngOnInit() {
        const current = this.rootContext.totalStepperItems();
        this.rootContext.totalStepperItems.set([...current, this.elementRef.nativeElement]);
    }

    ngOnDestroy() {
        const current = this.rootContext.totalStepperItems();
        const updated = current.filter((el: HTMLElement) => el !== this.elementRef.nativeElement);

        this.rootContext.totalStepperItems.set(updated);
    }

    handleMouseDown(event: MouseEvent) {
        if (this.itemContext.disabled()) {
            return;
        }

        // handler only left mouse click
        if (event.button !== 0) {
            return;
        }

        if (this.rootContext.linear()) {
            if (
                this.itemContext.step() <= this.rootContext.value()! ||
                this.itemContext.step() === this.rootContext.value()! + 1
            ) {
                if (!event.ctrlKey) {
                    this.rootContext.value.set(this.itemContext.step());
                    return;
                }
            }
        } else {
            if (!event.ctrlKey) {
                this.rootContext.value.set(this.itemContext.step());
                return;
            }
        }

        // prevent focus to avoid accidental activation
        event.preventDefault();
    }

    handleKeyDown(event: KeyboardEvent) {
        event.preventDefault();

        if (this.itemContext.disabled()) {
            return;
        }

        if ((event.key === kbd.ENTER || event.key === kbd.SPACE) && !event.ctrlKey && !event.shiftKey)
            this.rootContext.value.set(this.itemContext.step());

        if ([kbd.ARROW_LEFT, kbd.ARROW_RIGHT, kbd.ARROW_UP, kbd.ARROW_DOWN].includes(event.key)) {
            useArrowNavigation(event, getActiveElement() as HTMLElement, undefined, {
                itemsArray: this.stepperItems() as HTMLElement[],
                focus: true,
                loop: false,
                arrowKeyOptions: this.rootContext.orientation(),
                dir: this.rootContext.dir()
            });
        }
    }
}

</document_content>
</document>
<document index="16">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/types.ts</source>
<document_content>
export type StepperState = 'completed' | 'active' | 'inactive';

</document_content>
</document>
<document index="17">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/utils/getActiveElement.ts</source>
<document_content>
export function getActiveElement(): Element | null {
    let activeElement = document.activeElement;
    if (activeElement == null) {
        return null;
    }

    while (
        activeElement != null &&
        activeElement.shadowRoot != null &&
        activeElement.shadowRoot.activeElement != null
    ) {
        activeElement = activeElement.shadowRoot.activeElement;
    }

    return activeElement;
}

</document_content>
</document>
<document index="18">
<source>/Users/josh/Documents/GitHub/radix-ng/primitives/packages/primitives/stepper/src/utils/useArrowNavigation.ts</source>
<document_content>
// made by https://reka-ui.com/

import { Direction } from '@angular/cdk/bidi';

type ArrowKeyOptions = 'horizontal' | 'vertical' | 'both';

interface ArrowNavigationOptions {
    /**
     * The arrow key options to allow navigation
     *
     * @defaultValue "both"
     */
    arrowKeyOptions?: ArrowKeyOptions;

    /**
     * The attribute name to find the collection items in the parent element.
     *
     * @defaultValue "data-reka-collection-item"
     */
    attributeName?: string;

    /**
     * The parent element where contains all the collection items, this will collect every item to be used when nav
     * It will be ignored if attributeName is provided
     *
     * @defaultValue []
     */
    itemsArray?: HTMLElement[];

    /**
     * Allow loop navigation. If false, it will stop at the first and last element
     *
     * @defaultValue true
     */
    loop?: boolean;

    /**
     * The orientation of the collection
     *
     * @defaultValue "ltr"
     */
    dir?: Direction;

    /**
     * Prevent the scroll when navigating. This happens when the direction of the
     * key matches the scroll direction of any ancestor scrollable elements.
     *
     * @defaultValue true
     */
    preventScroll?: boolean;

    /**
     * By default all currentElement would trigger navigation. If `true`, currentElement nodeName in the ignore list will return null
     *
     * @defaultValue false
     */
    enableIgnoredElement?: boolean;

    /**
     * Focus the element after navigation
     *
     * @defaultValue false
     */
    focus?: boolean;
}

const ignoredElement = ['INPUT', 'TEXTAREA'];

/**
 * Allow arrow navigation for every html element with data-reka-collection-item tag
 *
 * @param e               Keyboard event
 * @param currentElement  Event initiator element or any element that wants to handle the navigation
 * @param parentElement   Parent element where contains all the collection items, this will collect every item to be used when nav
 * @param options         further options
 * @returns               the navigated html element or null if none
 */
export function useArrowNavigation(
    e: KeyboardEvent,
    currentElement: HTMLElement,
    parentElement: HTMLElement | undefined,
    options: ArrowNavigationOptions = {}
): HTMLElement | null {
    if (!currentElement || (options.enableIgnoredElement && ignoredElement.includes(currentElement.nodeName)))
        return null;

    const {
        arrowKeyOptions = 'both',
        attributeName = '[data-reka-collection-item]',
        itemsArray = [],
        loop = true,
        dir = 'ltr',
        preventScroll = true,
        focus = false
    } = options;

    const [right, left, up, down, home, end] = [
        e.key === 'ArrowRight',
        e.key === 'ArrowLeft',
        e.key === 'ArrowUp',
        e.key === 'ArrowDown',
        e.key === 'Home',
        e.key === 'End'
    ];
    const goingVertical = up || down;
    const goingHorizontal = right || left;
    if (
        !home &&
        !end &&
        ((!goingVertical && !goingHorizontal) ||
            (arrowKeyOptions === 'vertical' && goingHorizontal) ||
            (arrowKeyOptions === 'horizontal' && goingVertical))
    ) {
        return null;
    }

    const allCollectionItems: HTMLElement[] = parentElement
        ? Array.from(parentElement.querySelectorAll(attributeName))
        : itemsArray;

    if (!allCollectionItems.length) return null;

    if (preventScroll) e.preventDefault();

    let item: HTMLElement | null = null;

    if (goingHorizontal || goingVertical) {
        const goForward = goingVertical ? down : dir === 'ltr' ? right : left;
        item = findNextFocusableElement(allCollectionItems, currentElement, {
            goForward,
            loop
        });
    } else if (home) {
        item = allCollectionItems.length ? allCollectionItems[0] : null;
    } else if (end) {
        item = allCollectionItems.length ? allCollectionItems[allCollectionItems.length - 1] : null;
    }

    if (focus) item?.focus();

    return item;
}

interface FindNextFocusableElementOptions {
    /**
     * Whether to search forwards or backwards.
     */
    goForward: boolean;
    /**
     * Whether to allow looping the search. If false, it will stop at the first/last element.
     *
     * @default true
     */
    loop?: boolean;
}

/**
 * Recursive function to find the next focusable element to avoid disabled elements
 *
 * @param elements Elements to navigate
 * @param currentElement Current active element
 * @param options
 * @returns next focusable element
 */
function findNextFocusableElement(
    elements: HTMLElement[],
    currentElement: HTMLElement,
    options: FindNextFocusableElementOptions,
    iterations = elements.length
): HTMLElement | null {
    if (--iterations === 0) return null;

    const index = elements.indexOf(currentElement);
    const newIndex = options.goForward ? index + 1 : index - 1;

    if (!options.loop && (newIndex < 0 || newIndex >= elements.length)) return null;

    const adjustedNewIndex = (newIndex + elements.length) % elements.length;
    const candidate = elements[adjustedNewIndex];
    if (!candidate) return null;

    const isDisabled = candidate.hasAttribute('disabled') && candidate.getAttribute('disabled') !== 'false';
    if (isDisabled) {
        return findNextFocusableElement(elements, candidate, options, iterations);
    }
    return candidate;
}

</document_content>
</document>
</documents>
